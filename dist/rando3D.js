require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function () {
    'use strict';

    var BABYLON = require('babylonjs');
    require('EasePack');
    require('TweenLite');
    require('TimelineLite');
    require('BezierPlugin');
    require('DirectionalRotationPlugin');

    function Rando3D() {

        var RANDO = RANDO || {};

        require('./modules/settings')(RANDO, BABYLON);
        require('./modules/dem')(RANDO, BABYLON);
        require('./modules/events')(RANDO);
        require('./modules/poi')(RANDO, BABYLON);
        require('./modules/scene')(RANDO, BABYLON);
        require('./modules/tile-container')(RANDO);
        require('./modules/trek')(RANDO, BABYLON);
        require('./modules/utils')(RANDO, BABYLON);
        require('./modules/cameras/camera-computer')(RANDO, BABYLON);
        require('./modules/cameras/camera-container')(RANDO, BABYLON);
        require('./modules/cameras/bird-camera')(RANDO, BABYLON);
        require('./modules/cameras/examine-camera')(RANDO, BABYLON);
        require('./modules/cameras/hiker-camera')(RANDO, BABYLON);

        function init(customSettings, canvas, cameraID) {

            jQuery.each(customSettings, function (settingName, settingValue) {
                RANDO.SETTINGS[settingName] = settingValue;
            });

            RANDO.START_TIME = Date.now();

            var scene = new RANDO.Scene(canvas, cameraID);

            return scene;
        }

        return {
            init: init
        };

    }

    if (window) {
        window.Rando3D = Rando3D;
    }
})();
},{"./modules/cameras/bird-camera":2,"./modules/cameras/camera-computer":3,"./modules/cameras/camera-container":4,"./modules/cameras/examine-camera":5,"./modules/cameras/hiker-camera":6,"./modules/dem":7,"./modules/events":8,"./modules/poi":9,"./modules/scene":10,"./modules/settings":11,"./modules/tile-container":12,"./modules/trek":13,"./modules/utils":14,"BezierPlugin":"BezierPlugin","DirectionalRotationPlugin":"DirectionalRotationPlugin","EasePack":"EasePack","TimelineLite":"TimelineLite","TweenLite":"TweenLite","babylonjs":"babylonjs"}],2:[function(require,module,exports){
/*******************************************************************************
 * Rando.BirdCamera.js
 *
 * BirdCamera class :
 *  It is a camera which look like the FreeCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  The differences are :
 *      - permites to translate it of world's X and Z axis instead of
 *  locale's one.
 *      - there is a wheel zoom.
 *
 *  It gives the impression of flying. That's why it is called BirdCamera
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.BirdCamera = function (name, position, scene) {
        BABYLON.Camera.call(this, name, position, scene);

        this.moveDirection = new BABYLON.Vector3(0, 0, 0);
        this.rotationDirection = new BABYLON.Vector2(0, 0);
        this.zoomDirection = new BABYLON.Vector3(0, 0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);
        this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

        this._keys = [];
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];

        // Collisions
        this._collider = new BABYLON.Collider();
        this._needMoveForGravity = true;

        // Internals
        this._currentTarget = BABYLON.Vector3.Zero();
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._camMatrix = BABYLON.Matrix.Zero();
        this._cameraTransformMatrix = BABYLON.Matrix.Zero();
        this._cameraRotationMatrix = BABYLON.Matrix.Zero();
        this._referencePoint = BABYLON.Vector3.Zero();
        this._transformedReferencePoint = BABYLON.Vector3.Zero();
        this._oldPosition = BABYLON.Vector3.Zero();
        this._diffPosition = BABYLON.Vector3.Zero();
        this._newPosition = BABYLON.Vector3.Zero();
        this._lookAtTemp = BABYLON.Matrix.Zero();
        this._tempMatrix = BABYLON.Matrix.Zero();
        this._positionAfterZoom = BABYLON.Vector3.Zero();
    };

    RANDO.BirdCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.BirdCamera.prototype.speed = 2.0;
    RANDO.BirdCamera.prototype.checkCollisions = false;
    RANDO.BirdCamera.prototype.applyGravity = false;
    RANDO.BirdCamera.prototype.noRotationConstraint = false;
    RANDO.BirdCamera.prototype.angularSensibility = 2000.0;
    RANDO.BirdCamera.prototype.lockedTarget = null;
    RANDO.BirdCamera.prototype.onCollide = null;
    RANDO.BirdCamera.prototype.wheelPrecision = 0.3;
    RANDO.BirdCamera.prototype.inertialRadiusOffset = 0;
    RANDO.BirdCamera.prototype.lowerRadiusLimit = null;
    RANDO.BirdCamera.prototype.upperRadiusLimit = null;

    RANDO.BirdCamera.prototype._getLockedTargetPosition = function () {
        if (!this.lockedTarget) {
            return null;
        }

        return this.lockedTarget.position || this.lockedTarget;
    };

    // Cache
    RANDO.BirdCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.lockedTarget = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };

    RANDO.BirdCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass)
            BABYLON.Camera.prototype._updateCache.call(this);

        var lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
            this._cache.lockedTarget = null;
        }
        else {
            if (!this._cache.lockedTarget) {
                this._cache.lockedTarget = lockedTargetPosition.clone();
            }
            else {
                this._cache.lockedTarget.copyFrom(lockedTargetPosition);
            }
        }

        this._cache.rotation.copyFrom(this.rotation);
    };

    // Synchronized
    RANDO.BirdCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this)) {
            return false;
        }

        var lockedTargetPosition = this._getLockedTargetPosition();

        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)
            && this._cache.rotation.equals(this.rotation);
    };

    // Methods
    RANDO.BirdCamera.prototype._computeLocalCameraSpeed = function () {
        return this.speed * ((BABYLON.Tools.GetDeltaTime() / (BABYLON.Tools.GetFps() * 10.0)));
    };

    // Target
    RANDO.BirdCamera.prototype.setTarget = function (target) {
        this.upVector.normalize();

        BABYLON.Matrix.LookAtLHToRef(this.position, target, this.upVector, this._camMatrix);
        this._camMatrix.invert();

        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);

        var vDir = target.subtract(this.position);

        if (vDir.x >= 0.0) {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);
        } else {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);
        }

        this.rotation.z = -Math.acos(BABYLON.Vector3.Dot(new BABYLON.Vector3(0, 1.0, 0), this.upVector));

        if (isNaN(this.rotation.x)) {
            this.rotation.x = 0;
        }

        if (isNaN(this.rotation.y)) {
            this.rotation.y = 0;
        }

        if (isNaN(this.rotation.z)) {
            this.rotation.z = 0;
        }
    };

    RANDO.BirdCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    // Controls
    RANDO.BirdCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var engine = this._scene.getEngine();

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        if (this._onMouseDown === undefined) {
            this._onMouseDown = function (evt) {
                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseUp = function (evt) {
                previousPosition = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseOut = function (evt) {
                previousPosition = null;
                that._keys = [];
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!previousPosition && !engine.isPointerLock) {
                    return;
                }

                var offsetX;
                var offsetY;

                if (!engine.isPointerLock) {
                    offsetX = evt.clientX - previousPosition.x;
                    offsetY = evt.clientY - previousPosition.y;
                } else {
                    offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                    offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
                }

                that.rotationDirection.y += offsetX / that.angularSensibility;
                that.rotationDirection.x += offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onWheel = function (event) {
                var delta = 0;
                if (event.wheelDelta) {
                    delta = event.wheelDelta / (that.wheelPrecision * 40);
                } else if (event.detail) {
                    delta = -event.detail / that.wheelPrecision;
                }

                if (delta)
                    that.inertialRadiusOffset += delta;

                if (event.preventDefault) {
                    if (!noPreventDefault) {
                        event.preventDefault();
                    }
                }
            };

            this._onKeyDown = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index === -1) {
                        that._keys.push(evt.keyCode);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            };

            this._onKeyUp = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index >= 0) {
                        that._keys.splice(index, 1);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
            };

            this._reset = function () {
                that._keys = [];
                previousPosition = null;
                that.moveDirection = new BABYLON.Vector3(0, 0, 0);
                that.rotationDirection = new BABYLON.Vector2(0, 0);
                that.zoomDirection = new BABYLON.Vector3(0, 0, 0);
            };
        }

        element.addEventListener("mousedown", this._onMouseDown, false);
        element.addEventListener("mouseup", this._onMouseUp, false);
        element.addEventListener("mouseout", this._onMouseOut, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener('mousewheel', this._onWheel, false);
        element.addEventListener('DOMMouseScroll', this._onWheel, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.BirdCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener("mousedown", this._onMouseDown);
        element.removeEventListener("mouseup", this._onMouseUp);
        element.removeEventListener("mouseout", this._onMouseOut);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener('mousewheel', this._onWheel);
        element.removeEventListener('DOMMouseScroll', this._onWheel);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._attachedElement = null;
        if (this._reset) {
            this._reset();
        }
    };

    RANDO.BirdCamera.prototype._collideWithWorld = function (velocity) {
        var globalPosition;

        if (this.parent) {
            globalPosition = BABYLON.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
            globalPosition = this.position;
        }

        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._collider.radius = this.ellipsoid;

        this.getScene()._getNewPosition(this._oldPosition, velocity, this._collider, 3, this._newPosition);
        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);

        if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
            this.position.addInPlace(this._diffPosition);
            if (this.onCollide) {
                this.onCollide(this._collider.collidedMesh);
            }
        }
    };

    RANDO.BirdCamera.prototype._checkInputs = function () {
        if (!this._localDirection) {
            this._localDirection = BABYLON.Vector3.Zero();
            this._transformedDirection = BABYLON.Vector3.Zero();
        }

        // Moves with the keyboard
        for (var index = 0; index < this._keys.length; index++) {
            var keyCode = this._keys[index];
            var speed = this._computeLocalCameraSpeed();

            if (this.keysLeft.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(0, 0, -speed);
            }

            this._cameraTransformMatrix = BABYLON.Matrix.RotationY(this.rotation.y);
            BABYLON.Vector3.TransformNormalToRef(
                this._localDirection,
                this._cameraTransformMatrix,
                this._transformedDirection
            );
            this.moveDirection.addInPlace(this._transformedDirection);
        }

        // Mouse wheel zoom
        if (this.inertialRadiusOffset) {
            BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

            this.getViewMatrix().invertToRef(this._cameraTransformMatrix);
            BABYLON.Vector3.TransformNormalToRef(
                this._referencePoint,
                this._cameraTransformMatrix,
                this.zoomDirection
            );

            this.zoomDirection.scaleInPlace(this.inertialRadiusOffset);
        }
    };

    RANDO.BirdCamera.prototype._update = function () {
        this._checkInputs();

        var needToMove = (
            this._needMoveForGravity ||
            Math.abs(this.moveDirection.x) > 0 ||
            Math.abs(this.moveDirection.y) > 0 ||
            Math.abs(this.moveDirection.z) > 0
        );
        var needToRotate = (
            Math.abs(this.rotationDirection.x) > 0 ||
            Math.abs(this.rotationDirection.y) > 0
        );
        var needToZoom = (
            Math.abs(this.zoomDirection.x) > 0 ||
            Math.abs(this.zoomDirection.y) > 0 ||
            Math.abs(this.zoomDirection.z) > 0
        );
        var needCollisions = this.checkCollisions && this._scene.collisionsEnabled;

        // Rotate
        if (needToRotate) {
            this.rotation.x += this.rotationDirection.x;
            this.rotation.y += this.rotationDirection.y;

            if (!this.noRotationConstraint) {
                var limit = (Math.PI / 2) * 0.95;

                if (this.rotation.x > limit)
                    this.rotation.x = limit;
                if (this.rotation.x < -limit)
                    this.rotation.x = -limit;
            }
        }

        // Moves and collisions
        if (needToZoom && needToMove) {
            if (needCollisions) {
                this._collideWithWorld(this.zoomDirection.add(this.moveDirection));
            } else {
                this.position.addInPlace(this.zoomDirection.add(this.moveDirection));
            }
        } else if (needToZoom) {
            if (needCollisions) {
                this._collideWithWorld(this.zoomDirection);
            } else {
                this.position.addInPlace(this.zoomDirection);
            }
        } else if (needToMove) {
            if (needCollisions) {
                this._collideWithWorld(this.moveDirection);
            } else {
                this.position.addInPlace(this.moveDirection);
            }
        }

        // Inertia
        if (needToMove) {
            if (Math.abs(this.moveDirection.x) < BABYLON.Engine.epsilon)
                this.moveDirection.x = 0;

            if (Math.abs(this.moveDirection.y) < BABYLON.Engine.epsilon)
                this.moveDirection.y = 0;

            if (Math.abs(this.moveDirection.z) < BABYLON.Engine.epsilon)
                this.moveDirection.z = 0;

            this.moveDirection.scaleInPlace(this.inertia);
        }
        if (needToRotate) {
            if (Math.abs(this.rotationDirection.x) < BABYLON.Engine.epsilon)
                this.rotationDirection.x = 0;

            if (Math.abs(this.rotationDirection.y) < BABYLON.Engine.epsilon)
                this.rotationDirection.y = 0;

            this.rotationDirection.scaleInPlace(this.inertia);
        }
        if (needToZoom) {
            if (Math.abs(this.inertialRadiusOffset) < BABYLON.Engine.epsilon)
                this.inertialRadiusOffset = 0;

            this.inertialRadiusOffset *= this.inertia;
        }
    };


    RANDO.BirdCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    RANDO.BirdCamera.prototype._getViewMatrix = function () {
        BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

        if (!this.lockedTarget) {
            // Compute
            if (this.upVector.x != 0 || this.upVector.y != 1.0 || this.upVector.z != 0) {
                BABYLON.Matrix.LookAtLHToRef(BABYLON.Vector3.Zero(), this._referencePoint, this.upVector, this._lookAtTemp);
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);

                this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix, this._tempMatrix);
                this._lookAtTemp.invert();
                this._tempMatrix.multiplyToRef(this._lookAtTemp, this._cameraRotationMatrix);
            } else {
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
            }

            BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);

            // Computing target and final matrix
            this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        } else {
            this._currentTarget.copyFrom(this._getLockedTargetPosition());
        }

        BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);
        return this._viewMatrix;
    };
};
},{}],3:[function(require,module,exports){
/*******************************************************************************
 * Rando.CameraComputer.js
 *
 * CameraComputer class :
 *  Used to separate calculations from the CameraContainer
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.CameraComputer = function (center, extent, altitudes, offsets, scene, number) {
        this._center        = {
            'x' : center.x + offsets.x,
            'y' : center.y,
            'z' : center.z + offsets.z
        };
        this._totalExtent   = {
            'x' : {
                'min' : extent.x.min + offsets.x,
                'max' : extent.x.max + offsets.x
            },
            'y' : {
                'min' : extent.y.min,
                'max' : extent.y.max
            },
            'z' : {
                'min' : extent.z.min + offsets.z,
                'max' : extent.z.max + offsets.z
            }
        };
        this._scene = scene;
        this._altitudes = altitudes;
        this._squares   = [];
        this._alphaSquare = null;
        this._number = number || 5;
    };

    /* Methods */
    RANDO.CameraComputer.prototype.computeInitialPositionToRef = function (initialPosition) {
        this._generateSquares ();
        this._findAlphaSquare ();
        this._setPositionToRef (initialPosition);
        //~ this._buildSquareViewer();
    };

    RANDO.CameraComputer.prototype.computeInitialTargetToRef = function (initialTarget) {
        initialTarget.x = this._center.x;
        initialTarget.y = 0;
        initialTarget.z = this._center.z;
    };

    RANDO.CameraComputer.prototype.computeLimitsToRef = function (limits) {
        limits.lowerX = this._totalExtent.x.min;
        limits.upperX = this._totalExtent.x.max;
        limits.lowerZ = this._totalExtent.z.min;
        limits.upperZ = this._totalExtent.z.max;

        limits.lowerRadius = RANDO.SETTINGS.MIN_THICKNESS + this._center.y;
        limits.upperRadius = 8000;
    };


    RANDO.CameraComputer.prototype._generateSquares = function () {
        // Fill square's extents (needed to determine indices)
        var squareGrid = RANDO.Utils.createFlatGrid(
            {
                'x' : this._totalExtent.x.min,
                'y' : this._totalExtent.z.min
            },
            {
                'x' : this._totalExtent.x.max,
                'y' : this._totalExtent.z.min
            },
            {
                'x' : this._totalExtent.x.max,
                'y' : this._totalExtent.z.max
            },
            {
                'x' : this._totalExtent.x.min,
                'y' : this._totalExtent.z.max
            },
            this._number+1,
            this._number+1
        );
        this._fillExtents (squareGrid);

        // Fill square's types
        this._fillTypes ();

        // Fill square's indices
        var elevatedPoints = RANDO.Utils.createElevationGrid (
            this._totalExtent.x.min,
            this._totalExtent.x.max,
            this._totalExtent.z.min,
            this._totalExtent.z.max,
            this._altitudes
        );
        this._fillIndices (elevatedPoints);

        // Fill square's neighborhood
        this._fillNeighborhood ();
    };

    /**
     * RANDO.CameraComputer._fillExtents() : Fill the extent property of all squares
     *  - grid : a flat grid containing points of squares
     */
    RANDO.CameraComputer.prototype._fillExtents = function (grid) {
        for (var row = 0 ; row < grid.length-1 ; row++) {
            for (var col = 0 ; col < grid[row].length-1 ; col++) {
                this._squares.push ({
                    'extent' : {
                        'x' : {
                            'min' : grid[row][col].x,
                            'max' : grid[row+1][col+1].x
                        },
                        'z' : {
                            'min' : grid[row][col].y,
                            'max' : grid[row+1][col+1].y
                        }
                    }
                });
            }
        }
    };

    /**
     * RANDO.CameraComputer._fillTypes() : Fill the type property of all squares
     */
    RANDO.CameraComputer.prototype._fillTypes = function () {
        // CORNER types
        this._squares[0].type = "CORNER"; // left-down corner
        this._squares[this._number - 1].type = "CORNER"; // right-down corner
        this._squares[(this._number - 1) * this._number].type = "CORNER"; // left-up corner
        this._squares[(this._number * this._number) - 1].type = "CORNER"; // right-up corner

        // Extern BORDER types
        for (var i = 1; i < this._number - 1; i++) {
            this._squares[i].type = "EXTBORDER"; // down border
            this._squares[(this._number - 1) * this._number + i].type = "EXTBORDER"; // top border
            this._squares[this._number * i].type = "EXTBORDER"; // left border
            this._squares[this._number * i + this._number -1].type = "EXTBORDER";// right border
        }

        // Intern BORDER types
        for (var i = 1; i < this._number - 1; i++) {
            this._squares[i + this._number].type = "INTBORDER";// down internal border
            this._squares[i + this._number + (this._number-3) * this._number].type = "INTBORDER";
            this._squares[i * this._number + 1].type = "INTBORDER";
            this._squares[i * this._number + 1 + (this._number-3)].type = "INTBORDER";
        };

        // BLACK types
        for (var it in this._squares) {
            if (!this._squares[it].type) this._squares[it].type = "BLACK";
        }
    };

    /**
     * RANDO.CameraComputer._fillIndices() : Fill the index property of all squares
     *  - elevatedPoints : a two-array of all 3D points of the DEM
     *
     * NB : It needs to have already computed the extent and the type of each square
     */
    RANDO.CameraComputer.prototype._fillIndices = function (elevatedPoints) {
        // Increment indices of squares with elevated points which are inside
        for (var row = 0; row < elevatedPoints.length; row++) {
            for (var col = 0; col < elevatedPoints[row].length; col++) {
                var position = elevatedPoints[row][col];
                for (var it in this._squares) {
                    var square = this._squares[it];
                    if (square.type != "BLACK" && RANDO.Utils.isInExtent(position, square.extent)) {
                        if (square.index) {
                            square.index += position.y;
                            square.nb_alt++;
                        } else {
                            square.index = position.y;
                            square.nb_alt = 1;
                        }
                    }
                }
            }
        }

        // Create an index between 0 and 10 which represents the elevation's average of a square
        for (var it in this._squares) {
            var square = this._squares[it];
            square.index = square.index / square.nb_alt;
            square.index = square.index * 10 / (this._totalExtent.y.max  - this._totalExtent.y.min);
            if (square.type == "BLACK") {
                square.index = -1;
            }
        }
    };

    /**
     * RANDO.CameraComputer._fillNeighborhood() : Fill the neighborhood property of squares
     * which are of CORNER or EXTBORDER types
     *
     * ****************************************
     * The neighborhood contains all neighbours of a square following this schedule :
     *
     *          CORNER :
     *      |
     *      n
     *      n n
     *      s n n _
     *
     *          EXTBORDER :
     *      n n n
     *    _ n s n _
     *
     * With
     *  s = square we want to get its neighbours
     *  n = neighbours of the square
     *
     * ****************************************
     * NB : - The square will be counted in its neighborhood
     *      - It needs to have already computed the index of each square
     */
    RANDO.CameraComputer.prototype._fillNeighborhood = function () {
        var dx, dy, t_dx, t_dy = [-this._number, this._number];

        for (var curr = 0; curr < this._squares.length; curr++) {
            var square = this._squares[curr];

            if (square.type == "CORNER") {
                square.neighborhood = [];
                if (curr%this._number == 0) {
                    dx = 1;
                }
                else {
                    dx = -1;
                }
                if (this._squares[curr + this._number]) {
                    dy = this._number;
                }
                else {
                    dy = -this._number;
                }
                square.neighborhood.push(curr);
                square.neighborhood.push(curr + dx);
                square.neighborhood.push(curr + 2 * dx);
                square.neighborhood.push(curr + dy);
                square.neighborhood.push(curr + 2 * dy);
                square.neighborhood.push(curr + dx + dy);
            }
            else if (square.type == "EXTBORDER") {
                square.neighborhood = [];
                if (curr%this._number == 0) {
                    t_dx = [0, 1];
                }
                else if (curr%this._number == this._number -1) {
                    t_dx = [-1, 0];
                }
                else {
                    t_dx = [-1, 0, 1];
                }
                for (var i in t_dx) {
                    square.neighborhood.push (curr + t_dx[i]);
                    for (var j in t_dy) {
                        if (this._squares[curr + t_dy[j]]) {
                            square.neighborhood.push (curr + t_dx[i] + t_dy[j]);
                        }
                    }
                }
            }
            else {
                square.neighborhood = [];
            }
        }
    };

    /**
     * RANDO.CameraComputer._findAlphaSquare() : Find the Alpha Square
     *  The alpha square is the square which have the neighborhood with the lowest indices values
     */
    RANDO.CameraComputer.prototype._findAlphaSquare = function () {
        var that = this;
        this._alphaSquare = _.min(this._squares, function (square) {
            var result = 0;
            if (!square.neighborhood.length) {
                return Infinity;
            }
            for (var it in square.neighborhood) {
                result += that._squares[square.neighborhood[it]].index;
            }
            return result;
        });
    };

    /**
     * RANDO.CameraComputer._setPositionToRef() : set the position given in parameter
     *  according to the alpha square position
     *
     *  - result : reference to the position to change
     */
    RANDO.CameraComputer.prototype._setPositionToRef = function (result) {
        // Alpha position : elevation do not matter
        var A = new BABYLON.Vector3(
            (this._alphaSquare.extent.x.max + this._alphaSquare.extent.x.min) /2,
            0,
            (this._alphaSquare.extent.z.max + this._alphaSquare.extent.z.min) /2
        );

        // Center position
        var O = new BABYLON.Vector3(
            this._center.x,
            this._center.y,
            this._center.z
        );

        var scale = 2.5;
        var OC = A.subtract(O).scale(scale);

        // Camera position
        var C = OC.add(O);
        result.x = C.x;
        result.y = this._center.y + (this._totalExtent.y.max - this._totalExtent.y.min);
        result.z = C.z;
    };

    /**
     * RANDO.CameraComputer._buildSquareViewer() : build a viewer which materialize
     *  differents squares in spheres of color
     *
     *  CORNER squares are green
     *  Extern BORDER squares are blue
     *  Intern BORDER squares are orange
     *  Intern squares are black
     *  Alpha Square is red
     */
    RANDO.CameraComputer.prototype._buildSquareViewer = function () {
        for (var it in this._squares) {
            var sphere = BABYLON.Mesh.CreateSphere(
                "Square " + it,
                10, 100,
                this._scene
            );

            sphere.position.x = (this._squares[it].extent.x.min + this._squares[it].extent.x.max) /2;
            sphere.position.y = this._totalExtent.y.max;
            sphere.position.z = (this._squares[it].extent.z.min + this._squares[it].extent.z.max) /2;
            sphere.material = new BABYLON.StandardMaterial("Square " + it + " - Material", this._scene);
            if (this._alphaSquare == this._squares[it]) {
                sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            }
            else if (this._squares[it].type == "CORNER") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
            }
            else if (this._squares[it].type == "EXTBORDER") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 1, 1);
            }
            else if (this._squares[it].type == "INTBORDER") {
                sphere.material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
            }
            else if (this._squares[it].type == "BLACK") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            }
        }

        var sphere = BABYLON.Mesh.CreateSphere("Center", 10, 100, this._scene);
        sphere.position.x = this._center.x;
        sphere.position.y = this._totalExtent.y.max;
        sphere.position.z = this._center.z;
    };
};
},{}],4:[function(require,module,exports){
/*******************************************************************************
 * Rando.CameraContainer.js
 *
 * CameraContainer class :
 *  A container which will contains all cameras of the scene
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.CameraContainer = function (canvas, scene, params) {
        this._canvas = canvas;
        this._scene = scene;
        this._switchEnabled = params.switchEnabled || false;

        this._computer = new RANDO.CameraComputer (
            params.demCenter,
            params.demExtent,
            params.demAltitudes,
            params.offsets || BABYLON.Vector3.Zero(),
            scene,
            6
        );

        this.cameras = {};

        this._animationPath = null;
        this._controlsAttached  = false;
        this._positionBeforeSwitch = null;
        this._targetBeforeSwitch = null;

        this.initialPosition = BABYLON.Vector3.Zero();
        this.initialTarget = BABYLON.Vector3.Zero();
        this.limits = {
            'lowerX'        : null,
            'upperX'        : null,
            'lowerZ'        : null,
            'upperZ'        : null,
            'lowerRadius'   : null,
            'upperRadius'   : null
        };

        this.init();
    };

    // Static Array defining possibles cameras IDs
    RANDO.CameraIDs = ["examine", "bird", "hiker"];

    /* Methods */
    RANDO.CameraContainer.prototype.init = function () {
        this._computeInitialParameters ();
        this._buildBirdCamera ();
        this._buildExamineCamera ();
        this._buildHikerCamera ();
        this._initInterface();
        this._cameraSwitcher ();
    };

    /**
     * RANDO.CameraContainer._buildExamineCamera() : build of the Examine camera
     */
    RANDO.CameraContainer.prototype._buildExamineCamera = function () {
        var examine_camera = new RANDO.ExamineCamera(
            "Examine Camera",0, 0, 0,
            this.initialTarget,
            this._scene
        );
        examine_camera.id = "examine";
        examine_camera.keysUp     = [90, 38]; // Touche Z and up
        examine_camera.keysDown   = [83, 40]; // Touche S and down
        examine_camera.keysLeft   = [81, 37]; // Touche Q and left
        examine_camera.keysRight  = [68, 39]; // Touche D and right

        examine_camera.wheelPrecision = 0.2;
        examine_camera.checkCollisions = true;
        examine_camera.ellipsoid.y = RANDO.SETTINGS.COLLISIONS_OFFSET;
        examine_camera.maxZ = 50000;
        examine_camera.speed = RANDO.SETTINGS.CAM_SPEED_F ;

        examine_camera.lowerXLimit = this.limits.lowerX;
        examine_camera.lowerZLimit = this.limits.lowerZ;
        examine_camera.upperXLimit = this.limits.upperX;
        examine_camera.upperZLimit = this.limits.upperZ;
        examine_camera.upperBetaLimit = Math.PI/2;

        this.cameras.examine = examine_camera;
    };

    /**
     * RANDO.CameraContainer._buildBirdCamera() : build of the Bird camera
     */
    RANDO.CameraContainer.prototype._buildBirdCamera = function () {
        var bird_camera = new RANDO.BirdCamera(
            "Bird Camera",
            BABYLON.Vector3.Zero(),
            this._scene
        );
        bird_camera.id = "bird";
        bird_camera.keysUp     = [90, 38]; // Touche Z and up
        bird_camera.keysDown   = [83, 40]; // Touche S and down
        bird_camera.keysLeft   = [81, 37]; // Touche Q and left
        bird_camera.keysRight  = [68, 39]; // Touche D and right

        bird_camera.checkCollisions = true;
        bird_camera.ellipsoid.y = RANDO.SETTINGS.COLLISIONS_OFFSET;
        bird_camera.maxZ = 50000;
        bird_camera.speed = RANDO.SETTINGS.CAM_SPEED_F ;

        this.cameras.bird = bird_camera;
    };

    /**
     * RANDO.CameraContainer._buildHikerCamera() : build of the Hiker camera
     */
    RANDO.CameraContainer.prototype._buildHikerCamera = function () {
        var hiker_camera = new RANDO.HikerCamera(
            "Hiker Camera",
            BABYLON.Vector3.Zero(),
            this._scene
        );
        hiker_camera.id = "hiker";

        hiker_camera.checkCollisions = true;
        hiker_camera.maxZ = 50000;

        hiker_camera.returnSpeed = RANDO.SETTINGS.HCAM_RETURN_SPEED;
        hiker_camera.followSpeed = RANDO.SETTINGS.HCAM_FOLLOW_SPEED;


        this.cameras.hiker = hiker_camera;
    };

    /**
     * RANDO.CameraContainer.setActiveCamera() : set the active camera of the scene
     *      - newID: ID of the camera we want to set as active
     *
     * NB : newID should be in the static array RANDO.cameraIDs
     */
    RANDO.CameraContainer.prototype.setActiveCamera = function (newID) {
        if (RANDO.CameraIDs.indexOf(newID) == -1) {
            console.error("RANDO.CameraContainer.setActiveCamera () : " + newID +
                            " is not an available camera's ID");
            return;
        }

        var oldID = this._scene.activeCamera.id;

        // Record informations of the old camera
        this._recordInfoBeforeSwitch(oldID);

        // Attach & detach controls of cameras
        if (this._controlsAttached) {
            this.cameras[oldID].detachControl();
        }
        this.cameras[newID].attachControl(this._canvas);
        this._controlsAttached = true;

        // Update camera
        this._scene.setActiveCameraByID (newID);
        this._resetByDefault();

        // Interface changes
        jQuery(".controls--" + oldID).css("display", "none");
        jQuery(".camera--"   + oldID).removeClass("camera--selected");
        jQuery(".controls--" + newID).css("display", "block");
        jQuery(".camera--"   + newID).addClass("camera--selected");
    };

    RANDO.CameraContainer.prototype._recordInfoBeforeSwitch = function (oldID) {
        if (oldID == "examine") {
            this._positionBeforeSwitch  = this._scene.activeCamera.position.clone();
            this._targetBeforeSwitch    = this._scene.activeCamera.target.clone();
            this._rotationBeforeSwitch  = null;
        } 
        else if (oldID == "bird" || oldID == "hiker") {
            this._positionBeforeSwitch  = this._scene.activeCamera.position.clone();
            this._rotationBeforeSwitch  = this._scene.activeCamera.rotation.clone();
            this._targetBeforeSwitch    = null;
        }
    };

    RANDO.CameraContainer.prototype.setAnimationPath = function (vertices) {
        this._animationPath = vertices;
        this.cameras.hiker.setPath(vertices);
        this.enableCamera ("hiker");
    };

    RANDO.CameraContainer.prototype._cameraSwitcher = function () {
        var idArray = RANDO.CameraIDs;
        var that = this;

        if (!this._switchEnabled) {
            return;
        }
        else {
             jQuery(".camera_switcher").css("display", "block");
        }

        for (var it in idArray) {
            // The hiker camera must not be active until his path has not been set
            if (idArray[it] != "hiker") {
                this.enableCamera(idArray[it]);
            }

            // Click event
            jQuery(".camera--" + idArray[it]).click({id : idArray[it]}, function (e) {

                if(jQuery(this).hasClass('camera--disabled')) {
                    return;
                }
                else {
                    that.setActiveCamera (e.data.id);
                }
            });
        }
    };

    RANDO.CameraContainer.prototype.enableCamera = function (id) {
        jQuery(".camera--" + id ).removeClass("camera--disabled");
        jQuery(".camera--" + id ).addClass("camera--enabled");
        jQuery(".camera--" + id + " img").attr("src", RANDO.SETTINGS.IMAGES_FOLDER + id + "_camera.png");
    };

    RANDO.CameraContainer.prototype._resetByDefault = function () {
        var activeCam = this._scene.activeCamera;

        // Examine Camera
        if (activeCam.id == "examine") {
            activeCam.setPosition(this.initialPosition.clone());
            activeCam.target = this.initialTarget.clone();
        }

        // Bird Camera
        else if (activeCam.id == "bird") {
            activeCam.position = this.initialPosition.clone();
            activeCam.setTarget(this.initialTarget.clone());
        }

        // Hiker Camera
        else if (activeCam.id == "hiker" ) {
            if (this._positionBeforeSwitch) {
                activeCam.position = this._positionBeforeSwitch;
            }
            if (this._rotationBeforeSwitch) {
                activeCam.rotation = this._rotationBeforeSwitch;
            }
            if (this._targetBeforeSwitch) {
                activeCam.setTarget(this._targetBeforeSwitch);
            }
        }

        activeCam._reset ();
    };

    RANDO.CameraContainer.prototype._computeInitialParameters = function () {
        this._computer.computeInitialPositionToRef (this.initialPosition);

        this._computer.computeInitialTargetToRef (this.initialTarget);

        this._computer.computeLimitsToRef (this.limits);
    };

    RANDO.CameraContainer.prototype._initInterface = function () {
        for (var it in this.cameras) {
            var id = this.cameras[it].id;
            jQuery(".controls--" + id + " .controls-description")
                .text(RANDO.SETTINGS.CAMERA_MESSAGES[id]);
            jQuery(".camera--"   + id + " .camera-description")
                .text(RANDO.SETTINGS.CAMERA_MESSAGES[id]);
        }
    };
};
},{}],5:[function(require,module,exports){
/*******************************************************************************
 * Rando.ExamineCamera.js
 *
 * ExamineCamera class :
 *  It is a camera which look like the ArcRotateCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  But we can also translate it over world axis X and Z.
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    var eventPrefix = BABYLON.Tools.GetPointerPrefix();

    RANDO.ExamineCamera = function (name, alpha, beta, radius, target, scene) {
        BABYLON.Camera.call(
            this, name, RANDO.ExamineCamera.sphericToCartesian(
                alpha,
                beta,
                radius,
                target
            ), scene
        );

        this.alpha = alpha;
        this.beta = beta;
        this.radius = radius;
        this.target = target;

        this._keys = [];
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];

        // Collisions
        this._collider = new BABYLON.Collider();
        this._needMoveForGravity = true;

        this.cameraDirection = new BABYLON.Vector3(0, 0, 0);
        this.cameraRotation = new BABYLON.Vector2(0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);
        this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

        // Internals
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._cameraTransformMatrix = BABYLON.Matrix.Zero();
        this._oldPosition = BABYLON.Vector3.Zero();
        this._diffPosition = BABYLON.Vector3.Zero();
        this._newPosition = BABYLON.Vector3.Zero();
    };

    RANDO.ExamineCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.ExamineCamera.prototype.inertialAlphaOffset = 0;
    RANDO.ExamineCamera.prototype.inertialBetaOffset = 0;
    RANDO.ExamineCamera.prototype.inertialRadiusOffset = 0;
    RANDO.ExamineCamera.prototype.lowerAlphaLimit = null;
    RANDO.ExamineCamera.prototype.upperAlphaLimit = null;
    RANDO.ExamineCamera.prototype.lowerBetaLimit = 0.01;
    RANDO.ExamineCamera.prototype.upperBetaLimit = Math.PI;
    RANDO.ExamineCamera.prototype.lowerRadiusLimit = null;
    RANDO.ExamineCamera.prototype.upperRadiusLimit = null;
    RANDO.ExamineCamera.prototype.lowerXLimit = null;
    RANDO.ExamineCamera.prototype.upperXLimit = null;
    RANDO.ExamineCamera.prototype.lowerZLimit = null;
    RANDO.ExamineCamera.prototype.upperZLimit = null;
    RANDO.ExamineCamera.prototype.angularSensibility = 1000.0;
    RANDO.ExamineCamera.prototype.wheelPrecision = 3.0;

    RANDO.ExamineCamera.prototype._getTargetPosition = function () {
        return this.target.position || this.target;
    };

    // Cache
    RANDO.ExamineCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.target = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.alpha = undefined;
        this._cache.beta = undefined;
        this._cache.radius = undefined;
    };

    RANDO.ExamineCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass)
            BABYLON.Camera.prototype._updateCache.call(this);

        this._cache.target.copyFrom(this._getTargetPosition());
        this._cache.alpha = this.alpha;
        this._cache.beta = this.beta;
        this._cache.radius = this.radius;
    };

    // Synchronized
    RANDO.ExamineCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this))
            return false;

        return this._cache.target.equals(this._getTargetPosition())
            && this._cache.alpha === this.alpha
            && this._cache.beta === this.beta
            && this._cache.radius === this.radius;
    };

    RANDO.ExamineCamera.prototype._computeLocalCameraSpeed = function () {
        return this.speed * ((BABYLON.Tools.GetDeltaTime() / (BABYLON.Tools.GetFps() * 10.0)));
    };

    RANDO.ExamineCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var pointerId;

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        var engine = this._scene.getEngine();

        if (this._onPointerDown === undefined) {
            this._onPointerDown = function (evt) {

                if (pointerId) {
                    return;
                }

                pointerId = evt.pointerId;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onPointerUp = function (evt) {
                previousPosition = null;
                pointerId = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };


            this._onPointerMove = function (evt) {
                if (!previousPosition) {
                    return;
                }

                if (pointerId !== evt.pointerId) {
                    return;
                }

                var offsetX = evt.clientX - previousPosition.x;
                var offsetY = evt.clientY - previousPosition.y;

                that.inertialAlphaOffset -= offsetX / that.angularSensibility;
                that.inertialBetaOffset -= offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!engine.isPointerLock) {
                    return;
                }

                var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;

                that.inertialAlphaOffset -= offsetX / that.angularSensibility;
                that.inertialBetaOffset -= offsetY / that.angularSensibility;

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._wheel = function (event) {
                var delta = 0;
                if (event.wheelDelta) {
                    delta = event.wheelDelta / (that.wheelPrecision * 40);
                } else if (event.detail) {
                    delta = -event.detail / that.wheelPrecision;
                }

                if (delta)
                    that.inertialRadiusOffset += delta;

                if (event.preventDefault) {
                    if (!noPreventDefault) {
                        event.preventDefault();
                    }
                }
            };

            this._onKeyDown = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index === -1) {
                        that._keys.push(evt.keyCode);
                    }

                    if (evt.preventDefault) {
                        if (!noPreventDefault) {
                            evt.preventDefault();
                        }
                    }
                }
            };

            this._onKeyUp = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index >= 0) {
                        that._keys.splice(index, 1);
                    }

                    if (evt.preventDefault) {
                        if (!noPreventDefault) {
                            evt.preventDefault();
                        }
                    }
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
                pointerId = null;
            };

            this._onGestureStart = function (e) {
                if (window.MSGesture === undefined) {
                    return;
                }

                if (!that._MSGestureHandler) {
                    that._MSGestureHandler = new MSGesture();
                    that._MSGestureHandler.target = canvas;
                }

                that._MSGestureHandler.addPointer(e.pointerId);
            };

            this._onGesture = function (e) {
                that.radius *= e.scale;


                if (e.preventDefault) {
                    if (!noPreventDefault) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
            };

            this._reset = function () {
                that._keys = [];
                that.inertialAlphaOffset = 0;
                that.inertialBetaOffset = 0;
                that.inertialRadiusOffset = 0;
                that.cameraDirection = new BABYLON.Vector3(0, 0, 0);
                previousPosition = null;
                pointerId = null;
            };
        }

        element.addEventListener(eventPrefix + "down", this._onPointerDown, false);
        element.addEventListener(eventPrefix + "up", this._onPointerUp, false);
        element.addEventListener(eventPrefix + "out", this._onPointerUp, false);
        element.addEventListener(eventPrefix + "move", this._onPointerMove, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener("MSPointerDown", this._onGestureStart, false);
        element.addEventListener("MSGestureChange", this._onGesture, false);
        element.addEventListener('mousewheel', this._wheel, false);
        element.addEventListener('DOMMouseScroll', this._wheel, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.ExamineCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener(eventPrefix + "down", this._onPointerDown);
        element.removeEventListener(eventPrefix + "up", this._onPointerUp);
        element.removeEventListener(eventPrefix + "out", this._onPointerUp);
        element.removeEventListener(eventPrefix + "move", this._onPointerMove);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener("MSPointerDown", this._onGestureStart);
        element.removeEventListener("MSGestureChange", this._onGesture);
        element.removeEventListener('mousewheel', this._wheel);
        element.removeEventListener('DOMMouseScroll', this._wheel);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._MSGestureHandler = null;
        this._attachedElement = null;

        if (this._reset) {
            this._reset();
        }
    };

    RANDO.ExamineCamera.prototype._collideWithWorld = function (velocity) {
        var globalPosition;

        if (this.parent) {
            globalPosition = BABYLON.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
            globalPosition = this.position;
        }

        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._collider.radius = this.ellipsoid;

        this.getScene()._getNewPosition(this._oldPosition, velocity, this._collider, 3, this._newPosition);
        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);

        if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
            this.position.addInPlace(this._diffPosition);
            this.setPosition(this.position);
            if (this.onCollide) {
                this.onCollide(this._collider.collidedMesh);
            }
        }
    };

    RANDO.ExamineCamera.prototype._checkInputs = function () {
        if (!this._localDirection) {
            this._localDirection = BABYLON.Vector3.Zero();
            this._transformedDirection = BABYLON.Vector3.Zero();
        }

        // Moves with the Keyboard
        for (var index = 0; index < this._keys.length; index++) {
            var keyCode = this._keys[index];
            var speed = this._computeLocalCameraSpeed();

            if (this.keysLeft.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            }

            this.getViewMatrix().invertToRef(this._cameraTransformMatrix);

            BABYLON.Vector3.TransformNormalToRef(
                this._localDirection,
                this._cameraTransformMatrix,
                this._transformedDirection
            );

            if (this.keysUp.indexOf(keyCode)   !== -1 ||
                this.keysDown.indexOf(keyCode)  !== -1 ) {
                this.cameraDirection.addInPlace(
                    BABYLON.Vector3.TransformNormal(
                        this._transformedDirection,
                        BABYLON.Matrix.RotationY(-Math.PI/2)
                    )
                );
            } else {
                this.cameraDirection.addInPlace(this._transformedDirection);
            }
        }
    };

    RANDO.ExamineCamera.prototype._update = function () {
        this._checkInputs();

        var needToMoveTarget = (
            Math.abs(this.cameraDirection.x) > 0 ||
            Math.abs(this.cameraDirection.y) > 0 ||
            Math.abs(this.cameraDirection.z) > 0
        );

        var needToRotateOrZoom = (
            this.inertialAlphaOffset  != 0 ||
            this.inertialBetaOffset   != 0 ||
            this.inertialRadiusOffset != 0
        );

        var needCollisions = this.checkCollisions && this._scene.collisionsEnabled;

        // Update target
        if (needToMoveTarget) {
            this.target.addInPlace(this.cameraDirection);
        }

        // Update Alpha Beta Radius
        if (needToRotateOrZoom) {
            this.alpha  += this.inertialAlphaOffset;
            this.beta   += this.inertialBetaOffset;
            this.radius -= this.inertialRadiusOffset;
        }

        // Limits
        if (this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit) {
            this.alpha = this.lowerAlphaLimit;
            this.inertialAlphaOffset = 0;
        }
        if (this.upperAlphaLimit && this.alpha > this.upperAlphaLimit) {
            this.alpha = this.upperAlphaLimit;
            this.inertialAlphaOffset = 0;
        }
        if (this.lowerBetaLimit && this.beta < this.lowerBetaLimit) {
            this.beta = this.lowerBetaLimit;
            this.inertialBetaOffset = 0;
        }
        if (this.upperBetaLimit && this.beta > this.upperBetaLimit) {
            this.beta = this.upperBetaLimit;
            this.inertialBetaOffset = 0;
        }
        if (this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit) {
            this.radius = this.lowerRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
        if (this.upperRadiusLimit && this.radius > this.upperRadiusLimit) {
            this.radius = this.upperRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
        if (this.lowerXLimit && this.target.x < this.lowerXLimit) {
            this.target.x = this.lowerXLimit;
            this.cameraDirection.x = 0;
        }
        if (this.upperXLimit && this.target.x > this.upperXLimit) {
            this.target.x = this.upperXLimit;
            this.cameraDirection.x = 0;
        }
        if (this.lowerZLimit && this.target.z < this.lowerZLimit) {
            this.target.z = this.lowerZLimit;
            this.cameraDirection.z = 0;
        }
        if (this.upperZLimit && this.target.z > this.upperZLimit) {
            this.target.z = this.upperZLimit;
            this.cameraDirection.z = 0;
        }

        // Moves and Collisions
        if (needToRotateOrZoom && needToMoveTarget) {
            if (needCollisions) {
                this._collideWithWorld(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                    .add(this.cameraDirection)
                );
            }
            else {
                this.position.addInPlace(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                    .add(this.cameraDirection)
                );
                this.setPosition (this.position);
            }
        }
        else if (needToRotateOrZoom) {
            if (needCollisions) {
                this._collideWithWorld(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                );
            } else {
                this.position.addInPlace(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                );
                this.setPosition (this.position);
            }
        }
        else if (needToMoveTarget) {
            if (needCollisions) {
                this._collideWithWorld(this.cameraDirection);
            } else {
                this.position.addInPlace(this.cameraDirection);
                this.setPosition (this.position);
            }
        }

        // Inertia
        if (needToMoveTarget) {
            if (Math.abs(this.cameraDirection.x) < BABYLON.Engine.Epsilon)
                this.cameraDirection.x = 0;

            if (Math.abs(this.cameraDirection.y) < BABYLON.Engine.Epsilon)
                this.cameraDirection.y = 0;

            if (Math.abs(this.cameraDirection.z) < BABYLON.Engine.Epsilon)
                this.cameraDirection.z = 0;

            this.cameraDirection.scaleInPlace(this.inertia);
        }

        if (needToRotateOrZoom) {
            if (Math.abs(this.inertialAlphaOffset) < BABYLON.Engine.Epsilon)
                this.inertialAlphaOffset = 0;

            if (Math.abs(this.inertialBetaOffset) < BABYLON.Engine.Epsilon)
                this.inertialBetaOffset = 0;

            if (Math.abs(this.inertialRadiusOffset) < BABYLON.Engine.Epsilon)
                this.inertialRadiusOffset = 0;

            this.inertialAlphaOffset    *= this.inertia;
            this.inertialBetaOffset     *= this.inertia;
            this.inertialRadiusOffset   *= this.inertia;
        }
    };

    RANDO.ExamineCamera.prototype.setPosition = function (position) {
        this.position = position;
        var radiusv3 = position.subtract(this._getTargetPosition());
        this.radius = radiusv3.length();

        this.alpha = Math.acos(radiusv3.x / Math.sqrt(
            Math.pow(radiusv3.x, 2) +
            Math.pow(radiusv3.z, 2)
        ));
        if (radiusv3.z < 0) {
            this.alpha = 2 * Math.PI - this.alpha;
        }
        this.beta = Math.acos(radiusv3.y / this.radius);
    };

    RANDO.ExamineCamera.prototype._getViewMatrix = function () {
        BABYLON.Matrix.LookAtLHToRef(
            this.position,
            this.target,
            this.upVector,
            this._viewMatrix
        );

        return this._viewMatrix;
    };

    RANDO.ExamineCamera.ZOOM_ON_FACTOR = 1;
    RANDO.ExamineCamera.prototype.zoomOn = function (meshes) {
        meshes = meshes || this._scene.meshes;

        var minMaxVector = BABYLON.Mesh.MinMax(meshes);
        var distance = BABYLON.Vector3.Distance(minMaxVector.min, minMaxVector.max);

        this.radius = distance * RANDO.ExamineCamera.ZOOM_ON_FACTOR;

        this.focusOn({min: minMaxVector.min, max: minMaxVector.max, distance: distance});
    };

    RANDO.ExamineCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance) {
        var meshesOrMinMaxVector;
        var distance;

        if (meshesOrMinMaxVectorAndDistance.min === undefined) { // meshes
            meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance || this._scene.meshes;
            meshesOrMinMaxVector = BABYLON.Mesh.MinMax(meshesOrMinMaxVector);
            distance = BABYLON.Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
        }
        else { //minMaxVector and distance
            meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance;
            distance = meshesOrMinMaxVectorAndDistance.distance;
        }

        this.target = BABYLON.Mesh.Center(meshesOrMinMaxVector);

        this.maxZ = distance * 2;
    };

    // Static
    RANDO.ExamineCamera.sphericToCartesian = function (alpha, beta, radius, center) {
        var cosa = Math.cos(alpha);
        var sina = Math.sin(alpha);
        var cosb = Math.cos(beta);
        var sinb = Math.sin(beta);

        center = center || BABYLON.Vector3.Zero();
        return center.add(new BABYLON.Vector3(
            radius * cosa * sinb,
            radius * cosb,
            radius * sina * sinb
        ));
    };

    RANDO.ExamineCamera.cartesianToSpheric = function (position, center) {
        var radiusv3 = position.subtract(center);
        var radius = radiusv3.length();

        var alpha = Math.acos(radiusv3.x / Math.sqrt(
            Math.pow(radiusv3.x, 2) +
            Math.pow(radiusv3.z, 2)
        ));
        if (radiusv3.z < 0) {
            var alpha = 2*Math.PI - this.alpha;
        }
        var beta = Math.acos(radiusv3.y / this.radius);
        return {
            'alpha': alpha,
            'beta': beta,
            'radius': radius
        };
    };
};
},{}],6:[function(require,module,exports){
/*******************************************************************************
 * Rando.HikerCamera.js
 *
 * HikerCamera class :
 *  It is a camera which look like the FreeCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  The major differences is than all moves have been replaced by some
 *  animation controls. In effect this camera was done to follow a path.
 *
 *  After instantiate the camera, set the commands and set the path with
 *  setPath() function, we can play, pause, stop, rewind and move forward the
 *  camera along this path as we want.
 *
 *
 *  Beware ! this camera will need to have imported these libraries :

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/easing/EasePack.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TimelineLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/BezierPlugin.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/DirectionalRotationPlugin.min.js"></script>

 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.HikerCamera = function (name, position, scene) {
        BABYLON.Camera.call(this, name, position, scene);

        this.cameraRotation = new BABYLON.Vector2(0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);

        this.keysPlayPause = [32];
        this.keysStop  = [13];
        this.keysRewind = [40];
        this.keysForward = [38];

        // Internals
        this._currentTarget = BABYLON.Vector3.Zero();
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._camMatrix = BABYLON.Matrix.Zero();
        this._cameraRotationMatrix = BABYLON.Matrix.Zero();
        this._referencePoint = BABYLON.Vector3.Zero();
        this._transformedReferencePoint = BABYLON.Vector3.Zero();
        this._lookAtTemp = BABYLON.Matrix.Zero();
        this._tempMatrix = BABYLON.Matrix.Zero();

        // Animation
        this._timeline = null
        this._path = [];
        this._state = null;
        this._oldState = null;
        this._isMoving = false;
        this._lenghtOfBezier = 0;
        this._positionTween = null;
        this._rotationTween = null;
    };

    RANDO.HikerCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.HikerCamera.prototype.returnSpeed = 2000;
    RANDO.HikerCamera.prototype.followSpeed = 20;
    RANDO.HikerCamera.prototype.checkCollisions = false;
    RANDO.HikerCamera.prototype.applyGravity = false;
    RANDO.HikerCamera.prototype.noRotationConstraint = false;
    RANDO.HikerCamera.prototype.angularSensibility = 2000.0;
    RANDO.HikerCamera.prototype.lockedTarget = null;
    RANDO.HikerCamera.prototype.onCollide = null;
    RANDO.HikerCamera.prototype.wheelPrecision = 0.3;
    RANDO.HikerCamera.prototype.inertialRadiusOffset = 0;
    RANDO.HikerCamera.prototype.lowerRadiusLimit = null;
    RANDO.HikerCamera.prototype.upperRadiusLimit = null;

    RANDO.HikerCamera.prototype._getLockedTargetPosition = function () {
        if (!this.lockedTarget) {
            return null;
        }

        return this.lockedTarget.position || this.lockedTarget;
    };

    // Cache
    RANDO.HikerCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.lockedTarget = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };

    RANDO.HikerCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass) {
            BABYLON.Camera.prototype._updateCache.call(this);
        }

        var lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
            this._cache.lockedTarget = null;
        }
        else {
            if (!this._cache.lockedTarget) {
                this._cache.lockedTarget = lockedTargetPosition.clone();
            }
            else {
                this._cache.lockedTarget.copyFrom(lockedTargetPosition);
            }
        }

        this._cache.rotation.copyFrom(this.rotation);
    };

    // Synchronized
    RANDO.HikerCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this)) {
            return false;
        }

        var lockedTargetPosition = this._getLockedTargetPosition();

        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)
            && this._cache.rotation.equals(this.rotation);
    };

    // Target
    RANDO.HikerCamera.prototype.setTarget = function (target) {
        this.upVector.normalize();

        BABYLON.Matrix.LookAtLHToRef(this.position, target, this.upVector, this._camMatrix);
        this._camMatrix.invert();

        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);

        var vDir = target.subtract(this.position);

        if (vDir.x >= 0.0) {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);
        } else {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);
        }

        this.rotation.z = -Math.acos(BABYLON.Vector3.Dot(new BABYLON.Vector3(0, 1.0, 0), this.upVector));

        if (isNaN(this.rotation.x)) {
            this.rotation.x = 0;
        }

        if (isNaN(this.rotation.y)) {
            this.rotation.y = 0;
        }

        if (isNaN(this.rotation.z)) {
            this.rotation.z = 0;
        }
    };
    // Controls
    RANDO.HikerCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var engine = this._scene.getEngine();

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        if (this._onMouseDown === undefined) {
            this._onMouseDown = function (evt) {
                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseUp = function (evt) {
                previousPosition = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseOut = function (evt) {
                previousPosition = null;
                that._keys = [];
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!previousPosition && !engine.isPointerLock) {
                    return;
                }

                var offsetX;
                var offsetY;

                if (!engine.isPointerLock) {
                    offsetX = evt.clientX - previousPosition.x;
                    offsetY = evt.clientY - previousPosition.y;
                } else {
                    offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                    offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
                }

                that.cameraRotation.y += offsetX / that.angularSensibility;
                that.cameraRotation.x += offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onKeyDown = function (evt) {
                var state = that._state;
                var oldState = state;
                if (that._path.length && !that._isMoving) {
                    var keyCode = evt.keyCode;

                    if (that.keysRewind.indexOf(keyCode) !== -1) {
                        if (state == "pause") {
                            state = "rewind";
                        }
                    }
                    else if (that.keysForward.indexOf(keyCode) !== -1) {
                        if (state == "pause" || state == "stop") {
                            state = "forward";
                        }
                    }
                    that._oldState  = oldState;
                    that._state     = state;
                }
            };

            this._onKeyUp = function (evt) {
                var state = that._state;
                var oldState = state;
                if (that._path.length && !that._isMoving) {
                    var keyCode = evt.keyCode;

                    if (that.keysPlayPause.indexOf(keyCode) !== -1) {
                        if (state == "stop" || state == "pause") {
                            state = "play";
                        } else if (state == "play") {
                            state = "pause";
                        }
                    }
                    else if (that.keysStop.indexOf(keyCode) !== -1) {
                        if (state == "play" || state == "pause" || !state) {
                            state = "stop";
                        }
                    }
                    else if (that.keysRewind.indexOf(keyCode) !== -1) {
                        if (state == "rewind" && that._timeline._time == 0) {
                            state = "stop";
                        }
                        else if (state == "rewind" && that._timeline._time != 0) {
                            state = "pause";
                        }
                    }
                    else if (that.keysForward.indexOf(keyCode) !== -1) {
                        if (state == "forward") {
                            state = "pause";
                        }
                    }
                    that._oldState  = oldState;
                    that._state     = state;
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
            };

            this._reset = function () {
                that._keys = [];
                previousPosition = null;
                that.cameraRotation = new BABYLON.Vector2(0, 0);

                if (that._path.length) {
                    that.loadPathOnTimeline();
                }
                that._oldState = null;
                that._state = "stop";

                if (that._position_transition) {
                    that._position_transition.kill();
                }
                if (that._rotation_transition) {
                    that._rotation_transition.kill();
                }
            };
        }

        element.addEventListener("mousedown", this._onMouseDown, false);
        element.addEventListener("mouseup", this._onMouseUp, false);
        element.addEventListener("mouseout", this._onMouseOut, false);
        element.addEventListener("mousemove", this._onMouseMove, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.HikerCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener("mousedown", this._onMouseDown);
        element.removeEventListener("mouseup", this._onMouseUp);
        element.removeEventListener("mouseout", this._onMouseOut);
        element.removeEventListener("mousemove", this._onMouseMove);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._attachedElement = null;
        if (this._reset) {
            this._reset();
        }
    };

    RANDO.HikerCamera.prototype._update = function () {

        var needToRotate = (
            Math.abs(this.cameraRotation.x) > 0 ||
            Math.abs(this.cameraRotation.y) > 0
        );
        var stateHaveChanged = (this._oldState != this._state);

        // Rotate
        if (needToRotate) {
            this.rotation.x += this.cameraRotation.x;
            this.rotation.y += this.cameraRotation.y;

            if (!this.noRotationConstraint) {
                var limit = (Math.PI / 2) * 0.95;

                if (this.rotation.x > limit)
                    this.rotation.x = limit;
                if (this.rotation.x < -limit)
                    this.rotation.x = -limit;
            }

            // Inertia
            if (Math.abs(this.cameraRotation.x) < BABYLON.Engine.epsilon)
                this.cameraRotation.x = 0;

            if (Math.abs(this.cameraRotation.y) < BABYLON.Engine.epsilon)
                this.cameraRotation.y = 0;

            this.cameraRotation.scaleInPlace(this.inertia);
        }

        // State
        if (stateHaveChanged) {
            console.log(this._oldState + " to " + this._state);
            var newState = this._state;

            switch (newState) {
                case "stop" :
                    this._isMoving = true;
                    this._timeline.pause();
                    var that = this;
                    this.moveTo(this._path[0], this._path[1], this.returnSpeed, function(){
                        that._timeline.pause(0);
                        that._isMoving = false;
                    });
                break;
                case "play" :
                    this._timeline.play();
                break;
                case "pause" :
                    this._timeline.pause();
                break;
                case "rewind" :
                    this._timeline.reverse();
                break;
                case "forward" :
                    this._timeline.play();
            }

            this._oldState = this._state;
        }
    };

    RANDO.HikerCamera.prototype._getViewMatrix = function () {
        BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

        if (!this.lockedTarget) {
            // Compute
            if (this.upVector.x != 0 || this.upVector.y != 1.0 || this.upVector.z != 0) {
                BABYLON.Matrix.LookAtLHToRef(BABYLON.Vector3.Zero(), this._referencePoint, this.upVector, this._lookAtTemp);
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);

                this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix, this._tempMatrix);
                this._lookAtTemp.invert();
                this._tempMatrix.multiplyToRef(this._lookAtTemp, this._cameraRotationMatrix);
            } else {
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
            }

            BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);

            // Computing target and final matrix
            this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        } else {
            this._currentTarget.copyFrom(this._getLockedTargetPosition());
        }

        BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);
        return this._viewMatrix;
    };

    RANDO.HikerCamera.prototype.setPath = function (vertices) {
        // Reinitialize the path
        var path = this._path;
        if (path.length) {
            path = [];
        }

        // Fill path array
        for (var i = 0; i < vertices.length; i+=20) {
            path.push(vertices[i]);
        }
        if (vertices[vertices.length] != path[path.length]) {
            path.push(vertices[vertices.length]);
        }

        // Load this path on the timeline
        this._lengthOfBezier = vertices.length;
        this.loadPathOnTimeline ();
    };

    RANDO.HikerCamera.prototype.loadPathOnTimeline = function () {
        // Verify if path and lengthOfBezier exist
        if (!this._path) {
            return;
        }
        if (!this._lengthOfBezier) {
            this._lengthOfBezier = this._path.length * 2;
        }

        // Reinitialize timeline
        if (this._timeline) {
            this._timeline.clear();
            this._timeline.kill();
            this._timeline = null;
        }
        var that = this;
        this._timeline = new TimelineLite({onComplete: function () {
            that._onCompleteTimeline();
        }});

        // Initials parameters of animation
        var quantity = this._lengthOfBezier;
        var duration = this._lengthOfBezier / this.followSpeed;
        var position = {
            x: this._path[0].x,
            y: this._path[0].y,
            z: this._path[0].z
        };

        // Creates the Bezier curve
        var tween = TweenLite.to(position, quantity, {bezier: this._path, ease:Linear.easeNone});
        var i, d = 20;

        // Load the Bezier curve on timeline
        for (i = 0; i < quantity-d; i++) {
            tween.time(i); // Jumps to the appropriate time in the tween, causing
                            // position variable to be updated accordingly.
            var currentPosition = _.clone(position);
            tween.time(i+d);
            var currentTarget = _.clone(position);
            var rotation_y = RANDO.Utils.angleFromAxis(currentPosition, currentTarget, BABYLON.Axis.Y);

            this._timeline.add([
                TweenLite.to(this.position, (duration / quantity), {
                    x: currentPosition.x,
                    y: currentPosition.y + RANDO.SETTINGS.CAM_OFFSET,
                    z: currentPosition.z,
                    ease: "Linear.easeNone"
                }),
                TweenLite.to(this.rotation, (duration / quantity), {
                    directionalRotation :{ y: (rotation_y +"_short"), useRadians:true} ,
                    ease: "Linear.easeNone"
                })
            ]);
        }
        while (i < quantity) {
            tween.time(i++);
            this._timeline.add(
                TweenLite.to(this.position, (duration / quantity), {
                    x: position.x,
                    y: position.y + RANDO.SETTINGS.CAM_OFFSET,
                    z: position.z,
                    ease: "Linear.easeNone"
                })
            );
        }

        // Animation paused by default
        this._timeline.pause(0);
    };

    RANDO.HikerCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    RANDO.HikerCamera.prototype._onCompleteTimeline = function () {
        this._state = "stop";
    };

    RANDO.HikerCamera.prototype.moveTo = function (futurePosition, futureTarget, speed, onComplete) {
        var y_rotation = RANDO.Utils.angleFromAxis(futurePosition, futureTarget, BABYLON.Axis.Y);

        var distance = BABYLON.Vector3.Distance(this.position, futurePosition);
        var duration = distance / speed;

        // Translation
        this._positionTween = TweenLite.to(this.position, duration, {
            x: futurePosition.x,
            y: futurePosition.y + RANDO.SETTINGS.CAM_OFFSET,
            z: futurePosition.z,
            ease: 'ease-in',
            onComplete : function (){
                if (typeof(onComplete) === "function") onComplete();
            }
        });

        // Rotation
        this._rotationTween = TweenLite.to(this.rotation, duration, {
            directionalRotation : {
                x: "0_short",
                y: (y_rotation + "_short"),
                z: "0_short",
                useRadians : true
            },
            ease: 'ease-in'
        });
    };
};
},{}],7:[function(require,module,exports){
/*******************************************************************************
 * Rando.Dem.js
 *
 * Dem class :
 *  Permites the creation of a Digital Elevation Model in 3D
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Dem = function (extent, altitudes, offsets, scene) {
        /* Attributes declaration */
        this._extent = this._prepareExtent(extent, offsets);
        this._altitudes = altitudes
        this._offsets = offsets;
        this._scene = scene;
        this._tiles = null;
        this._frame = null;
        this._textures = [];
        this._min_thickness = RANDO.SETTINGS.MIN_THICKNESS;

        this.ground = new BABYLON.Mesh("Digital Elevation Model", scene);
        this.sides  = new BABYLON.Mesh("Sides", scene);
        this.scaleViewer = null;

        /* Initialization */
        this.init();
    };

    /* Methods */
    RANDO.Dem.prototype.init = function () {
        this._adjustZoom ();

        var tileContainer = new RANDO.TileContainer(
            this.getRealExtent(),
            this._altitudes,
            this._offsets
        );
        this._tiles = tileContainer._tiles;
        this._frame = tileContainer.getFrame();

        this.buildGround();
        this.buildSides();
        this.buildBasement();
    };

    /*
     * RANDO.Dem._prepareExtent() : translate extent of the offsets in parameters
     *  - extent : extent to translate
     *  - offsets : values of the translation
     */
    RANDO.Dem.prototype._prepareExtent = function (extent, offsets) {
        extent.x.min += offsets.x;
        extent.x.max += offsets.x;
        extent.z.min += offsets.z;
        extent.z.max += offsets.z;
        return extent;
    };

    /*
     * RANDO.Dem._adjustZoom() : adjust the tile's zoom according the extent of the DEM
     *  More the DEM is large, more the zoom decreased and so tiles are bigger.
     *
     * NB : It take in count the RANDO.SETTINGS.TILE_NUMBER_LIMIT which correspond to the
     * limit number of tiles. This number can be changed in convenience before launch the scene.
     */
    RANDO.Dem.prototype._adjustZoom = function () {
        while (RANDO.Utils.getNumberOfTiles(RANDO.SETTINGS.TILE_ZOOM, this.getRealExtent()) > RANDO.SETTINGS.TILE_NUMBER_LIMIT) {
            RANDO.SETTINGS.TILE_ZOOM -= 1;
        }
    };

    /**
     * RANDO.Dem.buildGround() : build the ground of the DEM
     */
    RANDO.Dem.prototype.buildGround = function () {
        // Ground building...
        console.log("Ground building... " + (Date.now() - RANDO.START_TIME) );

        // Creates all tiles
        for (var it in this._tiles) {
            var meshTile = this._buildTile(this._tiles[it]);
            meshTile.parent = this.ground;

            // Prepare the future tile's texture
            this._prepareTexture(this._tiles[it].coordinates);
        }

        // Ground built !
        console.log("Ground built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem.buildSides() : build four sides of the DEM
     */
    RANDO.Dem.prototype.buildSides = function () {
        // Sides building...
        console.log("Sides building... " + (Date.now() - RANDO.START_TIME) );

        var alt_min = - this._min_thickness;

        // Creates differents sides
        var e_side = this._buildSide("East Side",  this._frame.east,  alt_min, false);
        var w_side = this._buildSide("West Side",  this._frame.west,  alt_min, true );
        var n_side = this._buildSide("North Side", this._frame.north, alt_min, false);
        var s_side = this._buildSide("South Side", this._frame.south, alt_min, true );

        // Set sides container as parent of sides
        e_side.parent = this.sides;
        w_side.parent = this.sides;
        n_side.parent = this.sides;
        s_side.parent = this.sides;

        // Sides built !
        console.log("Sides built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem.buildBasement() : build the basement of the DEM
     */
    RANDO.Dem.prototype.buildBasement = function () {
        // Basement building...
        console.log("Basement building... " + (Date.now() - RANDO.START_TIME) );

        var A = {
            'x' : this._extent.x.min,
            'y' : this._extent.z.min
        };
        var B = {
            'x' : this._extent.x.max,
            'y' : this._extent.z.min
        };
        var C = {
            'x' : this._extent.x.max,
            'y' : this._extent.z.max
        };
        var D = {
            'x' : this._extent.x.min,
            'y' : this._extent.z.max
        };
        var basement = RANDO.Utils.createGroundFromExtent (
            "DEM Basement", A, B, C, D, 1, 1, this._scene
        );
        basement.material = new BABYLON.StandardMaterial("Basement Material", this._scene);
        basement.material.diffuseTexture = new BABYLON.Texture(
            RANDO.SETTINGS.SIDE_TEX_URL,
            this._scene
        );
        basement.position.y -= this._min_thickness;

        // Basement built !
        console.log("Basement built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem._buildTile() : build a tile of the DEM
     *      - data : data of a tile
     *
     *  return the tile mesh
     */
    RANDO.Dem.prototype._buildTile = function (data) {
        var scene   = this._scene;
        var engine  = scene.getEngine();
        var that    = this;

        // Creates Tile
        var tile = RANDO.Utils.createGroundFromGrid(
            "Tile",
            data.grid,
            scene
        );

        // Recomputes normals for lights and shadows
        RANDO.Utils.computeMeshNormals(tile)

        // Set Uvs data of the tile
        RANDO.Utils.setMeshUvs(tile, data.uv);

        // Enables collisions
        tile.checkCollisions = true;

        // Material
        var material = new BABYLON.StandardMaterial("DEM - Material", scene);
        material.wireframe = true;
        material.backFaceCulling = false;
        tile.material = material;
        return tile;
    };

    /**
     * RANDO.Dem._buildSide() : build a side of the DEM
     *      - name: name of the side
     *      - line: Array of point corresponding to a border of the DEM
     *      - alt_min: altitude minimale of the DEM
     *      - reverse: Boolean, if true reverse the line
     *
     *  return the side mesh
     */
    RANDO.Dem.prototype._buildSide = function (name, line, alt_min, reverse) {
        var scene = this._scene;

        if (reverse) {
            line.reverse();
        }

        // Creates side
        var side = RANDO.Utils.createSideFromLine(name, line, alt_min, scene);

        this._computeSideUvs(side, line, alt_min);

        // Side material
        side.material = new BABYLON.StandardMaterial(name + "Material", scene);
        side.material.diffuseTexture = new BABYLON.Texture(RANDO.SETTINGS.SIDE_TEX_URL, scene);

        // Recomputes normals for lights and shadows
        RANDO.Utils.computeMeshNormals(side);

        // Enables collisions
        side.checkCollisions = true;

        return side;
    };

    /**
     * RANDO.Dem.applyTextures() : Load tile's textures over the DEM
     */
    RANDO.Dem.prototype.applyTextures = function () {
        console.log("Textures application ... " + (Date.now() - RANDO.START_TIME) );

        //~ // Prepare all textures
        //~ for (var it in this._tiles) {
            //~ this._prepareTexture(this._tiles[it].coordinates);
        //~ }

        var scene = this._scene;
        var meshes = this.ground.getChildren ();
        var finalTextures = this._textures;
        var checked = [];
        var count = finalTextures.length;
        for (var it in finalTextures){
            checked.push(false);
        }

        function loop (){
            var it = 0;
            var chunk = 50;
            function apply () {
                var cnt = chunk;
                while (cnt-- && it < finalTextures.length) {
                    if (!checked[it] && finalTextures[it]._texture.isReady) {
                        checked[it] = true;

                        // Set the texture when it's loaded
                        var material = meshes[it].material;
                        material.diffuseTexture = finalTextures[it];
                        material.diffuseTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
                        material.diffuseTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
                        material.wireframe = false;
                        count--;
                    }
                    it++;
                }
                if (it < finalTextures.length) {
                    setTimeout (apply, 1);
                } else if (count > 0) {
                    setTimeout (loop, 1);
                } else {
                    console.log("Textures applied ! " + (Date.now() - RANDO.START_TIME) );
                }
            };
            apply();
        }
        loop();
    };

    /**
     * RANDO.Dem._prepareTexture() : Prepare a tile of textures for the DEM and add
     *  it to the textures Array.
     *      - coordinates : coordinates of a tile
     *
     */
    RANDO.Dem.prototype._prepareTexture = function (coordinates) {
        var scene = this._scene;
        var engine = scene.getEngine();
        var url = RANDO.Utils.replaceUrlCoordinates(
            RANDO.SETTINGS.TILE_TEX_URL,
            coordinates.z,
            coordinates.x,
            coordinates.y
        );
        this._textures.push(new BABYLON.Texture(url, scene));
    };

    /**
     * RANDO.Dem._computeSideUvs() : Computes uvs values of a side
     *      - side : side mesh
     *      - line : line of altitudes
     *      - alt_min : it is the minimum altitude of the DEM
     */
    RANDO.Dem.prototype._computeSideUvs = function (side, line, alt_min) {
        var cType = 'z';
        if (line[line.length-1].z - line[0].z == 0) {
            cType = 'x';
        }

        var u = [];
        for (var it in line) {
            u.push(
                Math.abs(line[it][cType] - line[0][cType]) *
                1 / (Math.abs(line[line.length-1][cType] - line[0][cType]))
            );
        }

        var uv = [];
        for (var it in u) {
            uv.push(u[it]); // u value
            uv.push((line[it].y - alt_min)/(this._extent.y.max - alt_min)); // v value
        }
        for (var it in u) {
            uv.push(u[it]); // u value
            uv.push(0); // v value
        }

        side.setVerticesData(BABYLON.VertexBuffer.UVKind, uv);
    };

    /**
     * RANDO.Dem.getRealExtent() : Give the real extent of the DEM, it means the
     *  extent in meters in the original projection.
     */
    RANDO.Dem.prototype.getRealExtent = function () {
        var extent = {};
        extent.x = {};
        extent.y = {};
        extent.z = {};
        extent.x.min = this._extent.x.min - this._offsets.x;
        extent.x.max = this._extent.x.max - this._offsets.x;
        extent.y.min = this._extent.y.min;
        extent.y.max = this._extent.y.max;
        extent.z.min = this._extent.z.min - this._offsets.z;
        extent.z.max = this._extent.z.max - this._offsets.z;
        return extent;
    };
};
},{}],8:[function(require,module,exports){
module.exports = function(RANDO) {

    var RANDO = RANDO || {};

    RANDO.Events = {};
    /*
     * Bind and Unbind events
     *
     ***************************/
    // DOM Level 2 Event model
    if (document.addEventListener) {
        RANDO.Events.addEvent = function (elem, type, fn) {
            elem.addEventListener(type, fn, false);
            return fn;
        };
        RANDO.Events.removeEvent = function (elem, type, fn) {
            elem.removeEventListener(type, fn, false);
        };
    }
    // Proprietary legacy IE Model
    else if (document.attachEvent) {
        RANDO.Events.addEvent = function (elem, type, fn) {
            var bound = function () {
                return fn.apply(elem, arguments);
            };
            elem.attachEvent("on" + type, bound);
            return bound;
        };
        RANDO.Events.removeEvent = function (elem, type, fn) {
            elem.removeEventListener("on" + type, fn);
        };
    }
};
},{}],9:[function(require,module,exports){
/*******************************************************************************
 * Rando.Poi.js
 *
 * Poi class :
 *  Permites the build of a Point of Interest in 3D
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Poi = function (id, data, offsets, scene) {
        this._id            = id
        this._position      = {
            'x' : data.coordinates.x + offsets.x,
            'y' : 0,
            'z' : data.coordinates.z + offsets.z
        };
        this._name          = data.properties.name;
        this._type          = data.properties.type;
        this._elevation     = data.properties.elevation;
        this._description   = data.properties.description || RANDO.SETTINGS.NO_DESCRIPTION_MESSAGE;
        this._scene         = scene;

        this.panel          = null;
        this.picto          = null;
        this.sphere         = null;
        this._attachedLight = null;
        this.init();
    };

    RANDO.Poi.prototype.init = function () {
        this._buildPanel ();
        this._buildSphere ();

        var that = this;
        this._scene.registerBeforeRender( function () {
            that._registerBeforeRender();
        });
    };

    /**
     * RANDO.Poi._buildPanel() : build a Panel with a picto which defines the type of POI
     */
    RANDO.Poi.prototype._buildPanel = function () {
        var scene       = this._scene;
        var position    = this._position;
        var text        = this._name;
        var src         = RANDO.SETTINGS.PICTO_PREFIX + this._type.pictogram;
        var id          = this._id;
        var elevation   = this._elevation;

        // Size of panel (in pixel and in meters)
        var pan_size = {
            px: {
                width : 512,
                height : 512
            },
            m: {
                width : RANDO.SETTINGS.PICTO_SIZE,
                height : RANDO.SETTINGS.PICTO_SIZE + 30
            }
        };
        // Size of the pictogram (in pixels)
        var picto_size = {
            width : pan_size.px.width,
            height : pan_size.px.height * RANDO.SETTINGS.PICTO_SIZE / pan_size.m.height
        };

        // Building panel Mesh
        var panel = BABYLON.Mesh.CreateGround(
            "POI - Panel",
            pan_size.m.width,
            pan_size.m.height,
            2, scene
        );
        panel.id = id;
        panel.rotate (BABYLON.Axis.X, -Math.PI/2, BABYLON.Space.LOCAL);
        panel.position.x = position.x;
        panel.position.y = -1000;
        panel.position.z = position.z;
        panel.material = new BABYLON.StandardMaterial("POI - Panel - Material", scene);
        this.panel = panel;

        // Panel Texture
        var panel_tex = new BABYLON.DynamicTexture("POI - Panel - Texture", pan_size.px.width, scene, true);
        panel_tex.hasAlpha = true;
        fillPanelTexture();

        // Building pictogram Container
        var picto = BABYLON.Mesh.CreateGround(
            "POI - Panel",
            pan_size.m.width,
            pan_size.m.height,
            2, scene
        );
        picto.id = id;
        picto.material = new BABYLON.StandardMaterial("POI - Picto - Material", scene);
        picto.renderingGroupId = 1;
        this.picto = picto;
        picto.parent = panel;

        // Pictogram Texture
        var picto_tex = new BABYLON.DynamicTexture("POI - Picto - Texture", pan_size.px.width, scene, true);
        picto_tex.hasAlpha = true;
        fillPictoTexture();

        function fillPictoTexture () {
            var pictoContext = picto_tex.getContext();

            // Load the pictogram on the pictogram container
            var img = new Image();
            img.onload = function () {
                pictoContext.drawImage(img, 0, 0, picto_size.width, picto_size.height);

                // Update
                pictoContext.restore();
                picto_tex.update();
                picto.material.diffuseTexture = picto_tex;
                picto.material.emissiveTexture = picto_tex;
            };
            img.src = src;
        };

        function fillPanelTexture () {
            var panelContext = panel_tex.getContext();

            // Draws background of the pictogram on the panel
            panelContext.fillStyle = "rgba(255, 255, 255, 0.5)";
            RANDO.Utils.roundRect(panelContext, 0, 0, picto_size.width, picto_size.height, pan_size.px.width/10);

            // Set & draw the text on the panel
            var text = elevation + "m";
            var fontSize = (pan_size.px.height - picto_size.height) * RANDO.SETTINGS.POI_LABEL_SCALE ;
            panelContext.font = "bolder " + fontSize + "pt Arial";
            panelContext.fillStyle = "#fff";
            panelContext.textAlign = "center";
            panelContext.fillText(text, pan_size.px.width/2, pan_size.px.height);

            // Update
            panelContext.restore();
            panel_tex.update();
            panel.material.opacityTexture   = panel_tex;
            panel.material.emissiveTexture  = panel_tex;
        };
    };

    /**
     * RANDO.Poi._buildSphere() : build a Sphere which will be on the real position
     *  of the POI on the DEM.
     */
    RANDO.Poi.prototype._buildSphere = function () {
        var scene       = this._scene;
        var position    = this._position;

        var sphere = BABYLON.Mesh.CreateSphere(
            "POI - Sphere", 10, RANDO.SETTINGS.POI_SIZE, scene
        );
        sphere.material = new BABYLON.StandardMaterial(
            "POI - Sphere - Material", scene
        );
        sphere.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        sphere.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        this.sphere = sphere;
    };

    /**
     * RANDO.Poi._registerBeforeRender() : function to call before each scene render
     */
    RANDO.Poi.prototype._registerBeforeRender = function () {
        var scene       = this._scene;
        var panel       = this.panel;
        var picto       = this.picto;

        // Controls visibility according the Distance from camera
        if (BABYLON.Vector3.Distance(panel.position, scene.activeCamera.position) < 300) {
            panel.isVisible = false;
            picto.isVisible = false;
        }
        else {
            panel.isVisible = true;
            picto.isVisible = true;
        }

        // Controls panel orientation
        panel.lookAt(scene.activeCamera.position, 0, -Math.PI/2, 0);
    };

    /**
     * RANDO.Poi.drape() : drape the POI over the DEM
     *      - ground : ground of the DEM
     */
    RANDO.Poi.prototype.drape = function (ground) {
        RANDO.Utils.drapePoint(this.panel.position, ground, RANDO.SETTINGS.POI_OFFSET);
        this.sphere.position = this.panel.position.clone();
        this.sphere.position.y -= RANDO.SETTINGS.POI_OFFSET;
    };

    /**
     * RANDO.Poi.onMouseDownHandler() : callback to run if the mouse is down over a picto
     *      - evt: event informations
     */
    RANDO.Poi.prototype.onMouseDownHandler = function (evt) {
        jQuery('.poi--clicked').text(this._name + ' (' + this._elevation + 'm )');
        jQuery('.poi--clicked').css('left', evt.clientX - 20 + 'px');
        jQuery('.poi--clicked').css('top',  evt.clientY - 40 + 'px');
        jQuery('.poi--clicked').css('display', 'block');

        jQuery('.poi_side h2').html(this._name );
        jQuery('.poi_side .description').html(this._description);
        jQuery('.poi_side').css('display', 'block');

        jQuery('.interface').css('width', '80%');
    };

    /**
     * RANDO.Poi.onMouseOverHandler() : callback to run if the mouse is over a picto
     *      - evt: event informations
     */
    RANDO.Poi.prototype.onMouseOverHandler = function (evt) {
        jQuery('.poi--hover').text(this._name + ' (' + this._elevation + 'm )');
        jQuery('.poi--hover').css('left', evt.clientX - 20 + 'px');
        jQuery('.poi--hover').css('top',  evt.clientY - 40 + 'px');
        jQuery('.poi--hover').css('display', 'block');

        jQuery('#canvas_renderer')[0].style.cursor = 'pointer';
    };

    /** Static
     * RANDO.Poi.runMouseListener() : Static function which run all mouse
     *  listeners linked to POIs, we give it a POI's array and it adds
     *  mouse events over all its elements.
     *
     *      - canvas : canvas where the scene is
     *      - pois : array of POIs
     *      - scene : scene
     */
    RANDO.Poi.runMouseListener = function (canvas, pois, scene) {
        var clickedID;

        // MouseDown Event : check if the mouse is over a Picto when Mouse left click is down
        RANDO.Events.addEvent(window, "mousedown", function (evt) {
            var pickResult = scene.pick (evt.clientX, evt.clientY);
            var pickedMesh = pickResult.pickedMesh;

            jQuery('.poi--hover').css('display', 'none');
            jQuery('.poi--clicked').css('display', 'none');
            clickedID = -1;

            // if the click hits a pictogram, we display informations of POI
            if (pickResult.hit && pickedMesh.name == "POI - Panel") {
                pois[pickedMesh.id].onMouseDownHandler(evt);
                clickedID = pickedMesh.id;
            }
        });

        // MouseMove Event : always check if mouse is over a Picto
        RANDO.Events.addEvent(window, "mousemove", function (evt) {
            var pickResult = scene.pick (evt.clientX, evt.clientY);
            var pickedMesh = pickResult.pickedMesh;

            jQuery('.poi--hover').css('display', 'none');
            jQuery('#canvas_renderer')[0].style.cursor = 'default';

            // if mouse is over a pictogram, we display informations of POI
            if (pickResult.hit && pickedMesh.name == "POI - Panel"
                && clickedID != pickedMesh.id) {
                pois[pickedMesh.id].onMouseOverHandler(evt);
            }
        });

        // Close button events of the POI side
        jQuery(".close_btn").on('click', function () {
            jQuery(".poi_side").css('display', 'none');
            jQuery('.interface').css('width', '100%');
        });
        jQuery(".close_btn").mouseover( function () {
           this.style.cursor = 'pointer';
        });
        jQuery(".close_btn").mouseout( function () {
            this.style.cursor = 'default';
        });
    };

};
},{}],10:[function(require,module,exports){
/*******************************************************************************
 * Rando.Scene.js
 *
 * Scene class :
 *  Permites the creation and manipulation of a scene 3D containing (or not) :
 *      - a Digital Elevation Model
 *      - a Trek which is draped over the DEM
 *      - a set of Points Of Interest draped over the DEM too
 *      - a set of Cameras
 *      - a set of lights
 *
 * @author: Célian GARCIA
 ******************************************************************************/


module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Scene = function (canvas, cameraID) {
        // Attributes declaration
        this._canvas    = canvas;
        this._cameraID  = cameraID;

        this._engine    = null;
        this._scene     = null;
        this.camContainer    = null;
        this.lights     = {};
        this.dem        = null;
        this.trek       = null;
        this.pois       = [];

        this._dem_data  = {};
        this._trek_data = [];
        this._pois_data = [];
        this._offsets   = {};
    };


    /* Methods */
    RANDO.Scene.prototype.init = function () {
        RANDO.START_TIME = Date.now();
        this._engine = new BABYLON.Engine(this._canvas, true);
        this._scene  = new BABYLON.Scene(this._engine);
        var that = this;
        RANDO.Events.addEvent(window, "resize", function(){
            that._engine.resize();
        });

        this._scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        this._scene.collisionsEnabled = true;
        this._buildLights();
        this.process();
    };

    /**
     * RANDO.Scene.process() : launch the building process of the scene
     *  It displays :
     *          - Terrain
     *          - Trek
     *          - POIs
     */
    RANDO.Scene.prototype.process = function () {
        var that = this;

        jQuery.getJSON(RANDO.SETTINGS.DEM_URL)
         .done(function (data) {
            that._parseDemJson(data);
            that._buildCameras();
         })
         .then(function () {
            return jQuery.getJSON(RANDO.SETTINGS.PROFILE_URL);
         })
         .done(function (data) {
            that._parseTrekJson(data);
         })
         .then(function () {
            return jQuery.getJSON(RANDO.SETTINGS.POI_URL);
         })
         .done(function (data) {
            that._parsePoiJson(data);

         })
         .then(function () {
            // Run renderloop
            that._engine.runRenderLoop(function() {
                that._scene.render();
            });

            // Tiled DEM mesh building
            that.dem = new RANDO.Dem(
                that._dem_data.extent,
                that._dem_data.altitudes,
                that._offsets,
                that._scene
            );

            // Trek building
            that.trek = new RANDO.Trek  (
                that._trek_data,
                that._offsets,
                that._scene
            );

            // POIs building
            var id = 0;
            for (var it in that._pois_data) {
                if (RANDO.Utils.isInExtent(that._pois_data[it].coordinates, that.dem.getRealExtent())) {
                    that.pois.push(new RANDO.Poi(
                        id++,
                        that._pois_data[it],
                        that._offsets,
                        that._scene
                    ));
                }
            }
            RANDO.Poi.runMouseListener(that._canvas, that.pois, that._scene);

            // To execute when scene is ready
            that._scene.executeWhenReady(function () {
                that._executeWhenReady ();
            });
         })
    };

    /**
     * RANDO.Scene._buildCameras() : builds cameras of the scene
     *
     *  If the camera ID is not available, it is changed to "demo_camera"
     */
    RANDO.Scene.prototype._buildCameras = function () {
        // Parameters for the Camera Container
        var params = {
            'demCenter' : this._dem_data.center,
            'offsets'   : this._offsets,
            'demExtent' : this._dem_data.extent,
            'demAltitudes': this._dem_data.altitudes,
            'switchEnabled' : true
        };

        // Instantiate the container
        this.camContainer = new RANDO.CameraContainer(this._canvas, this._scene, params);

        // Control camera ID entered (examine_camera by default)...
        if (!jQuery.inArray(this._cameraID, RANDO.CameraIDs))
            this._cameraID = "examine";

        // ...and set it as active
        this.camContainer.setActiveCamera (this._cameraID);
    };

    /**
     * RANDO.Scene._buildLights() : builds the differents lights of the scene
     */
    RANDO.Scene.prototype._buildLights = function () {
        var scene = this._scene;

        // Sun
        this.lights.sun = light (
            "Sun", new BABYLON.Vector3(-500, -10000, 0), 1.2
        );

        // Side Light 1
        this.lights.sideLight1 = light (
            "Side Light 1", new BABYLON.Vector3(1, 0, 0.8), 1.2
        );

        // Side Light 2
        this.lights.sideLight2 = light (
            "Side Light 2", new BABYLON.Vector3(-1, 0, -0.8), 1.2
        );

        // light() : return a directional light
        function light (name, direction, intensity) {
            var light = new BABYLON.DirectionalLight(
                name,
                direction,
                scene
            );
            light.intensity = intensity;
            light.specular = new BABYLON.Color4(0, 0, 0, 0);
            return light;
        }
    };

    /**
     * RANDO.Scene._executeWhenReady() : function which is executed when the scene
     *  is ready, in other words, when the scene have built all its elements.
     */
    RANDO.Scene.prototype._executeWhenReady = function () {
        console.log("Scene is ready ! " + (Date.now() - RANDO.START_TIME) );

        var trek            = this.trek;
        var camContainer    = this.camContainer;
        var lights          = this.lights;

        // Init sidelights excluded meshes arrays with the tiles
        lights.sideLight1.excludedMeshes = this.dem.ground.getChildren();
        lights.sideLight2.excludedMeshes = this.dem.ground.getChildren();

        // Apply DEM textures
        this.dem.applyTextures();

        // Drape the trek with an onComplete callback
        trek.drape(this.dem.ground, onDrapeComplete);

        // Drape POIS
        for (var it in this.pois) {
            this.pois[it].drape(this.dem.ground);
        }

        function onDrapeComplete () {
            // Updates trek vertices ...
            trek.updateVertices();

            // ... to give them to the camera container (for hiker camera)
            camContainer.setAnimationPath(trek._vertices);

            // Merges the trek to increase performances
            trek.merge();

            // Update excluded meshes of lights
            jQuery.merge(lights.sideLight1.excludedMeshes, trek.mergedTreks);
            jQuery.merge(lights.sideLight2.excludedMeshes, trek.mergedTreks);
        }
    };

    /**
     * RANDO.Scene._parseDemJson() : parse data from the DEM json
     *      - data : data from DEM json
     */
    RANDO.Scene.prototype._parseDemJson = function (data) {
        // Conversions
        var m_center = RANDO.Utils.toMeters(data.center);
        var m_extent = RANDO.Utils.getMetersExtent (data.extent);

        // Record DEM extent
        this._dem_data.extent = m_extent;
        this._dem_data.extent.y.min *= RANDO.SETTINGS.ALTITUDES_Z_SCALE;
        this._dem_data.extent.y.max *= RANDO.SETTINGS.ALTITUDES_Z_SCALE;

        // Record DEM altitudes scaled
        this._dem_data.altitudes = RANDO.Utils.scaleArray2(
            data.altitudes,
            RANDO.SETTINGS.ALTITUDES_Z_SCALE
        );

        // Record DEM center
        this._dem_data.center = {
            'x' : m_center.x,
            'y' : (this._dem_data.extent.y.min + this._dem_data.extent.y.max) / 2,
            'z' : m_center.y
        };

        // Records scene offsets
        this._offsets.x = -m_center.x;
        this._offsets.z = -m_center.y;
    };

    /**
     * RANDO.Scene._parseTrekJson() : parse data from the Trek profile json
     *      - data : data from Trek profile json
     */
    RANDO.Scene.prototype._parseTrekJson = function (data) {

        for (var it in data.profile){
            var tmp = {
                'lng' : data.profile[it][2][0],
                'lat' : data.profile[it][2][1]
            };

            // We take only x and z values (not the altitudes)
            tmp = RANDO.Utils.toMeters(tmp);

            // toMeters() give x-y-coordinates and babylon take x-z-coordinates
            tmp.z = tmp.y;
            delete tmp["y"];

            // Record
            this._trek_data.push(tmp);
        }
    };

    /**
     * RANDO.Scene._parsePoiJson() : parse data from the POI json
     *      - data : data from POI json
     */
    RANDO.Scene.prototype._parsePoiJson = function (data) {
        for (var it in data.features) {
            var feature = data.features[it];

            // Conversion
            var coordinates = RANDO.Utils.toMeters({
                'lng' : feature.geometry.coordinates[0],
                'lat' : feature.geometry.coordinates[1]
            });

            // Record
            this._pois_data.push ({
                'coordinates' : {
                    'x': coordinates.x,
                    'z': coordinates.y
                },
                'properties' : feature.properties
            });
        }
    };
};
},{}],11:[function(require,module,exports){
// Rando.Settings.js
// General settings

module.exports = function(RANDO, BABYLON) {
    var RANDO = RANDO || {};
    RANDO.SETTINGS = {};

    // Links
    RANDO.SETTINGS.IMAGES_FOLDER = '';
    RANDO.SETTINGS.DEM_URL = ''; // Url of the DEM json
    RANDO.SETTINGS.PROFILE_URL = ''; // Url of the trek's profile json
    RANDO.SETTINGS.TILE_TEX_URL = ''; // Url of a tile texture
    RANDO.SETTINGS.SIDE_TEX_URL = ''; // Url of the side texture
    RANDO.SETTINGS.TILE_TEX_URL_SUBDOMAINS = ['a', 'b', 'c'];
    ////////////////////////////////////////////////////////////////////////////////


    // Camera
    RANDO.SETTINGS.CAM_OFFSET = 200; // Camera's altitude offset (in meters)

    RANDO.SETTINGS.HCAM_FOLLOW_SPEED = 15; // HikerCamera speed when it follows trek
    RANDO.SETTINGS.HCAM_RETURN_SPEED = 1500; // HikerCamera speed when it comes back to default
    RANDO.SETTINGS.CAM_SPEED_F = 50;  // Camera speed in Flying mode(from 0 to infinity !)
    RANDO.SETTINGS.COLLISIONS_OFFSET = 150;
    ////////////////////////////////////////////////////////////////////////////////


    // Geometry
    RANDO.SETTINGS.ALTITUDES_Z_SCALE = 1.4;
    RANDO.SETTINGS.LIMIT_VERT_BY_MESH = 65536;
    RANDO.SETTINGS.TREK_SPH_TESSEL = 5;
    RANDO.SETTINGS.TREK_CYL_TESSEL = 20;
    RANDO.SETTINGS.MIN_THICKNESS = 200; // Minimum thickness of the DEM
    RANDO.SETTINGS.TREK_OFFSET = 2; // Trek's altitude offset (in meters)

    RANDO.SETTINGS.TREK_COLOR = new BABYLON.Color3(0.1, 0.6, 0.2); // Trek color (green)
                     // new BABYLON.Color3(0.1,0.6,0.2); // green
                     // new BABYLON.Color3(0.8,0,0.2); // fuschia
                     // new BABYLON.Color3(0.9,0.5,0); // orange

    RANDO.SETTINGS.TREK_WIDTH = 10; // Trek width (in meters)

    RANDO.SETTINGS.TILE_ZOOM = 17;
    RANDO.SETTINGS.TILE_NUMBER_LIMIT = 200;

    RANDO.SETTINGS.POI_OFFSET = 100;
    RANDO.SETTINGS.POI_FORM1 = {
        objectName : '' ,
        folder: 'blender/',
        fileName: 'poi.babylon'
    };
    RANDO.SETTINGS.POI_SIZE = 20;
    RANDO.SETTINGS.POI_LABEL_SCALE = 1;
    RANDO.SETTINGS.PICTO_SIZE = 100;
    RANDO.SETTINGS.PICTO_PREFIX = '';

    RANDO.SETTINGS.NO_DESCRIPTION_MESSAGE = '<p>Pas de description liée à ce point d\'intérêt.</p>';
    RANDO.SETTINGS.CAMERA_MESSAGES = {
        'bird' : 'On peut survoler le terrain tel un oiseau, tourner la tête, monter, descendre et se déplacer !',
        'examine' : 'On peut examiner le terrain en le tournant dans tous les sens.',
        'hiker' : 'Ici on est dans la peau d\'un randonneur, on suit sans effort l\'avancement de l\'itinéraire, en profitant de la vue.'
    };

    return RANDO;
};

////////////////////////////////////////////////////////////////////////////////

},{}],12:[function(require,module,exports){
/*******************************************************************************
 * Rando.TileContainer.js
 *
 * TileContainer class :
 *  Contains all data for the build of a tiled Digital Elevation Model
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function (RANDO) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.TileContainer = function (extent, altitudes, offsets) {
        /* Attributes declaration */
        this._extent = _.clone(extent);
        this._altitudes = _.clone(altitudes);
        this._offsets = _.clone(offsets);
        this._grid = null;
        this._tiles = {};

        this._init();
    };

    /* Methods */
    RANDO.TileContainer.prototype._init = function () {
        this._generateTiles();
        this._joinTiles();
        this._computeSize();
        this._computeUvs();
        this.translate();
    };

    /**
     * RANDO.TileContainer._generateTiles() : generates an array of tiles which are js objects
     */
    RANDO.TileContainer.prototype._generateTiles = function () {
        var zoom = RANDO.SETTINGS.TILE_ZOOM;
        var tiles = this._tiles;
        var col, row;

        this._grid = RANDO.Utils.createElevationGrid(
            this._extent.x.min,
            this._extent.x.max,
            this._extent.z.min,
            this._extent.z.max,
            this._altitudes
        );

        var grid = this._grid;

        var curr_index,  prev_index  = null,
            curr_point,  prev_point  = null,
            curr_tile_n, prev_tile_n = null,
            line_tmp = [],
            new_line = true;

        // Subdivide grid in tiles
        for (row in grid) {
            for (col in grid[row]) {
                curr_point = grid[row][col];

                // Get current tile number corresponding to the current point
                curr_tile_n = RANDO.Utils.meters2num(curr_point.x, curr_point.z, zoom);
                curr_index = "" + zoom + "/" + curr_tile_n.xtile + "/" + curr_tile_n.ytile;

                // tiles["z/x/y"] exists or not
                tiles[curr_index] = tiles[curr_index] || {};
                if (Object.keys(tiles[curr_index]).length == 0){
                    tiles[curr_index].grid = [];
                    tiles[curr_index].coordinates = {
                        z: zoom,
                        x: curr_tile_n.xtile,
                        y: curr_tile_n.ytile
                    };
                }
                // if the previous index exists and is different from the current index
                if ( prev_index != null && prev_index != curr_index ) {
                    tiles[prev_index].grid.push(line_tmp); // push the line into previous tile
                    line_tmp = []; // reset the line
                }

                line_tmp.push(_.clone(curr_point));

                prev_index = curr_index;
                prev_point = curr_point;
                new_line = false;
                prev_tile_n = curr_tile_n;
            }
            new_line = true;
        }

        // Push the last line of the last tile
        tiles[curr_index].grid.push(line_tmp);
    };

    /**
     * RANDO.TileContainer._joinTiles() : joins tiles data
     */
    RANDO.TileContainer.prototype._joinTiles = function () {
        var tiles = this._tiles;
        var col, row, it;

        // Joins East and West sides of tiles
        for (it in tiles) {
            var current_tile = tiles[it];
            var next_coord = {
                z: current_tile.coordinates.z,
                x: current_tile.coordinates.x + 1,
                y: current_tile.coordinates.y
            };
            var next_index = ""  + next_coord.z + "/" + next_coord.x + "/" + next_coord.y + "";

            // if next tile exist
            if (tiles[next_index]) {
                var current_grid = current_tile.grid;
                var next_grid = tiles[next_index].grid;

                // for each row in the current tile grid
                for (row in current_grid) {
                    var prev_point = current_grid[row][current_grid[row].length-1];
                    var next_point = next_grid[row][0];
                    var mid = RANDO.Utils.middle(prev_point, next_point);
                    current_grid[row].push(mid);
                    next_grid[row].splice(0, 0, _.clone(mid));
                }
            }
        }

        // Joins North and South sides of tiles
        for (it in tiles) {
            var current_tile = _.clone(tiles[it]);
            var next_coord = {
                z: current_tile.coordinates.z,
                x: current_tile.coordinates.x,
                y: current_tile.coordinates.y + 1
            };
            var next_index = ""  + next_coord.z + "/" + next_coord.x + "/" + next_coord.y + "";

            if (tiles[next_index]) {
                var next_tile = tiles[next_index];

                // First line of current tile
                var prev_line = _.clone(current_tile.grid[0]);

                // Last line of next tile
                var next_line = _.clone(next_tile.grid[next_tile.grid.length-1]);

                // we create a new line placed on the middle of the both previous
                // We need two variables to store this line
                var med_line1 = [];
                var med_line2 = [];

                for (var i in prev_line) {
                    var mid = RANDO.Utils.middle(prev_line[i], next_line[i]);
                    med_line1.push(_.clone(mid));
                    med_line2.push(_.clone(mid));
                }

                // The "median line" go to the south of current tile
                current_tile.grid.splice(0, 0, med_line1);
                // ... and to the north of next tile
                next_tile.grid.push(med_line2);
            }
        }
    };

    /**
     * RANDO.TileContainer._computeSize() : computes height and width of each tile and add it to the tiles data container
     */
    RANDO.TileContainer.prototype._computeSize = function () {
        var tiles = this._tiles;
        for (var it in tiles) {
            var tile = tiles[it];
            var grid = tile.grid;
            var n = grid.length-1;
            var m = grid[0].length-1;
            tile.size = {
                'width' : grid[0][m].x - grid[0][0].x,
                'height': grid[n][0].z - grid[0][0].z
            };
        }
    };

    /**
     * RANDO.TileContainer._computeUvs() :  computes uv values of each tile and add it to the tiles data container
     */
    RANDO.TileContainer.prototype._computeUvs = function () {
        var tiles = this._tiles;

        var max_width = _.max(tiles, function(tile) {
                return tile.size.width;
        }).size.width;

        var max_height = _.max(tiles, function(tile) {
                return tile.size.height;
        }).size.height;

        var extent = this.getExtentInTilesCoordinates();

        // Fill the uv data of tiles
        for (var it in tiles) {
            var tile = tiles[it];
            tile.uv = {};

            // Fill u array
            if (tile.coordinates.x == extent.x.min) { // East tiles
                tile.uv.u = uValues(tile, max_width, "east");
            }
            else if (tile.coordinates.x == extent.x.max) { // West tiles
                tile.uv.u = uValues(tile, max_width, "west");
            }
            else { // Interior tiles
                tile.uv.u = uValues(tile, tile.size.width, "normal");
            }

            // Fill v array
            if (tile.coordinates.y == extent.y.min) { // North tiles
                tile.uv.v = vValues(tile, max_height, "north");
            }
            else if (tile.coordinates.y == extent.y.max) { // South tiles
                tile.uv.v = vValues(tile, max_height, "south");
            }
            else { // Interior tiles
                tile.uv.v = vValues(tile, tile.size.height, "normal");
            }
        }

        function uValues(tile, width, string) {
            if (typeof (string) === 'undefined') string = "normal";
            console.assert(
                string == "east" || string == "normal" || string == "west",
                "uValues() function uncorrectly used"
            );

            if (string == "west") {
                string = "normal";
            }

            var n = tile.grid[0].length-1;
            switch (string) {
                case "east":
                    var u = [];
                    u[n] = 1;
                    for (var col = n-1; col >= 0; col--) {
                        var crt_x = tile.grid[0][col].x;
                        var nxt_x = tile.grid[0][col+1].x;
                        u[col] = u[col+1] - (Math.abs(nxt_x - crt_x)/width);
                    }
                    return u;
                break;
                case "normal":
                    var u = [];
                    u[0] = 0;
                    for (var col = 1; col <= n; col++) {
                        var crt_x = tile.grid[0][col].x;
                        var prv_x = tile.grid[0][col-1].x;
                        u[col] = u[col-1] + (Math.abs(prv_x - crt_x)/width);
                    }
                    return u;
                break;
                default:
                    return null;
            }
        };


        function vValues(tile, height, string) {
            if (typeof (string) === 'undefined') string = "normal";
            console.assert(
                string == "south" || string == "normal" || string == "north",
                "uValues() function uncorrectly used"
            );

            if (string == "north") {
                string = "normal";
            }

            var m = tile.grid.length-1;
            switch (string) {
                case "south":
                    var v = [];
                    v[m] = 1;
                    for (var row = m-1; row >= 0; row--) {
                        var crt_z = tile.grid[row][0].z;
                        var nxt_z = tile.grid[row+1][0].z;
                        v[row] = v[row+1] - (Math.abs(nxt_z - crt_z)/height);
                    }
                    v.reverse();
                    return v;
                break;
                case "normal":
                    var v = [];
                    v[0] = 0;
                    for (var row = 1; row <= m; row++) {
                        var crt_z = tile.grid[row][0].z;
                        var prv_z = tile.grid[row-1][0].z;
                        v[row] = v[row-1] + (Math.abs(prv_z - crt_z)/height);
                    }
                    v.reverse();
                    return v;
                break;
                default: return null;
            }
        };
    };

    /**
     * RANDO.TileContainer.translate() : translate the Tiles data of the offsets attribute or of
     * the offsets given in parameters
     */
    RANDO.TileContainer.prototype.translate = function (dx, dy, dz) {
        var tiles = this._tiles;
        var offsets = {};
        var col, row;

        if (typeof(dx) === "undefined"){
            offsets.x = this._offsets.x;
        }else {
            offsets.x = dx;
        }

        if (typeof(dy) === "undefined"){
            offsets.y = this._offsets.y;
        }else {
            offsets.y = dy;
        }

        if (typeof(dz) === "undefined"){
            offsets.z = this._offsets.z;
        }else {
            offsets.z = dz;
        }

        // Translates the tiles positions of the offsets
        for (var it in tiles) {
            var grid = tiles[it].grid;
            for (row in grid) {
                for (col in grid[row]) {
                    grid[row][col].x += offsets.x;
                    grid[row][col].z += offsets.z;
                }
            }
        }
    };

    /**
     * RANDO.TileContainer.getFrame() : get the frame of the DEM composed by 4 lines
     *  east, west, north, and south.
     */
    RANDO.TileContainer.prototype.getFrame = function () {
        var frame = {};
        frame.east  = [];
        frame.west  = [];
        frame.north = [];
        frame.south = [];
        var tiles = this._tiles;
        var col, row;

        var extent = this.getExtentInTilesCoordinates();

        for (var it in tiles) {
            var tile = tiles[it];
            if ( tile.coordinates.x == extent.x.max ) {
                var last_col = tile.grid[0].length -1;
                for (row in tile.grid) {
                    frame.east.push(tile.grid[row][last_col]);
                }
            }
            if ( tile.coordinates.x == extent.x.min ) {
                var first_col = 0;
                for (row in tile.grid) {
                    frame.west.push(tile.grid[row][first_col]);
                }
            }
            if ( tile.coordinates.y == extent.y.min ) {
                var last_row = tile.grid.length-1;
                for (col in tile.grid[last_row]){
                    frame.south.push(tile.grid[last_row][col]);
                }
            }
            if ( tile.coordinates.y == extent.y.max ) {
                var first_row = 0;
                for (col in tile.grid[first_row]){
                    frame.north.push(tile.grid[first_row][col]);
                }
            }
        }

        return frame;
    };

    /**
     * RANDO.TileContainer.getExtentInTilesCoordinates() : get the x and y extent in tile's
     * coordinates
     */
    RANDO.TileContainer.prototype.getExtentInTilesCoordinates = function () {
        var tileExtent = {};
        tileExtent.x = {};
        tileExtent.y = {};
        var tiles = this._tiles;

        // X extent
        tileExtent.x.min = _.min(tiles, function (tile) {
            return tile.coordinates.x;
        }).coordinates.x;

        tileExtent.x.max = _.max(tiles, function (tile) {
            return tile.coordinates.x;
        }).coordinates.x;

        // Y extent
        tileExtent.y.min = _.min(tiles, function (tile) {
            return tile.coordinates.y;
        }).coordinates.y;
        tileExtent.y.max = _.max(tiles, function (tile) {
            return tile.coordinates.y;
        }).coordinates.y;

        return tileExtent;
    };
};
},{}],13:[function(require,module,exports){
/*******************************************************************************
 * Rando.Trek.js
 *
 * Trek class :
 *  Permites the build of a Trek in 3D
 *
 * @author: Célian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Trek = function (data, offsets, scene) {
        this._vertices = this._prepareVertices(data, offsets);
        this._scene = scene;

        this.spheres     = null;
        this.cylinders   = null;
        this.material    = null;
        this.mergedTreks = [];

        this.init();
    };

    /* Methods */
    RANDO.Trek.prototype.init = function () {
        this.material = new BABYLON.StandardMaterial("Trek Material", this._scene)
        this.material.diffuseColor = RANDO.SETTINGS.TREK_COLOR;
        this.material.emissiveColor = RANDO.SETTINGS.TREK_COLOR;

        this.buildTrek ();
    };

    /**
     * RANDO.Trek._prepareVertices() : translate the Trek data of the offsets attribute
     *
     * return the array of vertices
     */
    RANDO.Trek.prototype._prepareVertices = function (data, offsets) {
        var vertices = _.map(data, _.clone);

        for (var it in vertices){
            vertices[it].x += offsets.x;
            vertices[it].y = 0;
            vertices[it].z += offsets.z;
        }
        return vertices;
    };

    /**
     * RANDO.Trek.buildTrek() : builds the trek with spheres and cylinders
     */
    RANDO.Trek.prototype.buildTrek = function () {
        // Trek building ...
        console.log("Trek building... " + (Date.now() - RANDO.START_TIME) );
        var vertices    = this._vertices;
        var scene       = this._scene;
        var material    = this.material;
        var spheres     = new BABYLON.Mesh("TREK - Spheres", scene);
        var cylinders   = new BABYLON.Mesh("TREK - Cylinders", scene);
        var n_sph = 0, n_cyl = 0;

        function createSphere(vertex) {
            n_sph++;
            var sphere = BABYLON.Mesh.CreateSphere(
                "Sphere " + n_sph,
                RANDO.SETTINGS.TREK_SPH_TESSEL,
                RANDO.SETTINGS.TREK_WIDTH,
                scene
            );

            sphere.position  = vertex;
            sphere.material  = material;
            sphere.parent    = spheres;
            sphere.isVisible = false;
        };

        function createCylinder(vertexA, vertexB) {
            n_cyl++;
            var cyl_height = BABYLON.Vector3.Distance(vertexA, vertexB);
            var cylinder = BABYLON.Mesh.CreateCylinder(
                "Cylinder " + n_cyl,
                1,
                RANDO.SETTINGS.TREK_WIDTH,
                RANDO.SETTINGS.TREK_WIDTH,
                RANDO.SETTINGS.TREK_CYL_TESSEL,
                scene
            );

            cylinder.material   = material;
            cylinder.parent     = cylinders;
            cylinder.isVisible  = false;
        };

        var prev, curr = null;
        for (var it in vertices){
            prev = curr;
            var curr = new BABYLON.Vector3(
                vertices[it].x,
                vertices[it].y,
                vertices[it].z
            );

            createSphere(curr);
            if (prev) {
                createCylinder(prev, curr);
            }
        }

        // Trek built !
        console.log("Trek built ! " + (Date.now() - RANDO.START_TIME) );

        this.spheres = spheres;
        this.cylinders = cylinders;
    };

    /**
     * RANDO.Trek.drape() : drape the trek over the ground
     *      - ground : Mesh in which we drape spheres
     *      - onComplete : callback called at the end of the RANDO.Trek.prototype.
     */
    RANDO.Trek.prototype.drape = function (ground, onComplete) {
        var spheres     = this.spheres.getChildren();
        var cylinders   = this.cylinders.getChildren();
        var trek_length = spheres.length;
        var index       = 0;
        var chunk       = 100; // By chunks of 100 points
        var that        = this;

        console.log("Trek adjustments ... " + (Date.now() - RANDO.START_TIME) );
        drapeChunk();

        // Step 1 : drape the spheres over the ground
        function drapeChunk () {
            var cnt = chunk;
            while (cnt-- && index < trek_length) {
                RANDO.Utils.drapePoint(spheres[index].position, ground, RANDO.SETTINGS.TREK_OFFSET);
                ++index;
            }
            if (index < trek_length){
                setTimeout(drapeChunk, 1);
            }else {
                // At the end of draping we place cylinders
                setTimeout(placeCylinders, 1);
            }
        };

        // Step 2 : Place all cylinders between each pairs of spheres
        function placeCylinders () {
            for (var i = 0; i < trek_length-1; i++) {
                RANDO.Utils.placeCylinder(
                    cylinders[i],
                    spheres[i].position,
                    spheres[i+1].position
                );
            }

            onComplete();
            console.log("Trek adjusted ! " + (Date.now() - RANDO.START_TIME) );
        };
    };

    /**
     * RANDO.Trek.merge() : merge all elements (spheres and cylinders) of the Trek
     */
    RANDO.Trek.prototype.merge = function () {
        console.log("Trek merging ... " + (Date.now() - RANDO.START_TIME) );
        var scene       = this._scene;
        var spheres     = this.spheres.getChildren();
        var cylinders   = this.cylinders.getChildren();
        var meshes      = spheres.concat(cylinders);
        var limit       = RANDO.SETTINGS.LIMIT_VERT_BY_MESH;

        var count = 0;
        var nMergedTrek = 0;
        var buffer = [];
        for (var i = 0; i < meshes.length; i++) {
            count += meshes[i].getTotalVertices();
            // The number of vertices in the buffer is acceptable
            if (count < limit) {
                meshes[i].isVisible = false;
                buffer.push(meshes[i]);
            }
            // The number of vertices in the buffer will not be acceptable
            else {
                //... so we merge all meshes of buffer
                var mergedTrek = new BABYLON.Mesh(
                    "Merged Trek " + nMergedTrek++, scene
                );
                RANDO.Utils.mergeMeshes(mergedTrek, buffer);
                mergedTrek.material = this.material;
                this.mergedTreks.push(mergedTrek);
                // ... and we push the current mesh in a new empty buffer
                buffer = [];
                buffer.push(meshes[i]);
                count = meshes[i].getTotalVertices();
            }
        }

        // If the count never reached the limit
        if (buffer.length != 0) {
            var mergedTrek = new BABYLON.Mesh(
                "Merged Trek " + nMergedTrek++, scene
            );
            RANDO.Utils.mergeMeshes(mergedTrek, buffer);
            mergedTrek.material = this.material;

            this.mergedTreks.push(mergedTrek);
        }
        console.log("Trek merged ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Trek.updateVertices() : update this._vertices attribute
     */
    RANDO.Trek.prototype.updateVertices = function () {
        var vertices    = this._vertices;
        var spheres     = this.spheres.getChildren();
        console.assert(vertices.length == spheres.length);
        for (var it in spheres) {
            vertices[it].x = spheres[it].position.x;
            vertices[it].y = spheres[it].position.y;
            vertices[it].z = spheres[it].position.z;
        }
    };

    /**
     * RANDO.Trek.getTotalVertices() : get the total number of vertices in the trek.
     */
    RANDO.Trek.prototype.getTotalVertices = function () {
        var spheresArray    = this.spheres.getChildren();
        var cylindersArray  = this.cylinders.getChildren();
        var meshes          = spheresArray.concat(cylindersArray);

        var totalVertices = 0;
        for (var it in meshes) {
            totalVertices += meshes[it].getTotalVertices();
        }

        return totalVertices;
    };
};
},{}],14:[function(require,module,exports){
// Rando.Utils.js
// Rando utilities

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.Utils = {};

    /****    BABYLON extents     ************************/
    /**
     *  createGroundFromExtent(): Create a ground from an extent of 4 points
     *      - name : Name of the new Ground
     *      - A : northwest vertex
     *      - B : northeast vertex
     *      - C : southeast vertex
     *      - D : southwest vertex
     *      - w_subdivisions : Number of Width's subdivisions in the new Ground
     *      - h_subdivisions : Number of Height's subdivisions in the new Ground
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromExtent = function (name, A, B, C, D, w_subdivisions, h_subdivisions, scene, updatable) {
        var ground = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var grid = RANDO.Utils.createFlatGrid(A, B, C, D, w_subdivisions+ 1, h_subdivisions+ 1);
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var position = grid[row][col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(position.x, 0, position.y);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createGroundFromGrid(): Create a ground from a grid of 2D points
     *      - name : Name of the new Ground
     *      - grid : grid of 2d points (each point contains a x and a y)
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromGrid = function (name, grid, scene, updatable) {
        var ground = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var h_subdivisions = grid.length-1;
        var w_subdivisions = grid[0].length-1;

        for (row = 0; row <= h_subdivisions; row++) {
            w_subdivisions = grid[row].length-1;
            for (col = 0; col <= w_subdivisions; col++) {
                var position = grid[h_subdivisions - row][col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(position.x, position.y, position.z);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            w_subdivisions = grid[row].length-1;
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createGroundFromVertices(): Create a ground from an array of vertices
     *      - name : Name of the new Ground
     *      - vertices : Array of vertices in BABYLON.VertexBuffer.PositionKind format
     *      - w_subdivisions : Number of Width's subdivisions in the new Ground
     *      - h_subdivisions : Number of Height's subdivisions in the new Ground
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromVertices = function( name, vertices, w_subdivisions, h_subdivisions, scene, updatable) {
        console.assert(vertices.length%3 == 0);
        console.assert((vertices.length/3) == w_subdivisions*h_subdivisions,
        (vertices.length/3) + "!=" + w_subdivisions + "*" + h_subdivisions);

        var ground = BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var i = 0;
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(vertices[i], vertices[i+1], vertices[i+2]);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
                i+=3;
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createSideFromLine(): Create a side of the DEM from a line of points (top line)
     *      - name : Name of the new Ground
     *      - line : Array of points [{x: ,y: ,z: }, ...]
     *      - base : Altitude of the base line
     *      - scene : Scene which contains the new side
     *      - updatable :
     *
     */
    RANDO.Utils.createSideFromLine = function (name, line, base, scene, updatable) {
        var side = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var h_subdivisions = 1
        var w_subdivisions = line.length-1;

        // Positions, normals, and uvs
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var position = line[col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                if (row == 0) {
                    positions.push(position.x, position.y, position.z);
                } else {
                    positions.push(position.x, base, position.z);
                }

                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row/1);
            }
        }

        // Indices
        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        side.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        side.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        side.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        side.setIndices(indices);

        return side;
    }

    /**
     *  placeCylinder()
     *      - cylinder (BABYLON.Mesh): BABYLON Cylinder object
     *      - A (BABYLON.Vector3):     First Point
     *      - B (BABYLON.Vector3):     Second Point
     *
     * Place the cylinder between both points
     ****************************************************************/
    RANDO.Utils.placeCylinder = function (cylinder, A, B) {
        // Initial position at the center of the AB vector
        cylinder.position = new BABYLON.Vector3(
            (A.x+B.x)/2,
            (A.y+B.y)/2,
            (A.z+B.z)/2
        );

        // Adjust scale of cylinder
        var new_height = BABYLON.Vector3.Distance(A, B);
        cylinder.scaling.y = new_height;

        // First rotation
        var angle1 = RANDO.Utils.angleFromAxis(A, B, BABYLON.Axis.X);
        cylinder.rotate(
            BABYLON.Axis.X,
            angle1,
            BABYLON.Space.LOCAL
        );

        // Second rotation
        var H = new BABYLON.Vector3(A.x,B.y,B.z);
        var angle2 = RANDO.Utils.angleFromPoints(A, B, H);
        cylinder.rotate(
            BABYLON.Axis.Z,
            angle2,
            BABYLON.Space.LOCAL
        );

        return cylinder;
    };

    /**
     * ComputeMeshNormals() : recompute normals of a mesh (for the shadows after)
     *      - mesh: mesh to recompute
     */
    RANDO.Utils.computeMeshNormals = function (mesh) {
        var vertices = BABYLON.VertexData.ExtractFromMesh (mesh);
        BABYLON.VertexData.ComputeNormals(vertices.positions, vertices.indices, vertices.normals);
        vertices.applyToMesh(mesh);
    };

    /**
     * setMeshUvs() : set the mesh uvs taking from the object uv taken in parameter
     *      mesh: babylon mesh
     *      uvs: object js containing uvs values
     *
     * NB: format of uv object parameter :
     *      uv = {
     *          u: [],
     *          v: []
     *      }
     */
    RANDO.Utils.setMeshUvs = function (mesh, uv) {
        var uv_array = [];
        var col, row;
        for (row in uv.v) {
            for (col in uv.u) {
                uv_array.push(uv.u[col]);
                uv_array.push(uv.v[row]);
            }
        }

        console.assert(
            mesh.getVerticesData(BABYLON.VertexBuffer.UVKind).length == uv_array.length,
            "setMeshUvs() : uvs in parameter are not well sized"
        );

        mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uv_array);
    };

    /**
     * RANDO.Utils.mergeMeshes() : Merge a mesh array in only one mesh. It permites
     * to increase performance.
     *      - newMesh : future merged Mesh
     *      - arrayObj : array of Meshes to merge
     *
     * Function directly inspired from David Catuhe's one in the github wiki of BabylonJS
     * https://github.com/BabylonJS/Babylon.js/wiki/How-to-merge-meshes
     */
    RANDO.Utils.mergeMeshes = function (newMesh, arrayObj) {
        var arrayPos = [];
        var arrayNormal = [];
        var arrayUv = [];
        var arrayUv2 = [];
        var arrayColor = [];
        var arrayMatricesIndices = [];
        var arrayMatricesWeights = [];
        var arrayIndice = [];
        var savedPosition = [];
        var savedNormal = [];
        var UVKind = true;
        var UV2Kind = true;
        var ColorKind = true;
        var MatricesIndicesKind = true;
        var MatricesWeightsKind = true;
        var i = 0, it;

        for (i = 0; i != arrayObj.length ; i++) {
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.UVKind]))
                UVKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.UV2Kind]))
                UV2Kind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.ColorKind]))
                ColorKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.MatricesIndicesKind]))
                MatricesIndicesKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.MatricesWeightsKind]))
                MatricesWeightsKind = false;
        }

        for (i = 0; i != arrayObj.length ; i++) {
            var ite = 0;
            var iter = 0;
            arrayPos[i] = arrayObj[i].getVerticesData(BABYLON.VertexBuffer.PositionKind);
            arrayNormal[i] = arrayObj[i].getVerticesData(BABYLON.VertexBuffer.NormalKind);
            if (UVKind)
                arrayUv = arrayUv.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.UVKind));
            if (UV2Kind)
                arrayUv2 = arrayUv2.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.UV2Kind));
            if (ColorKind)
                arrayColor = arrayColor.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.ColorKind));
            if (MatricesIndicesKind)
                arrayMatricesIndices = arrayMatricesIndices.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind));
            if (MatricesWeightsKind)
                arrayMatricesWeights = arrayMatricesWeights.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind));

            var maxValue = savedPosition.length / 3;

            arrayObj[i].computeWorldMatrix(true);
            var worldMatrix = arrayObj[i].getWorldMatrix();

            while (ite < arrayPos[i].length) {
                var vertex = new BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(arrayPos[i][ite], arrayPos[i][ite + 1], arrayPos[i][ite + 2]), worldMatrix);
                savedPosition.push(vertex.x);
                savedPosition.push(vertex.y);
                savedPosition.push(vertex.z);
                ite = ite + 3;
            }
            while (iter < arrayNormal[i].length) {
                var vertex = new BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(arrayNormal[i][iter], arrayNormal[i][iter + 1], arrayNormal[i][iter + 2]), worldMatrix);
                savedNormal.push(vertex.x);
                savedNormal.push(vertex.y);
                savedNormal.push(vertex.z);
                iter = iter + 3;
            }
            if (i > 0) {
                var tmp = arrayObj[i].getIndices();
                for (it = 0 ; it != tmp.length; it++) {
                    tmp[it] = tmp[it] + maxValue;
                }
                arrayIndice = arrayIndice.concat(tmp);
            }
            else {
                arrayIndice = arrayObj[i].getIndices();
            }

            arrayObj[i].dispose(false);
        }

        newMesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, savedPosition, false);
        newMesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, savedNormal, false);
        if (arrayUv.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, arrayUv, false);
        if (arrayUv2.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.UV2Kind, arrayUv2, false);
        if (arrayColor.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.ColorKind, arrayColor, false);
        if (arrayMatricesIndices.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, arrayMatricesIndices, false);
        if (arrayMatricesWeights.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, arrayMatricesWeights, false);

        newMesh.setIndices(arrayIndice);
    };

    /**
     * RANDO.Utils.getSize () : get the size of a mesh
     *      - mesh : mesh
     *
     * return an object containing the width, height and deep of the mesh
     */
    RANDO.Utils.getSize = function (mesh) {
        var minmax = BABYLON.Mesh.MinMax([mesh]);

        return {
            'width'  : (minmax.max.x - minmax.min.x) ,
            'height' : (minmax.max.y - minmax.min.y) ,
            'deep'   : (minmax.max.z - minmax.min.z)
        };
    }

    /**
     * RANDO.Utils.isInExtent() :
     *  return true if the given coordinates are in the given extent
     */
    RANDO.Utils.isInExtent = function (coordinates, extent) {
        return (
            coordinates.x >= extent.x.min &&
            coordinates.x <= extent.x.max &&
            coordinates.z >= extent.z.min &&
            coordinates.z <= extent.z.max
         )? true: false;
    };

    /**
     * RANDO.Utils.getNumberOfTiles() : return the number of tiles according a zoom level and
     * a meters extent.
     */
    RANDO.Utils.getNumberOfTiles = function (zoom, extent) {
        var xTileMin = RANDO.Utils.meters2num (extent.x.min, extent.z.min, zoom).xtile;
        var xTileMax = RANDO.Utils.meters2num (extent.x.max, extent.z.max, zoom).xtile;
        var yTileMin = RANDO.Utils.meters2num (extent.x.min, extent.z.min, zoom).ytile;
        var yTileMax = RANDO.Utils.meters2num (extent.x.max, extent.z.max, zoom).ytile;
        return (xTileMax - xTileMin + 1) * (yTileMin - yTileMax + 1);
    };

    /****    GEOMETRY     ************************/
    /**tested
     * middle():
     *      A: first point
     *      B: second point
     *
     * return the middle of the segment form by A and B
     */
    RANDO.Utils.middle = function (A, B) {
        return {
            x: (A.x+B.x)/2,
            y: (A.y+B.y)/2,
            z: (A.z+B.z)/2
        };
    };

    /**tested
     * subdivide() :  interpolate a segment between 2 points A and B
     *      - n : number of points expected in result
     *      - A : first point
     *      - B : second point
     *
     * return an array of point
     *
     * NB : points are in the format : { x : .. , y : .. }
     *
     *
     * example :
     *
     *         * B                   * B
     *        /                     /
     *       /      n = 4          * M2
     *      /      ---->          /
     *     /                     * M1
     *    /                     /
     * A *                    A*
     *
     *          result : [A, M1, M2, B]
     *
     */
    RANDO.Utils.subdivide = function (n, A, B) {

        if (n<=0) return null;

        if (n==1) return A;

        if (n==2) return [A,B];

        if (n>=3) {
            var dx = (B.x-A.x)/(n-1);
            var dy = (B.y-A.y)/(n-1);

            var x = A.x;
            var y = A.y;

            var res = [];
            res.push(A);
            for (var i=0; i<n-2; i++){
                x += dx;
                y += dy;
                res.push({
                    'x' : x,
                    'y' : y
                });
            }
            res.push(B);
            return res;
        }
    }

    /**tested
     * createGrid() : create a grid of points for all type of quadrilateres, in particular
     *  these which are not square or rectangle.
     *      - A, B, C, D :  vertices of quadrilatere to subdivide
     *      - n_verti :     number of points in vertical size
     *      - n_horiz :     number of points in horizontal size
     *
     *
     * NB : * n_verti and n_horiz cannot be invert
     *      * the order of input points is also important, it determines
     * the order of output points :
     *  [A, ...., B,    -> first line
     *   ..........,
     *   D, ...., C]    -> last line
     *
     *
     * Example of quadrilatere :
     * D *------------------* C
     *   |                   \
     *   |                    \
     *   |                     \
     *   |                      \
     *   |                       \
     *   |                        \
     * A *-------------------------* B
     *
     */
    RANDO.Utils.createFlatGrid = function (A, B, C, D, n_horiz, n_verti) {
        if(n_verti<=0) return null;
        if(n_horiz<=0) return null;

        // subdivide both sides of the quad
        var west_side = RANDO.Utils.subdivide(n_verti, A, D);
        var east_side = RANDO.Utils.subdivide(n_verti, B, C);
        var grid = [];
        console.assert(west_side.length == east_side.length,
            "createGrid : west_side.length != east_side.length \n" +
            west_side.length +
            " != " +
            east_side.length
        );


        for (var j=0; j < n_verti; j++){
            // subidivide lines
            var line = RANDO.Utils.subdivide(n_horiz, west_side[j], east_side[j]);
            grid.push(line);
        }
        return grid;
    }

    /**
     *
     *
     */
    RANDO.Utils.createElevationGrid = function (xmin, xmax, ymin, ymax, altitudes) {
        var A = {
            'x' : xmin,
            'y' : ymin
        };
        var B = {
            'x' : xmax,
            'y' : ymin
        };
        var C = {
            'x' : xmax,
            'y' : ymax
        };
        var D = {
            'x' : xmin,
            'y' : ymax
        };
        var row, col;

        // Creates grid from extent datas
        var grid = RANDO.Utils.createFlatGrid(
            A, B, C, D,
            altitudes[0].length,
            altitudes.length
        );

        // Gives altitudes to the grid
        for (row in altitudes){
            for (col in altitudes[row]){
                grid[row][col].z = grid[row][col].y;
                grid[row][col].y = altitudes[row][col];
            }
        }
        return grid;
    };

    /**tested
     * angleFromAxis(): get an angle for a rotation
     *      - A     (BABYLON.Vector3) : First point
     *      - B     (BABYLON.Vector3) : Second point
     *      - axis  (BABYLON.Vector3) : Axis of rotation
     *
     *
     * Example with a rotation around y axis
     *
     *                     _ z
     *       .->           |
     *      /              |     * B
     *                     |    /
     *                     |   /
     *                     |  /
     *                     | /
     *                     |/               x
     *       --------------*--------------->
     *                     |A
     *                     |
     *
     * NB : It uses global axis only
     *  (1, 0, 0), (0, 1, 0), or (0, 0, 1)
     *
     */
    RANDO.Utils.angleFromAxis = function (A, B, axis) {
        var angle, AH, AB;
        switch (axis){
            case BABYLON.Axis.X :
                if(A.y == B.y && A.z == B.z) // It don't need rotation around X
                    return 0;
                AH = B.y-A.y;
                AB = Math.sqrt(
                    Math.pow(B.y-A.y, 2)+
                    Math.pow(B.z-A.z, 2)
                );
                angle = Math.acos(AH/AB);
                if (B.z < A.z)
                    return -angle;
                return angle;
            break;
            case BABYLON.Axis.Y :
                if(A.x == B.x && A.z == B.z) // It don't need rotation around Y
                    return 0;
                AH = B.z-A.z;
                AB = Math.sqrt(
                    Math.pow(B.z-A.z, 2)+
                    Math.pow(B.x-A.x, 2)
                );

                angle = Math.acos(AH/AB);
                //if (angle > Math.PI/2)
                    //angle = -((Math.PI/2)-angle)
                if (B.x < A.x)
                    return -angle;
                return angle;
            break;
            case BABYLON.Axis.Z :
                if(A.x == B.x && A.y == B.y) // It don't need rotation around Z
                        return 0;
                AH = B.x-A.x;
                AB = Math.sqrt(
                    Math.pow(B.x-A.x, 2)+
                    Math.pow(B.y-A.y, 2)
                );
                angle = Math.acos(AH/AB);
                if (B.y < A.y)
                    return -angle;
                return angle;
        }
        return null;
    }

    /**
     * angleFromPoints() : get an angle from 3 points for a rotation around an axis
     *  orthogonal of the plan formed by the 3 points
     *      - A (BABYLON.Vector3) : First point
     *      - B (BABYLON.Vector3) : Second point
     *      - H (BABYLON.Vector3) : Orthogonal projection of B over the axis
     *
     *
     * Example with a rotation around z axis
     *
     *                     _ x
     *       .->           |
     *      /            H *     * B
     *                     |    /
     *                     |   /
     *                     |  /
     *                     | /
     *                     |/               y
     *       --------------*--------------->
     *                     |A
     *                     |
     *
     * NB : It is used when we don't have especially classical global axis. For example
     * after a first rotation.
     *
     */
    RANDO.Utils.angleFromPoints = function (A, B, H) {
        var AH = BABYLON.Vector3.Distance(A, H);
        var AB = BABYLON.Vector3.Distance(A, B);
        var angle = Math.acos(AH/AB);

        // Check the sign
        if (H.x < B.x)
            return -angle;
        return angle;
    };

    RANDO.Utils.roundRect = function (context, x, y, w, h, radius) {
        var r = x + w;
        var b = y + h;
        context.beginPath();
        context.lineWidth="4";
        context.moveTo(x+radius, y);
        context.lineTo(r-radius, y);
        context.quadraticCurveTo(r, y, r, y+radius);
        context.lineTo(r, y+h-radius);
        context.quadraticCurveTo(r, b, r-radius, b);
        context.lineTo(x+radius, b);
        context.quadraticCurveTo(x, b, x, b-radius);
        context.lineTo(x, y+radius);
        context.quadraticCurveTo(x, y, x+radius, y);
        context.stroke();
        context.fill()
    };

    /**tested
     *  scaleArray2() : multiply all values of 2-dimensions array by a scale value
     *      - array2 : original array
     *      - scale : scale value
     *
     * return a new array which contains all values of array2 multiplied
     */
    RANDO.Utils.scaleArray2 = function (array2, scale) {
        var result = [];
        for (var row in array2) {
            var line = [];
            for (var col in array2[row]) {
                line.push(array2[row][col] * scale);
            }
            result.push(line);
        }
        return result;
    };


    /****    GETTERS     ************************/
    /**tested
     * getUrlFromCoordinates(): get the url of a tile texture
     *      z : level of zoom
     *      x : x coordinates of tile
     *      y : y coordinates of tile
     *
     */
    RANDO.Utils.replaceUrlCoordinates = function (url, z, x, y) {
        var subdomains = RANDO.SETTINGS.TILE_TEX_URL_SUBDOMAINS,
            index = Math.abs(x + y) % subdomains.length,
            subdomain = subdomains[index];

        url = url.replace("{s}", subdomain);
        url = url.replace("{z}", z);
        url = url.replace("{x}", x);
        url = url.replace("{y}", y);

        return url;
    }


    /****    CONVERSIONS     ************************/
    /**tested
     * toMeters() : convert a point in latitude/longitude to x/y meters coordinates
     *      - latlng : point in lat/lng
     *
     * return a point in meters
     *
     * { lat : .. , lng : .. }  ---> { x : .. , y : .. }
     */
    RANDO.Utils.toMeters = function (latlng) {

        var R = 6378137;

        var d = Math.PI / 180;
        var max = 1 - 1*Math.pow(10, -15);
        var sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);

        return {
            x : R * latlng.lng * d,
            y : R * Math.log((1 + sin) / (1 - sin)) / 2
        };
    };

    /**tested
     * toLatlng() : convert a point in x/y meters coordinates to latitude/longitude
     *      - point : point in x/y meters coordinates
     *
     * return a point in lat/long
     *
     * { x : .. , y : .. }  --->  { lat : .. , lng : .. }
     */
    RANDO.Utils.toLatlng = function (point) {

        var R = 6378137;

        var d = 180 / Math.PI;

        return {
            lat: (2 * Math.atan(Math.exp(point.y / R)) - (Math.PI / 2)) * d,
            lng: point.x * d / R
        };
    }

    /**
     * getMetersExtent() : get the extent of the DEM in meters
     *      - extent : extent of the DEM in latitudes/longitudes
     */
    RANDO.Utils.getMetersExtent = function (extent) {
        var nw = RANDO.Utils.toMeters(extent.northwest);
        var ne = RANDO.Utils.toMeters(extent.northeast);
        var sw = RANDO.Utils.toMeters(extent.southwest);
        var se = RANDO.Utils.toMeters(extent.southeast);

        return {
            'x' : {
                'min' : Math.min(nw.x, sw.x),
                'max' : Math.min(ne.x, se.x)
            },
            'y' : extent.altitudes,
            'z' : {
                'min' : Math.min(sw.y, se.y),
                'max' : Math.min(nw.y, ne.y)
            },
        }
    };

    /**
     * meters2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - x: x coordinate of point (in meters)
     *      - y: y coordinate of point (in meters)
     *      - zoom: zoom level
     */
    RANDO.Utils.meters2num = function (x, y, zoom) {
        var tmp_ll = RANDO.Utils.toLatlng({
            'x': x,
            'y': y
        });
        return RANDO.Utils.deg2num(tmp_ll.lat, tmp_ll.lng, zoom);
    };

    /**
     * deg2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - lat_deg: latitude  coordinate of point (in degrees)
     *      - lng_deg: longitude coordinate of point (in degrees)
     *      - zoom: zoom level
     */
    RANDO.Utils.deg2num = function (lat_deg, lng_deg, zoom) {
        var lat_rad = lat_deg*Math.PI/180;
        var n = Math.pow(2.0, zoom);
        var xtile = Math.floor((lng_deg + 180.0) / 360.0 * n);
        var ytile = Math.floor((1.0 - Math.log(Math.tan(lat_rad) + (1 / Math.cos(lat_rad))) / Math.PI) / 2.0 * n);
        return {
            "xtile": xtile,
            "ytile": ytile
        };
    };

    /**
     * rad2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - lat_rad: latitude  coordinate of point (in radians)
     *      - lng_rad: longitude coordinate of point (in radians)
     *      - zoom: zoom level
     */
    RANDO.Utils.rad2num = function (lat_rad, lng_rad, zoom) {
        var lat_deg = lat_rad*180/Math.PI;
        var lng_deg = lng_rad*180/Math.PI;
        var n = Math.pow(2.0, zoom);
        var xtile = Math.floor((lng_deg + 180.0) / 360.0 * n);
        var ytile = Math.floor((1.0 - Math.log(Math.tan(lat_rad) + (1 / Math.cos(lat_rad))) / Math.PI) / 2.0 * n);
        return {
            "xtile": xtile,
            "ytile": ytile
        };
    };


    /****    TRANSLATIONS     ************************/
    /**
     * drapePoint() : drape a point over the ground
     *      - point: point to drape
     *      - dem: ground
     */
    RANDO.Utils.drapePoint = function (point, dem, offset) {
        var it;
        if (typeof(offset) === "undefined") {
            var offset = 0;
        }
        var children = dem.getChildren();
        var ray =  new BABYLON.Ray(point, BABYLON.Axis.Y);
        for (it in children) {
            var pick = children[it].intersects(ray, true);
            if (pick.pickedPoint) {
                point.y = pick.pickedPoint.y + offset;
            }
        }
    }

};

},{}],"BezierPlugin":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 1.3.4
 * DATE: 2014-11-15
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.4",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._round = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._round[p]) {
								val = Math.round(val);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._roundProps = function(lookup, value) {
			var op = this._overwriteProps,
				i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("../TweenLite.js");
		module.exports = getGlobal();
	}
}("BezierPlugin"));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../TweenLite.js":"TweenLite"}],"DirectionalRotationPlugin":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 0.2.1
 * DATE: 2014-07-17
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"EasePack":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 1.15.2
 * DATE: 2015-01-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true), 
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;
			
		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);
		
		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();	
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");
		
		return Back;
		
	}, true);

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"TimelineLite":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.1
 * DATE: 2015-03-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_blankArray = [],
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {
				var tl = tween._timeline,
					time = tl._totalTime,
					startTime = tween._startTime,
					reversed = (tween._rawPrevTime < 0 || (tween._rawPrevTime === 0 && tl._reversed)),//don't use tween.ratio because if the playhead lands exactly on top of the addPause(), ratio will be 1 even if the master timeline was reversed (which is correct). The key here is to sense the direction of the playhead.
					next = reversed ? 0 : _tinyNum,
					prev = reversed ? _tinyNum : 0,
					sibling;
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = prev;
						sibling = sibling._prev;
					}
					sibling = tween._next;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = next;
						sibling = sibling._next;
					}
					if (callback) {
						callback.apply(scope || tl, params || _blankArray);
					}
					if (this._forcingPlayhead || !tl._paused) { //the callback could have called resume().
						tl.seek(time);
					}
				}
			},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.16.1";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				if (vars.startAt) {
					vars.startAt = _copy(vars.startAt);
				}
				tl.to(targets[i], duration, _copy(vars), i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				return this._remove(value, false);
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce;
			if (time >= totalDur) {
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			if (this.totalDuration() !== 0) if (value !== 0) {
				this.timeScale(this._totalDuration / value);
			}
			return this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);


}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("./TweenLite.js"); //dependency
		module.exports = getGlobal();
	}
}("TimelineLite"));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TweenLite.js":"TweenLite"}],"TweenLite":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.1
 * DATE: 2015-03-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
(function(window, moduleName) {

		"use strict";
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node
								module.exports = cl;
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame),
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function() {
				if (_id !== null) {
					_self.sleep();
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF && _self.frame < 5) {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.16.1";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},

			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},

			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}

				} else {
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}
				if (pt) if (pt._next) {
					pt._next._prev = pt;
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration) {
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i])) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.10.1";
		TweenPlugin.API = 2;
		p._firstPT = null;

		p._addTween = function(target, prop, start, end, overwriteProp, round) {
			var c, pt;
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {
					pt._next._prev = pt;
				}
				return pt;
			}
		};

		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.r) {
					val = Math.round(val);
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
		};

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._roundProps = function(lookup, value) {
			var pt = this._firstPT;
			while (pt) {
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenLite");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"babylonjs":[function(require,module,exports){
/*! Babylon 2014-08-08 */
var BABYLON;!function(a){var b=function(){function a(a,b,c){"undefined"==typeof a&&(a=0),"undefined"==typeof b&&(b=0),"undefined"==typeof c&&(c=0),this.r=a,this.g=b,this.b=c}return a.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"},a.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.r,a[b+1]=this.g,a[b+2]=this.b},a.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},a.prototype.multiply=function(b){return new a(this.r*b.r,this.g*b.g,this.b*b.b)},a.prototype.multiplyToRef=function(a,b){b.r=this.r*a.r,b.g=this.g*a.g,b.b=this.b*a.b},a.prototype.equals=function(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b},a.prototype.scale=function(b){return new a(this.r*b,this.g*b,this.b*b)},a.prototype.scaleToRef=function(a,b){b.r=this.r*a,b.g=this.g*a,b.b=this.b*a},a.prototype.add=function(b){return new a(this.r+b.r,this.g+b.g,this.b+b.b)},a.prototype.addToRef=function(a,b){b.r=this.r+a.r,b.g=this.g+a.g,b.b=this.b+a.b},a.prototype.subtract=function(b){return new a(this.r-b.r,this.g-b.g,this.b-b.b)},a.prototype.subtractToRef=function(a,b){b.r=this.r-a.r,b.g=this.g-a.g,b.b=this.b-a.b},a.prototype.clone=function(){return new a(this.r,this.g,this.b)},a.prototype.copyFrom=function(a){this.r=a.r,this.g=a.g,this.b=a.b},a.prototype.copyFromFloats=function(a,b,c){this.r=a,this.g=b,this.b=c},a.FromArray=function(b){return new a(b[0],b[1],b[2])},a.FromInts=function(b,c,d){return new a(b/255,c/255,d/255)},a.Lerp=function(b,c,d){var e=b.r+(c.r-b.r)*d,f=b.g+(c.g-b.g)*d,g=b.b+(c.b-b.b)*d;return new a(e,f,g)},a.Red=function(){return new a(1,0,0)},a.Green=function(){return new a(0,1,0)},a.Blue=function(){return new a(0,0,1)},a.Black=function(){return new a(0,0,0)},a.White=function(){return new a(1,1,1)},a.Purple=function(){return new a(.5,0,.5)},a.Magenta=function(){return new a(1,0,1)},a.Yellow=function(){return new a(1,1,0)},a.Gray=function(){return new a(.5,.5,.5)},a}();a.Color3=b;var c=function(){function b(a,b,c,d){this.r=a,this.g=b,this.b=c,this.a=d}return b.prototype.addInPlace=function(a){this.r+=a.r,this.g+=a.g,this.b+=a.b,this.a+=a.a},b.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},b.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.r,a[b+1]=this.g,a[b+2]=this.b,a[b+3]=this.a},b.prototype.add=function(a){return new b(this.r+a.r,this.g+a.g,this.b+a.b,this.a+a.a)},b.prototype.subtract=function(a){return new b(this.r-a.r,this.g-a.g,this.b-a.b,this.a-a.a)},b.prototype.subtractToRef=function(a,b){b.r=this.r-a.r,b.g=this.g-a.g,b.b=this.b-a.b,b.a=this.a-a.a},b.prototype.scale=function(a){return new b(this.r*a,this.g*a,this.b*a,this.a*a)},b.prototype.scaleToRef=function(a,b){b.r=this.r*a,b.g=this.g*a,b.b=this.b*a,b.a=this.a*a},b.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"},b.prototype.clone=function(){return new b(this.r,this.g,this.b,this.a)},b.Lerp=function(c,d,e){var f=new b(0,0,0,0);return a.Color4.LerpToRef(c,d,e,f),f},b.LerpToRef=function(a,b,c,d){d.r=a.r+(b.r-a.r)*c,d.g=a.g+(b.g-a.g)*c,d.b=a.b+(b.b-a.b)*c,d.a=a.a+(b.a-a.a)*c},b.FromArray=function(a,c){return"undefined"==typeof c&&(c=0),new b(a[c],a[c+1],a[c+2],a[c+3])},b.FromInts=function(a,c,d,e){return new b(a/255,c/255,d/255,e/255)},b}();a.Color4=c;var d=function(){function a(a,b){this.x=a,this.y=b}return a.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+"}"},a.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.x,a[b+1]=this.y},a.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},a.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y},a.prototype.add=function(b){return new a(this.x+b.x,this.y+b.y)},a.prototype.subtract=function(b){return new a(this.x-b.x,this.y-b.y)},a.prototype.negate=function(){return new a(-this.x,-this.y)},a.prototype.scaleInPlace=function(a){this.x*=a,this.y*=a},a.prototype.scale=function(b){return new a(this.x*b,this.y*b)},a.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y},a.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},a.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y},a.prototype.normalize=function(){var a=this.length();if(0!==a){var b=1/a;this.x*=b,this.y*=b}},a.prototype.clone=function(){return new a(this.x,this.y)},a.Zero=function(){return new a(0,0)},a.FromArray=function(b,c){return c||(c=0),new a(b[c],b[c+1])},a.CatmullRom=function(b,c,d,e,f){var g=f*f,h=f*g,i=.5*(2*c.x+(-b.x+d.x)*f+(2*b.x-5*c.x+4*d.x-e.x)*g+(-b.x+3*c.x-3*d.x+e.x)*h),j=.5*(2*c.y+(-b.y+d.y)*f+(2*b.y-5*c.y+4*d.y-e.y)*g+(-b.y+3*c.y-3*d.y+e.y)*h);return new a(i,j)},a.Clamp=function(b,c,d){var e=b.x;e=e>d.x?d.x:e,e=e<c.x?c.x:e;var f=b.y;return f=f>d.y?d.y:f,f=f<c.y?c.y:f,new a(e,f)},a.Hermite=function(b,c,d,e,f){var g=f*f,h=f*g,i=2*h-3*g+1,j=-2*h+3*g,k=h-2*g+f,l=h-g,m=b.x*i+d.x*j+c.x*k+e.x*l,n=b.y*i+d.y*j+c.y*k+e.y*l;return new a(m,n)},a.Lerp=function(b,c,d){var e=b.x+(c.x-b.x)*d,f=b.y+(c.y-b.y)*d;return new a(e,f)},a.Dot=function(a,b){return a.x*b.x+a.y*b.y},a.Normalize=function(a){var b=a.clone();return b.normalize(),b},a.Minimize=function(b,c){var d=b.x<c.x?b.x:c.x,e=b.y<c.y?b.y:c.y;return new a(d,e)},a.Maximize=function(b,c){var d=b.x>c.x?b.x:c.x,e=b.y>c.y?b.y:c.y;return new a(d,e)},a.Transform=function(b,c){var d=b.x*c.m[0]+b.y*c.m[4],e=b.x*c.m[1]+b.y*c.m[5];return new a(d,e)},a.Distance=function(b,c){return Math.sqrt(a.DistanceSquared(b,c))},a.DistanceSquared=function(a,b){var c=a.x-b.x,d=a.y-b.y;return c*c+d*d},a}();a.Vector2=d;var e=function(){function b(a,b,c){this.x=a,this.y=b,this.z=c}return b.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+"}"},b.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},b.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.x,a[b+1]=this.y,a[b+2]=this.z},b.prototype.addInPlace=function(a){this.x+=a.x,this.y+=a.y,this.z+=a.z},b.prototype.add=function(a){return new b(this.x+a.x,this.y+a.y,this.z+a.z)},b.prototype.addToRef=function(a,b){b.x=this.x+a.x,b.y=this.y+a.y,b.z=this.z+a.z},b.prototype.subtractInPlace=function(a){this.x-=a.x,this.y-=a.y,this.z-=a.z},b.prototype.subtract=function(a){return new b(this.x-a.x,this.y-a.y,this.z-a.z)},b.prototype.subtractToRef=function(a,b){b.x=this.x-a.x,b.y=this.y-a.y,b.z=this.z-a.z},b.prototype.subtractFromFloats=function(a,c,d){return new b(this.x-a,this.y-c,this.z-d)},b.prototype.subtractFromFloatsToRef=function(a,b,c,d){d.x=this.x-a,d.y=this.y-b,d.z=this.z-c},b.prototype.negate=function(){return new b(-this.x,-this.y,-this.z)},b.prototype.scaleInPlace=function(a){this.x*=a,this.y*=a,this.z*=a},b.prototype.scale=function(a){return new b(this.x*a,this.y*a,this.z*a)},b.prototype.scaleToRef=function(a,b){b.x=this.x*a,b.y=this.y*a,b.z=this.z*a},b.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y&&this.z===a.z},b.prototype.equalsWithEpsilon=function(b){return Math.abs(this.x-b.x)<a.Engine.Epsilon&&Math.abs(this.y-b.y)<a.Engine.Epsilon&&Math.abs(this.z-b.z)<a.Engine.Epsilon},b.prototype.equalsToFloats=function(a,b,c){return this.x===a&&this.y===b&&this.z===c},b.prototype.multiplyInPlace=function(a){this.x*=a.x,this.y*=a.y,this.z*=a.z},b.prototype.multiply=function(a){return new b(this.x*a.x,this.y*a.y,this.z*a.z)},b.prototype.multiplyToRef=function(a,b){b.x=this.x*a.x,b.y=this.y*a.y,b.z=this.z*a.z},b.prototype.multiplyByFloats=function(a,c,d){return new b(this.x*a,this.y*c,this.z*d)},b.prototype.divide=function(a){return new b(this.x/a.x,this.y/a.y,this.z/a.z)},b.prototype.divideToRef=function(a,b){b.x=this.x/a.x,b.y=this.y/a.y,b.z=this.z/a.z},b.prototype.MinimizeInPlace=function(a){a.x<this.x&&(this.x=a.x),a.y<this.y&&(this.y=a.y),a.z<this.z&&(this.z=a.z)},b.prototype.MaximizeInPlace=function(a){a.x>this.x&&(this.x=a.x),a.y>this.y&&(this.y=a.y),a.z>this.z&&(this.z=a.z)},b.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},b.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z},b.prototype.normalize=function(){var a=this.length();if(0!==a){var b=1/a;this.x*=b,this.y*=b,this.z*=b}},b.prototype.clone=function(){return new b(this.x,this.y,this.z)},b.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y,this.z=a.z},b.prototype.copyFromFloats=function(a,b,c){this.x=a,this.y=b,this.z=c},b.FromArray=function(a,c){return c||(c=0),new b(a[c],a[c+1],a[c+2])},b.FromArrayToRef=function(a,b,c){c.x=a[b],c.y=a[b+1],c.z=a[b+2]},b.FromFloatArrayToRef=function(a,b,c){c.x=a[b],c.y=a[b+1],c.z=a[b+2]},b.FromFloatsToRef=function(a,b,c,d){d.x=a,d.y=b,d.z=c},b.Zero=function(){return new b(0,0,0)},b.Up=function(){return new b(0,1,0)},b.TransformCoordinates=function(a,c){var d=b.Zero();return b.TransformCoordinatesToRef(a,c,d),d},b.TransformCoordinatesToRef=function(a,b,c){var d=a.x*b.m[0]+a.y*b.m[4]+a.z*b.m[8]+b.m[12],e=a.x*b.m[1]+a.y*b.m[5]+a.z*b.m[9]+b.m[13],f=a.x*b.m[2]+a.y*b.m[6]+a.z*b.m[10]+b.m[14],g=a.x*b.m[3]+a.y*b.m[7]+a.z*b.m[11]+b.m[15];c.x=d/g,c.y=e/g,c.z=f/g},b.TransformCoordinatesFromFloatsToRef=function(a,b,c,d,e){var f=a*d.m[0]+b*d.m[4]+c*d.m[8]+d.m[12],g=a*d.m[1]+b*d.m[5]+c*d.m[9]+d.m[13],h=a*d.m[2]+b*d.m[6]+c*d.m[10]+d.m[14],i=a*d.m[3]+b*d.m[7]+c*d.m[11]+d.m[15];e.x=f/i,e.y=g/i,e.z=h/i},b.TransformNormal=function(a,c){var d=b.Zero();return b.TransformNormalToRef(a,c,d),d},b.TransformNormalToRef=function(a,b,c){c.x=a.x*b.m[0]+a.y*b.m[4]+a.z*b.m[8],c.y=a.x*b.m[1]+a.y*b.m[5]+a.z*b.m[9],c.z=a.x*b.m[2]+a.y*b.m[6]+a.z*b.m[10]},b.TransformNormalFromFloatsToRef=function(a,b,c,d,e){e.x=a*d.m[0]+b*d.m[4]+c*d.m[8],e.y=a*d.m[1]+b*d.m[5]+c*d.m[9],e.z=a*d.m[2]+b*d.m[6]+c*d.m[10]},b.CatmullRom=function(a,c,d,e,f){var g=f*f,h=f*g,i=.5*(2*c.x+(-a.x+d.x)*f+(2*a.x-5*c.x+4*d.x-e.x)*g+(-a.x+3*c.x-3*d.x+e.x)*h),j=.5*(2*c.y+(-a.y+d.y)*f+(2*a.y-5*c.y+4*d.y-e.y)*g+(-a.y+3*c.y-3*d.y+e.y)*h),k=.5*(2*c.z+(-a.z+d.z)*f+(2*a.z-5*c.z+4*d.z-e.z)*g+(-a.z+3*c.z-3*d.z+e.z)*h);return new b(i,j,k)},b.Clamp=function(a,c,d){var e=a.x;e=e>d.x?d.x:e,e=e<c.x?c.x:e;var f=a.y;f=f>d.y?d.y:f,f=f<c.y?c.y:f;var g=a.z;return g=g>d.z?d.z:g,g=g<c.z?c.z:g,new b(e,f,g)},b.Hermite=function(a,c,d,e,f){var g=f*f,h=f*g,i=2*h-3*g+1,j=-2*h+3*g,k=h-2*g+f,l=h-g,m=a.x*i+d.x*j+c.x*k+e.x*l,n=a.y*i+d.y*j+c.y*k+e.y*l,o=a.z*i+d.z*j+c.z*k+e.z*l;return new b(m,n,o)},b.Lerp=function(a,c,d){var e=a.x+(c.x-a.x)*d,f=a.y+(c.y-a.y)*d,g=a.z+(c.z-a.z)*d;return new b(e,f,g)},b.Dot=function(a,b){return a.x*b.x+a.y*b.y+a.z*b.z},b.Cross=function(a,c){var d=b.Zero();return b.CrossToRef(a,c,d),d},b.CrossToRef=function(a,b,c){c.x=a.y*b.z-a.z*b.y,c.y=a.z*b.x-a.x*b.z,c.z=a.x*b.y-a.y*b.x},b.Normalize=function(a){var c=b.Zero();return b.NormalizeToRef(a,c),c},b.NormalizeToRef=function(a,b){b.copyFrom(a),b.normalize()},b.Project=function(c,d,e,f){var g=f.width,h=f.height,i=f.x,j=f.y,k=a.Matrix.FromValues(g/2,0,0,0,0,-h/2,0,0,0,0,1,0,i+g/2,h/2+j,0,1),l=d.multiply(e).multiply(k);return b.TransformCoordinates(c,l)},b.Unproject=function(b,c,d,e,f,g){var h=e.multiply(f).multiply(g);h.invert(),b.x=b.x/c*2-1,b.y=-(b.y/d*2-1);var i=a.Vector3.TransformCoordinates(b,h),j=b.x*h.m[3]+b.y*h.m[7]+b.z*h.m[11]+h.m[15];return a.Tools.WithinEpsilon(j,1)&&(i=i.scale(1/j)),i},b.Minimize=function(a,b){var c=a.clone();return c.MinimizeInPlace(b),c},b.Maximize=function(a,b){var c=a.clone();return c.MaximizeInPlace(b),c},b.Distance=function(a,c){return Math.sqrt(b.DistanceSquared(a,c))},b.DistanceSquared=function(a,b){var c=a.x-b.x,d=a.y-b.y,e=a.z-b.z;return c*c+d*d+e*e},b.Center=function(a,b){var c=a.add(b);return c.scaleInPlace(.5),c},b}();a.Vector3=e;var f=function(){function a(a,b,c,d){"undefined"==typeof a&&(a=0),"undefined"==typeof b&&(b=0),"undefined"==typeof c&&(c=0),"undefined"==typeof d&&(d=0),this.x=a,this.y=b,this.z=c,this.w=d}return a.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+" W:"+this.w+"}"},a.prototype.asArray=function(){return[this.x,this.y,this.z,this.w]},a.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y&&this.z===a.z&&this.w===a.w},a.prototype.clone=function(){return new a(this.x,this.y,this.z,this.w)},a.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w},a.prototype.add=function(b){return new a(this.x+b.x,this.y+b.y,this.z+b.z,this.w+b.w)},a.prototype.subtract=function(b){return new a(this.x-b.x,this.y-b.y,this.z-b.z,this.w-b.w)},a.prototype.scale=function(b){return new a(this.x*b,this.y*b,this.z*b,this.w*b)},a.prototype.multiply=function(b){var c=new a(0,0,0,1);return this.multiplyToRef(b,c),c},a.prototype.multiplyToRef=function(a,b){b.x=this.x*a.w+this.y*a.z-this.z*a.y+this.w*a.x,b.y=-this.x*a.z+this.y*a.w+this.z*a.x+this.w*a.y,b.z=this.x*a.y-this.y*a.x+this.z*a.w+this.w*a.z,b.w=-this.x*a.x-this.y*a.y-this.z*a.z+this.w*a.w},a.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},a.prototype.normalize=function(){var a=1/this.length();this.x*=a,this.y*=a,this.z*=a,this.w*=a},a.prototype.toEulerAngles=function(){var a=this.x,b=this.y,c=this.z,d=this.w,f=a*a,g=b*b,h=c*c,i=Math.atan2(2*(b*d-a*c),1-2*(g+h)),j=Math.asin(2*(a*b+c*d)),k=Math.atan2(2*(a*d-b*c),1-2*(f+h)),l=a*b+c*d;return l>.499?(i=2*Math.atan2(a,d),k=0):-.499>l&&(i=-2*Math.atan2(a,d),k=0),new e(j,i,k)},a.prototype.toRotationMatrix=function(a){var b=this.x*this.x,c=this.y*this.y,d=this.z*this.z,e=this.x*this.y,f=this.z*this.w,g=this.z*this.x,h=this.y*this.w,i=this.y*this.z,j=this.x*this.w;a.m[0]=1-2*(c+d),a.m[1]=2*(e+f),a.m[2]=2*(g-h),a.m[3]=0,a.m[4]=2*(e-f),a.m[5]=1-2*(d+b),a.m[6]=2*(i+j),a.m[7]=0,a.m[8]=2*(g+h),a.m[9]=2*(i-j),a.m[10]=1-2*(c+b),a.m[11]=0,a.m[12]=0,a.m[13]=0,a.m[14]=0,a.m[15]=1},a.prototype.fromRotationMatrix=function(a){var b,c=a.m,d=c[0],e=c[4],f=c[8],g=c[1],h=c[5],i=c[9],j=c[2],k=c[6],l=c[10],m=d+h+l;return m>0?(b=.5/Math.sqrt(m+1),this.w=.25/b,this.x=(k-i)*b,this.y=(f-j)*b,void(this.z=(g-e)*b)):d>h&&d>l?(b=2*Math.sqrt(1+d-h-l),this.w=(k-i)/b,this.x=.25*b,this.y=(e+g)/b,void(this.z=(f+j)/b)):h>l?(b=2*Math.sqrt(1+h-d-l),this.w=(f-j)/b,this.x=(e+g)/b,this.y=.25*b,void(this.z=(i+k)/b)):(b=2*Math.sqrt(1+l-d-h),this.w=(g-e)/b,this.x=(f+j)/b,this.y=(i+k)/b,void(this.z=.25*b))},a.RotationAxis=function(b,c){var d=new a,e=Math.sin(c/2);return d.w=Math.cos(c/2),d.x=b.x*e,d.y=b.y*e,d.z=b.z*e,d},a.FromArray=function(b,c){return c||(c=0),new a(b[c],b[c+1],b[c+2],b[c+3])},a.RotationYawPitchRoll=function(b,c,d){var e=new a;return a.RotationYawPitchRollToRef(b,c,d,e),e},a.RotationYawPitchRollToRef=function(a,b,c,d){var e=.5*c,f=.5*b,g=.5*a,h=Math.sin(e),i=Math.cos(e),j=Math.sin(f),k=Math.cos(f),l=Math.sin(g),m=Math.cos(g);d.x=m*j*i+l*k*h,d.y=l*k*i-m*j*h,d.z=m*k*h-l*j*i,d.w=m*k*i+l*j*h},a.Slerp=function(b,c,d){var e,f,g=d,h=b.x*c.x+b.y*c.y+b.z*c.z+b.w*c.w,i=!1;if(0>h&&(i=!0,h=-h),h>.999999)f=1-g,e=i?-g:g;else{var j=Math.acos(h),k=1/Math.sin(j);f=Math.sin((1-g)*j)*k,e=i?-Math.sin(g*j)*k:Math.sin(g*j)*k}return new a(f*b.x+e*c.x,f*b.y+e*c.y,f*b.z+e*c.z,f*b.w+e*c.w)},a}();a.Quaternion=f;var g=function(){function a(){this.m=new Float32Array(16)}return a.prototype.isIdentity=function(){return 1!=this.m[0]||1!=this.m[5]||1!=this.m[10]||1!=this.m[15]?!1:0!=this.m[1]||0!=this.m[2]||0!=this.m[3]||0!=this.m[4]||0!=this.m[6]||0!=this.m[7]||0!=this.m[8]||0!=this.m[9]||0!=this.m[11]||0!=this.m[12]||0!=this.m[13]||0!=this.m[14]?!1:!0},a.prototype.determinant=function(){var a=this.m[10]*this.m[15]-this.m[11]*this.m[14],b=this.m[9]*this.m[15]-this.m[11]*this.m[13],c=this.m[9]*this.m[14]-this.m[10]*this.m[13],d=this.m[8]*this.m[15]-this.m[11]*this.m[12],e=this.m[8]*this.m[14]-this.m[10]*this.m[12],f=this.m[8]*this.m[13]-this.m[9]*this.m[12];return this.m[0]*(this.m[5]*a-this.m[6]*b+this.m[7]*c)-this.m[1]*(this.m[4]*a-this.m[6]*d+this.m[7]*e)+this.m[2]*(this.m[4]*b-this.m[5]*d+this.m[7]*f)-this.m[3]*(this.m[4]*c-this.m[5]*e+this.m[6]*f)},a.prototype.toArray=function(){return this.m},a.prototype.asArray=function(){return this.toArray()},a.prototype.invert=function(){this.invertToRef(this)},a.prototype.invertToRef=function(a){var b=this.m[0],c=this.m[1],d=this.m[2],e=this.m[3],f=this.m[4],g=this.m[5],h=this.m[6],i=this.m[7],j=this.m[8],k=this.m[9],l=this.m[10],m=this.m[11],n=this.m[12],o=this.m[13],p=this.m[14],q=this.m[15],r=l*q-m*p,s=k*q-m*o,t=k*p-l*o,u=j*q-m*n,v=j*p-l*n,w=j*o-k*n,x=g*r-h*s+i*t,y=-(f*r-h*u+i*v),z=f*s-g*u+i*w,A=-(f*t-g*v+h*w),B=1/(b*x+c*y+d*z+e*A),C=h*q-i*p,D=g*q-i*o,E=g*p-h*o,F=f*q-i*n,G=f*p-h*n,H=f*o-g*n,I=h*m-i*l,J=g*m-i*k,K=g*l-h*k,L=f*m-i*j,M=f*l-h*j,N=f*k-g*j;a.m[0]=x*B,a.m[4]=y*B,a.m[8]=z*B,a.m[12]=A*B,a.m[1]=-(c*r-d*s+e*t)*B,a.m[5]=(b*r-d*u+e*v)*B,a.m[9]=-(b*s-c*u+e*w)*B,a.m[13]=(b*t-c*v+d*w)*B,a.m[2]=(c*C-d*D+e*E)*B,a.m[6]=-(b*C-d*F+e*G)*B,a.m[10]=(b*D-c*F+e*H)*B,a.m[14]=-(b*E-c*G+d*H)*B,a.m[3]=-(c*I-d*J+e*K)*B,a.m[7]=(b*I-d*L+e*M)*B,a.m[11]=-(b*J-c*L+e*N)*B,a.m[15]=(b*K-c*M+d*N)*B},a.prototype.setTranslation=function(a){this.m[12]=a.x,this.m[13]=a.y,this.m[14]=a.z},a.prototype.multiply=function(b){var c=new a;return this.multiplyToRef(b,c),c},a.prototype.copyFrom=function(a){for(var b=0;16>b;b++)this.m[b]=a.m[b]},a.prototype.copyToArray=function(a,b){"undefined"==typeof b&&(b=0);for(var c=0;16>c;c++)a[b+c]=this.m[c]},a.prototype.multiplyToRef=function(a,b){this.multiplyToArray(a,b.m,0)},a.prototype.multiplyToArray=function(a,b,c){var d=this.m[0],e=this.m[1],f=this.m[2],g=this.m[3],h=this.m[4],i=this.m[5],j=this.m[6],k=this.m[7],l=this.m[8],m=this.m[9],n=this.m[10],o=this.m[11],p=this.m[12],q=this.m[13],r=this.m[14],s=this.m[15],t=a.m[0],u=a.m[1],v=a.m[2],w=a.m[3],x=a.m[4],y=a.m[5],z=a.m[6],A=a.m[7],B=a.m[8],C=a.m[9],D=a.m[10],E=a.m[11],F=a.m[12],G=a.m[13],H=a.m[14],I=a.m[15];b[c]=d*t+e*x+f*B+g*F,b[c+1]=d*u+e*y+f*C+g*G,b[c+2]=d*v+e*z+f*D+g*H,b[c+3]=d*w+e*A+f*E+g*I,b[c+4]=h*t+i*x+j*B+k*F,b[c+5]=h*u+i*y+j*C+k*G,b[c+6]=h*v+i*z+j*D+k*H,b[c+7]=h*w+i*A+j*E+k*I,b[c+8]=l*t+m*x+n*B+o*F,b[c+9]=l*u+m*y+n*C+o*G,b[c+10]=l*v+m*z+n*D+o*H,b[c+11]=l*w+m*A+n*E+o*I,b[c+12]=p*t+q*x+r*B+s*F,b[c+13]=p*u+q*y+r*C+s*G,b[c+14]=p*v+q*z+r*D+s*H,b[c+15]=p*w+q*A+r*E+s*I},a.prototype.equals=function(a){return a&&this.m[0]===a.m[0]&&this.m[1]===a.m[1]&&this.m[2]===a.m[2]&&this.m[3]===a.m[3]&&this.m[4]===a.m[4]&&this.m[5]===a.m[5]&&this.m[6]===a.m[6]&&this.m[7]===a.m[7]&&this.m[8]===a.m[8]&&this.m[9]===a.m[9]&&this.m[10]===a.m[10]&&this.m[11]===a.m[11]&&this.m[12]===a.m[12]&&this.m[13]===a.m[13]&&this.m[14]===a.m[14]&&this.m[15]===a.m[15]},a.prototype.clone=function(){return a.FromValues(this.m[0],this.m[1],this.m[2],this.m[3],this.m[4],this.m[5],this.m[6],this.m[7],this.m[8],this.m[9],this.m[10],this.m[11],this.m[12],this.m[13],this.m[14],this.m[15])},a.FromArray=function(b,c){var d=new a;return c||(c=0),a.FromArrayToRef(b,c,d),d},a.FromArrayToRef=function(a,b,c){for(var d=0;16>d;d++)c.m[d]=a[d+b]},a.FromValuesToRef=function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){q.m[0]=a,q.m[1]=b,q.m[2]=c,q.m[3]=d,q.m[4]=e,q.m[5]=f,q.m[6]=g,q.m[7]=h,q.m[8]=i,q.m[9]=j,q.m[10]=k,q.m[11]=l,q.m[12]=m,q.m[13]=n,q.m[14]=o,q.m[15]=p},a.FromValues=function(b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){var r=new a;return r.m[0]=b,r.m[1]=c,r.m[2]=d,r.m[3]=e,r.m[4]=f,r.m[5]=g,r.m[6]=h,r.m[7]=i,r.m[8]=j,r.m[9]=k,r.m[10]=l,r.m[11]=m,r.m[12]=n,r.m[13]=o,r.m[14]=p,r.m[15]=q,r},a.Identity=function(){return a.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},a.IdentityToRef=function(b){a.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,b)},a.Zero=function(){return a.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)},a.RotationX=function(b){var c=new a;return a.RotationXToRef(b,c),c},a.RotationXToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[0]=1,b.m[15]=1,b.m[5]=d,b.m[10]=d,b.m[9]=-c,b.m[6]=c,b.m[1]=0,b.m[2]=0,b.m[3]=0,b.m[4]=0,b.m[7]=0,b.m[8]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationY=function(b){var c=new a;return a.RotationYToRef(b,c),c},a.RotationYToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[5]=1,b.m[15]=1,b.m[0]=d,b.m[2]=-c,b.m[8]=c,b.m[10]=d,b.m[1]=0,b.m[3]=0,b.m[4]=0,b.m[6]=0,b.m[7]=0,b.m[9]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationZ=function(b){var c=new a;return a.RotationZToRef(b,c),c},a.RotationZToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[10]=1,b.m[15]=1,b.m[0]=d,b.m[1]=c,b.m[4]=-c,b.m[5]=d,b.m[2]=0,b.m[3]=0,b.m[6]=0,b.m[7]=0,b.m[8]=0,b.m[9]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationAxis=function(b,c){var d=Math.sin(-c),e=Math.cos(-c),f=1-e;b.normalize();var g=a.Zero();return g.m[0]=b.x*b.x*f+e,g.m[1]=b.x*b.y*f-b.z*d,g.m[2]=b.x*b.z*f+b.y*d,g.m[3]=0,g.m[4]=b.y*b.x*f+b.z*d,g.m[5]=b.y*b.y*f+e,g.m[6]=b.y*b.z*f-b.x*d,g.m[7]=0,g.m[8]=b.z*b.x*f-b.y*d,g.m[9]=b.z*b.y*f+b.x*d,g.m[10]=b.z*b.z*f+e,g.m[11]=0,g.m[15]=1,g},a.RotationYawPitchRoll=function(b,c,d){var e=new a;return a.RotationYawPitchRollToRef(b,c,d,e),e},a.RotationYawPitchRollToRef=function(a,b,c,d){f.RotationYawPitchRollToRef(a,b,c,this._tempQuaternion),this._tempQuaternion.toRotationMatrix(d)},a.Scaling=function(b,c,d){var e=a.Zero();return a.ScalingToRef(b,c,d,e),e},a.ScalingToRef=function(a,b,c,d){d.m[0]=a,d.m[1]=0,d.m[2]=0,d.m[3]=0,d.m[4]=0,d.m[5]=b,d.m[6]=0,d.m[7]=0,d.m[8]=0,d.m[9]=0,d.m[10]=c,d.m[11]=0,d.m[12]=0,d.m[13]=0,d.m[14]=0,d.m[15]=1},a.Translation=function(b,c,d){var e=a.Identity();return a.TranslationToRef(b,c,d,e),e},a.TranslationToRef=function(b,c,d,e){a.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b,c,d,1,e)},a.LookAtLH=function(b,c,d){var e=a.Zero();return a.LookAtLHToRef(b,c,d,e),e},a.LookAtLHToRef=function(b,c,d,f){c.subtractToRef(b,this._zAxis),this._zAxis.normalize(),e.CrossToRef(d,this._zAxis,this._xAxis),this._xAxis.normalize(),e.CrossToRef(this._zAxis,this._xAxis,this._yAxis),this._yAxis.normalize();var g=-e.Dot(this._xAxis,b),h=-e.Dot(this._yAxis,b),i=-e.Dot(this._zAxis,b);return a.FromValuesToRef(this._xAxis.x,this._yAxis.x,this._zAxis.x,0,this._xAxis.y,this._yAxis.y,this._zAxis.y,0,this._xAxis.z,this._yAxis.z,this._zAxis.z,0,g,h,i,1,f)},a.OrthoLH=function(b,c,d,e){var f=2/b,g=2/c,h=1/(e-d),i=d/(d-e);return a.FromValues(f,0,0,0,0,g,0,0,0,0,h,0,0,0,i,1)},a.OrthoOffCenterLH=function(b,c,d,e,f,g){var h=a.Zero();return a.OrthoOffCenterLHToRef(b,c,d,e,f,g,h),h},a.OrthoOffCenterLHToRef=function(a,b,c,d,e,f,g){g.m[0]=2/(b-a),g.m[1]=g.m[2]=g.m[3]=0,g.m[5]=2/(d-c),g.m[4]=g.m[6]=g.m[7]=0,g.m[10]=-1/(e-f),g.m[8]=g.m[9]=g.m[11]=0,g.m[12]=(a+b)/(a-b),g.m[13]=(d+c)/(c-d),g.m[14]=e/(e-f),g.m[15]=1},a.PerspectiveLH=function(b,c,d,e){var f=a.Zero();return f.m[0]=2*d/b,f.m[1]=f.m[2]=f.m[3]=0,f.m[5]=2*d/c,f.m[4]=f.m[6]=f.m[7]=0,f.m[10]=-e/(d-e),f.m[8]=f.m[9]=0,f.m[11]=1,f.m[12]=f.m[13]=f.m[15]=0,f.m[14]=d*e/(d-e),f},a.PerspectiveFovLH=function(b,c,d,e){var f=a.Zero();return a.PerspectiveFovLHToRef(b,c,d,e,f),f},a.PerspectiveFovLHToRef=function(a,b,c,d,e){var f=1/Math.tan(.5*a);e.m[0]=f/b,e.m[1]=e.m[2]=e.m[3]=0,e.m[5]=f,e.m[4]=e.m[6]=e.m[7]=0,e.m[8]=e.m[9]=0,e.m[10]=-d/(c-d),e.m[11]=1,e.m[12]=e.m[13]=e.m[15]=0,e.m[14]=c*d/(c-d)},a.GetFinalMatrix=function(b,c,d,e,f,g){var h=b.width,i=b.height,j=b.x,k=b.y,l=a.FromValues(h/2,0,0,0,0,-i/2,0,0,0,0,g-f,0,j+h/2,i/2+k,f,1);return c.multiply(d).multiply(e).multiply(l)},a.Transpose=function(b){var c=new a;return c.m[0]=b.m[0],c.m[1]=b.m[4],c.m[2]=b.m[8],c.m[3]=b.m[12],c.m[4]=b.m[1],c.m[5]=b.m[5],c.m[6]=b.m[9],c.m[7]=b.m[13],c.m[8]=b.m[2],c.m[9]=b.m[6],c.m[10]=b.m[10],c.m[11]=b.m[14],c.m[12]=b.m[3],c.m[13]=b.m[7],c.m[14]=b.m[11],c.m[15]=b.m[15],c},a.Reflection=function(b){var c=new a;return a.ReflectionToRef(b,c),c},a.ReflectionToRef=function(a,b){a.normalize();var c=a.normal.x,d=a.normal.y,e=a.normal.z,f=-2*c,g=-2*d,h=-2*e;b.m[0]=f*c+1,b.m[1]=g*c,b.m[2]=h*c,b.m[3]=0,b.m[4]=f*d,b.m[5]=g*d+1,b.m[6]=h*d,b.m[7]=0,b.m[8]=f*e,b.m[9]=g*e,b.m[10]=h*e+1,b.m[11]=0,b.m[12]=f*a.d,b.m[13]=g*a.d,b.m[14]=h*a.d,b.m[15]=1},a._tempQuaternion=new f,a._xAxis=e.Zero(),a._yAxis=e.Zero(),a._zAxis=e.Zero(),a}();a.Matrix=g;var h=function(){function b(a,b,c,d){this.normal=new e(a,b,c),this.d=d}return b.prototype.asArray=function(){return[this.normal.x,this.normal.y,this.normal.z,this.d]},b.prototype.clone=function(){return new b(this.normal.x,this.normal.y,this.normal.z,this.d)},b.prototype.normalize=function(){var a=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z),b=0;0!=a&&(b=1/a),this.normal.x*=b,this.normal.y*=b,this.normal.z*=b,this.d*=b},b.prototype.transform=function(b){var c=a.Matrix.Transpose(b),d=this.normal.x,e=this.normal.y,f=this.normal.z,g=this.d,h=d*c.m[0]+e*c.m[1]+f*c.m[2]+g*c.m[3],i=d*c.m[4]+e*c.m[5]+f*c.m[6]+g*c.m[7],j=d*c.m[8]+e*c.m[9]+f*c.m[10]+g*c.m[11],k=d*c.m[12]+e*c.m[13]+f*c.m[14]+g*c.m[15];return new a.Plane(h,i,j,k)},b.prototype.dotCoordinate=function(a){return this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z+this.d},b.prototype.copyFromPoints=function(a,b,c){var d,e=b.x-a.x,f=b.y-a.y,g=b.z-a.z,h=c.x-a.x,i=c.y-a.y,j=c.z-a.z,k=f*j-g*i,l=g*h-e*j,m=e*i-f*h,n=Math.sqrt(k*k+l*l+m*m);d=0!=n?1/n:0,this.normal.x=k*d,this.normal.y=l*d,this.normal.z=m*d,this.d=-(this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z)},b.prototype.isFrontFacingTo=function(a,b){var c=e.Dot(this.normal,a);return b>=c},b.prototype.signedDistanceTo=function(a){return e.Dot(a,this.normal)+this.d},b.FromArray=function(b){return new a.Plane(b[0],b[1],b[2],b[3])},b.FromPoints=function(b,c,d){var e=new a.Plane(0,0,0,0);return e.copyFromPoints(b,c,d),e},b.FromPositionAndNormal=function(b,c){var d=new a.Plane(0,0,0,0);return c.normalize(),d.normal=c,d.d=-(c.x*b.x+c.y*b.y+c.z*b.z),d},b.SignedDistanceToPlaneFromPositionAndNormal=function(a,b,c){var d=-(b.x*a.x+b.y*a.y+b.z*a.z);return e.Dot(c,b)+d},b}();a.Plane=h;var i=function(){function a(a,b,c,d){this.x=a,this.y=b,this.width=c,this.height=d}return a.prototype.toGlobal=function(b){var c=b.getRenderWidth(),d=b.getRenderHeight();return new a(this.x*c,this.y*d,this.width*c,this.height*d)},a}();a.Viewport=i;var j=function(){function a(){}return a.GetPlanes=function(b){for(var c=[],d=0;6>d;d++)c.push(new h(0,0,0,0));return a.GetPlanesToRef(b,c),c},a.GetPlanesToRef=function(a,b){b[0].normal.x=a.m[3]+a.m[2],b[0].normal.y=a.m[7]+a.m[6],b[0].normal.z=a.m[10]+a.m[10],b[0].d=a.m[15]+a.m[14],b[0].normalize(),b[1].normal.x=a.m[3]-a.m[2],b[1].normal.y=a.m[7]-a.m[6],b[1].normal.z=a.m[11]-a.m[10],b[1].d=a.m[15]-a.m[14],b[1].normalize(),b[2].normal.x=a.m[3]+a.m[0],b[2].normal.y=a.m[7]+a.m[4],b[2].normal.z=a.m[11]+a.m[8],b[2].d=a.m[15]+a.m[12],b[2].normalize(),b[3].normal.x=a.m[3]-a.m[0],b[3].normal.y=a.m[7]-a.m[4],b[3].normal.z=a.m[11]-a.m[8],b[3].d=a.m[15]-a.m[12],b[3].normalize(),b[4].normal.x=a.m[3]-a.m[1],b[4].normal.y=a.m[7]-a.m[5],b[4].normal.z=a.m[11]-a.m[9],b[4].d=a.m[15]-a.m[13],b[4].normalize(),b[5].normal.x=a.m[3]+a.m[1],b[5].normal.y=a.m[7]+a.m[5],b[5].normal.z=a.m[11]+a.m[9],b[5].d=a.m[15]+a.m[13],b[5].normalize()},a}();a.Frustum=j;var k=function(){function b(a,b){this.origin=a,this.direction=b}return b.prototype.intersectsBoxMinMax=function(a,b){var c=0,d=Number.MAX_VALUE;if(Math.abs(this.direction.x)<1e-7){if(this.origin.x<a.x||this.origin.x>b.x)return!1}else{var e=1/this.direction.x,f=(a.x-this.origin.x)*e,g=(b.x-this.origin.x)*e;if(f>g){var h=f;f=g,g=h}if(c=Math.max(f,c),d=Math.min(g,d),c>d)return!1}if(Math.abs(this.direction.y)<1e-7){if(this.origin.y<a.y||this.origin.y>b.y)return!1}else if(e=1/this.direction.y,f=(a.y-this.origin.y)*e,g=(b.y-this.origin.y)*e,f>g&&(h=f,f=g,g=h),c=Math.max(f,c),d=Math.min(g,d),c>d)return!1;if(Math.abs(this.direction.z)<1e-7){if(this.origin.z<a.z||this.origin.z>b.z)return!1}else if(e=1/this.direction.z,f=(a.z-this.origin.z)*e,g=(b.z-this.origin.z)*e,f>g&&(h=f,f=g,g=h),c=Math.max(f,c),d=Math.min(g,d),c>d)return!1;return!0},b.prototype.intersectsBox=function(a){return this.intersectsBoxMinMax(a.minimum,a.maximum)},b.prototype.intersectsSphere=function(a){var b=a.center.x-this.origin.x,c=a.center.y-this.origin.y,d=a.center.z-this.origin.z,e=b*b+c*c+d*d,f=a.radius*a.radius;if(f>=e)return!0;var g=b*this.direction.x+c*this.direction.y+d*this.direction.z;if(0>g)return!1;var h=e-g*g;return f>=h},b.prototype.intersectsTriangle=function(b,c,d){this._edge1||(this._edge1=a.Vector3.Zero(),this._edge2=a.Vector3.Zero(),this._pvec=a.Vector3.Zero(),this._tvec=a.Vector3.Zero(),this._qvec=a.Vector3.Zero()),c.subtractToRef(b,this._edge1),d.subtractToRef(b,this._edge2),a.Vector3.CrossToRef(this.direction,this._edge2,this._pvec);var f=e.Dot(this._edge1,this._pvec);if(0===f)return null;var g=1/f;this.origin.subtractToRef(b,this._tvec);var h=e.Dot(this._tvec,this._pvec)*g;if(0>h||h>1)return null;e.CrossToRef(this._tvec,this._edge1,this._qvec);var i=e.Dot(this.direction,this._qvec)*g;return 0>i||h+i>1?null:new a.IntersectionInfo(h,i,e.Dot(this._edge2,this._qvec)*g)},b.CreateNew=function(c,d,e,f,g,h,i){var j=a.Vector3.Unproject(new a.Vector3(c,d,0),e,f,g,h,i),k=a.Vector3.Unproject(new a.Vector3(c,d,1),e,f,g,h,i),l=k.subtract(j);return l.normalize(),new b(j,l)},b.Transform=function(c,d){var e=a.Vector3.TransformCoordinates(c.origin,d),f=a.Vector3.TransformNormal(c.direction,d);return new b(e,f)},b}();a.Ray=k,function(a){a[a.LOCAL=0]="LOCAL",a[a.WORLD=1]="WORLD"}(a.Space||(a.Space={}));var l=(a.Space,function(){function b(){}return b.X=new a.Vector3(1,0,0),b.Y=new a.Vector3(0,1,0),b.Z=new a.Vector3(0,0,1),b}());a.Axis=l}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b,c=60,d=[],e=60,f=0,g=function(b,c){return b?b instanceof a.Mesh?null:b instanceof a.SubMesh?b.clone(c):b.clone?b.clone():null:null},h=function(){function h(){}return h.GetFilename=function(a){var b=a.lastIndexOf("/");return 0>b?a:a.substring(b+1)},h.GetDOMTextContent=function(a){for(var b="",c=a.firstChild;c;)3==c.nodeType&&(b+=c.textContent),c=c.nextSibling;return b},h.ToDegrees=function(a){return 180*a/Math.PI},h.ToRadians=function(a){return a*Math.PI/180},h.ExtractMinAndMaxIndexed=function(b,c,d,e){for(var f=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),g=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),h=d;d+e>h;h++){var i=new a.Vector3(b[3*c[h]],b[3*c[h]+1],b[3*c[h]+2]);f=a.Vector3.Minimize(i,f),g=a.Vector3.Maximize(i,g)}return{minimum:f,maximum:g}},h.ExtractMinAndMax=function(b,c,d){for(var e=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),f=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),g=c;c+d>g;g++){var h=new a.Vector3(b[3*g],b[3*g+1],b[3*g+2]);e=a.Vector3.Minimize(h,e),f=a.Vector3.Maximize(h,f)}return{minimum:e,maximum:f}},h.MakeArray=function(a,b){return b===!0||void 0!==a&&null!=a?Array.isArray(a)?a:[a]:void 0},h.GetPointerPrefix=function(){var a="pointer";return navigator.pointerEnabled||(a="mouse"),a},h.QueueNewFrame=function(a){window.requestAnimationFrame?window.requestAnimationFrame(a):window.msRequestAnimationFrame?window.msRequestAnimationFrame(a):window.webkitRequestAnimationFrame?window.webkitRequestAnimationFrame(a):window.mozRequestAnimationFrame?window.mozRequestAnimationFrame(a):window.oRequestAnimationFrame?window.oRequestAnimationFrame(a):window.setTimeout(a,16)},h.RequestFullscreen=function(a){a.requestFullscreen?a.requestFullscreen():a.msRequestFullscreen?a.msRequestFullscreen():a.webkitRequestFullscreen?a.webkitRequestFullscreen():a.mozRequestFullScreen&&a.mozRequestFullScreen()},h.ExitFullscreen=function(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitCancelFullScreen?document.webkitCancelFullScreen():document.msCancelFullScreen&&document.msCancelFullScreen()},h.CleanUrl=function(a){return a=a.replace(/#/gm,"%23")},h.LoadImage=function(b,c,d,e){b=h.CleanUrl(b);var f=new Image;f.crossOrigin="anonymous",f.onload=function(){c(f)},f.onerror=function(a){d(f,a)};var g=function(){f.src=b},i=function(){e.loadImageFromDB(b,f)};if(e&&e.enableTexturesOffline&&a.Database.isUASupportingBlobStorage)e.openAsync(i,g);else if(-1===b.indexOf("file:"))g();else try{var j,k=b.substring(5);try{j=URL.createObjectURL(a.FilesInput.FilesTextures[k],{oneTimeOnly:!0})}catch(l){j=URL.createObjectURL(a.FilesInput.FilesTextures[k])}f.src=j}catch(m){h.Log("Error while trying to load texture: "+k),f.src=null}return f},h.LoadFile=function(b,c,d,e,f){b=h.CleanUrl(b);
var g=function(){var e=new XMLHttpRequest,g=h.BaseUrl+b;e.open("GET",g,!0),f&&(e.responseType="arraybuffer"),e.onprogress=d,e.onreadystatechange=function(){if(4==e.readyState){if(200!=e.status&&!a.Tools.ValidateXHRData(e,f?6:1))throw new Error("Error status: "+e.status+" - Unable to load "+g);c(f?e.response:e.responseText)}},e.send(null)},i=function(){e.loadFileFromDB(b,c,d,g,f)};if(-1!==b.indexOf("file:")){var j=b.substring(5);a.Tools.ReadFile(a.FilesInput.FilesToLoad[j],c,d,!0)}else e&&e.enableSceneOffline?e.openAsync(i,g):g()},h.ReadFile=function(a,b,c,d){var e=new FileReader;e.onload=function(a){b(a.target.result)},e.onprogress=c,d?e.readAsArrayBuffer(a):e.readAsText(a)},h.CheckExtends=function(a,b,c){a.x<b.x&&(b.x=a.x),a.y<b.y&&(b.y=a.y),a.z<b.z&&(b.z=a.z),a.x>c.x&&(c.x=a.x),a.y>c.y&&(c.y=a.y),a.z>c.z&&(c.z=a.z)},h.WithinEpsilon=function(a,b){var c=a-b;return c>=-1.401298e-45&&1.401298e-45>=c},h.DeepCopy=function(a,b,c,d){for(var e in a)if(("_"!==e[0]||d&&-1!==d.indexOf(e))&&(!c||-1===c.indexOf(e))){var f=a[e],h=typeof f;if("function"!=h)if("object"==h)if(f instanceof Array){if(b[e]=[],f.length>0)if("object"==typeof f[0])for(var i=0;i<f.length;i++){var j=g(f[i],b);-1===b[e].indexOf(j)&&b[e].push(j)}else b[e]=f.slice(0)}else b[e]=g(f,b);else b[e]=f}},h.IsEmpty=function(a){for(var b in a)return!1;return!0},h.RegisterTopRootEvents=function(a){for(var b=0;b<a.length;b++){var c=a[b];window.addEventListener(c.name,c.handler,!1);try{window.parent&&window.parent.addEventListener(c.name,c.handler,!1)}catch(d){}}},h.UnregisterTopRootEvents=function(a){for(var b=0;b<a.length;b++){var c=a[b];window.removeEventListener(c.name,c.handler);try{window.parent&&window.parent.removeEventListener(c.name,c.handler)}catch(d){}}},h.GetFps=function(){return e},h.GetDeltaTime=function(){return f},h._MeasureFps=function(){d.push((new Date).getTime());var a=d.length;if(a>=2&&(f=d[a-1]-d[a-2]),a>=c){a>c&&(d.splice(0,1),a=d.length);for(var b=0,g=0;a-1>g;g++)b+=d[g+1]-d[g];e=1e3/(b/(a-1))}},h.CreateScreenshot=function(c,d,e){var f,g,i=d.getScene(),j=null;if(i.activeCamera!==d&&(j=i.activeCamera,i.activeCamera=d),e.precision)f=Math.round(c.getRenderWidth()*e.precision),g=Math.round(f/c.getAspectRatio(d)),e={width:f,height:g};else if(e.width&&e.height)f=e.width,g=e.height;else if(e.width&&!e.height)f=e.width,g=Math.round(f/c.getAspectRatio(d)),e={width:f,height:g};else if(e.height&&!e.width)g=e.height,f=Math.round(g*c.getAspectRatio(d)),e={width:f,height:g};else{if(isNaN(e))return void h.Error("Invalid 'size' parameter !");g=e,f=e}var k=new a.RenderTargetTexture("screenShot",e,c.scenes[0],!1,!1);k.renderList=c.scenes[0].meshes,k.onAfterRender=function(){for(var a=4*f,d=g/2,e=c.readPixels(0,0,f,g),h=0;d>h;h++)for(var i=0;a>i;i++){var j=i+h*a,k=g-h-1,l=i+k*a,m=e[j];e[j]=e[l],e[l]=m}b||(b=document.createElement("canvas")),b.width=f,b.height=g;var n=b.getContext("2d"),o=n.createImageData(f,g);o.data.set(e),n.putImageData(o,0,0);var p=b.toDataURL();if("download"in document.createElement("a")){var q=window.document.createElement("a");q.href=p;var r=new Date,s=r.getFullYear()+"/"+r.getMonth()+"/"+r.getDate()+"-"+r.getHours()+":"+r.getMinutes();q.setAttribute("download","screenshot-"+s+".png"),window.document.body.appendChild(q),q.addEventListener("click",function(){q.parentElement.removeChild(q)}),q.click()}else{var t=window.open(""),u=t.document.createElement("img");u.src=p,t.document.body.appendChild(u)}},k.render(!0),k.dispose(),j&&(i.activeCamera=j)},h.ValidateXHRData=function(b,c){"undefined"==typeof c&&(c=7);try{if(1&c){if(b.responseText&&b.responseText.length>0)return!0;if(1===c)return!1}if(2&c){var d=a.Internals.TGATools.GetTGAHeader(b.response);if(d.width&&d.height&&d.width>0&&d.height>0)return!0;if(2===c)return!1}if(4&c){var e=new Uint8Array(b.response,0,3);return 68==e[0]&&68==e[1]&&83==e[2]?!0:!1}}catch(f){}return!1},Object.defineProperty(h,"NoneLogLevel",{get:function(){return h._NoneLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"MessageLogLevel",{get:function(){return h._MessageLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"WarningLogLevel",{get:function(){return h._WarningLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ErrorLogLevel",{get:function(){return h._ErrorLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"AllLogLevel",{get:function(){return h._MessageLogLevel|h._WarningLogLevel|h._ErrorLogLevel},enumerable:!0,configurable:!0}),h._FormatMessage=function(a){var b=function(a){return 10>a?"0"+a:""+a},c=new Date;return"BJS - ["+b(c.getHours())+":"+b(c.getMinutes())+":"+b(c.getSeconds())+"]: "+a},h._LogDisabled=function(){},h._LogEnabled=function(a){console.log(h._FormatMessage(a))},h._WarnDisabled=function(){},h._WarnEnabled=function(a){console.warn(h._FormatMessage(a))},h._ErrorDisabled=function(){},h._ErrorEnabled=function(a){console.error(h._FormatMessage(a))},Object.defineProperty(h,"LogLevels",{set:function(a){h.Log=(a&h.MessageLogLevel)===h.MessageLogLevel?h._LogEnabled:h._LogDisabled,h.Warn=(a&h.WarningLogLevel)===h.WarningLogLevel?h._WarnEnabled:h._WarnDisabled,h.Error=(a&h.ErrorLogLevel)===h.ErrorLogLevel?h._ErrorEnabled:h._ErrorDisabled},enumerable:!0,configurable:!0}),h.BaseUrl="",h._NoneLogLevel=0,h._MessageLogLevel=1,h._WarningLogLevel=2,h._ErrorLogLevel=4,h.Log=h._LogEnabled,h.Warn=h._WarnEnabled,h.Error=h._ErrorEnabled,h}();a.Tools=h}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b,c,d){var e=a.createShader("vertex"===c?a.VERTEX_SHADER:a.FRAGMENT_SHADER);if(a.shaderSource(e,(d?d+"\n":"")+b),a.compileShader(e),!a.getShaderParameter(e,a.COMPILE_STATUS))throw new Error(a.getShaderInfoLog(e));return e},c=function(b,c,d){var e=d.NEAREST,f=d.NEAREST;return b===a.Texture.BILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=c?d.LINEAR_MIPMAP_NEAREST:d.LINEAR):b===a.Texture.TRILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=c?d.LINEAR_MIPMAP_LINEAR:d.LINEAR):b===a.Texture.NEAREST_SAMPLINGMODE&&(e=d.NEAREST,f=c?d.NEAREST_MIPMAP_LINEAR:d.NEAREST),{min:f,mag:e}},d=function(a,b){var c=1;do c*=2;while(a>c);return c>b&&(c=b),c},e=function(b,e,f,g,h,i,j,k,l,m){"undefined"==typeof m&&(m=a.Texture.TRILINEAR_SAMPLINGMODE);var n=f.getEngine(),o=d(g,n.getCaps().maxTextureSize),p=d(h,n.getCaps().maxTextureSize);e.bindTexture(e.TEXTURE_2D,b),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,void 0===i?1:i?1:0),l(o,p);var q=c(m,!j,e);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,q.mag),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,q.min),j||k||e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null),n._activeTexturesCache=[],b._baseWidth=g,b._baseHeight=h,b._width=o,b._height=p,b.isReady=!0,f._removePendingData(b)},f=function(b,c,d,e,g,h){var i,j=function(){d.push(i),e._removePendingData(i),c!=h.length-1?f(b,c+1,d,e,g,h):g(d)},k=function(){e._removePendingData(i)};i=a.Tools.LoadImage(b+h[c],j,k,e.database),e._addPendingData(i)},g=function(){function a(){}return a}();a.EngineCapabilities=g;var h=function(){function h(a,b,c){var d=this;this.isFullscreen=!1,this.isPointerLock=!1,this.forceWireframe=!1,this.cullBackFaces=!0,this.renderEvenInBackground=!0,this.scenes=new Array,this._windowIsBackground=!1,this._runningLoop=!1,this._loadedTexturesCache=new Array,this._activeTexturesCache=new Array,this._compiledEffects={},this._depthMask=!1,this._renderingCanvas=a,this._canvasClientRect=this._renderingCanvas.getBoundingClientRect(),c=c||{},c.antialias=b;try{this._gl=a.getContext("webgl",c)||a.getContext("experimental-webgl",c)}catch(e){throw new Error("WebGL not supported")}if(!this._gl)throw new Error("WebGL not supported");this._onBlur=function(){d._windowIsBackground=!0},this._onFocus=function(){d._windowIsBackground=!1},window.addEventListener("blur",this._onBlur),window.addEventListener("focus",this._onFocus),this._workingCanvas=document.createElement("canvas"),this._workingContext=this._workingCanvas.getContext("2d"),this._hardwareScalingLevel=1/(window.devicePixelRatio||1),this.resize(),this._caps=new g,this._caps.maxTexturesImageUnits=this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),this._caps.maxTextureSize=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),this._caps.maxCubemapTextureSize=this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),this._caps.maxRenderTextureSize=this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),this._caps.standardDerivatives=null!==this._gl.getExtension("OES_standard_derivatives"),this._caps.s3tc=this._gl.getExtension("WEBGL_compressed_texture_s3tc"),this._caps.textureFloat=null!==this._gl.getExtension("OES_texture_float"),this._caps.textureAnisotropicFilterExtension=this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.instancedArrays=this._gl.getExtension("ANGLE_instanced_arrays"),this.setDepthBuffer(!0),this.setDepthFunctionToLessOrEqual(),this.setDepthWrite(!0),this._onFullscreenChange=function(){void 0!==document.fullscreen?d.isFullscreen=document.fullscreen:void 0!==document.mozFullScreen?d.isFullscreen=document.mozFullScreen:void 0!==document.webkitIsFullScreen?d.isFullscreen=document.webkitIsFullScreen:void 0!==document.msIsFullScreen&&(d.isFullscreen=document.msIsFullScreen),d.isFullscreen&&d._pointerLockRequested&&(a.requestPointerLock=a.requestPointerLock||a.msRequestPointerLock||a.mozRequestPointerLock||a.webkitRequestPointerLock,a.requestPointerLock&&a.requestPointerLock())},document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),document.addEventListener("mozfullscreenchange",this._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",this._onFullscreenChange,!1),document.addEventListener("msfullscreenchange",this._onFullscreenChange,!1),this._onPointerLockChange=function(){d.isPointerLock=document.mozPointerLockElement===a||document.webkitPointerLockElement===a||document.msPointerLockElement===a||document.pointerLockElement===a},document.addEventListener("pointerlockchange",this._onPointerLockChange,!1),document.addEventListener("mspointerlockchange",this._onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",this._onPointerLockChange,!1)}return Object.defineProperty(h,"ALPHA_DISABLE",{get:function(){return h._ALPHA_DISABLE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ALPHA_ADD",{get:function(){return h._ALPHA_ADD},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ALPHA_COMBINE",{get:function(){return h._ALPHA_COMBINE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_NONE",{get:function(){return h._DELAYLOADSTATE_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_LOADED",{get:function(){return h._DELAYLOADSTATE_LOADED},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_LOADING",{get:function(){return h._DELAYLOADSTATE_LOADING},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_NOTLOADED",{get:function(){return h._DELAYLOADSTATE_NOTLOADED},enumerable:!0,configurable:!0}),Object.defineProperty(h,"Version",{get:function(){return"1.13.0"},enumerable:!0,configurable:!0}),h.prototype.getAspectRatio=function(a){var b=a.viewport;return this.getRenderWidth()*b.width/(this.getRenderHeight()*b.height)},h.prototype.getRenderWidth=function(){return this._currentRenderTarget?this._currentRenderTarget._width:this._renderingCanvas.width},h.prototype.getRenderHeight=function(){return this._currentRenderTarget?this._currentRenderTarget._height:this._renderingCanvas.height},h.prototype.getRenderingCanvas=function(){return this._renderingCanvas},h.prototype.getRenderingCanvasClientRect=function(){return this._renderingCanvas.getBoundingClientRect()},h.prototype.setHardwareScalingLevel=function(a){this._hardwareScalingLevel=a,this.resize()},h.prototype.getHardwareScalingLevel=function(){return this._hardwareScalingLevel},h.prototype.getLoadedTexturesCache=function(){return this._loadedTexturesCache},h.prototype.getCaps=function(){return this._caps},h.prototype.setDepthFunctionToGreater=function(){this._gl.depthFunc(this._gl.GREATER)},h.prototype.setDepthFunctionToGreaterOrEqual=function(){this._gl.depthFunc(this._gl.GEQUAL)},h.prototype.setDepthFunctionToLess=function(){this._gl.depthFunc(this._gl.LESS)},h.prototype.setDepthFunctionToLessOrEqual=function(){this._gl.depthFunc(this._gl.LEQUAL)},h.prototype.stopRenderLoop=function(){this._renderFunction=null,this._runningLoop=!1},h.prototype._renderLoop=function(){var b=this,c=!0;!this.renderEvenInBackground&&this._windowIsBackground&&(c=!1),c&&(this.beginFrame(),this._renderFunction&&this._renderFunction(),this.endFrame()),this._runningLoop&&a.Tools.QueueNewFrame(function(){b._renderLoop()})},h.prototype.runRenderLoop=function(b){var c=this;this._runningLoop=!0,this._renderFunction=b,a.Tools.QueueNewFrame(function(){c._renderLoop()})},h.prototype.switchFullscreen=function(b){this.isFullscreen?a.Tools.ExitFullscreen():(this._pointerLockRequested=b,a.Tools.RequestFullscreen(this._renderingCanvas))},h.prototype.clear=function(a,b,c){this._gl.clearColor(a.r,a.g,a.b,void 0!==a.a?a.a:1),this._depthMask&&this._gl.clearDepth(1);var d=0;b&&(d|=this._gl.COLOR_BUFFER_BIT),c&&this._depthMask&&(d|=this._gl.DEPTH_BUFFER_BIT),this._gl.clear(d)},h.prototype.setViewport=function(a,b,c){var d=b||this._renderingCanvas.width,e=c||this._renderingCanvas.height,f=a.x||0,g=a.y||0;this._cachedViewport=a,this._gl.viewport(f*d,g*e,d*a.width,e*a.height)},h.prototype.setDirectViewport=function(a,b,c,d){this._cachedViewport=null,this._gl.viewport(a,b,c,d)},h.prototype.beginFrame=function(){a.Tools._MeasureFps()},h.prototype.endFrame=function(){this.flushFramebuffer()},h.prototype.resize=function(){this._renderingCanvas.width=this._renderingCanvas.clientWidth/this._hardwareScalingLevel,this._renderingCanvas.height=this._renderingCanvas.clientHeight/this._hardwareScalingLevel,this._canvasClientRect=this._renderingCanvas.getBoundingClientRect()},h.prototype.bindFramebuffer=function(a){this._currentRenderTarget=a;var b=this._gl;b.bindFramebuffer(b.FRAMEBUFFER,a._framebuffer),this._gl.viewport(0,0,a._width,a._height),this.wipeCaches()},h.prototype.unBindFramebuffer=function(a){if(this._currentRenderTarget=null,a.generateMipMaps){var b=this._gl;b.bindTexture(b.TEXTURE_2D,a),b.generateMipmap(b.TEXTURE_2D),b.bindTexture(b.TEXTURE_2D,null)}this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,null)},h.prototype.flushFramebuffer=function(){this._gl.flush()},h.prototype.restoreDefaultFramebuffer=function(){this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,null),this.setViewport(this._cachedViewport),this.wipeCaches()},h.prototype._resetVertexBufferBinding=function(){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,null),this._cachedVertexBuffers=null},h.prototype.createVertexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(a),this._gl.STATIC_DRAW),this._resetVertexBufferBinding(),b.references=1,b},h.prototype.createDynamicVertexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,a,this._gl.DYNAMIC_DRAW),this._resetVertexBufferBinding(),b.references=1,b},h.prototype.updateDynamicVertexBuffer=function(a,b){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a),b instanceof Float32Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,b):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,new Float32Array(b)),this._resetVertexBufferBinding()},h.prototype._resetIndexBufferBinding=function(){this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,null),this._cachedIndexBuffer=null},h.prototype.createIndexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),b.references=1,b},h.prototype.bindBuffers=function(a,b,c,d,e){if(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==e){this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=e,this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a);for(var f=0,g=0;g<c.length;g++){var h=e.getAttributeLocation(g);h>=0&&this._gl.vertexAttribPointer(h,c[g],this._gl.FLOAT,!1,d,f),f+=4*c[g]}}this._cachedIndexBuffer!==b&&(this._cachedIndexBuffer=b,this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b))},h.prototype.bindMultiBuffers=function(a,b,c){if(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==c){this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=c;for(var d=c.getAttributesNames(),e=0;e<d.length;e++){var f=c.getAttributeLocation(e);if(f>=0){var g=a[d[e]];if(!g)continue;var h=g.getStrideSize();this._gl.bindBuffer(this._gl.ARRAY_BUFFER,g.getBuffer()),this._gl.vertexAttribPointer(f,h,this._gl.FLOAT,!1,4*h,0)}}}this._cachedIndexBuffer!==b&&(this._cachedIndexBuffer=b,this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b))},h.prototype._releaseBuffer=function(a){return a.references--,0===a.references?(this._gl.deleteBuffer(a),!0):!1},h.prototype.createInstancesBuffer=function(a){var b=this._gl.createBuffer();return b.capacity=a,this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,a,this._gl.DYNAMIC_DRAW),b},h.prototype.deleteInstancesBuffer=function(a){this._gl.deleteBuffer(a)},h.prototype.updateAndBindInstancesBuffer=function(a,b,c){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,b);for(var d=0;4>d;d++){var e=c[d];this._gl.enableVertexAttribArray(e),this._gl.vertexAttribPointer(e,4,this._gl.FLOAT,!1,64,16*d),this._caps.instancedArrays.vertexAttribDivisorANGLE(e,1)}},h.prototype.unBindInstancesBuffer=function(a,b){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a);for(var c=0;4>c;c++){var d=b[c];this._gl.disableVertexAttribArray(d),this._caps.instancedArrays.vertexAttribDivisorANGLE(d,0)}},h.prototype.draw=function(a,b,c,d){return d?void this._caps.instancedArrays.drawElementsInstancedANGLE(a?this._gl.TRIANGLES:this._gl.LINES,c,this._gl.UNSIGNED_SHORT,2*b,d):void this._gl.drawElements(a?this._gl.TRIANGLES:this._gl.LINES,c,this._gl.UNSIGNED_SHORT,2*b)},h.prototype._releaseEffect=function(a){this._compiledEffects[a._key]&&(delete this._compiledEffects[a._key],a.getProgram()&&this._gl.deleteProgram(a.getProgram()))},h.prototype.createEffect=function(b,c,d,e,f,g,h,i){var j=b.vertexElement||b.vertex||b,k=b.fragmentElement||b.fragment||b,l=j+"+"+k+"@"+f;if(this._compiledEffects[l])return this._compiledEffects[l];var m=new a.Effect(b,c,d,e,this,f,g,h,i);return m._key=l,this._compiledEffects[l]=m,m},h.prototype.createShaderProgram=function(a,c,d){var e=b(this._gl,a,"vertex",d),f=b(this._gl,c,"fragment",d),g=this._gl.createProgram();this._gl.attachShader(g,e),this._gl.attachShader(g,f),this._gl.linkProgram(g);var h=this._gl.getProgramParameter(g,this._gl.LINK_STATUS);if(!h){var i=this._gl.getProgramInfoLog(g);if(i)throw new Error(i)}return this._gl.deleteShader(e),this._gl.deleteShader(f),g},h.prototype.getUniforms=function(a,b){for(var c=[],d=0;d<b.length;d++)c.push(this._gl.getUniformLocation(a,b[d]));return c},h.prototype.getAttributes=function(a,b){for(var c=[],d=0;d<b.length;d++)try{c.push(this._gl.getAttribLocation(a,b[d]))}catch(e){c.push(-1)}return c},h.prototype.enableEffect=function(a){if(a&&a.getAttributesCount()&&this._currentEffect!==a){this._vertexAttribArrays=this._vertexAttribArrays||[],this._gl.useProgram(a.getProgram());for(var b in this._vertexAttribArrays)b>this._gl.VERTEX_ATTRIB_ARRAY_ENABLED||!this._vertexAttribArrays[b]||(this._vertexAttribArrays[b]=!1,this._gl.disableVertexAttribArray(b));for(var c=a.getAttributesCount(),d=0;c>d;d++){var e=a.getAttributeLocation(d);e>=0&&(this._vertexAttribArrays[e]=!0,this._gl.enableVertexAttribArray(e))}this._currentEffect=a}},h.prototype.setArray=function(a,b){a&&this._gl.uniform1fv(a,b)},h.prototype.setMatrices=function(a,b){a&&this._gl.uniformMatrix4fv(a,!1,b)},h.prototype.setMatrix=function(a,b){a&&this._gl.uniformMatrix4fv(a,!1,b.toArray())},h.prototype.setFloat=function(a,b){a&&this._gl.uniform1f(a,b)},h.prototype.setFloat2=function(a,b,c){a&&this._gl.uniform2f(a,b,c)},h.prototype.setFloat3=function(a,b,c,d){a&&this._gl.uniform3f(a,b,c,d)},h.prototype.setBool=function(a,b){a&&this._gl.uniform1i(a,b)},h.prototype.setFloat4=function(a,b,c,d,e){a&&this._gl.uniform4f(a,b,c,d,e)},h.prototype.setColor3=function(a,b){a&&this._gl.uniform3f(a,b.r,b.g,b.b)},h.prototype.setColor4=function(a,b,c){a&&this._gl.uniform4f(a,b.r,b.g,b.b,c)},h.prototype.setState=function(a){this._cullingState!==a&&(a?(this._gl.cullFace(this.cullBackFaces?this._gl.BACK:this._gl.FRONT),this._gl.enable(this._gl.CULL_FACE)):this._gl.disable(this._gl.CULL_FACE),this._cullingState=a)},h.prototype.setDepthBuffer=function(a){a?this._gl.enable(this._gl.DEPTH_TEST):this._gl.disable(this._gl.DEPTH_TEST)},h.prototype.setDepthWrite=function(a){this._gl.depthMask(a),this._depthMask=a},h.prototype.setColorWrite=function(a){this._gl.colorMask(a,a,a,a)},h.prototype.setAlphaMode=function(b){switch(b){case a.Engine.ALPHA_DISABLE:this.setDepthWrite(!0),this._gl.disable(this._gl.BLEND);break;case a.Engine.ALPHA_COMBINE:this.setDepthWrite(!1),this._gl.blendFuncSeparate(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._gl.enable(this._gl.BLEND);break;case a.Engine.ALPHA_ADD:this.setDepthWrite(!1),this._gl.blendFuncSeparate(this._gl.ONE,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._gl.enable(this._gl.BLEND)}},h.prototype.setAlphaTesting=function(a){this._alphaTest=a},h.prototype.getAlphaTesting=function(){return this._alphaTest},h.prototype.wipeCaches=function(){this._activeTexturesCache=[],this._currentEffect=null,this._cullingState=null,this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null},h.prototype.setSamplingMode=function(b,c){var d=this._gl;d.bindTexture(d.TEXTURE_2D,b);var e=d.NEAREST,f=d.NEAREST;c===a.Texture.BILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=d.LINEAR):c===a.Texture.TRILINEAR_SAMPLINGMODE&&(e=d.LINEAR,f=d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,e),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,f),d.bindTexture(d.TEXTURE_2D,null)},h.prototype.createTexture=function(b,c,d,f,g){var h=this;"undefined"==typeof g&&(g=a.Texture.TRILINEAR_SAMPLINGMODE);var i=this._gl.createTexture(),j=b.substr(b.length-4,4).toLowerCase(),k=this.getCaps().s3tc&&".dds"===j,l=".tga"===j;if(f._addPendingData(i),i.url=b,i.noMipmap=c,i.references=1,this._loadedTexturesCache.push(i),l)a.Tools.LoadFile(b,function(b){var j=new Uint8Array(b),k=a.Internals.TGATools.GetTGAHeader(j);e(i,h._gl,f,k.width,k.height,d,c,!1,function(){a.Internals.TGATools.UploadContent(h._gl,j)},g)},null,f.database,!0);else if(k)a.Tools.LoadFile(b,function(j){var k=a.Internals.DDSTools.GetDDSInfo(j),l=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&!c&&k.width>>k.mipmapCount-1==1;e(i,h._gl,f,k.width,k.height,d,!l,k.isFourCC,function(){console.log("loading "+b),a.Internals.DDSTools.UploadDDSLevels(h._gl,h.getCaps().s3tc,j,k,l,1)},g)},null,f.database,!0);else{var m=function(a){e(i,h._gl,f,a.width,a.height,d,c,!1,function(b,c){var d=a.width==b&&a.height==c;d||(h._workingCanvas.width=b,h._workingCanvas.height=c,h._workingContext.drawImage(a,0,0,a.width,a.height,0,0,b,c)),h._gl.texImage2D(h._gl.TEXTURE_2D,0,h._gl.RGBA,h._gl.RGBA,h._gl.UNSIGNED_BYTE,d?a:h._workingCanvas)},g)},n=function(){f._removePendingData(i)};a.Tools.LoadImage(b,m,n,f.database)}return i},h.prototype.createDynamicTexture=function(a,b,e,f){var g=this._gl.createTexture();a=d(a,this._caps.maxTextureSize),b=d(b,this._caps.maxTextureSize),this._gl.bindTexture(this._gl.TEXTURE_2D,g);var h=c(f,e,this._gl);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,h.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,h.min),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],g._baseWidth=a,g._baseHeight=b,g._width=a,g._height=b,g.isReady=!1,g.generateMipMaps=e,g.references=1,this._loadedTexturesCache.push(g),g},h.prototype.updateDynamicTexture=function(a,b,c){this._gl.bindTexture(this._gl.TEXTURE_2D,a),this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,c?1:0),this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,b),a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],a.isReady=!0},h.prototype.updateVideoTexture=function(a,b,c){this._gl.bindTexture(this._gl.TEXTURE_2D,a),this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,c?0:1),b.videoWidth!==a._width||b.videoHeight!==a._height?(a._workingCanvas||(a._workingCanvas=document.createElement("canvas"),a._workingContext=a._workingCanvas.getContext("2d"),a._workingCanvas.width=a._width,a._workingCanvas.height=a._height),a._workingContext.drawImage(b,0,0,b.videoWidth,b.videoHeight,0,0,a._width,a._height),this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,a._workingCanvas)):this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,b),a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],a.isReady=!0},h.prototype.createRenderTargetTexture=function(b,d){var e=!1,f=!0,g=a.Texture.TRILINEAR_SAMPLINGMODE;void 0!==d&&(e=void 0===d.generateMipMaps?d:d.generateMipmaps,f=void 0===d.generateDepthBuffer?!0:d.generateDepthBuffer,void 0!==d.samplingMode&&(g=d.samplingMode));var h=this._gl,i=h.createTexture();h.bindTexture(h.TEXTURE_2D,i);var j=b.width||b,k=b.height||b,l=c(g,e,h);h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,l.mag),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,l.min),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,j,k,0,h.RGBA,h.UNSIGNED_BYTE,null);var m;f&&(m=h.createRenderbuffer(),h.bindRenderbuffer(h.RENDERBUFFER,m),h.renderbufferStorage(h.RENDERBUFFER,h.DEPTH_COMPONENT16,j,k));var n=h.createFramebuffer();return h.bindFramebuffer(h.FRAMEBUFFER,n),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,i,0),f&&h.framebufferRenderbuffer(h.FRAMEBUFFER,h.DEPTH_ATTACHMENT,h.RENDERBUFFER,m),h.bindTexture(h.TEXTURE_2D,null),h.bindRenderbuffer(h.RENDERBUFFER,null),h.bindFramebuffer(h.FRAMEBUFFER,null),i._framebuffer=n,f&&(i._depthBuffer=m),i._width=j,i._height=k,i.isReady=!0,i.generateMipMaps=e,i.references=1,this._activeTexturesCache=[],this._loadedTexturesCache.push(i),i},h.prototype.createCubeTexture=function(b,c,e,g){var h=this,i=this._gl,j=i.createTexture();j.isCube=!0,j.url=b,j.references=1,this._loadedTexturesCache.push(j);var k=b.substr(b.length-4,4).toLowerCase(),l=this.getCaps().s3tc&&".dds"===k;return l?a.Tools.LoadFile(b,function(b){var c=a.Internals.DDSTools.GetDDSInfo(b),d=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&!g;i.bindTexture(i.TEXTURE_CUBE_MAP,j),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),a.Internals.DDSTools.UploadDDSLevels(h._gl,h.getCaps().s3tc,b,c,d,6),g||c.isFourCC||1!=c.mipmapCount||i.generateMipmap(i.TEXTURE_CUBE_MAP),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,d?i.LINEAR_MIPMAP_LINEAR:i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.bindTexture(i.TEXTURE_CUBE_MAP,null),h._activeTexturesCache=[],j._width=c.width,j._height=c.height,j.isReady=!0}):f(b,0,[],c,function(a){var b=d(a[0].width,h._caps.maxCubemapTextureSize),c=b;h._workingCanvas.width=b,h._workingCanvas.height=c;var e=[i.TEXTURE_CUBE_MAP_POSITIVE_X,i.TEXTURE_CUBE_MAP_POSITIVE_Y,i.TEXTURE_CUBE_MAP_POSITIVE_Z,i.TEXTURE_CUBE_MAP_NEGATIVE_X,i.TEXTURE_CUBE_MAP_NEGATIVE_Y,i.TEXTURE_CUBE_MAP_NEGATIVE_Z];i.bindTexture(i.TEXTURE_CUBE_MAP,j),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,0);for(var f=0;f<e.length;f++)h._workingContext.drawImage(a[f],0,0,a[f].width,a[f].height,0,0,b,c),i.texImage2D(e[f],0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,h._workingCanvas);g||i.generateMipmap(i.TEXTURE_CUBE_MAP),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,g?i.LINEAR:i.LINEAR_MIPMAP_LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.bindTexture(i.TEXTURE_CUBE_MAP,null),h._activeTexturesCache=[],j._width=b,j._height=c,j.isReady=!0},e),j},h.prototype._releaseTexture=function(a){var b=this._gl;a._framebuffer&&b.deleteFramebuffer(a._framebuffer),a._depthBuffer&&b.deleteRenderbuffer(a._depthBuffer),b.deleteTexture(a);for(var c=0;c<this._caps.maxTexturesImageUnits;c++)this._gl.activeTexture(this._gl["TEXTURE"+c]),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,null),this._activeTexturesCache[c]=null;var d=this._loadedTexturesCache.indexOf(a);-1!==d&&this._loadedTexturesCache.splice(d,1)},h.prototype.bindSamplers=function(a){this._gl.useProgram(a.getProgram());for(var b=a.getSamplers(),c=0;c<b.length;c++){var d=a.getUniform(b[c]);this._gl.uniform1i(d,c)}this._currentEffect=null},h.prototype._bindTexture=function(a,b){this._gl.activeTexture(this._gl["TEXTURE"+a]),this._gl.bindTexture(this._gl.TEXTURE_2D,b),this._activeTexturesCache[a]=null},h.prototype.setTextureFromPostProcess=function(a,b){this._bindTexture(a,b._textures.data[b._currentRenderTextureInd])},h.prototype.setTexture=function(b,c){if(!(0>b)){if(!c||!c.isReady())return void(null!=this._activeTexturesCache[b]&&(this._gl.activeTexture(this._gl["TEXTURE"+b]),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,null),this._activeTexturesCache[b]=null));if(c instanceof a.VideoTexture)c.update()&&(this._activeTexturesCache[b]=null);else if(c.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED)return void c.delayLoad();if(this._activeTexturesCache[b]!=c){this._activeTexturesCache[b]=c;var d=c.getInternalTexture();if(this._gl.activeTexture(this._gl["TEXTURE"+b]),d.isCube){if(this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,d),d._cachedCoordinatesMode!==c.coordinatesMode){d._cachedCoordinatesMode=c.coordinatesMode;var e=c.coordinatesMode!==a.Texture.CUBIC_MODE&&c.coordinatesMode!==a.Texture.SKYBOX_MODE?this._gl.REPEAT:this._gl.CLAMP_TO_EDGE;this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP,this._gl.TEXTURE_WRAP_S,e),this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP,this._gl.TEXTURE_WRAP_T,e)}this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP,c)}else{if(this._gl.bindTexture(this._gl.TEXTURE_2D,d),d._cachedWrapU!==c.wrapU)switch(d._cachedWrapU=c.wrapU,c.wrapU){case a.Texture.WRAP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.REPEAT);break;case a.Texture.CLAMP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE);break;case a.Texture.MIRROR_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.MIRRORED_REPEAT)}if(d._cachedWrapV!==c.wrapV)switch(d._cachedWrapV=c.wrapV,c.wrapV){case a.Texture.WRAP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.REPEAT);break;case a.Texture.CLAMP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);break;case a.Texture.MIRROR_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.MIRRORED_REPEAT)
}this._setAnisotropicLevel(this._gl.TEXTURE_2D,c)}}}},h.prototype._setAnisotropicLevel=function(a,b){var c=this._caps.textureAnisotropicFilterExtension;c&&b._cachedAnisotropicFilteringLevel!==b.anisotropicFilteringLevel&&(this._gl.texParameterf(a,c.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropicFilteringLevel,this._caps.maxAnisotropy)),b._cachedAnisotropicFilteringLevel=b.anisotropicFilteringLevel)},h.prototype.readPixels=function(a,b,c,d){var e=new Uint8Array(d*c*4);return this._gl.readPixels(0,0,c,d,this._gl.RGBA,this._gl.UNSIGNED_BYTE,e),e},h.prototype.dispose=function(){for(this.stopRenderLoop();this.scenes.length;)this.scenes[0].dispose();for(var a in this._compiledEffects)this._gl.deleteProgram(this._compiledEffects[a]._program);for(var b in this._vertexAttribArrays)b>this._gl.VERTEX_ATTRIB_ARRAY_ENABLED||!this._vertexAttribArrays[b]||this._gl.disableVertexAttribArray(b);window.removeEventListener("blur",this._onBlur),window.removeEventListener("focus",this._onFocus),document.removeEventListener("fullscreenchange",this._onFullscreenChange),document.removeEventListener("mozfullscreenchange",this._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",this._onFullscreenChange),document.removeEventListener("msfullscreenchange",this._onFullscreenChange),document.removeEventListener("pointerlockchange",this._onPointerLockChange),document.removeEventListener("mspointerlockchange",this._onPointerLockChange),document.removeEventListener("mozpointerlockchange",this._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",this._onPointerLockChange)},h.isSupported=function(){try{var a=document.createElement("canvas"),b=a.getContext("webgl")||a.getContext("experimental-webgl");return null!=b&&!!window.WebGLRenderingContext}catch(c){return!1}},h._ALPHA_DISABLE=0,h._ALPHA_ADD=1,h._ALPHA_COMBINE=2,h._DELAYLOADSTATE_NONE=0,h._DELAYLOADSTATE_LOADED=1,h._DELAYLOADSTATE_LOADING=2,h._DELAYLOADSTATE_NOTLOADED=4,h.Epsilon=.001,h.CollisionsEpsilon=.001,h.ShadersRepository="Babylon/Shaders/",h}();a.Engine=h}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b){this.state="",this.animations=new Array,this._childrenFlag=-1,this._isEnabled=!0,this._isReady=!0,this._currentRenderId=-1,this.name=a,this.id=a,this._scene=b,this._initCache()}return b.prototype.getScene=function(){return this._scene},b.prototype.getEngine=function(){return this._scene.getEngine()},b.prototype.getWorldMatrix=function(){return a.Matrix.Identity()},b.prototype._initCache=function(){this._cache={},this._cache.parent=void 0},b.prototype.updateCache=function(a){(a||!this.isSynchronized())&&(this._cache.parent=this.parent,this._updateCache())},b.prototype._updateCache=function(){},b.prototype._isSynchronized=function(){return!0},b.prototype.isSynchronizedWithParent=function(){return this.parent?this.parent._currentRenderId<=this._currentRenderId:!0},b.prototype.isSynchronized=function(a){var b=this.hasNewParent();return b=b||!this.isSynchronizedWithParent(),b=b||!this._isSynchronized(),a&&this.updateCache(!0),!b},b.prototype.hasNewParent=function(a){return this._cache.parent===this.parent?!1:(a&&(this._cache.parent=this.parent),!0)},b.prototype.isReady=function(){return this._isReady},b.prototype.isEnabled=function(){return this._isEnabled?this.parent?this.parent.isEnabled():!0:!1},b.prototype.setEnabled=function(a){this._isEnabled=a},b.prototype.isDescendantOf=function(a){return this.parent?this.parent===a?!0:this.parent.isDescendantOf(a):!1},b.prototype._getDescendants=function(a,b){for(var c=0;c<a.length;c++){var d=a[c];d.isDescendantOf(this)&&b.push(d)}},b.prototype.getDescendants=function(){var a=[];return this._getDescendants(this._scene.meshes,a),this._getDescendants(this._scene.lights,a),this._getDescendants(this._scene.cameras,a),a},b.prototype._setReady=function(a){if(a!=this._isReady){if(!a)return void(this._isReady=!1);this._isReady=!0,this.onReady&&this.onReady(this)}},b}();a.Node=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.minimum=b,this.maximum=c,this._tempRadiusVector=a.Vector3.Zero();var d=a.Vector3.Distance(b,c);this.center=a.Vector3.Lerp(b,c,.5),this.radius=.5*d,this.centerWorld=a.Vector3.Zero(),this._update(a.Matrix.Identity())}return b.prototype._update=function(b){a.Vector3.TransformCoordinatesToRef(this.center,b,this.centerWorld),a.Vector3.TransformNormalFromFloatsToRef(1,1,1,b,this._tempRadiusVector),this.radiusWorld=Math.max(Math.abs(this._tempRadiusVector.x),Math.abs(this._tempRadiusVector.y),Math.abs(this._tempRadiusVector.z))*this.radius},b.prototype.isInFrustum=function(a){for(var b=0;6>b;b++)if(a[b].dotCoordinate(this.centerWorld)<=-this.radiusWorld)return!1;return!0},b.prototype.intersectsPoint=function(b){var c=this.centerWorld.x-b.x,d=this.centerWorld.y-b.y,e=this.centerWorld.z-b.z,f=Math.sqrt(c*c+d*d+e*e);return Math.abs(this.radiusWorld-f)<a.Engine.Epsilon?!1:!0},b.Intersects=function(a,b){var c=a.centerWorld.x-b.centerWorld.x,d=a.centerWorld.y-b.centerWorld.y,e=a.centerWorld.z-b.centerWorld.z,f=Math.sqrt(c*c+d*d+e*e);return a.radiusWorld+b.radiusWorld<f?!1:!0},b}();a.BoundingSphere=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.minimum=b,this.maximum=c,this.vectors=new Array,this.vectorsWorld=new Array,this.vectors.push(this.minimum.clone()),this.vectors.push(this.maximum.clone()),this.vectors.push(this.minimum.clone()),this.vectors[2].x=this.maximum.x,this.vectors.push(this.minimum.clone()),this.vectors[3].y=this.maximum.y,this.vectors.push(this.minimum.clone()),this.vectors[4].z=this.maximum.z,this.vectors.push(this.maximum.clone()),this.vectors[5].z=this.minimum.z,this.vectors.push(this.maximum.clone()),this.vectors[6].x=this.minimum.x,this.vectors.push(this.maximum.clone()),this.vectors[7].y=this.minimum.y,this.center=this.maximum.add(this.minimum).scale(.5),this.extends=this.maximum.subtract(this.minimum).scale(.5),this.directions=[a.Vector3.Zero(),a.Vector3.Zero(),a.Vector3.Zero()];for(var d=0;d<this.vectors.length;d++)this.vectorsWorld[d]=a.Vector3.Zero();this.minimumWorld=a.Vector3.Zero(),this.maximumWorld=a.Vector3.Zero(),this._update(a.Matrix.Identity())}return b.prototype.getWorldMatrix=function(){return this._worldMatrix},b.prototype._update=function(b){a.Vector3.FromFloatsToRef(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,this.minimumWorld),a.Vector3.FromFloatsToRef(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,this.maximumWorld);for(var c=0;c<this.vectors.length;c++){var d=this.vectorsWorld[c];a.Vector3.TransformCoordinatesToRef(this.vectors[c],b,d),d.x<this.minimumWorld.x&&(this.minimumWorld.x=d.x),d.y<this.minimumWorld.y&&(this.minimumWorld.y=d.y),d.z<this.minimumWorld.z&&(this.minimumWorld.z=d.z),d.x>this.maximumWorld.x&&(this.maximumWorld.x=d.x),d.y>this.maximumWorld.y&&(this.maximumWorld.y=d.y),d.z>this.maximumWorld.z&&(this.maximumWorld.z=d.z)}this.maximumWorld.addToRef(this.minimumWorld,this.center),this.center.scaleInPlace(.5),a.Vector3.FromFloatArrayToRef(b.m,0,this.directions[0]),a.Vector3.FromFloatArrayToRef(b.m,4,this.directions[1]),a.Vector3.FromFloatArrayToRef(b.m,8,this.directions[2]),this._worldMatrix=b},b.prototype.isInFrustum=function(a){return b.IsInFrustum(this.vectorsWorld,a)},b.prototype.intersectsPoint=function(b){var c=a.Engine.Epsilon;return this.maximumWorld.x-b.x<c||c>b.x-this.minimumWorld.x?!1:this.maximumWorld.y-b.y<c||c>b.y-this.minimumWorld.y?!1:this.maximumWorld.z-b.z<c||c>b.z-this.minimumWorld.z?!1:!0},b.prototype.intersectsSphere=function(a){return b.IntersectsSphere(this.minimumWorld,this.maximumWorld,a.centerWorld,a.radiusWorld)},b.prototype.intersectsMinMax=function(a,b){return this.maximumWorld.x<a.x||this.minimumWorld.x>b.x?!1:this.maximumWorld.y<a.y||this.minimumWorld.y>b.y?!1:this.maximumWorld.z<a.z||this.minimumWorld.z>b.z?!1:!0},b.Intersects=function(a,b){return a.maximumWorld.x<b.minimumWorld.x||a.minimumWorld.x>b.maximumWorld.x?!1:a.maximumWorld.y<b.minimumWorld.y||a.minimumWorld.y>b.maximumWorld.y?!1:a.maximumWorld.z<b.minimumWorld.z||a.minimumWorld.z>b.maximumWorld.z?!1:!0},b.IntersectsSphere=function(b,c,d,e){var f=a.Vector3.Clamp(d,b,c),g=a.Vector3.DistanceSquared(d,f);return e*e>=g},b.IsInFrustum=function(a,b){for(var c=0;6>c;c++){for(var d=8,e=0;8>e&&b[c].dotCoordinate(a[e])<0;e++)--d;if(0==d)return!1}return!0},b}();a.BoundingBox=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(b,c){var d=a.Vector3.Dot(c.center,b),e=Math.abs(a.Vector3.Dot(c.directions[0],b))*c.extends.x,f=Math.abs(a.Vector3.Dot(c.directions[1],b))*c.extends.y,g=Math.abs(a.Vector3.Dot(c.directions[2],b))*c.extends.z,h=e+f+g;return{min:d-h,max:d+h}},c=function(a,b,c,d){return!(a>d||c>b)},d=function(a,d,e){var f=b(a,d),g=b(a,e);return c(f.min,f.max,g.min,g.max)},e=function(){function b(b,c){this.minimum=b,this.maximum=c,this.boundingBox=new a.BoundingBox(b,c),this.boundingSphere=new a.BoundingSphere(b,c)}return b.prototype._update=function(a){this.boundingBox._update(a),this.boundingSphere._update(a)},b.prototype.isInFrustum=function(a){return this.boundingSphere.isInFrustum(a)?this.boundingBox.isInFrustum(a):!1},b.prototype._checkCollision=function(a){return a._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)},b.prototype.intersectsPoint=function(a){return this.boundingSphere.centerWorld&&this.boundingSphere.intersectsPoint(a)&&this.boundingBox.intersectsPoint(a)?!0:!1},b.prototype.intersects=function(b,c){if(!this.boundingSphere.centerWorld||!b.boundingSphere.centerWorld)return!1;if(!a.BoundingSphere.Intersects(this.boundingSphere,b.boundingSphere))return!1;if(!a.BoundingBox.Intersects(this.boundingBox,b.boundingBox))return!1;if(!c)return!0;var e=this.boundingBox,f=b.boundingBox;return d(e.directions[0],e,f)&&d(e.directions[1],e,f)&&d(e.directions[2],e,f)&&d(f.directions[0],e,f)&&d(f.directions[1],e,f)&&d(f.directions[2],e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[2]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[2]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[2]),e,f)?!0:!1},b}();a.BoundingInfo=e}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.diffuse=new a.Color3(1,1,1),this.specular=new a.Color3(1,1,1),this.intensity=1,this.range=Number.MAX_VALUE,this.excludedMeshes=new Array,this._excludedMeshesIds=new Array,d.lights.push(this)}return __extends(c,b),c.prototype.getShadowGenerator=function(){return this._shadowGenerator},c.prototype.transferToEffect=function(){},c.prototype._getWorldMatrix=function(){return a.Matrix.Identity()},c.prototype.getWorldMatrix=function(){this._currentRenderId=this.getScene().getRenderId();var b=this._getWorldMatrix();return this.parent&&this.parent.getWorldMatrix?(this._parentedWorldMatrix||(this._parentedWorldMatrix=a.Matrix.Identity()),b.multiplyToRef(this.parent.getWorldMatrix(),this._parentedWorldMatrix),this._parentedWorldMatrix):b},c.prototype.dispose=function(){this._shadowGenerator&&(this._shadowGenerator.dispose(),this._shadowGenerator=null);var a=this.getScene().lights.indexOf(this);this.getScene().lights.splice(a,1)},c}(a.Node);a.Light=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,d),this.position=c}return __extends(c,b),c.prototype.transferToEffect=function(b,c){return this.parent&&this.parent.getWorldMatrix?(this._transformedPosition||(this._transformedPosition=a.Vector3.Zero()),a.Vector3.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._transformedPosition),void b.setFloat4(c,this._transformedPosition.x,this._transformedPosition.y,this._transformedPosition.z,0)):void b.setFloat4(c,this.position.x,this.position.y,this.position.z,0)},c.prototype.getShadowGenerator=function(){return null},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.PointLight=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d,e,f,g){b.call(this,a,g),this.position=c,this.direction=d,this.angle=e,this.exponent=f}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(this.position)),this.direction},c.prototype.transferToEffect=function(b,c,d){var e;if(this.parent&&this.parent.getWorldMatrix){this._transformedDirection||(this._transformedDirection=a.Vector3.Zero()),this._transformedPosition||(this._transformedPosition=a.Vector3.Zero());var f=this.parent.getWorldMatrix();a.Vector3.TransformCoordinatesToRef(this.position,f,this._transformedPosition),a.Vector3.TransformNormalToRef(this.direction,f,this._transformedDirection),b.setFloat4(c,this._transformedPosition.x,this._transformedPosition.y,this._transformedPosition.z,this.exponent),e=a.Vector3.Normalize(this._transformedDirection)}else b.setFloat4(c,this.position.x,this.position.y,this.position.z,this.exponent),e=a.Vector3.Normalize(this.direction);b.setFloat4(d,e.x,e.y,e.z,Math.cos(.5*this.angle))},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.SpotLight=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,d),this.direction=c,this.position=c.scale(-1)}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(this.position)),this.direction},c.prototype._computeTransformedPosition=function(){return this.parent&&this.parent.getWorldMatrix?(this._transformedPosition||(this._transformedPosition=a.Vector3.Zero()),a.Vector3.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._transformedPosition),!0):!1},c.prototype.transferToEffect=function(b,c){return this.parent&&this.parent.getWorldMatrix?(this._transformedDirection||(this._transformedDirection=a.Vector3.Zero()),a.Vector3.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this._transformedDirection),void b.setFloat4(c,this._transformedDirection.x,this._transformedDirection.y,this._transformedDirection.z,1)):void b.setFloat4(c,this.direction.x,this.direction.y,this.direction.z,1)},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.DirectionalLight=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(c,d){var e=this;this.filter=b.FILTER_VARIANCESHADOWMAP,this._darkness=0,this._transparencyShadow=!1,this._viewMatrix=a.Matrix.Zero(),this._projectionMatrix=a.Matrix.Zero(),this._transformMatrix=a.Matrix.Zero(),this._worldViewProjection=a.Matrix.Zero(),this._light=d,this._scene=d.getScene(),d._shadowGenerator=this,this._shadowMap=new a.RenderTargetTexture(d.name+"_shadowMap",c,this._scene,!1),this._shadowMap.wrapU=a.Texture.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._shadowMap.renderParticles=!1;var f=function(b){var c=b.getRenderingMesh(),d=e._scene,f=d.getEngine();f.setState(b.getMaterial().backFaceCulling);var g=c._getInstancesRenderList(b._id);if(!g.mustReturn){var h=null!==f.getCaps().instancedArrays&&null!==g.visibleInstances;if(e.isReady(b,h)){f.enableEffect(e._effect),c._bind(b,e._effect,!1);var i=b.getMaterial();if(e._effect.setMatrix("viewProjection",e.getTransformMatrix()),i&&i.needAlphaTesting()){var j=i.getAlphaTestTexture();e._effect.setTexture("diffuseSampler",j),e._effect.setMatrix("diffuseMatrix",j.getTextureMatrix())}var k=c.skeleton&&c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind);if(k&&e._effect.setMatrices("mBones",c.skeleton.getTransformMatrices()),h)c._renderWithInstances(b,!1,g,e._effect,f);else if(g.renderSelf[b._id]&&(e._effect.setMatrix("world",c.getWorldMatrix()),c._draw(b,!0)),g.visibleInstances[b._id])for(var l=0;l<g.visibleInstances[b._id].length;l++){var m=g.visibleInstances[b._id][l];e._effect.setMatrix("world",m.getWorldMatrix()),c._draw(b,!0)}}else e._shadowMap.resetRefreshCounter()}};this._shadowMap.customRenderFunction=function(a,b,c){var d;for(d=0;d<a.length;d++)f(a.data[d]);for(d=0;d<b.length;d++)f(b.data[d]);if(e._transparencyShadow)for(d=0;d<c.length;d++)f(c.data[d])}}return Object.defineProperty(b,"FILTER_NONE",{get:function(){return b._FILTER_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"FILTER_VARIANCESHADOWMAP",{get:function(){return b._FILTER_VARIANCESHADOWMAP},enumerable:!0,configurable:!0}),Object.defineProperty(b,"FILTER_POISSONSAMPLING",{get:function(){return b._FILTER_POISSONSAMPLING},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"useVarianceShadowMap",{get:function(){return this.filter===b.FILTER_VARIANCESHADOWMAP},set:function(a){this.filter=a?b.FILTER_VARIANCESHADOWMAP:b.FILTER_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"usePoissonSampling",{get:function(){return this.filter===b.FILTER_POISSONSAMPLING},set:function(a){this.filter=a?b.FILTER_POISSONSAMPLING:b.FILTER_NONE},enumerable:!0,configurable:!0}),b.prototype.isReady=function(b,c){var d=[];this.useVarianceShadowMap&&d.push("#define VSM");var e=[a.VertexBuffer.PositionKind],f=b.getMesh(),g=b.getMaterial();g&&g.needAlphaTesting()&&(d.push("#define ALPHATEST"),f.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(e.push(a.VertexBuffer.UVKind),d.push("#define UV1")),f.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(e.push(a.VertexBuffer.UV2Kind),d.push("#define UV2"))),f.skeleton&&f.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&f.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(e.push(a.VertexBuffer.MatricesIndicesKind),e.push(a.VertexBuffer.MatricesWeightsKind),d.push("#define BONES"),d.push("#define BonesPerMesh "+(f.skeleton.bones.length+1))),c&&(d.push("#define INSTANCES"),e.push("world0"),e.push("world1"),e.push("world2"),e.push("world3"));var h=d.join("\n");return this._cachedDefines!=h&&(this._cachedDefines=h,this._effect=this._scene.getEngine().createEffect("shadowMap",e,["world","mBones","viewProjection","diffuseMatrix"],["diffuseSampler"],h)),this._effect.isReady()},b.prototype.getShadowMap=function(){return this._shadowMap},b.prototype.getLight=function(){return this._light},b.prototype.getTransformMatrix=function(){var b=this._light.position,c=this._light.direction;if(this._light._computeTransformedPosition()&&(b=this._light._transformedPosition),!(this._cachedPosition&&this._cachedDirection&&b.equals(this._cachedPosition)&&c.equals(this._cachedDirection))){this._cachedPosition=b.clone(),this._cachedDirection=c.clone();var d=this._scene.activeCamera;a.Matrix.LookAtLHToRef(b,this._light.position.add(c),a.Vector3.Up(),this._viewMatrix),a.Matrix.PerspectiveFovLHToRef(Math.PI/2,1,d.minZ,d.maxZ,this._projectionMatrix),this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix},b.prototype.getDarkness=function(){return this._darkness},b.prototype.setDarkness=function(a){a>=1?this._darkness=1:0>=a&&(this._darkness=0),elsethis._darkness=a},b.prototype.setTransparencyShadow=function(a){this._transparencyShadow=a},b.prototype.dispose=function(){this._shadowMap.dispose()},b._FILTER_NONE=0,b._FILTER_VARIANCESHADOWMAP=1,b._FILTER_POISSONSAMPLING=2,b}();a.ShadowGenerator=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,e),this.direction=d,this.groundColor=new a.Color3(0,0,0)}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(a.Vector3.Zero())),this.direction},c.prototype.getShadowGenerator=function(){return null},c.prototype.transferToEffect=function(b,c,d){var e=a.Vector3.Normalize(this.direction);b.setFloat4(c,e.x,e.y,e.z,0),b.setColor3(d,this.groundColor.scale(this.intensity))},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),this._worldMatrix},c}(a.Light);a.HemisphericLight=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b,c,d){return a.x>c.x+d?!1:c.x-d>b.x?!1:a.y>c.y+d?!1:c.y-d>b.y?!1:a.z>c.z+d?!1:c.z-d>b.z?!1:!0},c=function(a,b,c,d){var e=b*b-4*a*c,f={root:0,found:!1};if(0>e)return f;var g=Math.sqrt(e),h=(-b-g)/(2*a),i=(-b+g)/(2*a);if(h>i){var j=i;i=h,h=j}return h>0&&d>h?(f.root=h,f.found=!0,f):i>0&&d>i?(f.root=i,f.found=!0,f):f},d=function(){function d(){this.radius=new a.Vector3(1,1,1),this.retry=0,this.basePointWorld=a.Vector3.Zero(),this.velocityWorld=a.Vector3.Zero(),this.normalizedVelocity=a.Vector3.Zero(),this._collisionPoint=a.Vector3.Zero(),this._planeIntersectionPoint=a.Vector3.Zero(),this._tempVector=a.Vector3.Zero(),this._tempVector2=a.Vector3.Zero(),this._tempVector3=a.Vector3.Zero(),this._tempVector4=a.Vector3.Zero(),this._edge=a.Vector3.Zero(),this._baseToVertex=a.Vector3.Zero(),this._destinationPoint=a.Vector3.Zero(),this._slidePlaneNormal=a.Vector3.Zero(),this._displacementVector=a.Vector3.Zero()}return d.prototype._initialize=function(b,c,d){this.velocity=c,a.Vector3.NormalizeToRef(c,this.normalizedVelocity),this.basePoint=b,b.multiplyToRef(this.radius,this.basePointWorld),c.multiplyToRef(this.radius,this.velocityWorld),this.velocityWorldLength=this.velocityWorld.length(),this.epsilon=d,this.collisionFound=!1},d.prototype._checkPointInTriangle=function(b,c,d,e,f){c.subtractToRef(b,this._tempVector),d.subtractToRef(b,this._tempVector2),a.Vector3.CrossToRef(this._tempVector,this._tempVector2,this._tempVector4);var g=a.Vector3.Dot(this._tempVector4,f);return 0>g?!1:(e.subtractToRef(b,this._tempVector3),a.Vector3.CrossToRef(this._tempVector2,this._tempVector3,this._tempVector4),g=a.Vector3.Dot(this._tempVector4,f),0>g?!1:(a.Vector3.CrossToRef(this._tempVector3,this._tempVector,this._tempVector4),g=a.Vector3.Dot(this._tempVector4,f),g>=0))},d.prototype._canDoCollision=function(c,d,e,f){var g=a.Vector3.Distance(this.basePointWorld,c),h=Math.max(this.radius.x,this.radius.y,this.radius.z);return g>this.velocityWorldLength+h+d?!1:b(e,f,this.basePointWorld,this.velocityWorldLength+h)?!0:!1},d.prototype._testTriangle=function(b,d,e,f,g){var h,i=!1;d._trianglePlanes||(d._trianglePlanes=[]),d._trianglePlanes[b]||(d._trianglePlanes[b]=new a.Plane(0,0,0,0),d._trianglePlanes[b].copyFromPoints(e,f,g));var j=d._trianglePlanes[b];if(d.getMaterial()||j.isFrontFacingTo(this.normalizedVelocity,0)){var k=j.signedDistanceTo(this.basePoint),l=a.Vector3.Dot(j.normal,this.velocity);if(0==l){if(Math.abs(k)>=1)return;i=!0,h=0}else{h=(-1-k)/l;var m=(1-k)/l;if(h>m){var n=m;m=h,h=n}if(h>1||0>m)return;0>h&&(h=0),h>1&&(h=1)}this._collisionPoint.copyFromFloats(0,0,0);var o=!1,p=1;if(i||(this.basePoint.subtractToRef(j.normal,this._planeIntersectionPoint),this.velocity.scaleToRef(h,this._tempVector),this._planeIntersectionPoint.addInPlace(this._tempVector),this._checkPointInTriangle(this._planeIntersectionPoint,e,f,g,j.normal)&&(o=!0,p=h,this._collisionPoint.copyFrom(this._planeIntersectionPoint))),!o){var q=this.velocity.lengthSquared(),r=q;this.basePoint.subtractToRef(e,this._tempVector);var s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p);u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(e)),this.basePoint.subtractToRef(f,this._tempVector),s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p),u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(f)),this.basePoint.subtractToRef(g,this._tempVector),s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p),u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(g)),f.subtractToRef(e,this._edge),e.subtractToRef(this.basePoint,this._baseToVertex);var v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex);if(r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found){var y=(w*u.root-x)/v;y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),e.addToRef(this._edge,this._collisionPoint))}g.subtractToRef(f,this._edge),f.subtractToRef(this.basePoint,this._baseToVertex),v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex),r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found&&(y=(w*u.root-x)/v,y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),f.addToRef(this._edge,this._collisionPoint))),e.subtractToRef(g,this._edge),g.subtractToRef(this.basePoint,this._baseToVertex),v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex),r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found&&(y=(w*u.root-x)/v,y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),g.addToRef(this._edge,this._collisionPoint)))}if(o){var z=p*this.velocity.length();(!this.collisionFound||z<this.nearestDistance)&&(this.intersectionPoint?this.intersectionPoint.copyFrom(this._collisionPoint):this.intersectionPoint=this._collisionPoint.clone(),this.nearestDistance=z,this.collisionFound=!0,this.collidedMesh=d.getMesh())}}},d.prototype._collide=function(a,b,c,d,e,f){for(var g=d;e>g;g+=3){var h=b[c[g]-f],i=b[c[g+1]-f],j=b[c[g+2]-f];this._testTriangle(g,a,j,i,h)}},d.prototype._getResponse=function(b,c){b.addToRef(c,this._destinationPoint),c.scaleInPlace(this.nearestDistance/c.length()),this.basePoint.addToRef(c,b),b.subtractToRef(this.intersectionPoint,this._slidePlaneNormal),this._slidePlaneNormal.normalize(),this._slidePlaneNormal.scaleToRef(this.epsilon,this._displacementVector),b.addInPlace(this._displacementVector),this.intersectionPoint.addInPlace(this._displacementVector),this._slidePlaneNormal.scaleInPlace(a.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint,this._slidePlaneNormal,this._destinationPoint)),this._destinationPoint.subtractInPlace(this._slidePlaneNormal),this._destinationPoint.subtractToRef(this.intersectionPoint,c)},d}();a.Collider=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(d,e,f){b.call(this,d,f),this.position=e,this.upVector=a.Vector3.Up(),this.orthoLeft=null,this.orthoRight=null,this.orthoBottom=null,this.orthoTop=null,this.fov=.8,this.minZ=.1,this.maxZ=1e3,this.inertia=.9,this.mode=c.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new a.Viewport(0,0,1,1),this.subCameras=[],this.layerMask=4294967295,this._computedViewMatrix=a.Matrix.Identity(),this._projectionMatrix=new a.Matrix,this._postProcesses=new Array,this._postProcessesTakenIndices=[],f.cameras.push(this),f.activeCamera||(f.activeCamera=this)}return __extends(c,b),c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.position=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0},c.prototype._updateCache=function(a){a||b.prototype._updateCache.call(this);var c=this.getEngine();this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector),this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._cache.fov=this.fov,this._cache.aspectRatio=c.getAspectRatio(this),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.renderWidth=c.getRenderWidth(),this._cache.renderHeight=c.getRenderHeight()},c.prototype._updateFromScene=function(){this.updateCache(),this._update()},c.prototype._isSynchronized=function(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()},c.prototype._isSynchronizedViewMatrix=function(){return b.prototype._isSynchronized.call(this)?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1},c.prototype._isSynchronizedProjectionMatrix=function(){var b=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!b)return!1;var c=this.getEngine();return b=this.mode===a.Camera.PERSPECTIVE_CAMERA?this._cache.fov===this.fov&&this._cache.aspectRatio===c.getAspectRatio(this):this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===c.getRenderWidth()&&this._cache.renderHeight===c.getRenderHeight()},c.prototype.attachControl=function(){},c.prototype.detachControl=function(){},c.prototype._update=function(){},c.prototype.attachPostProcess=function(b,c){if("undefined"==typeof c&&(c=null),!b.isReusable()&&this._postProcesses.indexOf(b)>-1)return a.Tools.Error("You're trying to reuse a post process not defined as reusable."),0;if(null==c||0>c)return this._postProcesses.push(b),this._postProcessesTakenIndices.push(this._postProcesses.length-1),this._postProcesses.length-1;var d=0;if(this._postProcesses[c]){for(var e=this._postProcesses.length-1,f=e;f>=c+1;--f)this._postProcesses[f+1]=this._postProcesses[f];d=1}for(f=0;f<this._postProcessesTakenIndices.length;++f)if(!(this._postProcessesTakenIndices[f]<c)){e=this._postProcessesTakenIndices.length-1;for(var g=e;g>=f;--g)this._postProcessesTakenIndices[g+1]=this._postProcessesTakenIndices[g]+d;this._postProcessesTakenIndices[f]=c;break}d||-1!=this._postProcessesTakenIndices.indexOf(c)||this._postProcessesTakenIndices.push(c);var h=c+d;return this._postProcesses[h]=b,h},c.prototype.detachPostProcess=function(a,b){"undefined"==typeof b&&(b=null);var c=[];if(b)for(b=b instanceof Array?b:[b],f=0;f<b.length;f++){var d=this._postProcesses[b[f]];d===a?(delete this._postProcesses[b[f]],g=this._postProcessesTakenIndices.indexOf(b[f]),this._postProcessesTakenIndices.splice(g,1)):c.push(f)
}else for(var e=this._postProcesses.length,f=0;e>f;f++)if(this._postProcesses[f]===a){delete this._postProcesses[f];var g=this._postProcessesTakenIndices.indexOf(f);this._postProcessesTakenIndices.splice(g,1)}return c},c.prototype.getWorldMatrix=function(){this._worldMatrix||(this._worldMatrix=a.Matrix.Identity());var b=this.getViewMatrix();return b.invertToRef(this._worldMatrix),this._worldMatrix},c.prototype._getViewMatrix=function(){return a.Matrix.Identity()},c.prototype.getViewMatrix=function(){return this._computedViewMatrix=this._computeViewMatrix(),this.parent&&this.parent.getWorldMatrix&&!this.isSynchronized()?(this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),this._computedViewMatrix.invertToRef(this._worldMatrix),this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._computedViewMatrix),this._computedViewMatrix.invert(),this._currentRenderId=this.getScene().getRenderId(),this._computedViewMatrix):this._computedViewMatrix},c.prototype._computeViewMatrix=function(a){return!a&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._computedViewMatrix=this._getViewMatrix(),this.parent&&this.parent.getWorldMatrix||(this._currentRenderId=this.getScene().getRenderId()),this._computedViewMatrix)},c.prototype.getProjectionMatrix=function(b){if(!b&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;var c=this.getEngine();if(this.mode===a.Camera.PERSPECTIVE_CAMERA)return this.minZ<=0&&(this.minZ=.1),a.Matrix.PerspectiveFovLHToRef(this.fov,c.getAspectRatio(this),this.minZ,this.maxZ,this._projectionMatrix),this._projectionMatrix;var d=c.getRenderWidth()/2,e=c.getRenderHeight()/2;return a.Matrix.OrthoOffCenterLHToRef(this.orthoLeft||-d,this.orthoRight||d,this.orthoBottom||-e,this.orthoTop||e,this.minZ,this.maxZ,this._projectionMatrix),this._projectionMatrix},c.prototype.dispose=function(){var a=this.getScene().cameras.indexOf(this);this.getScene().cameras.splice(a,1);for(var b=0;b<this._postProcessesTakenIndices.length;++b)this._postProcesses[this._postProcessesTakenIndices[b]].dispose(this)},c.PERSPECTIVE_CAMERA=0,c.ORTHOGRAPHIC_CAMERA=1,c}(a.Node);a.Camera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,d,e),this.cameraDirection=new a.Vector3(0,0,0),this.cameraRotation=new a.Vector2(0,0),this.rotation=new a.Vector3(0,0,0),this.ellipsoid=new a.Vector3(.5,1,.5),this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.speed=2,this.checkCollisions=!1,this.applyGravity=!1,this.noRotationConstraint=!1,this.angularSensibility=2e3,this.lockedTarget=null,this._keys=[],this._collider=new a.Collider,this._needMoveForGravity=!0,this._currentTarget=a.Vector3.Zero(),this._viewMatrix=a.Matrix.Zero(),this._camMatrix=a.Matrix.Zero(),this._cameraTransformMatrix=a.Matrix.Zero(),this._cameraRotationMatrix=a.Matrix.Zero(),this._referencePoint=new a.Vector3(0,0,1),this._transformedReferencePoint=a.Vector3.Zero(),this._oldPosition=a.Vector3.Zero(),this._diffPosition=a.Vector3.Zero(),this._newPosition=a.Vector3.Zero(),this._lookAtTemp=a.Matrix.Zero(),this._tempMatrix=a.Matrix.Zero()}return __extends(c,b),c.prototype._getLockedTargetPosition=function(){return this.lockedTarget?this.lockedTarget.position||this.lockedTarget:null},c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.lockedTarget=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},c.prototype._updateCache=function(a){a||b.prototype._updateCache.call(this);var c=this._getLockedTargetPosition();c?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(c):this._cache.lockedTarget=c.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation)},c.prototype._isSynchronizedViewMatrix=function(){if(!b.prototype._isSynchronizedViewMatrix.call(this))return!1;var a=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(a):!a)&&this._cache.rotation.equals(this.rotation)},c.prototype._computeLocalCameraSpeed=function(){return this.speed*(a.Tools.GetDeltaTime()/(10*a.Tools.GetFps()))},c.prototype.setTarget=function(b){this.upVector.normalize(),a.Matrix.LookAtLHToRef(this.position,b,this.upVector,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);var c=b.subtract(this.position);this.rotation.y=c.x>=0?-Math.atan(c.z/c.x)+Math.PI/2:-Math.atan(c.z/c.x)-Math.PI/2,this.rotation.z=-Math.acos(a.Vector3.Dot(new a.Vector3(0,1,0),this.upVector)),isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0)},c.prototype.getTarget=function(){return this._currentTarget},c.prototype.attachControl=function(b,c){var d,e=this,f=this.getEngine();this._attachedElement||(this._attachedElement=b,void 0===this._onMouseDown&&(this._onMouseDown=function(a){d={x:a.clientX,y:a.clientY},c||a.preventDefault()},this._onMouseUp=function(a){d=null,c||a.preventDefault()},this._onMouseOut=function(a){d=null,e._keys=[],c||a.preventDefault()},this._onMouseMove=function(a){if(d||f.isPointerLock){var b,g;f.isPointerLock?(b=a.movementX||a.mozMovementX||a.webkitMovementX||a.msMovementX||0,g=a.movementY||a.mozMovementY||a.webkitMovementY||a.msMovementY||0):(b=a.clientX-d.x,g=a.clientY-d.y),e.cameraRotation.y+=b/e.angularSensibility,e.cameraRotation.x+=g/e.angularSensibility,d={x:a.clientX,y:a.clientY},c||a.preventDefault()}},this._onKeyDown=function(a){if(-1!==e.keysUp.indexOf(a.keyCode)||-1!==e.keysDown.indexOf(a.keyCode)||-1!==e.keysLeft.indexOf(a.keyCode)||-1!==e.keysRight.indexOf(a.keyCode)){var b=e._keys.indexOf(a.keyCode);-1===b&&e._keys.push(a.keyCode),c||a.preventDefault()}},this._onKeyUp=function(a){if(-1!==e.keysUp.indexOf(a.keyCode)||-1!==e.keysDown.indexOf(a.keyCode)||-1!==e.keysLeft.indexOf(a.keyCode)||-1!==e.keysRight.indexOf(a.keyCode)){var b=e._keys.indexOf(a.keyCode);b>=0&&e._keys.splice(b,1),c||a.preventDefault()}},this._onLostFocus=function(){e._keys=[]},this._reset=function(){e._keys=[],d=null,e.cameraDirection=new a.Vector3(0,0,0),e.cameraRotation=new a.Vector2(0,0)}),b.addEventListener("mousedown",this._onMouseDown,!1),b.addEventListener("mouseup",this._onMouseUp,!1),b.addEventListener("mouseout",this._onMouseOut,!1),b.addEventListener("mousemove",this._onMouseMove,!1),a.Tools.RegisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]))},c.prototype.detachControl=function(b){this._attachedElement==b&&(b.removeEventListener("mousedown",this._onMouseDown),b.removeEventListener("mouseup",this._onMouseUp),b.removeEventListener("mouseout",this._onMouseOut),b.removeEventListener("mousemove",this._onMouseMove),a.Tools.UnregisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]),this._attachedElement=null,this._reset&&this._reset())},c.prototype._collideWithWorld=function(b){var c;c=this.parent?a.Vector3.TransformCoordinates(this.position,this.parent.getWorldMatrix()):this.position,c.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._collider.radius=this.ellipsoid,this.getScene()._getNewPosition(this._oldPosition,b,this._collider,3,this._newPosition),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>a.Engine.CollisionsEpsilon&&(this.position.addInPlace(this._diffPosition),this.onCollide&&this.onCollide(this._collider.collidedMesh))},c.prototype._checkInputs=function(){this._localDirection||(this._localDirection=a.Vector3.Zero(),this._transformedDirection=a.Vector3.Zero());for(var b=0;b<this._keys.length;b++){var c=this._keys[b],d=this._computeLocalCameraSpeed();-1!==this.keysLeft.indexOf(c)?this._localDirection.copyFromFloats(-d,0,0):-1!==this.keysUp.indexOf(c)?this._localDirection.copyFromFloats(0,0,d):-1!==this.keysRight.indexOf(c)?this._localDirection.copyFromFloats(d,0,0):-1!==this.keysDown.indexOf(c)&&this._localDirection.copyFromFloats(0,0,-d),this.getViewMatrix().invertToRef(this._cameraTransformMatrix),a.Vector3.TransformNormalToRef(this._localDirection,this._cameraTransformMatrix,this._transformedDirection),this.cameraDirection.addInPlace(this._transformedDirection)}},c.prototype._update=function(){this._checkInputs();var b=this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0,c=Math.abs(this.cameraRotation.x)>0||Math.abs(this.cameraRotation.y)>0;if(b)if(this.checkCollisions&&this.getScene().collisionsEnabled){if(this._collideWithWorld(this.cameraDirection),this.applyGravity){var d=this.position;this._collideWithWorld(this.getScene().gravity),this._needMoveForGravity=0!=a.Vector3.DistanceSquared(d,this.position)}}else this.position.addInPlace(this.cameraDirection);if(c&&(this.rotation.x+=this.cameraRotation.x,this.rotation.y+=this.cameraRotation.y,!this.noRotationConstraint)){var e=Math.PI/2*.95;this.rotation.x>e&&(this.rotation.x=e),this.rotation.x<-e&&(this.rotation.x=-e)}b&&(Math.abs(this.cameraDirection.x)<a.Engine.Epsilon&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<a.Engine.Epsilon&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<a.Engine.Epsilon&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),c&&(Math.abs(this.cameraRotation.x)<a.Engine.Epsilon&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<a.Engine.Epsilon&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia))},c.prototype._getViewMatrix=function(){return this.lockedTarget?this._currentTarget.copyFrom(this._getLockedTargetPosition()):(0!=this.upVector.x||1!=this.upVector.y||0!=this.upVector.z?(a.Matrix.LookAtLHToRef(a.Vector3.Zero(),this._referencePoint,this.upVector,this._lookAtTemp),a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix,this._tempMatrix),this._lookAtTemp.invert(),this._tempMatrix.multiplyToRef(this._lookAtTemp,this._cameraRotationMatrix)):a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),a.Vector3.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget)),a.Matrix.LookAtLHToRef(this.position,this._currentTarget,this.upVector,this._viewMatrix),this._viewMatrix},c}(a.Camera);a.FreeCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,c,d),this._offsetX=null,this._offsetY=null,this._pointerCount=0,this._pointerPressed=[],this.angularSensibility=2e5,this.moveSensibility=500}return __extends(c,b),c.prototype.attachControl=function(b,c){var d,e=this;this._attachedCanvas||(this._attachedCanvas=b,void 0===this._onPointerDown&&(this._onPointerDown=function(a){c||a.preventDefault(),e._pointerPressed.push(a.pointerId),1===e._pointerPressed.length&&(d={x:a.clientX,y:a.clientY})},this._onPointerUp=function(a){c||a.preventDefault();var b=e._pointerPressed.indexOf(a.pointerId);-1!==b&&(e._pointerPressed.splice(b,1),0==b&&(d=null,e._offsetX=null,e._offsetY=null))},this._onPointerMove=function(a){if(c||a.preventDefault(),d){var b=e._pointerPressed.indexOf(a.pointerId);0==b&&(e._offsetX=a.clientX-d.x,e._offsetY=-(a.clientY-d.y))}},this._onLostFocus=function(){e._offsetX=null,e._offsetY=null}),b.addEventListener("pointerdown",this._onPointerDown),b.addEventListener("pointerup",this._onPointerUp),b.addEventListener("pointerout",this._onPointerUp),b.addEventListener("pointermove",this._onPointerMove),a.Tools.RegisterTopRootEvents([{name:"blur",handler:this._onLostFocus}]))},c.prototype.detachControl=function(b){this._attachedCanvas==b&&(b.removeEventListener("pointerdown",this._onPointerDown),b.removeEventListener("pointerup",this._onPointerUp),b.removeEventListener("pointerout",this._onPointerUp),b.removeEventListener("pointermove",this._onPointerMove),a.Tools.UnregisterTopRootEvents([{name:"blur",handler:this._onLostFocus}]),this._attachedCanvas=null)},c.prototype._checkInputs=function(){if(this._offsetX)if(this.cameraRotation.y+=this._offsetX/this.angularSensibility,this._pointerPressed.length>1)this.cameraRotation.x+=-this._offsetY/this.angularSensibility;else{var b=this._computeLocalCameraSpeed(),c=new a.Vector3(0,0,b*this._offsetY/this.moveSensibility);a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,0,this._cameraRotationMatrix),this.cameraDirection.addInPlace(a.Vector3.TransformCoordinates(c,this._cameraRotationMatrix))}},c}(a.FreeCamera);a.TouchCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){var e=this;b.call(this,a,c,d),this._offsetX=null,this._offsetY=null,this._orientationGamma=0,this._orientationBeta=0,this._initialOrientationGamma=0,this._initialOrientationBeta=0,this.angularSensibility=1e4,this.moveSensibility=50,window.addEventListener("resize",function(){e._initialOrientationGamma=null},!1)}return __extends(c,b),c.prototype.attachControl=function(a){var b=this;this._attachedCanvas||(this._attachedCanvas=a,this._orientationChanged||(this._orientationChanged=function(a){b._initialOrientationGamma||(b._initialOrientationGamma=a.gamma,b._initialOrientationBeta=a.beta),b._orientationGamma=a.gamma,b._orientationBeta=a.beta,b._offsetY=b._initialOrientationBeta-b._orientationBeta,b._offsetX=b._initialOrientationGamma-b._orientationGamma}),window.addEventListener("deviceorientation",this._orientationChanged))},c.prototype.detachControl=function(a){this._attachedCanvas==a&&(window.removeEventListener("deviceorientation",this._orientationChanged),this._attachedCanvas=null,this._orientationGamma=0,this._orientationBeta=0,this._initialOrientationGamma=0,this._initialOrientationBeta=0)},c.prototype._checkInputs=function(){if(this._offsetX){this.cameraRotation.y-=this._offsetX/this.angularSensibility;var b=this._computeLocalCameraSpeed(),c=new a.Vector3(0,0,b*this._offsetY/this.moveSensibility);a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,0,this._cameraRotationMatrix),this.cameraDirection.addInPlace(a.Vector3.TransformCoordinates(c,this._cameraRotationMatrix))}},c}(a.FreeCamera);a.DeviceOrientationCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=a.Tools.GetPointerPrefix(),c=function(c){function d(b,d,e,f,g,h){c.call(this,b,a.Vector3.Zero(),h),this.alpha=d,this.beta=e,this.radius=f,this.target=g,this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.lowerAlphaLimit=null,this.upperAlphaLimit=null,this.lowerBetaLimit=.01,this.upperBetaLimit=Math.PI,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.angularSensibility=1e3,this.wheelPrecision=3,this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.zoomOnFactor=1,this._keys=[],this._viewMatrix=new a.Matrix,this.checkCollisions=!1,this.collisionRadius=new a.Vector3(.5,.5,.5),this._collider=new a.Collider,this._previousPosition=a.Vector3.Zero(),this._collisionVelocity=a.Vector3.Zero(),this._newPosition=a.Vector3.Zero(),this.getViewMatrix()}return __extends(d,c),d.prototype._getTargetPosition=function(){return this.target.position||this.target},d.prototype._initCache=function(){c.prototype._initCache.call(this),this._cache.target=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.alpha=void 0,this._cache.beta=void 0,this._cache.radius=void 0},d.prototype._updateCache=function(a){a||c.prototype._updateCache.call(this),this._cache.target.copyFrom(this._getTargetPosition()),this._cache.alpha=this.alpha,this._cache.beta=this.beta,this._cache.radius=this.radius},d.prototype._isSynchronizedViewMatrix=function(){return c.prototype._isSynchronizedViewMatrix.call(this)?this._cache.target.equals(this._getTargetPosition())&&this._cache.alpha===this.alpha&&this._cache.beta===this.beta&&this._cache.radius===this.radius:!1},d.prototype.attachControl=function(c,d){var e,f,g=this;if(!this._attachedElement){this._attachedElement=c;var h=this.getEngine();void 0===this._onPointerDown&&(this._onPointerDown=function(a){f||(f=a.pointerId,e={x:a.clientX,y:a.clientY},d||a.preventDefault())},this._onPointerUp=function(a){e=null,f=null,d||a.preventDefault()},this._onPointerMove=function(a){if(e&&f===a.pointerId){var b=a.clientX-e.x,c=a.clientY-e.y;g.inertialAlphaOffset-=b/g.angularSensibility,g.inertialBetaOffset-=c/g.angularSensibility,e={x:a.clientX,y:a.clientY},d||a.preventDefault()}},this._onMouseMove=function(a){if(h.isPointerLock){var b=a.movementX||a.mozMovementX||a.webkitMovementX||a.msMovementX||0,c=a.movementY||a.mozMovementY||a.webkitMovementY||a.msMovementY||0;g.inertialAlphaOffset-=b/g.angularSensibility,g.inertialBetaOffset-=c/g.angularSensibility,d||a.preventDefault()}},this._wheel=function(a){var b=0;a.wheelDelta?b=a.wheelDelta/(40*g.wheelPrecision):a.detail&&(b=-a.detail/g.wheelPrecision),b&&(g.inertialRadiusOffset+=b),a.preventDefault&&(d||a.preventDefault())},this._onKeyDown=function(a){if(-1!==g.keysUp.indexOf(a.keyCode)||-1!==g.keysDown.indexOf(a.keyCode)||-1!==g.keysLeft.indexOf(a.keyCode)||-1!==g.keysRight.indexOf(a.keyCode)){var b=g._keys.indexOf(a.keyCode);-1===b&&g._keys.push(a.keyCode),a.preventDefault&&(d||a.preventDefault())}},this._onKeyUp=function(a){if(-1!==g.keysUp.indexOf(a.keyCode)||-1!==g.keysDown.indexOf(a.keyCode)||-1!==g.keysLeft.indexOf(a.keyCode)||-1!==g.keysRight.indexOf(a.keyCode)){var b=g._keys.indexOf(a.keyCode);b>=0&&g._keys.splice(b,1),a.preventDefault&&(d||a.preventDefault())}},this._onLostFocus=function(){g._keys=[],f=null},this._onGestureStart=function(a){void 0!==window.MSGesture&&(g._MSGestureHandler||(g._MSGestureHandler=new MSGesture,g._MSGestureHandler.target=c),g._MSGestureHandler.addPointer(a.pointerId))},this._onGesture=function(a){g.radius*=a.scale,a.preventDefault&&(d||(a.stopPropagation(),a.preventDefault()))},this._reset=function(){g._keys=[],g.inertialAlphaOffset=0,g.inertialBetaOffset=0,g.inertialRadiusOffset=0,e=null,f=null}),c.addEventListener(b+"down",this._onPointerDown,!1),c.addEventListener(b+"up",this._onPointerUp,!1),c.addEventListener(b+"out",this._onPointerUp,!1),c.addEventListener(b+"move",this._onPointerMove,!1),c.addEventListener("mousemove",this._onMouseMove,!1),c.addEventListener("MSPointerDown",this._onGestureStart,!1),c.addEventListener("MSGestureChange",this._onGesture,!1),c.addEventListener("mousewheel",this._wheel,!1),c.addEventListener("DOMMouseScroll",this._wheel,!1),a.Tools.RegisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}])}},d.prototype.detachControl=function(c){this._attachedElement==c&&(c.removeEventListener(b+"down",this._onPointerDown),c.removeEventListener(b+"up",this._onPointerUp),c.removeEventListener(b+"out",this._onPointerUp),c.removeEventListener(b+"move",this._onPointerMove),c.removeEventListener("mousemove",this._onMouseMove),c.removeEventListener("MSPointerDown",this._onGestureStart),c.removeEventListener("MSGestureChange",this._onGesture),c.removeEventListener("mousewheel",this._wheel),c.removeEventListener("DOMMouseScroll",this._wheel),a.Tools.UnregisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]),this._MSGestureHandler=null,this._attachedElement=null,this._reset&&this._reset())},d.prototype._update=function(){for(var b=0;b<this._keys.length;b++){var c=this._keys[b];-1!==this.keysLeft.indexOf(c)?this.inertialAlphaOffset-=.01:-1!==this.keysUp.indexOf(c)?this.inertialBetaOffset-=.01:-1!==this.keysRight.indexOf(c)?this.inertialAlphaOffset+=.01:-1!==this.keysDown.indexOf(c)&&(this.inertialBetaOffset+=.01)}(0!=this.inertialAlphaOffset||0!=this.inertialBetaOffset||0!=this.inertialRadiusOffset)&&(this.alpha+=this.inertialAlphaOffset,this.beta+=this.inertialBetaOffset,this.radius-=this.inertialRadiusOffset,this.inertialAlphaOffset*=this.inertia,this.inertialBetaOffset*=this.inertia,this.inertialRadiusOffset*=this.inertia,Math.abs(this.inertialAlphaOffset)<a.Engine.Epsilon&&(this.inertialAlphaOffset=0),Math.abs(this.inertialBetaOffset)<a.Engine.Epsilon&&(this.inertialBetaOffset=0),Math.abs(this.inertialRadiusOffset)<a.Engine.Epsilon&&(this.inertialRadiusOffset=0)),this.lowerAlphaLimit&&this.alpha<this.lowerAlphaLimit&&(this.alpha=this.lowerAlphaLimit),this.upperAlphaLimit&&this.alpha>this.upperAlphaLimit&&(this.alpha=this.upperAlphaLimit),this.lowerBetaLimit&&this.beta<this.lowerBetaLimit&&(this.beta=this.lowerBetaLimit),this.upperBetaLimit&&this.beta>this.upperBetaLimit&&(this.beta=this.upperBetaLimit),this.lowerRadiusLimit&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit),this.upperRadiusLimit&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit)},d.prototype.setPosition=function(a){var b=a.subtract(this._getTargetPosition());this.radius=b.length(),this.alpha=Math.acos(b.x/Math.sqrt(Math.pow(b.x,2)+Math.pow(b.z,2))),b.z<0&&(this.alpha=2*Math.PI-this.alpha),this.beta=Math.acos(b.y/this.radius)},d.prototype._getViewMatrix=function(){var b=Math.cos(this.alpha),c=Math.sin(this.alpha),d=Math.cos(this.beta),e=Math.sin(this.beta),f=this._getTargetPosition();return f.addToRef(new a.Vector3(this.radius*b*e,this.radius*d,this.radius*c*e),this.position),this.checkCollisions&&(this._collider.radius=this.collisionRadius,this.position.subtractToRef(this._previousPosition,this._collisionVelocity),this.getScene()._getNewPosition(this._previousPosition,this._collisionVelocity,this._collider,3,this._newPosition),this._newPosition.equalsWithEpsilon(this.position)||(this.position.copyFrom(this._previousPosition),this.alpha=this._previousAlpha,this.beta=this._previousBeta,this.radius=this._previousRadius,this.onCollide&&this.onCollide(this._collider.collidedMesh))),a.Matrix.LookAtLHToRef(this.position,f,this.upVector,this._viewMatrix),this._previousAlpha=this.alpha,this._previousBeta=this.beta,this._previousRadius=this.radius,this._previousPosition.copyFrom(this.position),this._viewMatrix},d.prototype.zoomOn=function(b){b=b||this.getScene().meshes;var c=a.Mesh.MinMax(b),d=a.Vector3.Distance(c.min,c.max);this.radius=d*this.zoomOnFactor,this.focusOn({min:c.min,max:c.max,distance:d})},d.prototype.focusOn=function(b){var c,d;void 0===b.min?(c=b||this.getScene().meshes,c=a.Mesh.MinMax(c),d=a.Vector3.Distance(c.min,c.max)):(c=b,d=b.distance),this.target=a.Mesh.Center(c),this.maxZ=2*d},d}(a.Camera);a.ArcRotateCamera=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.autoClear=!0,this.clearColor=new a.Color3(.2,.2,.3),this.ambientColor=new a.Color3(0,0,0),this.forceWireframe=!1,this.cameraToUseForPointers=null,this.fogMode=a.Scene.FOGMODE_NONE,this.fogColor=new a.Color3(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.lightsEnabled=!0,this.lights=new Array,this.cameras=new Array,this.activeCameras=new Array,this.meshes=new Array,this._geometries=new Array,this.materials=new Array,this.multiMaterials=new Array,this.defaultMaterial=new a.StandardMaterial("default material",this),this.texturesEnabled=!0,this.textures=new Array,this.particlesEnabled=!0,this.particleSystems=new Array,this.spriteManagers=new Array,this.layers=new Array,this.skeletons=new Array,this.lensFlareSystems=new Array,this.collisionsEnabled=!0,this.gravity=new a.Vector3(0,-9,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.customRenderTargets=new Array,this.importedMeshesFiles=new Array,this._actionManagers=new Array,this._meshesForIntersections=new a.SmartArray(256),this._totalVertices=0,this._activeVertices=0,this._activeParticles=0,this._lastFrameDuration=0,this._evaluateActiveMeshesDuration=0,this._renderTargetsDuration=0,this._particlesDuration=0,this._renderDuration=0,this._spritesDuration=0,this._animationRatio=0,this._renderId=0,this._executeWhenReadyTimeoutId=-1,this._toBeDisposed=new a.SmartArray(256),this._onReadyCallbacks=new Array,this._pendingData=[],this._onBeforeRenderCallbacks=new Array,this._activeMeshes=new a.SmartArray(256),this._processedMaterials=new a.SmartArray(256),this._renderTargets=new a.SmartArray(256),this._activeParticleSystems=new a.SmartArray(256),this._activeSkeletons=new a.SmartArray(32),this._activeAnimatables=new Array,this._transformMatrix=a.Matrix.Zero(),this._scaledPosition=a.Vector3.Zero(),this._scaledVelocity=a.Vector3.Zero(),this._engine=b,b.scenes.push(this),this._renderingManager=new a.RenderingManager(this),this.postProcessManager=new a.PostProcessManager(this),this.postProcessRenderPipelineManager=new a.PostProcessRenderPipelineManager,this._boundingBoxRenderer=new a.BoundingBoxRenderer(this),this.attachControl()}return Object.defineProperty(b.prototype,"meshUnderPointer",{get:function(){return this._meshUnderPointer},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"pointerX",{get:function(){return this._pointerX},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"pointerY",{get:function(){return this._pointerY},enumerable:!0,configurable:!0}),b.prototype.getBoundingBoxRenderer=function(){return this._boundingBoxRenderer},b.prototype.getEngine=function(){return this._engine},b.prototype.getTotalVertices=function(){return this._totalVertices},b.prototype.getActiveVertices=function(){return this._activeVertices},b.prototype.getActiveParticles=function(){return this._activeParticles},b.prototype.getLastFrameDuration=function(){return this._lastFrameDuration},b.prototype.getEvaluateActiveMeshesDuration=function(){return this._evaluateActiveMeshesDuration},b.prototype.getActiveMeshes=function(){return this._activeMeshes},b.prototype.getRenderTargetsDuration=function(){return this._renderTargetsDuration},b.prototype.getRenderDuration=function(){return this._renderDuration},b.prototype.getParticlesDuration=function(){return this._particlesDuration},b.prototype.getSpritesDuration=function(){return this._spritesDuration},b.prototype.getAnimationRatio=function(){return this._animationRatio},b.prototype.getRenderId=function(){return this._renderId},b.prototype._updatePointerPosition=function(a){var b=this._engine.getRenderingCanvasClientRect();this._pointerX=a.clientX-b.left,this._pointerY=a.clientY-b.top,this.cameraToUseForPointers&&(this._pointerX=this._pointerX-this.cameraToUseForPointers.viewport.x*this._engine.getRenderWidth(),this._pointerY=this._pointerY-this.cameraToUseForPointers.viewport.y*this._engine.getRenderHeight())},b.prototype.attachControl=function(){var b=this;this._onPointerMove=function(a){var c=b._engine.getRenderingCanvas();b._updatePointerPosition(a);var d=b.pick(b._pointerX,b._pointerY,function(a){return a.isPickable&&a.isVisible&&a.isReady()&&a.actionManager&&a.actionManager.hasPointerTriggers},!1,b.cameraToUseForPointers);d.hit?(b.setPointerOverMesh(d.pickedMesh),c.style.cursor="pointer",b._meshUnderPointer=d.pickedMesh):(b.setPointerOverMesh(null),c.style.cursor="",b._meshUnderPointer=null)},this._onPointerDown=function(c){var d=null;b.onPointerDown||(d=function(a){return a.isPickable&&a.isVisible&&a.isReady()&&a.actionManager&&a.actionManager.hasPickTriggers}),b._updatePointerPosition(c);var e=b.pick(b._pointerX,b._pointerY,d,!1,b.cameraToUseForPointers);if(e.hit&&e.pickedMesh.actionManager){switch(c.button){case 0:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnLeftPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh));break;case 1:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnCenterPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh));break;case 2:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnRightPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh))}e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh))}b.onPointerDown&&b.onPointerDown(c,e)},this._onKeyDown=function(c){b.actionManager&&b.actionManager.processTrigger(a.ActionManager.OnKeyDownTrigger,a.ActionEvent.CreateNewFromScene(b,c))},this._onKeyUp=function(c){b.actionManager&&b.actionManager.processTrigger(a.ActionManager.OnKeyUpTrigger,a.ActionEvent.CreateNewFromScene(b,c))};var c=a.Tools.GetPointerPrefix();this._engine.getRenderingCanvas().addEventListener(c+"move",this._onPointerMove,!1),this._engine.getRenderingCanvas().addEventListener(c+"down",this._onPointerDown,!1),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)},b.prototype.detachControl=function(){var b=a.Tools.GetPointerPrefix();this._engine.getRenderingCanvas().removeEventListener(b+"move",this._onPointerMove),this._engine.getRenderingCanvas().removeEventListener(b+"down",this._onPointerDown),window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)},b.prototype.isReady=function(){if(this._pendingData.length>0)return!1;for(var b=0;b<this._geometries.length;b++){var c=this._geometries[b];if(c.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING)return!1}for(b=0;b<this.meshes.length;b++){var d=this.meshes[b];if(!d.isReady())return!1;var e=d.material;if(e&&!e.isReady(d))return!1}return!0},b.prototype.registerBeforeRender=function(a){this._onBeforeRenderCallbacks.push(a)},b.prototype.unregisterBeforeRender=function(a){var b=this._onBeforeRenderCallbacks.indexOf(a);b>-1&&this._onBeforeRenderCallbacks.splice(b,1)},b.prototype._addPendingData=function(a){this._pendingData.push(a)},b.prototype._removePendingData=function(a){var b=this._pendingData.indexOf(a);-1!==b&&this._pendingData.splice(b,1)},b.prototype.getWaitingItemsCount=function(){return this._pendingData.length},b.prototype.executeWhenReady=function(a){var b=this;this._onReadyCallbacks.push(a),-1===this._executeWhenReadyTimeoutId&&(this._executeWhenReadyTimeoutId=setTimeout(function(){b._checkIsReady()},150))},b.prototype._checkIsReady=function(){var a=this;return this.isReady()?(this._onReadyCallbacks.forEach(function(a){a()}),this._onReadyCallbacks=[],void(this._executeWhenReadyTimeoutId=-1)):void(this._executeWhenReadyTimeoutId=setTimeout(function(){a._checkIsReady()},150))},b.prototype.beginAnimation=function(b,c,d,e,f,g,h){if(void 0===f&&(f=1),this.stopAnimation(b),h||(h=new a.Animatable(this,b,c,d,e,f,g)),b.animations&&h.appendAnimations(b,b.animations),b.getAnimatables)for(var i=b.getAnimatables(),j=0;j<i.length;j++)this.beginAnimation(i[j],c,d,e,f,g,h);return h},b.prototype.beginDirectAnimation=function(b,c,d,e,f,g,h){void 0===g&&(g=1);var i=new a.Animatable(this,b,d,e,f,g,h,c);return i},b.prototype.getAnimatableByTarget=function(a){for(var b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===a)return this._activeAnimatables[b];return null},b.prototype.stopAnimation=function(a){var b=this.getAnimatableByTarget(a);b&&b.stop()},b.prototype._animate=function(){this._animationStartDate||(this._animationStartDate=(new Date).getTime());for(var a=(new Date).getTime(),b=a-this._animationStartDate,c=0;c<this._activeAnimatables.length;c++)this._activeAnimatables[c]._animate(b)||(this._activeAnimatables.splice(c,1),c--)
},b.prototype.getViewMatrix=function(){return this._viewMatrix},b.prototype.getProjectionMatrix=function(){return this._projectionMatrix},b.prototype.getTransformMatrix=function(){return this._transformMatrix},b.prototype.setTransformMatrix=function(a,b){this._viewMatrix=a,this._projectionMatrix=b,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)},b.prototype.setActiveCameraByID=function(a){var b=this.getCameraByID(a);return b?(this.activeCamera=b,b):null},b.prototype.setActiveCameraByName=function(a){var b=this.getCameraByName(a);return b?(this.activeCamera=b,b):null},b.prototype.getMaterialByID=function(a){for(var b=0;b<this.materials.length;b++)if(this.materials[b].id===a)return this.materials[b];return null},b.prototype.getMaterialByName=function(a){for(var b=0;b<this.materials.length;b++)if(this.materials[b].name===a)return this.materials[b];return null},b.prototype.getCameraByID=function(a){for(var b=0;b<this.cameras.length;b++)if(this.cameras[b].id===a)return this.cameras[b];return null},b.prototype.getCameraByName=function(a){for(var b=0;b<this.cameras.length;b++)if(this.cameras[b].name===a)return this.cameras[b];return null},b.prototype.getLightByName=function(a){for(var b=0;b<this.lights.length;b++)if(this.lights[b].name===a)return this.lights[b];return null},b.prototype.getLightByID=function(a){for(var b=0;b<this.lights.length;b++)if(this.lights[b].id===a)return this.lights[b];return null},b.prototype.getGeometryByID=function(a){for(var b=0;b<this._geometries.length;b++)if(this._geometries[b].id===a)return this._geometries[b];return null},b.prototype.pushGeometry=function(a,b){return!b&&this.getGeometryByID(a.id)?!1:(this._geometries.push(a),!0)},b.prototype.getGeometries=function(){return this._geometries},b.prototype.getMeshByID=function(a){for(var b=0;b<this.meshes.length;b++)if(this.meshes[b].id===a)return this.meshes[b];return null},b.prototype.getLastMeshByID=function(a){for(var b=this.meshes.length-1;b>=0;b--)if(this.meshes[b].id===a)return this.meshes[b];return null},b.prototype.getLastEntryByID=function(a){for(var b=this.meshes.length-1;b>=0;b--)if(this.meshes[b].id===a)return this.meshes[b];for(b=this.cameras.length-1;b>=0;b--)if(this.cameras[b].id===a)return this.cameras[b];for(b=this.lights.length-1;b>=0;b--)if(this.lights[b].id===a)return this.lights[b];return null},b.prototype.getMeshByName=function(a){for(var b=0;b<this.meshes.length;b++)if(this.meshes[b].name===a)return this.meshes[b];return null},b.prototype.getLastSkeletonByID=function(a){for(var b=this.skeletons.length-1;b>=0;b--)if(this.skeletons[b].id===a)return this.skeletons[b];return null},b.prototype.getSkeletonById=function(a){for(var b=0;b<this.skeletons.length;b++)if(this.skeletons[b].id===a)return this.skeletons[b];return null},b.prototype.getSkeletonByName=function(a){for(var b=0;b<this.skeletons.length;b++)if(this.skeletons[b].name===a)return this.skeletons[b];return null},b.prototype.isActiveMesh=function(a){return-1!==this._activeMeshes.indexOf(a)},b.prototype._evaluateSubMesh=function(a,b){if(1==b.subMeshes.length||a.isInFrustum(this._frustumPlanes)){var c=a.getMaterial();b.showSubMeshesBoundingBox&&this._boundingBoxRenderer.renderList.push(a.getBoundingInfo().boundingBox),c&&(c.getRenderTargetTextures&&-1===this._processedMaterials.indexOf(c)&&(this._processedMaterials.push(c),this._renderTargets.concat(c.getRenderTargetTextures())),this._activeVertices+=a.verticesCount,this._renderingManager.dispatch(a))}},b.prototype._evaluateActiveMeshes=function(){this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._boundingBoxRenderer.reset(),this._frustumPlanes?a.Frustum.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=a.Frustum.GetPlanes(this._transformMatrix);var b,c;if(this._selectionOctree){var d=this._selectionOctree.select(this._frustumPlanes);b=d.data,c=d.length}else c=this.meshes.length,b=this.meshes;for(var e=0;c>e;e++){var f=b[e];this._totalVertices+=f.getTotalVertices(),f.isReady()&&(f.computeWorldMatrix(),f._preActivate(),f.actionManager&&f.actionManager.hasSpecificTriggers([a.ActionManager.OnIntersectionEnterTrigger,a.ActionManager.OnIntersectionExitTrigger])&&this._meshesForIntersections.pushNoDuplicate(f),f.isEnabled()&&f.isVisible&&f.visibility>0&&0!=(f.layerMask&this.activeCamera.layerMask)&&f.isInFrustum(this._frustumPlanes)&&(this._activeMeshes.push(f),f._activate(this._renderId),this._activeMesh(f)))}var g=(new Date).getTime();if(this.particlesEnabled)for(var h=0;h<this.particleSystems.length;h++){var i=this.particleSystems[h];i.isStarted()&&(!i.emitter.position||i.emitter&&i.emitter.isEnabled())&&(this._activeParticleSystems.push(i),i.animate())}this._particlesDuration+=(new Date).getTime()-g},b.prototype._activeMesh=function(a){if(a.skeleton&&this._activeSkeletons.pushNoDuplicate(a.skeleton),a.showBoundingBox&&this._boundingBoxRenderer.renderList.push(a.getBoundingInfo().boundingBox),a.subMeshes){var b,c;if(a._submeshesOctree&&a.useOctreeForRenderingSelection){var d=a._submeshesOctree.select(this._frustumPlanes);b=d.length,c=d.data}else c=a.subMeshes,b=c.length;for(var e=0;b>e;e++){var f=c[e];this._evaluateSubMesh(f,a)}}},b.prototype.updateTransformMatrix=function(a){this.setTransformMatrix(this.activeCamera.getViewMatrix(),this.activeCamera.getProjectionMatrix(a))},b.prototype._renderForCamera=function(a){var b=this._engine;if(this.activeCamera=a,!this.activeCamera)throw new Error("Active camera not set");b.setViewport(this.activeCamera.viewport),this._renderId++,this.updateTransformMatrix(),this.beforeCameraRender&&this.beforeCameraRender(this.activeCamera);var c=(new Date).getTime();this._evaluateActiveMeshes(),this._evaluateActiveMeshesDuration+=(new Date).getTime()-c;for(var d=0;d<this._activeSkeletons.length;d++){var e=this._activeSkeletons.data[d];e.prepare()}for(var f=0;f<this.customRenderTargets.length;f++){var g=this.customRenderTargets[f];this._renderTargets.push(g)}var h=(new Date).getTime();if(this.renderTargetsEnabled){for(var i=0;i<this._renderTargets.length;i++)g=this._renderTargets.data[i],g._shouldRender()&&(this._renderId++,g.render());this._renderId++}this._renderTargets.length>0&&b.restoreDefaultFramebuffer(),this._renderTargetsDuration=(new Date).getTime()-h,this.postProcessManager._prepareFrame();var j=(new Date).getTime();if(this.layers.length){b.setDepthBuffer(!1);var k,l;for(k=0;k<this.layers.length;k++)l=this.layers[k],l.isBackground&&l.render();b.setDepthBuffer(!0)}this._renderingManager.render(null,null,!0,!0),this._boundingBoxRenderer.render();for(var m=0;m<this.lensFlareSystems.length;m++)this.lensFlareSystems[m].render();if(this.layers.length){for(b.setDepthBuffer(!1),k=0;k<this.layers.length;k++)l=this.layers[k],l.isBackground||l.render();b.setDepthBuffer(!0)}this._renderDuration+=(new Date).getTime()-j,this.postProcessManager._finalizeFrame(a.isIntermediate),this.activeCamera._updateFromScene(),this._renderTargets.reset(),this.afterCameraRender&&this.afterCameraRender(this.activeCamera)},b.prototype._processSubCameras=function(a){if(0==a.subCameras.length)return void this._renderForCamera(a);for(var b=0;b<a.subCameras.length;b++)this._renderForCamera(a.subCameras[b]);this.activeCamera=a,this.setTransformMatrix(this.activeCamera.getViewMatrix(),this.activeCamera.getProjectionMatrix()),this.activeCamera._updateFromScene()},b.prototype._checkIntersections=function(){for(var b=0;b<this._meshesForIntersections.length;b++)for(var c=this._meshesForIntersections.data[b],d=0;d<c.actionManager.actions.length;d++){var e=c.actionManager.actions[d];if(e.trigger==a.ActionManager.OnIntersectionEnterTrigger||e.trigger==a.ActionManager.OnIntersectionExitTrigger){var f=e.getTriggerParameter(),g=f.intersectsMesh(c,!1),h=c._intersectionsInProgress.indexOf(f);if(g&&-1===h&&e.trigger==a.ActionManager.OnIntersectionEnterTrigger)c.actionManager.processTrigger(a.ActionManager.OnIntersectionEnterTrigger,a.ActionEvent.CreateNew(c)),c._intersectionsInProgress.push(f);else if(!g&&h>-1&&e.trigger==a.ActionManager.OnIntersectionExitTrigger){c.actionManager.processTrigger(a.ActionManager.OnIntersectionExitTrigger,a.ActionEvent.CreateNew(c));var i=c._intersectionsInProgress.indexOf(f);i>-1&&c._intersectionsInProgress.splice(i,1)}}}},b.prototype.render=function(){var c=(new Date).getTime();this._particlesDuration=0,this._spritesDuration=0,this._activeParticles=0,this._renderDuration=0,this._evaluateActiveMeshesDuration=0,this._totalVertices=0,this._activeVertices=0,this._meshesForIntersections.reset(),this.actionManager&&this.actionManager.processTrigger(a.ActionManager.OnEveryFrameTrigger,null),this.beforeRender&&this.beforeRender();for(var d=0;d<this._onBeforeRenderCallbacks.length;d++)this._onBeforeRenderCallbacks[d]();var e=Math.max(b.MinDeltaTime,Math.min(a.Tools.GetDeltaTime(),b.MaxDeltaTime));this._animationRatio=.06*e,this._animate(),this._physicsEngine&&this._physicsEngine._runOneStep(e/1e3),this._engine.clear(this.clearColor,this.autoClear||this.forceWireframe,!0);for(var f=0;f<this.lights.length;f++){var g=this.lights[f],h=g.getShadowGenerator();g.isEnabled()&&h&&-1!==h.getShadowMap().getScene().textures.indexOf(h.getShadowMap())&&this._renderTargets.push(h.getShadowMap())}if(this.postProcessRenderPipelineManager.update(),this.activeCameras.length>0)for(var i=this._renderId,j=0;j<this.activeCameras.length;j++)this._renderId=i,this._processSubCameras(this.activeCameras[j]);else this._processSubCameras(this.activeCamera);this._checkIntersections(),this.afterRender&&this.afterRender();for(var k=0;k<this._toBeDisposed.length;k++)this._toBeDisposed.data[k].dispose(),this._toBeDisposed[k]=null;this._toBeDisposed.reset(),this._lastFrameDuration=(new Date).getTime()-c},b.prototype.dispose=function(){this.beforeRender=null,this.afterRender=null,this.skeletons=[],this._boundingBoxRenderer.dispose(),this.onDispose&&this.onDispose(),this.detachControl();var a,b=this._engine.getRenderingCanvas();for(a=0;a<this.cameras.length;a++)this.cameras[a].detachControl(b);for(;this.lights.length;)this.lights[0].dispose();for(;this.meshes.length;)this.meshes[0].dispose(!0);for(;this.cameras.length;)this.cameras[0].dispose();for(;this.materials.length;)this.materials[0].dispose();for(;this.particleSystems.length;)this.particleSystems[0].dispose();for(;this.spriteManagers.length;)this.spriteManagers[0].dispose();for(;this.layers.length;)this.layers[0].dispose();for(;this.textures.length;)this.textures[0].dispose();this.postProcessManager.dispose(),this._physicsEngine&&this.disablePhysicsEngine(),a=this._engine.scenes.indexOf(this),this._engine.scenes.splice(a,1),this._engine.wipeCaches()},b.prototype._getNewPosition=function(a,b,c,d,e,f){"undefined"==typeof f&&(f=null),a.divideToRef(c.radius,this._scaledPosition),b.divideToRef(c.radius,this._scaledVelocity),c.retry=0,c.initialVelocity=this._scaledVelocity,c.initialPosition=this._scaledPosition,this._collideWithWorld(this._scaledPosition,this._scaledVelocity,c,d,e,f),e.multiplyInPlace(c.radius)},b.prototype._collideWithWorld=function(b,c,d,e,f,g){"undefined"==typeof g&&(g=null);var h=10*a.Engine.CollisionsEpsilon;if(d.retry>=e)return void f.copyFrom(b);d._initialize(b,c,h);for(var i=0;i<this.meshes.length;i++){var j=this.meshes[i];j.isEnabled()&&j.checkCollisions&&j.subMeshes&&j!==g&&j._checkCollision(d)}return d.collisionFound?((0!=c.x||0!=c.y||0!=c.z)&&d._getResponse(b,c),c.length()<=h?void f.copyFrom(b):(d.retry++,void this._collideWithWorld(b,c,d,e,f,g))):void b.addToRef(c,f)},b.prototype.createOrUpdateSelectionOctree=function(b,c){"undefined"==typeof b&&(b=64),"undefined"==typeof c&&(c=2),this._selectionOctree||(this._selectionOctree=new a.Octree(a.Octree.CreationFuncForMeshes,b,c));for(var d=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),f=0;f<this.meshes.length;f++){var g=this.meshes[f];g.computeWorldMatrix(!0);var h=g.getBoundingInfo().boundingBox.minimumWorld,i=g.getBoundingInfo().boundingBox.maximumWorld;a.Tools.CheckExtends(h,d,e),a.Tools.CheckExtends(i,d,e)}return this._selectionOctree.update(d,e,this.meshes),this._selectionOctree},b.prototype.createPickingRay=function(b,c,d,e){var f=this._engine;if(!e){if(!this.activeCamera)throw new Error("Active camera not set");e=this.activeCamera}var g=e.viewport,h=g.toGlobal(f);return b=b/this._engine.getHardwareScalingLevel()-h.x,c=c/this._engine.getHardwareScalingLevel()-(this._engine.getRenderHeight()-h.y-h.height),a.Ray.CreateNew(b/window.devicePixelRatio,c/window.devicePixelRatio,h.width,h.height,d?d:a.Matrix.Identity(),e.getViewMatrix(),e.getProjectionMatrix())},b.prototype._internalPick=function(b,c,d){for(var e=null,f=0;f<this.meshes.length;f++){var g=this.meshes[f];if(c){if(!c(g))continue}else if(!g.isEnabled()||!g.isVisible||!g.isPickable)continue;var h=g.getWorldMatrix(),i=b(h),j=g.intersects(i,d);if(j&&j.hit&&(d||null==e||!(j.distance>=e.distance))&&(e=j,d))break}return e||new a.PickingInfo},b.prototype.pick=function(a,b,c,d,e){var f=this;return this._internalPick(function(c){return f.createPickingRay(a,b,c,e)},c,d)},b.prototype.pickWithRay=function(b,c,d){var e=this;return this._internalPick(function(c){return e._pickWithRayInverseMatrix||(e._pickWithRayInverseMatrix=a.Matrix.Identity()),c.invertToRef(e._pickWithRayInverseMatrix),a.Ray.Transform(b,e._pickWithRayInverseMatrix)},c,d)},b.prototype.setPointerOverMesh=function(b){this._pointerOverMesh!==b&&(this._pointerOverMesh&&this._pointerOverMesh.actionManager&&this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOutTrigger,a.ActionEvent.CreateNew(this._pointerOverMesh)),this._pointerOverMesh=b,this._pointerOverMesh&&this._pointerOverMesh.actionManager&&this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOverTrigger,a.ActionEvent.CreateNew(this._pointerOverMesh)))},b.prototype.getPointerOverMesh=function(){return this._pointerOverMesh},b.prototype.getPhysicsEngine=function(){return this._physicsEngine},b.prototype.enablePhysics=function(b,c){return this._physicsEngine?!0:(this._physicsEngine=new a.PhysicsEngine(c),this._physicsEngine.isSupported()?(this._physicsEngine._initialize(b),!0):(this._physicsEngine=null,!1))},b.prototype.disablePhysicsEngine=function(){this._physicsEngine&&(this._physicsEngine.dispose(),this._physicsEngine=void 0)},b.prototype.isPhysicsEnabled=function(){return void 0!==this._physicsEngine},b.prototype.setGravity=function(a){this._physicsEngine&&this._physicsEngine._setGravity(a)},b.prototype.createCompoundImpostor=function(a,b){if(a.parts&&(b=a,a=a.parts),!this._physicsEngine)return null;for(var c=0;c<a.length;c++){var d=a[c].mesh;d._physicImpostor=a[c].impostor,d._physicsMass=b.mass/a.length,d._physicsFriction=b.friction,d._physicRestitution=b.restitution}return this._physicsEngine._registerMeshesAsCompound(a,b)},b.prototype.deleteCompoundImpostor=function(b){for(var c=0;c<b.parts.length;c++){var d=b.parts[c].mesh;d._physicImpostor=a.PhysicsEngine.NoImpostor,this._physicsEngine._unregisterMesh(d)}},b.prototype._getByTags=function(b,c){if(void 0===c)return b;var d=[];for(var e in b){var f=b[e];a.Tags.MatchesQuery(f,c)&&d.push(f)}return d},b.prototype.getMeshesByTags=function(a){return this._getByTags(this.meshes,a)},b.prototype.getCamerasByTags=function(a){return this._getByTags(this.cameras,a)},b.prototype.getLightsByTags=function(a){return this._getByTags(this.lights,a)},b.prototype.getMaterialByTags=function(a){return this._getByTags(this.materials,a).concat(this._getByTags(this.multiMaterials,a))},b.FOGMODE_NONE=0,b.FOGMODE_EXP=1,b.FOGMODE_EXP2=2,b.FOGMODE_LINEAR=3,b.MinDeltaTime=1,b.MaxDeltaTime=1e3,b}();a.Scene=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(c,d,e,f,g){switch(this._engine=c instanceof a.Mesh?c.getScene().getEngine():c,this._updatable=f,this._data=d,g||this.create(),this._kind=e,e){case b.PositionKind:this._strideSize=3;break;case b.NormalKind:this._strideSize=3;break;case b.UVKind:this._strideSize=2;break;case b.UV2Kind:this._strideSize=2;break;case b.ColorKind:this._strideSize=3;break;case b.MatricesIndicesKind:this._strideSize=4;break;case b.MatricesWeightsKind:this._strideSize=4}}return b.prototype.isUpdatable=function(){return this._updatable},b.prototype.getData=function(){return this._data},b.prototype.getBuffer=function(){return this._buffer},b.prototype.getStrideSize=function(){return this._strideSize},b.prototype.create=function(a){(a||!this._buffer)&&(a=a||this._data,this._buffer||(this._buffer=this._updatable?this._engine.createDynamicVertexBuffer(4*a.length):this._engine.createVertexBuffer(a)),this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,a),this._data=a))},b.prototype.update=function(a){this.create(a)},b.prototype.dispose=function(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)},Object.defineProperty(b,"PositionKind",{get:function(){return b._PositionKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"NormalKind",{get:function(){return b._NormalKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"UVKind",{get:function(){return b._UVKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"UV2Kind",{get:function(){return b._UV2Kind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ColorKind",{get:function(){return b._ColorKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"MatricesIndicesKind",{get:function(){return b._MatricesIndicesKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"MatricesWeightsKind",{get:function(){return b._MatricesWeightsKind},enumerable:!0,configurable:!0}),b._PositionKind="position",b._NormalKind="normal",b._UVKind="uv",b._UV2Kind="uv2",b._ColorKind="color",b._MatricesIndicesKind="matricesIndices",b._MatricesWeightsKind="matricesWeights",b}();a.VertexBuffer=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.position=new a.Vector3(0,0,0),this.rotation=new a.Vector3(0,0,0),this.scaling=new a.Vector3(1,1,1),this.billboardMode=a.AbstractMesh.BILLBOARDMODE_NONE,this.visibility=1,this.infiniteDistance=!1,this.isVisible=!0,this.isPickable=!0,this.showBoundingBox=!1,this.showSubMeshesBoundingBox=!1,this.onDispose=null,this.checkCollisions=!1,this.renderingGroupId=0,this.receiveShadows=!1,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.layerMask=4294967295,this._physicImpostor=a.PhysicsEngine.NoImpostor,this.ellipsoid=new a.Vector3(.5,1,.5),this.ellipsoidOffset=new a.Vector3(0,0,0),this._collider=new a.Collider,this._oldPositionForCollisions=new a.Vector3(0,0,0),this._diffPositionForCollisions=new a.Vector3(0,0,0),this._newPositionForCollisions=new a.Vector3(0,0,0),this._localScaling=a.Matrix.Zero(),this._localRotation=a.Matrix.Zero(),this._localTranslation=a.Matrix.Zero(),this._localBillboard=a.Matrix.Zero(),this._localPivotScaling=a.Matrix.Zero(),this._localPivotScalingRotation=a.Matrix.Zero(),this._localWorld=a.Matrix.Zero(),this._worldMatrix=a.Matrix.Zero(),this._rotateYByPI=a.Matrix.RotationY(Math.PI),this._absolutePosition=a.Vector3.Zero(),this._collisionsTransformMatrix=a.Matrix.Zero(),this._collisionsScalingMatrix=a.Matrix.Zero(),this._isDirty=!1,this._pivotMatrix=a.Matrix.Identity(),this._isDisposed=!1,this._renderId=0,this._intersectionsInProgress=new Array,d.meshes.push(this)}return __extends(c,b),Object.defineProperty(c,"BILLBOARDMODE_NONE",{get:function(){return c._BILLBOARDMODE_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_X",{get:function(){return c._BILLBOARDMODE_X},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_Y",{get:function(){return c._BILLBOARDMODE_Y},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_Z",{get:function(){return c._BILLBOARDMODE_Z},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_ALL",{get:function(){return c._BILLBOARDMODE_ALL},enumerable:!0,configurable:!0}),c.prototype.getTotalVertices=function(){return 0},c.prototype.getIndices=function(){return null},c.prototype.getVerticesData=function(){return null},c.prototype.isVerticesDataPresent=function(){return!1},c.prototype.getBoundingInfo=function(){return this._boundingInfo||this._updateBoundingInfo(),this._boundingInfo},c.prototype._preActivate=function(){},c.prototype._activate=function(a){this._renderId=a},c.prototype.getWorldMatrix=function(){return this._currentRenderId!==this.getScene().getRenderId()&&this.computeWorldMatrix(),this._worldMatrix},Object.defineProperty(c.prototype,"worldMatrixFromCache",{get:function(){return this._worldMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"absolutePosition",{get:function(){return this._absolutePosition},enumerable:!0,configurable:!0}),c.prototype.rotate=function(b,c,d){if(this.rotationQuaternion||(this.rotationQuaternion=a.Quaternion.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation=a.Vector3.Zero()),d&&0!=d){if(this.parent){var e=this.parent.getWorldMatrix().clone();e.invert(),b=a.Vector3.TransformNormal(b,e)}f=a.Quaternion.RotationAxis(b,c),this.rotationQuaternion=f.multiply(this.rotationQuaternion)}else{var f=a.Quaternion.RotationAxis(b,c);this.rotationQuaternion=this.rotationQuaternion.multiply(f)}},c.prototype.translate=function(a,b,c){var d=a.scale(b);if(c&&0!=c)this.setAbsolutePosition(this.getAbsolutePosition().add(d));else{var e=this.getPositionExpressedInLocalSpace().add(d);this.setPositionWithLocalVector(e)}},c.prototype.getAbsolutePosition=function(){return this.computeWorldMatrix(),this._absolutePosition},c.prototype.setAbsolutePosition=function(b){if(b){var c,d,e;if(void 0===b.x){if(arguments.length<3)return;c=arguments[0],d=arguments[1],e=arguments[2]}else c=b.x,d=b.y,e=b.z;if(this.parent){var f=this.parent.getWorldMatrix().clone();f.invert();var g=new a.Vector3(c,d,e);this.position=a.Vector3.TransformCoordinates(g,f)}else this.position.x=c,this.position.y=d,this.position.z=e}},c.prototype.setPivotMatrix=function(a){this._pivotMatrix=a,this._cache.pivotMatrixUpdated=!0},c.prototype.getPivotMatrix=function(){return this._pivotMatrix},c.prototype._isSynchronized=function(){if(this._isDirty)return!1;if(this.billboardMode!==c.BILLBOARDMODE_NONE)return!1;if(this._cache.pivotMatrixUpdated)return!1;if(this.infiniteDistance)return!1;if(!this._cache.position.equals(this.position))return!1;if(this.rotationQuaternion){if(!this._cache.rotationQuaternion.equals(this.rotationQuaternion))return!1}else if(!this._cache.rotation.equals(this.rotation))return!1;return this._cache.scaling.equals(this.scaling)?!0:!1},c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.localMatrixUpdated=!1,this._cache.position=a.Vector3.Zero(),this._cache.scaling=a.Vector3.Zero(),this._cache.rotation=a.Vector3.Zero(),this._cache.rotationQuaternion=new a.Quaternion(0,0,0,0)},c.prototype.markAsDirty=function(a){"rotation"===a&&(this.rotationQuaternion=null),this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0},c.prototype._updateBoundingInfo=function(){if(this._boundingInfo=this._boundingInfo||new a.BoundingInfo(this.absolutePosition,this.absolutePosition),this._boundingInfo._update(this.worldMatrixFromCache),this.subMeshes)for(var b=0;b<this.subMeshes.length;b++){var c=this.subMeshes[b];c.updateBoundingInfo(this.worldMatrixFromCache)}},c.prototype.computeWorldMatrix=function(b){if(!b&&(this._currentRenderId==this.getScene().getRenderId()||this.isSynchronized(!0)))return this._worldMatrix;if(this._cache.position.copyFrom(this.position),this._cache.scaling.copyFrom(this.scaling),this._cache.pivotMatrixUpdated=!1,this._currentRenderId=this.getScene().getRenderId(),this._isDirty=!1,a.Matrix.ScalingToRef(this.scaling.x,this.scaling.y,this.scaling.z,this._localScaling),this.rotationQuaternion?(this.rotationQuaternion.toRotationMatrix(this._localRotation),this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)):(a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._localRotation),this._cache.rotation.copyFrom(this.rotation)),this.infiniteDistance&&!this.parent){var d=this.getScene().activeCamera,e=d.getWorldMatrix(),f=new a.Vector3(e.m[12],e.m[13],e.m[14]);a.Matrix.TranslationToRef(this.position.x+f.x,this.position.y+f.y,this.position.z+f.z,this._localTranslation)}else a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._localTranslation);if(this._pivotMatrix.multiplyToRef(this._localScaling,this._localPivotScaling),this._localPivotScaling.multiplyToRef(this._localRotation,this._localPivotScalingRotation),this.billboardMode!==c.BILLBOARDMODE_NONE){var g=this.position.clone(),h=this.getScene().activeCamera.position.clone();this.parent&&this.parent.position&&(g.addInPlace(this.parent.position),a.Matrix.TranslationToRef(g.x,g.y,g.z,this._localTranslation)),(this.billboardMode&c.BILLBOARDMODE_ALL)===c.BILLBOARDMODE_ALL?h=this.getScene().activeCamera.position:(this.billboardMode&a.AbstractMesh.BILLBOARDMODE_X&&(h.x=g.x+a.Engine.Epsilon),this.billboardMode&a.AbstractMesh.BILLBOARDMODE_Y&&(h.y=g.y+.001),this.billboardMode&a.AbstractMesh.BILLBOARDMODE_Z&&(h.z=g.z+.001)),a.Matrix.LookAtLHToRef(g,h,a.Vector3.Up(),this._localBillboard),this._localBillboard.m[12]=this._localBillboard.m[13]=this._localBillboard.m[14]=0,this._localBillboard.invert(),this._localPivotScalingRotation.multiplyToRef(this._localBillboard,this._localWorld),this._rotateYByPI.multiplyToRef(this._localWorld,this._localPivotScalingRotation)}return this._localPivotScalingRotation.multiplyToRef(this._localTranslation,this._localWorld),this.parent&&this.parent.getWorldMatrix&&this.billboardMode===a.AbstractMesh.BILLBOARDMODE_NONE?this._localWorld.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix):this._worldMatrix.copyFrom(this._localWorld),this._updateBoundingInfo(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._worldMatrix},c.prototype.setPositionWithLocalVector=function(b){this.computeWorldMatrix(),this.position=a.Vector3.TransformNormal(b,this._localWorld)},c.prototype.getPositionExpressedInLocalSpace=function(){this.computeWorldMatrix();var b=this._localWorld.clone();return b.invert(),a.Vector3.TransformNormal(this.position,b)},c.prototype.locallyTranslate=function(b){this.computeWorldMatrix(),this.position=a.Vector3.TransformCoordinates(b,this._localWorld)},c.prototype.lookAt=function(b,c,d,e){c=c||0,d=d||0,e=e||0;var f=b.subtract(this.position),g=-Math.atan2(f.z,f.x)-Math.PI/2,h=Math.sqrt(f.x*f.x+f.z*f.z),i=Math.atan2(f.y,h);this.rotationQuaternion=a.Quaternion.RotationYawPitchRoll(g+c,i+d,e)},c.prototype.isInFrustum=function(a){return this._boundingInfo.isInFrustum(a)?!0:!1},c.prototype.intersectsMesh=function(a,b){return this._boundingInfo&&a._boundingInfo?this._boundingInfo.intersects(a._boundingInfo,b):!1},c.prototype.intersectsPoint=function(a){return this._boundingInfo?this._boundingInfo.intersectsPoint(a):!1},c.prototype.setPhysicsState=function(b,c){var d=this.getScene().getPhysicsEngine();if(d){if(b.impostor&&(c=b,b=b.impostor),b=b||a.PhysicsEngine.NoImpostor,b===a.PhysicsEngine.NoImpostor)return void d._unregisterMesh(this);c.mass=c.mass||0,c.friction=c.friction||.2,c.restitution=c.restitution||.9,this._physicImpostor=b,this._physicsMass=c.mass,this._physicsFriction=c.friction,this._physicRestitution=c.restitution,d._registerMesh(this,b,c)}},c.prototype.getPhysicsImpostor=function(){return this._physicImpostor?this._physicImpostor:a.PhysicsEngine.NoImpostor},c.prototype.getPhysicsMass=function(){return this._physicsMass?this._physicsMass:0},c.prototype.getPhysicsFriction=function(){return this._physicsFriction?this._physicsFriction:0},c.prototype.getPhysicsRestitution=function(){return this._physicRestitution?this._physicRestitution:0},c.prototype.applyImpulse=function(a,b){this._physicImpostor&&this.getScene().getPhysicsEngine()._applyImpulse(this,a,b)},c.prototype.setPhysicsLinkWith=function(a,b,c,d){this._physicImpostor&&this.getScene().getPhysicsEngine()._createLink(this,a,b,c,d)},c.prototype.updatePhysicsBodyPosition=function(){this._physicImpostor&&this.getScene().getPhysicsEngine()._updateBodyPosition(this)},c.prototype.moveWithCollisions=function(b){var c=this.getAbsolutePosition();c.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPositionForCollisions),this._oldPositionForCollisions.addInPlace(this.ellipsoidOffset),this._collider.radius=this.ellipsoid,this.getScene()._getNewPosition(this._oldPositionForCollisions,b,this._collider,3,this._newPositionForCollisions,this),this._newPositionForCollisions.subtractToRef(this._oldPositionForCollisions,this._diffPositionForCollisions),this._diffPositionForCollisions.length()>a.Engine.CollisionsEpsilon&&this.position.addInPlace(this._diffPositionForCollisions)},c.prototype.createOrUpdateSubmeshesOctree=function(b,c){"undefined"==typeof b&&(b=64),"undefined"==typeof c&&(c=2),this._submeshesOctree||(this._submeshesOctree=new a.Octree(a.Octree.CreationFuncForSubMeshes,b,c)),this.computeWorldMatrix(!0);var d=this.getBoundingInfo().boundingBox;return this._submeshesOctree.update(d.minimumWorld,d.maximumWorld,this.subMeshes),this._submeshesOctree},c.prototype._collideForSubMesh=function(b,c,d){if(this._generatePointsArray(),!b._lastColliderWorldVertices||!b._lastColliderTransformMatrix.equals(c)){b._lastColliderTransformMatrix=c.clone(),b._lastColliderWorldVertices=[],b._trianglePlanes=[];for(var e=b.verticesStart,f=b.verticesStart+b.verticesCount,g=e;f>g;g++)b._lastColliderWorldVertices.push(a.Vector3.TransformCoordinates(this._positions[g],c))}d._collide(b,b._lastColliderWorldVertices,this.getIndices(),b.indexStart,b.indexStart+b.indexCount,b.verticesStart)},c.prototype._processCollisionsForSubMeshes=function(a,b){var c,d;if(this._submeshesOctree&&this.useOctreeForCollisions){var e=a.velocityWorldLength+Math.max(a.radius.x,a.radius.y,a.radius.z),f=this._submeshesOctree.intersects(a.basePointWorld,e);d=f.length,c=f.data}else c=this.subMeshes,d=c.length;for(var g=0;d>g;g++){var h=c[g];d>1&&!h._checkCollision(a)||this._collideForSubMesh(h,b,a)}},c.prototype._checkCollision=function(b){this._boundingInfo._checkCollision(b)&&(a.Matrix.ScalingToRef(1/b.radius.x,1/b.radius.y,1/b.radius.z,this._collisionsScalingMatrix),this.worldMatrixFromCache.multiplyToRef(this._collisionsScalingMatrix,this._collisionsTransformMatrix),this._processCollisionsForSubMeshes(b,this._collisionsTransformMatrix))},c.prototype._generatePointsArray=function(){return!1},c.prototype.intersects=function(b,c){var d=new a.PickingInfo;if(!(this.subMeshes&&this._boundingInfo&&b.intersectsSphere(this._boundingInfo.boundingSphere)&&b.intersectsBox(this._boundingInfo.boundingBox)))return d;if(!this._generatePointsArray())return d;var e,f,g=null;if(this._submeshesOctree&&this.useOctreeForPicking){var h=a.Ray.Transform(b,this.getWorldMatrix()),i=this._submeshesOctree.intersectsRay(h);f=i.length,e=i.data}else e=this.subMeshes,f=e.length;for(var j=0;f>j;j++){var k=e[j];if(!(f>1)||k.canIntersects(b)){var l=k.intersects(b,this._positions,this.getIndices(),c);if(l&&(c||!g||l.distance<g.distance)&&(g=l,c))break}}if(g){var m=this.getWorldMatrix(),n=a.Vector3.TransformCoordinates(b.origin,m),o=b.direction.clone();o.normalize(),o=o.scale(g.distance);var p=a.Vector3.TransformNormal(o,m),q=n.add(p);return d.hit=!0,d.distance=a.Vector3.Distance(n,q),d.pickedPoint=q,d.pickedMesh=this,d.bu=g.bu,d.bv=g.bv,d.faceId=g.faceId,d}return d},c.prototype.clone=function(){return null},c.prototype.releaseSubMeshes=function(){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose();
else this.subMeshes=new Array},c.prototype.dispose=function(b){for(this.getPhysicsImpostor()!=a.PhysicsEngine.NoImpostor&&this.setPhysicsState(a.PhysicsEngine.NoImpostor),e=0;e<this._intersectionsInProgress.length;e++){var c=this._intersectionsInProgress[e],d=c._intersectionsInProgress.indexOf(this);c._intersectionsInProgress.splice(d,1)}this._intersectionsInProgress=[],this.releaseSubMeshes();var e=this.getScene().meshes.indexOf(this);if(this.getScene().meshes.splice(e,1),b)for(e=0;e<this.getScene().meshes.length;e++){var f=this.getScene().meshes[e];f.parent===this&&(f.parent=null,f.computeWorldMatrix(!0))}else{for(e=0;e<this.getScene().particleSystems.length;e++)this.getScene().particleSystems[e].emitter==this&&(this.getScene().particleSystems[e].dispose(),e--);var g=this.getScene().meshes.slice(0);for(e=0;e<g.length;e++)g[e].parent==this&&g[e].dispose()}this._isDisposed=!0,this.onDispose&&this.onDispose()},c._BILLBOARDMODE_NONE=0,c._BILLBOARDMODE_X=1,c._BILLBOARDMODE_Y=2,c._BILLBOARDMODE_Z=4,c._BILLBOARDMODE_ALL=7,c}(a.Node);a.AbstractMesh=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function a(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=new Array}return a}();a._InstancesBatch=b;var c=function(c){function d(d,e){c.call(this,d,e),this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.instances=new Array,this._onBeforeRenderCallbacks=new Array,this._onAfterRenderCallbacks=new Array,this._visibleInstances={},this._renderIdForInstances=new Array,this._batchCache=new b,this._instancesBufferSize=2048}return __extends(d,c),d.prototype.getTotalVertices=function(){return this._geometry?this._geometry.getTotalVertices():0},d.prototype.getVerticesData=function(a){return this._geometry?this._geometry.getVerticesData(a):null},d.prototype.getVertexBuffer=function(a){return this._geometry?this._geometry.getVertexBuffer(a):void 0},d.prototype.isVerticesDataPresent=function(a){return this._geometry?this._geometry.isVerticesDataPresent(a):this._delayInfo?-1!==this._delayInfo.indexOf(a):!1},d.prototype.getVerticesDataKinds=function(){if(!this._geometry){var a=[];if(this._delayInfo)for(var b in this._delayInfo)a.push(b);return a}return this._geometry.getVerticesDataKinds()},d.prototype.getTotalIndices=function(){return this._geometry?this._geometry.getTotalIndices():0},d.prototype.getIndices=function(){return this._geometry?this._geometry.getIndices():[]},d.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING?!1:c.prototype.isReady.call(this)},d.prototype.isDisposed=function(){return this._isDisposed},d.prototype._preActivate=function(){var a=this.getScene().getRenderId();this._preActivateId!=a&&(this._preActivateId=a,this._visibleInstances=null)},d.prototype._registerInstanceForRenderId=function(a,b){this._visibleInstances||(this._visibleInstances={},this._visibleInstances.defaultRenderId=b,this._visibleInstances.selfDefaultRenderId=this._renderId),this._visibleInstances[b]||(this._visibleInstances[b]=new Array),this._visibleInstances[b].push(a)},d.prototype.refreshBoundingInfo=function(){var b=this.getVerticesData(a.VertexBuffer.PositionKind);if(b){var c=a.Tools.ExtractMinAndMax(b,0,this.getTotalVertices());this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)}if(this.subMeshes)for(var d=0;d<this.subMeshes.length;d++)this.subMeshes[d].refreshBoundingInfo();this._updateBoundingInfo()},d.prototype._createGlobalSubMesh=function(){var b=this.getTotalVertices();return b&&this.getIndices()?(this.releaseSubMeshes(),new a.SubMesh(0,0,b,0,this.getTotalIndices(),this)):null},d.prototype.subdivide=function(b){if(!(1>b)){for(var c=this.getTotalIndices(),d=c/b|0,e=0;d%3!=0;)d++;this.releaseSubMeshes();for(var f=0;b>f&&!(e>=c);f++)a.SubMesh.CreateFromIndices(0,e,Math.min(d,c-e),this),e+=d;this.synchronizeInstances()}},d.prototype.setVerticesData=function(b,c,d){if(b instanceof Array){var e=c;c=b,b=e,a.Tools.Warn("Deprecated usage of setVerticesData detected (since v1.12). Current signature is setVerticesData(kind, data, updatable).")}if(this._geometry)this._geometry.setVerticesData(b,c,d);else{var f=new a.VertexData;f.set(c,b);var g=this.getScene();new a.Geometry(a.Geometry.RandomId(),g,f,d,this)}},d.prototype.updateVerticesData=function(a,b,c,d){this._geometry&&(d?(this.makeGeometryUnique(),this.updateVerticesData(a,b,c,!1)):this._geometry.updateVerticesData(a,b,c))},d.prototype.makeGeometryUnique=function(){if(this._geometry){var b=this._geometry.copy(a.Geometry.RandomId());b.applyToMesh(this)}},d.prototype.setIndices=function(b){if(this._geometry)this._geometry.setIndices(b);else{var c=new a.VertexData;c.indices=b;var d=this.getScene();new a.Geometry(a.Geometry.RandomId(),d,c,!1,this)}},d.prototype._bind=function(a,b,c){var d=this.getScene().getEngine(),e=this._geometry.getIndexBuffer();c&&(e=a.getLinesIndexBuffer(this.getIndices(),d)),d.bindMultiBuffers(this._geometry.getVertexBuffers(),e,b)},d.prototype._draw=function(a,b,c){if(this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){var d=this.getScene().getEngine();d.draw(b,b?a.indexStart:0,b?a.indexCount:a.linesIndexCount,c)}},d.prototype.registerBeforeRender=function(a){this._onBeforeRenderCallbacks.push(a)},d.prototype.unregisterBeforeRender=function(a){var b=this._onBeforeRenderCallbacks.indexOf(a);b>-1&&this._onBeforeRenderCallbacks.splice(b,1)},d.prototype.registerAfterRender=function(a){this._onAfterRenderCallbacks.push(a)},d.prototype.unregisterAfterRender=function(a){var b=this._onAfterRenderCallbacks.indexOf(a);b>-1&&this._onAfterRenderCallbacks.splice(b,1)},d.prototype._getInstancesRenderList=function(a){var b=this.getScene();if(this._batchCache.mustReturn=!1,this._batchCache.renderSelf[a]=this.isEnabled()&&this.isVisible,this._batchCache.visibleInstances[a]=null,this._visibleInstances){var c=b.getRenderId();this._batchCache.visibleInstances[a]=this._visibleInstances[c];var d=this._renderId;if(!this._batchCache.visibleInstances[a]&&this._visibleInstances.defaultRenderId&&(this._batchCache.visibleInstances[a]=this._visibleInstances[this._visibleInstances.defaultRenderId],c=this._visibleInstances.defaultRenderId,d=this._visibleInstances.selfDefaultRenderId),this._batchCache.visibleInstances[a]&&this._batchCache.visibleInstances[a].length){if(this._renderIdForInstances[a]===c)return this._batchCache.mustReturn=!0,this._batchCache;c!==d&&(this._batchCache.renderSelf[a]=!1)}this._renderIdForInstances[a]=c}return this._batchCache},d.prototype._renderWithInstances=function(a,b,c,d,e){for(var f=this.instances.length+1,g=16*f*4;this._instancesBufferSize<g;)this._instancesBufferSize*=2;(!this._worldMatricesInstancesBuffer||this._worldMatricesInstancesBuffer.capacity<this._instancesBufferSize)&&(this._worldMatricesInstancesBuffer&&e.deleteInstancesBuffer(this._worldMatricesInstancesBuffer),this._worldMatricesInstancesBuffer=e.createInstancesBuffer(this._instancesBufferSize),this._worldMatricesInstancesArray=new Float32Array(this._instancesBufferSize/4));var h=0,i=0,j=this.getWorldMatrix();c.renderSelf[a._id]&&(j.copyToArray(this._worldMatricesInstancesArray,h),h+=16,i++);var k=c.visibleInstances[a._id];if(k)for(var l=0;l<k.length;l++){var m=k[l];m.getWorldMatrix().copyToArray(this._worldMatricesInstancesArray,h),h+=16,i++}var n=d.getAttributeLocationByName("world0"),o=d.getAttributeLocationByName("world1"),p=d.getAttributeLocationByName("world2"),q=d.getAttributeLocationByName("world3"),r=[n,o,p,q];e.updateAndBindInstancesBuffer(this._worldMatricesInstancesBuffer,this._worldMatricesInstancesArray,r),this._draw(a,!b,i),e.unBindInstancesBuffer(this._worldMatricesInstancesBuffer,r)},d.prototype.render=function(a){var b=this.getScene(),c=this._getInstancesRenderList(a._id);if(!c.mustReturn&&this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){for(var d=0;d<this._onBeforeRenderCallbacks.length;d++)this._onBeforeRenderCallbacks[d]();var e=b.getEngine(),f=null!==e.getCaps().instancedArrays&&null!==c.visibleInstances[a._id],g=a.getMaterial();if(g&&g.isReady(this,f)){g._preBind();var h=g.getEffect(),i=e.forceWireframe||g.wireframe;this._bind(a,h,i);var j=this.getWorldMatrix();if(g.bind(j,this),f)this._renderWithInstances(a,i,c,h,e);else if(c.renderSelf[a._id]&&this._draw(a,!i),c.visibleInstances[a._id])for(var k=0;k<c.visibleInstances[a._id].length;k++){var l=c.visibleInstances[a._id][k];j=l.getWorldMatrix(),g.bindOnlyWorldMatrix(j),this._draw(a,!i)}for(g.unbind(),d=0;d<this._onAfterRenderCallbacks.length;d++)this._onAfterRenderCallbacks[d]()}}},d.prototype.getEmittedParticleSystems=function(){for(var a=new Array,b=0;b<this.getScene().particleSystems.length;b++){var c=this.getScene().particleSystems[b];c.emitter===this&&a.push(c)}return a},d.prototype.getHierarchyEmittedParticleSystems=function(){var a=new Array,b=this.getDescendants();b.push(this);for(var c=0;c<this.getScene().particleSystems.length;c++){var d=this.getScene().particleSystems[c];-1!==b.indexOf(d.emitter)&&a.push(d)}return a},d.prototype.getChildren=function(){for(var a=[],b=0;b<this.getScene().meshes.length;b++){var c=this.getScene().meshes[b];c.parent==this&&a.push(c)}return a},d.prototype._checkDelayState=function(){var b=this,c=this,d=this.getScene();this._geometry?this._geometry.load(d):c.delayLoadState===a.Engine.DELAYLOADSTATE_NOTLOADED&&(c.delayLoadState=a.Engine.DELAYLOADSTATE_LOADING,d._addPendingData(c),a.Tools.LoadFile(this.delayLoadingFile,function(c){b._delayLoadingFunction(JSON.parse(c),b),b.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,d._removePendingData(b)},function(){},d.database))},d.prototype.isInFrustum=function(b){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING?!1:c.prototype.isInFrustum.call(this,b)?(this._checkDelayState(),!0):!1},d.prototype.setMaterialByID=function(a){for(var b=this.getScene().materials,c=0;c<b.length;c++)if(b[c].id==a)return void(this.material=b[c]);var d=this.getScene().multiMaterials;for(c=0;c<d.length;c++)if(d[c].id==a)return void(this.material=d[c])},d.prototype.getAnimatables=function(){var a=[];return this.material&&a.push(this.material),a},d.prototype.bakeTransformIntoVertices=function(b){if(this.isVerticesDataPresent(a.VertexBuffer.PositionKind)){this._resetPointsArrayCache();for(var c=this.getVerticesData(a.VertexBuffer.PositionKind),d=[],e=0;e<c.length;e+=3)a.Vector3.TransformCoordinates(a.Vector3.FromArray(c,e),b).toArray(d,e);if(this.setVerticesData(a.VertexBuffer.PositionKind,d,this.getVertexBuffer(a.VertexBuffer.PositionKind).isUpdatable()),this.isVerticesDataPresent(a.VertexBuffer.NormalKind)){for(c=this.getVerticesData(a.VertexBuffer.NormalKind),e=0;e<c.length;e+=3)a.Vector3.TransformNormal(a.Vector3.FromArray(c,e),b).toArray(d,e);this.setVerticesData(a.VertexBuffer.NormalKind,d,this.getVertexBuffer(a.VertexBuffer.NormalKind).isUpdatable())}}},d.prototype._resetPointsArrayCache=function(){this._positions=null},d.prototype._generatePointsArray=function(){if(this._positions)return!0;this._positions=[];var b=this.getVerticesData(a.VertexBuffer.PositionKind);if(!b)return!1;for(var c=0;c<b.length;c+=3)this._positions.push(a.Vector3.FromArray(b,c));return!0},d.prototype.clone=function(b,c,d){var e=new a.Mesh(b,this.getScene());if(this._geometry.applyToMesh(e),a.Tools.DeepCopy(this,e,["name","material","skeleton"],[]),e.material=this.material,c&&(e.parent=c),!d)for(var f=0;f<this.getScene().meshes.length;f++){var g=this.getScene().meshes[f];g.parent==this&&g.clone(g.name,e)}for(f=0;f<this.getScene().particleSystems.length;f++){var h=this.getScene().particleSystems[f];h.emitter==this&&h.clone(h.name,e)}return e.computeWorldMatrix(!0),e},d.prototype.dispose=function(a){for(this._geometry&&this._geometry.releaseForMesh(this,!0),this._worldMatricesInstancesBuffer&&(this.getEngine().deleteInstancesBuffer(this._worldMatricesInstancesBuffer),this._worldMatricesInstancesBuffer=null);this.instances.length;)this.instances[0].dispose();c.prototype.dispose.call(this,a)},d.prototype.convertToFlatShadedMesh=function(){for(var b=this.getVerticesDataKinds(),c=[],d=[],e=[],f=!1,g=0;g<b.length;g++){var h=b[g],i=this.getVertexBuffer(h);h!==a.VertexBuffer.NormalKind?(c[h]=i,d[h]=c[h].getData(),e[h]=[]):(f=i.isUpdatable(),b.splice(g,1),g--)}var j=this.subMeshes.slice(0),k=this.getIndices(),l=this.getTotalIndices();for(r=0;l>r;r++){var m=k[r];for(g=0;g<b.length;g++){h=b[g];for(var n=c[h].getStrideSize(),o=0;n>o;o++)e[h].push(d[h][m*n+o])}}for(var p=[],q=e[a.VertexBuffer.PositionKind],r=0;l>r;r+=3){k[r]=r,k[r+1]=r+1,k[r+2]=r+2;for(var s=a.Vector3.FromArray(q,3*r),t=a.Vector3.FromArray(q,3*(r+1)),u=a.Vector3.FromArray(q,3*(r+2)),v=s.subtract(t),w=u.subtract(t),x=a.Vector3.Normalize(a.Vector3.Cross(v,w)),y=0;3>y;y++)p.push(x.x),p.push(x.y),p.push(x.z)}for(this.setIndices(k),this.setVerticesData(a.VertexBuffer.NormalKind,p,f),g=0;g<b.length;g++)h=b[g],this.setVerticesData(h,e[h],c[h].isUpdatable());this.releaseSubMeshes();for(var z=0;z<j.length;z++){var A=j[z];new a.SubMesh(A.materialIndex,A.indexStart,A.indexCount,A.indexStart,A.indexCount,this)}this.synchronizeInstances()},d.prototype.createInstance=function(b){return new a.InstancedMesh(b,this)},d.prototype.synchronizeInstances=function(){for(var a=0;a<this.instances.length;a++){var b=this.instances[a];b._syncSubMeshes()}},d.CreateBox=function(b,c,d,e){var f=new a.Mesh(b,d),g=a.VertexData.CreateBox(c);return g.applyToMesh(f,e),f},d.CreateSphere=function(b,c,d,e,f){var g=new a.Mesh(b,e),h=a.VertexData.CreateSphere(c,d);return h.applyToMesh(g,f),g},d.CreateCylinder=function(b,c,d,e,f,g,h,i){void 0!==h&&h instanceof a.Scene||(void 0!==h&&(i=h),h=g,g=1);var j=new a.Mesh(b,h),k=a.VertexData.CreateCylinder(c,d,e,f,g);return k.applyToMesh(j,i),j},d.CreateTorus=function(b,c,d,e,f,g){var h=new a.Mesh(b,f),i=a.VertexData.CreateTorus(c,d,e);return i.applyToMesh(h,g),h},d.CreateTorusKnot=function(b,c,d,e,f,g,h,i,j){var k=new a.Mesh(b,i),l=a.VertexData.CreateTorusKnot(c,d,e,f,g,h);return l.applyToMesh(k,j),k},d.CreateLines=function(b,c,d,e){var f=new a.LinesMesh(b,d,e),g=a.VertexData.CreateLines(c);return g.applyToMesh(f,e),f},d.CreatePlane=function(b,c,d,e){var f=new a.Mesh(b,d),g=a.VertexData.CreatePlane(c);return g.applyToMesh(f,e),f},d.CreateGround=function(b,c,d,e,f,g){var h=new a.GroundMesh(b,f);h._setReady(!1),h._subdivisions=e;var i=a.VertexData.CreateGround(c,d,e);return i.applyToMesh(h,g),h._setReady(!0),h},d.CreateTiledGround=function(b,c,d,e,f,g,h,i,j){var k=new a.Mesh(b,i),l=a.VertexData.CreateTiledGround(c,d,e,f,g,h);return l.applyToMesh(k,j),k},d.CreateGroundFromHeightMap=function(b,c,d,e,f,g,h,i,j){var k=new a.GroundMesh(b,i);k._subdivisions=f,k._setReady(!1);var l=function(b){var c=document.createElement("canvas"),i=c.getContext("2d"),l=b.width,m=b.height;c.width=l,c.height=m,i.drawImage(b,0,0);var n=i.getImageData(0,0,l,m).data,o=a.VertexData.CreateGroundFromHeightMap(d,e,f,g,h,n,l,m);o.applyToMesh(k,j),k._setReady(!0)};return a.Tools.LoadImage(c,l,function(){},i.database),k},d.MinMax=function(a){var b=null,c=null;for(var d in a){var e=a[d],f=e.getBoundingInfo().boundingBox;b?(b.MinimizeInPlace(f.minimumWorld),c.MaximizeInPlace(f.maximumWorld)):(b=f.minimumWorld,c=f.maximumWorld)}return{min:b,max:c}},d.Center=function(b){var c=void 0!==b.min?b:a.Mesh.MinMax(b);return a.Vector3.Center(c.min,c.max)},d}(a.AbstractMesh);a.Mesh=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.generateOctree=!1,this._worldInverse=new a.Matrix}return __extends(c,b),Object.defineProperty(c.prototype,"subdivisions",{get:function(){return this._subdivisions},enumerable:!0,configurable:!0}),c.prototype.optimize=function(){this.subdivide(this._subdivisions),this.createOrUpdateSubmeshesOctree(32)},c.prototype.getHeightAtCoordinates=function(b,c){var d=new a.Ray(new a.Vector3(b,this.getBoundingInfo().boundingBox.maximumWorld.y+1,c),new a.Vector3(0,-1,0));this.getWorldMatrix().invertToRef(this._worldInverse),d=a.Ray.Transform(d,this._worldInverse);var e=this.intersects(d);return e.hit?e.pickedPoint.y:0},c}(a.Mesh);a.GroundMesh=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c){b.call(this,a,c.getScene()),c.instances.push(this),this._sourceMesh=c,this.position.copyFrom(c.position),this.rotation.copyFrom(c.rotation),this.scaling.copyFrom(c.scaling),c.rotationQuaternion&&(this.rotationQuaternion=c.rotationQuaternion.clone()),this.infiniteDistance=c.infiniteDistance,this.setPivotMatrix(c.getPivotMatrix()),this.refreshBoundingInfo(),this._syncSubMeshes()}return __extends(c,b),Object.defineProperty(c.prototype,"receiveShadows",{get:function(){return this._sourceMesh.receiveShadows},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"material",{get:function(){return this._sourceMesh.material},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"visibility",{get:function(){return this._sourceMesh.visibility},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"skeleton",{get:function(){return this._sourceMesh.skeleton},enumerable:!0,configurable:!0}),c.prototype.getTotalVertices=function(){return this._sourceMesh.getTotalVertices()},Object.defineProperty(c.prototype,"sourceMesh",{get:function(){return this._sourceMesh},enumerable:!0,configurable:!0}),c.prototype.getVerticesData=function(a){return this._sourceMesh.getVerticesData(a)},c.prototype.isVerticesDataPresent=function(a){return this._sourceMesh.isVerticesDataPresent(a)},c.prototype.getIndices=function(){return this._sourceMesh.getIndices()},Object.defineProperty(c.prototype,"_positions",{get:function(){return this._sourceMesh._positions},enumerable:!0,configurable:!0}),c.prototype.refreshBoundingInfo=function(){var b=this._sourceMesh.getVerticesData(a.VertexBuffer.PositionKind);if(b){var c=a.Tools.ExtractMinAndMax(b,0,this._sourceMesh.getTotalVertices());this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)}this._updateBoundingInfo()},c.prototype._preActivate=function(){this.sourceMesh._preActivate()},c.prototype._activate=function(a){this.sourceMesh._registerInstanceForRenderId(this,a)},c.prototype._syncSubMeshes=function(){this.releaseSubMeshes();for(var a=0;a<this._sourceMesh.subMeshes.length;a++)this._sourceMesh.subMeshes[a].clone(this,this._sourceMesh)},c.prototype._generatePointsArray=function(){return this._sourceMesh._generatePointsArray()},c.prototype.clone=function(b,c,d){var e=this._sourceMesh.createInstance(b);if(a.Tools.DeepCopy(this,e,["name"],[]),this.refreshBoundingInfo(),c&&(e.parent=c),!d)for(var f=0;f<this.getScene().meshes.length;f++){var g=this.getScene().meshes[f];g.parent==this&&g.clone(g.name,e)}return e.computeWorldMatrix(!0),e},c.prototype.dispose=function(a){var c=this._sourceMesh.instances.indexOf(this);this._sourceMesh.instances.splice(c,1),b.prototype.dispose.call(this,a)},c}(a.AbstractMesh);a.InstancedMesh=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h){"undefined"==typeof h&&(h=!0),this.materialIndex=a,this.verticesStart=b,this.verticesCount=c,this.indexStart=d,this.indexCount=e,this._renderId=0,this._mesh=f,this._renderingMesh=g||f,f.subMeshes.push(this),this._id=f.subMeshes.length-1,h&&this.refreshBoundingInfo()}return b.prototype.getBoundingInfo=function(){return this._boundingInfo},b.prototype.getMesh=function(){return this._mesh},b.prototype.getRenderingMesh=function(){return this._renderingMesh},b.prototype.getMaterial=function(){var b=this._renderingMesh.material;if(b&&b instanceof a.MultiMaterial){var c=b;return c.getSubMaterial(this.materialIndex)}return b?b:this._mesh.getScene().defaultMaterial},b.prototype.refreshBoundingInfo=function(){var b=this._renderingMesh.getVerticesData(a.VertexBuffer.PositionKind);if(!b)return void(this._boundingInfo=this._mesh._boundingInfo);var c,d=this._renderingMesh.getIndices();c=0===this.indexStart&&this.indexCount===d.length?a.Tools.ExtractMinAndMax(b,this.verticesStart,this.verticesCount):a.Tools.ExtractMinAndMaxIndexed(b,d,this.indexStart,this.indexCount),this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)},b.prototype._checkCollision=function(a){return this._boundingInfo._checkCollision(a)},b.prototype.updateBoundingInfo=function(a){this._boundingInfo||this.refreshBoundingInfo(),this._boundingInfo._update(a)},b.prototype.isInFrustum=function(a){return this._boundingInfo.isInFrustum(a)},b.prototype.render=function(){this._renderingMesh.render(this)},b.prototype.getLinesIndexBuffer=function(a,b){if(!this._linesIndexBuffer){for(var c=[],d=this.indexStart;d<this.indexStart+this.indexCount;d+=3)c.push(a[d],a[d+1],a[d+1],a[d+2],a[d+2],a[d]);this._linesIndexBuffer=b.createIndexBuffer(c),this.linesIndexCount=c.length}return this._linesIndexBuffer},b.prototype.canIntersects=function(a){return a.intersectsBox(this._boundingInfo.boundingBox)},b.prototype.intersects=function(a,b,c,d){for(var e=null,f=this.indexStart;f<this.indexStart+this.indexCount;f+=3){var g=b[c[f]],h=b[c[f+1]],i=b[c[f+2]],j=a.intersectsTriangle(g,h,i);if(j&&(d||!e||j.distance<e.distance)&&(e=j,e.faceId=f/3,d))break}return e},b.prototype.clone=function(c,d){var e=new b(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,c,d,!1);return e._boundingInfo=new a.BoundingInfo(this._boundingInfo.minimum,this._boundingInfo.maximum),e},b.prototype.dispose=function(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);var a=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(a,1)},b.CreateFromIndices=function(b,c,d,e,f){var g=Number.MAX_VALUE,h=-Number.MAX_VALUE;f=f||e;for(var i=f.getIndices(),j=c;c+d>j;j++){var k=i[j];g>k&&(g=k),k>h&&(h=k)}return new a.SubMesh(b,g,h-g+1,c,d,e,f)},b}();a.SubMesh=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.hasAlpha=!1,this.getAlphaFromRGB=!1,this.level=1,this.isCube=!1,this.isRenderTarget=!1,this.animations=new Array,this.coordinatesIndex=0,this.coordinatesMode=a.Texture.EXPLICIT_MODE,this.wrapU=a.Texture.WRAP_ADDRESSMODE,this.wrapV=a.Texture.WRAP_ADDRESSMODE,this.anisotropicFilteringLevel=4,this._scene=b,this._scene.textures.push(this)}return b.prototype.getScene=function(){return this._scene},b.prototype.getTextureMatrix=function(){return null},b.prototype.getReflectionTextureMatrix=function(){return null},b.prototype.getInternalTexture=function(){return this._texture},b.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_NOTLOADED?!0:this._texture?this._texture.isReady:!1},b.prototype.getSize=function(){return this._texture._width?{width:this._texture._width,height:this._texture._height}:this._texture._size?{width:this._texture._size,height:this._texture._size}:{width:0,height:0}},b.prototype.getBaseSize=function(){return this.isReady()?this._texture._size?{width:this._texture._size,height:this._texture._size}:{width:this._texture._baseWidth,height:this._texture._baseHeight}:{width:0,height:0}},b.prototype._getFromCache=function(a,b){for(var c=this._scene.getEngine().getLoadedTexturesCache(),d=0;d<c.length;d++){var e=c[d];if(e.url===a&&e.noMipmap===b)return e.references++,e}return null},b.prototype.delayLoad=function(){},b.prototype.releaseInternalTexture=function(){if(this._texture){var a=this._scene.getEngine().getLoadedTexturesCache();if(this._texture.references--,0==this._texture.references){var b=a.indexOf(this._texture);a.splice(b,1),this._scene.getEngine()._releaseTexture(this._texture),delete this._texture}}},b.prototype.clone=function(){return null},b.prototype.dispose=function(){var a=this._scene.textures.indexOf(this);a>=0&&this._scene.textures.splice(a,1),void 0!==this._texture&&(this.releaseInternalTexture(),this.onDispose&&this.onDispose())},b}();a.BaseTexture=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.index=b,this._opaqueSubMeshes=new a.SmartArray(256),this._transparentSubMeshes=new a.SmartArray(256),this._alphaTestSubMeshes=new a.SmartArray(256),this._scene=c}return b.prototype.render=function(b,c){if(b)return b(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,c),!0;if(0===this._opaqueSubMeshes.length&&0===this._alphaTestSubMeshes.length&&0===this._transparentSubMeshes.length)return!1;var d,e,f=this._scene.getEngine();for(d=0;d<this._opaqueSubMeshes.length;d++)e=this._opaqueSubMeshes.data[d],this._activeVertices+=e.verticesCount,e.render();for(f.setAlphaTesting(!0),d=0;d<this._alphaTestSubMeshes.length;d++)e=this._alphaTestSubMeshes.data[d],this._activeVertices+=e.verticesCount,e.render();if(f.setAlphaTesting(!1),c&&c(),this._transparentSubMeshes.length){for(d=0;d<this._transparentSubMeshes.length;d++)e=this._transparentSubMeshes.data[d],e._distanceToCamera=e.getBoundingInfo().boundingSphere.centerWorld.subtract(this._scene.activeCamera.position).length();var g=this._transparentSubMeshes.data.slice(0,this._transparentSubMeshes.length);for(g.sort(function(a,b){return a._distanceToCamera<b._distanceToCamera?1:a._distanceToCamera>b._distanceToCamera?-1:0}),f.setAlphaMode(a.Engine.ALPHA_COMBINE),d=0;d<g.length;d++)e=g[d],this._activeVertices+=e.verticesCount,e.render();f.setAlphaMode(a.Engine.ALPHA_DISABLE)}return!0},b.prototype.prepare=function(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset()},b.prototype.dispatch=function(a){var b=a.getMaterial(),c=a.getMesh();b.needAlphaBlending()||c.visibility<1?(b.alpha>0||c.visibility<1)&&this._transparentSubMeshes.push(a):b.needAlphaTesting()?this._alphaTestSubMeshes.push(a):this._opaqueSubMeshes.push(a)},b}();a.RenderingGroup=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a){this._renderingGroups=new Array,this._scene=a}return b.prototype._renderParticles=function(a,b){if(0!==this._scene._activeParticleSystems.length){for(var c=(new Date).getTime(),d=0;d<this._scene._activeParticleSystems.length;d++){var e=this._scene._activeParticleSystems.data[d];e.renderingGroupId===a&&(this._clearDepthBuffer(),e.emitter.position&&b&&-1===b.indexOf(e.emitter)||(this._scene._activeParticles+=e.render()))}this._scene._particlesDuration+=(new Date).getTime()-c}},b.prototype._renderSprites=function(a){if(0!==this._scene.spriteManagers.length){for(var b=(new Date).getTime(),c=0;c<this._scene.spriteManagers.length;c++){var d=this._scene.spriteManagers[c];d.renderingGroupId===a&&(this._clearDepthBuffer(),d.render())}this._scene._spritesDuration+=(new Date).getTime()-b}},b.prototype._clearDepthBuffer=function(){this._depthBufferAlreadyCleaned||(this._scene.getEngine().clear(0,!1,!0),this._depthBufferAlreadyCleaned=!0)},b.prototype.render=function(b,c,d,e){for(var f=this,g=0;g<a.RenderingManager.MAX_RENDERINGGROUPS;g++){this._depthBufferAlreadyCleaned=!1;var h=this._renderingGroups[g];h?(this._clearDepthBuffer(),h.render(b,function(){e&&f._renderSprites(g)})||this._renderingGroups.splice(g,1)):e&&this._renderSprites(g),d&&this._renderParticles(g,c)}},b.prototype.reset=function(){for(var a in this._renderingGroups){var b=this._renderingGroups[a];b.prepare()}},b.prototype.dispatch=function(b){var c=b.getMesh(),d=c.renderingGroupId||0;this._renderingGroups[d]||(this._renderingGroups[d]=new a.RenderingGroup(d,this._scene)),this._renderingGroups[d].dispatch(b)},b.MAX_RENDERINGGROUPS=4,b}();a.RenderingManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(d,e,f,g,h){"undefined"==typeof h&&(h=c.TRILINEAR_SAMPLINGMODE),b.call(this,e),this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.name=d,this.url=d,this._noMipmap=f,this._invertY=g,this._samplingMode=h,d&&(this._texture=this._getFromCache(d,f),this._texture||(e.useDelayedTextureLoading?this.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED:this._texture=e.getEngine().createTexture(d,f,g,e,this._samplingMode)))}return __extends(c,b),c.prototype.delayLoad=function(){this.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED&&(this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||(this._texture=this.getScene().getEngine().createTexture(this.url,this._noMipmap,this._invertY,this.getScene(),this._samplingMode)))},c.prototype._prepareRowForTextureGeneration=function(b,c,d,e){b-=this.uOffset+.5,c-=this.vOffset+.5,d-=.5,a.Vector3.TransformCoordinatesFromFloatsToRef(b,c,d,this._rowGenerationMatrix,e),e.x*=this.uScale,e.y*=this.vScale,e.x+=.5,e.y+=.5,e.z+=.5},c.prototype.getTextureMatrix=function(){return this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng?this._cachedTextureMatrix:(this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedTextureMatrix||(this._cachedTextureMatrix=a.Matrix.Zero(),this._rowGenerationMatrix=new a.Matrix,this._t0=a.Vector3.Zero(),this._t1=a.Vector3.Zero(),this._t2=a.Vector3.Zero()),a.Matrix.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix.m[0]=this._t1.x,this._cachedTextureMatrix.m[1]=this._t1.y,this._cachedTextureMatrix.m[2]=this._t1.z,this._cachedTextureMatrix.m[4]=this._t2.x,this._cachedTextureMatrix.m[5]=this._t2.y,this._cachedTextureMatrix.m[6]=this._t2.z,this._cachedTextureMatrix.m[8]=this._t0.x,this._cachedTextureMatrix.m[9]=this._t0.y,this._cachedTextureMatrix.m[10]=this._t0.z,this._cachedTextureMatrix)},c.prototype.getReflectionTextureMatrix=function(){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale===this._cachedUScale&&this.vScale===this._cachedVScale&&this.coordinatesMode===this._cachedCoordinatesMode)return this._cachedTextureMatrix;switch(this._cachedTextureMatrix||(this._cachedTextureMatrix=a.Matrix.Zero(),this._projectionModeMatrix=a.Matrix.Zero()),this.coordinatesMode){case a.Texture.SPHERICAL_MODE:a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix[0]=-.5*this.uScale,this._cachedTextureMatrix[5]=-.5*this.vScale,this._cachedTextureMatrix[12]=.5+this.uOffset,this._cachedTextureMatrix[13]=.5+this.vOffset;break;case a.Texture.PLANAR_MODE:a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix[0]=this.uScale,this._cachedTextureMatrix[5]=this.vScale,this._cachedTextureMatrix[12]=this.uOffset,this._cachedTextureMatrix[13]=this.vOffset;break;case a.Texture.PROJECTION_MODE:a.Matrix.IdentityToRef(this._projectionModeMatrix),this._projectionModeMatrix.m[0]=.5,this._projectionModeMatrix.m[5]=-.5,this._projectionModeMatrix.m[10]=0,this._projectionModeMatrix.m[12]=.5,this._projectionModeMatrix.m[13]=.5,this._projectionModeMatrix.m[14]=1,this._projectionModeMatrix.m[15]=1,this.getScene().getProjectionMatrix().multiplyToRef(this._projectionModeMatrix,this._cachedTextureMatrix);
break;default:a.Matrix.IdentityToRef(this._cachedTextureMatrix)}return this._cachedTextureMatrix},c.prototype.clone=function(){var b=new a.Texture(this._texture.url,this.getScene(),this._noMipmap,this._invertY);return b.hasAlpha=this.hasAlpha,b.level=this.level,b.wrapU=this.wrapU,b.wrapV=this.wrapV,b.coordinatesIndex=this.coordinatesIndex,b.coordinatesMode=this.coordinatesMode,b.uOffset=this.uOffset,b.vOffset=this.vOffset,b.uScale=this.uScale,b.vScale=this.vScale,b.uAng=this.uAng,b.vAng=this.vAng,b.wAng=this.wAng,b},c.NEAREST_SAMPLINGMODE=1,c.BILINEAR_SAMPLINGMODE=2,c.TRILINEAR_SAMPLINGMODE=3,c.EXPLICIT_MODE=0,c.SPHERICAL_MODE=1,c.PLANAR_MODE=2,c.CUBIC_MODE=3,c.PROJECTION_MODE=4,c.SKYBOX_MODE=5,c.CLAMP_ADDRESSMODE=0,c.WRAP_ADDRESSMODE=1,c.MIRROR_ADDRESSMODE=2,c}(a.BaseTexture);a.Texture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){b.call(this,d),this.coordinatesMode=a.Texture.CUBIC_MODE,this.name=c,this.url=c,this._noMipmap=f,this.hasAlpha=!1,this._texture=this._getFromCache(c,f),e||(e=["_px.jpg","_py.jpg","_pz.jpg","_nx.jpg","_ny.jpg","_nz.jpg"]),this._extensions=e,this._texture||(d.useDelayedTextureLoading?this.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED:this._texture=d.getEngine().createCubeTexture(c,d,e,f)),this.isCube=!0,this._textureMatrix=a.Matrix.Identity()}return __extends(c,b),c.prototype.clone=function(){var b=new a.CubeTexture(this.url,this.getScene(),this._extensions,this._noMipmap);return b.level=this.level,b.wrapU=this.wrapU,b.wrapV=this.wrapV,b.coordinatesIndex=this.coordinatesIndex,b.coordinatesMode=this.coordinatesMode,b},c.prototype.delayLoad=function(){this.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED&&(this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||(this._texture=this.getScene().getEngine().createCubeTexture(this.url,this.getScene(),this._extensions)))},c.prototype.getReflectionTextureMatrix=function(){return this._textureMatrix},c}(a.BaseTexture);a.CubeTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g){"undefined"==typeof g&&(g=!0),b.call(this,null,e,!f),this.renderList=new Array,this.renderParticles=!0,this.renderSprites=!1,this.coordinatesMode=a.Texture.PROJECTION_MODE,this._currentRefreshId=-1,this._refreshRate=1,this.name=c,this.isRenderTarget=!0,this._size=d,this._generateMipMaps=f,this._doNotChangeAspectRatio=g,this._texture=e.getEngine().createRenderTargetTexture(d,f),this._renderingManager=new a.RenderingManager(e)}return __extends(c,b),c.prototype.resetRefreshCounter=function(){this._currentRefreshId=-1},Object.defineProperty(c.prototype,"refreshRate",{get:function(){return this._refreshRate},set:function(a){this._refreshRate=a,this.resetRefreshCounter()},enumerable:!0,configurable:!0}),c.prototype._shouldRender=function(){return-1===this._currentRefreshId?(this._currentRefreshId=1,!0):this.refreshRate==this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)},c.prototype.getRenderSize=function(){return this._size},c.prototype.resize=function(a,b){this.releaseInternalTexture(),this._texture=this.getScene().getEngine().createRenderTargetTexture(a,b)},c.prototype.render=function(a){var b=this.getScene(),c=b.getEngine();if(this._waitingRenderList){this.renderList=[];for(var d=0;d<this._waitingRenderList.length;d++){var e=this._waitingRenderList[d];this.renderList.push(b.getMeshByID(e))}delete this._waitingRenderList}if(this.renderList&&0!=this.renderList.length){a&&b.postProcessManager._prepareFrame(this._texture)||c.bindFramebuffer(this._texture),c.clear(b.clearColor,!0,!0),this._renderingManager.reset();for(var f=0;f<this.renderList.length;f++){var g=this.renderList[f];if(g){if(!g.isReady()||g.material&&!g.material.isReady()){this.resetRefreshCounter();continue}if(g.isEnabled()&&g.isVisible&&g.subMeshes&&0!=(g.layerMask&b.activeCamera.layerMask)){g._activate(b.getRenderId());for(var h=0;h<g.subMeshes.length;h++){var i=g.subMeshes[h];b._activeVertices+=i.verticesCount,this._renderingManager.dispatch(i)}}}}this._doNotChangeAspectRatio||b.updateTransformMatrix(!0),this.onBeforeRender&&this.onBeforeRender(),this._renderingManager.render(this.customRenderFunction,this.renderList,this.renderParticles,this.renderSprites),a&&b.postProcessManager._finalizeFrame(!1,this._texture),this.onAfterRender&&this.onAfterRender(),c.unBindFramebuffer(this._texture),this._doNotChangeAspectRatio||b.updateTransformMatrix(!0)}},c.prototype.clone=function(){var b=this.getSize(),c=new a.RenderTargetTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.coordinatesMode=this.coordinatesMode,c.renderList=this.renderList.slice(0),c},c}(a.Texture);a.RenderTargetTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){var g=this;b.call(this,c,d,e,f,!0),this.mirrorPlane=new a.Plane(0,1,0,1),this._transformMatrix=a.Matrix.Zero(),this._mirrorMatrix=a.Matrix.Zero(),this.onBeforeRender=function(){a.Matrix.ReflectionToRef(g.mirrorPlane,g._mirrorMatrix),g._savedViewMatrix=e.getViewMatrix(),g._mirrorMatrix.multiplyToRef(g._savedViewMatrix,g._transformMatrix),e.setTransformMatrix(g._transformMatrix,e.getProjectionMatrix()),e.clipPlane=g.mirrorPlane,e.getEngine().cullBackFaces=!1},this.onAfterRender=function(){e.setTransformMatrix(g._savedViewMatrix,e.getProjectionMatrix()),e.getEngine().cullBackFaces=!0,delete e.clipPlane}}return __extends(c,b),c.prototype.clone=function(){var b=this.getSize(),c=new a.MirrorTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.mirrorPlane=this.mirrorPlane.clone(),c.renderList=this.renderList.slice(0),c},c}(a.RenderTargetTexture);a.MirrorTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g){"undefined"==typeof g&&(g=a.Texture.TRILINEAR_SAMPLINGMODE),b.call(this,null,e,!f),this.name=c,this.wrapU=a.Texture.CLAMP_ADDRESSMODE,this.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._generateMipMaps=f,d.getContext?(this._canvas=d,this._texture=e.getEngine().createDynamicTexture(d.width,d.height,f,g)):(this._canvas=document.createElement("canvas"),this._texture=d.width?e.getEngine().createDynamicTexture(d.width,d.height,f,g):e.getEngine().createDynamicTexture(d,d,f,g));var h=this.getSize();this._canvas.width=h.width,this._canvas.height=h.height,this._context=this._canvas.getContext("2d")}return __extends(c,b),c.prototype.getContext=function(){return this._context},c.prototype.update=function(a){this.getScene().getEngine().updateDynamicTexture(this._texture,this._canvas,void 0===a?!0:a)},c.prototype.drawText=function(a,b,c,d,e,f,g){var h=this.getSize();if(f&&(this._context.fillStyle=f,this._context.fillRect(0,0,h.width,h.height)),this._context.font=d,null===b){var i=this._context.measureText(a);b=(h.width-i.width)/2}this._context.fillStyle=e,this._context.fillText(a,b,c),this.update(g)},c.prototype.clone=function(){var b=this.getSize(),c=new a.DynamicTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.wrapU=this.wrapU,c.wrapV=this.wrapV,c},c}(a.Texture);a.DynamicTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i){"undefined"==typeof i&&(i=a.Texture.TRILINEAR_SAMPLINGMODE);var j=this;b.call(this,null,f,!g,h),this._autoLaunch=!0,this.name=c,this.wrapU=a.Texture.WRAP_ADDRESSMODE,this.wrapV=a.Texture.WRAP_ADDRESSMODE;var k=e.width||e,l=e.height||e;this._texture=f.getEngine().createDynamicTexture(k,l,g,i);var m=this.getSize();this.video=document.createElement("video"),this.video.width=m.width,this.video.height=m.height,this.video.autoplay=!1,this.video.loop=!0,this.video.addEventListener("canplaythrough",function(){j._texture&&(j._texture.isReady=!0)}),d.forEach(function(a){var b=document.createElement("source");b.src=a,j.video.appendChild(b)}),this._lastUpdate=(new Date).getTime()}return __extends(c,b),c.prototype.update=function(){this._autoLaunch&&(this._autoLaunch=!1,this.video.play());var a=(new Date).getTime();return a-this._lastUpdate<15?!1:(this._lastUpdate=a,this.getScene().getEngine().updateVideoTexture(this._texture,this.video,this._invertY),!0)},c}(a.Texture);a.VideoTexture=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h,i){var j=this;this._isReady=!1,this._compilationError="",this._valueCache=[],this._engine=e,this.name=a,this.defines=f,this._uniformsNames=c.concat(d),this._samplers=d,this._attributesNames=b,this.onError=i,this.onCompiled=h;var k,l;k=a.vertexElement?document.getElementById(a.vertexElement):a.vertex||a,l=a.fragmentElement?document.getElementById(a.fragmentElement):a.fragment||a,this._loadVertexShader(k,function(a){j._loadFragmentShader(l,function(c){j._prepareEffect(a,c,b,f,g)})})}return b.prototype.isReady=function(){return this._isReady},b.prototype.getProgram=function(){return this._program},b.prototype.getAttributesNames=function(){return this._attributesNames},b.prototype.getAttributeLocation=function(a){return this._attributes[a]},b.prototype.getAttributeLocationByName=function(a){var b=this._attributesNames.indexOf(a);return this._attributes[b]},b.prototype.getAttributesCount=function(){return this._attributes.length},b.prototype.getUniformIndex=function(a){return this._uniformsNames.indexOf(a)},b.prototype.getUniform=function(a){return this._uniforms[this._uniformsNames.indexOf(a)]},b.prototype.getSamplers=function(){return this._samplers},b.prototype.getCompilationError=function(){return this._compilationError},b.prototype._loadVertexShader=function(b,c){if(b instanceof HTMLElement){var d=a.Tools.GetDOMTextContent(b);return void c(d)}if(a.Effect.ShadersStore[b+"VertexShader"])return void c(a.Effect.ShadersStore[b+"VertexShader"]);var e;e="."===b[0]?b:a.Engine.ShadersRepository+b,a.Tools.LoadFile(e+".vertex.fx",c)},b.prototype._loadFragmentShader=function(b,c){if(b instanceof HTMLElement){var d=a.Tools.GetDOMTextContent(b);return void c(d)}if(a.Effect.ShadersStore[b+"PixelShader"])return void c(a.Effect.ShadersStore[b+"PixelShader"]);var e;e="."===b[0]?b:a.Engine.ShadersRepository+b,a.Tools.LoadFile(e+".fragment.fx",c)},b.prototype._prepareEffect=function(b,c,d,e,f,g){try{var h=this._engine;this._program=h.createShaderProgram(b,c,e),this._uniforms=h.getUniforms(this._program,this._uniformsNames),this._attributes=h.getAttributes(this._program,d);for(var i=0;i<this._samplers.length;i++){var j=this.getUniform(this._samplers[i]);null==j&&(this._samplers.splice(i,1),i--)}h.bindSamplers(this),this._isReady=!0,this.onCompiled&&this.onCompiled(this)}catch(k){if(!g&&f){for(i=0;i<f.length;i++)e=e.replace(f[i],"");this._prepareEffect(b,c,d,e,f,!0)}else a.Tools.Error("Unable to compile effect: "+this.name),a.Tools.Error("Defines: "+e),a.Tools.Error("Optional defines: "+f),a.Tools.Error("Error: "+k.message),this._compilationError=k.message,this.onError&&this.onError(this,this._compilationError)}},b.prototype._bindTexture=function(a,b){this._engine._bindTexture(this._samplers.indexOf(a),b)},b.prototype.setTexture=function(a,b){this._engine.setTexture(this._samplers.indexOf(a),b)},b.prototype.setTextureFromPostProcess=function(a,b){this._engine.setTextureFromPostProcess(this._samplers.indexOf(a),b)},b.prototype._cacheFloat2=function(a,b,c){return this._valueCache[a]?(this._valueCache[a][0]=b,void(this._valueCache[a][1]=c)):void(this._valueCache[a]=[b,c])},b.prototype._cacheFloat3=function(a,b,c,d){return this._valueCache[a]?(this._valueCache[a][0]=b,this._valueCache[a][1]=c,void(this._valueCache[a][2]=d)):void(this._valueCache[a]=[b,c,d])},b.prototype._cacheFloat4=function(a,b,c,d,e){return this._valueCache[a]?(this._valueCache[a][0]=b,this._valueCache[a][1]=c,this._valueCache[a][2]=d,void(this._valueCache[a][3]=e)):void(this._valueCache[a]=[b,c,d,e])},b.prototype.setArray=function(a,b){return this._engine.setArray(this.getUniform(a),b),this},b.prototype.setMatrices=function(a,b){return this._engine.setMatrices(this.getUniform(a),b),this},b.prototype.setMatrix=function(a,b){return this._engine.setMatrix(this.getUniform(a),b),this},b.prototype.setFloat=function(a,b){return this._valueCache[a]&&this._valueCache[a]===b?this:(this._valueCache[a]=b,this._engine.setFloat(this.getUniform(a),b),this)},b.prototype.setBool=function(a,b){return this._valueCache[a]&&this._valueCache[a]===b?this:(this._valueCache[a]=b,this._engine.setBool(this.getUniform(a),b?1:0),this)},b.prototype.setVector2=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.x&&this._valueCache[a][1]==b.y?this:(this._cacheFloat2(a,b.x,b.y),this._engine.setFloat2(this.getUniform(a),b.x,b.y),this)},b.prototype.setFloat2=function(a,b,c){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c?this:(this._cacheFloat2(a,b,c),this._engine.setFloat2(this.getUniform(a),b,c),this)},b.prototype.setVector3=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.x&&this._valueCache[a][1]==b.y&&this._valueCache[a][2]==b.z?this:(this._cacheFloat3(a,b.x,b.y,b.z),this._engine.setFloat3(this.getUniform(a),b.x,b.y,b.z),this)},b.prototype.setFloat3=function(a,b,c,d){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c&&this._valueCache[a][2]==d?this:(this._cacheFloat3(a,b,c,d),this._engine.setFloat3(this.getUniform(a),b,c,d),this)},b.prototype.setFloat4=function(a,b,c,d,e){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c&&this._valueCache[a][2]==d&&this._valueCache[a][3]==e?this:(this._cacheFloat4(a,b,c,d,e),this._engine.setFloat4(this.getUniform(a),b,c,d,e),this)},b.prototype.setColor3=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.r&&this._valueCache[a][1]==b.g&&this._valueCache[a][2]==b.b?this:(this._cacheFloat3(a,b.r,b.g,b.b),this._engine.setColor3(this.getUniform(a),b),this)},b.prototype.setColor4=function(a,b,c){return this._valueCache[a]&&this._valueCache[a][0]==b.r&&this._valueCache[a][1]==b.g&&this._valueCache[a][2]==b.b&&this._valueCache[a][3]==c?this:(this._cacheFloat4(a,b.r,b.g,b.b,c),this._engine.setColor4(this.getUniform(a),b,c),this)},b.ShadersStore={anaglyphPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\n\nvoid main(void)\n{\n    vec4 leftFrag = texture2D(leftSampler, vUV);\n    leftFrag = vec4(1.0, leftFrag.g, leftFrag.b, 1.0);\n\n	vec4 rightFrag = texture2D(textureSampler, vUV);\n    rightFrag = vec4(rightFrag.r, 1.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(rightFrag.rgb * leftFrag.rgb, 1.0);\n}",blackAndWhitePixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));\n	gl_FragColor = vec4(luminance, luminance, luminance, 1.0);\n}",blurPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Parameters\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nvoid main(void)\n{\n	float weights[7];\n	weights[0] = 0.05;\n	weights[1] = 0.1;\n	weights[2] = 0.2;\n	weights[3] = 0.3;\n	weights[4] = 0.2;\n	weights[5] = 0.1;\n	weights[6] = 0.05;\n\n	vec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\n	vec2 texelStep = texelSize * direction * blurWidth;\n	vec2 start = vUV - 3.0 * texelStep;\n\n	vec4 baseColor = vec4(0., 0., 0., 0.);\n	vec2 texelOffset = vec2(0., 0.);\n\n	for (int i = 0; i < 7; i++)\n	{\n		baseColor += texture2D(textureSampler, start + texelOffset) * weights[i];\n		texelOffset += texelStep;\n	}\n\n	gl_FragColor = baseColor;\n}",colorPixelShader:"precision mediump float;\n\nuniform vec3 color;\n\nvoid main(void) {\n	gl_FragColor = vec4(color, 1.);\n}",colorVertexShader:"precision mediump float;\n\n// Attributes\nattribute vec3 position;\n\n// Uniforms\nuniform mat4 worldViewProjection;\n\nvoid main(void) {\n	gl_Position = worldViewProjection * vec4(position, 1.0);\n}",convolutionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform float kernel[9];\n\nvoid main(void)\n{\n	vec2 onePixel = vec2(1.0, 1.0) / screenSize;\n	vec4 colorSum =\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, -1)) * kernel[0] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, -1)) * kernel[1] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, -1)) * kernel[2] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 0)) * kernel[3] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 0)) * kernel[4] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 0)) * kernel[5] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 1)) * kernel[6] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 1)) * kernel[7] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 1)) * kernel[8];\n\n	float kernelWeight =\n		kernel[0] +\n		kernel[1] +\n		kernel[2] +\n		kernel[3] +\n		kernel[4] +\n		kernel[5] +\n		kernel[6] +\n		kernel[7] +\n		kernel[8];\n\n	if (kernelWeight <= 0.0) {\n		kernelWeight = 1.0;\n	}\n\n	gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);\n}",defaultPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\nuniform float darkness0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\nuniform float darkness1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\nuniform float darkness2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\nuniform float darkness3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Reflection\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform mat4 view;\n\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return vPositionUVW;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return darkness;\n	}\n	return 1.;\n}\n\nfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float visibility = 1.;\n\n	vec2 poissonDisk[4];\n	poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n	poissonDisk[1] = vec2(0.94558609, -0.76890725);\n	poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n	poissonDisk[3] = vec2(0.34495938, 0.29387760);\n\n	// Poisson Sampling\n	for (int i = 0; i<4; i++){\n		if (unpack(texture2D(shadowSampler, uv + poissonDisk[i] / 1500.0))  <  depth.z){\n			visibility -= 0.2;\n		}\n	}\n	return visibility;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n// Bump\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform sampler2D bumpSampler;\n\n// Thanks to http://www.thetenthplanet.de/archives/1180\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\n{\n	// get edge vectors of the pixel triangle\n	vec3 dp1 = dFdx(p);\n	vec3 dp2 = dFdy(p);\n	vec2 duv1 = dFdx(uv);\n	vec2 duv2 = dFdy(uv);\n\n	// solve the linear system\n	vec3 dp2perp = cross(dp2, normal);\n	vec3 dp1perp = cross(normal, dp1);\n	vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n	vec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\n\n	// construct a scale-invariant frame \n	float invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\n	return mat3(tangent * invmax, binormal * invmax, normal);\n}\n\nvec3 perturbNormal(vec3 viewDir)\n{\n	vec3 map = texture2D(bumpSampler, vBumpUV).xyz * vBumpInfos.y;\n	map = map * 255. / 127. - 128. / 127.;\n	mat3 TBN = cotangent_frame(vNormalW, -viewDir, vBumpUV);\n	return normalize(TBN * map);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nstruct lightingInfo\n{\n	vec3 diffuse;\n	vec3 specular;\n};\n\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 lightVectorW;\n	float attenuation = 1.0;\n	if (lightData.w == 0.)\n	{\n		vec3 direction = lightData.xyz - vPositionW;\n\n		attenuation = max(0., 1.0 - length(direction) / range);\n		lightVectorW = normalize(direction);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, max(1., vSpecularColor.a));\n\n	result.diffuse = ndl * diffuseColor * attenuation;\n	result.specular = specComp * specularColor * attenuation;\n\n	return result;\n}\n\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 direction = lightData.xyz - vPositionW;\n	vec3 lightVectorW = normalize(direction);\n	float attenuation = max(0., 1.0 - length(direction) / range);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result.diffuse = ndl * spotAtten * diffuseColor * attenuation;\n		result.specular = specComp * specularColor * spotAtten * attenuation;\n\n		return result;\n	}\n\n	result.diffuse = vec3(0.);\n	result.specular = vec3(0.);\n\n	return result;\n}\n\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	lightingInfo result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result.diffuse = mix(groundColor, diffuseColor, ndl);\n	result.specular = specComp * specularColor;\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n#ifdef ALPHAFROMDIFFUSE\n	alpha *= baseColor.a;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = normalize(vNormalW);\n\n#ifdef BUMP\n	normalW = perturbNormal(viewDirectionW);\n#endif\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef HEMILIGHT0\n	lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	#ifdef SHADOWPCF0\n		shadow = computeShadowWithPCF(vPositionFromLight0, shadowSampler0);\n	#else\n		shadow = computeShadow(vPositionFromLight0, shadowSampler0, darkness0);\n	#endif\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	#ifdef SHADOWPCF1\n		shadow = computeShadowWithPCF(vPositionFromLight1, shadowSampler1);\n	#else\n		shadow = computeShadow(vPositionFromLight1, shadowSampler1, darkness1);\n	#endif\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	#ifdef SHADOWPCF2\n		shadow = computeShadowWithPCF(vPositionFromLight2, shadowSampler2);\n	#else\n		shadow = computeShadow(vPositionFromLight2, shadowSampler2, darkness2);\n	#endif	\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	#ifdef SHADOWPCF3\n		shadow = computeShadowWithPCF(vPositionFromLight3, shadowSampler3);\n	#else\n		shadow = computeShadow(vPositionFromLight3, shadowSampler3, darkness3);\n	#endif	\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	vec3 vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), normalW);\n\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y * shadow;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y * shadow;\n	}\n#endif\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n\n#ifdef OPACITYRGB\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n	alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n\n\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}",defaultVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\n\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif\n\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef REFLECTION\n	vPositionUVW = position;\n#endif \n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n#ifdef INSTANCES\n	finalWorld = mat4(world0, world1, world2, world3);\n#else\n	finalWorld = world;\n#endif\n#endif\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * worldPos;\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * worldPos;\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * worldPos;\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * worldPos;\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}",displayPassPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(passSampler, vUV);\n}",filterPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform mat4 kernelMatrix;\n\nvoid main(void)\n{\n	vec3 baseColor = texture2D(textureSampler, vUV).rgb;\n	vec3 updatedColor = (kernelMatrix * vec4(baseColor, 1.0)).rgb;\n\n	gl_FragColor = vec4(updatedColor, 1.0);\n}",fxaaPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 texelSize;\n\nvoid main(){\n	vec2 localTexelSize = texelSize;\n	vec4 rgbNW = texture2D(textureSampler, (vUV + vec2(-1.0, -1.0) * localTexelSize));\n	vec4 rgbNE = texture2D(textureSampler, (vUV + vec2(1.0, -1.0) * localTexelSize));\n	vec4 rgbSW = texture2D(textureSampler, (vUV + vec2(-1.0, 1.0) * localTexelSize));\n	vec4 rgbSE = texture2D(textureSampler, (vUV + vec2(1.0, 1.0) * localTexelSize));\n	vec4 rgbM = texture2D(textureSampler, vUV);\n	vec4 luma = vec4(0.299, 0.587, 0.114, 1.0);\n	float lumaNW = dot(rgbNW, luma);\n	float lumaNE = dot(rgbNE, luma);\n	float lumaSW = dot(rgbSW, luma);\n	float lumaSE = dot(rgbSE, luma);\n	float lumaM = dot(rgbM, luma);\n	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n	vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n	float dirReduce = max(\n		(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n		FXAA_REDUCE_MIN);\n\n	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n		dir * rcpDirMin)) * localTexelSize;\n\n	vec4 rgbA = 0.5 * (\n		texture2D(textureSampler, vUV + dir * (1.0 / 3.0 - 0.5)) +\n		texture2D(textureSampler, vUV + dir * (2.0 / 3.0 - 0.5)));\n\n	vec4 rgbB = rgbA * 0.5 + 0.25 * (\n		texture2D(textureSampler, vUV + dir *  -0.5) +\n		texture2D(textureSampler, vUV + dir * 0.5));\n	float lumaB = dot(rgbB, luma);\n	if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\n		gl_FragColor = rgbA;\n	}\n	else {\n		gl_FragColor = rgbB;\n	}\n}",layerPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}",layerVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 textureMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = vec2(textureMatrix * vec4(position * madd + madd, 1.0, 0.0));\n	gl_Position = vec4(position, 0.0, 1.0);\n}",legacydefaultPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_PROJECTION	4.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vReflectionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return 0.;\n	}\n	return 1.;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nmat3 computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW;\n	if (lightData.w == 0.)\n	{\n		lightVectorW = normalize(lightData.xyz - vPositionW);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = max(0., pow(specComp, max(1.0, vSpecularColor.a)));\n\n	result[0] = ndl * diffuseColor.rgb;\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW = normalize(lightData.xyz - vPositionW);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result[0] = ndl * spotAtten * diffuseColor.rgb;\n		result[1] = specComp * specularColor * spotAtten;\n		result[2] = vec3(0.);\n\n		return result;\n	}\n\n	result[0] = vec3(0.);\n	result[1] = vec3(0.);\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	mat3 result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result[0] = mix(groundColor, diffuseColor.rgb, ndl);\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = normalize(vNormalW);\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	mat3 info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef HEMILIGHT0\n	mat3 info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	mat3 info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	shadow = computeShadow(vPositionFromLight0, shadowSampler0);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	shadow = computeShadow(vPositionFromLight1, shadowSampler1);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	shadow = computeShadow(vPositionFromLight2, shadowSampler2);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	shadow = computeShadow(vPositionFromLight3, shadowSampler3);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y;\n	}\n#endif\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n#ifdef OPACITYRGB\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n	alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}",legacydefaultVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nuniform vec3 vEyePosition;\nvarying vec3 vReflectionUVW;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return position;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n	finalWorld = world;\n#endif\n\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef REFLECTION\n	vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), vNormalW);\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * worldPos;\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * worldPos;\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * worldPos;\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * worldPos;\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}",lensFlarePixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}",lensFlareVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 viewportMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = viewportMatrix * vec4(position, 0.0, 1.0);\n}",oculusDistortionCorrectionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\n\nvec2 HmdWarp(vec2 in01) {\n\n	vec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\n	float rSq = theta.x * theta.x + theta.y * theta.y;\n	vec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n	return LensCenter + Scale * rvector;\n}\n\n\n\nvoid main(void)\n{\n	vec2 tc = HmdWarp(vUV);\n	if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	else{\n		gl_FragColor = vec4(texture2D(textureSampler, tc).rgb, 1.0);\n	}\n}",particlesPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	gl_FragColor = (baseColor * textureMask + (vec4(1., 1., 1., 1.) - textureMask)) * vColor;\n}",particlesVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 color;\nattribute vec4 options;\n\n// Uniforms\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nuniform mat4 invView;\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	float size = options.y;\n	float angle = options.x;\n	vec2 offset = options.zw;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n	\n	vColor = color;\n	vUV = offset;\n\n	// Clip plane\n#ifdef CLIPPLANE\n	vec4 worldPos = invView * vec4(viewPos, 1.0);\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n}",passPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	gl_FragColor = texture2D(textureSampler, vUV);\n}",postprocessVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = vec4(position, 0.0, 1.0);\n}",refractionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\n// Parameters\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\n\nvoid main() {\n	float ref = 1.0 - texture2D(refractionSampler, vUV).r;\n\n	vec2 uv = vUV - vec2(0.5);\n	vec2 offset = uv * depth * ref;\n	vec3 sourceColor = texture2D(textureSampler, vUV - offset).rgb;\n\n	gl_FragColor = vec4(sourceColor + sourceColor * ref * colorLevel, 1.0);\n}",shadowMapPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 pack(float depth)\n{\n	const vec4 bitOffset = vec4(255. * 255. * 255., 255. * 255., 255., 1.);\n	const vec4 bitMask = vec4(0., 1. / 255., 1. / 255., 1. / 255.);\n	\n	vec4 comp = mod(depth * bitOffset * vec4(254.), vec4(255.)) / vec4(254.);\n	comp -= comp.xxyz * bitMask;\n	\n	return comp;\n}\n\n// Thanks to http://devmaster.net/\nvec2 packHalf(float depth) \n{ \n	const vec2 bitOffset = vec2(1.0 / 255., 0.);\n	vec2 color = vec2(depth, fract(depth * 255.));\n\n	return color - (color.yy * bitOffset);\n}\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n\nvoid main(void)\n{\n#ifdef ALPHATEST\n	if (texture2D(diffuseSampler, vUV).a < 0.4)\n		discard;\n#endif\n\n#ifdef VSM\n	float moment1 = gl_FragCoord.z / gl_FragCoord.w;\n	float moment2 = moment1 * moment1;\n	gl_FragColor = vec4(packHalf(moment1), packHalf(moment2));\n#else\n	gl_FragColor = pack(vPosition.z / vPosition.w);\n#endif\n}",shadowMapVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attribute\nattribute vec3 position;\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniform\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif\n\nuniform mat4 viewProjection;\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n\nvoid main(void)\n{\n#ifdef INSTANCES\n	mat4 finalWorld = mat4(world0, world1, world2, world3);\n#else\n	mat4 finalWorld = world;\n#endif\n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = finalWorld * (m0 + m1 + m2 + m3);\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n#else\n#ifndef VSM\n	vPosition = viewProjection * finalWorld * vec4(position, 1.0);\n#endif\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n#endif\n\n#ifdef ALPHATEST\n#ifdef UV1\n	vUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n#endif\n#ifdef UV2\n	vUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n#endif\n#endif\n}",spritesPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform bool alphaTest;\n\nvarying vec4 vColor;\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return min(1., max(0., fogCoeff));\n}\n#endif\n\n\nvoid main(void) {\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	if (alphaTest) \n	{\n		if (baseColor.a < 0.95)\n			discard;\n	}\n\n	baseColor *= vColor;\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	baseColor.rgb = fog * baseColor.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = baseColor;\n}",spritesVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 options;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\n// Uniforms\nuniform vec2 textureInfos;\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	\n	float angle = options.x;\n	float size = options.y;\n	vec2 offset = options.zw;\n	vec2 uvScale = textureInfos.xy;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n\n	// Color\n	vColor = color;\n	\n	// Texture\n	vec2 uvOffset = vec2(abs(offset.x - cellInfo.x), 1.0 - abs(offset.y - cellInfo.y));\n\n	vUV = (uvOffset + cellInfo.zw) * uvScale;\n\n	// Fog\n#ifdef FOG\n	fFogDistance = viewPos.z;\n#endif\n}"},b
}();a.Effect=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c){this.name=a,this.checkReadyOnEveryCall=!0,this.checkReadyOnlyOnce=!1,this.state="",this.alpha=1,this.wireframe=!1,this.backFaceCulling=!0,this._wasPreviouslyReady=!1,this.id=a,this._scene=b,c||b.materials.push(this)}return a.prototype.isReady=function(){return!0},a.prototype.getEffect=function(){return this._effect},a.prototype.getScene=function(){return this._scene},a.prototype.needAlphaBlending=function(){return this.alpha<1},a.prototype.needAlphaTesting=function(){return!1},a.prototype.getAlphaTestTexture=function(){return null},a.prototype.trackCreation=function(){},a.prototype._preBind=function(){var a=this._scene.getEngine();a.enableEffect(this._effect),a.setState(this.backFaceCulling)},a.prototype.bind=function(){},a.prototype.bindOnlyWorldMatrix=function(){},a.prototype.unbind=function(){},a.prototype.dispose=function(a){var b=this._scene.materials.indexOf(this);this._scene.materials.splice(b,1),a&&this._effect&&(this._scene.getEngine()._releaseEffect(this._effect),this._effect=null),this.onDispose&&this.onDispose()},a}();a.Material=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=4,c=function(c){function d(b,d){var e=this;c.call(this,b,d),this.ambientColor=new a.Color3(0,0,0),this.diffuseColor=new a.Color3(1,1,1),this.specularColor=new a.Color3(1,1,1),this.specularPower=64,this.emissiveColor=new a.Color3(0,0,0),this.useAlphaFromDiffuseTexture=!1,this._cachedDefines=null,this._renderTargets=new a.SmartArray(16),this._worldViewProjectionMatrix=a.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._baseColor=new a.Color3,this._scaledDiffuse=new a.Color3,this._scaledSpecular=new a.Color3,this.getRenderTargetTextures=function(){return e._renderTargets.reset(),e.reflectionTexture&&e.reflectionTexture.isRenderTarget&&e._renderTargets.push(e.reflectionTexture),e._renderTargets}}return __extends(d,c),d.prototype.needAlphaBlending=function(){return this.alpha<1||null!=this.opacityTexture||this._shouldUseAlphaFromDiffuseTexture()},d.prototype.needAlphaTesting=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha&&!this.diffuseTexture.getAlphaFromRGB},d.prototype._shouldUseAlphaFromDiffuseTexture=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha&&this.useAlphaFromDiffuseTexture},d.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},d.prototype.isReady=function(c,d){if(this.checkReadyOnlyOnce&&this._wasPreviouslyReady)return!0;var e=this.getScene();if(!this.checkReadyOnEveryCall&&this._renderId===e.getRenderId())return!0;var f=e.getEngine(),g=[],h=new Array;if(e.texturesEnabled){if(this.diffuseTexture&&a.StandardMaterial.DiffuseTextureEnabled){if(!this.diffuseTexture.isReady())return!1;g.push("#define DIFFUSE")}if(this.ambientTexture&&a.StandardMaterial.AmbientTextureEnabled){if(!this.ambientTexture.isReady())return!1;g.push("#define AMBIENT")}if(this.opacityTexture&&a.StandardMaterial.OpacityTextureEnabled){if(!this.opacityTexture.isReady())return!1;g.push("#define OPACITY"),this.opacityTexture.getAlphaFromRGB&&g.push("#define OPACITYRGB")}if(this.reflectionTexture&&a.StandardMaterial.ReflectionTextureEnabled){if(!this.reflectionTexture.isReady())return!1;g.push("#define REFLECTION")}if(this.emissiveTexture&&a.StandardMaterial.EmissiveTextureEnabled){if(!this.emissiveTexture.isReady())return!1;g.push("#define EMISSIVE")}if(this.specularTexture&&a.StandardMaterial.SpecularTextureEnabled){if(!this.specularTexture.isReady())return!1;g.push("#define SPECULAR"),h.push(g[g.length-1])}}if(e.getEngine().getCaps().standardDerivatives&&this.bumpTexture&&a.StandardMaterial.BumpTextureEnabled){if(!this.bumpTexture.isReady())return!1;g.push("#define BUMP"),h.push(g[g.length-1])}e.clipPlane&&g.push("#define CLIPPLANE"),f.getAlphaTesting()&&g.push("#define ALPHATEST"),this._shouldUseAlphaFromDiffuseTexture()&&g.push("#define ALPHAFROMDIFFUSE"),e.fogMode!==a.Scene.FOGMODE_NONE&&(g.push("#define FOG"),h.push(g[g.length-1]));var i=!1,j=0;if(e.lightsEnabled)for(var k=0;k<e.lights.length;k++){var l=e.lights[k];if(l.isEnabled()){if(l._excludedMeshesIds.length>0){for(var m=0;m<l._excludedMeshesIds.length;m++){var n=e.getMeshByID(l._excludedMeshesIds[m]);n&&l.excludedMeshes.push(n)}l._excludedMeshesIds=[]}if(!c||-1===l.excludedMeshes.indexOf(c)){g.push("#define LIGHT"+j),j>0&&h.push(g[g.length-1]);var o;o=l instanceof a.SpotLight?"#define SPOTLIGHT"+j:l instanceof a.HemisphericLight?"#define HEMILIGHT"+j:"#define POINTDIRLIGHT"+j,g.push(o),j>0&&h.push(g[g.length-1]);var p=l.getShadowGenerator();if(c&&c.receiveShadows&&p&&(g.push("#define SHADOW"+j),j>0&&h.push(g[g.length-1]),i||(g.push("#define SHADOWS"),i=!0),p.useVarianceShadowMap&&(g.push("#define SHADOWVSM"+j),j>0&&h.push(g[g.length-1])),p.usePoissonSampling&&(g.push("#define SHADOWPCF"+j),j>0&&h.push(g[g.length-1]))),j++,j==b)break}}}var q=[a.VertexBuffer.PositionKind,a.VertexBuffer.NormalKind];c&&(c.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(q.push(a.VertexBuffer.UVKind),g.push("#define UV1")),c.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(q.push(a.VertexBuffer.UV2Kind),g.push("#define UV2")),c.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(q.push(a.VertexBuffer.ColorKind),g.push("#define VERTEXCOLOR")),c.skeleton&&c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(q.push(a.VertexBuffer.MatricesIndicesKind),q.push(a.VertexBuffer.MatricesWeightsKind),g.push("#define BONES"),g.push("#define BonesPerMesh "+(c.skeleton.bones.length+1)),g.push("#define BONES4"),h.push(g[g.length-1])),d&&(g.push("#define INSTANCES"),q.push("world0"),q.push("world1"),q.push("world2"),q.push("world3")));var r=g.join("\n");if(this._cachedDefines!=r){this._cachedDefines=r;var s="default";e.getEngine().getCaps().standardDerivatives||(s="legacydefault"),this._effect=e.getEngine().createEffect(s,q,["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","vLightData0","vLightDiffuse0","vLightSpecular0","vLightDirection0","vLightGround0","lightMatrix0","vLightData1","vLightDiffuse1","vLightSpecular1","vLightDirection1","vLightGround1","lightMatrix1","vLightData2","vLightDiffuse2","vLightSpecular2","vLightDirection2","vLightGround2","lightMatrix2","vLightData3","vLightDiffuse3","vLightSpecular3","vLightDirection3","vLightGround3","lightMatrix3","vFogInfos","vFogColor","vDiffuseInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","mBones","vClipPlane","diffuseMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","specularMatrix","bumpMatrix","darkness0","darkness1","darkness2","darkness3"],["diffuseSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","specularSampler","bumpSampler","shadowSampler0","shadowSampler1","shadowSampler2","shadowSampler3"],r,h,this.onCompiled,this.onError)}return this._effect.isReady()?(this._renderId=e.getRenderId(),this._wasPreviouslyReady=!0,!0):!1},d.prototype.unbind=function(){this.reflectionTexture&&this.reflectionTexture.isRenderTarget&&this._effect.setTexture("reflection2DSampler",null)},d.prototype.bindOnlyWorldMatrix=function(a){this._effect.setMatrix("world",a)},d.prototype.bind=function(c,d){var e=this.getScene();if(this._baseColor.copyFrom(this.diffuseColor),this.bindOnlyWorldMatrix(c),this._effect.setMatrix("viewProjection",e.getTransformMatrix()),d.skeleton&&d.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&d.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&this._effect.setMatrices("mBones",d.skeleton.getTransformMatrices()),this.diffuseTexture&&a.StandardMaterial.DiffuseTextureEnabled&&(this._effect.setTexture("diffuseSampler",this.diffuseTexture),this._effect.setFloat2("vDiffuseInfos",this.diffuseTexture.coordinatesIndex,this.diffuseTexture.level),this._effect.setMatrix("diffuseMatrix",this.diffuseTexture.getTextureMatrix()),this._baseColor.copyFromFloats(1,1,1)),this.ambientTexture&&a.StandardMaterial.AmbientTextureEnabled&&(this._effect.setTexture("ambientSampler",this.ambientTexture),this._effect.setFloat2("vAmbientInfos",this.ambientTexture.coordinatesIndex,this.ambientTexture.level),this._effect.setMatrix("ambientMatrix",this.ambientTexture.getTextureMatrix())),this.opacityTexture&&a.StandardMaterial.OpacityTextureEnabled&&(this._effect.setTexture("opacitySampler",this.opacityTexture),this._effect.setFloat2("vOpacityInfos",this.opacityTexture.coordinatesIndex,this.opacityTexture.level),this._effect.setMatrix("opacityMatrix",this.opacityTexture.getTextureMatrix())),this.reflectionTexture&&a.StandardMaterial.ReflectionTextureEnabled&&(this.reflectionTexture.isCube?this._effect.setTexture("reflectionCubeSampler",this.reflectionTexture):this._effect.setTexture("reflection2DSampler",this.reflectionTexture),this._effect.setMatrix("reflectionMatrix",this.reflectionTexture.getReflectionTextureMatrix()),this._effect.setFloat3("vReflectionInfos",this.reflectionTexture.coordinatesMode,this.reflectionTexture.level,this.reflectionTexture.isCube?1:0)),this.emissiveTexture&&a.StandardMaterial.EmissiveTextureEnabled&&(this._effect.setTexture("emissiveSampler",this.emissiveTexture),this._effect.setFloat2("vEmissiveInfos",this.emissiveTexture.coordinatesIndex,this.emissiveTexture.level),this._effect.setMatrix("emissiveMatrix",this.emissiveTexture.getTextureMatrix())),this.specularTexture&&a.StandardMaterial.SpecularTextureEnabled&&(this._effect.setTexture("specularSampler",this.specularTexture),this._effect.setFloat2("vSpecularInfos",this.specularTexture.coordinatesIndex,this.specularTexture.level),this._effect.setMatrix("specularMatrix",this.specularTexture.getTextureMatrix())),this.bumpTexture&&e.getEngine().getCaps().standardDerivatives&&a.StandardMaterial.BumpTextureEnabled&&(this._effect.setTexture("bumpSampler",this.bumpTexture),this._effect.setFloat2("vBumpInfos",this.bumpTexture.coordinatesIndex,this.bumpTexture.level),this._effect.setMatrix("bumpMatrix",this.bumpTexture.getTextureMatrix())),e.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),this._effect.setVector3("vEyePosition",e.activeCamera.position),this._effect.setColor3("vAmbientColor",this._globalAmbientColor),this._effect.setColor4("vDiffuseColor",this._baseColor,this.alpha*d.visibility),this._effect.setColor4("vSpecularColor",this.specularColor,this.specularPower),this._effect.setColor3("vEmissiveColor",this.emissiveColor),e.lightsEnabled)for(var f=0,g=0;g<e.lights.length;g++){var h=e.lights[g];if(h.isEnabled()&&(!d||-1===h.excludedMeshes.indexOf(d))){h instanceof a.PointLight?h.transferToEffect(this._effect,"vLightData"+f):h instanceof a.DirectionalLight?h.transferToEffect(this._effect,"vLightData"+f):h instanceof a.SpotLight?h.transferToEffect(this._effect,"vLightData"+f,"vLightDirection"+f):h instanceof a.HemisphericLight&&h.transferToEffect(this._effect,"vLightData"+f,"vLightGround"+f),h.diffuse.scaleToRef(h.intensity,this._scaledDiffuse),h.specular.scaleToRef(h.intensity,this._scaledSpecular),this._effect.setColor4("vLightDiffuse"+f,this._scaledDiffuse,h.range),this._effect.setColor3("vLightSpecular"+f,this._scaledSpecular);var i=h.getShadowGenerator();if(d.receiveShadows&&i&&(this._effect.setMatrix("lightMatrix"+f,i.getTransformMatrix()),this._effect.setTexture("shadowSampler"+f,i.getShadowMap()),this._effect.setFloat("darkness"+f,i.getDarkness())),f++,f==b)break}}if(e.clipPlane){var j=e.clipPlane;this._effect.setFloat4("vClipPlane",j.normal.x,j.normal.y,j.normal.z,j.d)}(e.fogMode!==a.Scene.FOGMODE_NONE||this.reflectionTexture)&&this._effect.setMatrix("view",e.getViewMatrix()),e.fogMode!==a.Scene.FOGMODE_NONE&&(this._effect.setFloat4("vFogInfos",e.fogMode,e.fogStart,e.fogEnd,e.fogDensity),this._effect.setColor3("vFogColor",e.fogColor))},d.prototype.getAnimatables=function(){var a=[];return this.diffuseTexture&&this.diffuseTexture.animations&&this.diffuseTexture.animations.length>0&&a.push(this.diffuseTexture),this.ambientTexture&&this.ambientTexture.animations&&this.ambientTexture.animations.length>0&&a.push(this.ambientTexture),this.opacityTexture&&this.opacityTexture.animations&&this.opacityTexture.animations.length>0&&a.push(this.opacityTexture),this.reflectionTexture&&this.reflectionTexture.animations&&this.reflectionTexture.animations.length>0&&a.push(this.reflectionTexture),this.emissiveTexture&&this.emissiveTexture.animations&&this.emissiveTexture.animations.length>0&&a.push(this.emissiveTexture),this.specularTexture&&this.specularTexture.animations&&this.specularTexture.animations.length>0&&a.push(this.specularTexture),this.bumpTexture&&this.bumpTexture.animations&&this.bumpTexture.animations.length>0&&a.push(this.bumpTexture),a},d.prototype.dispose=function(a){this.diffuseTexture&&this.diffuseTexture.dispose(),this.ambientTexture&&this.ambientTexture.dispose(),this.opacityTexture&&this.opacityTexture.dispose(),this.reflectionTexture&&this.reflectionTexture.dispose(),this.emissiveTexture&&this.emissiveTexture.dispose(),this.specularTexture&&this.specularTexture.dispose(),this.bumpTexture&&this.bumpTexture.dispose(),c.prototype.dispose.call(this,a)},d.prototype.clone=function(b){var c=new a.StandardMaterial(b,this.getScene());return c.checkReadyOnEveryCall=this.checkReadyOnEveryCall,c.alpha=this.alpha,c.wireframe=this.wireframe,c.backFaceCulling=this.backFaceCulling,this.diffuseTexture&&this.diffuseTexture.clone&&(c.diffuseTexture=this.diffuseTexture.clone()),this.ambientTexture&&this.ambientTexture.clone&&(c.ambientTexture=this.ambientTexture.clone()),this.opacityTexture&&this.opacityTexture.clone&&(c.opacityTexture=this.opacityTexture.clone()),this.reflectionTexture&&this.reflectionTexture.clone&&(c.reflectionTexture=this.reflectionTexture.clone()),this.emissiveTexture&&this.emissiveTexture.clone&&(c.emissiveTexture=this.emissiveTexture.clone()),this.specularTexture&&this.specularTexture.clone&&(c.specularTexture=this.specularTexture.clone()),this.bumpTexture&&this.bumpTexture.clone&&(c.bumpTexture=this.bumpTexture.clone()),c.ambientColor=this.ambientColor.clone(),c.diffuseColor=this.diffuseColor.clone(),c.specularColor=this.specularColor.clone(),c.specularPower=this.specularPower,c.emissiveColor=this.emissiveColor.clone(),c},d.DiffuseTextureEnabled=!0,d.AmbientTextureEnabled=!0,d.OpacityTextureEnabled=!0,d.ReflectionTextureEnabled=!0,d.EmissiveTextureEnabled=!0,d.SpecularTextureEnabled=!0,d.BumpTextureEnabled=!0,d}(a.Material);a.StandardMaterial=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c){a.call(this,b,c,!0),this.subMaterials=new Array,c.multiMaterials.push(this)}return __extends(b,a),b.prototype.getSubMaterial=function(a){return 0>a||a>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[a]},b.prototype.isReady=function(a){for(var b=0;b<this.subMaterials.length;b++){var c=this.subMaterials[b];if(c&&!this.subMaterials[b].isReady(a))return!1}return!0},b}(a.Material);a.MultiMaterial=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.idbFactory=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,this.callbackManifestChecked=c,this.currentSceneUrl=a.Database.ReturnFullUrlLocation(b),this.db=null,this.enableSceneOffline=!1,this.enableTexturesOffline=!1,this.manifestVersionFound=0,this.mustUpdateRessources=!1,this.hasReachedQuota=!1,this.checkManifestFile()}return b.prototype.checkManifestFile=function(){function b(){a.Tools.Log("Valid manifest file not found. Scene & textures will be loaded directly from the web server."),d.enableSceneOffline=!1,d.enableTexturesOffline=!1,d.callbackManifestChecked(!1)}var c=this,d=this,e=this.currentSceneUrl+".manifest",f=new XMLHttpRequest,g=e+(null==e.match(/\?/)?"?":"&")+(new Date).getTime();f.open("GET",g,!0),f.addEventListener("load",function(){if(200===f.status||a.Tools.ValidateXHRData(f,1))try{var d=JSON.parse(f.response);c.enableSceneOffline=d.enableSceneOffline,c.enableTexturesOffline=d.enableTexturesOffline,d.version&&!isNaN(parseInt(d.version))&&(c.manifestVersionFound=d.version),c.callbackManifestChecked&&c.callbackManifestChecked(!0)}catch(e){b()}else b()},!1),f.addEventListener("error",function(){b()},!1);try{f.send()}catch(h){a.Tools.Error("Error on XHR send request."),d.callbackManifestChecked(!1)}},b.prototype.openAsync=function(b,c){function d(){f.isSupported=!1,c&&c()}var e=this,f=this;if(this.idbFactory&&(this.enableSceneOffline||this.enableTexturesOffline))if(this.db)b&&b();else{this.hasReachedQuota=!1,this.isSupported=!0;var g=this.idbFactory.open("babylonjs",1);g.onerror=function(){d()},g.onblocked=function(){a.Tools.Error("IDB request blocked. Please reload the page."),d()},g.onsuccess=function(){e.db=g.result,b()},g.onupgradeneeded=function(b){e.db=b.target.result;try{b.oldVersion>0&&(e.db.deleteObjectStore("scenes"),e.db.deleteObjectStore("versions"),e.db.deleteObjectStore("textures"));{e.db.createObjectStore("scenes",{keyPath:"sceneUrl"}),e.db.createObjectStore("versions",{keyPath:"sceneUrl"}),e.db.createObjectStore("textures",{keyPath:"textureUrl"})}}catch(c){a.Tools.Error("Error while creating object stores. Exception: "+c.message),d()}}}else this.isSupported=!1,c&&c()},b.prototype.loadImageFromDB=function(b,c){var d=this,e=a.Database.ReturnFullUrlLocation(b),f=function(){d.hasReachedQuota||null===d.db?c.src=b:d._saveImageIntoDBAsync(e,c)};this.mustUpdateRessources?f():this._loadImageFromDBAsync(e,c,f)},b.prototype._loadImageFromDBAsync=function(b,c,d){if(this.isSupported&&null!==this.db){var e,f=this.db.transaction(["textures"]);f.onabort=function(){c.src=b},f.oncomplete=function(){var f;if(e){var g=window.URL||window.webkitURL;f=g.createObjectURL(e.data,{oneTimeOnly:!0}),c.onerror=function(){a.Tools.Error("Error loading image from blob URL: "+f+" switching back to web url: "+b),c.src=b},c.src=f}else d()};var g=f.objectStore("textures").get(b);g.onsuccess=function(a){e=a.target.result},g.onerror=function(){a.Tools.Error("Error loading texture "+b+" from DB."),c.src=b}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c.src=b},b.prototype._saveImageIntoDBAsync=function(b,c){var d=this;if(this.isSupported){var e=function(){var a;if(f){var b=window.URL||window.webkitURL;try{a=b.createObjectURL(f,{oneTimeOnly:!0})}catch(d){a=b.createObjectURL(f)}}c.src=a};if(a.Database.isUASupportingBlobStorage){var f,g=new XMLHttpRequest;g.open("GET",b,!0),g.responseType="blob",g.addEventListener("load",function(){if(200===g.status){f=g.response;var h=d.db.transaction(["textures"],"readwrite");h.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(this.hasReachedQuota=!0)}catch(b){}e()},h.oncomplete=function(){e()};var i={textureUrl:b,data:f};try{var j=h.objectStore("textures").put(i);j.onsuccess=function(){},j.onerror=function(){e()}}catch(k){25===k.code&&(a.Database.isUASupportingBlobStorage=!1),c.src=b}}else c.src=b},!1),g.addEventListener("error",function(){a.Tools.Error("Error in XHR request in BABYLON.Database."),c.src=b},!1),g.send()}else c.src=b}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c.src=b},b.prototype._checkVersionFromDB=function(a,b){var c=this,d=function(){c._saveVersionIntoDBAsync(a,b)};this._loadVersionFromDBAsync(a,b,d)},b.prototype._loadVersionFromDBAsync=function(b,c,d){var e=this;if(this.isSupported){var f;try{var g=this.db.transaction(["versions"]);g.oncomplete=function(){f?e.manifestVersionFound>f.data?(e.mustUpdateRessources=!0,d()):c(f.data):(e.mustUpdateRessources=!0,d())},g.onabort=function(){c(-1)};var h=g.objectStore("versions").get(b);h.onsuccess=function(a){f=a.target.result},h.onerror=function(){a.Tools.Error("Error loading version for scene "+b+" from DB."),c(-1)}}catch(i){a.Tools.Error("Error while accessing 'versions' object store (READ OP). Exception: "+i.message),c(-1)}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c(-1)},b.prototype._saveVersionIntoDBAsync=function(b,c){var d=this;if(this.isSupported&&!this.hasReachedQuota)try{var e=this.db.transaction(["versions"],"readwrite");e.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(d.hasReachedQuota=!0)}catch(b){}c(-1)},e.oncomplete=function(){c(d.manifestVersionFound)};var f={sceneUrl:b,data:this.manifestVersionFound},g=e.objectStore("versions").put(f);g.onsuccess=function(){},g.onerror=function(){a.Tools.Error("Error in DB add version request in BABYLON.Database.")}}catch(h){a.Tools.Error("Error while accessing 'versions' object store (WRITE OP). Exception: "+h.message),c(-1)}else c(-1)},b.prototype.loadFileFromDB=function(b,c,d,e,f){var g=this,h=a.Database.ReturnFullUrlLocation(b),i=function(){g._saveFileIntoDBAsync(h,c,d)};this._checkVersionFromDB(h,function(a){-1!==a?g.mustUpdateRessources?g._saveFileIntoDBAsync(h,c,d,f):g._loadFileFromDBAsync(h,c,i,f):e()})},b.prototype._loadFileFromDBAsync=function(b,c,d){if(this.isSupported){var e;e=-1!==b.indexOf(".babylon")?"scenes":"textures";var f,g=this.db.transaction([e]);g.oncomplete=function(){f?c(f.data):d()},g.onabort=function(){d()};var h=g.objectStore(e).get(b);h.onsuccess=function(a){f=a.target.result},h.onerror=function(){a.Tools.Error("Error loading file "+b+" from DB."),d()}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c()},b.prototype._saveFileIntoDBAsync=function(b,c,d,e){var f=this;if(this.isSupported){var g;g=-1!==b.indexOf(".babylon")?"scenes":"textures";var h,i=new XMLHttpRequest;i.open("GET",b,!0),e&&(i.responseType="arraybuffer"),i.onprogress=d,i.addEventListener("load",function(){if(200===i.status||a.Tools.ValidateXHRData(i,e?6:1))if(h=e?i.response:i.responseText,f.hasReachedQuota)c(h);else{var d=f.db.transaction([g],"readwrite");d.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(this.hasReachedQuota=!0)}catch(b){}c(h)},d.oncomplete=function(){c(h)};var j;j="scenes"===g?{sceneUrl:b,data:h,version:f.manifestVersionFound}:{textureUrl:b,data:h};try{var k=d.objectStore(g).put(j);k.onsuccess=function(){},k.onerror=function(){a.Tools.Error("Error in DB add file request in BABYLON.Database.")}}catch(l){c(h)}}else c()},!1),i.addEventListener("error",function(){a.Tools.Error("error on XHR request."),c()},!1),i.send()}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c()},b.isUASupportingBlobStorage=!0,b.parseURL=function(a){var b=document.createElement("a");b.href=a;var c=a.substring(a.lastIndexOf("/")+1,a.length),d=a.substring(0,a.indexOf(c,0));return d},b.ReturnFullUrlLocation=function(b){return-1===b.indexOf("http:/")?a.Database.parseURL(window.location.href)+b:b},b}();a.Database=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g){this.name=b,this.cellSize=e,this.sprites=new Array,this.renderingGroupId=0,this._vertexDeclaration=[3,4,4,4],this._vertexStrideSize=60,this._capacity=d,this._spriteTexture=new a.Texture(c,f,!0,!1),this._spriteTexture.wrapU=a.Texture.CLAMP_ADDRESSMODE,this._spriteTexture.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._epsilon=void 0===g?.01:g,this._scene=f,this._scene.spriteManagers.push(this),this._vertexDeclaration=[3,4,4,4],this._vertexStrideSize=60,this._vertexBuffer=f.getEngine().createDynamicVertexBuffer(d*this._vertexStrideSize*4);for(var h=[],i=0,j=0;d>j;j++)h.push(i),h.push(i+1),h.push(i+2),h.push(i),h.push(i+2),h.push(i+3),i+=4;this._indexBuffer=f.getEngine().createIndexBuffer(h),this._vertices=new Float32Array(d*this._vertexStrideSize),this._effectBase=this._scene.getEngine().createEffect("sprites",["position","options","cellInfo","color"],["view","projection","textureInfos","alphaTest"],["diffuseSampler"],""),this._effectFog=this._scene.getEngine().createEffect("sprites",["position","options","cellInfo","color"],["view","projection","textureInfos","alphaTest","vFogInfos","vFogColor"],["diffuseSampler"],"#define FOG")}return b.prototype._appendSpriteVertex=function(a,b,c,d,e){var f=15*a;0==c?c=this._epsilon:1==c&&(c=1-this._epsilon),0==d?d=this._epsilon:1==d&&(d=1-this._epsilon),this._vertices[f]=b.position.x,this._vertices[f+1]=b.position.y,this._vertices[f+2]=b.position.z,this._vertices[f+3]=b.angle,this._vertices[f+4]=b.size,this._vertices[f+5]=c,this._vertices[f+6]=d,this._vertices[f+7]=b.invertU?1:0,this._vertices[f+8]=b.invertV?1:0;var g=b.cellIndex/e>>0;this._vertices[f+9]=b.cellIndex-g*e,this._vertices[f+10]=g,this._vertices[f+11]=b.color.r,this._vertices[f+12]=b.color.g,this._vertices[f+13]=b.color.b,this._vertices[f+14]=b.color.a},b.prototype.render=function(){if(this._effectBase.isReady()&&this._effectFog.isReady()&&this._spriteTexture&&this._spriteTexture.isReady()){for(var b=this._scene.getEngine(),c=this._spriteTexture.getBaseSize(),d=a.Tools.GetDeltaTime(),e=Math.min(this._capacity,this.sprites.length),f=c.width/this.cellSize,g=0,h=0;e>h;h++){var i=this.sprites[h];i&&(i._animate(d),this._appendSpriteVertex(g++,i,0,0,f),this._appendSpriteVertex(g++,i,1,0,f),this._appendSpriteVertex(g++,i,1,1,f),this._appendSpriteVertex(g++,i,0,1,f))}b.updateDynamicVertexBuffer(this._vertexBuffer,this._vertices,e*this._vertexStrideSize);var j=this._effectBase;this._scene.fogMode!==a.Scene.FOGMODE_NONE&&(j=this._effectFog),b.enableEffect(j);var k=this._scene.getViewMatrix();j.setTexture("diffuseSampler",this._spriteTexture),j.setMatrix("view",k),j.setMatrix("projection",this._scene.getProjectionMatrix()),j.setFloat2("textureInfos",this.cellSize/c.width,this.cellSize/c.height),this._scene.fogMode!==a.Scene.FOGMODE_NONE&&(j.setFloat4("vFogInfos",this._scene.fogMode,this._scene.fogStart,this._scene.fogEnd,this._scene.fogDensity),j.setColor3("vFogColor",this._scene.fogColor)),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,j),j.setBool("alphaTest",!0),b.setColorWrite(!1),b.draw(!0,0,6*e),b.setColorWrite(!0),j.setBool("alphaTest",!1),b.setAlphaMode(a.Engine.ALPHA_COMBINE),b.draw(!0,0,6*e),b.setAlphaMode(a.Engine.ALPHA_DISABLE)}},b.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this._spriteTexture&&(this._spriteTexture.dispose(),this._spriteTexture=null);var a=this._scene.spriteManagers.indexOf(this);this._scene.spriteManagers.splice(a,1),this.onDispose&&this.onDispose()},b}();a.SpriteManager=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.name=b,this.color=new a.Color4(1,1,1,1),this.size=1,this.angle=0,this.cellIndex=0,this.invertU=0,this.invertV=0,this.animations=new Array,this._animationStarted=!1,this._loopAnimation=!1,this._fromIndex=0,this._toIndex=0,this._delay=0,this._direction=1,this._frameCount=0,this._time=0,this._manager=c,this._manager.sprites.push(this),this.position=a.Vector3.Zero()}return b.prototype.playAnimation=function(a,b,c,d){this._fromIndex=a,this._toIndex=b,this._loopAnimation=c,this._delay=d,this._animationStarted=!0,this._direction=b>a?1:-1,this.cellIndex=a,this._time=0},b.prototype.stopAnimation=function(){this._animationStarted=!1},b.prototype._animate=function(a){this._animationStarted&&(this._time+=a,this._time>this._delay&&(this._time=this._time%this._delay,this.cellIndex+=this._direction,this.cellIndex==this._toIndex&&(this._loopAnimation?this.cellIndex=this._fromIndex:(this._animationStarted=!1,this.disposeWhenFinishedAnimating&&this.dispose()))))},b.prototype.dispose=function(){for(var a=0;a<this._manager.sprites.length;a++)this._manager.sprites[a]==this&&this._manager.sprites.splice(a,1)},b}();a.Sprite=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.name=b,this._vertexDeclaration=[2],this._vertexStrideSize=8,this.texture=c?new a.Texture(c,d,!0):null,this.isBackground=void 0===e?!0:e,this.color=void 0===f?new a.Color4(1,1,1,1):f,this._scene=d,this._scene.layers.push(this);var g=[];g.push(1,1),g.push(-1,1),g.push(-1,-1),g.push(1,-1),this._vertexBuffer=d.getEngine().createVertexBuffer(g);var h=[];h.push(0),h.push(1),h.push(2),h.push(0),h.push(2),h.push(3),this._indexBuffer=d.getEngine().createIndexBuffer(h),this._effect=this._scene.getEngine().createEffect("layer",["position"],["textureMatrix","color"],["textureSampler"],"")}return b.prototype.render=function(){if(this._effect.isReady()&&this.texture&&this.texture.isReady()){var b=this._scene.getEngine();b.enableEffect(this._effect),b.setState(!1),this._effect.setTexture("textureSampler",this.texture),this._effect.setMatrix("textureMatrix",this.texture.getTextureMatrix()),this._effect.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,this._effect),b.setAlphaMode(a.Engine.ALPHA_COMBINE),b.draw(!0,0,6),b.setAlphaMode(a.Engine.ALPHA_DISABLE)}},b.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null);var a=this._scene.layers.indexOf(this);this._scene.layers.splice(a,1),this.onDispose&&this.onDispose()},b}();a.Layer=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this.position=a.Vector3.Zero(),this.direction=a.Vector3.Zero(),this.color=new a.Color4(0,0,0,0),this.colorStep=new a.Color4(0,0,0,0),this.lifeTime=1,this.age=0,this.size=0,this.angle=0,this.angularSpeed=0}return b}();a.Particle=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b){if(a==b)return a;var c=Math.random();return c*(b-a)+a},c=function(){function c(c,d,e,f){var g=this;this.name=c,this.fragmentElement=f,this.renderingGroupId=0,this.emitter=null,this.emitRate=10,this.manualEmitCount=-1,this.updateSpeed=.01,this.targetStopDuration=0,this.disposeOnStop=!1,this.minEmitPower=1,this.maxEmitPower=1,this.minLifeTime=1,this.maxLifeTime=1,this.minSize=1,this.maxSize=1,this.minAngularSpeed=0,this.maxAngularSpeed=0,this.blendMode=a.ParticleSystem.BLENDMODE_ONEONE,this.forceDepthWrite=!1,this.gravity=a.Vector3.Zero(),this.direction1=new a.Vector3(0,1,0),this.direction2=new a.Vector3(0,1,0),this.minEmitBox=new a.Vector3(-.5,-.5,-.5),this.maxEmitBox=new a.Vector3(.5,.5,.5),this.color1=new a.Color4(1,1,1,1),this.color2=new a.Color4(1,1,1,1),this.colorDead=new a.Color4(0,0,0,1),this.textureMask=new a.Color4(1,1,1,1),this.particles=new Array,this._vertexDeclaration=[3,4,4],this._vertexStrideSize=44,this._stockParticles=new Array,this._newPartsExcess=0,this._scaledColorStep=new a.Color4(0,0,0,0),this._colorDiff=new a.Color4(0,0,0,0),this._scaledDirection=a.Vector3.Zero(),this._scaledGravity=a.Vector3.Zero(),this._currentRenderId=-1,this._started=!1,this._stopped=!1,this._actualFrame=0,this.id=c,this._capacity=d,this._scene=e,e.particleSystems.push(this),this._vertexBuffer=e.getEngine().createDynamicVertexBuffer(d*this._vertexStrideSize*4);for(var h=[],i=0,j=0;d>j;j++)h.push(i),h.push(i+1),h.push(i+2),h.push(i),h.push(i+2),h.push(i+3),i+=4;this._indexBuffer=e.getEngine().createIndexBuffer(h),this._vertices=new Float32Array(d*this._vertexStrideSize),this.startDirectionFunction=function(c,d,e){var f=b(g.direction1.x,g.direction2.x),h=b(g.direction1.y,g.direction2.y),i=b(g.direction1.z,g.direction2.z);
a.Vector3.TransformNormalFromFloatsToRef(f*c,h*c,i*c,d,e)},this.startPositionFunction=function(c,d){var e=b(g.minEmitBox.x,g.maxEmitBox.x),f=b(g.minEmitBox.y,g.maxEmitBox.y),h=b(g.minEmitBox.z,g.maxEmitBox.z);a.Vector3.TransformCoordinatesFromFloatsToRef(e,f,h,c,d)}}return c.prototype.getCapacity=function(){return this._capacity},c.prototype.isAlive=function(){return this._alive},c.prototype.isStarted=function(){return this._started},c.prototype.start=function(){this._started=!0,this._stopped=!1,this._actualFrame=0},c.prototype.stop=function(){this._stopped=!0},c.prototype._appendParticleVertex=function(a,b,c,d){var e=11*a;this._vertices[e]=b.position.x,this._vertices[e+1]=b.position.y,this._vertices[e+2]=b.position.z,this._vertices[e+3]=b.color.r,this._vertices[e+4]=b.color.g,this._vertices[e+5]=b.color.b,this._vertices[e+6]=b.color.a,this._vertices[e+7]=b.angle,this._vertices[e+8]=b.size,this._vertices[e+9]=c,this._vertices[e+10]=d},c.prototype._update=function(c){this._alive=this.particles.length>0;for(var d=0;d<this.particles.length;d++){var e=this.particles[d];e.age+=this._scaledUpdateSpeed,e.age>=e.lifeTime?(this._stockParticles.push(this.particles.splice(d,1)[0]),d--):(e.colorStep.scaleToRef(this._scaledUpdateSpeed,this._scaledColorStep),e.color.addInPlace(this._scaledColorStep),e.color.a<0&&(e.color.a=0),e.angle+=e.angularSpeed*this._scaledUpdateSpeed,e.direction.scaleToRef(this._scaledUpdateSpeed,this._scaledDirection),e.position.addInPlace(this._scaledDirection),this.gravity.scaleToRef(this._scaledUpdateSpeed,this._scaledGravity),e.direction.addInPlace(this._scaledGravity))}var f;for(f=this.emitter.position?this.emitter.getWorldMatrix():a.Matrix.Translation(this.emitter.x,this.emitter.y,this.emitter.z),d=0;c>d&&this.particles.length!=this._capacity;d++){0!==this._stockParticles.length?(e=this._stockParticles.pop(),e.age=0):e=new a.Particle,this.particles.push(e);var g=b(this.minEmitPower,this.maxEmitPower);this.startDirectionFunction(g,f,e.direction),e.lifeTime=b(this.minLifeTime,this.maxLifeTime),e.size=b(this.minSize,this.maxSize),e.angularSpeed=b(this.minAngularSpeed,this.maxAngularSpeed),this.startPositionFunction(f,e.position);var h=b(0,1);a.Color4.LerpToRef(this.color1,this.color2,h,e.color),this.colorDead.subtractToRef(e.color,this._colorDiff),this._colorDiff.scaleToRef(1/e.lifeTime,e.colorStep)}},c.prototype._getEffect=function(){var a=[];this._scene.clipPlane&&a.push("#define CLIPPLANE");var b=a.join("\n");if(this._cachedDefines!=b){this._cachedDefines=b;var c;c=this.fragmentElement?{vertex:"particles",fragmentElement:this.fragmentElement}:"particles",this._effect=this._scene.getEngine().createEffect(c,["position","color","options"],["invView","view","projection","vClipPlane","textureMask"],["diffuseSampler"],b)}return this._effect},c.prototype.animate=function(){if(this._started){var a=this._getEffect();if(this.emitter&&a.isReady()&&this.particleTexture&&this.particleTexture.isReady()&&this._currentRenderId!==this._scene.getRenderId()){this._currentRenderId=this._scene.getRenderId(),this._scaledUpdateSpeed=this.updateSpeed*this._scene.getAnimationRatio();var b;this.manualEmitCount>-1?(b=this.manualEmitCount,this.manualEmitCount=0):b=this.emitRate;var c=b*this._scaledUpdateSpeed>>0;this._newPartsExcess+=b*this._scaledUpdateSpeed-c,this._newPartsExcess>1&&(c+=this._newPartsExcess>>0,this._newPartsExcess-=this._newPartsExcess>>0),this._alive=!1,this._stopped?c=0:(this._actualFrame+=this._scaledUpdateSpeed,this.targetStopDuration&&this._actualFrame>=this.targetStopDuration&&this.stop()),this._update(c),this._stopped&&(this._alive||(this._started=!1,this.disposeOnStop&&this._scene._toBeDisposed.push(this)));for(var d=0,e=0;e<this.particles.length;e++){var f=this.particles[e];this._appendParticleVertex(d++,f,0,0),this._appendParticleVertex(d++,f,1,0),this._appendParticleVertex(d++,f,1,1),this._appendParticleVertex(d++,f,0,1)}var g=this._scene.getEngine();g.updateDynamicVertexBuffer(this._vertexBuffer,this._vertices,this.particles.length*this._vertexStrideSize)}}},c.prototype.render=function(){var b=this._getEffect();if(!(this.emitter&&b.isReady()&&this.particleTexture&&this.particleTexture.isReady()&&this.particles.length))return 0;var c=this._scene.getEngine();c.enableEffect(b);var d=this._scene.getViewMatrix();if(b.setTexture("diffuseSampler",this.particleTexture),b.setMatrix("view",d),b.setMatrix("projection",this._scene.getProjectionMatrix()),b.setFloat4("textureMask",this.textureMask.r,this.textureMask.g,this.textureMask.b,this.textureMask.a),this._scene.clipPlane){var e=this._scene.clipPlane,f=d.clone();f.invert(),b.setMatrix("invView",f),b.setFloat4("vClipPlane",e.normal.x,e.normal.y,e.normal.z,e.d)}return c.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,b),c.setAlphaMode(this.blendMode===a.ParticleSystem.BLENDMODE_ONEONE?a.Engine.ALPHA_ADD:a.Engine.ALPHA_COMBINE),this.forceDepthWrite&&c.setDepthWrite(!0),c.draw(!0,0,6*this.particles.length),c.setAlphaMode(a.Engine.ALPHA_DISABLE),this.particles.length},c.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.particleTexture&&(this.particleTexture.dispose(),this.particleTexture=null);var a=this._scene.particleSystems.indexOf(this);this._scene.particleSystems.splice(a,1),this.onDispose&&this.onDispose()},c.prototype.clone=function(b,c){var d=new a.ParticleSystem(b,this._capacity,this._scene);return a.Tools.DeepCopy(this,d,["particles"],["_vertexDeclaration","_vertexStrideSize"]),void 0===c&&(c=this.emitter),d.emitter=c,this.particleTexture&&(d.particleTexture=new a.Texture(this.particleTexture.url,this._scene)),d.start(),d},c.BLENDMODE_ONEONE=0,c.BLENDMODE_STANDARD=1,c}();a.ParticleSystem=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,c,d,e,f){this.name=a,this.targetProperty=c,this.framePerSecond=d,this.dataType=e,this.loopMode=f,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this.targetPropertyPath=c.split("."),this.dataType=e,this.loopMode=void 0===f?b.ANIMATIONLOOPMODE_CYCLE:f}return b.prototype.isStopped=function(){return this._stopped},b.prototype.getKeys=function(){return this._keys},b.prototype.floatInterpolateFunction=function(a,b,c){return a+(b-a)*c},b.prototype.quaternionInterpolateFunction=function(b,c,d){return a.Quaternion.Slerp(b,c,d)},b.prototype.vector3InterpolateFunction=function(b,c,d){return a.Vector3.Lerp(b,c,d)},b.prototype.color3InterpolateFunction=function(b,c,d){return a.Color3.Lerp(b,c,d)},b.prototype.clone=function(){var a=new b(this.name,this.targetPropertyPath.join("."),this.framePerSecond,this.dataType,this.loopMode);return a.setKeys(this._keys),a},b.prototype.setKeys=function(a){this._keys=a.slice(0),this._offsetsCache={},this._highLimitsCache={}},b.prototype._interpolate=function(a,c,d,e,f){if(d===b.ANIMATIONLOOPMODE_CONSTANT&&c>0)return f.clone?f.clone():f;this.currentFrame=a;for(var g=0;g<this._keys.length;g++)if(this._keys[g+1].frame>=a){var h=this._keys[g].value,i=this._keys[g+1].value,j=(a-this._keys[g].frame)/(this._keys[g+1].frame-this._keys[g].frame);switch(this.dataType){case b.ANIMATIONTYPE_FLOAT:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.floatInterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return e*c+this.floatInterpolateFunction(h,i,j)}break;case b.ANIMATIONTYPE_QUATERNION:var k=null;switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:k=this.quaternionInterpolateFunction(h,i,j);break;case b.ANIMATIONLOOPMODE_RELATIVE:k=this.quaternionInterpolateFunction(h,i,j).add(e.scale(c))}return k;case b.ANIMATIONTYPE_VECTOR3:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.vector3InterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return this.vector3InterpolateFunction(h,i,j).add(e.scale(c))}case b.ANIMATIONTYPE_COLOR3:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.color3InterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return this.color3InterpolateFunction(h,i,j).add(e.scale(c))}case b.ANIMATIONTYPE_MATRIX:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:case b.ANIMATIONLOOPMODE_RELATIVE:return h}}break}return this._keys[this._keys.length-1].value},b.prototype.animate=function(a,c,d,e,f){if(!this.targetPropertyPath||this.targetPropertyPath.length<1)return this._stopped=!0,!1;var g=!0;if(0!=this._keys[0].frame){var h={frame:0,value:this._keys[0].value};this._keys.splice(0,0,h)}(c<this._keys[0].frame||c>this._keys[this._keys.length-1].frame)&&(c=this._keys[0].frame),(d<this._keys[0].frame||d>this._keys[this._keys.length-1].frame)&&(d=this._keys[this._keys.length-1].frame);var i=d-c,j=a*this.framePerSecond*f/1e3;if(j>i&&!e)k=0,g=!1,l=this._keys[this._keys.length-1].value;else{var k=0,l=0;if(this.loopMode!=b.ANIMATIONLOOPMODE_CYCLE){var m=d.toString()+c.toString();if(!this._offsetsCache[m]){var n=this._interpolate(c,0,b.ANIMATIONLOOPMODE_CYCLE),o=this._interpolate(d,0,b.ANIMATIONLOOPMODE_CYCLE);switch(this.dataType){case b.ANIMATIONTYPE_FLOAT:this._offsetsCache[m]=o-n;break;case b.ANIMATIONTYPE_QUATERNION:this._offsetsCache[m]=o.subtract(n);break;case b.ANIMATIONTYPE_VECTOR3:this._offsetsCache[m]=o.subtract(n);case b.ANIMATIONTYPE_COLOR3:this._offsetsCache[m]=o.subtract(n)}this._highLimitsCache[m]=o}l=this._highLimitsCache[m],k=this._offsetsCache[m]}}var p=j/i>>0,q=g?c+j%i:d,r=this._interpolate(q,p,this.loopMode,k,l);if(this.targetPropertyPath.length>1){for(var s=this._target[this.targetPropertyPath[0]],t=1;t<this.targetPropertyPath.length-1;t++)s=s[this.targetPropertyPath[t]];s[this.targetPropertyPath[this.targetPropertyPath.length-1]]=r}else this._target[this.targetPropertyPath[0]]=r;return this._target.markAsDirty&&this._target.markAsDirty(this.targetProperty),g||(this._stopped=!0),g},Object.defineProperty(b,"ANIMATIONTYPE_FLOAT",{get:function(){return b._ANIMATIONTYPE_FLOAT},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_VECTOR3",{get:function(){return b._ANIMATIONTYPE_VECTOR3},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_QUATERNION",{get:function(){return b._ANIMATIONTYPE_QUATERNION},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_MATRIX",{get:function(){return b._ANIMATIONTYPE_MATRIX},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_COLOR3",{get:function(){return b._ANIMATIONTYPE_COLOR3},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_RELATIVE",{get:function(){return b._ANIMATIONLOOPMODE_RELATIVE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_CYCLE",{get:function(){return b._ANIMATIONLOOPMODE_CYCLE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_CONSTANT",{get:function(){return b._ANIMATIONLOOPMODE_CONSTANT},enumerable:!0,configurable:!0}),b._ANIMATIONTYPE_FLOAT=0,b._ANIMATIONTYPE_VECTOR3=1,b._ANIMATIONTYPE_QUATERNION=2,b._ANIMATIONTYPE_MATRIX=3,b._ANIMATIONTYPE_COLOR3=4,b._ANIMATIONLOOPMODE_RELATIVE=0,b._ANIMATIONLOOPMODE_CYCLE=1,b._ANIMATIONLOOPMODE_CONSTANT=2,b}();a.Animation=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c,d,e,f,g,h){"undefined"==typeof c&&(c=0),"undefined"==typeof d&&(d=100),"undefined"==typeof e&&(e=!1),"undefined"==typeof f&&(f=1),this.target=b,this.fromFrame=c,this.toFrame=d,this.loopAnimation=e,this.speedRatio=f,this.onAnimationEnd=g,this._animations=new Array,this._paused=!1,this.animationStarted=!1,h&&this.appendAnimations(b,h),this._scene=a,a._activeAnimatables.push(this)}return a.prototype.appendAnimations=function(a,b){for(var c=0;c<b.length;c++){var d=b[c];d._target=a,this._animations.push(d)}},a.prototype.getAnimationByTargetProperty=function(a){for(var b=this._animations,c=0;c<b.length;c++)if(b[c].targetProperty===a)return b[c];return null},a.prototype.pause=function(){this._paused=!0},a.prototype.restart=function(){this._paused=!1},a.prototype.stop=function(){var a=this._scene._activeAnimatables.indexOf(this);a>-1&&this._scene._activeAnimatables.splice(a,1),this.onAnimationEnd&&this.onAnimationEnd()},a.prototype._animate=function(a){if(this._paused)return!0;this._localDelayOffset||(this._localDelayOffset=a);for(var b=!1,c=this._animations,d=0;d<c.length;d++){var e=c[d],f=e.animate(a-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this.speedRatio);b=b||f}return!b&&this.onAnimationEnd&&this.onAnimationEnd(),b},a}();a.Animatable=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d){"undefined"==typeof d&&(d=2),this.maxDepth=d,this.dynamicContent=new Array,this._maxBlockCapacity=c||64,this._selectionContent=new a.SmartArray(1024),this._creationFunc=b}return b.prototype.update=function(a,c,d){b._CreateBlocks(a,c,d,this._maxBlockCapacity,0,this.maxDepth,this,this._creationFunc)},b.prototype.addMesh=function(a){for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.addEntry(a)}},b.prototype.select=function(a,b){this._selectionContent.reset();for(var c=0;c<this.blocks.length;c++){var d=this.blocks[c];d.select(a,this._selectionContent,b)}return b?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b.prototype.intersects=function(a,b,c){this._selectionContent.reset();for(var d=0;d<this.blocks.length;d++){var e=this.blocks[d];e.intersects(a,b,this._selectionContent,c)}return c?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b.prototype.intersectsRay=function(a){this._selectionContent.reset();for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.intersectsRay(a,this._selectionContent)}return this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b._CreateBlocks=function(b,c,d,e,f,g,h,i){h.blocks=new Array;for(var j=new a.Vector3((c.x-b.x)/2,(c.y-b.y)/2,(c.z-b.z)/2),k=0;2>k;k++)for(var l=0;2>l;l++)for(var m=0;2>m;m++){var n=b.add(j.multiplyByFloats(k,l,m)),o=b.add(j.multiplyByFloats(k+1,l+1,m+1)),p=new a.OctreeBlock(n,o,e,f+1,g,i);p.addEntries(d),h.blocks.push(p)}},b.CreationFuncForMeshes=function(a,b){a.getBoundingInfo().boundingBox.intersectsMinMax(b.minPoint,b.maxPoint)&&b.entries.push(a)},b.CreationFuncForSubMeshes=function(a,b){a.getBoundingInfo().boundingBox.intersectsMinMax(b.minPoint,b.maxPoint)&&b.entries.push(a)},b}();a.Octree=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f){this.entries=new Array,this._boundingVectors=new Array,this._capacity=c,this._depth=d,this._maxDepth=e,this._creationFunc=f,this._minPoint=a,this._maxPoint=b,this._boundingVectors.push(a.clone()),this._boundingVectors.push(b.clone()),this._boundingVectors.push(a.clone()),this._boundingVectors[2].x=b.x,this._boundingVectors.push(a.clone()),this._boundingVectors[3].y=b.y,this._boundingVectors.push(a.clone()),this._boundingVectors[4].z=b.z,this._boundingVectors.push(b.clone()),this._boundingVectors[5].z=a.z,this._boundingVectors.push(b.clone()),this._boundingVectors[6].x=a.x,this._boundingVectors.push(b.clone()),this._boundingVectors[7].y=a.y}return Object.defineProperty(b.prototype,"capacity",{get:function(){return this._capacity},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"minPoint",{get:function(){return this._minPoint},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"maxPoint",{get:function(){return this._maxPoint},enumerable:!0,configurable:!0}),b.prototype.addEntry=function(a){if(this.blocks)for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.addEntry(a)}else this._creationFunc(a,this),this.entries.length>this.capacity&&this._depth<this._maxDepth&&this.createInnerBlocks()},b.prototype.addEntries=function(a){for(var b=0;b<a.length;b++){var c=a[b];this.addEntry(c)}},b.prototype.select=function(b,c,d){if(a.BoundingBox.IsInFrustum(this._boundingVectors,b)){if(this.blocks){for(var e=0;e<this.blocks.length;e++){var f=this.blocks[e];f.select(b,c,d)}return}d?c.concat(this.entries):c.concatWithNoDuplicate(this.entries)}},b.prototype.intersects=function(b,c,d,e){if(a.BoundingBox.IntersectsSphere(this._minPoint,this._maxPoint,b,c)){if(this.blocks){for(var f=0;f<this.blocks.length;f++){var g=this.blocks[f];g.intersects(b,c,d,e)}return}e?d.concat(this.entries):d.concatWithNoDuplicate(this.entries)}},b.prototype.intersectsRay=function(a,b){if(a.intersectsBoxMinMax(this._minPoint,this._maxPoint)){if(this.blocks){for(var c=0;c<this.blocks.length;c++){var d=this.blocks[c];d.intersectsRay(a,b)}return}b.concatWithNoDuplicate(this.entries)}},b.prototype.createInnerBlocks=function(){a.Octree._CreateBlocks(this._minPoint,this._maxPoint,this.entries,this._capacity,this._depth,this._maxDepth,this,this._creationFunc)},b}();a.OctreeBlock=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e){this.name=b,this.children=new Array,this.animations=new Array,this._worldTransform=new a.Matrix,this._absoluteTransform=new a.Matrix,this._invertedAbsoluteTransform=new a.Matrix,this._skeleton=c,this._matrix=e,this._baseMatrix=e,c.bones.push(this),d?(this._parent=d,d.children.push(this)):this._parent=null,this._updateDifferenceMatrix()}return b.prototype.getParent=function(){return this._parent},b.prototype.getLocalMatrix=function(){return this._matrix},b.prototype.getBaseMatrix=function(){return this._baseMatrix},b.prototype.getWorldMatrix=function(){return this._worldTransform},b.prototype.getInvertedAbsoluteTransform=function(){return this._invertedAbsoluteTransform},b.prototype.getAbsoluteMatrix=function(){for(var a=this._matrix.clone(),b=this._parent;b;)a=a.multiply(b.getLocalMatrix()),b=b.getParent();return a},b.prototype.updateMatrix=function(a){this._matrix=a,this._skeleton._markAsDirty(),this._updateDifferenceMatrix()},b.prototype._updateDifferenceMatrix=function(){this._parent?this._matrix.multiplyToRef(this._parent._absoluteTransform,this._absoluteTransform):this._absoluteTransform.copyFrom(this._matrix),this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);for(var a=0;a<this.children.length;a++)this.children[a]._updateDifferenceMatrix()},b.prototype.markAsDirty=function(){this._skeleton._markAsDirty()},b}();a.Bone=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d){this.name=b,this.id=c,this.bones=new Array,this._isDirty=!0,this._identity=a.Matrix.Identity(),this.bones=[],this._scene=d,d.skeletons.push(this)}return b.prototype.getTransformMatrices=function(){return this._transformMatrices},b.prototype._markAsDirty=function(){this._isDirty=!0},b.prototype.prepare=function(){if(this._isDirty){this._transformMatrices&&this._transformMatrices.length===16*(this.bones.length+1)||(this._transformMatrices=new Float32Array(16*(this.bones.length+1)));for(var a=0;a<this.bones.length;a++){var b=this.bones[a],c=b.getParent();c?b.getLocalMatrix().multiplyToRef(c.getWorldMatrix(),b.getWorldMatrix()):b.getWorldMatrix().copyFrom(b.getLocalMatrix()),b.getInvertedAbsoluteTransform().multiplyToArray(b.getWorldMatrix(),this._transformMatrices,16*a)}this._identity.copyToArray(this._transformMatrices,16*this.bones.length),this._isDirty=!1}},b.prototype.getAnimatables=function(){if(!this._animatables||this._animatables.length!=this.bones.length){this._animatables=[];for(var a=0;a<this.bones.length;a++)this._animatables.push(this.bones[a])}return this._animatables},b.prototype.clone=function(b,c){for(var d=new a.Skeleton(b,c||b,this._scene),e=0;e<this.bones.length;e++){var f=this.bones[e],g=null;if(f.getParent()){var h=this.bones.indexOf(f.getParent());g=d.bones[h]}var i=new a.Bone(f.name,d,g,f.getBaseMatrix());a.Tools.DeepCopy(f.animations,i.animations)}return d},b}();a.Skeleton=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g,h,i,j){this.name=b,this.width=-1,this.height=-1,this._reusable=!1,this._textures=new a.SmartArray(2),this._currentRenderTextureInd=0,null!=g?(this._camera=g,this._scene=g.getScene(),g.attachPostProcess(this),this._engine=this._scene.getEngine()):this._engine=i,this._renderRatio=f,this.renderTargetSamplingMode=h?h:a.Texture.NEAREST_SAMPLINGMODE,this._reusable=j||!1,e=e||[],e.push("textureSampler"),this._effect=this._engine.createEffect({vertex:"postprocess",fragment:c},["position"],d||[],e,"")}return b.prototype.isReusable=function(){return this._reusable},b.prototype.activate=function(a,b){a=a||this._camera;var c=a.getScene(),d=(b?b._width:this._engine.getRenderingCanvas().width)*this._renderRatio,e=(b?b._height:this._engine.getRenderingCanvas().height)*this._renderRatio;if(this.width!==d||this.height!==e){if(this._textures.length>0){for(var f=0;f<this._textures.length;f++)this._engine._releaseTexture(this._textures.data[f]);this._textures.reset()}this.width=d,this.height=e,this._textures.push(this._engine.createRenderTargetTexture({width:this.width,height:this.height},{generateMipMaps:!1,generateDepthBuffer:a._postProcesses.indexOf(this)===a._postProcessesTakenIndices[0],samplingMode:this.renderTargetSamplingMode})),this._reusable&&this._textures.push(this._engine.createRenderTargetTexture({width:this.width,height:this.height},{generateMipMaps:!1,generateDepthBuffer:a._postProcesses.indexOf(this)===a._postProcessesTakenIndices[0],samplingMode:this.renderTargetSamplingMode})),this.onSizeChanged&&this.onSizeChanged()}this._engine.bindFramebuffer(this._textures.data[this._currentRenderTextureInd]),this.onActivate&&this.onActivate(a),this._engine.clear(c.clearColor,c.autoClear||c.forceWireframe,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2)},b.prototype.apply=function(){return this._effect.isReady()?(this._engine.enableEffect(this._effect),this._engine.setState(!1),this._engine.setAlphaMode(a.Engine.ALPHA_DISABLE),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._effect._bindTexture("textureSampler",this._textures.data[this._currentRenderTextureInd]),this.onApply&&this.onApply(this._effect),this._effect):null},b.prototype.dispose=function(a){if(a=a||this._camera,this._textures.length>0){for(var b=0;b<this._textures.length;b++)this._engine._releaseTexture(this._textures.data[b]);this._textures.reset()}a.detachPostProcess(this);var c=a._postProcesses.indexOf(this);c===a._postProcessesTakenIndices[0]&&a._postProcessesTakenIndices.length>0&&(this._camera._postProcesses[a._postProcessesTakenIndices[0]].width=-1)},b}();a.PostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a){this._vertexDeclaration=[2],this._vertexStrideSize=8,this._scene=a;var b=[];b.push(1,1),b.push(-1,1),b.push(-1,-1),b.push(1,-1),this._vertexBuffer=a.getEngine().createVertexBuffer(b);var c=[];c.push(0),c.push(1),c.push(2),c.push(0),c.push(2),c.push(3),this._indexBuffer=a.getEngine().createIndexBuffer(c)}return a.prototype._prepareFrame=function(a){var b=this._scene.activeCamera._postProcesses,c=this._scene.activeCamera._postProcessesTakenIndices;return 0!==c.length&&this._scene.postProcessesEnabled?(b[this._scene.activeCamera._postProcessesTakenIndices[0]].activate(this._scene.activeCamera,a),!0):!1},a.prototype._finalizeFrame=function(a,b){var c=this._scene.activeCamera._postProcesses,d=this._scene.activeCamera._postProcessesTakenIndices;if(0!==d.length&&this._scene.postProcessesEnabled){for(var e=this._scene.getEngine(),f=0;f<d.length&&(f<d.length-1?c[d[f+1]].activate(this._scene.activeCamera):b?e.bindFramebuffer(b):e.restoreDefaultFramebuffer(),!a);f++){var g=c[d[f]].apply();g&&(e.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,g),e.draw(!0,0,6))}e.setDepthBuffer(!0),e.setDepthWrite(!0)}},a.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)},a}();a.PostProcessManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"pass",null,null,c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.PassPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i,j){"undefined"==typeof h&&(h=a.Texture.BILINEAR_SAMPLINGMODE);var k=this;b.call(this,c,"blur",["screenSize","direction","blurWidth"],null,f,g,h,i,j),this.direction=d,this.blurWidth=e,this.onApply=function(a){a.setFloat2("screenSize",k.width,k.height),a.setVector2("direction",k.direction),a.setFloat("blurWidth",k.blurWidth)}}return __extends(c,b),c}(a.PostProcess);a.BlurPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g,h){var i=this;a.call(this,b,"filter",["kernelMatrix"],null,d,e,f,g,h),this.kernelMatrix=c,this.onApply=function(a){a.setMatrix("kernelMatrix",i.kernelMatrix)}}return __extends(b,a),b}(a.PostProcess);a.FilterPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i,j,k,l){var m=this;b.call(this,c,"refraction",["baseColor","depth","colorLevel"],["refractionSampler"],h,i,j,k,l),this.color=e,this.depth=f,this.colorLevel=g,this.onActivate=function(b){m._refRexture=m._refRexture||new a.Texture(d,b.getScene())},this.onApply=function(a){a.setColor3("baseColor",m.color),a.setFloat("depth",m.depth),a.setFloat("colorLevel",m.colorLevel),a.setTexture("refractionSampler",m._refRexture)}}return __extends(c,b),c.prototype.dispose=function(a){this._refRexture&&this._refRexture.dispose(),b.prototype.dispose.call(this,a)},c}(a.PostProcess);a.RefractionPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"blackAndWhite",null,null,c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.BlackAndWhitePostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g,h){var i=this;a.call(this,b,"convolution",["kernel","screenSize"],null,d,e,f,g,h),this.kernel=c,this.onApply=function(a){a.setFloat2("screenSize",i.width,i.height),a.setArray("kernel",i.kernel)}}return __extends(b,a),b.EdgeDetect0Kernel=[1,0,-1,0,0,0,-1,0,1],b.EdgeDetect1Kernel=[0,1,0,1,-4,1,0,1,0],b.EdgeDetect2Kernel=[-1,-1,-1,-1,8,-1,-1,-1,-1],b.SharpenKernel=[0,-1,0,-1,5,-1,0,-1,0],b.EmbossKernel=[-2,-1,0,-1,1,1,0,1,2],b.GaussianKernel=[0,1,0,1,1,1,0,1,0],b}(a.PostProcess);a.ConvolutionPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){var h=this;a.call(this,b,"fxaa",["texelSize"],null,c,d,e,f,g),this.onSizeChanged=function(){h.texelWidth=1/h.width,h.texelHeight=1/h.height},this.onApply=function(a){a.setFloat2("texelSize",h.texelWidth,h.texelHeight)}}return __extends(b,a),b}(a.PostProcess);a.FxaaPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.size=b,this.position=c,this.dispose=function(){this.texture&&this.texture.dispose();var a=this._system.lensFlares.indexOf(this);this._system.lensFlares.splice(a,1)},this.color=d||new a.Color3(1,1,1),this.texture=e?new a.Texture(e,f.getScene(),!0):null,this._system=f,f.lensFlares.push(this)}return b}();a.LensFlare=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c){this.name=a,this.lensFlares=new Array,this.borderLimit=300,this._vertexDeclaration=[2],this._vertexStrideSize=8,this._isEnabled=!0,this._scene=c,this._emitter=b,c.lensFlareSystems.push(this),this.meshesSelectionPredicate=function(a){return a.material&&a.isVisible&&a.isEnabled()&&a.checkCollisions&&0!=(a.layerMask&c.activeCamera.layerMask)};var d=[];d.push(1,1),d.push(-1,1),d.push(-1,-1),d.push(1,-1),this._vertexBuffer=c.getEngine().createVertexBuffer(d);var e=[];e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),this._indexBuffer=c.getEngine().createIndexBuffer(e),this._effect=this._scene.getEngine().createEffect("lensFlare",["position"],["color","viewportMatrix"],["textureSampler"],"")}return Object.defineProperty(b.prototype,"isEnabled",{get:function(){return this._isEnabled},set:function(a){this._isEnabled=a},enumerable:!0,configurable:!0}),b.prototype.getScene=function(){return this._scene},b.prototype.getEmitter=function(){return this._emitter},b.prototype.getEmitterPosition=function(){return this._emitter.getAbsolutePosition?this._emitter.getAbsolutePosition():this._emitter.position},b.prototype.computeEffectivePosition=function(b){var c=this.getEmitterPosition();return c=a.Vector3.Project(c,a.Matrix.Identity(),this._scene.getTransformMatrix(),b),this._positionX=c.x,this._positionY=c.y,c=a.Vector3.TransformCoordinates(this.getEmitterPosition(),this._scene.getViewMatrix()),c.z>0&&this._positionX>b.x&&this._positionX<b.x+b.width&&this._positionY>b.y&&this._positionY<b.y+b.height?!0:!1},b.prototype._isVisible=function(){if(!this._isEnabled)return!1;var b=this.getEmitterPosition(),c=b.subtract(this._scene.activeCamera.position),d=c.length();c.normalize();var e=new a.Ray(this._scene.activeCamera.position,c),f=this._scene.pickWithRay(e,this.meshesSelectionPredicate,!0);return!f.hit||f.distance>d},b.prototype.render=function(){if(!this._effect.isReady())return!1;var b=this._scene.getEngine(),c=this._scene.activeCamera.viewport,d=c.toGlobal(b);if(!this.computeEffectivePosition(d))return!1;if(!this._isVisible())return!1;var e,f;e=this._positionX<this.borderLimit+d.x?this.borderLimit+d.x-this._positionX:this._positionX>d.x+d.width-this.borderLimit?this._positionX-d.x-d.width+this.borderLimit:0,f=this._positionY<this.borderLimit+d.y?this.borderLimit+d.y-this._positionY:this._positionY>d.y+d.height-this.borderLimit?this._positionY-d.y-d.height+this.borderLimit:0;var g=e>f?e:f;g>this.borderLimit&&(g=this.borderLimit);var h=1-g/this.borderLimit;if(0>h)return!1;h>1&&(h=1);var i=d.x+d.width/2,j=d.y+d.height/2,k=i-this._positionX,l=j-this._positionY;b.enableEffect(this._effect),b.setState(!1),b.setDepthBuffer(!1),b.setAlphaMode(a.Engine.ALPHA_ADD),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,this._effect);for(var m=0;m<this.lensFlares.length;m++){var n=this.lensFlares[m],o=i-k*n.position,p=j-l*n.position,q=n.size,r=n.size*b.getAspectRatio(this._scene.activeCamera),s=2*(o/d.width)-1,t=1-2*(p/d.height),u=a.Matrix.FromValues(q/2,0,0,0,0,r/2,0,0,0,0,1,0,s,t,0,1);this._effect.setMatrix("viewportMatrix",u),this._effect.setTexture("textureSampler",n.texture),this._effect.setFloat4("color",n.color.r*h,n.color.g*h,n.color.b*h,1),b.draw(!0,0,6)
}return b.setDepthBuffer(!0),b.setAlphaMode(a.Engine.ALPHA_DISABLE),!0},b.prototype.dispose=function(){for(this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null);this.lensFlares.length;)this.lensFlares[0].dispose();var a=this._scene.lensFlareSystems.indexOf(this);this._scene.lensFlareSystems.splice(a,1)},b}();a.LensFlareSystem=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c){this.bu=a,this.bv=b,this.distance=c,this.faceId=0}return a}();a.IntersectionInfo=b;var c=function(){function b(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1}return b.prototype.getNormal=function(){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(a.VertexBuffer.NormalKind))return null;var b=this.pickedMesh.getIndices(),c=this.pickedMesh.getVerticesData(a.VertexBuffer.NormalKind),d=a.Vector3.FromArray(c,3*b[3*this.faceId]),e=a.Vector3.FromArray(c,3*b[3*this.faceId+1]),f=a.Vector3.FromArray(c,3*b[3*this.faceId+2]);return d=d.scale(this.bu),e=e.scale(this.bv),f=f.scale(1-this.bu-this.bv),new a.Vector3(d.x+e.x+f.x,d.y+e.y+f.y,d.z+e.z+f.z)},b.prototype.getTextureCoordinates=function(){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(a.VertexBuffer.UVKind))return null;var b=this.pickedMesh.getIndices(),c=this.pickedMesh.getVerticesData(a.VertexBuffer.UVKind),d=a.Vector2.FromArray(c,2*b[3*this.faceId]),e=a.Vector2.FromArray(c,2*b[3*this.faceId+1]),f=a.Vector2.FromArray(c,2*b[3*this.faceId+2]);return d=d.scale(this.bu),e=e.scale(this.bv),f=f.scale(1-this.bu-this.bv),new a.Vector2(d.x+e.x+f.x,d.y+e.y+f.y)},b}();a.PickingInfo=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h){this.engine=a,this.canvas=c,this.currentScene=b,this.sceneLoadedCallback=d,this.progressCallback=e,this.additionnalRenderLoopLogicCallback=f,this.textureLoadingCallback=g,this.startingProcessingFilesCallback=h}return b.prototype.monitorElementForDragNDrop=function(a){var b=this;a&&(this.elementToMonitor=a,this.elementToMonitor.addEventListener("dragenter",function(a){b.drag(a)},!1),this.elementToMonitor.addEventListener("dragover",function(a){b.drag(a)},!1),this.elementToMonitor.addEventListener("drop",function(a){b.drop(a)},!1))},b.prototype.renderFunction=function(){if(this.additionnalRenderLoopLogicCallback&&this.additionnalRenderLoopLogicCallback(),this.currentScene){if(this.textureLoadingCallback){var a=this.currentScene.getWaitingItemsCount();a>0&&this.textureLoadingCallback(a)}this.currentScene.render()}},b.prototype.drag=function(a){a.stopPropagation(),a.preventDefault()},b.prototype.drop=function(a){a.stopPropagation(),a.preventDefault(),this.loadFiles(a)},b.prototype.loadFiles=function(b){var c=this,d=this;this.startingProcessingFilesCallback&&this.startingProcessingFilesCallback();var e,f;if(b&&b.dataTransfer&&b.dataTransfer.files&&(f=b.dataTransfer.files),b&&b.target&&b.target.files&&(f=b.target.files),f&&f.length>0){for(var g=0;g<f.length;g++)switch(f[g].type){case"image/jpeg":case"image/png":a.FilesInput.FilesTextures[f[g].name]=f[g];break;case"image/targa":case"image/vnd.ms-dds":a.FilesInput.FilesToLoad[f[g].name]=f[g];break;default:-1!==f[g].name.indexOf(".babylon")&&-1===f[g].name.indexOf(".manifest")&&-1===f[g].name.indexOf(".incremental")&&-1===f[g].name.indexOf(".babylonmeshdata")&&-1===f[g].name.indexOf(".babylongeometrydata")&&(e=f[g])}e?(this.currentScene&&(this.engine.stopRenderLoop(),this.currentScene.dispose()),a.SceneLoader.Load("file:",e,this.engine,function(a){d.currentScene=a,d.currentScene.executeWhenReady(function(){d.currentScene.activeCamera&&d.currentScene.activeCamera.attachControl(d.canvas),d.sceneLoadedCallback&&d.sceneLoadedCallback(e,d.currentScene),d.engine.runRenderLoop(function(){d.renderFunction()})})},function(a){c.progressCallback&&c.progressCallback(a)})):a.Tools.Error("Please provide a valid .babylon file.")}},b.FilesTextures=new Array,b.FilesToLoad=new Array,b}();a.FilesInput=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this._registeredMeshes=[],this.updateBodyPosition=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent){var d=c.body.body;return d.setPosition(a.position.x,a.position.y,a.position.z),void d.setOrientation(a.rotation.x,a.rotation.y,a.rotation.z)}if(c.mesh.parent===a){a.computeWorldMatrix(!0),c.mesh.computeWorldMatrix(!0);var e=c.mesh.getAbsolutePosition(),f=a.rotation;return d=c.body.body,d.setPosition(e.x,e.y,e.z),void d.setOrientation(f.x,f.y,f.z)}}}}return b.prototype._checkWithEpsilon=function(b){return b<a.PhysicsEngine.Epsilon?a.PhysicsEngine.Epsilon:b},b.prototype.initialize=function(){this._world=new OIMO.World,this._world.clear()},b.prototype.setGravity=function(a){this._world.gravity=a},b.prototype.registerMesh=function(b,c,d){var e=null;switch(this.unregisterMesh(b),b.computeWorldMatrix(!0),c){case a.PhysicsEngine.SphereImpostor:var f=b.getBoundingInfo().boundingBox,g=f.maximumWorld.x-f.minimumWorld.x,h=f.maximumWorld.y-f.minimumWorld.y,i=f.maximumWorld.z-f.minimumWorld.z,j=Math.max(this._checkWithEpsilon(g),this._checkWithEpsilon(h),this._checkWithEpsilon(i))/2;e=new OIMO.Body({type:"sphere",size:[j],pos:[b.position.x,b.position.y,b.position.z],rot:[b.rotation.x/OIMO.TO_RAD,b.rotation.y/OIMO.TO_RAD,b.rotation.z/OIMO.TO_RAD],move:0!=d.mass,config:[d.mass,d.friction,d.restitution],world:this._world}),this._registeredMeshes.push({mesh:b,body:e});break;case a.PhysicsEngine.PlaneImpostor:case a.PhysicsEngine.BoxImpostor:f=b.getBoundingInfo().boundingBox;var k=f.minimumWorld,l=f.maximumWorld,m=l.subtract(k),n=this._checkWithEpsilon(m.x),o=this._checkWithEpsilon(m.y),p=this._checkWithEpsilon(m.z);e=new OIMO.Body({type:"box",size:[n,o,p],pos:[b.position.x,b.position.y,b.position.z],rot:[b.rotation.x/OIMO.TO_RAD,b.rotation.y/OIMO.TO_RAD,b.rotation.z/OIMO.TO_RAD],move:0!=d.mass,config:[d.mass,d.friction,d.restitution],world:this._world}),this._registeredMeshes.push({mesh:b,body:e})}return e},b.prototype.registerMeshesAsCompound=function(a,b){for(var c=[],d=[],e=[],f=[],g=a[0].mesh,h=0;h<a.length;h++){var i=a[h],j=this._createBodyAsCompound(i,b,g);c.push(j.type),d.push.apply(d,j.size),e.push.apply(e,j.pos),f.push.apply(f,j.rot)}var k=new OIMO.Body({type:c,size:d,pos:e,rot:f,move:0!=b.mass,config:[b.mass,b.friction,b.restitution],world:this._world});return this._registeredMeshes.push({mesh:g,body:k}),k},b.prototype._createBodyAsCompound=function(b){var c=null,d=b.mesh;switch(b.impostor){case a.PhysicsEngine.SphereImpostor:var e=d.getBoundingInfo().boundingBox,f=e.maximumWorld.x-e.minimumWorld.x,g=e.maximumWorld.y-e.minimumWorld.y,h=e.maximumWorld.z-e.minimumWorld.z,i=Math.max(this._checkWithEpsilon(f),this._checkWithEpsilon(g),this._checkWithEpsilon(h))/2;c={type:"sphere",size:[i,-1,-1],pos:[d.position.x,d.position.y,d.position.z],rot:[d.rotation.x/OIMO.TO_RAD,d.rotation.y/OIMO.TO_RAD,d.rotation.z/OIMO.TO_RAD]};break;case a.PhysicsEngine.PlaneImpostor:case a.PhysicsEngine.BoxImpostor:e=d.getBoundingInfo().boundingBox;var j=e.minimumWorld,k=e.maximumWorld,l=k.subtract(j),m=this._checkWithEpsilon(l.x),n=this._checkWithEpsilon(l.y),o=this._checkWithEpsilon(l.z),p=d.position;c={type:"box",size:[m,n,o],pos:[p.x,p.y,p.z],rot:[d.rotation.x/OIMO.TO_RAD,d.rotation.y/OIMO.TO_RAD,d.rotation.z/OIMO.TO_RAD]}}return c},b.prototype.unregisterMesh=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent)return c.body&&(this._world.removeRigidBody(c.body.body),this._unbindBody(c.body)),void this._registeredMeshes.splice(b,1)}},b.prototype._unbindBody=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];c.body===a&&(c.body=null)}},b.prototype.applyImpulse=function(a,b,c){for(var d=0;d<this._registeredMeshes.length;d++){var e=this._registeredMeshes[d];if(e.mesh===a||e.mesh===a.parent)return void e.body.body.applyImpulse(c.scale(OIMO.INV_SCALE),b.scale(OIMO.INV_SCALE))}},b.prototype.createLink=function(a,b,c,d,e){for(var f=null,g=null,h=0;h<this._registeredMeshes.length;h++){var i=this._registeredMeshes[h];i.mesh===a?f=i.body.body:i.mesh===b&&(g=i.body.body)}return f&&g?(e||(e={}),new OIMO.Link({type:e.type,body1:f,body2:g,min:e.min,max:e.max,axe1:e.axe1,axe2:e.axe2,pos1:[c.x,c.y,c.z],pos2:[d.x,d.y,d.z],collision:e.collision,spring:e.spring,world:this._world}),!0):!1},b.prototype.dispose=function(){for(this._world.clear();this._registeredMeshes.length;)this.unregisterMesh(this._registeredMeshes[0].mesh)},b.prototype.isSupported=function(){return void 0!==OIMO},b.prototype._getLastShape=function(a){for(var b=a.shapes;b.next;)b=b.next;return b},b.prototype.runOneStep=function(){this._world.step();for(var b,c=this._registeredMeshes.length;c--;){var d=this._registeredMeshes[c].body.body,e=this._registeredMeshes[c].mesh;if(!d.sleeping)if(d.shapes.next){var f=this._getLastShape(d);e.position.x=f.position.x*OIMO.WORLD_SCALE,e.position.y=f.position.y*OIMO.WORLD_SCALE,e.position.z=f.position.z*OIMO.WORLD_SCALE;var g=a.Matrix.FromArray(d.getMatrix());e.rotationQuaternion||(e.rotationQuaternion=new a.Quaternion(0,0,0,1)),e.rotationQuaternion.fromRotationMatrix(g)}else b=d.getMatrix(),g=a.Matrix.FromArray(b),e.position.x=g.m[12],e.position.y=g.m[13],e.position.z=g.m[14],e.rotationQuaternion||(e.rotationQuaternion=new a.Quaternion(0,0,0,1)),e.rotationQuaternion.fromRotationMatrix(g)}},b}();a.OimoJSPlugin=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this._currentPlugin=b||new a.OimoJSPlugin}return b.prototype._initialize=function(a){this._currentPlugin.initialize(),this._setGravity(a)},b.prototype._runOneStep=function(a){a>.1?a=.1:0>=a&&(a=1/60),this._currentPlugin.runOneStep(a)},b.prototype._setGravity=function(b){this.gravity=b||new a.Vector3(0,-9.82,0),this._currentPlugin.setGravity(this.gravity)},b.prototype._registerMesh=function(a,b,c){return this._currentPlugin.registerMesh(a,b,c)},b.prototype._registerMeshesAsCompound=function(a,b){return this._currentPlugin.registerMeshesAsCompound(a,b)},b.prototype._unregisterMesh=function(a){this._currentPlugin.unregisterMesh(a)},b.prototype._applyImpulse=function(a,b,c){this._currentPlugin.applyImpulse(a,b,c)},b.prototype._createLink=function(a,b,c,d,e){return this._currentPlugin.createLink(a,b,c,d,e)},b.prototype._updateBodyPosition=function(a){this._currentPlugin.updateBodyPosition(a)},b.prototype.dispose=function(){this._currentPlugin.dispose()},b.prototype.isSupported=function(){return this._currentPlugin.isSupported()},b.NoImpostor=0,b.SphereImpostor=1,b.BoxImpostor=2,b.PlaneImpostor=3,b.CompoundImpostor=4,b.MeshImpostor=4,b.CapsuleImpostor=5,b.ConeImpostor=6,b.CylinderImpostor=7,b.ConvexHullImpostor=8,b.Epsilon=.001,b}();a.PhysicsEngine=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(b){var c={};if(c.name=b.name,c.id=b.id,c.tags=a.Tags.GetTags(b),b instanceof a.PointLight)c.type=0,c.position=b.position.asArray();else if(b instanceof a.DirectionalLight){c.type=1;var d=b;c.position=d.position.asArray(),c.direction=d.direction.asArray()}else if(b instanceof a.SpotLight){c.type=2;var e=b;c.position=e.position.asArray(),c.direction=e.position.asArray(),c.angle=e.angle,c.exponent=e.exponent}else if(b instanceof a.HemisphericLight){c.type=3;var f=b;c.direction=f.direction.asArray(),c.groundColor=f.groundColor.asArray()}return b.intensity&&(c.intensity=b.intensity),c.range=b.range,c.diffuse=b.diffuse.asArray(),c.specular=b.specular.asArray(),c},c=function(b){var c={};return c.name=b.name,c.tags=a.Tags.GetTags(b),c.id=b.id,c.position=b.position.asArray(),b.parent&&(c.parentId=b.parent.id),c.rotation=b.rotation.asArray(),b.lockedTarget&&b.lockedTarget.id&&(c.lockedTargetId=b.lockedTarget.id),c.fov=b.fov,c.minZ=b.minZ,c.maxZ=b.maxZ,c.speed=b.speed,c.inertia=b.inertia,c.checkCollisions=b.checkCollisions,c.applyGravity=b.applyGravity,b.ellipsoid&&(c.ellipsoid=b.ellipsoid.asArray()),d(b,c),c.layerMask=b.layerMask,c},d=function(a,b){if(a.animations){b.animations=[];for(var c=0;c<a.animations.length;c++){var d=a.animations[c];b.animations.push(e(d))}}},e=function(b){var c={};c.name=b.name,c.property=b.targetProperty,c.framePerSecond=b.framePerSecond,c.dataType=b.dataType,c.loopBehavior=b.loopMode;var d=b.dataType;c.keys=[];for(var e=b.getKeys(),f=0;f<e.length;f++){var g=e[f],h={};switch(h.frame=g.frame,d){case a.Animation.ANIMATIONTYPE_FLOAT:h.values=[g.value];break;case a.Animation.ANIMATIONTYPE_QUATERNION:case a.Animation.ANIMATIONTYPE_MATRIX:case a.Animation.ANIMATIONTYPE_VECTOR3:h.values=g.value.asArray()}c.keys.push(h)}return c},f=function(b){var c={};c.name=b.name,c.id=b.id,c.tags=a.Tags.GetTags(b),c.materials=[];for(var d=0;d<b.subMaterials.length;d++){var e=b.subMaterials[d];c.materials.push(e?e.id:null)}return c},g=function(b){var c={};return c.name=b.name,c.ambient=b.ambientColor.asArray(),c.diffuse=b.diffuseColor.asArray(),c.specular=b.specularColor.asArray(),c.specularPower=b.specularPower,c.emissive=b.emissiveColor.asArray(),c.alpha=b.alpha,c.id=b.id,c.tags=a.Tags.GetTags(b),c.backFaceCulling=b.backFaceCulling,b.diffuseTexture&&(c.diffuseTexture=h(b.diffuseTexture)),b.ambientTexture&&(c.ambientTexture=h(b.ambientTexture)),b.opacityTexture&&(c.opacityTexture=h(b.opacityTexture)),b.reflectionTexture&&(c.reflectionTexture=h(b.reflectionTexture)),b.emissiveTexture&&(c.emissiveTexture=h(b.emissiveTexture)),b.specularTexture&&(c.specularTexture=h(b.specularTexture)),b.bumpTexture&&(c.bumpTexture=h(b.bumpTexture)),c},h=function(b){var c={};if(!b.name)return null;if(b instanceof a.CubeTexture)return c.name=b.name,c.hasAlpha=b.hasAlpha,c.level=b.level,c.coordinatesMode=b.coordinatesMode,c;if(b instanceof a.MirrorTexture){var e=b;c.renderTargetSize=e.getRenderSize(),c.renderList=[];for(var f=0;f<e.renderList.length;f++)c.renderList.push(e.renderList[f].id);c.mirrorPlane=e.mirrorPlane.asArray()}else if(b instanceof a.RenderTargetTexture){var g=b;for(c.renderTargetSize=g.getRenderSize(),c.renderList=[],f=0;f<g.renderList.length;f++)c.renderList.push(g.renderList[f].id)}var h=b;return c.name=b.name,c.hasAlpha=b.hasAlpha,c.level=b.level,c.coordinatesIndex=b.coordinatesIndex,c.coordinatesMode=b.coordinatesMode,c.uOffset=h.uOffset,c.vOffset=h.vOffset,c.uScale=h.uScale,c.vScale=h.vScale,c.uAng=h.uAng,c.vAng=h.vAng,c.wAng=h.wAng,c.wrapU=b.wrapU,c.wrapV=b.wrapV,d(b,c),c},i=function(a){var b={};b.name=a.name,b.id=a.id,b.bones=[];for(var c=0;c<a.bones.length;c++){var d=a.bones[c],f={parentBoneIndex:d.getParent()?a.bones.indexOf(d.getParent()):-1,name:d.name,matrix:d.getLocalMatrix().toArray()};b.bones.push(f),d.animations&&d.animations.length>0&&(f.animation=e(d.animations[0]))}return b},j=function(a){var b={};return b.emitterId=a.emitter.id,b.capacity=a.getCapacity(),a.particleTexture&&(b.textureName=a.particleTexture.name),b.minAngularSpeed=a.minAngularSpeed,b.maxAngularSpeed=a.maxAngularSpeed,b.minSize=a.minSize,b.maxSize=a.maxSize,b.minLifeTime=a.minLifeTime,b.maxLifeTime=a.maxLifeTime,b.emitRate=a.emitRate,b.minEmitBox=a.minEmitBox.asArray(),b.maxEmitBox=a.maxEmitBox.asArray(),b.gravity=a.gravity.asArray(),b.direction1=a.direction1.asArray(),b.direction2=a.direction2.asArray(),b.color1=a.color1.asArray(),b.color2=a.color2.asArray(),b.colorDead=a.colorDead.asArray(),b.updateSpeed=a.updateSpeed,b.targetStopDuration=a.targetStopDuration,b.textureMask=a.textureMask.asArray(),b.blendMode=a.blendMode,b},k=function(b){var c={};c.emitterId=b.getEmitter().id,c.borderLimit=b.borderLimit,c.flares=[];for(var d=0;d<b.lensFlares.length;d++){var e=b.lensFlares[d];c.flares.push({size:e.size,position:e.position,color:e.color.asArray(),textureName:a.Tools.GetFilename(e.texture.name)})}return c},l=function(a){var b={},c=a.getShadowGenerator();b.lightId=a.id,b.mapSize=c.getShadowMap().getRenderSize(),b.useVarianceShadowMap=c.useVarianceShadowMap,b.usePoissonSampling=c.usePoissonSampling,b.renderList=[];for(var d=0;d<c.getShadowMap().renderList.length;d++){var e=c.getShadowMap().renderList[d];b.renderList.push(e.id)}return b},m=[],n=function(b,c){if(!m[b.id]){if(b instanceof a.Geometry.Primitives.Box)c.boxes.push(r(b));else if(b instanceof a.Geometry.Primitives.Sphere)c.spheres.push(s(b));else if(b instanceof a.Geometry.Primitives.Cylinder)c.cylinders.push(t(b));else if(b instanceof a.Geometry.Primitives.Torus)c.toruses.push(u(b));else if(b instanceof a.Geometry.Primitives.Ground)c.grounds.push(v(b));else if(b instanceof a.Geometry.Primitives.Plane)c.planes.push(w(b));else if(b instanceof a.Geometry.Primitives.TorusKnot)c.torusKnots.push(x(b));else{if(b instanceof a.Geometry.Primitives._Primitive)throw new Error("Unknow primitive type");c.vertexData.push(p(b))}m[b.id]=!0}},o=function(b){var c={};return c.id=b.id,a.Tags.HasTags(b)&&(c.tags=a.Tags.GetTags(b)),c},p=function(b){var c=o(b);return b.isVerticesDataPresent(a.VertexBuffer.PositionKind)&&(c.positions=b.getVerticesData(a.VertexBuffer.PositionKind)),b.isVerticesDataPresent(a.VertexBuffer.NormalKind)&&(c.normals=b.getVerticesData(a.VertexBuffer.NormalKind)),b.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(c.uvs=b.getVerticesData(a.VertexBuffer.UVKind)),b.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(c.uvs2=b.getVerticesData(a.VertexBuffer.UV2Kind)),b.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(c.colors=b.getVerticesData(a.VertexBuffer.ColorKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&(c.matricesIndices=b.getVerticesData(a.VertexBuffer.MatricesIndicesKind),c.matricesIndices._isExpanded=!0),b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(c.matricesWeights=b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)),c.indices=b.getIndices(),c},q=function(a){var b=o(a);return b.canBeRegenerated=a.canBeRegenerated(),b},r=function(a){var b=q(a);return b.size=a.size,b},s=function(a){var b=q(a);return b.segments=a.segments,b.diameter=a.diameter,b},t=function(a){var b=q(a);return b.height=a.height,b.diameterTop=a.diameterTop,b.diameterBottom=a.diameterBottom,b.tessellation=a.tessellation,b},u=function(a){var b=q(a);return b.diameter=a.diameter,b.thickness=a.thickness,b.tessellation=a.tessellation,b},v=function(a){var b=q(a);return b.width=a.width,b.height=a.height,b.subdivisions=a.subdivisions,b},w=function(a){var b=q(a);return b.size=a.size,b},x=function(a){var b=q(a);return b.radius=a.radius,b.tube=a.tube,b.radialSegments=a.radialSegments,b.tubularSegments=a.tubularSegments,b.p=a.p,b.q=a.q,b},y=function(b,c){var e={};e.name=b.name,e.id=b.id,a.Tags.HasTags(b)&&(e.tags=a.Tags.GetTags(b)),e.position=b.position.asArray(),b.rotationQuaternion?e.rotationQuaternion=b.rotationQuaternion.asArray():b.rotation&&(e.rotation=b.rotation.asArray()),e.scaling=b.scaling.asArray(),e.localMatrix=b.getPivotMatrix().asArray(),e.isEnabled=b.isEnabled(),e.isVisible=b.isVisible,e.infiniteDistance=b.infiniteDistance,e.pickable=b.isPickable,e.receiveShadows=b.receiveShadows,e.billboardMode=b.billboardMode,e.visibility=b.visibility,e.checkCollisions=b.checkCollisions,b.parent&&(e.parentId=b.parent.id);var f=b._geometry;if(f){var g=f.id;e.geometryId=g,b.getScene().getGeometryByID(g)||n(f,c.geometries),e.subMeshes=[];for(var h=0;h<b.subMeshes.length;h++){var i=b.subMeshes[h];e.subMeshes.push({materialIndex:i.materialIndex,verticesStart:i.verticesStart,verticesCount:i.verticesCount,indexStart:i.indexStart,indexCount:i.indexCount})}}if(b.material?e.materialId=b.material.id:b.material=null,b.skeleton&&(e.skeletonId=b.skeleton.id),b.getPhysicsImpostor()!==a.PhysicsEngine.NoImpostor)switch(e.physicsMass=b.getPhysicsMass(),e.physicsFriction=b.getPhysicsFriction(),e.physicsRestitution=b.getPhysicsRestitution(),b.getPhysicsImpostor()){case a.PhysicsEngine.BoxImpostor:e.physicsImpostor=1;break;case a.PhysicsEngine.SphereImpostor:e.physicsImpostor=2}return d(b,e),e.layerMask=b.layerMask,e},z=function(){function d(){}return d.Serialize=function(d){var e={};e.useDelayedTextureLoading=d.useDelayedTextureLoading,e.autoClear=d.autoClear,e.clearColor=d.clearColor.asArray(),e.ambientColor=d.ambientColor.asArray(),e.gravity=d.gravity.asArray(),d.fogMode&&0!==d.fogMode&&(e.fogMode=d.fogMode,e.fogColor=d.fogColor.asArray(),e.fogStart=d.fogStart,e.fogEnd=d.fogEnd,e.fogDensity=d.fogDensity),e.lights=[];for(var h=0;h<d.lights.length;h++){var o=d.lights[h];e.lights.push(b(o))}for(e.cameras=[],h=0;h<d.cameras.length;h++){var p=d.cameras[h];p instanceof a.FreeCamera&&e.cameras.push(c(p))}for(d.activeCamera&&(e.activeCameraID=d.activeCamera.id),e.materials=[],e.multiMaterials=[],h=0;h<d.materials.length;h++){var q=d.materials[h];q instanceof a.StandardMaterial?e.materials.push(g(q)):q instanceof a.MultiMaterial&&e.multiMaterials.push(f(q))}for(e.skeletons=[],h=0;h<d.skeletons.length;h++)e.skeletons.push(i(d.skeletons[h]));e.geometries={},e.geometries.boxes=[],e.geometries.spheres=[],e.geometries.cylinders=[],e.geometries.toruses=[],e.geometries.grounds=[],e.geometries.planes=[],e.geometries.torusKnots=[],e.geometries.vertexData=[],m=[];for(var r=d.getGeometries(),h=0;h<r.length;h++){var s=r[h];s.isReady()&&n(s,e.geometries)}for(e.meshes=[],h=0;h<d.meshes.length;h++){var t=d.meshes[h];if(t instanceof a.Mesh){var u=t;(u.delayLoadState===a.Engine.DELAYLOADSTATE_LOADED||u.delayLoadState===a.Engine.DELAYLOADSTATE_NONE)&&e.meshes.push(y(u,e))}}for(e.particleSystems=[],h=0;h<d.particleSystems.length;h++)e.particleSystems.push(j(d.particleSystems[h]));for(e.lensFlareSystems=[],h=0;h<d.lensFlareSystems.length;h++)e.lensFlareSystems.push(k(d.lensFlareSystems[h]));for(e.shadowGenerators=[],h=0;h<d.lights.length;h++)o=d.lights[h],o.getShadowGenerator()&&e.shadowGenerators.push(l(o));return e},d}();a.SceneSerializer=z}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return Object.defineProperty(b,"ForceFullSceneLoadingForIncremental",{get:function(){return b._ForceFullSceneLoadingForIncremental},set:function(a){b._ForceFullSceneLoadingForIncremental=a},enumerable:!0,configurable:!0}),b._getPluginForFilename=function(a){for(var b=a.lastIndexOf("."),c=a.substring(b).toLowerCase(),d=0;d<this._registeredPlugins.length;d++){var e=this._registeredPlugins[d];if(-1!==e.extensions.indexOf(c))return e}return this._registeredPlugins[this._registeredPlugins.length-1]},b.RegisterPlugin=function(a){a.extensions=a.extensions.toLowerCase(),b._registeredPlugins.push(a)},b.ImportMesh=function(b,c,d,e,f,g,h){var i=this,j=function(){e.database=k;var j=i._getPluginForFilename(d),l=function(a){var g=[],i=[],k=[];return j.importMesh(b,e,a,c,g,i,k)?void(f&&(e.importedMeshesFiles.push(c+d),f(g,i,k))):void(h&&h(e))};return d.substr&&"data:"===d.substr(0,5)?void l(d.substr(5)):void a.Tools.LoadFile(c+d,function(a){l(a)},g,k)},k=new a.Database(c+d,j)},b.Load=function(b,c,d,e,f,g){var h,i=this._getPluginForFilename(c.name||c),j=function(c){var f=new a.Scene(d);return f.database=h,i.load(f,c,b)?void(e&&e(f)):void(g&&g(f))},k=function(){a.Tools.LoadFile(b+c,j,f,h)};return c.substr&&"data:"===c.substr(0,5)?void j(c.substr(5)):void(-1===b.indexOf("file:")?h=new a.Database(b+c,k):a.Tools.ReadFile(c,j,f))},b._ForceFullSceneLoadingForIncremental=!1,b._registeredPlugins=new Array,b}();a.SceneLoader=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(){var b=function(b,c,d){var e=new a.CubeTexture(b+c.name,d);return e.name=c.name,e.hasAlpha=c.hasAlpha,e.level=c.level,e.coordinatesMode=c.coordinatesMode,e},c=function(c,d,e){if(!d.name&&!d.isRenderTarget)return null;if(d.isCube)return b(c,d,e);var f;if(d.mirrorPlane?(f=new a.MirrorTexture(d.name,d.renderTargetSize,e),f._waitingRenderList=d.renderList,f.mirrorPlane=a.Plane.FromArray(d.mirrorPlane)):d.isRenderTarget?(f=new a.RenderTargetTexture(d.name,d.renderTargetSize,e),f._waitingRenderList=d.renderList):f=new a.Texture(c+d.name,e),f.name=d.name,f.hasAlpha=d.hasAlpha,f.getAlphaFromRGB=d.getAlphaFromRGB,f.level=d.level,f.coordinatesIndex=d.coordinatesIndex,f.coordinatesMode=d.coordinatesMode,f.uOffset=d.uOffset,f.vOffset=d.vOffset,f.uScale=d.uScale,f.vScale=d.vScale,f.uAng=d.uAng,f.vAng=d.vAng,f.wAng=d.wAng,f.wrapU=d.wrapU,f.wrapV=d.wrapV,d.animations)for(var g=0;g<d.animations.length;g++){var h=d.animations[g];f.animations.push(k(h))}return f},d=function(b,c){for(var d=new a.Skeleton(b.name,b.id,c),e=0;e<b.bones.length;e++){var f=b.bones[e],g=null;f.parentBoneIndex>-1&&(g=d.bones[f.parentBoneIndex]);var h=new a.Bone(f.name,d,g,a.Matrix.FromArray(f.matrix));f.animation&&h.animations.push(k(f.animation))}return d},e=function(b,d,e){var f;return f=new a.StandardMaterial(b.name,d),f.ambientColor=a.Color3.FromArray(b.ambient),f.diffuseColor=a.Color3.FromArray(b.diffuse),f.specularColor=a.Color3.FromArray(b.specular),f.specularPower=b.specularPower,f.emissiveColor=a.Color3.FromArray(b.emissive),f.alpha=b.alpha,f.id=b.id,a.Tags.AddTagsTo(f,b.tags),f.backFaceCulling=b.backFaceCulling,f.wireframe=b.wireframe,b.diffuseTexture&&(f.diffuseTexture=c(e,b.diffuseTexture,d)),b.ambientTexture&&(f.ambientTexture=c(e,b.ambientTexture,d)),b.opacityTexture&&(f.opacityTexture=c(e,b.opacityTexture,d)),b.reflectionTexture&&(f.reflectionTexture=c(e,b.reflectionTexture,d)),b.emissiveTexture&&(f.emissiveTexture=c(e,b.emissiveTexture,d)),b.specularTexture&&(f.specularTexture=c(e,b.specularTexture,d)),b.bumpTexture&&(f.bumpTexture=c(e,b.bumpTexture,d)),f},f=function(a,b,c,d){for(var f=0;f<b.materials.length;f++){var g=b.materials[f];if(g.id===a)return e(g,c,d)}return null},g=function(b,c){var d=new a.MultiMaterial(b.name,c);d.id=b.id,a.Tags.AddTagsTo(d,b.tags);for(var e=0;e<b.materials.length;e++){var f=b.materials[e];d.subMaterials.push(f?c.getMaterialByID(f):null)}return d},h=function(b,c,d){var e=c.getLastEntryByID(b.emitterId),f=new a.LensFlareSystem("lensFlareSystem#"+b.emitterId,e,c);f.borderLimit=b.borderLimit;for(var g=0;g<b.flares.length;g++){var h=b.flares[g];new a.LensFlare(h.size,h.position,a.Color3.FromArray(h.color),d+h.textureName,f)}return f},i=function(b,c,d){var e=c.getLastMeshByID(b.emitterId),f=new a.ParticleSystem("particles#"+e.name,b.capacity,c);return b.textureName&&(f.particleTexture=new a.Texture(d+b.textureName,c),f.particleTexture.name=b.textureName),f.minAngularSpeed=b.minAngularSpeed,f.maxAngularSpeed=b.maxAngularSpeed,f.minSize=b.minSize,f.maxSize=b.maxSize,f.minLifeTime=b.minLifeTime,f.maxLifeTime=b.maxLifeTime,f.emitter=e,f.emitRate=b.emitRate,f.minEmitBox=a.Vector3.FromArray(b.minEmitBox),f.maxEmitBox=a.Vector3.FromArray(b.maxEmitBox),f.gravity=a.Vector3.FromArray(b.gravity),f.direction1=a.Vector3.FromArray(b.direction1),f.direction2=a.Vector3.FromArray(b.direction2),f.color1=a.Color4.FromArray(b.color1),f.color2=a.Color4.FromArray(b.color2),f.colorDead=a.Color4.FromArray(b.colorDead),f.updateSpeed=b.updateSpeed,f.targetStopDuration=b.targetStopFrame,f.textureMask=a.Color4.FromArray(b.textureMask),f.blendMode=b.blendMode,f.start(),f},j=function(b,c){for(var d=c.getLightByID(b.lightId),e=new a.ShadowGenerator(b.mapSize,d),f=0;f<b.renderList.length;f++){var g=c.getMeshByID(b.renderList[f]);e.getShadowMap().renderList.push(g)}return b.usePoissonSampling?e.usePoissonSampling=!0:e.useVarianceShadowMap=b.useVarianceShadowMap,e},k=function(b){for(var c=new a.Animation(b.name,b.property,b.framePerSecond,b.dataType,b.loopBehavior),d=b.dataType,e=[],f=0;f<b.keys.length;f++){var g,h=b.keys[f];switch(d){case a.Animation.ANIMATIONTYPE_FLOAT:g=h.values[0];break;case a.Animation.ANIMATIONTYPE_QUATERNION:g=a.Quaternion.FromArray(h.values);break;case a.Animation.ANIMATIONTYPE_MATRIX:g=a.Matrix.FromArray(h.values);break;case a.Animation.ANIMATIONTYPE_VECTOR3:default:g=a.Vector3.FromArray(h.values)}e.push({frame:h.frame,value:g})}return c.setKeys(e),c},l=function(b,c){var d;switch(b.type){case 0:d=new a.PointLight(b.name,a.Vector3.FromArray(b.position),c);break;case 1:d=new a.DirectionalLight(b.name,a.Vector3.FromArray(b.direction),c),d.position=a.Vector3.FromArray(b.position);break;case 2:d=new a.SpotLight(b.name,a.Vector3.FromArray(b.position),a.Vector3.FromArray(b.direction),b.angle,b.exponent,c);break;case 3:d=new a.HemisphericLight(b.name,a.Vector3.FromArray(b.direction),c),d.groundColor=a.Color3.FromArray(b.groundColor)}if(d.id=b.id,a.Tags.AddTagsTo(d,b.tags),void 0!==b.intensity&&(d.intensity=b.intensity),b.range&&(d.range=b.range),d.diffuse=a.Color3.FromArray(b.diffuse),d.specular=a.Color3.FromArray(b.specular),b.excludedMeshesIds&&(d._excludedMeshesIds=b.excludedMeshesIds),b.animations)for(var e=0;e<b.animations.length;e++){var f=b.animations[e];d.animations.push(k(f))}b.autoAnimate&&c.beginAnimation(d,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1)},m=function(b,c){var d=new a.FreeCamera(b.name,a.Vector3.FromArray(b.position),c);if(d.id=b.id,a.Tags.AddTagsTo(d,b.tags),b.parentId&&(d._waitingParentId=b.parentId),b.target?d.setTarget(a.Vector3.FromArray(b.target)):d.rotation=a.Vector3.FromArray(b.rotation),b.lockedTargetId&&(d._waitingLockedTargetId=b.lockedTargetId),d.fov=b.fov,d.minZ=b.minZ,d.maxZ=b.maxZ,d.speed=b.speed,d.inertia=b.inertia,d.checkCollisions=b.checkCollisions,d.applyGravity=b.applyGravity,b.ellipsoid&&(d.ellipsoid=a.Vector3.FromArray(b.ellipsoid)),b.animations)for(var e=0;e<b.animations.length;e++){var f=b.animations[e];d.animations.push(k(f))}return b.autoAnimate&&c.beginAnimation(d,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1),d.layerMask=b.layerMask&&!isNaN(b.layerMask)?Math.abs(parseInt(b.layerMask)):4294967295,d},n=function(a,b){var c=a.id;return b.getGeometryByID(c)},o=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Box(b.id,c,b.size,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},p=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Sphere(b.id,c,b.segments,b.diameter,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},q=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Cylinder(b.id,c,b.height,b.diameterTop,b.diameterBottom,b.tessellation,b.subdivisions,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},r=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Torus(b.id,c,b.diameter,b.thickness,b.tessellation,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},s=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Ground(b.id,c,b.width,b.height,b.subdivisions,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},t=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Plane(b.id,c,b.size,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},u=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.TorusKnot(b.id,c,b.radius,b.tube,b.radialSegments,b.tubularSegments,b.p,b.q,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},v=function(b,c,d){if(n(b,c))return null;var e=new a.Geometry(b.id,c);return a.Tags.AddTagsTo(e,b.tags),b.delayLoadingFile?(e.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED,e.delayLoadingFile=d+b.delayLoadingFile,e._boundingInfo=new a.BoundingInfo(a.Vector3.FromArray(b.boundingBoxMinimum),a.Vector3.FromArray(b.boundingBoxMaximum)),e._delayInfo=[],b.hasUVs&&e._delayInfo.push(a.VertexBuffer.UVKind),b.hasUVs2&&e._delayInfo.push(a.VertexBuffer.UV2Kind),b.hasColors&&e._delayInfo.push(a.VertexBuffer.ColorKind),b.hasMatricesIndices&&e._delayInfo.push(a.VertexBuffer.MatricesIndicesKind),b.hasMatricesWeights&&e._delayInfo.push(a.VertexBuffer.MatricesWeightsKind),e._delayLoadingFunction=y):y(b,e),c.pushGeometry(e,!0),e},w=function(b,c,d){var e=new a.Mesh(b.name,c);if(e.id=b.id,a.Tags.AddTagsTo(e,b.tags),e.position=a.Vector3.FromArray(b.position),b.rotationQuaternion?e.rotationQuaternion=a.Quaternion.FromArray(b.rotationQuaternion):b.rotation&&(e.rotation=a.Vector3.FromArray(b.rotation)),e.scaling=a.Vector3.FromArray(b.scaling),b.localMatrix?e.setPivotMatrix(a.Matrix.FromArray(b.localMatrix)):b.pivotMatrix&&e.setPivotMatrix(a.Matrix.FromArray(b.pivotMatrix)),e.setEnabled(b.isEnabled),e.isVisible=b.isVisible,e.infiniteDistance=b.infiniteDistance,e.showBoundingBox=b.showBoundingBox,e.showSubMeshesBoundingBox=b.showSubMeshesBoundingBox,void 0!==b.pickable&&(e.isPickable=b.pickable),e.receiveShadows=b.receiveShadows,e.billboardMode=b.billboardMode,void 0!==b.visibility&&(e.visibility=b.visibility),e.checkCollisions=b.checkCollisions,e._shouldGenerateFlatShading=b.useFlatShading,b.parentId&&(e.parent=c.getLastEntryByID(b.parentId)),b.delayLoadingFile?(e.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED,e.delayLoadingFile=d+b.delayLoadingFile,e._boundingInfo=new a.BoundingInfo(a.Vector3.FromArray(b.boundingBoxMinimum),a.Vector3.FromArray(b.boundingBoxMaximum)),e._delayInfo=[],b.hasUVs&&e._delayInfo.push(a.VertexBuffer.UVKind),b.hasUVs2&&e._delayInfo.push(a.VertexBuffer.UV2Kind),b.hasColors&&e._delayInfo.push(a.VertexBuffer.ColorKind),b.hasMatricesIndices&&e._delayInfo.push(a.VertexBuffer.MatricesIndicesKind),b.hasMatricesWeights&&e._delayInfo.push(a.VertexBuffer.MatricesWeightsKind),e._delayLoadingFunction=z,a.SceneLoader.ForceFullSceneLoadingForIncremental&&e._checkDelayState()):z(b,e),b.materialId?e.setMaterialByID(b.materialId):e.material=null,b.skeletonId>-1&&(e.skeleton=c.getLastSkeletonByID(b.skeletonId)),b.physicsImpostor&&(c.isPhysicsEnabled()||c.enablePhysics(),e.setPhysicsState({impostor:b.physicsImpostor,mass:b.physicsMass,friction:b.physicsFriction,restitution:b.physicsRestitution})),b.animations)for(var f=0;f<b.animations.length;f++){var g=b.animations[f];
e.animations.push(k(g))}if(b.autoAnimate&&c.beginAnimation(e,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1),e.layerMask=b.layerMask&&!isNaN(b.layerMask)?Math.abs(parseInt(b.layerMask)):4294967295,b.instances)for(var h=0;h<b.instances.length;h++){var i=b.instances[h],j=e.createInstance(i.name);if(a.Tags.AddTagsTo(j,i.tags),j.position=a.Vector3.FromArray(i.position),i.rotationQuaternion?j.rotationQuaternion=a.Quaternion.FromArray(i.rotationQuaternion):i.rotation&&(j.rotation=a.Vector3.FromArray(i.rotation)),j.scaling=a.Vector3.FromArray(i.scaling),j.checkCollisions=e.checkCollisions,b.animations)for(f=0;f<b.animations.length;f++)g=b.animations[f],j.animations.push(k(g))}return e},x=function(a,b,c){b=b instanceof Array?b:[b];for(var d in b)if(a.name===b[d])return c.push(a.id),!0;return a.parentId&&-1!==c.indexOf(a.parentId)?(c.push(a.id),!0):!1},y=function(b,c){var d=new a.VertexData,e=b.positions;e&&d.set(e,a.VertexBuffer.PositionKind);var f=b.normals;f&&d.set(f,a.VertexBuffer.NormalKind);var g=b.uvs;g&&d.set(g,a.VertexBuffer.UVKind);var h=b.uv2s;h&&d.set(h,a.VertexBuffer.UV2Kind);var i=b.colors;i&&d.set(i,a.VertexBuffer.ColorKind);var j=b.matricesIndices;j&&d.set(j,a.VertexBuffer.MatricesIndicesKind);var k=b.matricesWeights;k&&d.set(k,a.VertexBuffer.MatricesWeightsKind);var l=b.indices;l&&(d.indices=l),c.setAllVerticesData(d,b.updatable)},z=function(b,c){var d=c.getScene(),e=b.geometryId;if(e){var f=d.getGeometryByID(e);f&&f.applyToMesh(c)}else if(b.positions&&b.normals&&b.indices){if(c.setVerticesData(a.VertexBuffer.PositionKind,b.positions,!1),c.setVerticesData(a.VertexBuffer.NormalKind,b.normals,!1),b.uvs&&c.setVerticesData(a.VertexBuffer.UVKind,b.uvs,!1),b.uvs2&&c.setVerticesData(a.VertexBuffer.UV2Kind,b.uvs2,!1),b.colors&&c.setVerticesData(a.VertexBuffer.ColorKind,b.colors,!1),b.matricesIndices)if(b.matricesIndices._isExpanded)delete b.matricesIndices._isExpanded,c.setVerticesData(a.VertexBuffer.MatricesIndicesKind,b.matricesIndices,!1);else{for(var g=[],h=0;h<b.matricesIndices.length;h++){var i=b.matricesIndices[h];g.push(255&i),g.push((65280&i)>>8),g.push((16711680&i)>>16),g.push(i>>24)}c.setVerticesData(a.VertexBuffer.MatricesIndicesKind,g,!1)}b.matricesWeights&&c.setVerticesData(a.VertexBuffer.MatricesWeightsKind,b.matricesWeights,!1),c.setIndices(b.indices)}if(b.subMeshes){c.subMeshes=[];for(var j=0;j<b.subMeshes.length;j++){var k=b.subMeshes[j];new a.SubMesh(k.materialIndex,k.verticesStart,k.verticesCount,k.indexStart,k.indexCount,c)}}c._shouldGenerateFlatShading&&(c.convertToFlatShadedMesh(),delete c._shouldGenerateFlatShading),c.computeWorldMatrix(!0),d._selectionOctree&&d._selectionOctree.addMesh(c)};a.SceneLoader.RegisterPlugin({extensions:".babylon",importMesh:function(a,b,c,e,h,j,k){for(var l=JSON.parse(c),m=[],n=[],o=[],p=0;p<l.meshes.length;p++){var q=l.meshes[p];if(!a||x(q,a,o)){if(a instanceof Array&&delete a[a.indexOf(q.name)],q.materialId){var r=-1!==n.indexOf(q.materialId);if(!r)for(var s=0;s<l.multiMaterials.length;s++){var t=l.multiMaterials[s];if(t.id==q.materialId){for(var u=0;u<t.materials.length;u++){var v=t.materials[u];n.push(v),f(v,l,b,e)}n.push(t.id),g(t,b),r=!0;break}}r||(n.push(q.materialId),f(q.materialId,l,b,e))}if(q.skeletonId>-1&&b.skeletons){var y=m.indexOf(q.skeletonId)>-1;if(!y)for(var z=0;z<l.skeletons.length;z++){var A=l.skeletons[z];A.id===q.skeletonId&&(k.push(d(A,b)),m.push(A.id))}}var B=w(q,b,e);h.push(B)}}if(l.particleSystems)for(p=0;p<l.particleSystems.length;p++){var C=l.particleSystems[p];-1!==o.indexOf(C.emitterId)&&j.push(i(C,b,e))}return!0},load:function(b,c,f){var k=JSON.parse(c);b.useDelayedTextureLoading=k.useDelayedTextureLoading&&!a.SceneLoader.ForceFullSceneLoadingForIncremental,b.autoClear=k.autoClear,b.clearColor=a.Color3.FromArray(k.clearColor),b.ambientColor=a.Color3.FromArray(k.ambientColor),b.gravity=a.Vector3.FromArray(k.gravity),k.fogMode&&0!==k.fogMode&&(b.fogMode=k.fogMode,b.fogColor=a.Color3.FromArray(k.fogColor),b.fogStart=k.fogStart,b.fogEnd=k.fogEnd,b.fogDensity=k.fogDensity);for(var n=0;n<k.lights.length;n++){var x=k.lights[n];l(x,b)}for(n=0;n<k.cameras.length;n++){var y=k.cameras[n];m(y,b)}if(k.activeCameraID&&b.setActiveCameraByID(k.activeCameraID),k.materials)for(n=0;n<k.materials.length;n++){var z=k.materials[n];e(z,b,f)}if(k.multiMaterials)for(n=0;n<k.multiMaterials.length;n++){var A=k.multiMaterials[n];g(A,b)}if(k.skeletons)for(n=0;n<k.skeletons.length;n++){var B=k.skeletons[n];d(B,b)}var C=k.geometries;if(C){var D=C.boxes;if(D)for(n=0;n<D.length;n++){var E=D[n];o(E,b)}var F=C.spheres;if(F)for(n=0;n<F.length;n++){var G=F[n];p(G,b)}var H=C.cylinders;if(H)for(n=0;n<H.length;n++){var I=H[n];q(I,b)}var J=C.toruses;if(J)for(n=0;n<J.length;n++){var K=J[n];r(K,b)}var L=C.grounds;if(L)for(n=0;n<L.length;n++){var M=L[n];s(M,b)}var N=C.planes;if(N)for(n=0;n<N.length;n++){var O=N[n];t(O,b)}var P=C.torusKnots;if(P)for(n=0;n<P.length;n++){var Q=P[n];u(Q,b)}var R=C.vertexData;if(R)for(n=0;n<R.length;n++){var S=R[n];v(S,b,f)}}for(n=0;n<k.meshes.length;n++){var T=k.meshes[n];w(T,b,f)}for(n=0;n<b.cameras.length;n++){var U=b.cameras[n];if(U._waitingParentId&&(U.parent=b.getLastEntryByID(U._waitingParentId),delete U._waitingParentId),U instanceof a.FreeCamera){var V=U;V._waitingLockedTargetId&&(V.lockedTarget=b.getLastEntryByID(V._waitingLockedTargetId),delete V._waitingLockedTargetId)}}if(k.particleSystems)for(n=0;n<k.particleSystems.length;n++){var W=k.particleSystems[n];i(W,b,f)}if(k.lensFlareSystems)for(n=0;n<k.lensFlareSystems.length;n++){var X=k.lensFlareSystems[n];h(X,b,f)}if(k.shadowGenerators)for(n=0;n<k.shadowGenerators.length;n++){var Y=k.shadowGenerators[n];j(Y,b)}return!0}})}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=0,c=function(){function b(a,b,c){this.pos=a,this.normal=b,this.uv=c}return b.prototype.clone=function(){return new b(this.pos.clone(),this.normal.clone(),this.uv.clone())},b.prototype.flip=function(){this.normal=this.normal.scale(-1)},b.prototype.interpolate=function(c,d){return new b(a.Vector3.Lerp(this.pos,c.pos,d),a.Vector3.Lerp(this.normal,c.normal,d),a.Vector2.Lerp(this.uv,c.uv,d))},b}(),d=function(){function b(a,b){this.normal=a,this.w=b}return b.FromPoints=function(c,d,e){var f=e.subtract(c),g=d.subtract(c);if(0===f.lengthSquared()||0===g.lengthSquared())return null;var h=a.Vector3.Normalize(a.Vector3.Cross(f,g));return new b(h,a.Vector3.Dot(h,c))},b.prototype.clone=function(){return new b(this.normal.clone(),this.w)},b.prototype.flip=function(){this.normal.scaleInPlace(-1),this.w=-this.w},b.prototype.splitPolygon=function(c,d,f,g,h){for(var i=0,j=1,k=2,l=3,m=0,n=[],o=0;o<c.vertices.length;o++){var p=a.Vector3.Dot(this.normal,c.vertices[o].pos)-this.w,q=p<-b.EPSILON?k:p>b.EPSILON?j:i;m|=q,n.push(q)}switch(m){case i:(a.Vector3.Dot(this.normal,c.plane.normal)>0?d:f).push(c);break;case j:g.push(c);break;case k:h.push(c);break;case l:var r=[],s=[];for(o=0;o<c.vertices.length;o++){var t=(o+1)%c.vertices.length,u=n[o],v=n[t],w=c.vertices[o],x=c.vertices[t];if(u!=k&&r.push(w),u!=j&&s.push(u!=k?w.clone():w),(u|v)==l){p=(this.w-a.Vector3.Dot(this.normal,w.pos))/a.Vector3.Dot(this.normal,x.pos.subtract(w.pos));var y=w.interpolate(x,p);r.push(y),s.push(y.clone())}}if(r.length>=3){var z=new e(r,c.shared);z.plane&&g.push(z)}s.length>=3&&(z=new e(s,c.shared),z.plane&&h.push(z))}},b.EPSILON=1e-5,b}(),e=function(){function a(a,b){this.vertices=a,this.shared=b,this.plane=d.FromPoints(a[0].pos,a[1].pos,a[2].pos)}return a.prototype.clone=function(){var b=this.vertices.map(function(a){return a.clone()});return new a(b,this.shared)},a.prototype.flip=function(){this.vertices.reverse().map(function(a){a.flip()}),this.plane.flip()},a}(),f=function(){function a(a){this.plane=null,this.front=null,this.back=null,this.polygons=[],a&&this.build(a)}return a.prototype.clone=function(){var b=new a;return b.plane=this.plane&&this.plane.clone(),b.front=this.front&&this.front.clone(),b.back=this.back&&this.back.clone(),b.polygons=this.polygons.map(function(a){return a.clone()}),b},a.prototype.invert=function(){for(var a=0;a<this.polygons.length;a++)this.polygons[a].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();var b=this.front;this.front=this.back,this.back=b},a.prototype.clipPolygons=function(a){if(!this.plane)return a.slice();for(var b=[],c=[],d=0;d<a.length;d++)this.plane.splitPolygon(a[d],b,c,b,c);return this.front&&(b=this.front.clipPolygons(b)),c=this.back?this.back.clipPolygons(c):[],b.concat(c)},a.prototype.clipTo=function(a){this.polygons=a.clipPolygons(this.polygons),this.front&&this.front.clipTo(a),this.back&&this.back.clipTo(a)},a.prototype.allPolygons=function(){var a=this.polygons.slice();return this.front&&(a=a.concat(this.front.allPolygons())),this.back&&(a=a.concat(this.back.allPolygons())),a},a.prototype.build=function(b){if(b.length){this.plane||(this.plane=b[0].plane.clone());for(var c=[],d=[],e=0;e<b.length;e++)this.plane.splitPolygon(b[e],this.polygons,this.polygons,c,d);c.length&&(this.front||(this.front=new a),this.front.build(c)),d.length&&(this.back||(this.back=new a),this.back.build(d))}},a}(),g=function(){function d(){this.polygons=new Array}return d.FromMesh=function(f){var g,h,i,j,k,l,m=[];if(!(f instanceof a.Mesh))throw"BABYLON.CSG:Wrong Mesh type,must be BABYLON.Mesh";f.computeWorldMatrix(!0);for(var n=f.getWorldMatrix(),o=f.position.clone(),p=f.rotation.clone(),q=f.scaling.clone(),r=f.getIndices(),s=f.getVerticesData(a.VertexBuffer.PositionKind),t=f.getVerticesData(a.VertexBuffer.NormalKind),u=f.getVerticesData(a.VertexBuffer.UVKind),v=f.subMeshes,w=0,x=v.length;x>w;w++)for(var y=v[w].indexStart,z=v[w].indexCount+v[w].indexStart;z>y;y+=3){l=[];for(var A=0;3>A;A++)h=new a.Vector3(t[3*r[y+A]],t[3*r[y+A]+1],t[3*r[y+A]+2]),i=new a.Vector2(u[2*r[y+A]],u[2*r[y+A]+1]),j=new a.Vector3(s[3*r[y+A]],s[3*r[y+A]+1],s[3*r[y+A]+2]),a.Vector3.TransformCoordinatesToRef(j,n,j),a.Vector3.TransformNormalToRef(h,n,h),g=new c(j,h,i),l.push(g);k=new e(l,{subMeshId:w,meshId:b,materialIndex:v[w].materialIndex}),k.plane&&m.push(k)}var B=d.FromPolygons(m);return B.matrix=n,B.position=o,B.rotation=p,B.scaling=q,b++,B},d.FromPolygons=function(b){var c=new a.CSG;return c.polygons=b,c},d.prototype.clone=function(){var b=new a.CSG;return b.polygons=this.polygons.map(function(a){return a.clone()}),b.copyTransformAttributes(this),b},d.prototype.toPolygons=function(){return this.polygons},d.prototype.union=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.unionInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),this.polygons=b.allPolygons()},d.prototype.subtract=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.invert(),b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),b.invert(),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.subtractInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.invert(),b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),b.invert(),this.polygons=b.allPolygons()},d.prototype.intersect=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.invert(),c.clipTo(b),c.invert(),b.clipTo(c),c.clipTo(b),b.build(c.allPolygons()),b.invert(),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.intersectInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.invert(),c.clipTo(b),c.invert(),b.clipTo(c),c.clipTo(b),b.build(c.allPolygons()),b.invert(),this.polygons=b.allPolygons()},d.prototype.inverse=function(){var a=this.clone();return a.inverseInPlace(),a},d.prototype.inverseInPlace=function(){this.polygons.map(function(a){a.flip()})},d.prototype.copyTransformAttributes=function(a){return this.matrix=a.matrix,this.position=a.position,this.rotation=a.rotation,this.scaling=a.scaling,this},d.prototype.buildMeshGeometry=function(b,c,d){var e=this.matrix.clone();e.invert();var f,g,h,i=new a.Mesh(b,c),j=[],k=[],l=[],m=[],n=a.Vector3.Zero(),o=a.Vector3.Zero(),p=a.Vector2.Zero(),q=this.polygons,r=[0,0,0],s={},t=0,u={};d&&q.sort(function(a,b){return a.shared.meshId===b.shared.meshId?a.shared.subMeshId-b.shared.subMeshId:a.shared.meshId-b.shared.meshId});for(var v=0,w=q.length;w>v;v++){f=q[v],u[f.shared.meshId]||(u[f.shared.meshId]={}),u[f.shared.meshId][f.shared.subMeshId]||(u[f.shared.meshId][f.shared.subMeshId]={indexStart:+1/0,indexEnd:-1/0,materialIndex:f.shared.materialIndex}),h=u[f.shared.meshId][f.shared.subMeshId];for(var x=2,y=f.vertices.length;y>x;x++){r[0]=0,r[1]=x-1,r[2]=x;for(var z=0;3>z;z++)n.copyFrom(f.vertices[r[z]].pos),o.copyFrom(f.vertices[r[z]].normal),p.copyFrom(f.vertices[r[z]].uv),a.Vector3.TransformCoordinatesToRef(n,e,n),a.Vector3.TransformNormalToRef(o,e,o),g=s[n.x+","+n.y+","+n.z],("undefined"==typeof g||l[3*g]!==o.x||l[3*g+1]!==o.y||l[3*g+2]!==o.z||m[2*g]!==p.x||m[2*g+1]!==p.y)&&(j.push(n.x,n.y,n.z),m.push(p.x,p.y),l.push(o.x,o.y,o.z),g=s[n.x+","+n.y+","+n.z]=j.length/3-1),k.push(g),h.indexStart=Math.min(t,h.indexStart),h.indexEnd=Math.max(t,h.indexEnd),t++}}if(i.setVerticesData(a.VertexBuffer.PositionKind,j),i.setVerticesData(a.VertexBuffer.NormalKind,l),i.setVerticesData(a.VertexBuffer.UVKind,m),i.setIndices(k),d){var A,B=0;i.subMeshes.length=0;for(var C in u){A=-1;for(var D in u[C])h=u[C][D],a.SubMesh.CreateFromIndices(h.materialIndex+B,h.indexStart,h.indexEnd-h.indexStart+1,i),A=Math.max(h.materialIndex,A);B+=++A}}return i},d.prototype.toMesh=function(a,b,c,d){var e=this.buildMeshGeometry(a,c,d);return e.material=b,e.position.copyFrom(this.position),e.rotation.copyFrom(this.rotation),e.scaling.copyFrom(this.scaling),e.computeWorldMatrix(!0),e},d}();a.CSG=g}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){var g=this;b.call(this,c,"oculusDistortionCorrection",["LensCenter","Scale","ScaleIn","HmdWarpParam"],null,f.PostProcessScaleFactor,d,a.Texture.BILINEAR_SAMPLINGMODE,null,null),this._isRightEye=e,this._distortionFactors=f.DistortionK,this._postProcessScaleFactor=f.PostProcessScaleFactor,this._lensCenterOffset=f.LensCenterOffset,this.onSizeChanged=function(){g.aspectRatio=.5*g.width/g.height,g._scaleIn=new a.Vector2(2,2/g.aspectRatio),g._scaleFactor=new a.Vector2(.5*(1/g._postProcessScaleFactor),.5*(1/g._postProcessScaleFactor)*g.aspectRatio),g._lensCenter=new a.Vector2(g._isRightEye?.5-.5*g._lensCenterOffset:.5+.5*g._lensCenterOffset,.5)},this.onApply=function(a){a.setFloat2("LensCenter",g._lensCenter.x,g._lensCenter.y),a.setFloat2("Scale",g._scaleFactor.x,g._scaleFactor.y),a.setFloat2("ScaleIn",g._scaleIn.x,g._scaleIn.y),a.setFloat4("HmdWarpParam",g._distortionFactors[0],g._distortionFactors[1],g._distortionFactors[2],g._distortionFactors[3])}}return __extends(c,b),c}(a.PostProcess);a.OculusDistortionCorrectionPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){a[a.X=0]="X",a[a.Y=1]="Y",a[a.Z=2]="Z"}(a.JoystickAxis||(a.JoystickAxis={}));var b=(a.JoystickAxis,function(){function b(c){var d=this;this._leftJoystick=c?!0:!1,this._joystickIndex=b._globalJoystickIndex,b._globalJoystickIndex++,this._axisTargetedByLeftAndRight=0,this._axisTargetedByUpAndDown=1,this.reverseLeftRight=!1,this.reverseUpDown=!1,this._touches=new a.VirtualJoystick.Collection,this.deltaPosition=a.Vector3.Zero(),this._joystickSensibility=25,this._inversedSensibility=1/(this._joystickSensibility/1e3),this._rotationSpeed=25,this._inverseRotationSpeed=1/(this._rotationSpeed/1e3),this._rotateOnAxisRelativeToMesh=!1,b.vjCanvas||(window.addEventListener("resize",function(){b.vjCanvasWidth=window.innerWidth,b.vjCanvasHeight=window.innerHeight,b.vjCanvas.width=b.vjCanvasWidth,b.vjCanvas.height=b.vjCanvasHeight,b.halfWidth=b.vjCanvasWidth/2,b.halfHeight=b.vjCanvasHeight/2},!1),b.vjCanvas=document.createElement("canvas"),b.vjCanvasWidth=window.innerWidth,b.vjCanvasHeight=window.innerHeight,b.vjCanvas.width=window.innerWidth,b.vjCanvas.height=window.innerHeight,b.vjCanvas.style.width="100%",b.vjCanvas.style.height="100%",b.vjCanvas.style.position="absolute",b.vjCanvas.style.backgroundColor="transparent",b.vjCanvas.style.top="0px",b.vjCanvas.style.left="0px",b.vjCanvas.style.zIndex="5",b.vjCanvas.style.msTouchAction="none",b.vjCanvasContext=b.vjCanvas.getContext("2d"),b.vjCanvasContext.strokeStyle="#ffffff",b.vjCanvasContext.lineWidth=2,document.body.appendChild(b.vjCanvas)),b.halfWidth=b.vjCanvas.width/2,b.halfHeight=b.vjCanvas.height/2,this.pressed=!1,this._joystickColor="cyan",this._joystickPointerID=-1,this._joystickPointerPos=new a.Vector2(0,0),this._joystickPointerStartPos=new a.Vector2(0,0),this._deltaJoystickVector=new a.Vector2(0,0),b.vjCanvas.addEventListener("pointerdown",function(a){d._onPointerDown(a)},!1),b.vjCanvas.addEventListener("pointermove",function(a){d._onPointerMove(a)},!1),b.vjCanvas.addEventListener("pointerup",function(a){d._onPointerUp(a)},!1),b.vjCanvas.addEventListener("pointerout",function(a){d._onPointerUp(a)},!1),b.vjCanvas.addEventListener("contextmenu",function(a){a.preventDefault()},!1),requestAnimationFrame(function(){d._drawVirtualJoystick()})}return b.prototype.setJoystickSensibility=function(a){this._joystickSensibility=a,this._inversedSensibility=1/(this._joystickSensibility/1e3)},b.prototype._onPointerDown=function(a){var c;a.preventDefault(),c=this._leftJoystick===!0?a.clientX<b.halfWidth:a.clientX>b.halfWidth,c&&this._joystickPointerID<0?(this._joystickPointerID=a.pointerId,this._joystickPointerStartPos.x=a.clientX,this._joystickPointerStartPos.y=a.clientY,this._joystickPointerPos=this._joystickPointerStartPos.clone(),this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this.pressed=!0,this._touches.add(a.pointerId.toString(),a)):b._globalJoystickIndex<2&&this._action&&(this._action(),this._touches.add(a.pointerId.toString(),a))},b.prototype._onPointerMove=function(a){if(this._joystickPointerID==a.pointerId){this._joystickPointerPos.x=a.clientX,this._joystickPointerPos.y=a.clientY,this._deltaJoystickVector=this._joystickPointerPos.clone(),this._deltaJoystickVector=this._deltaJoystickVector.subtract(this._joystickPointerStartPos);var b=this.reverseLeftRight?-1:1,c=b*this._deltaJoystickVector.x/this._inversedSensibility;switch(this._axisTargetedByLeftAndRight){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,c));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,c));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,c))}var d=this.reverseUpDown?1:-1,e=d*this._deltaJoystickVector.y/this._inversedSensibility;switch(this._axisTargetedByUpAndDown){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,e));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,e));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,e))}}else this._touches.item(a.pointerId.toString())&&(this._touches.item(a.pointerId.toString()).x=a.clientX,this._touches.item(a.pointerId.toString()).y=a.clientY)},b.prototype._onPointerUp=function(a){this._clearCanvas(),this._joystickPointerID==a.pointerId&&(this._joystickPointerID=-1,this.pressed=!1),this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this._touches.remove(a.pointerId.toString())},b.prototype.setJoystickColor=function(a){this._joystickColor=a},b.prototype.setActionOnTouch=function(a){this._action=a},b.prototype.setAxisForLeftRight=function(a){switch(a){case 0:case 1:case 2:this._axisTargetedByLeftAndRight=a;break;default:this._axisTargetedByLeftAndRight=0}},b.prototype.setAxisForUpDown=function(a){switch(a){case 0:case 1:case 2:this._axisTargetedByUpAndDown=a;break;default:this._axisTargetedByUpAndDown=1}},b.prototype._clearCanvas=function(){this._leftJoystick?b.vjCanvasContext.clearRect(0,0,b.vjCanvasWidth/2,b.vjCanvasHeight):b.vjCanvasContext.clearRect(b.vjCanvasWidth/2,0,b.vjCanvasWidth,b.vjCanvasHeight)},b.prototype._drawVirtualJoystick=function(){var a=this;this.pressed&&(this._clearCanvas(),this._touches.forEach(function(c){c.pointerId===a._joystickPointerID?(b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.lineWidth=6,b.vjCanvasContext.arc(a._joystickPointerStartPos.x,a._joystickPointerStartPos.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke(),b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.lineWidth=2,b.vjCanvasContext.arc(a._joystickPointerStartPos.x,a._joystickPointerStartPos.y,60,0,2*Math.PI,!0),b.vjCanvasContext.stroke(),b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.arc(a._joystickPointerPos.x,a._joystickPointerPos.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke()):(b.vjCanvasContext.beginPath(),b.vjCanvasContext.fillStyle="white",b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle="red",b.vjCanvasContext.lineWidth=6,b.vjCanvasContext.arc(c.x,c.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke())})),requestAnimationFrame(function(){a._drawVirtualJoystick()})},b.prototype.releaseCanvas=function(){b.vjCanvas&&(document.body.removeChild(b.vjCanvas),b.vjCanvas=null)},b._globalJoystickIndex=0,b}());a.VirtualJoystick=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){var b=function(){function a(){this._count=0,this._collection=new Array}return a.prototype.Count=function(){return this._count},a.prototype.add=function(a,b){return void 0!=this._collection[a]?void 0:(this._collection[a]=b,++this._count)},a.prototype.remove=function(a){return void 0==this._collection[a]?void 0:(delete this._collection[a],--this._count)},a.prototype.item=function(a){return this._collection[a]},a.prototype.forEach=function(a){var b;for(b in this._collection)this._collection.hasOwnProperty(b)&&a(this._collection[b])},a}();a.Collection=b}(a.VirtualJoystick||(a.VirtualJoystick={}));a.VirtualJoystick}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b={HResolution:1280,VResolution:800,HScreenSize:.149759993,VScreenSize:.0935999975,VScreenCenter:.0467999987,EyeToScreenDistance:.0410000011,LensSeparationDistance:.063500002,InterpupillaryDistance:.064000003,DistortionK:[1,.219999999,.239999995,0],ChromaAbCorrection:[.995999992,-.00400000019,1.01400006,0],PostProcessScaleFactor:1.714605507808412,LensCenterOffset:.151976421},c=function(c){function d(d,e,f,g){c.call(this,d,e,f),this._workMatrix=new a.Matrix,this._actualUp=new a.Vector3(0,0,0),this._aspectRatioAspectRatio=b.HResolution/(2*b.VResolution),this._aspectRatioFov=2*Math.atan(b.PostProcessScaleFactor*b.VScreenSize/(2*b.EyeToScreenDistance));var h=b.HScreenSize/4-b.LensSeparationDistance/2,i=4*h/b.HScreenSize;this._hMatrix=a.Matrix.Translation(g?i:-i,0,0),this.viewport=new a.Viewport(g?0:.5,0,.5,1),this._preViewMatrix=a.Matrix.Translation(g?.5*b.InterpupillaryDistance:-.5*b.InterpupillaryDistance,0,0);new a.OculusDistortionCorrectionPostProcess("Oculus Distortion",this,!g,b)}return __extends(d,c),d.prototype.getProjectionMatrix=function(){return a.Matrix.PerspectiveFovLHToRef(this._aspectRatioFov,this._aspectRatioAspectRatio,this.minZ,this.maxZ,this._workMatrix),this._workMatrix.multiplyToRef(this._hMatrix,this._projectionMatrix),this._projectionMatrix},d.prototype._getViewMatrix=function(){return a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),a.Vector3.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),a.Vector3.TransformNormalToRef(this.upVector,this._cameraRotationMatrix,this._actualUp),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),a.Matrix.LookAtLHToRef(this.position,this._currentTarget,this._actualUp,this._workMatrix),this._workMatrix.multiplyToRef(this._preViewMatrix,this._viewMatrix),this._viewMatrix},d}(a.FreeCamera),d=function(a){function b(b,d,e){a.call(this,b,d,e),this._leftCamera=new c(b+"_left",d.clone(),e,!0),this._rightCamera=new c(b+"_right",d.clone(),e,!1),this.subCameras.push(this._leftCamera),this.subCameras.push(this._rightCamera),this._deviceOrientationHandler=this._onOrientationEvent.bind(this)}return __extends(b,a),b.prototype._update=function(){this._leftCamera.position.copyFrom(this.position),this._rightCamera.position.copyFrom(this.position),this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),a.prototype._update.call(this)},b.prototype._updateCamera=function(a){a.minZ=this.minZ,a.maxZ=this.maxZ,a.rotation.x=this.rotation.x,a.rotation.y=this.rotation.y,a.rotation.z=this.rotation.z},b.prototype._onOrientationEvent=function(a){var b=a.alpha/180*Math.PI,c=a.beta/180*Math.PI,d=a.gamma/180*Math.PI;return this._offsetOrientation?(this.rotation.y+=b-this._offsetOrientation.yaw,this.rotation.x+=c-this._offsetOrientation.pitch,this.rotation.z+=this._offsetOrientation.roll-d,this._offsetOrientation.yaw=b,this._offsetOrientation.pitch=c,this._offsetOrientation.roll=d,void 0):void(this._offsetOrientation={yaw:b,pitch:c,roll:d})},b.prototype.attachControl=function(b,c){a.prototype.attachControl.call(this,b,c),window.addEventListener("deviceorientation",this._deviceOrientationHandler)},b.prototype.detachControl=function(b){a.prototype.detachControl.call(this,b),window.removeEventListener("deviceorientation",this._deviceOrientationHandler)},b}(a.FreeCamera);a.OculusCamera=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,d,e),this._leftjoystick=new a.VirtualJoystick(!0),this._leftjoystick.setAxisForUpDown(2),this._leftjoystick.setAxisForLeftRight(0),this._leftjoystick.setJoystickSensibility(.15),this._rightjoystick=new a.VirtualJoystick(!1),this._rightjoystick.setAxisForUpDown(0),this._rightjoystick.setAxisForLeftRight(1),this._rightjoystick.reverseUpDown=!0,this._rightjoystick.setJoystickSensibility(.05),this._rightjoystick.setJoystickColor("yellow")}return __extends(c,b),c.prototype._checkInputs=function(){var b=a.Matrix.RotationYawPitchRoll(this.rotation.y,this.rotation.x,0),c=a.Vector3.TransformCoordinates(this._leftjoystick.deltaPosition,b);this.cameraDirection=this.cameraDirection.add(c),this.cameraRotation=this.cameraRotation.add(this._rightjoystick.deltaPosition),this._leftjoystick.pressed||(this._leftjoystick.deltaPosition=this._leftjoystick.deltaPosition.scale(.9)),this._rightjoystick.pressed||(this._rightjoystick.deltaPosition=this._rightjoystick.deltaPosition.scale(.9))},c.prototype.dispose=function(){this._leftjoystick.releaseCanvas()},c}(a.FreeCamera);a.VirtualJoysticksCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){b.call(this,c,d),this._textures=new Array,this._floats=new Array,this._floatsArrays={},this._colors3=new Array,this._colors4=new Array,this._vectors2=new Array,this._vectors3=new Array,this._matrices=new Array,this._cachedWorldViewMatrix=new a.Matrix,this._shaderPath=e,f.needAlphaBlending=f.needAlphaBlending||!1,f.needAlphaTesting=f.needAlphaTesting||!1,f.attributes=f.attributes||["position","normal","uv"],f.uniforms=f.uniforms||["worldViewProjection"],f.samplers=f.samplers||[],this._options=f}return __extends(c,b),c.prototype.needAlphaBlending=function(){return this._options.needAlphaBlending},c.prototype.needAlphaTesting=function(){return this._options.needAlphaTesting},c.prototype._checkUniform=function(a){-1===this._options.uniforms.indexOf(a)&&this._options.uniforms.push(a)},c.prototype.setTexture=function(a,b){return-1===this._options.samplers.indexOf(a)&&this._options.samplers.push(a),this._textures[a]=b,this},c.prototype.setFloat=function(a,b){return this._checkUniform(a),this._floats[a]=b,this},c.prototype.setFloats=function(a,b){return this._checkUniform(a),this._floatsArrays[a]=b,this},c.prototype.setColor3=function(a,b){return this._checkUniform(a),this._colors3[a]=b,this},c.prototype.setColor4=function(a,b){return this._checkUniform(a),this._colors4[a]=b,this},c.prototype.setVector2=function(a,b){return this._checkUniform(a),this._vectors2[a]=b,this},c.prototype.setVector3=function(a,b){return this._checkUniform(a),this._vectors3[a]=b,this},c.prototype.setMatrix=function(a,b){return this._checkUniform(a),this._matrices[a]=b,this},c.prototype.isReady=function(){var a=this.getScene().getEngine();return this._effect=a.createEffect(this._shaderPath,this._options.attributes,this._options.uniforms,this._options.samplers,"",null,this.onCompiled,this.onError),this._effect.isReady()?!0:!1},c.prototype.bind=function(a){-1!==this._options.uniforms.indexOf("world")&&this._effect.setMatrix("world",a),-1!==this._options.uniforms.indexOf("view")&&this._effect.setMatrix("view",this.getScene().getViewMatrix()),-1!==this._options.uniforms.indexOf("worldView")&&(a.multiplyToRef(this.getScene().getViewMatrix(),this._cachedWorldViewMatrix),this._effect.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==this._options.uniforms.indexOf("projection")&&this._effect.setMatrix("projection",this.getScene().getProjectionMatrix()),-1!==this._options.uniforms.indexOf("worldViewProjection")&&this._effect.setMatrix("worldViewProjection",a.multiply(this.getScene().getTransformMatrix()));for(var b in this._textures)this._effect.setTexture(b,this._textures[b]);for(b in this._floats)this._effect.setFloat(b,this._floats[b]);for(b in this._floatsArrays)this._effect.setArray(b,this._floatsArrays[b]);for(b in this._colors3)this._effect.setColor3(b,this._colors3[b]);for(b in this._colors4){var c=this._colors4[b];this._effect.setFloat4(b,c.r,c.g,c.b,c.a)}for(b in this._vectors2)this._effect.setVector2(b,this._vectors2[b]);for(b in this._vectors3)this._effect.setVector3(b,this._vectors3[b]);for(b in this._matrices)this._effect.setMatrix(b,this._matrices[b])},c.prototype.dispose=function(a){for(var c in this._textures)this._textures[c].dispose();this._textures=[],b.prototype.dispose.call(this,a)},c}(a.Material);a.ShaderMaterial=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return b.prototype.set=function(b,c){switch(c){case a.VertexBuffer.PositionKind:this.positions=b;break;case a.VertexBuffer.NormalKind:this.normals=b;break;case a.VertexBuffer.UVKind:this.uvs=b;break;case a.VertexBuffer.UV2Kind:this.uv2s=b;break;case a.VertexBuffer.ColorKind:this.colors=b;break;case a.VertexBuffer.MatricesIndicesKind:this.matricesIndices=b;break;case a.VertexBuffer.MatricesWeightsKind:this.matricesWeights=b}},b.prototype.applyToMesh=function(a,b){this._applyTo(a,b)},b.prototype.applyToGeometry=function(a,b){this._applyTo(a,b)},b.prototype.updateMesh=function(a){this._update(a)},b.prototype.updateGeometry=function(a){this._update(a)},b.prototype._applyTo=function(b,c){this.positions&&b.setVerticesData(a.VertexBuffer.PositionKind,this.positions,c),this.normals&&b.setVerticesData(a.VertexBuffer.NormalKind,this.normals,c),this.uvs&&b.setVerticesData(a.VertexBuffer.UVKind,this.uvs,c),this.uv2s&&b.setVerticesData(a.VertexBuffer.UV2Kind,this.uv2s,c),this.colors&&b.setVerticesData(a.VertexBuffer.ColorKind,this.colors,c),this.matricesIndices&&b.setVerticesData(a.VertexBuffer.MatricesIndicesKind,this.matricesIndices,c),this.matricesWeights&&b.setVerticesData(a.VertexBuffer.MatricesWeightsKind,this.matricesWeights,c),this.indices&&b.setIndices(this.indices)
},b.prototype._update=function(b,c,d){this.positions&&b.updateVerticesData(a.VertexBuffer.PositionKind,this.positions,c,d),this.normals&&b.updateVerticesData(a.VertexBuffer.NormalKind,this.normals,c,d),this.uvs&&b.updateVerticesData(a.VertexBuffer.UVKind,this.uvs,c,d),this.uv2s&&b.updateVerticesData(a.VertexBuffer.UV2Kind,this.uv2s,c,d),this.colors&&b.updateVerticesData(a.VertexBuffer.ColorKind,this.colors,c,d),this.matricesIndices&&b.updateVerticesData(a.VertexBuffer.MatricesIndicesKind,this.matricesIndices,c,d),this.matricesWeights&&b.updateVerticesData(a.VertexBuffer.MatricesWeightsKind,this.matricesWeights,c,d),this.indices&&b.setIndices(this.indices)},b.prototype.transform=function(b){var c=a.Vector3.Zero();if(this.positions)for(var d=a.Vector3.Zero(),e=0;e<this.positions.length;e+=3)a.Vector3.FromArrayToRef(this.positions,e,d),a.Vector3.TransformCoordinatesToRef(d,b,c),this.positions[e]=c.x,this.positions[e+1]=c.y,this.positions[e+2]=c.z;if(this.normals){var f=a.Vector3.Zero();for(e=0;e<this.normals.length;e+=3)a.Vector3.FromArrayToRef(this.normals,e,f),a.Vector3.TransformNormalToRef(f,b,c),this.normals[e]=c.x,this.normals[e+1]=c.y,this.normals[e+2]=c.z}},b.prototype.merge=function(a){if(a.indices){this.indices||(this.indices=[]);for(var b=this.positions?this.positions.length/3:0,c=0;c<a.indices.length;c++)this.indices.push(a.indices[c]+b)}if(a.positions)for(this.positions||(this.positions=[]),c=0;c<a.positions.length;c++)this.positions.push(a.positions[c]);if(a.normals)for(this.normals||(this.normals=[]),c=0;c<a.normals.length;c++)this.normals.push(a.normals[c]);if(a.uvs)for(this.uvs||(this.uvs=[]),c=0;c<a.uvs.length;c++)this.uvs.push(a.uvs[c]);if(a.uv2s)for(this.uv2s||(this.uv2s=[]),c=0;c<a.uv2s.length;c++)this.uv2s.push(a.uv2s[c]);if(a.matricesIndices)for(this.matricesIndices||(this.matricesIndices=[]),c=0;c<a.matricesIndices.length;c++)this.matricesIndices.push(a.matricesIndices[c]);if(a.matricesWeights)for(this.matricesWeights||(this.matricesWeights=[]),c=0;c<a.matricesWeights.length;c++)this.matricesWeights.push(a.matricesWeights[c]);if(a.colors)for(this.colors||(this.colors=[]),c=0;c<a.colors.length;c++)this.colors.push(a.colors[c])},b.ExtractFromMesh=function(a){return b._ExtractFrom(a)},b.ExtractFromGeometry=function(a){return b._ExtractFrom(a)},b._ExtractFrom=function(b){var c=new a.VertexData;return b.isVerticesDataPresent(a.VertexBuffer.PositionKind)&&(c.positions=b.getVerticesData(a.VertexBuffer.PositionKind)),b.isVerticesDataPresent(a.VertexBuffer.NormalKind)&&(c.normals=b.getVerticesData(a.VertexBuffer.NormalKind)),b.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(c.uvs=b.getVerticesData(a.VertexBuffer.UVKind)),b.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(c.uv2s=b.getVerticesData(a.VertexBuffer.UV2Kind)),b.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(c.colors=b.getVerticesData(a.VertexBuffer.ColorKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&(c.matricesIndices=b.getVerticesData(a.VertexBuffer.MatricesIndicesKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(c.matricesWeights=b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)),c.indices=b.getIndices(),c},b.CreateBox=function(b){var c=[new a.Vector3(0,0,1),new a.Vector3(0,0,-1),new a.Vector3(1,0,0),new a.Vector3(-1,0,0),new a.Vector3(0,1,0),new a.Vector3(0,-1,0)],d=[],e=[],f=[],g=[];b=b||1;for(var h=0;h<c.length;h++){var i=c[h],j=new a.Vector3(i.y,i.z,i.x),k=a.Vector3.Cross(i,j),l=e.length/3;d.push(l),d.push(l+1),d.push(l+2),d.push(l),d.push(l+2),d.push(l+3);var m=i.subtract(j).subtract(k).scale(b/2);e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(1,1),m=i.subtract(j).add(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(0,1),m=i.add(j).add(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(0,0),m=i.add(j).subtract(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(1,0)}var n=new a.VertexData;return n.indices=d,n.positions=e,n.normals=f,n.uvs=g,n},b.CreateSphere=function(b,c){b=b||32,c=c||1;for(var d=c/2,e=2+b,f=2*e,g=[],h=[],i=[],j=[],k=0;e>=k;k++){for(var l=k/e,m=l*Math.PI,n=0;f>=n;n++){var o=n/f,p=o*Math.PI*2,q=a.Matrix.RotationZ(-m),r=a.Matrix.RotationY(p),s=a.Vector3.TransformCoordinates(a.Vector3.Up(),q),t=a.Vector3.TransformCoordinates(s,r),u=t.scale(d),v=a.Vector3.Normalize(u);h.push(u.x,u.y,u.z),i.push(v.x,v.y,v.z),j.push(l,o)}if(k>0)for(var w=h.length/3,x=w-2*(f+1);w>x+f+2;x++)g.push(x),g.push(x+1),g.push(x+f+1),g.push(x+f+1),g.push(x+1),g.push(x+f+2)}var y=new a.VertexData;return y.indices=g,y.positions=h,y.normals=i,y.uvs=j,y},b.CreateCylinder=function(b,c,d,e,f){"undefined"==typeof f&&(f=1);var g=c/2,h=d/2,i=[],j=[],k=[],l=[];b=b||1,c=c||.5,d=d||1,e=e||16,f=f||1,f=1>f?1:f;for(var m=function(b){var c=2*b*Math.PI/e,d=Math.cos(c),f=Math.sin(c);return new a.Vector3(d,0,f)},n=function(c){var d=c?g:h;if(0!=d){var f=j.length/3,k=new a.Vector3(0,b/2,0),n=new a.Vector2(.5,.5);for(c||(k.scaleInPlace(-1),n.x=-n.x),r=0;e>r;r++){var o=m(r),p=o.scale(d).add(k),q=new a.Vector2(o.x*n.x+.5,o.z*n.y+.5);j.push(p.x,p.y,p.z),l.push(q.x,q.y)}for(var r=0;e-2>r;r++)c?(i.push(f),i.push(f+(r+1)%e),i.push(f+(r+2)%e)):(i.push(f),i.push(f+(r+2)%e),i.push(f+(r+1)%e))}},o=new a.Vector3(0,-1,0).scale(b/2),p=new a.Vector3(0,1,0).scale(b/f),q=e+1,r=0;e>=r;r++)for(var s,t=m(r),u=new a.Vector2(r/e,0),v=h,w=0;f>=w;w++)s=t.scale(v),s.addInPlace(o.add(p.scale(w))),u.y+=1/f,v+=(g-h)/f,j.push(s.x,s.y,s.z),l.push(u.x,u.y);f+=1;for(var w=0;f-1>w;w++)for(var r=0;e>=r;r++)i.push(r*f+w),i.push((r*f+(w+f))%(q*f)),i.push(r*f+(w+1)),i.push(r*f+(w+1)),i.push((r*f+(w+f))%(q*f)),i.push((r*f+(w+f+1))%(q*f));n(!0),n(!1),a.VertexData.ComputeNormals(j,i,k);var x=new a.VertexData;return x.indices=i,x.positions=j,x.normals=k,x.uvs=l,x},b.CreateTorus=function(b,c,d){var e=[],f=[],g=[],h=[];b=b||1,c=c||.5,d=d||16;for(var i=d+1,j=0;d>=j;j++)for(var k=j/d,l=j*Math.PI*2/d-Math.PI/2,m=a.Matrix.Translation(b/2,0,0).multiply(a.Matrix.RotationY(l)),n=0;d>=n;n++){var o=1-n/d,p=n*Math.PI*2/d+Math.PI,q=Math.cos(p),r=Math.sin(p),s=new a.Vector3(q,r,0),t=s.scale(c/2),u=new a.Vector2(k,o);t=a.Vector3.TransformCoordinates(t,m),s=a.Vector3.TransformNormal(s,m),f.push(t.x,t.y,t.z),g.push(s.x,s.y,s.z),h.push(u.x,u.y);var v=(j+1)%i,w=(n+1)%i;e.push(j*i+n),e.push(j*i+w),e.push(v*i+n),e.push(j*i+w),e.push(v*i+w),e.push(v*i+n)}var x=new a.VertexData;return x.indices=e,x.positions=f,x.normals=g,x.uvs=h,x},b.CreateLines=function(b){for(var c=[],d=[],e=0;e<b.length;e++)d.push(b[e].x,b[e].y,b[e].z),e>0&&(c.push(e-1),c.push(e));var f=new a.VertexData;return f.indices=c,f.positions=d,f},b.CreateGround=function(b,c,d){var e,f,g=[],h=[],i=[],j=[];for(b=b||1,c=c||1,d=d||1,e=0;d>=e;e++)for(f=0;d>=f;f++){var k=new a.Vector3(f*b/d-b/2,0,(d-e)*c/d-c/2),l=new a.Vector3(0,1,0);h.push(k.x,k.y,k.z),i.push(l.x,l.y,l.z),j.push(f/d,1-e/d)}for(e=0;d>e;e++)for(f=0;d>f;f++)g.push(f+1+(e+1)*(d+1)),g.push(f+1+e*(d+1)),g.push(f+e*(d+1)),g.push(f+(e+1)*(d+1)),g.push(f+1+(e+1)*(d+1)),g.push(f+e*(d+1));var m=new a.VertexData;return m.indices=g,m.positions=h,m.normals=i,m.uvs=j,m},b.CreateTiledGround=function(b,c,d,e,f,g){function h(b,c,d,e){var f=n.length/3,h=g.w+1;for(i=0;i<g.h;i++)for(j=0;j<g.w;j++){var k=[f+j+i*h,f+(j+1)+i*h,f+(j+1)+(i+1)*h,f+j+(i+1)*h];m.push(k[1]),m.push(k[2]),m.push(k[3]),m.push(k[0]),m.push(k[1]),m.push(k[3])}var l=a.Vector3.Zero(),q=new a.Vector3(0,1,0);for(i=0;i<=g.h;i++)for(l.z=i*(e-c)/g.h+c,j=0;j<=g.w;j++)l.x=j*(d-b)/g.w+b,l.y=0,n.push(l.x,l.y,l.z),o.push(q.x,q.y,q.z),p.push(j/g.w,i/g.h)}"undefined"==typeof f&&(f={w:1,h:1}),"undefined"==typeof g&&(g={w:1,h:1});var i,j,k,l,m=[],n=[],o=[],p=[];f.h=f.w<1?1:f.h,f.w=f.w<1?1:f.w,g.w=g.w<1?1:g.w,g.h=g.h<1?1:g.h;var q={w:(d-b)/f.w,h:(e-c)/f.h};for(k=0;k<f.h;k++)for(l=0;l<f.w;l++)h(b+l*q.w,c+k*q.h,b+(l+1)*q.w,c+(k+1)*q.h);var r=new a.VertexData;return r.indices=m,r.positions=n,r.normals=o,r.uvs=p,r},b.CreateGroundFromHeightMap=function(b,c,d,e,f,g,h,i){var j,k,l=[],m=[],n=[],o=[];for(j=0;d>=j;j++)for(k=0;d>=k;k++){var p=new a.Vector3(k*b/d-b/2,0,(d-j)*c/d-c/2),q=(p.x+b/2)/b*(h-1)|0,r=(1-(p.z+c/2)/c)*(i-1)|0,s=4*(q+r*h),t=g[s]/255,u=g[s+1]/255,v=g[s+2]/255,w=.3*t+.59*u+.11*v;p.y=e+(f-e)*w,m.push(p.x,p.y,p.z),n.push(0,0,0),o.push(k/d,1-j/d)}for(j=0;d>j;j++)for(k=0;d>k;k++)l.push(k+1+(j+1)*(d+1)),l.push(k+1+j*(d+1)),l.push(k+j*(d+1)),l.push(k+(j+1)*(d+1)),l.push(k+1+(j+1)*(d+1)),l.push(k+j*(d+1));a.VertexData.ComputeNormals(m,l,n);var x=new a.VertexData;return x.indices=l,x.positions=m,x.normals=n,x.uvs=o,x},b.CreatePlane=function(b){var c=[],d=[],e=[],f=[];b=b||1;var g=b/2;d.push(-g,-g,0),e.push(0,0,-1),f.push(0,0),d.push(g,-g,0),e.push(0,0,-1),f.push(1,0),d.push(g,g,0),e.push(0,0,-1),f.push(1,1),d.push(-g,g,0),e.push(0,0,-1),f.push(0,1),c.push(0),c.push(1),c.push(2),c.push(0),c.push(2),c.push(3);var h=new a.VertexData;return h.indices=c,h.positions=d,h.normals=e,h.uvs=f,h},b.CreateTorusKnot=function(b,c,d,e,f,g){var h=[],i=[],j=[],k=[];b=b||2,c=c||.5,d=d||32,e=e||32,f=f||2,g=g||3;for(var l=function(c){var d=Math.cos(c),e=Math.sin(c),h=g/f*c,i=Math.cos(h),j=b*(2+i)*.5*d,k=b*(2+i)*e*.5,l=b*Math.sin(h)*.5;return new a.Vector3(j,k,l)},m=0;d>=m;m++){var n=m%d,o=n/d*2*f*Math.PI,p=l(o),q=l(o+.01),r=q.subtract(p),s=q.add(p),t=a.Vector3.Cross(r,s);s=a.Vector3.Cross(t,r),t.normalize(),s.normalize();for(var u=0;e>u;u++){var v=u%e,w=v/e*2*Math.PI,x=-c*Math.cos(w),y=c*Math.sin(w);i.push(p.x+x*s.x+y*t.x),i.push(p.y+x*s.y+y*t.y),i.push(p.z+x*s.z+y*t.z),k.push(m/d),k.push(u/e)}}for(m=0;d>m;m++)for(u=0;e>u;u++){var z=(u+1)%e,A=m*e+u,B=(m+1)*e+u,C=(m+1)*e+z,D=m*e+z;h.push(D),h.push(B),h.push(A),h.push(D),h.push(C),h.push(B)}a.VertexData.ComputeNormals(i,h,j);var E=new a.VertexData;return E.indices=h,E.positions=i,E.normals=j,E.uvs=k,E},b.ComputeNormals=function(b,c,d){var e,f=[],g=[];for(e=0;e<b.length;e+=3){var h=new a.Vector3(b[e],b[e+1],b[e+2]);f.push(h),g.push([])}var i=[];for(e=0;e<c.length/3;e++){var j=c[3*e],k=c[3*e+1],l=c[3*e+2],m=f[j],n=f[k],o=f[l],p=m.subtract(n),q=o.subtract(n);i[e]=a.Vector3.Normalize(a.Vector3.Cross(p,q)),g[j].push(e),g[k].push(e),g[l].push(e)}for(e=0;e<f.length;e++){for(var r=g[e],s=a.Vector3.Zero(),t=0;t<r.length;t++)s.addInPlace(i[r[t]]);s=a.Vector3.Normalize(s.scale(1/r.length)),d[3*e]=s.x,d[3*e+1]=s.y,d[3*e+2]=s.z}},b}();a.VertexData=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b,c){b._leftCamera.isIntermediate=!0,b.subCameras.push(b._leftCamera),b.subCameras.push(b._rightCamera),b._leftTexture=new a.PassPostProcess(c+"_leftTexture",1,b._leftCamera),b._anaglyphPostProcess=new a.AnaglyphPostProcess(c+"_anaglyph",1,b._rightCamera),b._anaglyphPostProcess.onApply=function(a){a.setTextureFromPostProcess("leftSampler",b._leftTexture)},b._update()},c=function(c){function d(d,e,f,g,h,i,j){c.call(this,d,e,f,g,h,j),this._eyeSpace=a.Tools.ToRadians(i),this._leftCamera=new a.ArcRotateCamera(d+"_left",e-this._eyeSpace,f,g,h,j),this._rightCamera=new a.ArcRotateCamera(d+"_right",e+this._eyeSpace,f,g,h,j),b(this,d)}return __extends(d,c),d.prototype._update=function(){this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),this._leftCamera.alpha=this.alpha-this._eyeSpace,this._rightCamera.alpha=this.alpha+this._eyeSpace,c.prototype._update.call(this)},d.prototype._updateCamera=function(a){a.beta=this.beta,a.radius=this.radius,a.minZ=this.minZ,a.maxZ=this.maxZ,a.fov=this.fov,a.target=this.target},d}(a.ArcRotateCamera);a.AnaglyphArcRotateCamera=c;var d=function(c){function d(d,e,f,g){c.call(this,d,e,g),this._eyeSpace=a.Tools.ToRadians(f),this._transformMatrix=new a.Matrix,this._leftCamera=new a.FreeCamera(d+"_left",e.clone(),g),this._rightCamera=new a.FreeCamera(d+"_right",e.clone(),g),b(this,d)}return __extends(d,c),d.prototype._getSubCameraPosition=function(b,c){var d=this.getTarget();a.Matrix.Translation(-d.x,-d.y,-d.z).multiplyToRef(a.Matrix.RotationY(b),this._transformMatrix),this._transformMatrix=this._transformMatrix.multiply(a.Matrix.Translation(d.x,d.y,d.z)),a.Vector3.TransformCoordinatesToRef(this.position,this._transformMatrix,c)},d.prototype._update=function(){this._getSubCameraPosition(-this._eyeSpace,this._leftCamera.position),this._getSubCameraPosition(this._eyeSpace,this._rightCamera.position),this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),c.prototype._update.call(this)},d.prototype._updateCamera=function(a){a.minZ=this.minZ,a.maxZ=this.maxZ,a.fov=this.fov,a.viewport=this.viewport,a.setTarget(this.getTarget())},d}(a.FreeCamera);a.AnaglyphFreeCamera=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"anaglyph",null,["leftSampler"],c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.AnaglyphPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return b.EnableFor=function(a){a._tags=a._tags||{},a.hasTags=function(){return b.HasTags(a)},a.addTags=function(c){return b.AddTagsTo(a,c)},a.removeTags=function(c){return b.RemoveTagsFrom(a,c)},a.matchesTagsQuery=function(c){return b.MatchesQuery(a,c)}},b.DisableFor=function(a){delete a._tags,delete a.hasTags,delete a.addTags,delete a.removeTags,delete a.matchesTagsQuery},b.HasTags=function(b){return b._tags?!a.Tools.IsEmpty(b._tags):!1},b.GetTags=function(a){return a._tags?a._tags:null},b.AddTagsTo=function(a,c){if(c){var d=c.split(" ");for(var e in d)b._AddTagTo(a,d[e])}},b._AddTagTo=function(a,c){c=c.trim(),""!==c&&"true"!==c&&"false"!==c&&(c.match(/[\s]/)||c.match(/^([!]|([|]|[&]){2})/)||(b.EnableFor(a),a._tags[c]=!0))},b.RemoveTagsFrom=function(a,c){if(b.HasTags(a)){var d=c.split(" ");for(var e in d)b._RemoveTagFrom(a,d[e])}},b._RemoveTagFrom=function(a,b){delete a._tags[b]},b.MatchesQuery=function(c,d){return void 0===d?!0:""===d?b.HasTags(c):a.Internals.AndOrNotEvaluator.Eval(d,function(a){return b.HasTags(c)&&c._tags[a]})},b}();a.Tags=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){var b=function(){function a(){}return a.Eval=function(b,c){return b=b.match(/\([^\(\)]*\)/g)?b.replace(/\([^\(\)]*\)/g,function(b){return b=b.slice(1,b.length-1),a._HandleParenthesisContent(b,c)}):a._HandleParenthesisContent(b,c),"true"===b?!0:"false"===b?!1:a.Eval(b,c)},a._HandleParenthesisContent=function(b,c){c=c||function(a){return"true"===a?!0:!1};var d,e=b.split("||");for(var f in e){var g=a._SimplifyNegation(e[f].trim()),h=g.split("&&");if(h.length>1)for(var i=0;i<h.length;++i){var j=a._SimplifyNegation(h[i].trim());if(d="true"!==j&&"false"!==j?"!"===j[0]?!c(j.substring(1)):c(j):"true"===j?!0:!1,!d){g="false";break}}if(d||"true"===g){d=!0;break}d="true"!==g&&"false"!==g?"!"===g[0]?!c(g.substring(1)):c(g):"true"===g?!0:!1}return d?"true":"false"},a._SimplifyNegation=function(a){return a=a.replace(/^[\s!]+/,function(a){return a=a.replace(/[\s]/g,function(){return""}),a.length%2?"!":""}),a=a.trim(),"!true"===a?a="false":"!false"===a&&(a="true"),a},a}();a.AndOrNotEvaluator=b}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g){this._enabled=!0,this._refCount=0,this._name=c,this._renderTexture=new a.RenderTargetTexture(c,d,b),this.setRenderList(e),this._renderTexture.onBeforeRender=f,this._renderTexture.onAfterRender=g,this._scene=b}return b.prototype._incRefCount=function(){return 0===this._refCount&&this._scene.customRenderTargets.push(this._renderTexture),++this._refCount},b.prototype._decRefCount=function(){return this._refCount--,this._refCount<=0&&this._scene.customRenderTargets.splice(this._scene.customRenderTargets.indexOf(this._renderTexture),1),this._refCount},b.prototype._update=function(){this.setRenderList(this._renderList)},b.prototype.setRenderList=function(a){this._renderTexture.renderList=a},b.prototype.getRenderTexture=function(){return this._renderTexture},b}();a.PostProcessRenderPass=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f){this._engine=a,this._name=b,this._postProcessType=c,this._ratio=d||1,this._samplingMode=e||null,this._singleInstance=f||!0,this._cameras=[],this._postProcesses=[],this._indicesForCamera=[],this._renderPasses=[],this._renderEffectAsPasses=[],this.parameters=function(){}}return b._GetInstance=function(a,c,d,e){for(var f,g,h=[],i=b._GetParametersNames(c),j=0;j<i.length;j++)switch(i[j]){case"name":h[j]=c.toString();break;case"ratio":h[j]=d;break;case"camera":h[j]=null;break;case"samplingMode":h[j]=e;break;case"engine":h[j]=a;break;case"reusable":h[j]=!0;break;default:h[j]=null}return f=function(){},f.prototype=c.prototype,g=new f,c.apply(g,h),g},b._GetParametersNames=function(a){var b=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,c=a.toString().replace(b,""),d=c.slice(c.indexOf("(")+1,c.indexOf(")")).match(/([^\s,]+)/g);return null===d&&(d=[]),d},b.prototype._update=function(){for(var a in this._renderPasses)this._renderPasses[a]._update()},b.prototype.addPass=function(a){this._renderPasses[a._name]=a,this._linkParameters()},b.prototype.removePass=function(a){delete this._renderPasses[a._name],this._linkParameters()},b.prototype.addRenderEffectAsPass=function(a){this._renderEffectAsPasses[a._name]=a,this._linkParameters()},b.prototype.getPass=function(a){for(var b in this._renderPasses)if(b===a)return this._renderPasses[a]},b.prototype.emptyPasses=function(){this._renderPasses.length=0,this._linkParameters()},b.prototype._attachCameras=function(c){for(var d,e=a.Tools.MakeArray(c||this._cameras),f=0;f<e.length;f++){var g=e[f],h=g.name;d=this._singleInstance?0:h,this._postProcesses[d]=this._postProcesses[d]||b._GetInstance(this._engine,this._postProcessType,this._ratio,this._samplingMode);var i=g.attachPostProcess(this._postProcesses[d]);null===this._indicesForCamera[h]&&(this._indicesForCamera[h]=[]),this._indicesForCamera[h].push(i),-1===this._cameras.indexOf(g)&&(this._cameras[h]=g);for(var j in this._renderPasses)this._renderPasses[j]._incRefCount()}this._linkParameters()},b.prototype._detachCameras=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){var e=c[d],f=e.name;e.detachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f]);var g=this._cameras.indexOf(f);this._indicesForCamera.splice(g,1),this._cameras.splice(g,1);for(var h in this._renderPasses)this._renderPasses[h]._decRefCount()}},b.prototype._enable=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){for(var e=c[d],f=e.name,g=0;g<this._indicesForCamera[f].length;g++)void 0===e._postProcesses[this._indicesForCamera[f][g]]&&b[d].attachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f][g]);for(var h in this._renderPasses)this._renderPasses[h]._incRefCount()}},b.prototype._disable=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){var e=c[d],f=e.Name;e.detachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f]);for(var g in this._renderPasses)this._renderPasses[g]._decRefCount()}},b.prototype.getPostProcess=function(a){return this._singleInstance?this._postProcesses[0]:this._postProcesses[a.name]},b.prototype._linkParameters=function(){var a=this;for(var b in this._postProcesses)this._postProcesses[b].onApply=function(b){a.parameters(b),a._linkTextures(b)}},b.prototype._linkTextures=function(a){for(var b in this._renderPasses)a.setTexture(b,this._renderPasses[b].getRenderTexture());for(var c in this._renderEffectAsPasses)a.setTextureFromPostProcess(c+"Sampler",this._renderEffectAsPasses[c].getPostProcess())},b}();a.PostProcessRenderEffect=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b){this._engine=a,this._name=b,this._renderEffects=[],this._renderEffectsForIsolatedPass=[],this._cameras=[]}return b.prototype.addEffect=function(a){this._renderEffects[a._name]=a},b.prototype._enableEffect=function(b,c){var d=this._renderEffects[b];d&&d.enable(a.Tools.MakeArray(c||this._cameras))},b.prototype._disableEffect=function(b,c){var d=this._renderEffects[b];d&&d.disable(a.Tools.MakeArray(c||this._cameras))},b.prototype._attachCameras=function(b,c){for(var d=a.Tools.MakeArray(b||this._cameras),e=[],f=0;f<d.length;f++){var g=d[f],h=g.name;-1===this._cameras.indexOf(g)?this._cameras[h]=g:c&&e.push(f)}for(var f=0;f<e.length;f++)b.splice(e[f],1);for(var i in this._renderEffects)this._renderEffects[i]._attachCameras(d)},b.prototype._detachCameras=function(b){var c=a.Tools.MakeArray(b||this._cameras);for(var d in this._renderEffects)this._renderEffects[d]._detachCameras(c);for(var e=0;e<c.length;e++)this._cameras.splice(this._cameras.indexOf(c[e]),1)},b.prototype._enableDisplayOnlyPass=function(c,d){var e=a.Tools.MakeArray(d||this._cameras),f=null;for(var g in this._renderEffects)if(f=this._renderEffects[g].getPass(c),null!=f)break;if(null!==f){for(var g in this._renderEffects)this._renderEffects[g]._disable(e);f._name=b.PASS_SAMPLER_NAME;for(var h=0;h<e.length;h++){var i=e[h],j=i.name;this._renderEffectsForIsolatedPass[j]=this._renderEffectsForIsolatedPass[j]||new a.PostProcessRenderEffect(this._engine,b.PASS_EFFECT_NAME,"BABYLON.DisplayPassPostProcess",1,null,null),this._renderEffectsForIsolatedPass[j].emptyPasses(),this._renderEffectsForIsolatedPass[j].addPass(f),this._renderEffectsForIsolatedPass[j]._attachCameras(i)}}},b.prototype._disableDisplayOnlyPass=function(c){for(var d=a.Tools.MakeArray(c||this._cameras),e=0;e<d.length;e++){var f=d[e],g=f.name;this._renderEffectsForIsolatedPass[g]=this._renderEffectsForIsolatedPass[g]||new a.PostProcessRenderEffect(this._engine,b.PASS_EFFECT_NAME,"BABYLON.DisplayPassPostProcess",1,null,null),this._renderEffectsForIsolatedPass[g]._disable(f)}for(var h in this._renderEffects)this._renderEffects[h]._enable(d)},b.prototype._update=function(){for(var a in this._renderEffects)this._renderEffects[a]._update();for(var b=0;b<this._cameras.length;b++){var c=this._cameras[b].name;this._renderEffectsForIsolatedPass[c]&&this._renderEffectsForIsolatedPass[c]._update()}},b.PASS_EFFECT_NAME="passEffect",b.PASS_SAMPLER_NAME="passSampler",b}();a.PostProcessRenderPipeline=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(){this._renderPipelines=[]}return a.prototype.addPipeline=function(a){this._renderPipelines[a._name]=a},a.prototype.attachCamerasToRenderPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.attachCameras(b,c)},a.prototype.detachCamerasFromRenderPipeline=function(a,b){var c=this._renderPipelines[a];c&&c.detachCameras(b)},a.prototype.enableEffectInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.enableEffect(b,c)},a.prototype.disableEffectInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.disableEffect(b,c)},a.prototype.enableDisplayOnlyPassInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.enableDisplayOnlyPass(b,c)},a.prototype.disableDisplayOnlyPassInPipeline=function(a,b){var c=this._renderPipelines[a];c&&c.disableDisplayOnlyPass(b)},a.prototype.update=function(){for(var a in this._renderPipelines)this._renderPipelines[a]._update()},a}();a.PostProcessRenderPipelineManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"displayPass",["passSampler"],["passSampler"],c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.DisplayPassPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.frontColor=new a.Color3(1,1,1),this.backColor=new a.Color3(.1,.1,.1),this.showBackLines=!0,this.renderList=new a.SmartArray(32),this._scene=b,this._colorShader=new a.ShaderMaterial("colorShader",b,"color",{attributes:["position"],uniforms:["worldViewProjection","color"]});var c=this._scene.getEngine(),d=a.VertexData.CreateBox(1);this._vb=new a.VertexBuffer(c,d.positions,a.VertexBuffer.PositionKind,!1),this._ib=c.createIndexBuffer([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,7,1,6,2,5,3,4])}return b.prototype.reset=function(){this.renderList.reset()},b.prototype.render=function(){if(0!=this.renderList.length&&this._colorShader.isReady()){var b=this._scene.getEngine();b.setDepthWrite(!1),this._colorShader._preBind();for(var c=0;c<this.renderList.length;c++){var d=this.renderList.data[c],e=d.minimum,f=d.maximum,g=f.subtract(e),h=e.add(g.scale(.5)),i=a.Matrix.Scaling(g.x,g.y,g.z).multiply(a.Matrix.Translation(h.x,h.y,h.z)).multiply(d.getWorldMatrix());b.bindBuffers(this._vb.getBuffer(),this._ib,[3],12,this._colorShader.getEffect()),this.showBackLines&&(b.setDepthFunctionToGreaterOrEqual(),this._colorShader.setColor3("color",this.backColor),this._colorShader.bind(i),b.draw(!1,0,24)),b.setDepthFunctionToLess(),this._colorShader.setColor3("color",this.frontColor),this._colorShader.bind(i),b.draw(!1,0,24)}this._colorShader.unbind(),b.setDepthFunctionToLessOrEqual(),b.setDepthWrite(!0)}},b.prototype.dispose=function(){this._colorShader.dispose(),this._vb.dispose(),this._scene.getEngine()._releaseBuffer(this._ib)},b}();a.BoundingBoxRenderer=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(b){var c=function(){function b(){}return b.GetTGAHeader=function(a){var b=0,c={id_length:a[b++],colormap_type:a[b++],image_type:a[b++],colormap_index:a[b++]|a[b++]<<8,colormap_length:a[b++]|a[b++]<<8,colormap_size:a[b++],origin:[a[b++]|a[b++]<<8,a[b++]|a[b++]<<8],width:a[b++]|a[b++]<<8,height:a[b++]|a[b++]<<8,pixel_size:a[b++],flags:a[b++]};return c},b.UploadContent=function(c,d){if(d.length<19)return void a.Tools.Error("Unable to load TGA file - Not enough data to contain header");var e=18,f=b.GetTGAHeader(d);if(f.id_length+e>d.length)return void a.Tools.Error("Unable to load TGA file - Not enough data");e+=f.id_length;var g=!1,h=!1,i=!1,j=!1;switch(f.image_type){case b._TYPE_RLE_INDEXED:g=!0;case b._TYPE_INDEXED:h=!0;break;case b._TYPE_RLE_RGB:g=!0;case b._TYPE_RGB:i=!0;break;case b._TYPE_RLE_GREY:g=!0;case b._TYPE_GREY:j=!0}var k,l,m=(15&f.flags,f.pixel_size>>3),n=f.width*f.height*m;if(h&&(l=d.subarray(e,e+=f.colormap_length*(f.colormap_size>>3))),g){k=new Uint8Array(n);for(var o,p,q,r=0,s=new Uint8Array(m);n>e;)if(o=d[e++],p=(127&o)+1,128&o){for(q=0;m>q;++q)s[q]=d[e++];for(q=0;p>q;++q)k.set(s,r+q*m);r+=m*p}else{for(p*=m,q=0;p>q;++q)k[r+q]=d[e++];r+=p}}else k=d.subarray(e,e+=h?f.width*f.height:n);var t,u,v,w,x,y;switch((f.flags&b._ORIGIN_MASK)>>b._ORIGIN_SHIFT){default:case b._ORIGIN_UL:t=0,v=1,y=f.width,u=0,w=1,x=f.height;break;case b._ORIGIN_BL:t=0,v=1,y=f.width,u=f.height-1,w=-1,x=-1;break;case b._ORIGIN_UR:t=f.width-1,v=-1,y=-1,u=0,w=1,x=f.height;break;case b._ORIGIN_BR:t=f.width-1,v=-1,y=-1,u=f.height-1,w=-1,x=-1}var z="_getImageData"+(j?"Grey":"")+f.pixel_size+"bits",A=b[z](f,l,k,u,w,x,t,v,y);c.texImage2D(c.TEXTURE_2D,0,c.RGBA,f.width,f.height,0,c.RGBA,c.UNSIGNED_BYTE,A)},b._getImageData8bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=b,o=a.width,p=a.height,q=0,r=new Uint8Array(o*p*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,q++)j=m[q],r[4*(k+o*l)+3]=255,r[4*(k+o*l)+2]=n[3*j+0],r[4*(k+o*l)+1]=n[3*j+1],r[4*(k+o*l)+0]=n[3*j+2];return r},b._getImageData16bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=a.width,o=a.height,p=0,q=new Uint8Array(n*o*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,p+=2)j=m[p+0]+(m[p+1]<<8),q[4*(k+n*l)+0]=(31744&j)>>7,q[4*(k+n*l)+1]=(992&j)>>2,q[4*(k+n*l)+2]=(31&j)>>3,q[4*(k+n*l)+3]=32768&j?0:255;return q},b._getImageData24bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=3)p[4*(j+m*k)+3]=255,p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+1]=l[o+1],p[4*(j+m*k)+0]=l[o+2];return p},b._getImageData32bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=4)p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+1]=l[o+1],p[4*(j+m*k)+0]=l[o+2],p[4*(j+m*k)+3]=l[o+3];return p},b._getImageDataGrey8bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=a.width,o=a.height,p=0,q=new Uint8Array(n*o*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,p++)j=m[p],q[4*(k+n*l)+0]=j,q[4*(k+n*l)+1]=j,q[4*(k+n*l)+2]=j,q[4*(k+n*l)+3]=255;return q},b._getImageDataGrey16bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=2)p[4*(j+m*k)+0]=l[o+0],p[4*(j+m*k)+1]=l[o+0],p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+3]=l[o+1];return p},b._TYPE_NO_DATA=0,b._TYPE_INDEXED=1,b._TYPE_RGB=2,b._TYPE_GREY=3,b._TYPE_RLE_INDEXED=9,b._TYPE_RLE_RGB=10,b._TYPE_RLE_GREY=11,b._ORIGIN_MASK=48,b._ORIGIN_SHIFT=4,b._ORIGIN_BL=0,b._ORIGIN_BR=1,b._ORIGIN_UL=2,b._ORIGIN_UR=3,b}();b.TGATools=c}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}function d(a){return String.fromCharCode(255&a,a>>8&255,a>>16&255,a>>24&255)}var e=542327876,f=131072,g=512,h=4,i=64,j=131072,k=c("DXT1"),l=c("DXT3"),m=c("DXT5"),n=31,o=0,p=1,q=2,r=3,s=4,t=7,u=20,v=21,w=22,x=28,y=function(){function b(){}return b.GetDDSInfo=function(a){var b=new Int32Array(a,0,n),c=1;return b[q]&f&&(c=Math.max(1,b[t])),{width:b[s],height:b[r],mipmapCount:c,isFourCC:(b[u]&h)===h,isRGB:(b[u]&i)===i,isLuminance:(b[u]&j)===j,isCube:(b[x]&g)===g}},b.GetRGBAArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+4*(j+i*a);f[h+2]=g[k],f[h+1]=g[k+1],f[h]=g[k+2],f[h+3]=g[k+3],h+=4}return f},b.GetRGBArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+3*(j+i*a);f[h+2]=g[k],f[h+1]=g[k+1],f[h]=g[k+2],h+=3}return f},b.GetLuminanceArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+(j+i*a);f[h]=g[k],h++}return f},b.UploadDDSLevels=function(c,g,h,i,j,u){var x,y,z,A,B,C,D,E,F,G,H=new Int32Array(h,0,n);if(H[o]!=e)return void a.Tools.Error("Invalid magic number in DDS header");if(!i.isFourCC&&!i.isRGB&&!i.isLuminance)return void a.Tools.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(i.isFourCC)switch(x=H[v]){case k:y=8,z=g.COMPRESSED_RGBA_S3TC_DXT1_EXT;break;case l:y=16,z=g.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case m:y=16,z=g.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;default:return void console.error("Unsupported FourCC code:",d(x))}F=1,H[q]&f&&j!==!1&&(F=Math.max(1,H[t]));for(var I=H[w],J=0;u>J;J++){var K=1==u?c.TEXTURE_2D:c.TEXTURE_CUBE_MAP_POSITIVE_X+J;for(A=H[s],B=H[r],D=H[p]+4,G=0;F>G;++G){if(i.isRGB)24==I?(C=A*B*3,E=b.GetRGBArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.RGB,A,B,0,c.RGB,c.UNSIGNED_BYTE,E)):(C=A*B*4,E=b.GetRGBAArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.RGBA,A,B,0,c.RGBA,c.UNSIGNED_BYTE,E));else if(i.isLuminance){var L=c.getParameter(c.UNPACK_ALIGNMENT),M=A,N=Math.floor((A+L-1)/L)*L;C=N*(B-1)+M,E=b.GetLuminanceArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.LUMINANCE,A,B,0,c.LUMINANCE,c.UNSIGNED_BYTE,E)}else C=Math.max(4,A)/4*Math.max(4,B)/4*y,E=new Uint8Array(h,D,C),c.compressedTexImage2D(K,G,z,A,B,0,E);D+=C,A*=.5,B*=.5,A=Math.max(1,A),B=Math.max(1,B)}}},b}();b.DDSTools=y}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(b){this.length=0,this._duplicateId=0,this.data=new Array(b),this._id=a._GlobalId++}return a.prototype.push=function(a){this.data[this.length++]=a,this.length>this.data.length&&(this.data.length*=2),a.__smartArrayFlags||(a.__smartArrayFlags={}),a.__smartArrayFlags[this._id]=this._duplicateId},a.prototype.pushNoDuplicate=function(a){a.__smartArrayFlags&&a.__smartArrayFlags[this._id]===this._duplicateId||this.push(a)
},a.prototype.sort=function(a){this.data.sort(a)},a.prototype.reset=function(){this.length=0,this._duplicateId++},a.prototype.concat=function(a){if(0!==a.length){this.length+a.length>this.data.length&&(this.data.length=2*(this.length+a.length));for(var b=0;b<a.length;b++)this.data[this.length++]=(a.data||a)[b]}},a.prototype.concatWithNoDuplicate=function(a){if(0!==a.length){this.length+a.length>this.data.length&&(this.data.length=2*(this.length+a.length));for(var b=0;b<a.length;b++){var c=(a.data||a)[b];this.pushNoDuplicate(c)}}},a.prototype.indexOf=function(a){var b=this.data.indexOf(a);return b>=this.length?-1:b},a._GlobalId=0,a}();a.SmartArray=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this._registeredMeshes=[],this._physicsMaterials=[],this.updateBodyPosition=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent){var d=c.body.body;return d.position.set(a.position.x,a.position.z,a.position.y),d.quaternion.x=a.rotationQuaternion.x,d.quaternion.z=a.rotationQuaternion.y,d.quaternion.y=a.rotationQuaternion.z,void(d.quaternion.w=-a.rotationQuaternion.w)}}}}return b.prototype.initialize=function(a){"undefined"==typeof a&&(a=10),this._world=new CANNON.World,this._world.broadphase=new CANNON.NaiveBroadphase,this._world.solver.iterations=a},b.prototype._checkWithEpsilon=function(b){return b<a.PhysicsEngine.Epsilon?a.PhysicsEngine.Epsilon:b},b.prototype.runOneStep=function(b){this._world.step(b);for(var c=0;c<this._registeredMeshes.length;c++){var d=this._registeredMeshes[c];d.isChild||(d.mesh.position.x=d.body.position.x,d.mesh.position.y=d.body.position.z,d.mesh.position.z=d.body.position.y,d.mesh.rotationQuaternion||(d.mesh.rotationQuaternion=new a.Quaternion(0,0,0,1)),d.mesh.rotationQuaternion.x=d.body.quaternion.x,d.mesh.rotationQuaternion.y=d.body.quaternion.z,d.mesh.rotationQuaternion.z=d.body.quaternion.y,d.mesh.rotationQuaternion.w=-d.body.quaternion.w)}},b.prototype.setGravity=function(a){this._world.gravity.set(a.x,a.z,a.y)},b.prototype.registerMesh=function(b,c,d){switch(this.unregisterMesh(b),b.computeWorldMatrix(!0),c){case a.PhysicsEngine.SphereImpostor:var e=b.getBoundingInfo().boundingBox,f=e.maximumWorld.x-e.minimumWorld.x,g=e.maximumWorld.y-e.minimumWorld.y,h=e.maximumWorld.z-e.minimumWorld.z;return this._createSphere(Math.max(this._checkWithEpsilon(f),this._checkWithEpsilon(g),this._checkWithEpsilon(h))/2,b,d);case a.PhysicsEngine.BoxImpostor:e=b.getBoundingInfo().boundingBox;var i=e.minimumWorld,j=e.maximumWorld,k=j.subtract(i).scale(.5);return this._createBox(this._checkWithEpsilon(k.x),this._checkWithEpsilon(k.y),this._checkWithEpsilon(k.z),b,d);case a.PhysicsEngine.PlaneImpostor:return this._createPlane(b,d);case a.PhysicsEngine.MeshImpostor:var l=b.getVerticesData(a.VertexBuffer.PositionKind),m=b.getIndices();return this._createConvexPolyhedron(l,m,b,d)}return null},b.prototype._createSphere=function(a,b,c){var d=new CANNON.Sphere(a);return c?this._createRigidBodyFromShape(d,b,c.mass,c.friction,c.restitution):d},b.prototype._createBox=function(a,b,c,d,e){var f=new CANNON.Box(new CANNON.Vec3(a,c,b));return e?this._createRigidBodyFromShape(f,d,e.mass,e.friction,e.restitution):f},b.prototype._createPlane=function(a,b){var c=new CANNON.Plane;return b?this._createRigidBodyFromShape(c,a,b.mass,b.friction,b.restitution):c},b.prototype._createConvexPolyhedron=function(b,c,d,e){var f=[],g=[];d.computeWorldMatrix(!0);for(var h=0;h<b.length;h+=3){var i=a.Vector3.Zero();a.Vector3.TransformNormalFromFloatsToRef(b[h],b[h+1],b[h+2],d.getWorldMatrix(),i),f.push(new CANNON.Vec3(i.x,i.z,i.y))}for(var j=0;j<c.length;j+=3)g.push([c[j],c[j+2],c[j+1]]);var k=new CANNON.ConvexPolyhedron(f,g);return e?this._createRigidBodyFromShape(k,d,e.mass,e.friction,e.restitution):k},b.prototype._addMaterial=function(a,b){var c,d;for(c=0;c<this._physicsMaterials.length;c++)if(d=this._physicsMaterials[c],d.friction===a&&d.restitution===b)return d;var e=new CANNON.Material;for(e.friction=a,e.restitution=b,this._physicsMaterials.push(e),c=0;c<this._physicsMaterials.length;c++){d=this._physicsMaterials[c];var f=new CANNON.ContactMaterial(d,e,d.friction*e.friction,d.restitution*e.restitution);f.contactEquationStiffness=1e10,f.contactEquationRegularizationTime=10,this._world.addContactMaterial(f)}return e},b.prototype._createRigidBodyFromShape=function(b,c,d,e,f){var g=null;c.rotationQuaternion&&(g=c.rotationQuaternion.clone(),c.rotationQuaternion=new a.Quaternion(0,0,0,1));var h=this._addMaterial(e,f),i=new CANNON.RigidBody(d,b,h);return g&&(i.quaternion.x=g.x,i.quaternion.z=g.y,i.quaternion.y=g.z,i.quaternion.w=-g.w),i.position.set(c.position.x,c.position.z,c.position.y),this._world.add(i),this._registeredMeshes.push({mesh:c,body:i,material:h}),i},b.prototype.registerMeshesAsCompound=function(a,b){for(var c=new CANNON.Compound,d=0;d<a.length;d++){var e=a[d].mesh,f=this.registerMesh(e,a[d].impostor);0==d?c.addChild(f,new CANNON.Vec3(0,0,0)):c.addChild(f,new CANNON.Vec3(e.position.x,e.position.z,e.position.y))}var g=a[0].mesh,h=this._createRigidBodyFromShape(c,g,b.mass,b.friction,b.restitution);return h.parts=a,h},b.prototype._unbindBody=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];c.body===a&&(c.body=null)}},b.prototype.unregisterMesh=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a)return c.body&&(this._world.remove(c.body),this._unbindBody(c.body)),void this._registeredMeshes.splice(b,1)}},b.prototype.applyImpulse=function(a,b,c){for(var d=new CANNON.Vec3(c.x,c.z,c.y),e=new CANNON.Vec3(b.x,b.z,b.y),f=0;f<this._registeredMeshes.length;f++){var g=this._registeredMeshes[f];if(g.mesh===a)return void g.body.applyImpulse(e,d)}},b.prototype.createLink=function(a,b,c,d){for(var e=null,f=null,g=0;g<this._registeredMeshes.length;g++){var h=this._registeredMeshes[g];h.mesh===a?e=h.body:h.mesh===b&&(f=h.body)}if(!e||!f)return!1;var i=new CANNON.PointToPointConstraint(e,new CANNON.Vec3(c.x,c.z,c.y),f,new CANNON.Vec3(d.x,d.z,d.y));return this._world.addConstraint(i),!0},b.prototype.dispose=function(){for(;this._registeredMeshes.length;)this.unregisterMesh(this._registeredMeshes[0].mesh)},b.prototype.isSupported=function(){return void 0!==window.CANNON},b}();a.CannonJSPlugin=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function a(a){this._actionManager=a}return a.prototype.isValid=function(){return!0},a.prototype._getProperty=function(a){return this._actionManager._getProperty(a)},a.prototype._getEffectiveTarget=function(a,b){return this._actionManager._getEffectiveTarget(a,b)},a}();a.Condition=b;var c=function(a){function b(c,d,e,f,g){"undefined"==typeof g&&(g=b.IsEqual),a.call(this,c),this.propertyPath=e,this.value=f,this.operator=g,this._target=this._getEffectiveTarget(d,this.propertyPath),this._property=this._getProperty(this.propertyPath)}return __extends(b,a),Object.defineProperty(b,"IsEqual",{get:function(){return b._IsEqual},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsDifferent",{get:function(){return b._IsDifferent},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsGreater",{get:function(){return b._IsGreater},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsLesser",{get:function(){return b._IsLesser},enumerable:!0,configurable:!0}),b.prototype.isValid=function(){switch(this.operator){case b.IsGreater:return this._target[this._property]>this.value;case b.IsLesser:return this._target[this._property]<this.value;case b.IsEqual:case b.IsDifferent:var a;return a=this.value.equals?this.value.equals(this._target[this._property]):this.value===this._target[this._property],this.operator===b.IsEqual?a:!a}return!1},b._IsEqual=0,b._IsDifferent=1,b._IsGreater=2,b._IsLesser=3,b}(b);a.ValueCondition=c;var d=function(a){function b(b,c){a.call(this,b),this.predicate=c}return __extends(b,a),b.prototype.isValid=function(){return this.predicate()},b}(b);a.PredicateCondition=d;var e=function(a){function b(b,c,d){a.call(this,b),this.value=d,this._target=c}return __extends(b,a),b.prototype.isValid=function(){return this._target.state===this.value},b}(b);a.StateCondition=e}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b){this.triggerOptions=a,a.parameter?(this.trigger=a.trigger,this._triggerParameter=a.parameter):this.trigger=a,this._nextActiveAction=this,this._condition=b}return a.prototype._prepare=function(){},a.prototype.getTriggerParameter=function(){return this._triggerParameter},a.prototype._executeCurrent=function(a){if(this._condition){var b=this._actionManager.getScene().getRenderId();if(this._condition._evaluationId===b){if(!this._condition._currentResult)return}else{if(this._condition._evaluationId=b,!this._condition.isValid())return void(this._condition._currentResult=!1);this._condition._currentResult=!0}}this._nextActiveAction.execute(a),this._nextActiveAction=this._nextActiveAction._child?this._nextActiveAction._child:this},a.prototype.execute=function(){},a.prototype.then=function(a){return this._child=a,a._actionManager=this._actionManager,a._prepare(),a},a.prototype._getProperty=function(a){return this._actionManager._getProperty(a)},a.prototype._getEffectiveTarget=function(a,b){return this._actionManager._getEffectiveTarget(a,b)},a}();a.Action=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c,d,e){this.source=a,this.pointerX=b,this.pointerY=c,this.meshUnderPointer=d,this.sourceEvent=e}return a.CreateNew=function(b){var c=b.getScene();return new a(b,c.pointerX,c.pointerY,c.meshUnderPointer)},a.CreateNewFromScene=function(b,c){return new a(null,b.pointerX,b.pointerY,b.meshUnderPointer,c)},a}();a.ActionEvent=b;var c=function(){function b(a){this.actions=new Array,this._scene=a,a._actionManagers.push(this)}return Object.defineProperty(b,"NothingTrigger",{get:function(){return b._NothingTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPickTrigger",{get:function(){return b._OnPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnLeftPickTrigger",{get:function(){return b._OnLeftPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnRightPickTrigger",{get:function(){return b._OnRightPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnCenterPickTrigger",{get:function(){return b._OnCenterPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPointerOverTrigger",{get:function(){return b._OnPointerOverTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPointerOutTrigger",{get:function(){return b._OnPointerOutTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnEveryFrameTrigger",{get:function(){return b._OnEveryFrameTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnIntersectionEnterTrigger",{get:function(){return b._OnIntersectionEnterTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnIntersectionExitTrigger",{get:function(){return b._OnIntersectionExitTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnKeyDownTrigger",{get:function(){return b._OnKeyDownTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnKeyUpTrigger",{get:function(){return b._OnKeyUpTrigger},enumerable:!0,configurable:!0}),b.prototype.dispose=function(){var a=this._scene._actionManagers.indexOf(this);a>-1&&this._scene._actionManagers.splice(a,1)},b.prototype.getScene=function(){return this._scene},b.prototype.hasSpecificTriggers=function(a){for(var b=0;b<this.actions.length;b++){var c=this.actions[b];if(a.indexOf(c.trigger)>-1)return!0}return!1},Object.defineProperty(b.prototype,"hasPointerTriggers",{get:function(){for(var a=0;a<this.actions.length;a++){var c=this.actions[a];if(c.trigger>=b._OnPickTrigger&&c.trigger<=b._OnPointerOutTrigger)return!0}return!1},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"hasPickTriggers",{get:function(){for(var a=0;a<this.actions.length;a++){var c=this.actions[a];if(c.trigger>=b._OnPickTrigger&&c.trigger<=b._OnCenterPickTrigger)return!0}return!1},enumerable:!0,configurable:!0}),b.prototype.registerAction=function(c){return c.trigger===b.OnEveryFrameTrigger&&this.getScene().actionManager!==this?(a.Tools.Warn("OnEveryFrameTrigger can only be used with scene.actionManager"),null):(this.actions.push(c),c._actionManager=this,c._prepare(),c)},b.prototype.processTrigger=function(a,c){for(var d=0;d<this.actions.length;d++){var e=this.actions[d];if(e.trigger===a){if(a==b.OnKeyUpTrigger||a==b.OnKeyDownTrigger){var f=e.getTriggerParameter();if(f&&c.sourceEvent.key!==f)continue}e._executeCurrent(c)}}},b.prototype._getEffectiveTarget=function(a,b){for(var c=b.split("."),d=0;d<c.length-1;d++)a=a[c[d]];return a},b.prototype._getProperty=function(a){var b=a.split(".");return b[b.length-1]},b._NothingTrigger=0,b._OnPickTrigger=1,b._OnLeftPickTrigger=2,b._OnRightPickTrigger=3,b._OnCenterPickTrigger=4,b._OnPointerOverTrigger=5,b._OnPointerOutTrigger=6,b._OnEveryFrameTrigger=7,b._OnIntersectionEnterTrigger=8,b._OnIntersectionExitTrigger=9,b._OnKeyDownTrigger=10,b._OnKeyUpTrigger=11,b}();a.ActionManager=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d,e,f,g,h){"undefined"==typeof f&&(f=1e3),b.call(this,a,g),this.propertyPath=d,this.value=e,this.duration=f,this.stopOtherAnimations=h,this._target=c}return __extends(c,b),c.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},c.prototype.execute=function(){var b,c=this._actionManager.getScene(),d=[{frame:0,value:this._target[this._property]},{frame:100,value:this.value}];if("number"==typeof this.value)b=a.Animation.ANIMATIONTYPE_FLOAT;else if(this.value instanceof a.Color3)b=a.Animation.ANIMATIONTYPE_COLOR3;else if(this.value instanceof a.Vector3)b=a.Animation.ANIMATIONTYPE_VECTOR3;else if(this.value instanceof a.Matrix)b=a.Animation.ANIMATIONTYPE_MATRIX;else{if(!(this.value instanceof a.Quaternion))return void a.Tools.Warn("InterpolateValueAction: Unsupported type ("+typeof this.value+")");b=a.Animation.ANIMATIONTYPE_QUATERNION}var e=new a.Animation("InterpolateValueAction",this._property,100*(1e3/this.duration),b,a.Animation.ANIMATIONLOOPMODE_CONSTANT);e.setKeys(d),this.stopOtherAnimations&&c.stopAnimation(this._target),c.beginDirectAnimation(this._target,[e],0,100)},c}(a.Action);a.InterpolateValueAction=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e){a.call(this,b,e),this.propertyPath=d,this._target=c}return __extends(b,a),b.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},b.prototype.execute=function(){this._target[this._property]=!this._target[this._property]},b}(a.Action);a.SwitchBooleanAction=b;var c=function(a){function b(b,c,d,e){a.call(this,b,e),this.value=d,this._target=c}return __extends(b,a),b.prototype.execute=function(){this._target.state=this.value},b}(a.Action);a.SetStateAction=c;var d=function(a){function b(b,c,d,e,f){a.call(this,b,f),this.propertyPath=d,this.value=e,this._target=c}return __extends(b,a),b.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},b.prototype.execute=function(){this._target[this._property]=this.value},b}(a.Action);a.SetValueAction=d;var e=function(b){function c(a,c,d,e,f){b.call(this,a,f),this.propertyPath=d,this.value=e,this._target=c}return __extends(c,b),c.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath),"number"!=typeof this._target[this._property]&&a.Tools.Warn("Warning: IncrementValueAction can only be used with number values")},c.prototype.execute=function(){this._target[this._property]+=this.value},c}(a.Action);a.IncrementValueAction=e;var f=function(a){function b(b,c,d,e,f,g){a.call(this,b,g),this.from=d,this.to=e,this.loop=f,this._target=c}return __extends(b,a),b.prototype._prepare=function(){},b.prototype.execute=function(){var a=this._actionManager.getScene();a.beginAnimation(this._target,this.from,this.to,this.loop)},b}(a.Action);a.PlayAnimationAction=f;var g=function(a){function b(b,c,d){a.call(this,b,d),this._target=c}return __extends(b,a),b.prototype._prepare=function(){},b.prototype.execute=function(){var a=this._actionManager.getScene();a.stopAnimation(this._target)},b}(a.Action);a.StopAnimationAction=g;var h=function(b){function c(c,d){"undefined"==typeof c&&(c=a.ActionManager.NothingTrigger),b.call(this,c,d)}return __extends(c,b),c.prototype.execute=function(){},c}(a.Action);a.DoNothingAction=h;var i=function(a){function b(b,c,d){a.call(this,b,d),this.children=c}return __extends(b,a),b.prototype._prepare=function(){for(var a=0;a<this.children.length;a++)this.children[a]._actionManager=this._actionManager,this.children[a]._prepare()},b.prototype.execute=function(a){for(var b=0;b<this.children.length;b++)this.children[b].execute(a)},b}(a.Action);a.CombineAction=i;var j=function(a){function b(b,c,d){a.call(this,b,d),this.func=c}return __extends(b,a),b.prototype.execute=function(a){this.func(a)},b}(a.Action);a.ExecuteCodeAction=j;var k=function(b){function c(a,c,d,e){b.call(this,a,e),this._target=c,this._parent=d}return __extends(c,b),c.prototype._prepare=function(){},c.prototype.execute=function(){if(this._target.parent!==this._parent){var b=this._parent.getWorldMatrix().clone();b.invert(),this._target.position=a.Vector3.TransformCoordinates(this._target.position,b),this._target.parent=this._parent}},c}(a.Action);a.SetParentAction=k}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this._totalVertices=0,this._indices=[],this.id=b,this._engine=c.getEngine(),this._meshes=[],this._scene=c,d?this.setAllVerticesData(d,e):(this._totalVertices=0,this._indices=[]),f&&this.applyToMesh(f)}return b.prototype.getScene=function(){return this._scene},b.prototype.getEngine=function(){return this._engine},b.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADED||this.delayLoadState===a.Engine.DELAYLOADSTATE_NONE},b.prototype.setAllVerticesData=function(a,b){a.applyToGeometry(this,b)},b.prototype.setVerticesData=function(b,c,d){if(this._vertexBuffers=this._vertexBuffers||{},this._vertexBuffers[b]&&this._vertexBuffers[b].dispose(),this._vertexBuffers[b]=new a.VertexBuffer(this._engine,c,b,d,0===this._meshes.length),b===a.VertexBuffer.PositionKind){var e=this._vertexBuffers[b].getStrideSize();this._totalVertices=c.length/e;for(var f=a.Tools.ExtractMinAndMax(c,0,this._totalVertices),g=this._meshes,h=g.length,i=0;h>i;i++){var j=g[i];j._resetPointsArrayCache(),j._boundingInfo=new a.BoundingInfo(f.minimum,f.maximum),j._createGlobalSubMesh(),j.computeWorldMatrix(!0)}}},b.prototype.updateVerticesData=function(b,c,d){var e=this.getVertexBuffer(b);if(e&&(e.update(c),b===a.VertexBuffer.PositionKind)){var f;if(d){var g=e.getStrideSize();this._totalVertices=c.length/g,f=a.Tools.ExtractMinAndMax(c,0,this._totalVertices)}for(var h=this._meshes,i=h.length,j=0;i>j;j++){var k=h[j];k._resetPointsArrayCache(),d&&(k._boundingInfo=new a.BoundingInfo(f.minimum,f.maximum))}}},b.prototype.getTotalVertices=function(){return this.isReady()?this._totalVertices:0},b.prototype.getVerticesData=function(a){var b=this.getVertexBuffer(a);return b?b.getData():null},b.prototype.getVertexBuffer=function(a){return this.isReady()?this._vertexBuffers[a]:null},b.prototype.getVertexBuffers=function(){return this.isReady()?this._vertexBuffers:null},b.prototype.isVerticesDataPresent=function(a){return this._vertexBuffers?void 0!==this._vertexBuffers[a]:this._delayInfo?-1!==this._delayInfo.indexOf(a):!1},b.prototype.getVerticesDataKinds=function(){var a=[];if(!this._vertexBuffers&&this._delayInfo)for(var b in this._delayInfo)a.push(b);else for(b in this._vertexBuffers)a.push(b);return a},b.prototype.setIndices=function(a){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=a,0!==this._meshes.length&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices));for(var b=this._meshes,c=b.length,d=0;c>d;d++)b[d]._createGlobalSubMesh()},b.prototype.getTotalIndices=function(){return this.isReady()?this._indices.length:0},b.prototype.getIndices=function(){return this.isReady()?this._indices:null},b.prototype.getIndexBuffer=function(){return this.isReady()?this._indexBuffer:null},b.prototype.releaseForMesh=function(a,b){var c=this._meshes,d=c.indexOf(a);if(-1!==d){for(var e in this._vertexBuffers)this._vertexBuffers[e].dispose();this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer)&&(this._indexBuffer=null),c.splice(d,1),a._geometry=null,0==c.length&&b&&this.dispose()}},b.prototype.applyToMesh=function(a){if(a._geometry!==this){var b=a._geometry;b&&b.releaseForMesh(a);var c=this._meshes;a._geometry=this,this._scene.pushGeometry(this),c.push(a),this.isReady()?this._applyToMesh(a):a._boundingInfo=this._boundingInfo}},b.prototype._applyToMesh=function(b){var c=this._meshes.length;for(var d in this._vertexBuffers)if(1===c&&this._vertexBuffers[d].create(),this._vertexBuffers[d]._buffer.references=c,d===a.VertexBuffer.PositionKind){b._resetPointsArrayCache();var e=a.Tools.ExtractMinAndMax(this._vertexBuffers[d].getData(),0,this._totalVertices);b._boundingInfo=new a.BoundingInfo(e.minimum,e.maximum),b._createGlobalSubMesh()}1===c&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices)),this._indexBuffer&&(this._indexBuffer.references=c)},b.prototype.load=function(b,c){var d=this;if(this.delayLoadState!==a.Engine.DELAYLOADSTATE_LOADING){if(this.isReady())return void(c&&c());this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADING,b._addPendingData(this),a.Tools.LoadFile(this.delayLoadingFile,function(e){d._delayLoadingFunction(JSON.parse(e),d),d.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,d._delayInfo=[],b._removePendingData(d);for(var f=d._meshes,g=f.length,h=0;g>h;h++)d._applyToMesh(f[h]);c&&c()},function(){},b.database)}},b.prototype.dispose=function(){for(var b=this._meshes,c=b.length,d=0;c>d;d++)this.releaseForMesh(b[d]);this._meshes=[];for(var e in this._vertexBuffers)this._vertexBuffers[e].dispose();this._vertexBuffers=[],this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null;var f=this._scene.getGeometries();d=f.indexOf(this),d>-1&&f.splice(d,1)},b.prototype.copy=function(b){var c=new a.VertexData;c.indices=[];for(var d=this.getIndices(),e=0;e<d.length;e++)c.indices.push(d[e]);var f=!1,g=!1;for(var h in this._vertexBuffers)c.set(this.getVerticesData(h),h),g||(f=this.getVertexBuffer(h).isUpdatable(),g=!f);var i=new a.Geometry(b,this._scene,c,f,null);i.delayLoadState=this.delayLoadState,i.delayLoadingFile=this.delayLoadingFile,i._delayLoadingFunction=this._delayLoadingFunction;for(h in this._delayInfo)i._delayInfo=i._delayInfo||[],i._delayInfo.push(h);var j=a.Tools.ExtractMinAndMax(this.getVerticesData(a.VertexBuffer.PositionKind),0,this.getTotalVertices());return i._boundingInfo=new a.BoundingInfo(j.minimum,j.maximum),i},b.ExtractFromMesh=function(a,b){var c=a._geometry;return c?c.copy(b):null},b.RandomId=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(a){var b=16*Math.random()|0,c="x"==a?b:3&b|8;return c.toString(16)})},b}();a.Geometry=b,function(b){!function(c){var d=function(a){function b(b,c,d,e,f){this._beingRegenerated=!0,this._canBeRegenerated=e,a.call(this,b,c,d,!1,f),this._beingRegenerated=!1}return __extends(b,a),b.prototype.canBeRegenerated=function(){return this._canBeRegenerated},b.prototype.regenerate=function(){this._canBeRegenerated&&(this._beingRegenerated=!0,this.setAllVerticesData(this._regenerateVertexData(),!1),this._beingRegenerated=!1)},b.prototype.asNewGeometry=function(b){return a.prototype.copy.call(this,b)},b.prototype.setAllVerticesData=function(b){this._beingRegenerated&&a.prototype.setAllVerticesData.call(this,b,!1)},b.prototype.setVerticesData=function(b,c){this._beingRegenerated&&a.prototype.setVerticesData.call(this,b,c,!1)},b.prototype._regenerateVertexData=function(){throw new Error("Abstract method")},b.prototype.copy=function(){throw new Error("Must be overriden in sub-classes.")},b}(b);c._Primitive=d;var e=function(b){function c(a,c,d,e,f){this.size=d,b.call(this,a,c,this._regenerateVertexData(),e,f)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateBox(this.size)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.size,this.canBeRegenerated(),null)},c}(d);c.Box=e;var f=function(b){function c(a,c,d,e,f,g){this.segments=d,this.diameter=e,b.call(this,a,c,this._regenerateVertexData(),f,g)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateSphere(this.segments,this.diameter)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.segments,this.diameter,this.canBeRegenerated(),null)},c}(d);c.Sphere=f;var g=function(b){function c(a,c,d,e,f,g,h,i,j){"undefined"==typeof h&&(h=1),this.height=d,this.diameterTop=e,this.diameterBottom=f,this.tessellation=g,this.subdivisions=h,b.call(this,a,c,this._regenerateVertexData(),i,j)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateCylinder(this.height,this.diameterTop,this.diameterBottom,this.tessellation,this.subdivisions)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.height,this.diameterTop,this.diameterBottom,this.tessellation,this.subdivisions,this.canBeRegenerated(),null)},c}(d);c.Cylinder=g;var h=function(b){function c(a,c,d,e,f,g,h){this.diameter=d,this.thickness=e,this.tessellation=f,b.call(this,a,c,this._regenerateVertexData(),g,h)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTorus(this.diameter,this.thickness,this.tessellation)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.diameter,this.thickness,this.tessellation,this.canBeRegenerated(),null)},c}(d);c.Torus=h;var i=function(b){function c(a,c,d,e,f,g,h){this.width=d,this.height=e,this.subdivisions=f,b.call(this,a,c,this._regenerateVertexData(),g,h)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateGround(this.width,this.height,this.subdivisions)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.width,this.height,this.subdivisions,this.canBeRegenerated(),null)},c}(d);c.Ground=i;var j=function(b){function c(a,c,d,e,f,g,h,i,j,k){this.xmin=d,this.zmin=e,this.xmax=f,this.zmax=g,this.subdivisions=h,this.precision=i,b.call(this,a,c,this._regenerateVertexData(),j,k)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTiledGround(this.xmin,this.zmin,this.xmax,this.zmax,this.subdivisions,this.precision)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.xmin,this.zmin,this.xmax,this.zmax,this.subdivisions,this.precision,this.canBeRegenerated(),null)},c}(d);c.TiledGround=j;var k=function(b){function c(a,c,d,e,f){this.size=d,b.call(this,a,c,this._regenerateVertexData(),e,f)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreatePlane(this.size)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.size,this.canBeRegenerated(),null)},c}(d);c.Plane=k;var l=function(b){function c(a,c,d,e,f,g,h,i,j,k){this.radius=d,this.tube=e,this.radialSegments=f,this.tubularSegments=g,this.p=h,this.q=i,b.call(this,a,c,this._regenerateVertexData(),j,k)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTorusKnot(this.radius,this.tube,this.radialSegments,this.tubularSegments,this.p,this.q)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.radius,this.tube,this.radialSegments,this.tubularSegments,this.p,this.q,this.canBeRegenerated(),null)},c}(d);c.TorusKnot=l}(b.Primitives||(b.Primitives={}));b.Primitives}(a.Geometry||(a.Geometry={}));var b=a.Geometry}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function b(a){var b=this;this.babylonGamepads=[],this.oneGamepadConnected=!1,this.isMonitoring=!1,this.gamepadEventSupported="GamepadEvent"in window,this.gamepadSupportAvailable=navigator.getGamepads||!!navigator.webkitGetGamepads||!!navigator.msGetGamepads||!!navigator.webkitGamepads,this.buttonADataURL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAA9aSURBVHja7FtpbBzneX7m3otcihSpm9Z9UJalxPKhVLZlp6ktNzEaxE0CtAnQAgnSoPWPBi3syuiPwordFi5Qt2haFygCoylSV4Vby6os1I3kOLYrS65kXXQoypJJSaFEUTyXy925+rzfzC6HFFlL1kpAIe7i5czO7H7zPs97ft8MtTAMcSu/dNzirxkCZgiYIWCGgBkCZgi4hV/mDR5fSxAt+0ZiX0ucDxMSTJLK+f83BFSA6TFgK75OclshouKBFbA+xaV4k7Z+fD6sNRlmjYFXQMu4NiUVS/oHe5/ecnHo3MYxd7QthN9UcsdW6FqEPwgDOFbqpAajL2VlTrTULzj4Ow8+s4+nipSxWMoxIUkyrl/pGswFtIR7WzHgDCX77K7vfHNkbOA+AryjYZadb27OIJdzCNZBKmXw4kbk35qPsTEfJbeEkZESentHMdBfGtY142gu1bDvqV/925f4tQJlNCaj4hXX7RHXS0AFuJEAXvfHr/zmk67vPjir0V68aFEe8xtuQ6O1FHlrEXLmHBiaDUtzYBlpNYjrF+GFZfhhCcPeBQy53ehzT+H8QBe6uwfRf7l8xjKsvX/y5X98jl8fThDhJ4i46QQkrS5I6v7oX7/++77vPtLUlFnZtnIRlubvxRxnHbJmE79sxD/SqG0oZk8MFarRqufUkQAFrxcXSkfx0eB+nOggKX2jHYZhvf79r/z4L2IiipO84aYRkASfefnAX695p3P3c9mM/UufuaMVdzRvxVx7A0xaWdOMqVULJ6Z3TZv6KmHo0ztK6CkfxpHe3Th0pAuF0fLbn1u+9cmv3vW77bE3fGoSPi0BVfAvvPEHm9rPv//iooWz5m9Z/wCWZx+Go9UrN48QTD9IGMZ1cJIzTPisRQclPMrhME4W9mDfB2+i+2z/+TXz7/z2E7/85+9OIuGGE6BV3H77zm/d33nx6Ktr18zFg2t+DQude2n1tLJ8tcJ90vDhpG5Am7qTkJAQErywiLOld7G3/d9xvL0Hy1vWPbbtS3//00Q4hDeaAFXintrx1fu7+jp2r13bgofX/gaazbVkJQdLT9P6VqRFDSu2hIgXlBUBLgtCr3cce47/CMePX0Rr08qtzz7+8k8TpfKGtcKq1jPZre7oObyjdWkGd628l7AXwvMCeL7HjO6qrS8S1E5kTE9tfbiur665ccU9EB1EF9Ep0WXesEZIJb9j5/b/XUtzNrt29Rw0og2lchmBVqLo8LSAHlCixbTpddGm8Y7pjkttCCUP+JQy3FiatNuxdvUx9F4ayopO/OL9sQeEN4oA/eHn577oWPbGVes11PsrUBxjDafze1Te1VzouqnK2TgmLQljQqmrnAsT+iaPVb5b2co7EC+QhBgUeM1R1AcrsGp9Jy6+4W8U3fZ8r+e3EnOI2uaAX3l+zgNB4O9rW5/B8tY5WGo9BtOrJ4uMfUl+uj0B8HTmPXj8Pex86xVEnTDBBSE2r78fX9i09RPyZfT2A5ceIMSPwDOH8JH7Kk5+fAHtR0Zh6MZ9e7534Wc3wgO0sXLhD9OpFOa0egjGMhguD8BgTJooMfPbV1h/umz25ondcFP90IzY2iTgrfY9uH31aqSc9CeSEHkBEyITv28M8XMGc2/z0HGCpWCs8BS/9sWrDYOrJuCBZ+vu5sUfXbicia5kYGzUw4DWTwJKbApSjHuTBBjT2H68zg0MD4KlEwabZi0Y7wd85u/3O9/B6sVrPlEXeiF9nMmRxPt6Qf4y/HyIbh3HwkdF1zefGt5fUwK8wP2WAGwh02MFE/5ogYr3Qg/STL0W3d8aB1ppa+Pw0uI2Tz6/134Mg+UoIGZlZ2HMLaJYHkPICr6//RBamvPj/UA4dYKsegGrXqAXMaqNsDT6SreOY5Gu/FptCeBFN+caAphGiKFiGaOjA3AJHoGt6r7GgNbjqjo5yQkBUVHQ8PaJExjiaZ2yue12nO27gCNdHSptvf/xGdw11I2UZSmvCIJgQiJMhoEfeqpNDvUSRvUB5hMX9fUecg0aBi+Hm2uaAz633bmbm1VN8+h07LfKJdkOkQB2fL4BTlsj8No4YLG2putMSjwjp3QNvZdH8YsiExV501isFjU30lpF7D8dVfCA8sFHp7BuWYtaIwiCsCrCSDVhh9IX8k0CoHsoMQ84FrfFAE3zQAK0VaLzO9tK79XKAxSj+aYALt3XLfNipZD1v492YexrE/sP0zBgUIQIoYaflAXbz16CzyY6YKqYl8uheTarRioD7xAxCQHUpv18L1Yud+Iloujtk4zQo9WZcKURqjbHclzKvj0Gvcw8UA6oY2WqonSuGQGb5I+TJgEFEsB4daXzc0eopabcX13W0BXwgAnRZL4Q62s8ppnR/pFz/QjF+tRvxeIsY/cizGwRt83P4czACL8HdA1JUivCNGVogvdkNkgaGDNe4CvXFyJ8n+B5XGLJ1FmJXJ53AzjZKgGbatkKL5c/liNWIPO8uM/4VO2uKCQZjLmBqQAGJ4EmI8NMabDTOuyUobYXmPlCEpiqA1IkYdWSBpjpEDl6wsrF9aAjqHNOPXDyXAGprAknY5B0btOGGk/GlfE1taqofCNuuYNIJ+omOiZ1rpUHtEYWjkpWoP5EWV2sb5isA7aIQTHHxaIniNADui8PIs0Eb6SY/Z0UQc+j+mXYuoM7Vy/Age7zkBUyCZGLhRLSOYcWpfXFA1wPhqup8JNKq5UkKeoqSHxPLSoqnUQtw5ioc60IyE/VkOji8mYE2nZELNgCXLaOkGDFJBg4OzCMDEcxCfAzS1pQX5fHSNDLClLGwmwzls6vQ09hGFJYegdZ1hha2bqIBNelB5Qjog02TzpFNVEquYpMuTSYr/lcQPKPJHoRQ8W1GYO3lDgpO9pPWTEZEQGnuodg5Hyk66Lyd8fKOQQ6gqyWict7GeuWz8HQyWEFw+bB7ksF3Nk2V1nfpZTLQqSLslzXlDmHpsQ1osVoy/Solwf/GpdErpaAQUqjWxL2GWcWaSfAMIis7RBwiuCdtD1OgmNHBJCg7r4uZBnbdjaaq+3YewB+USYicY8juYPnMtloqdCjG3f39eO+3JKIAFadSiiZigBdgdcqItMxsmZbIbvUIKlzzQjoEgLGRjU2KTp8AjRCkzEnAG0mtQh8Ku0oAqok8JzP+Lw0MkB3jpKjKpapaL5WKZxafDdBqoC6O8LtyMAQhoZdzG7MwLU8FUYKPINcl+qimismRj26v2I71I3jDxfdpM41I6CTsmG4X0djKyc8RYu9t0Vl2QJbBJ5xFPiICJIg1hdhR3fs5HnWeldleZXABLA98b7Y5HtjkgwNEtbTN4iFC5oI3I1CTsAbsfVjAizJB3Qbx9HphRp6eqr3TDprSYA0FI/3ntOxbpUNM2OjpEcE6HYEWkhIKw+ICeBxi+T09F1WZU+iJq2n8fRDf4Ymu3XSrcOIgg8H9uOFn31fNUVC0oddZ7B5YxtDwlTgo66SEici2fokwCJjju0hw7J54WypQsB7tSRAza+H+nld30Y+m2b7SS+Qn9PKFl1egRciHIfWpxC8x+7tdA97+3zUcNyWX4Ci/THOoD2x/hmlQTox+3gDjWYeg/4gmF853xjBpUsjaGnJR24fu36FNzX5pmfY7EPStlSLIgb6gwk616QRYk8tS88/l/2PT/loyqbQkEmhPpNGNp1CmvtieQHvONGtL4sdy9Hjp5kkpTWmSzM7L529hErHs0cCpt2qW00BymDV3JXSU8HkAXKIjtNnedxS48m4Mr5cR9YlMrx+XTqNRmbP2ZkMOjvHKir/PNa5pouiitFjH44iZ6YwO5tFAy+eo6SdpOUJyhBQTJR+HT9HYLJaFve0PqQmTQLaVOCdmIRIWE+wrmWTzG8iAugF7qgWjSWkGbYa32EjJQTkGFv5dBZNJKCeHdb77UPXZP1rWhKLZ4Rqjv2Fz86lLMNlpusCY9BnqTNUIyTgrVhhs7rVq2KoW2TSxWlXLOCqWX4svmpzZdEjWvgQcdVWPnu+i4ClUS+HyLIFnsVf/9eBduw8eKYy2D1XMxO8Jg+IB9wl+3s/uAC3qKMpXY88m/ecnUHaSis3Na8Ab1UtaCh3j1y+sm8m9o0J+9Fv9MR4Zhw6DufTWasOebsOs+xZKHJOtvtQtertulrwV+0BtH5yWvyW7CxubsCTX9+KUQZ4ga7qmdGUFmrya8QWHwcxlReMF8Mw4QETrR8oy7tq2ivH5Tvya8n8aXZMGc4An/nRDpy52FfR8b5KCJCImt8YkYF/KDtnegfwz3sPodGajQajCTk9z/4mQ6iphMWv9AA9IeMWdyYdn+gBkVc5amwHWV6lHvVaI2YZzfinN95Ngv/htcT/p31CRNbdV8l8e++xD5HPNeHxhx5Bgf18kTN5T1kvjBfEjGjBJCai4gnjHqAnlvqS8e9NeujEjEul/NokDbai4V/2voafHD1S0evdWLeb8ojMNyly5fS//ffbcD0L33j4K4RX4rtMh/UUGLXmr6BWXN9MEFAhYfzmZ6hcXI+TpISRH8061Ui68gTWGUJP4aU9P8ZrB39S+Xkx1ummPSMkbebnJcxU1jm4D5eGhvB7j32HJcpUJHhxLIfxTZpxwGa8eKrHC51a9Tmp+N5P1RsQ01cJAwEflHw8/+pfYn/HgaQ+n7/a1vd6k+BUS2XvVD401TXhu488gQ0r71QUuLJsrWT8mSYtfkBMm0BAmFhNrgDX4oRqqeaJMw4c6TyIv/qPP0Xf8KUJ6sXuP1XluuEEyGsD5TXKgsqBNQvW4RtbnkDb4ttJQlGt/IQqLMJE7tWqOSBZCSrL6dFSqq3AnzhzDC/tewHt5w4nr3suvgN0+P8o3TeegFe3vYDHtj+xhLt/Q3kkeW5d693YuuHXsWHZPcixW4tCwo+trVU9QEs8G6HFqW5kdBiHTu3H64dfxpGuK8r665Tv7tz2D6e/tP23cT0E1OA5QR2iiIbs1i9u/9qTPPC12CtwlIofjZVvW/BZ3LVsC5bPW4u5DQuxaPay2NpRIuy61IkLA+dw8hdHceDUPpw49z9TXUysvWPXtl3bQ4yQtMJ1a18DAsbvRO/atvM5DXXPPbp9yzP8+GXBXTkngKYBdTWvE5RXdm87+HQEfLh2T57UIAdM95Js9+04LKSDbLzG31+Omxpx9xfxKR6AukkhMP0aKuUHsag5VEzE3fGSddsUVu6KFzIE+H/iJry0mX+bu8VfMwTMEDBDwAwBMwTMEHALv/5XgAEASpR5N6rB30UAAAAASUVORK5CYII=",this._callbackGamepadConnected=a,this.gamepadSupportAvailable?(this.gamepadEventSupported?(window.addEventListener("gamepadconnected",function(a){b._onGamepadConnected(a)
},!1),window.addEventListener("gamepaddisconnected",function(a){b._onGamepadDisconnected(a)},!1)):this._startMonitoringGamepads(),this.oneGamepadConnected||this._insertGamepadDOMInstructions()):this._insertGamepadDOMNotSupported()}return b.prototype._insertGamepadDOMInstructions=function(){b.gamepadDOMInfo=document.createElement("div");var a=document.createElement("img");a.src=this.buttonADataURL;var c=document.createElement("span");c.innerHTML="<strong>to activate gamepad</strong>",b.gamepadDOMInfo.appendChild(a),b.gamepadDOMInfo.appendChild(c),b.gamepadDOMInfo.style.position="absolute",b.gamepadDOMInfo.style.width="100%",b.gamepadDOMInfo.style.height="48px",b.gamepadDOMInfo.style.bottom="0px",b.gamepadDOMInfo.style.backgroundColor="rgba(1, 1, 1, 0.15)",b.gamepadDOMInfo.style.textAlign="center",b.gamepadDOMInfo.style.zIndex="10",a.style.position="relative",a.style.bottom="8px",c.style.position="relative",c.style.fontSize="32px",c.style.bottom="32px",c.style.color="green",document.body.appendChild(b.gamepadDOMInfo)},b.prototype._insertGamepadDOMNotSupported=function(){b.gamepadDOMInfo=document.createElement("div");var a=document.createElement("span");a.innerHTML="<strong>gamepad not supported</strong>",b.gamepadDOMInfo.appendChild(a),b.gamepadDOMInfo.style.position="absolute",b.gamepadDOMInfo.style.width="100%",b.gamepadDOMInfo.style.height="40px",b.gamepadDOMInfo.style.bottom="0px",b.gamepadDOMInfo.style.backgroundColor="rgba(1, 1, 1, 0.15)",b.gamepadDOMInfo.style.textAlign="center",b.gamepadDOMInfo.style.zIndex="10",a.style.position="relative",a.style.fontSize="32px",a.style.color="red",document.body.appendChild(b.gamepadDOMInfo)},b.prototype.dispose=function(){document.body.removeChild(b.gamepadDOMInfo)},b.prototype._onGamepadConnected=function(a){var b=this._addNewGamepad(a.gamepad);this._callbackGamepadConnected&&this._callbackGamepadConnected(b),this._startMonitoringGamepads()},b.prototype._addNewGamepad=function(c){this.oneGamepadConnected||(this.oneGamepadConnected=!0,b.gamepadDOMInfo&&(document.body.removeChild(b.gamepadDOMInfo),b.gamepadDOMInfo=null));var d;return d=-1!==c.id.search("Xbox 360")||-1!==c.id.search("xinput")?new a.Xbox360Pad(c.id,c.index,c):new a.GenericPad(c.id,c.index,c),this.babylonGamepads.push(d),d},b.prototype._onGamepadDisconnected=function(a){for(var b in this.babylonGamepads)if(this.babylonGamepads[b].index==a.gamepad.index){this.babylonGamepads.splice(b,1);break}0==this.babylonGamepads.length&&this._stopMonitoringGamepads()},b.prototype._startMonitoringGamepads=function(){this.isMonitoring||(this.isMonitoring=!0,this._checkGamepadsStatus())},b.prototype._stopMonitoringGamepads=function(){this.isMonitoring=!1},b.prototype._checkGamepadsStatus=function(){var a=this;this._updateGamepadObjects();for(var b in this.babylonGamepads)this.babylonGamepads[b].update();this.isMonitoring&&(window.requestAnimationFrame?window.requestAnimationFrame(function(){a._checkGamepadsStatus()}):window.mozRequestAnimationFrame?window.mozRequestAnimationFrame(function(){a._checkGamepadsStatus()}):window.webkitRequestAnimationFrame&&window.webkitRequestAnimationFrame(function(){a._checkGamepadsStatus()}))},b.prototype._updateGamepadObjects=function(){for(var a=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads?navigator.webkitGetGamepads():[],b=0;b<a.length;b++)if(a[b])if(a[b].index in this.babylonGamepads)this.babylonGamepads[b].browserGamepad=a[b];else{var c=this._addNewGamepad(a[b]);this._callbackGamepadConnected&&this._callbackGamepadConnected(c)}},b}();a.Gamepads=b;var c=function(){function a(a,b){this.x=a,this.y=b}return a}();a.StickValues=c;var d=function(){function a(a,b,c){this.id=a,this.index=b,this.browserGamepad=c,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[0],y:this.browserGamepad.axes[1]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[2],y:this.browserGamepad.axes[3]})}return a.prototype.onleftstickchanged=function(a){this._onleftstickchanged=a},a.prototype.onrightstickchanged=function(a){this._onrightstickchanged=a},Object.defineProperty(a.prototype,"leftStick",{get:function(){return this._leftStick},set:function(a){!this._onleftstickchanged||this._leftStick.x===a.x&&this._leftStick.y===a.y||this._onleftstickchanged(a),this._leftStick=a},enumerable:!0,configurable:!0}),Object.defineProperty(a.prototype,"rightStick",{get:function(){return this._rightStick},set:function(a){!this._onrightstickchanged||this._rightStick.x===a.x&&this._rightStick.y===a.y||this._onrightstickchanged(a),this._rightStick=a},enumerable:!0,configurable:!0}),a.prototype.update=function(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[0],y:this.browserGamepad.axes[1]}),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[2],y:this.browserGamepad.axes[3]})},a}();a.Gamepad=d;var e=function(a){function b(b,c,d){a.call(this,b,c,d),this.id=b,this.index=c,this.gamepad=d,this._buttons=new Array(d.buttons.length)}return __extends(b,a),b.prototype.onbuttondown=function(a){this._onbuttondown=a},b.prototype.onbuttonup=function(a){this._onbuttonup=a},b.prototype._setButtonValue=function(a,b,c){return a!==b&&(this._onbuttondown&&1===a&&this._onbuttondown(c),this._onbuttonup&&0===a&&this._onbuttonup(c)),a},b.prototype.update=function(){a.prototype.update.call(this);for(var b=0;b<this._buttons.length;b++)this._buttons[b]=this._setButtonValue(this.gamepad.buttons[b].value,this._buttons[b],b)},b}(d);a.GenericPad=e,function(a){a[a.A=0]="A",a[a.B=1]="B",a[a.X=2]="X",a[a.Y=3]="Y",a[a.Start=4]="Start",a[a.Back=5]="Back",a[a.LB=6]="LB",a[a.RB=7]="RB",a[a.LeftStick=8]="LeftStick",a[a.RightStick=9]="RightStick"}(a.Xbox360Button||(a.Xbox360Button={}));a.Xbox360Button;!function(a){a[a.Up=0]="Up",a[a.Down=1]="Down",a[a.Left=2]="Left",a[a.Right=3]="Right"}(a.Xbox360Dpad||(a.Xbox360Dpad={}));var f=(a.Xbox360Dpad,function(a){function b(){a.apply(this,arguments),this._leftTrigger=0,this._rightTrigger=0,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0}return __extends(b,a),b.prototype.onlefttriggerchanged=function(a){this._onlefttriggerchanged=a},b.prototype.onrighttriggerchanged=function(a){this._onrighttriggerchanged=a},Object.defineProperty(b.prototype,"leftTrigger",{get:function(){return this._leftTrigger},set:function(a){this._onlefttriggerchanged&&this._leftTrigger!==a&&this._onlefttriggerchanged(a),this._leftTrigger=a},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"rightTrigger",{get:function(){return this._rightTrigger},set:function(a){this._onrighttriggerchanged&&this._rightTrigger!==a&&this._onrighttriggerchanged(a),this._rightTrigger=a},enumerable:!0,configurable:!0}),b.prototype.onbuttondown=function(a){this._onbuttondown=a},b.prototype.onbuttonup=function(a){this._onbuttonup=a},b.prototype.ondpaddown=function(a){this._ondpaddown=a},b.prototype.ondpadup=function(a){this._ondpadup=a},b.prototype._setButtonValue=function(a,b,c){return a!==b&&(this._onbuttondown&&1===a&&this._onbuttondown(c),this._onbuttonup&&0===a&&this._onbuttonup(c)),a},b.prototype._setDPadValue=function(a,b,c){return a!==b&&(this._ondpaddown&&1===a&&this._ondpaddown(c),this._ondpadup&&0===a&&this._ondpadup(c)),a},Object.defineProperty(b.prototype,"buttonA",{get:function(){return this._buttonA},set:function(a){this._buttonA=this._setButtonValue(a,this._buttonA,0)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonB",{get:function(){return this._buttonB},set:function(a){this._buttonB=this._setButtonValue(a,this._buttonB,1)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonX",{get:function(){return this._buttonX},set:function(a){this._buttonX=this._setButtonValue(a,this._buttonX,2)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonY",{get:function(){return this._buttonY},set:function(a){this._buttonY=this._setButtonValue(a,this._buttonY,3)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonStart",{get:function(){return this._buttonStart},set:function(a){this._buttonStart=this._setButtonValue(a,this._buttonStart,4)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonBack",{get:function(){return this._buttonBack},set:function(a){this._buttonBack=this._setButtonValue(a,this._buttonBack,5)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonLB",{get:function(){return this._buttonLB},set:function(a){this._buttonLB=this._setButtonValue(a,this._buttonLB,6)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonRB",{get:function(){return this._buttonRB},set:function(a){this._buttonRB=this._setButtonValue(a,this._buttonRB,7)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonLeftStick",{get:function(){return this._buttonLeftStick},set:function(a){this._buttonLeftStick=this._setButtonValue(a,this._buttonLeftStick,8)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonRightStick",{get:function(){return this._buttonRightStick},set:function(a){this._buttonRightStick=this._setButtonValue(a,this._buttonRightStick,9)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadUp",{get:function(){return this._dPadUp},set:function(a){this._dPadUp=this._setDPadValue(a,this._dPadUp,0)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadDown",{get:function(){return this._dPadDown},set:function(a){this._dPadDown=this._setDPadValue(a,this._dPadDown,1)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadLeft",{get:function(){return this._dPadLeft},set:function(a){this._dPadLeft=this._setDPadValue(a,this._dPadLeft,2)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadRight",{get:function(){return this._dPadRight},set:function(a){this._dPadRight=this._setDPadValue(a,this._dPadRight,3)},enumerable:!0,configurable:!0}),b.prototype.update=function(){a.prototype.update.call(this),this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value},b}(d));a.Xbox360Pad=f}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){var f=this;b.call(this,c,d,e),this.angularSensibility=200,this.moveSensibility=75,this._gamepads=new a.Gamepads(function(a){f._onNewGameConnected(a)})}return __extends(c,b),c.prototype._onNewGameConnected=function(a){0===a.index&&(this._gamepad=a)},c.prototype._checkInputs=function(){if(this._gamepad){var b=this._gamepad.leftStick,c=b.x/this.moveSensibility,d=b.y/this.moveSensibility;b.x=Math.abs(c)>.005?0+c:0,b.y=Math.abs(d)>.005?0+d:0;var e=this._gamepad.rightStick,f=e.x/this.angularSensibility,g=e.y/this.angularSensibility;e.x=Math.abs(f)>.001?0+f:0,e.y=Math.abs(g)>.001?0+g:0;var h=a.Matrix.RotationYawPitchRoll(this.rotation.y,this.rotation.x,0),i=a.Vector3.TransformCoordinates(new a.Vector3(b.x,0,-b.y),h);this.cameraDirection=this.cameraDirection.add(i),this.cameraRotation=this.cameraRotation.add(new a.Vector3(e.y,e.x,0))}},c.prototype.dispose=function(){this._gamepads.dispose()},c}(a.FreeCamera);a.GamepadCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){"undefined"==typeof e&&(e=!1),b.call(this,c,d),this.color=new a.Color3(1,1,1),this._indices=new Array,this._colorShader=new a.ShaderMaterial("colorShader",d,"color",{attributes:["position"],uniforms:["worldViewProjection","color"]})}return __extends(c,b),Object.defineProperty(c.prototype,"material",{get:function(){return this._colorShader},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"isPickable",{get:function(){return!1},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"checkCollisions",{get:function(){return!1},enumerable:!0,configurable:!0}),c.prototype._bind=function(){var b=this.getScene().getEngine(),c=this._geometry.getIndexBuffer();b.bindBuffers(this._geometry.getVertexBuffer(a.VertexBuffer.PositionKind).getBuffer(),c,[3],12,this._colorShader.getEffect()),this._colorShader.setColor3("color",this.color)},c.prototype._draw=function(a){if(this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){var b=this.getScene().getEngine();b.draw(!1,a.indexStart,a.indexCount)}},c.prototype.intersects=function(){return null},c.prototype.dispose=function(a){this._colorShader.dispose(),b.prototype.dispose.call(this,a)},c}(a.Mesh);a.LinesMesh=b}(BABYLON||(BABYLON={}));module.exports=BABYLON;
},{}],"jQuery":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v1.11.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-17T15:27Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "1.11.2",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1, IE<9
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1, IE<9
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery(function() {
	// Minified: var a,b,c,d
	var val, div, body, container;

	body = document.getElementsByTagName( "body" )[ 0 ];
	if ( !body || !body.style ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	div = document.createElement( "div" );
	container = document.createElement( "div" );
	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
		if ( val ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	// Minified: var a,b,c
	var input = document.createElement( "input" ),
		div = document.createElement( "div" ),
		fragment = document.createDocumentFragment();

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: IE < 9, Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var shrinkWrapBlocksVal;

	support.shrinkWrapBlocks = function() {
		if ( shrinkWrapBlocksVal != null ) {
			return shrinkWrapBlocksVal;
		}

		// Will be changed later if needed.
		shrinkWrapBlocksVal = false;

		// Minified: var b,c,d
		var div, body, container;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		// Support: IE6
		// Check if elements with layout shrink-wrap their children
		if ( typeof div.style.zoom !== strundefined ) {
			// Reset CSS: box-sizing; display; margin; border
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;" +
				"padding:1px;width:1px;zoom:1";
			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
			shrinkWrapBlocksVal = div.offsetWidth !== 3;
		}

		body.removeChild( container );

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	// Minified: var b,c,d,e,f,g, h,i
	var div, style, a, pixelPositionVal, boxSizingReliableVal,
		reliableHiddenOffsetsVal, reliableMarginRightVal;

	// Setup
	div = document.createElement( "div" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];
	style = a && a.style;

	// Finish early in limited (non-browser) environments
	if ( !style ) {
		return;
	}

	style.cssText = "float:left;opacity:.5";

	// Support: IE<9
	// Make sure that element opacity exists (as opposed to filter)
	support.opacity = style.opacity === "0.5";

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
		style.WebkitBoxSizing === "";

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal == null ) {
				computeStyleTests();
			}
			return reliableHiddenOffsetsVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		// Support: Android 2.3
		reliableMarginRight: function() {
			if ( reliableMarginRightVal == null ) {
				computeStyleTests();
			}
			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		// Minified: var b,c,d,j
		var div, body, container, contents;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";

		// Support: IE<9
		// Assume reasonable values in the absence of getComputedStyle
		pixelPositionVal = boxSizingReliableVal = false;
		reliableMarginRightVal = true;

		// Check for getComputedStyle so that this code is not run in IE<9.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Support: Android 2.3
			// Div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			contents = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			contents.style.cssText = div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
			contents.style.marginRight = contents.style.width = "0";
			div.style.width = "1px";

			reliableMarginRightVal =
				!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

			div.removeChild( contents );
		}

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		contents = div.getElementsByTagName( "td" );
		contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
		reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		if ( reliableHiddenOffsetsVal ) {
			contents[ 0 ].style.display = "";
			contents[ 1 ].style.display = "none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		}

		body.removeChild( container );
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display && display !== "none" || !hidden ) {
				jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	// Minified: var a,b,c,d,e
	var input, div, select, a, opt;

	// Setup
	div = document.createElement( "div" );
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off, url.length ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"lodash":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.6.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.6.0';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_DROP_WHILE_FLAG = 0,
      LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   */
  var reComboMarks = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /**
   * Used to match [ES template delimiters](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
   * In addition to special characters the forward slash is escaped to allow for
   * easier `eval` use and `Function` compilation.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
    ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
    '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
          othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of each element
   * in a collection and stable sort them in the following order:
   *
   * If orders is unspecified, sort in ascending order for all properties.
   * Otherwise, for each property, sort in ascending order if its corresponding value in
   * orders is true, and descending order if false.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        return result * (orders[index] ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
        ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        push = arrayProto.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = isNative(Set = context.Set) && Set,
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
            result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsFinite = context.isFinite,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,
     * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,
     * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,
     * `without`, `wrap`, `xor`, `zip`, and `zipObject`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,
     * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
     * `isFinite`,`isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `sum`, `template`, `trim`, `trimLeft`,
     * `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) {
     *   return sum + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = /\bthis\b/.test(function() { return this; });

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = null;
      this.__dir__ = 1;
      this.__dropCount__ = 0;
      this.__filtered__ = false;
      this.__iteratees__ = null;
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = null;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.__actions__,
          iteratees = this.__iteratees__,
          views = this.__views__,
          result = new LazyWrapper(this.__wrapped__);

      result.__actions__ = actions ? arrayCopy(actions) : null;
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var dir = this.__dir__,
          isRight = dir < 0,
          view = getView(0, array.length, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          takeCount = nativeMin(length, this.__takeCount__),
          iteratees = this.__iteratees__,
          iterLength = iteratees ? iteratees.length : 0,
          resIndex = 0,
          result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type;

          if (type == LAZY_DROP_WHILE_FLAG) {
            if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
              data.count = 0;
              data.done = false;
            }
            data.index = index;
            if (!data.done) {
              var limit = data.limit;
              if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                continue outer;
              }
            }
          } else {
            var computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
          length = array.length,
          result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
          length = array.length,
          result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     */
    function arraySum(array) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +array[length] || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          length = collection.length,
          isArr = isLength(length),
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return typeof thisArg == 'undefined'
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return typeof thisArg == 'undefined'
        ? baseProperty(func + '')
        : baseMatchesProperty(func + '', thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= 200) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} isDeep Specify a deep flatten.
     * @param {boolean} isStrict Restrict flattening to arrays and `arguments` objects.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
              valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
          othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
          value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = (objTag == objectTag || (isLoose && objTag == funcTag)),
          othIsObj = (othTag == objectTag || (isLoose && othTag == funcTag)),
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (isLoose) {
        if (!isSameTag && !(objIsObj && othIsObj)) {
          return false;
        }
      } else {
        var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (valWrapped || othWrapped) {
          return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
        if (!isSameTag) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var index = -1,
          length = props.length,
          noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
              ? values[index] !== object[props[index]]
              : !(props[index] in object)
            ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index],
            objValue = object[key],
            srcValue = values[index];

        if (noCustomizer && strictCompareFlags[index]) {
          var result = typeof objValue != 'undefined' || (key in object);
        } else {
          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
          length = props.length;

      if (!length) {
        return constant(true);
      }
      if (length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value &&
              (typeof value != 'undefined' || (key in toObject(object)));
          };
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value &&
            (typeof value != 'undefined' || (key in toObject(object)));
        };
      }
      return function(object) {
        return object != null && baseIsEqual(value, object[key], null, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
            (isCommon || (result === result ? (result !== value) : (value === value)))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : ((value && value.length) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string[]} props The property names to sort by.
     * @param {boolean[]} orders The sort orders of `props`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, props, orders) {
      var index = -1,
          length = collection.length,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var length = props.length,
            criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= 200,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var args = [result],
            action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
            computed = iteratee(array[mid]),
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
            result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee.
     *
     * **Note:** This function is used to create `_.countBy`, `_.groupBy`, `_.indexBy`,
     * and `_.partition`.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var args = arguments,
            length = args.length,
            object = args[0];

        if (length < 2 || object == null) {
          return object;
        }
        var customizer = args[length - 2],
            thisArg = args[length - 1],
            guard = args[3];

        if (length > 3 && typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(args[1], args[2], guard)) {
          customizer = length == 3 ? null : customizer;
          length = 2;
        }
        var index = 0;
        while (++index < length) {
          var source = args[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = null;
        }
        var result = createWrapper(func, flag, null, null, null, null, null, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
            noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      }
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var length = arguments.length;
        if (!length) {
          return function() { return arguments[0]; };
        }
        var wrapper,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var funcName = wrapper ? '' : getFuncName(func);
          wrapper = funcName == 'wrapper' ? new LodashWrapper([]) : wrapper;
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];
          funcName = getFuncName(func);

          var data = funcName == 'wrapper' ? getData(func) : null;
          if (data && isLaziable(data[0])) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments;
          if (wrapper && args.length == 1 && isArray(args[0])) {
            return wrapper.plant(args[0]).value();
          }
          var index = 0,
              result = funcs[index].apply(this, args);

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return string && ((fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string));
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, null, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
          key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : null,
                newHoldersRight = isCurry ? null : argsHolders,
                newPartials = isCurry ? args : null,
                newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var func = getCallback(iteratee);
        return (func === baseCallback && iteratee == null)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = null;
      }
      var data = isBindKey ? null : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length,
          result = true;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isLoose
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isLoose) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var skipCtor = isLoose,
          index = -1;

      while (++index < objLength) {
        var key = objProps[index],
            result = isLoose ? key in other : hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
              othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isLoose
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
          computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? (current < computed) : (current > computed)) ||
            (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    var getFuncName = (function() {
      if (!support.funcNames) {
        return constant('');
      }
      if (constant.name == 'constant') {
        return baseProperty('name');
      }
      return function(func) {
        var result = func.name,
            array = realNames[result],
            length = array ? array.length : 0;

        while (length--) {
          var data = array[length],
              otherFunc = data.func;

          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result;
      };
    }());

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
            prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      if (prereq) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
          support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
          (!hasOwnProperty.call(value, 'constructor') &&
            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length,
          support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isArray(array) || isArguments(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
            other = array[index];

        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = [],
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
        }
      }
      argsLength = args.length;
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [],
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          argsIndex = argsLength;
          while (--argsIndex) {
            var cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`
     *  - [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    comparisons are like strict equality comparisons, e.g. `===`, except
     *    that `NaN` matches `NaN`
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      array || (array = []);
      indexes = baseFlatten(indexes);

      var length = indexes.length,
          result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
          result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return (isArray(array) || isArguments(array))
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapper = wrapper.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapper.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapper = wrapper.plant(other);
     *
     * otherWrapper.value();
     * // => [9, 16]
     *
     * wrapper.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse(), this.__chain__);
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = null;
      }
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, methodName, args) {
      var index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
     * `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`,
     * `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`,
     * `trimRight`, `trunc`, `random`, `range`, `sample`, `some`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     *  create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `includes`, `merge`, `sortByAll`, and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight =  createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
          length = collection.length,
          result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = null;
      }
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      var index = -1,
          length = collection.length,
          result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll() {
      var args = arguments,
          collection = args[0],
          guard = args[3],
          index = 0,
          length = args.length - 1;

      if (collection == null) {
        return [];
      }
      var props = Array(length);
      while (index < length) {
        props[index] = args[++index];
      }
      if (guard && isIterateeCall(args[1], args[2], guard)) {
        props = args[1];
      }
      return baseSortByOrder(collection, baseFlatten(props), []);
    }

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the property names to sort by. A truthy value in `orders`
     * will sort the corresponding property name in ascending order while a
     * falsey value will sort it in descending order.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string[]} props The property names to sort by.
     * @param {boolean[]} orders The sort orders of `props`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);
     * // => [['barney', 36], ['barney', 26], ['fred', 40], ['fred', 30]]
     */
    function sortByOrder(collection, props, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(props, orders, guard)) {
        orders = null;
      }
      if (!isArray(props)) {
        props = props == null ? [] : [props];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, props, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            cache = memoized.cache,
            key = resolver ? resolver.apply(this, args) : args[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(typeof start == 'undefined' ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return isLength(length) && objToString.call(value) == argsTag;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) &&
        (objToString.call(value).indexOf('Element') > -1);
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
      };
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return objToString.call(value) == funcTag;
    };

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (!!value && type == 'object');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
          length = props.length;

      if (!length) {
        return true;
      }
      if (object == null) {
        return false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return value === object[key] && (typeof value != 'undefined' || (key in toObject(object)));
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(toObject(object), props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = restParam(function(args) {
      var object = args[0];
      if (object == null) {
        return object;
      }
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 3 };
     *
     * _.has(object, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
            length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (typeof end === 'undefined') {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= start && value < end;
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMarks, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = typeof position == 'undefined'
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it is shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function which compares the property value of `key` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(key, value) {
      return baseMatchesProperty(key + '', baseClone(value, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function
     * for mixins to avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * // use `_.runInContext` to avoid conflicts (esp. in Node.js)
     * var _ = require('lodash').runInContext();
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj && keys(source),
            methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', 'barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The opposite of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     *
     * _.map(['a', 'c'], _.propertyOf(object));
     * // => [3, 2]
     *
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `start` is less than `end`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(ceil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return augend + addend;
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      var func = getCallback(),
          noIteratee = iteratee == null;

      if (!(func === baseCallback && noIteratee)) {
        noIteratee = false;
        iteratee = func(iteratee, thisArg, 3);
      }
      return noIteratee
        ? arraySum(isArray(collection) ? collection : toIterable(collection))
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {
      var isFilter = type != LAZY_MAP_FLAG,
          isDropWhile = type == LAZY_DROP_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var filtered = this.__filtered__,
            result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

        iteratees.push({
          'done': false,
          'count': 0,
          'index': 0,
          'iteratee': getCallback(iteratee, thisArg, 1),
          'limit': -1,
          'type': type
        });

        result.__filtered__ = filtered || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__,
            result = (filtered && !index) ? this.dropWhile() : this.clone();

        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
        if (filtered) {
          if (index) {
            result.__takeCount__ = nativeMin(result.__takeCount__, n);
          } else {
            last(result.__iteratees__).limit = n;
          }
        } else {
          var views = result.__views__ || (result.__views__ = []);
          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.toArray = function() {
      return this.drop(0);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (!lodashFunc) {
        return;
      }
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments,
            length = args.length,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // avoid lazy use if the iteratee has a `length` other than `1`
          isLazy = useLazy = false;
        }
        var onlyLazy = isLazy && !isHybrid;
        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (useLazy) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
              result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.__actions__)) {
            var actions = result.__actions__ || (result.__actions__ = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': null }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvYXBwLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9iaXJkLWNhbWVyYS5qcyIsInNyYy9tb2R1bGVzL2NhbWVyYXMvY2FtZXJhLWNvbXB1dGVyLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9jYW1lcmEtY29udGFpbmVyLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9leGFtaW5lLWNhbWVyYS5qcyIsInNyYy9tb2R1bGVzL2NhbWVyYXMvaGlrZXItY2FtZXJhLmpzIiwic3JjL21vZHVsZXMvZGVtLmpzIiwic3JjL21vZHVsZXMvZXZlbnRzLmpzIiwic3JjL21vZHVsZXMvcG9pLmpzIiwic3JjL21vZHVsZXMvc2NlbmUuanMiLCJzcmMvbW9kdWxlcy9zZXR0aW5ncy5qcyIsInNyYy9tb2R1bGVzL3RpbGUtY29udGFpbmVyLmpzIiwic3JjL21vZHVsZXMvdHJlay5qcyIsInNyYy9tb2R1bGVzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9wbHVnaW5zL0JlemllclBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9nc2FwL3NyYy91bmNvbXByZXNzZWQvcGx1Z2lucy9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9lYXNpbmcvRWFzZVBhY2suanMiLCJub2RlX21vZHVsZXMvZ3NhcC9zcmMvdW5jb21wcmVzc2VkL1RpbWVsaW5lTGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nc2FwL3NyYy91bmNvbXByZXNzZWQvVHdlZW5MaXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYnlsb25qcy9iYWJ5bG9uLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNscEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDajZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzd1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2h3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMW1VQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEJBQllMT04gPSByZXF1aXJlKCdiYWJ5bG9uanMnKTtcbiAgICByZXF1aXJlKCdFYXNlUGFjaycpO1xuICAgIHJlcXVpcmUoJ1R3ZWVuTGl0ZScpO1xuICAgIHJlcXVpcmUoJ1RpbWVsaW5lTGl0ZScpO1xuICAgIHJlcXVpcmUoJ0JlemllclBsdWdpbicpO1xuICAgIHJlcXVpcmUoJ0RpcmVjdGlvbmFsUm90YXRpb25QbHVnaW4nKTtcblxuICAgIGZ1bmN0aW9uIFJhbmRvM0QoKSB7XG5cbiAgICAgICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG5cbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL3NldHRpbmdzJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvZGVtJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvZXZlbnRzJykoUkFORE8pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvcG9pJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvc2NlbmUnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy90aWxlLWNvbnRhaW5lcicpKFJBTkRPKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL3RyZWsnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy91dGlscycpKFJBTkRPLCBCQUJZTE9OKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL2NhbWVyYXMvY2FtZXJhLWNvbXB1dGVyJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvY2FtZXJhcy9jYW1lcmEtY29udGFpbmVyJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvY2FtZXJhcy9iaXJkLWNhbWVyYScpKFJBTkRPLCBCQUJZTE9OKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL2NhbWVyYXMvZXhhbWluZS1jYW1lcmEnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy9jYW1lcmFzL2hpa2VyLWNhbWVyYScpKFJBTkRPLCBCQUJZTE9OKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0KGN1c3RvbVNldHRpbmdzLCBjYW52YXMsIGNhbWVyYUlEKSB7XG5cbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKGN1c3RvbVNldHRpbmdzLCBmdW5jdGlvbiAoc2V0dGluZ05hbWUsIHNldHRpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTW3NldHRpbmdOYW1lXSA9IHNldHRpbmdWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBSQU5ETy5TVEFSVF9USU1FID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgdmFyIHNjZW5lID0gbmV3IFJBTkRPLlNjZW5lKGNhbnZhcywgY2FtZXJhSUQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2NlbmU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdDogaW5pdFxuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuUmFuZG8zRCA9IFJhbmRvM0Q7XG4gICAgfVxufSkoKTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uQmlyZENhbWVyYS5qc1xuICpcbiAqIEJpcmRDYW1lcmEgY2xhc3MgOlxuICogIEl0IGlzIGEgY2FtZXJhIHdoaWNoIGxvb2sgbGlrZSB0aGUgRnJlZUNhbWVyYSBvZiBCYWJ5bG9uSlMuXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9CYWJ5bG9uSlMvQmFieWxvbi5qcy93aWtpLzA1LUNhbWVyYXMuXG4gKlxuICogIFRoZSBkaWZmZXJlbmNlcyBhcmUgOlxuICogICAgICAtIHBlcm1pdGVzIHRvIHRyYW5zbGF0ZSBpdCBvZiB3b3JsZCdzIFggYW5kIFogYXhpcyBpbnN0ZWFkIG9mXG4gKiAgbG9jYWxlJ3Mgb25lLlxuICogICAgICAtIHRoZXJlIGlzIGEgd2hlZWwgem9vbS5cbiAqXG4gKiAgSXQgZ2l2ZXMgdGhlIGltcHJlc3Npb24gb2YgZmx5aW5nLiBUaGF0J3Mgd2h5IGl0IGlzIGNhbGxlZCBCaXJkQ2FtZXJhXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEgPSBmdW5jdGlvbiAobmFtZSwgcG9zaXRpb24sIHNjZW5lKSB7XG4gICAgICAgIEJBQllMT04uQ2FtZXJhLmNhbGwodGhpcywgbmFtZSwgcG9zaXRpb24sIHNjZW5lKTtcblxuICAgICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMigwLCAwKTtcbiAgICAgICAgdGhpcy56b29tRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuZWxsaXBzb2lkID0gbmV3IEJBQllMT04uVmVjdG9yMygwLjUsIDEsIDAuNSk7XG5cbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmtleXNVcCA9IFszOF07XG4gICAgICAgIHRoaXMua2V5c0Rvd24gPSBbNDBdO1xuICAgICAgICB0aGlzLmtleXNMZWZ0ID0gWzM3XTtcbiAgICAgICAgdGhpcy5rZXlzUmlnaHQgPSBbMzldO1xuXG4gICAgICAgIC8vIENvbGxpc2lvbnNcbiAgICAgICAgdGhpcy5fY29sbGlkZXIgPSBuZXcgQkFCWUxPTi5Db2xsaWRlcigpO1xuICAgICAgICB0aGlzLl9uZWVkTW92ZUZvckdyYXZpdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIEludGVybmFsc1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fdmlld01hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fY2FtTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VQb2ludCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQgPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9vbGRQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2RpZmZQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX25ld1Bvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fbG9va0F0VGVtcCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fdGVtcE1hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25BZnRlclpvb20gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlKTtcblxuICAgIC8vIE1lbWJlcnNcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5zcGVlZCA9IDIuMDtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5jaGVja0NvbGxpc2lvbnMgPSBmYWxzZTtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5hcHBseUdyYXZpdHkgPSBmYWxzZTtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5ub1JvdGF0aW9uQ29uc3RyYWludCA9IGZhbHNlO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmFuZ3VsYXJTZW5zaWJpbGl0eSA9IDIwMDAuMDtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5sb2NrZWRUYXJnZXQgPSBudWxsO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLm9uQ29sbGlkZSA9IG51bGw7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUud2hlZWxQcmVjaXNpb24gPSAwLjM7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuaW5lcnRpYWxSYWRpdXNPZmZzZXQgPSAwO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmxvd2VyUmFkaXVzTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLnVwcGVyUmFkaXVzTGltaXQgPSBudWxsO1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9ja2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tlZFRhcmdldC5wb3NpdGlvbiB8fCB0aGlzLmxvY2tlZFRhcmdldDtcbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5faW5pdENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUuX2luaXRDYWNoZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnJvdGF0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlID0gZnVuY3Rpb24gKGlnbm9yZVBhcmVudENsYXNzKSB7XG4gICAgICAgIGlmICghaWdub3JlUGFyZW50Q2xhc3MpXG4gICAgICAgICAgICBCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGxvY2tlZFRhcmdldFBvc2l0aW9uID0gdGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCFsb2NrZWRUYXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID0gbG9ja2VkVGFyZ2V0UG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5jb3B5RnJvbShsb2NrZWRUYXJnZXRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZS5yb3RhdGlvbi5jb3B5RnJvbSh0aGlzLnJvdGF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gU3luY2hyb25pemVkXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeC5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9ja2VkVGFyZ2V0UG9zaXRpb24gPSB0aGlzLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID8gdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0LmVxdWFscyhsb2NrZWRUYXJnZXRQb3NpdGlvbikgOiAhbG9ja2VkVGFyZ2V0UG9zaXRpb24pXG4gICAgICAgICAgICAmJiB0aGlzLl9jYWNoZS5yb3RhdGlvbi5lcXVhbHModGhpcy5yb3RhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIE1ldGhvZHNcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5fY29tcHV0ZUxvY2FsQ2FtZXJhU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWVkICogKChCQUJZTE9OLlRvb2xzLkdldERlbHRhVGltZSgpIC8gKEJBQllMT04uVG9vbHMuR2V0RnBzKCkgKiAxMC4wKSkpO1xuICAgIH07XG5cbiAgICAvLyBUYXJnZXRcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudXBWZWN0b3Iubm9ybWFsaXplKCk7XG5cbiAgICAgICAgQkFCWUxPTi5NYXRyaXguTG9va0F0TEhUb1JlZih0aGlzLnBvc2l0aW9uLCB0YXJnZXQsIHRoaXMudXBWZWN0b3IsIHRoaXMuX2NhbU1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2NhbU1hdHJpeC5pbnZlcnQoKTtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uLnggPSBNYXRoLmF0YW4odGhpcy5fY2FtTWF0cml4Lm1bNl0gLyB0aGlzLl9jYW1NYXRyaXgubVsxMF0pO1xuXG4gICAgICAgIHZhciB2RGlyID0gdGFyZ2V0LnN1YnRyYWN0KHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh2RGlyLnggPj0gMC4wKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnkgPSAoLU1hdGguYXRhbih2RGlyLnogLyB2RGlyLngpICsgTWF0aC5QSSAvIDIuMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnkgPSAoLU1hdGguYXRhbih2RGlyLnogLyB2RGlyLngpIC0gTWF0aC5QSSAvIDIuMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvdGF0aW9uLnogPSAtTWF0aC5hY29zKEJBQllMT04uVmVjdG9yMy5Eb3QobmV3IEJBQllMT04uVmVjdG9yMygwLCAxLjAsIDApLCB0aGlzLnVwVmVjdG9yKSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMucm90YXRpb24ueCkpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5yb3RhdGlvbi55KSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hTih0aGlzLnJvdGF0aW9uLnopKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnogPSAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIENvbnRyb2xzXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuYXR0YWNoQ29udHJvbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICBpZiAodGhpcy5fb25Nb3VzZURvd24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VPdXQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhhdC5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzUG9zaXRpb24gJiYgIWVuZ2luZS5pc1BvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIGlmICghZW5naW5lLmlzUG9pbnRlckxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGV2dC5jbGllbnRYIC0gcHJldmlvdXNQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gZXZ0LmNsaWVudFkgLSBwcmV2aW91c1Bvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGV2dC5tb3ZlbWVudFggfHwgZXZ0Lm1vek1vdmVtZW50WCB8fCBldnQud2Via2l0TW92ZW1lbnRYIHx8IGV2dC5tc01vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gZXZ0Lm1vdmVtZW50WSB8fCBldnQubW96TW92ZW1lbnRZIHx8IGV2dC53ZWJraXRNb3ZlbWVudFkgfHwgZXZ0Lm1zTW92ZW1lbnRZIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5yb3RhdGlvbkRpcmVjdGlvbi55ICs9IG9mZnNldFggLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcbiAgICAgICAgICAgICAgICB0aGF0LnJvdGF0aW9uRGlyZWN0aW9uLnggKz0gb2Zmc2V0WSAvIHRoYXQuYW5ndWxhclNlbnNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25XaGVlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gKHRoYXQud2hlZWxQcmVjaXNpb24gKiA0MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gdGhhdC53aGVlbFByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEpXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxSYWRpdXNPZmZzZXQgKz0gZGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmtleXNVcC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzRG93bi5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzTGVmdC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzUmlnaHQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoYXQuX2tleXMuaW5kZXhPZihldnQua2V5Q29kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fa2V5cy5wdXNoKGV2dC5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlVcCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzVXAuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0Rvd24uaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0xlZnQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c1JpZ2h0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0Ll9rZXlzLmluZGV4T2YoZXZ0LmtleUNvZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uTG9zdEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2tleXMgPSBbXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGF0Lm1vdmVEaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgICAgIHRoYXQucm90YXRpb25EaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IyKDAsIDApO1xuICAgICAgICAgICAgICAgIHRoYXQuem9vbURpcmVjdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMuX29uTW91c2VPdXQsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG5cbiAgICAgICAgQkFCWUxPTi5Ub29scy5SZWdpc3RlclRvcFJvb3RFdmVudHMoW1xuICAgICAgICAgICAgeyBuYW1lOiBcImtleWRvd25cIiwgaGFuZGxlcjogdGhpcy5fb25LZXlEb3duIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5dXBcIiwgaGFuZGxlcjogdGhpcy5fb25LZXlVcCB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImJsdXJcIiwgaGFuZGxlcjogdGhpcy5fb25Mb3N0Rm9jdXMgfVxuICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuZGV0YWNoQ29udHJvbCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZEVsZW1lbnQgIT0gZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLl9vbk1vdXNlT3V0KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl9vbldoZWVsKTtcblxuICAgICAgICBCQUJZTE9OLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLl9jb2xsaWRlV2l0aFdvcmxkID0gZnVuY3Rpb24gKHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBnbG9iYWxQb3NpdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGdsb2JhbFBvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24sIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYmFsUG9zaXRpb24uc3VidHJhY3RGcm9tRmxvYXRzVG9SZWYoMCwgdGhpcy5lbGxpcHNvaWQueSwgMCwgdGhpcy5fb2xkUG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9jb2xsaWRlci5yYWRpdXMgPSB0aGlzLmVsbGlwc29pZDtcblxuICAgICAgICB0aGlzLmdldFNjZW5lKCkuX2dldE5ld1Bvc2l0aW9uKHRoaXMuX29sZFBvc2l0aW9uLCB2ZWxvY2l0eSwgdGhpcy5fY29sbGlkZXIsIDMsIHRoaXMuX25ld1Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fbmV3UG9zaXRpb24uc3VidHJhY3RUb1JlZih0aGlzLl9vbGRQb3NpdGlvbiwgdGhpcy5fZGlmZlBvc2l0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5fZGlmZlBvc2l0aW9uLmxlbmd0aCgpID4gQkFCWUxPTi5FbmdpbmUuQ29sbGlzaW9uc0Vwc2lsb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLl9kaWZmUG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db2xsaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxpZGUodGhpcy5fY29sbGlkZXIuY29sbGlkZWRNZXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5fY2hlY2tJbnB1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmVzIHdpdGggdGhlIGtleWJvYXJkXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9rZXlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGtleUNvZGUgPSB0aGlzLl9rZXlzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IHRoaXMuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmtleXNMZWZ0LmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoLXNwZWVkLCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5rZXlzVXAuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cygwLCAwLCBzcGVlZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMua2V5c1JpZ2h0LmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoc3BlZWQsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmtleXNEb3duLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoMCwgMCwgLXNwZWVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZKHRoaXMucm90YXRpb24ueSk7XG4gICAgICAgICAgICBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYoXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4LFxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLmFkZEluUGxhY2UodGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW91c2Ugd2hlZWwgem9vbVxuICAgICAgICBpZiAodGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCkge1xuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLkZyb21GbG9hdHNUb1JlZigwLCAwLCAxLCB0aGlzLl9yZWZlcmVuY2VQb2ludCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0Vmlld01hdHJpeCgpLmludmVydFRvUmVmKHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgICAgICBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYoXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4LFxuICAgICAgICAgICAgICAgIHRoaXMuem9vbURpcmVjdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy56b29tRGlyZWN0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGVja0lucHV0cygpO1xuXG4gICAgICAgIHZhciBuZWVkVG9Nb3ZlID0gKFxuICAgICAgICAgICAgdGhpcy5fbmVlZE1vdmVGb3JHcmF2aXR5IHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLm1vdmVEaXJlY3Rpb24ueCkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLm1vdmVEaXJlY3Rpb24ueSkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLm1vdmVEaXJlY3Rpb24ueikgPiAwXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZWVkVG9Sb3RhdGUgPSAoXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnJvdGF0aW9uRGlyZWN0aW9uLngpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5yb3RhdGlvbkRpcmVjdGlvbi55KSA+IDBcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIG5lZWRUb1pvb20gPSAoXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnpvb21EaXJlY3Rpb24ueCkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnpvb21EaXJlY3Rpb24ueSkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLnpvb21EaXJlY3Rpb24ueikgPiAwXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZWVkQ29sbGlzaW9ucyA9IHRoaXMuY2hlY2tDb2xsaXNpb25zICYmIHRoaXMuX3NjZW5lLmNvbGxpc2lvbnNFbmFibGVkO1xuXG4gICAgICAgIC8vIFJvdGF0ZVxuICAgICAgICBpZiAobmVlZFRvUm90YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggKz0gdGhpcy5yb3RhdGlvbkRpcmVjdGlvbi54O1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ICs9IHRoaXMucm90YXRpb25EaXJlY3Rpb24ueTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vUm90YXRpb25Db25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gKE1hdGguUEkgLyAyKSAqIDAuOTU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3RhdGlvbi54ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW9uLnggPCAtbGltaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCA9IC1saW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmVzIGFuZCBjb2xsaXNpb25zXG4gICAgICAgIGlmIChuZWVkVG9ab29tICYmIG5lZWRUb01vdmUpIHtcbiAgICAgICAgICAgIGlmIChuZWVkQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVXaXRoV29ybGQodGhpcy56b29tRGlyZWN0aW9uLmFkZCh0aGlzLm1vdmVEaXJlY3Rpb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuem9vbURpcmVjdGlvbi5hZGQodGhpcy5tb3ZlRGlyZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmVlZFRvWm9vbSkge1xuICAgICAgICAgICAgaWYgKG5lZWRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZVdpdGhXb3JsZCh0aGlzLnpvb21EaXJlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy56b29tRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZWVkVG9Nb3ZlKSB7XG4gICAgICAgICAgICBpZiAobmVlZENvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKHRoaXMubW92ZURpcmVjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLm1vdmVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5lcnRpYVxuICAgICAgICBpZiAobmVlZFRvTW92ZSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMubW92ZURpcmVjdGlvbi54KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnggPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5tb3ZlRGlyZWN0aW9uLnkpIDwgQkFCWUxPTi5FbmdpbmUuZXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVEaXJlY3Rpb24ueSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLm1vdmVEaXJlY3Rpb24ueikgPCBCQUJZTE9OLkVuZ2luZS5lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbi56ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkVG9Sb3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnJvdGF0aW9uRGlyZWN0aW9uLngpIDwgQkFCWUxPTi5FbmdpbmUuZXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uLnggPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5yb3RhdGlvbkRpcmVjdGlvbi55KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbi55ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbi5zY2FsZUluUGxhY2UodGhpcy5pbmVydGlhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZFRvWm9vbSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQpIDwgQkFCWUxPTi5FbmdpbmUuZXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCAqPSB0aGlzLmluZXJ0aWE7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGFyZ2V0O1xuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5fZ2V0Vmlld01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQkFCWUxPTi5WZWN0b3IzLkZyb21GbG9hdHNUb1JlZigwLCAwLCAxLCB0aGlzLl9yZWZlcmVuY2VQb2ludCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxvY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZVxuICAgICAgICAgICAgaWYgKHRoaXMudXBWZWN0b3IueCAhPSAwIHx8IHRoaXMudXBWZWN0b3IueSAhPSAxLjAgfHwgdGhpcy51cFZlY3Rvci56ICE9IDApIHtcbiAgICAgICAgICAgICAgICBCQUJZTE9OLk1hdHJpeC5Mb29rQXRMSFRvUmVmKEJBQllMT04uVmVjdG9yMy5aZXJvKCksIHRoaXMuX3JlZmVyZW5jZVBvaW50LCB0aGlzLnVwVmVjdG9yLCB0aGlzLl9sb29rQXRUZW1wKTtcbiAgICAgICAgICAgICAgICBCQUJZTE9OLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSwgdGhpcy5yb3RhdGlvbi54LCB0aGlzLnJvdGF0aW9uLnosIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xvb2tBdFRlbXAubXVsdGlwbHlUb1JlZih0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCwgdGhpcy5fdGVtcE1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9va0F0VGVtcC5pbnZlcnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wTWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5fbG9va0F0VGVtcCwgdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBCQUJZTE9OLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSwgdGhpcy5yb3RhdGlvbi54LCB0aGlzLnJvdGF0aW9uLnosIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodGhpcy5fcmVmZXJlbmNlUG9pbnQsIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LCB0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50KTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0aW5nIHRhcmdldCBhbmQgZmluYWwgbWF0cml4XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZFRvUmVmKHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQsIHRoaXMuX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldC5jb3B5RnJvbSh0aGlzLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEJBQllMT04uTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbiwgdGhpcy5fY3VycmVudFRhcmdldCwgdGhpcy51cFZlY3RvciwgdGhpcy5fdmlld01hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3TWF0cml4O1xuICAgIH07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5DYW1lcmFDb21wdXRlci5qc1xuICpcbiAqIENhbWVyYUNvbXB1dGVyIGNsYXNzIDpcbiAqICBVc2VkIHRvIHNlcGFyYXRlIGNhbGN1bGF0aW9ucyBmcm9tIHRoZSBDYW1lcmFDb250YWluZXJcbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgLyogQ29uc3RydWN0b3IgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlciA9IGZ1bmN0aW9uIChjZW50ZXIsIGV4dGVudCwgYWx0aXR1ZGVzLCBvZmZzZXRzLCBzY2VuZSwgbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2NlbnRlciAgICAgICAgPSB7XG4gICAgICAgICAgICAneCcgOiBjZW50ZXIueCArIG9mZnNldHMueCxcbiAgICAgICAgICAgICd5JyA6IGNlbnRlci55LFxuICAgICAgICAgICAgJ3onIDogY2VudGVyLnogKyBvZmZzZXRzLnpcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdG90YWxFeHRlbnQgICA9IHtcbiAgICAgICAgICAgICd4JyA6IHtcbiAgICAgICAgICAgICAgICAnbWluJyA6IGV4dGVudC54Lm1pbiArIG9mZnNldHMueCxcbiAgICAgICAgICAgICAgICAnbWF4JyA6IGV4dGVudC54Lm1heCArIG9mZnNldHMueFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd5JyA6IHtcbiAgICAgICAgICAgICAgICAnbWluJyA6IGV4dGVudC55Lm1pbixcbiAgICAgICAgICAgICAgICAnbWF4JyA6IGV4dGVudC55Lm1heFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd6JyA6IHtcbiAgICAgICAgICAgICAgICAnbWluJyA6IGV4dGVudC56Lm1pbiArIG9mZnNldHMueixcbiAgICAgICAgICAgICAgICAnbWF4JyA6IGV4dGVudC56Lm1heCArIG9mZnNldHMuelxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLl9hbHRpdHVkZXMgPSBhbHRpdHVkZXM7XG4gICAgICAgIHRoaXMuX3NxdWFyZXMgICA9IFtdO1xuICAgICAgICB0aGlzLl9hbHBoYVNxdWFyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bWJlciA9IG51bWJlciB8fCA1O1xuICAgIH07XG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsUG9zaXRpb25Ub1JlZiA9IGZ1bmN0aW9uIChpbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVTcXVhcmVzICgpO1xuICAgICAgICB0aGlzLl9maW5kQWxwaGFTcXVhcmUgKCk7XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uVG9SZWYgKGluaXRpYWxQb3NpdGlvbik7XG4gICAgICAgIC8vfiB0aGlzLl9idWlsZFNxdWFyZVZpZXdlcigpO1xuICAgIH07XG5cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxUYXJnZXRUb1JlZiA9IGZ1bmN0aW9uIChpbml0aWFsVGFyZ2V0KSB7XG4gICAgICAgIGluaXRpYWxUYXJnZXQueCA9IHRoaXMuX2NlbnRlci54O1xuICAgICAgICBpbml0aWFsVGFyZ2V0LnkgPSAwO1xuICAgICAgICBpbml0aWFsVGFyZ2V0LnogPSB0aGlzLl9jZW50ZXIuejtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLmNvbXB1dGVMaW1pdHNUb1JlZiA9IGZ1bmN0aW9uIChsaW1pdHMpIHtcbiAgICAgICAgbGltaXRzLmxvd2VyWCA9IHRoaXMuX3RvdGFsRXh0ZW50LngubWluO1xuICAgICAgICBsaW1pdHMudXBwZXJYID0gdGhpcy5fdG90YWxFeHRlbnQueC5tYXg7XG4gICAgICAgIGxpbWl0cy5sb3dlclogPSB0aGlzLl90b3RhbEV4dGVudC56Lm1pbjtcbiAgICAgICAgbGltaXRzLnVwcGVyWiA9IHRoaXMuX3RvdGFsRXh0ZW50LnoubWF4O1xuXG4gICAgICAgIGxpbWl0cy5sb3dlclJhZGl1cyA9IFJBTkRPLlNFVFRJTkdTLk1JTl9USElDS05FU1MgKyB0aGlzLl9jZW50ZXIueTtcbiAgICAgICAgbGltaXRzLnVwcGVyUmFkaXVzID0gODAwMDtcbiAgICB9O1xuXG5cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX2dlbmVyYXRlU3F1YXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmlsbCBzcXVhcmUncyBleHRlbnRzIChuZWVkZWQgdG8gZGV0ZXJtaW5lIGluZGljZXMpXG4gICAgICAgIHZhciBzcXVhcmVHcmlkID0gUkFORE8uVXRpbHMuY3JlYXRlRmxhdEdyaWQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3gnIDogdGhpcy5fdG90YWxFeHRlbnQueC5taW4sXG4gICAgICAgICAgICAgICAgJ3knIDogdGhpcy5fdG90YWxFeHRlbnQuei5taW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3gnIDogdGhpcy5fdG90YWxFeHRlbnQueC5tYXgsXG4gICAgICAgICAgICAgICAgJ3knIDogdGhpcy5fdG90YWxFeHRlbnQuei5taW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3gnIDogdGhpcy5fdG90YWxFeHRlbnQueC5tYXgsXG4gICAgICAgICAgICAgICAgJ3knIDogdGhpcy5fdG90YWxFeHRlbnQuei5tYXhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3gnIDogdGhpcy5fdG90YWxFeHRlbnQueC5taW4sXG4gICAgICAgICAgICAgICAgJ3knIDogdGhpcy5fdG90YWxFeHRlbnQuei5tYXhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLl9udW1iZXIrMSxcbiAgICAgICAgICAgIHRoaXMuX251bWJlcisxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2ZpbGxFeHRlbnRzIChzcXVhcmVHcmlkKTtcblxuICAgICAgICAvLyBGaWxsIHNxdWFyZSdzIHR5cGVzXG4gICAgICAgIHRoaXMuX2ZpbGxUeXBlcyAoKTtcblxuICAgICAgICAvLyBGaWxsIHNxdWFyZSdzIGluZGljZXNcbiAgICAgICAgdmFyIGVsZXZhdGVkUG9pbnRzID0gUkFORE8uVXRpbHMuY3JlYXRlRWxldmF0aW9uR3JpZCAoXG4gICAgICAgICAgICB0aGlzLl90b3RhbEV4dGVudC54Lm1pbixcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsRXh0ZW50LngubWF4LFxuICAgICAgICAgICAgdGhpcy5fdG90YWxFeHRlbnQuei5taW4sXG4gICAgICAgICAgICB0aGlzLl90b3RhbEV4dGVudC56Lm1heCxcbiAgICAgICAgICAgIHRoaXMuX2FsdGl0dWRlc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9maWxsSW5kaWNlcyAoZWxldmF0ZWRQb2ludHMpO1xuXG4gICAgICAgIC8vIEZpbGwgc3F1YXJlJ3MgbmVpZ2hib3Job29kXG4gICAgICAgIHRoaXMuX2ZpbGxOZWlnaGJvcmhvb2QgKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbXB1dGVyLl9maWxsRXh0ZW50cygpIDogRmlsbCB0aGUgZXh0ZW50IHByb3BlcnR5IG9mIGFsbCBzcXVhcmVzXG4gICAgICogIC0gZ3JpZCA6IGEgZmxhdCBncmlkIGNvbnRhaW5pbmcgcG9pbnRzIG9mIHNxdWFyZXNcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX2ZpbGxFeHRlbnRzID0gZnVuY3Rpb24gKGdyaWQpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMCA7IHJvdyA8IGdyaWQubGVuZ3RoLTEgOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMCA7IGNvbCA8IGdyaWRbcm93XS5sZW5ndGgtMSA7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3F1YXJlcy5wdXNoICh7XG4gICAgICAgICAgICAgICAgICAgICdleHRlbnQnIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3gnIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nIDogZ3JpZFtyb3ddW2NvbF0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWF4JyA6IGdyaWRbcm93KzFdW2NvbCsxXS54XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3onIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nIDogZ3JpZFtyb3ddW2NvbF0ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWF4JyA6IGdyaWRbcm93KzFdW2NvbCsxXS55XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fZmlsbFR5cGVzKCkgOiBGaWxsIHRoZSB0eXBlIHByb3BlcnR5IG9mIGFsbCBzcXVhcmVzXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLl9maWxsVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENPUk5FUiB0eXBlc1xuICAgICAgICB0aGlzLl9zcXVhcmVzWzBdLnR5cGUgPSBcIkNPUk5FUlwiOyAvLyBsZWZ0LWRvd24gY29ybmVyXG4gICAgICAgIHRoaXMuX3NxdWFyZXNbdGhpcy5fbnVtYmVyIC0gMV0udHlwZSA9IFwiQ09STkVSXCI7IC8vIHJpZ2h0LWRvd24gY29ybmVyXG4gICAgICAgIHRoaXMuX3NxdWFyZXNbKHRoaXMuX251bWJlciAtIDEpICogdGhpcy5fbnVtYmVyXS50eXBlID0gXCJDT1JORVJcIjsgLy8gbGVmdC11cCBjb3JuZXJcbiAgICAgICAgdGhpcy5fc3F1YXJlc1sodGhpcy5fbnVtYmVyICogdGhpcy5fbnVtYmVyKSAtIDFdLnR5cGUgPSBcIkNPUk5FUlwiOyAvLyByaWdodC11cCBjb3JuZXJcblxuICAgICAgICAvLyBFeHRlcm4gQk9SREVSIHR5cGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fbnVtYmVyIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9zcXVhcmVzW2ldLnR5cGUgPSBcIkVYVEJPUkRFUlwiOyAvLyBkb3duIGJvcmRlclxuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1sodGhpcy5fbnVtYmVyIC0gMSkgKiB0aGlzLl9udW1iZXIgKyBpXS50eXBlID0gXCJFWFRCT1JERVJcIjsgLy8gdG9wIGJvcmRlclxuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1t0aGlzLl9udW1iZXIgKiBpXS50eXBlID0gXCJFWFRCT1JERVJcIjsgLy8gbGVmdCBib3JkZXJcbiAgICAgICAgICAgIHRoaXMuX3NxdWFyZXNbdGhpcy5fbnVtYmVyICogaSArIHRoaXMuX251bWJlciAtMV0udHlwZSA9IFwiRVhUQk9SREVSXCI7Ly8gcmlnaHQgYm9yZGVyXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm4gQk9SREVSIHR5cGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fbnVtYmVyIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9zcXVhcmVzW2kgKyB0aGlzLl9udW1iZXJdLnR5cGUgPSBcIklOVEJPUkRFUlwiOy8vIGRvd24gaW50ZXJuYWwgYm9yZGVyXG4gICAgICAgICAgICB0aGlzLl9zcXVhcmVzW2kgKyB0aGlzLl9udW1iZXIgKyAodGhpcy5fbnVtYmVyLTMpICogdGhpcy5fbnVtYmVyXS50eXBlID0gXCJJTlRCT1JERVJcIjtcbiAgICAgICAgICAgIHRoaXMuX3NxdWFyZXNbaSAqIHRoaXMuX251bWJlciArIDFdLnR5cGUgPSBcIklOVEJPUkRFUlwiO1xuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1tpICogdGhpcy5fbnVtYmVyICsgMSArICh0aGlzLl9udW1iZXItMyldLnR5cGUgPSBcIklOVEJPUkRFUlwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEJMQUNLIHR5cGVzXG4gICAgICAgIGZvciAodmFyIGl0IGluIHRoaXMuX3NxdWFyZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3F1YXJlc1tpdF0udHlwZSkgdGhpcy5fc3F1YXJlc1tpdF0udHlwZSA9IFwiQkxBQ0tcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fZmlsbEluZGljZXMoKSA6IEZpbGwgdGhlIGluZGV4IHByb3BlcnR5IG9mIGFsbCBzcXVhcmVzXG4gICAgICogIC0gZWxldmF0ZWRQb2ludHMgOiBhIHR3by1hcnJheSBvZiBhbGwgM0QgcG9pbnRzIG9mIHRoZSBERU1cbiAgICAgKlxuICAgICAqIE5CIDogSXQgbmVlZHMgdG8gaGF2ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSBleHRlbnQgYW5kIHRoZSB0eXBlIG9mIGVhY2ggc3F1YXJlXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLl9maWxsSW5kaWNlcyA9IGZ1bmN0aW9uIChlbGV2YXRlZFBvaW50cykge1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW5kaWNlcyBvZiBzcXVhcmVzIHdpdGggZWxldmF0ZWQgcG9pbnRzIHdoaWNoIGFyZSBpbnNpZGVcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgZWxldmF0ZWRQb2ludHMubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgZWxldmF0ZWRQb2ludHNbcm93XS5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZWxldmF0ZWRQb2ludHNbcm93XVtjb2xdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGl0IGluIHRoaXMuX3NxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNxdWFyZSA9IHRoaXMuX3NxdWFyZXNbaXRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3F1YXJlLnR5cGUgIT0gXCJCTEFDS1wiICYmIFJBTkRPLlV0aWxzLmlzSW5FeHRlbnQocG9zaXRpb24sIHNxdWFyZS5leHRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3F1YXJlLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlLmluZGV4ICs9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlLm5iX2FsdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUuaW5kZXggPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZS5uYl9hbHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGluZGV4IGJldHdlZW4gMCBhbmQgMTAgd2hpY2ggcmVwcmVzZW50cyB0aGUgZWxldmF0aW9uJ3MgYXZlcmFnZSBvZiBhIHNxdWFyZVxuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLl9zcXVhcmVzKSB7XG4gICAgICAgICAgICB2YXIgc3F1YXJlID0gdGhpcy5fc3F1YXJlc1tpdF07XG4gICAgICAgICAgICBzcXVhcmUuaW5kZXggPSBzcXVhcmUuaW5kZXggLyBzcXVhcmUubmJfYWx0O1xuICAgICAgICAgICAgc3F1YXJlLmluZGV4ID0gc3F1YXJlLmluZGV4ICogMTAgLyAodGhpcy5fdG90YWxFeHRlbnQueS5tYXggIC0gdGhpcy5fdG90YWxFeHRlbnQueS5taW4pO1xuICAgICAgICAgICAgaWYgKHNxdWFyZS50eXBlID09IFwiQkxBQ0tcIikge1xuICAgICAgICAgICAgICAgIHNxdWFyZS5pbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbXB1dGVyLl9maWxsTmVpZ2hib3Job29kKCkgOiBGaWxsIHRoZSBuZWlnaGJvcmhvb2QgcHJvcGVydHkgb2Ygc3F1YXJlc1xuICAgICAqIHdoaWNoIGFyZSBvZiBDT1JORVIgb3IgRVhUQk9SREVSIHR5cGVzXG4gICAgICpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogVGhlIG5laWdoYm9yaG9vZCBjb250YWlucyBhbGwgbmVpZ2hib3VycyBvZiBhIHNxdWFyZSBmb2xsb3dpbmcgdGhpcyBzY2hlZHVsZSA6XG4gICAgICpcbiAgICAgKiAgICAgICAgICBDT1JORVIgOlxuICAgICAqICAgICAgfFxuICAgICAqICAgICAgblxuICAgICAqICAgICAgbiBuXG4gICAgICogICAgICBzIG4gbiBfXG4gICAgICpcbiAgICAgKiAgICAgICAgICBFWFRCT1JERVIgOlxuICAgICAqICAgICAgbiBuIG5cbiAgICAgKiAgICBfIG4gcyBuIF9cbiAgICAgKlxuICAgICAqIFdpdGhcbiAgICAgKiAgcyA9IHNxdWFyZSB3ZSB3YW50IHRvIGdldCBpdHMgbmVpZ2hib3Vyc1xuICAgICAqICBuID0gbmVpZ2hib3VycyBvZiB0aGUgc3F1YXJlXG4gICAgICpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogTkIgOiAtIFRoZSBzcXVhcmUgd2lsbCBiZSBjb3VudGVkIGluIGl0cyBuZWlnaGJvcmhvb2RcbiAgICAgKiAgICAgIC0gSXQgbmVlZHMgdG8gaGF2ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSBpbmRleCBvZiBlYWNoIHNxdWFyZVxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5fZmlsbE5laWdoYm9yaG9vZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGR4LCBkeSwgdF9keCwgdF9keSA9IFstdGhpcy5fbnVtYmVyLCB0aGlzLl9udW1iZXJdO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnIgPSAwOyBjdXJyIDwgdGhpcy5fc3F1YXJlcy5sZW5ndGg7IGN1cnIrKykge1xuICAgICAgICAgICAgdmFyIHNxdWFyZSA9IHRoaXMuX3NxdWFyZXNbY3Vycl07XG5cbiAgICAgICAgICAgIGlmIChzcXVhcmUudHlwZSA9PSBcIkNPUk5FUlwiKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlLm5laWdoYm9yaG9vZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyJXRoaXMuX251bWJlciA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zcXVhcmVzW2N1cnIgKyB0aGlzLl9udW1iZXJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gdGhpcy5fbnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAtdGhpcy5fbnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2goY3Vycik7XG4gICAgICAgICAgICAgICAgc3F1YXJlLm5laWdoYm9yaG9vZC5wdXNoKGN1cnIgKyBkeCk7XG4gICAgICAgICAgICAgICAgc3F1YXJlLm5laWdoYm9yaG9vZC5wdXNoKGN1cnIgKyAyICogZHgpO1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaChjdXJyICsgZHkpO1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaChjdXJyICsgMiAqIGR5KTtcbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2goY3VyciArIGR4ICsgZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3F1YXJlLnR5cGUgPT0gXCJFWFRCT1JERVJcIikge1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyciV0aGlzLl9udW1iZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0X2R4ID0gWzAsIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyJXRoaXMuX251bWJlciA9PSB0aGlzLl9udW1iZXIgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdF9keCA9IFstMSwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0X2R4ID0gWy0xLCAwLCAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0X2R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaCAoY3VyciArIHRfZHhbaV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHRfZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zcXVhcmVzW2N1cnIgKyB0X2R5W2pdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaCAoY3VyciArIHRfZHhbaV0gKyB0X2R5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fZmluZEFscGhhU3F1YXJlKCkgOiBGaW5kIHRoZSBBbHBoYSBTcXVhcmVcbiAgICAgKiAgVGhlIGFscGhhIHNxdWFyZSBpcyB0aGUgc3F1YXJlIHdoaWNoIGhhdmUgdGhlIG5laWdoYm9yaG9vZCB3aXRoIHRoZSBsb3dlc3QgaW5kaWNlcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX2ZpbmRBbHBoYVNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl9hbHBoYVNxdWFyZSA9IF8ubWluKHRoaXMuX3NxdWFyZXMsIGZ1bmN0aW9uIChzcXVhcmUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICAgICAgaWYgKCFzcXVhcmUubmVpZ2hib3Job29kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGl0IGluIHNxdWFyZS5uZWlnaGJvcmhvb2QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhhdC5fc3F1YXJlc1tzcXVhcmUubmVpZ2hib3Job29kW2l0XV0uaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29tcHV0ZXIuX3NldFBvc2l0aW9uVG9SZWYoKSA6IHNldCB0aGUgcG9zaXRpb24gZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gICAgICogIGFjY29yZGluZyB0byB0aGUgYWxwaGEgc3F1YXJlIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiAgLSByZXN1bHQgOiByZWZlcmVuY2UgdG8gdGhlIHBvc2l0aW9uIHRvIGNoYW5nZVxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5fc2V0UG9zaXRpb25Ub1JlZiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgLy8gQWxwaGEgcG9zaXRpb24gOiBlbGV2YXRpb24gZG8gbm90IG1hdHRlclxuICAgICAgICB2YXIgQSA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoXG4gICAgICAgICAgICAodGhpcy5fYWxwaGFTcXVhcmUuZXh0ZW50LngubWF4ICsgdGhpcy5fYWxwaGFTcXVhcmUuZXh0ZW50LngubWluKSAvMixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAodGhpcy5fYWxwaGFTcXVhcmUuZXh0ZW50LnoubWF4ICsgdGhpcy5fYWxwaGFTcXVhcmUuZXh0ZW50LnoubWluKSAvMlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENlbnRlciBwb3NpdGlvblxuICAgICAgICB2YXIgTyA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoXG4gICAgICAgICAgICB0aGlzLl9jZW50ZXIueCxcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlci55LFxuICAgICAgICAgICAgdGhpcy5fY2VudGVyLnpcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgc2NhbGUgPSAyLjU7XG4gICAgICAgIHZhciBPQyA9IEEuc3VidHJhY3QoTykuc2NhbGUoc2NhbGUpO1xuXG4gICAgICAgIC8vIENhbWVyYSBwb3NpdGlvblxuICAgICAgICB2YXIgQyA9IE9DLmFkZChPKTtcbiAgICAgICAgcmVzdWx0LnggPSBDLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy5fY2VudGVyLnkgKyAodGhpcy5fdG90YWxFeHRlbnQueS5tYXggLSB0aGlzLl90b3RhbEV4dGVudC55Lm1pbik7XG4gICAgICAgIHJlc3VsdC56ID0gQy56O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fYnVpbGRTcXVhcmVWaWV3ZXIoKSA6IGJ1aWxkIGEgdmlld2VyIHdoaWNoIG1hdGVyaWFsaXplXG4gICAgICogIGRpZmZlcmVudHMgc3F1YXJlcyBpbiBzcGhlcmVzIG9mIGNvbG9yXG4gICAgICpcbiAgICAgKiAgQ09STkVSIHNxdWFyZXMgYXJlIGdyZWVuXG4gICAgICogIEV4dGVybiBCT1JERVIgc3F1YXJlcyBhcmUgYmx1ZVxuICAgICAqICBJbnRlcm4gQk9SREVSIHNxdWFyZXMgYXJlIG9yYW5nZVxuICAgICAqICBJbnRlcm4gc3F1YXJlcyBhcmUgYmxhY2tcbiAgICAgKiAgQWxwaGEgU3F1YXJlIGlzIHJlZFxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5fYnVpbGRTcXVhcmVWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGl0IGluIHRoaXMuX3NxdWFyZXMpIHtcbiAgICAgICAgICAgIHZhciBzcGhlcmUgPSBCQUJZTE9OLk1lc2guQ3JlYXRlU3BoZXJlKFxuICAgICAgICAgICAgICAgIFwiU3F1YXJlIFwiICsgaXQsXG4gICAgICAgICAgICAgICAgMTAsIDEwMCxcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2VuZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc3BoZXJlLnBvc2l0aW9uLnggPSAodGhpcy5fc3F1YXJlc1tpdF0uZXh0ZW50LngubWluICsgdGhpcy5fc3F1YXJlc1tpdF0uZXh0ZW50LngubWF4KSAvMjtcbiAgICAgICAgICAgIHNwaGVyZS5wb3NpdGlvbi55ID0gdGhpcy5fdG90YWxFeHRlbnQueS5tYXg7XG4gICAgICAgICAgICBzcGhlcmUucG9zaXRpb24ueiA9ICh0aGlzLl9zcXVhcmVzW2l0XS5leHRlbnQuei5taW4gKyB0aGlzLl9zcXVhcmVzW2l0XS5leHRlbnQuei5tYXgpIC8yO1xuICAgICAgICAgICAgc3BoZXJlLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcIlNxdWFyZSBcIiArIGl0ICsgXCIgLSBNYXRlcmlhbFwiLCB0aGlzLl9zY2VuZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxwaGFTcXVhcmUgPT0gdGhpcy5fc3F1YXJlc1tpdF0pIHtcbiAgICAgICAgICAgICAgICBzcGhlcmUubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbmV3IEJBQllMT04uQ29sb3IzKDEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3F1YXJlc1tpdF0udHlwZSA9PSBcIkNPUk5FUlwiKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlLm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG5ldyBCQUJZTE9OLkNvbG9yMygwLCAxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NxdWFyZXNbaXRdLnR5cGUgPT0gXCJFWFRCT1JERVJcIikge1xuICAgICAgICAgICAgICAgIHNwaGVyZS5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMCwgMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zcXVhcmVzW2l0XS50eXBlID09IFwiSU5UQk9SREVSXCIpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmUubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbmV3IEJBQllMT04uQ29sb3IzKDEsIDAuNSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zcXVhcmVzW2l0XS50eXBlID09IFwiQkxBQ0tcIikge1xuICAgICAgICAgICAgICAgIHNwaGVyZS5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMCwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BoZXJlID0gQkFCWUxPTi5NZXNoLkNyZWF0ZVNwaGVyZShcIkNlbnRlclwiLCAxMCwgMTAwLCB0aGlzLl9zY2VuZSk7XG4gICAgICAgIHNwaGVyZS5wb3NpdGlvbi54ID0gdGhpcy5fY2VudGVyLng7XG4gICAgICAgIHNwaGVyZS5wb3NpdGlvbi55ID0gdGhpcy5fdG90YWxFeHRlbnQueS5tYXg7XG4gICAgICAgIHNwaGVyZS5wb3NpdGlvbi56ID0gdGhpcy5fY2VudGVyLno7XG4gICAgfTtcbn07IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLkNhbWVyYUNvbnRhaW5lci5qc1xuICpcbiAqIENhbWVyYUNvbnRhaW5lciBjbGFzcyA6XG4gKiAgQSBjb250YWluZXIgd2hpY2ggd2lsbCBjb250YWlucyBhbGwgY2FtZXJhcyBvZiB0aGUgc2NlbmVcbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgLyogQ29uc3RydWN0b3IgKi9cbiAgICBSQU5ETy5DYW1lcmFDb250YWluZXIgPSBmdW5jdGlvbiAoY2FudmFzLCBzY2VuZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5fc3dpdGNoRW5hYmxlZCA9IHBhcmFtcy5zd2l0Y2hFbmFibGVkIHx8IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2NvbXB1dGVyID0gbmV3IFJBTkRPLkNhbWVyYUNvbXB1dGVyIChcbiAgICAgICAgICAgIHBhcmFtcy5kZW1DZW50ZXIsXG4gICAgICAgICAgICBwYXJhbXMuZGVtRXh0ZW50LFxuICAgICAgICAgICAgcGFyYW1zLmRlbUFsdGl0dWRlcyxcbiAgICAgICAgICAgIHBhcmFtcy5vZmZzZXRzIHx8IEJBQllMT04uVmVjdG9yMy5aZXJvKCksXG4gICAgICAgICAgICBzY2VuZSxcbiAgICAgICAgICAgIDZcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmNhbWVyYXMgPSB7fTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpb25QYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29udHJvbHNBdHRhY2hlZCAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25CZWZvcmVTd2l0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLl90YXJnZXRCZWZvcmVTd2l0Y2ggPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5pbml0aWFsVGFyZ2V0ID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5saW1pdHMgPSB7XG4gICAgICAgICAgICAnbG93ZXJYJyAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJ3VwcGVyWCcgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICdsb3dlclonICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAndXBwZXJaJyAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJ2xvd2VyUmFkaXVzJyAgIDogbnVsbCxcbiAgICAgICAgICAgICd1cHBlclJhZGl1cycgICA6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9O1xuXG4gICAgLy8gU3RhdGljIEFycmF5IGRlZmluaW5nIHBvc3NpYmxlcyBjYW1lcmFzIElEc1xuICAgIFJBTkRPLkNhbWVyYUlEcyA9IFtcImV4YW1pbmVcIiwgXCJiaXJkXCIsIFwiaGlrZXJcIl07XG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21wdXRlSW5pdGlhbFBhcmFtZXRlcnMgKCk7XG4gICAgICAgIHRoaXMuX2J1aWxkQmlyZENhbWVyYSAoKTtcbiAgICAgICAgdGhpcy5fYnVpbGRFeGFtaW5lQ2FtZXJhICgpO1xuICAgICAgICB0aGlzLl9idWlsZEhpa2VyQ2FtZXJhICgpO1xuICAgICAgICB0aGlzLl9pbml0SW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYVN3aXRjaGVyICgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb250YWluZXIuX2J1aWxkRXhhbWluZUNhbWVyYSgpIDogYnVpbGQgb2YgdGhlIEV4YW1pbmUgY2FtZXJhXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fYnVpbGRFeGFtaW5lQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhhbWluZV9jYW1lcmEgPSBuZXcgUkFORE8uRXhhbWluZUNhbWVyYShcbiAgICAgICAgICAgIFwiRXhhbWluZSBDYW1lcmFcIiwwLCAwLCAwLFxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy5fc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgZXhhbWluZV9jYW1lcmEuaWQgPSBcImV4YW1pbmVcIjtcbiAgICAgICAgZXhhbWluZV9jYW1lcmEua2V5c1VwICAgICA9IFs5MCwgMzhdOyAvLyBUb3VjaGUgWiBhbmQgdXBcbiAgICAgICAgZXhhbWluZV9jYW1lcmEua2V5c0Rvd24gICA9IFs4MywgNDBdOyAvLyBUb3VjaGUgUyBhbmQgZG93blxuICAgICAgICBleGFtaW5lX2NhbWVyYS5rZXlzTGVmdCAgID0gWzgxLCAzN107IC8vIFRvdWNoZSBRIGFuZCBsZWZ0XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmtleXNSaWdodCAgPSBbNjgsIDM5XTsgLy8gVG91Y2hlIEQgYW5kIHJpZ2h0XG5cbiAgICAgICAgZXhhbWluZV9jYW1lcmEud2hlZWxQcmVjaXNpb24gPSAwLjI7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmNoZWNrQ29sbGlzaW9ucyA9IHRydWU7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmVsbGlwc29pZC55ID0gUkFORE8uU0VUVElOR1MuQ09MTElTSU9OU19PRkZTRVQ7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLm1heFogPSA1MDAwMDtcbiAgICAgICAgZXhhbWluZV9jYW1lcmEuc3BlZWQgPSBSQU5ETy5TRVRUSU5HUy5DQU1fU1BFRURfRiA7XG5cbiAgICAgICAgZXhhbWluZV9jYW1lcmEubG93ZXJYTGltaXQgPSB0aGlzLmxpbWl0cy5sb3dlclg7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmxvd2VyWkxpbWl0ID0gdGhpcy5saW1pdHMubG93ZXJaO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS51cHBlclhMaW1pdCA9IHRoaXMubGltaXRzLnVwcGVyWDtcbiAgICAgICAgZXhhbWluZV9jYW1lcmEudXBwZXJaTGltaXQgPSB0aGlzLmxpbWl0cy51cHBlclo7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLnVwcGVyQmV0YUxpbWl0ID0gTWF0aC5QSS8yO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhcy5leGFtaW5lID0gZXhhbWluZV9jYW1lcmE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5fYnVpbGRCaXJkQ2FtZXJhKCkgOiBidWlsZCBvZiB0aGUgQmlyZCBjYW1lcmFcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb250YWluZXIucHJvdG90eXBlLl9idWlsZEJpcmRDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiaXJkX2NhbWVyYSA9IG5ldyBSQU5ETy5CaXJkQ2FtZXJhKFxuICAgICAgICAgICAgXCJCaXJkIENhbWVyYVwiLFxuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlplcm8oKSxcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lXG4gICAgICAgICk7XG4gICAgICAgIGJpcmRfY2FtZXJhLmlkID0gXCJiaXJkXCI7XG4gICAgICAgIGJpcmRfY2FtZXJhLmtleXNVcCAgICAgPSBbOTAsIDM4XTsgLy8gVG91Y2hlIFogYW5kIHVwXG4gICAgICAgIGJpcmRfY2FtZXJhLmtleXNEb3duICAgPSBbODMsIDQwXTsgLy8gVG91Y2hlIFMgYW5kIGRvd25cbiAgICAgICAgYmlyZF9jYW1lcmEua2V5c0xlZnQgICA9IFs4MSwgMzddOyAvLyBUb3VjaGUgUSBhbmQgbGVmdFxuICAgICAgICBiaXJkX2NhbWVyYS5rZXlzUmlnaHQgID0gWzY4LCAzOV07IC8vIFRvdWNoZSBEIGFuZCByaWdodFxuXG4gICAgICAgIGJpcmRfY2FtZXJhLmNoZWNrQ29sbGlzaW9ucyA9IHRydWU7XG4gICAgICAgIGJpcmRfY2FtZXJhLmVsbGlwc29pZC55ID0gUkFORE8uU0VUVElOR1MuQ09MTElTSU9OU19PRkZTRVQ7XG4gICAgICAgIGJpcmRfY2FtZXJhLm1heFogPSA1MDAwMDtcbiAgICAgICAgYmlyZF9jYW1lcmEuc3BlZWQgPSBSQU5ETy5TRVRUSU5HUy5DQU1fU1BFRURfRiA7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFzLmJpcmQgPSBiaXJkX2NhbWVyYTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29udGFpbmVyLl9idWlsZEhpa2VyQ2FtZXJhKCkgOiBidWlsZCBvZiB0aGUgSGlrZXIgY2FtZXJhXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fYnVpbGRIaWtlckNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhpa2VyX2NhbWVyYSA9IG5ldyBSQU5ETy5IaWtlckNhbWVyYShcbiAgICAgICAgICAgIFwiSGlrZXIgQ2FtZXJhXCIsXG4gICAgICAgICAgICBCQUJZTE9OLlZlY3RvcjMuWmVybygpLFxuICAgICAgICAgICAgdGhpcy5fc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgaGlrZXJfY2FtZXJhLmlkID0gXCJoaWtlclwiO1xuXG4gICAgICAgIGhpa2VyX2NhbWVyYS5jaGVja0NvbGxpc2lvbnMgPSB0cnVlO1xuICAgICAgICBoaWtlcl9jYW1lcmEubWF4WiA9IDUwMDAwO1xuXG4gICAgICAgIGhpa2VyX2NhbWVyYS5yZXR1cm5TcGVlZCA9IFJBTkRPLlNFVFRJTkdTLkhDQU1fUkVUVVJOX1NQRUVEO1xuICAgICAgICBoaWtlcl9jYW1lcmEuZm9sbG93U3BlZWQgPSBSQU5ETy5TRVRUSU5HUy5IQ0FNX0ZPTExPV19TUEVFRDtcblxuXG4gICAgICAgIHRoaXMuY2FtZXJhcy5oaWtlciA9IGhpa2VyX2NhbWVyYTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29udGFpbmVyLnNldEFjdGl2ZUNhbWVyYSgpIDogc2V0IHRoZSBhY3RpdmUgY2FtZXJhIG9mIHRoZSBzY2VuZVxuICAgICAqICAgICAgLSBuZXdJRDogSUQgb2YgdGhlIGNhbWVyYSB3ZSB3YW50IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKlxuICAgICAqIE5CIDogbmV3SUQgc2hvdWxkIGJlIGluIHRoZSBzdGF0aWMgYXJyYXkgUkFORE8uY2FtZXJhSURzXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5zZXRBY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAobmV3SUQpIHtcbiAgICAgICAgaWYgKFJBTkRPLkNhbWVyYUlEcy5pbmRleE9mKG5ld0lEKSA9PSAtMSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJBTkRPLkNhbWVyYUNvbnRhaW5lci5zZXRBY3RpdmVDYW1lcmEgKCkgOiBcIiArIG5ld0lEICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpcyBub3QgYW4gYXZhaWxhYmxlIGNhbWVyYSdzIElEXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZElEID0gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLmlkO1xuXG4gICAgICAgIC8vIFJlY29yZCBpbmZvcm1hdGlvbnMgb2YgdGhlIG9sZCBjYW1lcmFcbiAgICAgICAgdGhpcy5fcmVjb3JkSW5mb0JlZm9yZVN3aXRjaChvbGRJRCk7XG5cbiAgICAgICAgLy8gQXR0YWNoICYgZGV0YWNoIGNvbnRyb2xzIG9mIGNhbWVyYXNcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRyb2xzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhc1tvbGRJRF0uZGV0YWNoQ29udHJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FtZXJhc1tuZXdJRF0uYXR0YWNoQ29udHJvbCh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLl9jb250cm9sc0F0dGFjaGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBVcGRhdGUgY2FtZXJhXG4gICAgICAgIHRoaXMuX3NjZW5lLnNldEFjdGl2ZUNhbWVyYUJ5SUQgKG5ld0lEKTtcbiAgICAgICAgdGhpcy5fcmVzZXRCeURlZmF1bHQoKTtcblxuICAgICAgICAvLyBJbnRlcmZhY2UgY2hhbmdlc1xuICAgICAgICBqUXVlcnkoXCIuY29udHJvbHMtLVwiICsgb2xkSUQpLmNzcyhcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgICAgICBqUXVlcnkoXCIuY2FtZXJhLS1cIiAgICsgb2xkSUQpLnJlbW92ZUNsYXNzKFwiY2FtZXJhLS1zZWxlY3RlZFwiKTtcbiAgICAgICAgalF1ZXJ5KFwiLmNvbnRyb2xzLS1cIiArIG5ld0lEKS5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgIGpRdWVyeShcIi5jYW1lcmEtLVwiICAgKyBuZXdJRCkuYWRkQ2xhc3MoXCJjYW1lcmEtLXNlbGVjdGVkXCIpO1xuICAgIH07XG5cbiAgICBSQU5ETy5DYW1lcmFDb250YWluZXIucHJvdG90eXBlLl9yZWNvcmRJbmZvQmVmb3JlU3dpdGNoID0gZnVuY3Rpb24gKG9sZElEKSB7XG4gICAgICAgIGlmIChvbGRJRCA9PSBcImV4YW1pbmVcIikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25CZWZvcmVTd2l0Y2ggID0gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRCZWZvcmVTd2l0Y2ggICAgPSB0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEudGFyZ2V0LmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbkJlZm9yZVN3aXRjaCAgPSBudWxsO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmIChvbGRJRCA9PSBcImJpcmRcIiB8fCBvbGRJRCA9PSBcImhpa2VyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQmVmb3JlU3dpdGNoICA9IHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fcm90YXRpb25CZWZvcmVTd2l0Y2ggID0gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLnJvdGF0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRCZWZvcmVTd2l0Y2ggICAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuc2V0QW5pbWF0aW9uUGF0aCA9IGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25QYXRoID0gdmVydGljZXM7XG4gICAgICAgIHRoaXMuY2FtZXJhcy5oaWtlci5zZXRQYXRoKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5lbmFibGVDYW1lcmEgKFwiaGlrZXJcIik7XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX2NhbWVyYVN3aXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRBcnJheSA9IFJBTkRPLkNhbWVyYUlEcztcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fc3dpdGNoRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgIGpRdWVyeShcIi5jYW1lcmFfc3dpdGNoZXJcIikuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaXQgaW4gaWRBcnJheSkge1xuICAgICAgICAgICAgLy8gVGhlIGhpa2VyIGNhbWVyYSBtdXN0IG5vdCBiZSBhY3RpdmUgdW50aWwgaGlzIHBhdGggaGFzIG5vdCBiZWVuIHNldFxuICAgICAgICAgICAgaWYgKGlkQXJyYXlbaXRdICE9IFwiaGlrZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FtZXJhKGlkQXJyYXlbaXRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xpY2sgZXZlbnRcbiAgICAgICAgICAgIGpRdWVyeShcIi5jYW1lcmEtLVwiICsgaWRBcnJheVtpdF0pLmNsaWNrKHtpZCA6IGlkQXJyYXlbaXRdfSwgZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgICAgIGlmKGpRdWVyeSh0aGlzKS5oYXNDbGFzcygnY2FtZXJhLS1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlQ2FtZXJhIChlLmRhdGEuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuZW5hYmxlQ2FtZXJhID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGpRdWVyeShcIi5jYW1lcmEtLVwiICsgaWQgKS5yZW1vdmVDbGFzcyhcImNhbWVyYS0tZGlzYWJsZWRcIik7XG4gICAgICAgIGpRdWVyeShcIi5jYW1lcmEtLVwiICsgaWQgKS5hZGRDbGFzcyhcImNhbWVyYS0tZW5hYmxlZFwiKTtcbiAgICAgICAgalF1ZXJ5KFwiLmNhbWVyYS0tXCIgKyBpZCArIFwiIGltZ1wiKS5hdHRyKFwic3JjXCIsIFJBTkRPLlNFVFRJTkdTLklNQUdFU19GT0xERVIgKyBpZCArIFwiX2NhbWVyYS5wbmdcIik7XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX3Jlc2V0QnlEZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlQ2FtID0gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhO1xuXG4gICAgICAgIC8vIEV4YW1pbmUgQ2FtZXJhXG4gICAgICAgIGlmIChhY3RpdmVDYW0uaWQgPT0gXCJleGFtaW5lXCIpIHtcbiAgICAgICAgICAgIGFjdGl2ZUNhbS5zZXRQb3NpdGlvbih0aGlzLmluaXRpYWxQb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgICAgIGFjdGl2ZUNhbS50YXJnZXQgPSB0aGlzLmluaXRpYWxUYXJnZXQuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpcmQgQ2FtZXJhXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2ZUNhbS5pZCA9PSBcImJpcmRcIikge1xuICAgICAgICAgICAgYWN0aXZlQ2FtLnBvc2l0aW9uID0gdGhpcy5pbml0aWFsUG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIGFjdGl2ZUNhbS5zZXRUYXJnZXQodGhpcy5pbml0aWFsVGFyZ2V0LmNsb25lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlrZXIgQ2FtZXJhXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2ZUNhbS5pZCA9PSBcImhpa2VyXCIgKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25CZWZvcmVTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDYW0ucG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbkJlZm9yZVN3aXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbkJlZm9yZVN3aXRjaCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNhbS5yb3RhdGlvbiA9IHRoaXMuX3JvdGF0aW9uQmVmb3JlU3dpdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldEJlZm9yZVN3aXRjaCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNhbS5zZXRUYXJnZXQodGhpcy5fdGFyZ2V0QmVmb3JlU3dpdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGl2ZUNhbS5fcmVzZXQgKCk7XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX2NvbXB1dGVJbml0aWFsUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tcHV0ZXIuY29tcHV0ZUluaXRpYWxQb3NpdGlvblRvUmVmICh0aGlzLmluaXRpYWxQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZXIuY29tcHV0ZUluaXRpYWxUYXJnZXRUb1JlZiAodGhpcy5pbml0aWFsVGFyZ2V0KTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlci5jb21wdXRlTGltaXRzVG9SZWYgKHRoaXMubGltaXRzKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5faW5pdEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGhpcy5jYW1lcmFzKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmNhbWVyYXNbaXRdLmlkO1xuICAgICAgICAgICAgalF1ZXJ5KFwiLmNvbnRyb2xzLS1cIiArIGlkICsgXCIgLmNvbnRyb2xzLWRlc2NyaXB0aW9uXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoUkFORE8uU0VUVElOR1MuQ0FNRVJBX01FU1NBR0VTW2lkXSk7XG4gICAgICAgICAgICBqUXVlcnkoXCIuY2FtZXJhLS1cIiAgICsgaWQgKyBcIiAuY2FtZXJhLWRlc2NyaXB0aW9uXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoUkFORE8uU0VUVElOR1MuQ0FNRVJBX01FU1NBR0VTW2lkXSk7XG4gICAgICAgIH1cbiAgICB9O1xufTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uRXhhbWluZUNhbWVyYS5qc1xuICpcbiAqIEV4YW1pbmVDYW1lcmEgY2xhc3MgOlxuICogIEl0IGlzIGEgY2FtZXJhIHdoaWNoIGxvb2sgbGlrZSB0aGUgQXJjUm90YXRlQ2FtZXJhIG9mIEJhYnlsb25KUy5cbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL0JhYnlsb25KUy9CYWJ5bG9uLmpzL3dpa2kvMDUtQ2FtZXJhcy5cbiAqXG4gKiAgQnV0IHdlIGNhbiBhbHNvIHRyYW5zbGF0ZSBpdCBvdmVyIHdvcmxkIGF4aXMgWCBhbmQgWi5cbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgdmFyIGV2ZW50UHJlZml4ID0gQkFCWUxPTi5Ub29scy5HZXRQb2ludGVyUHJlZml4KCk7XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhID0gZnVuY3Rpb24gKG5hbWUsIGFscGhhLCBiZXRhLCByYWRpdXMsIHRhcmdldCwgc2NlbmUpIHtcbiAgICAgICAgQkFCWUxPTi5DYW1lcmEuY2FsbChcbiAgICAgICAgICAgIHRoaXMsIG5hbWUsIFJBTkRPLkV4YW1pbmVDYW1lcmEuc3BoZXJpY1RvQ2FydGVzaWFuKFxuICAgICAgICAgICAgICAgIGFscGhhLFxuICAgICAgICAgICAgICAgIGJldGEsXG4gICAgICAgICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgKSwgc2NlbmVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gICAgICAgIHRoaXMuYmV0YSA9IGJldGE7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgIHRoaXMua2V5c1VwID0gWzM4XTtcbiAgICAgICAgdGhpcy5rZXlzRG93biA9IFs0MF07XG4gICAgICAgIHRoaXMua2V5c0xlZnQgPSBbMzddO1xuICAgICAgICB0aGlzLmtleXNSaWdodCA9IFszOV07XG5cbiAgICAgICAgLy8gQ29sbGlzaW9uc1xuICAgICAgICB0aGlzLl9jb2xsaWRlciA9IG5ldyBCQUJZTE9OLkNvbGxpZGVyKCk7XG4gICAgICAgIHRoaXMuX25lZWRNb3ZlRm9yR3Jhdml0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICB0aGlzLmNhbWVyYVJvdGF0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMigwLCAwKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuZWxsaXBzb2lkID0gbmV3IEJBQllMT04uVmVjdG9yMygwLjUsIDEsIDAuNSk7XG5cbiAgICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICAgIHRoaXMuX3ZpZXdNYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fb2xkUG9zaXRpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9kaWZmUG9zaXRpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9uZXdQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWVtYmVyc1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmluZXJ0aWFsQWxwaGFPZmZzZXQgPSAwO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmluZXJ0aWFsQmV0YU9mZnNldCA9IDA7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuaW5lcnRpYWxSYWRpdXNPZmZzZXQgPSAwO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmxvd2VyQWxwaGFMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUudXBwZXJBbHBoYUxpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5sb3dlckJldGFMaW1pdCA9IDAuMDE7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUudXBwZXJCZXRhTGltaXQgPSBNYXRoLlBJO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmxvd2VyUmFkaXVzTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLnVwcGVyUmFkaXVzTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmxvd2VyWExpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS51cHBlclhMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUubG93ZXJaTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLnVwcGVyWkxpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5hbmd1bGFyU2Vuc2liaWxpdHkgPSAxMDAwLjA7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUud2hlZWxQcmVjaXNpb24gPSAzLjA7XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5fZ2V0VGFyZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5wb3NpdGlvbiB8fCB0aGlzLnRhcmdldDtcbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5faW5pdENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUuX2luaXRDYWNoZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnRhcmdldCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLmFscGhhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZS5iZXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZS5yYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLl91cGRhdGVDYWNoZSA9IGZ1bmN0aW9uIChpZ25vcmVQYXJlbnRDbGFzcykge1xuICAgICAgICBpZiAoIWlnbm9yZVBhcmVudENsYXNzKVxuICAgICAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl91cGRhdGVDYWNoZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2NhY2hlLnRhcmdldC5jb3B5RnJvbSh0aGlzLl9nZXRUYXJnZXRQb3NpdGlvbigpKTtcbiAgICAgICAgdGhpcy5fY2FjaGUuYWxwaGEgPSB0aGlzLmFscGhhO1xuICAgICAgICB0aGlzLl9jYWNoZS5iZXRhID0gdGhpcy5iZXRhO1xuICAgICAgICB0aGlzLl9jYWNoZS5yYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICB9O1xuXG4gICAgLy8gU3luY2hyb25pemVkXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeC5jYWxsKHRoaXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS50YXJnZXQuZXF1YWxzKHRoaXMuX2dldFRhcmdldFBvc2l0aW9uKCkpXG4gICAgICAgICAgICAmJiB0aGlzLl9jYWNoZS5hbHBoYSA9PT0gdGhpcy5hbHBoYVxuICAgICAgICAgICAgJiYgdGhpcy5fY2FjaGUuYmV0YSA9PT0gdGhpcy5iZXRhXG4gICAgICAgICAgICAmJiB0aGlzLl9jYWNoZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5fY29tcHV0ZUxvY2FsQ2FtZXJhU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWVkICogKChCQUJZTE9OLlRvb2xzLkdldERlbHRhVGltZSgpIC8gKEJBQllMT04uVG9vbHMuR2V0RnBzKCkgKiAxMC4wKSkpO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5hdHRhY2hDb250cm9sID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzUG9zaXRpb247XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHBvaW50ZXJJZDtcblxuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICB2YXIgZW5naW5lID0gdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uUG9pbnRlckRvd24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChldnQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvaW50ZXJJZCA9IGV2dC5wb2ludGVySWQ7XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogZXZ0LmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgdGhpcy5fb25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVySWQgIT09IGV2dC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gZXZ0LmNsaWVudFggLSBwcmV2aW91c1Bvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBldnQuY2xpZW50WSAtIHByZXZpb3VzUG9zaXRpb24ueTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxBbHBoYU9mZnNldCAtPSBvZmZzZXRYIC8gdGhhdC5hbmd1bGFyU2Vuc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmVydGlhbEJldGFPZmZzZXQgLT0gb2Zmc2V0WSAvIHRoYXQuYW5ndWxhclNlbnNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuZ2luZS5pc1BvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGV2dC5tb3ZlbWVudFggfHwgZXZ0Lm1vek1vdmVtZW50WCB8fCBldnQud2Via2l0TW92ZW1lbnRYIHx8IGV2dC5tc01vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gZXZ0Lm1vdmVtZW50WSB8fCBldnQubW96TW92ZW1lbnRZIHx8IGV2dC53ZWJraXRNb3ZlbWVudFkgfHwgZXZ0Lm1zTW92ZW1lbnRZIHx8IDA7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsQWxwaGFPZmZzZXQgLT0gb2Zmc2V0WCAvIHRoYXQuYW5ndWxhclNlbnNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxCZXRhT2Zmc2V0IC09IG9mZnNldFkgLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl93aGVlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBldmVudC53aGVlbERlbHRhIC8gKHRoYXQud2hlZWxQcmVjaXNpb24gKiA0MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtZXZlbnQuZGV0YWlsIC8gdGhhdC53aGVlbFByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsdGEpXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxSYWRpdXNPZmZzZXQgKz0gZGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmtleXNVcC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzRG93bi5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzTGVmdC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5rZXlzUmlnaHQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoYXQuX2tleXMuaW5kZXhPZihldnQua2V5Q29kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fa2V5cy5wdXNoKGV2dC5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlVcCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzVXAuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0Rvd24uaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0xlZnQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c1JpZ2h0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0Ll9rZXlzLmluZGV4T2YoZXZ0LmtleUNvZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uTG9zdEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBwb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25HZXN0dXJlU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuTVNHZXN0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5fTVNHZXN0dXJlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9NU0dlc3R1cmVIYW5kbGVyID0gbmV3IE1TR2VzdHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9NU0dlc3R1cmVIYW5kbGVyLnRhcmdldCA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0Ll9NU0dlc3R1cmVIYW5kbGVyLmFkZFBvaW50ZXIoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25HZXN0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJhZGl1cyAqPSBlLnNjYWxlO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgdGhhdC5pbmVydGlhbEFscGhhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsQmV0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmVydGlhbFJhZGl1c09mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhhdC5jYW1lcmFEaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJkb3duXCIsIHRoaXMuX29uUG9pbnRlckRvd24sIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJ1cFwiLCB0aGlzLl9vblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRQcmVmaXggKyBcIm91dFwiLCB0aGlzLl9vblBvaW50ZXJVcCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRQcmVmaXggKyBcIm1vdmVcIiwgdGhpcy5fb25Qb2ludGVyTW92ZSwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCB0aGlzLl9vbkdlc3R1cmVTdGFydCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJNU0dlc3R1cmVDaGFuZ2VcIiwgdGhpcy5fb25HZXN0dXJlLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX3doZWVsLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl93aGVlbCwgZmFsc2UpO1xuXG4gICAgICAgIEJBQllMT04uVG9vbHMuUmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmRldGFjaENvbnRyb2wgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFbGVtZW50ICE9IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwiZG93blwiLCB0aGlzLl9vblBvaW50ZXJEb3duKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJ1cFwiLCB0aGlzLl9vblBvaW50ZXJVcCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwib3V0XCIsIHRoaXMuX29uUG9pbnRlclVwKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJtb3ZlXCIsIHRoaXMuX29uUG9pbnRlck1vdmUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIHRoaXMuX29uR2VzdHVyZVN0YXJ0KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNHZXN0dXJlQ2hhbmdlXCIsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX3doZWVsKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsKTtcblxuICAgICAgICBCQUJZTE9OLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5fTVNHZXN0dXJlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLl9jb2xsaWRlV2l0aFdvcmxkID0gZnVuY3Rpb24gKHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciBnbG9iYWxQb3NpdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGdsb2JhbFBvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24sIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYmFsUG9zaXRpb24uc3VidHJhY3RGcm9tRmxvYXRzVG9SZWYoMCwgdGhpcy5lbGxpcHNvaWQueSwgMCwgdGhpcy5fb2xkUG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9jb2xsaWRlci5yYWRpdXMgPSB0aGlzLmVsbGlwc29pZDtcblxuICAgICAgICB0aGlzLmdldFNjZW5lKCkuX2dldE5ld1Bvc2l0aW9uKHRoaXMuX29sZFBvc2l0aW9uLCB2ZWxvY2l0eSwgdGhpcy5fY29sbGlkZXIsIDMsIHRoaXMuX25ld1Bvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fbmV3UG9zaXRpb24uc3VidHJhY3RUb1JlZih0aGlzLl9vbGRQb3NpdGlvbiwgdGhpcy5fZGlmZlBvc2l0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5fZGlmZlBvc2l0aW9uLmxlbmd0aCgpID4gQkFCWUxPTi5FbmdpbmUuQ29sbGlzaW9uc0Vwc2lsb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLl9kaWZmUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ29sbGlkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db2xsaWRlKHRoaXMuX2NvbGxpZGVyLmNvbGxpZGVkTWVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2NoZWNrSW5wdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlcyB3aXRoIHRoZSBLZXlib2FyZFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gdGhpcy5fa2V5c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgc3BlZWQgPSB0aGlzLl9jb21wdXRlTG9jYWxDYW1lcmFTcGVlZCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzTGVmdC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKC1zcGVlZCwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMua2V5c1VwLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoc3BlZWQsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmtleXNSaWdodC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKHNwZWVkLCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5rZXlzRG93bi5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKC1zcGVlZCwgMCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0Vmlld01hdHJpeCgpLmludmVydFRvUmVmKHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCk7XG5cbiAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxUb1JlZihcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbixcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXgsXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmtleXNVcC5pbmRleE9mKGtleUNvZGUpICAgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzRG93bi5pbmRleE9mKGtleUNvZGUpICAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24uYWRkSW5QbGFjZShcbiAgICAgICAgICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZKC1NYXRoLlBJLzIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi5hZGRJblBsYWNlKHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGVja0lucHV0cygpO1xuXG4gICAgICAgIHZhciBuZWVkVG9Nb3ZlVGFyZ2V0ID0gKFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueCkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmNhbWVyYURpcmVjdGlvbi55KSA+IDAgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnopID4gMFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBuZWVkVG9Sb3RhdGVPclpvb20gPSAoXG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQgICE9IDAgfHxcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0ICAgIT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCAhPSAwXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG5lZWRDb2xsaXNpb25zID0gdGhpcy5jaGVja0NvbGxpc2lvbnMgJiYgdGhpcy5fc2NlbmUuY29sbGlzaW9uc0VuYWJsZWQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRhcmdldFxuICAgICAgICBpZiAobmVlZFRvTW92ZVRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkSW5QbGFjZSh0aGlzLmNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgQWxwaGEgQmV0YSBSYWRpdXNcbiAgICAgICAgaWYgKG5lZWRUb1JvdGF0ZU9yWm9vbSkge1xuICAgICAgICAgICAgdGhpcy5hbHBoYSAgKz0gdGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5iZXRhICAgKz0gdGhpcy5pbmVydGlhbEJldGFPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyAtPSB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGltaXRzXG4gICAgICAgIGlmICh0aGlzLmxvd2VyQWxwaGFMaW1pdCAmJiB0aGlzLmFscGhhIDwgdGhpcy5sb3dlckFscGhhTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLmxvd2VyQWxwaGFMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBwZXJBbHBoYUxpbWl0ICYmIHRoaXMuYWxwaGEgPiB0aGlzLnVwcGVyQWxwaGFMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IHRoaXMudXBwZXJBbHBoYUxpbWl0O1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb3dlckJldGFMaW1pdCAmJiB0aGlzLmJldGEgPCB0aGlzLmxvd2VyQmV0YUxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmJldGEgPSB0aGlzLmxvd2VyQmV0YUxpbWl0O1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhbEJldGFPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwcGVyQmV0YUxpbWl0ICYmIHRoaXMuYmV0YSA+IHRoaXMudXBwZXJCZXRhTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuYmV0YSA9IHRoaXMudXBwZXJCZXRhTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG93ZXJSYWRpdXNMaW1pdCAmJiB0aGlzLnJhZGl1cyA8IHRoaXMubG93ZXJSYWRpdXNMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLmxvd2VyUmFkaXVzTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cHBlclJhZGl1c0xpbWl0ICYmIHRoaXMucmFkaXVzID4gdGhpcy51cHBlclJhZGl1c0xpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMudXBwZXJSYWRpdXNMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvd2VyWExpbWl0ICYmIHRoaXMudGFyZ2V0LnggPCB0aGlzLmxvd2VyWExpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC54ID0gdGhpcy5sb3dlclhMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwcGVyWExpbWl0ICYmIHRoaXMudGFyZ2V0LnggPiB0aGlzLnVwcGVyWExpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC54ID0gdGhpcy51cHBlclhMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvd2VyWkxpbWl0ICYmIHRoaXMudGFyZ2V0LnogPCB0aGlzLmxvd2VyWkxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC56ID0gdGhpcy5sb3dlclpMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnogPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwcGVyWkxpbWl0ICYmIHRoaXMudGFyZ2V0LnogPiB0aGlzLnVwcGVyWkxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC56ID0gdGhpcy51cHBlclpMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnogPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZXMgYW5kIENvbGxpc2lvbnNcbiAgICAgICAgaWYgKG5lZWRUb1JvdGF0ZU9yWm9vbSAmJiBuZWVkVG9Nb3ZlVGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAobmVlZENvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKFxuICAgICAgICAgICAgICAgICAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnNwaGVyaWNUb0NhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHRoaXMucG9zaXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hZGQodGhpcy5jYW1lcmFEaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZShcbiAgICAgICAgICAgICAgICAgICAgUkFORE8uRXhhbWluZUNhbWVyYS5zcGhlcmljVG9DYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHRoaXMuY2FtZXJhRGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiAodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmVlZFRvUm90YXRlT3Jab29tKSB7XG4gICAgICAgICAgICBpZiAobmVlZENvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKFxuICAgICAgICAgICAgICAgICAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnNwaGVyaWNUb0NhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHRoaXMucG9zaXRpb24pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKFxuICAgICAgICAgICAgICAgICAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnNwaGVyaWNUb0NhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHRoaXMucG9zaXRpb24pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uICh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZWVkVG9Nb3ZlVGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAobmVlZENvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKHRoaXMuY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uICh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZXJ0aWFcbiAgICAgICAgaWYgKG5lZWRUb01vdmVUYXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmNhbWVyYURpcmVjdGlvbi54KSA8IEJBQllMT04uRW5naW5lLkVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24ueCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmNhbWVyYURpcmVjdGlvbi55KSA8IEJBQllMT04uRW5naW5lLkVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24ueSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmNhbWVyYURpcmVjdGlvbi56KSA8IEJBQllMT04uRW5naW5lLkVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24ueiA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRUb1JvdGF0ZU9yWm9vbSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCkgPCBCQUJZTE9OLkVuZ2luZS5FcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCkgPCBCQUJZTE9OLkVuZ2luZS5FcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQpIDwgQkFCWUxPTi5FbmdpbmUuRXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0ICAgICo9IHRoaXMuaW5lcnRpYTtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0ICAgICAqPSB0aGlzLmluZXJ0aWE7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ICAgKj0gdGhpcy5pbmVydGlhO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdmFyIHJhZGl1c3YzID0gcG9zaXRpb24uc3VidHJhY3QodGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzdjMubGVuZ3RoKCk7XG5cbiAgICAgICAgdGhpcy5hbHBoYSA9IE1hdGguYWNvcyhyYWRpdXN2My54IC8gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3cocmFkaXVzdjMueCwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3cocmFkaXVzdjMueiwgMilcbiAgICAgICAgKSk7XG4gICAgICAgIGlmIChyYWRpdXN2My56IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IDIgKiBNYXRoLlBJIC0gdGhpcy5hbHBoYTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJldGEgPSBNYXRoLmFjb3MocmFkaXVzdjMueSAvIHRoaXMucmFkaXVzKTtcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJBQllMT04uTWF0cml4Lkxvb2tBdExIVG9SZWYoXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgICB0aGlzLnVwVmVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fdmlld01hdHJpeFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3TWF0cml4O1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLlpPT01fT05fRkFDVE9SID0gMTtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS56b29tT24gPSBmdW5jdGlvbiAobWVzaGVzKSB7XG4gICAgICAgIG1lc2hlcyA9IG1lc2hlcyB8fCB0aGlzLl9zY2VuZS5tZXNoZXM7XG5cbiAgICAgICAgdmFyIG1pbk1heFZlY3RvciA9IEJBQllMT04uTWVzaC5NaW5NYXgobWVzaGVzKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKG1pbk1heFZlY3Rvci5taW4sIG1pbk1heFZlY3Rvci5tYXgpO1xuXG4gICAgICAgIHRoaXMucmFkaXVzID0gZGlzdGFuY2UgKiBSQU5ETy5FeGFtaW5lQ2FtZXJhLlpPT01fT05fRkFDVE9SO1xuXG4gICAgICAgIHRoaXMuZm9jdXNPbih7bWluOiBtaW5NYXhWZWN0b3IubWluLCBtYXg6IG1pbk1heFZlY3Rvci5tYXgsIGRpc3RhbmNlOiBkaXN0YW5jZX0pO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5mb2N1c09uID0gZnVuY3Rpb24gKG1lc2hlc09yTWluTWF4VmVjdG9yQW5kRGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIG1lc2hlc09yTWluTWF4VmVjdG9yO1xuICAgICAgICB2YXIgZGlzdGFuY2U7XG5cbiAgICAgICAgaWYgKG1lc2hlc09yTWluTWF4VmVjdG9yQW5kRGlzdGFuY2UubWluID09PSB1bmRlZmluZWQpIHsgLy8gbWVzaGVzXG4gICAgICAgICAgICBtZXNoZXNPck1pbk1heFZlY3RvciA9IG1lc2hlc09yTWluTWF4VmVjdG9yQW5kRGlzdGFuY2UgfHwgdGhpcy5fc2NlbmUubWVzaGVzO1xuICAgICAgICAgICAgbWVzaGVzT3JNaW5NYXhWZWN0b3IgPSBCQUJZTE9OLk1lc2guTWluTWF4KG1lc2hlc09yTWluTWF4VmVjdG9yKTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKG1lc2hlc09yTWluTWF4VmVjdG9yLm1pbiwgbWVzaGVzT3JNaW5NYXhWZWN0b3IubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy9taW5NYXhWZWN0b3IgYW5kIGRpc3RhbmNlXG4gICAgICAgICAgICBtZXNoZXNPck1pbk1heFZlY3RvciA9IG1lc2hlc09yTWluTWF4VmVjdG9yQW5kRGlzdGFuY2U7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1lc2hlc09yTWluTWF4VmVjdG9yQW5kRGlzdGFuY2UuZGlzdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhcmdldCA9IEJBQllMT04uTWVzaC5DZW50ZXIobWVzaGVzT3JNaW5NYXhWZWN0b3IpO1xuXG4gICAgICAgIHRoaXMubWF4WiA9IGRpc3RhbmNlICogMjtcbiAgICB9O1xuXG4gICAgLy8gU3RhdGljXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5zcGhlcmljVG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoYWxwaGEsIGJldGEsIHJhZGl1cywgY2VudGVyKSB7XG4gICAgICAgIHZhciBjb3NhID0gTWF0aC5jb3MoYWxwaGEpO1xuICAgICAgICB2YXIgc2luYSA9IE1hdGguc2luKGFscGhhKTtcbiAgICAgICAgdmFyIGNvc2IgPSBNYXRoLmNvcyhiZXRhKTtcbiAgICAgICAgdmFyIHNpbmIgPSBNYXRoLnNpbihiZXRhKTtcblxuICAgICAgICBjZW50ZXIgPSBjZW50ZXIgfHwgQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgcmV0dXJuIGNlbnRlci5hZGQobmV3IEJBQllMT04uVmVjdG9yMyhcbiAgICAgICAgICAgIHJhZGl1cyAqIGNvc2EgKiBzaW5iLFxuICAgICAgICAgICAgcmFkaXVzICogY29zYixcbiAgICAgICAgICAgIHJhZGl1cyAqIHNpbmEgKiBzaW5iXG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLmNhcnRlc2lhblRvU3BoZXJpYyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgY2VudGVyKSB7XG4gICAgICAgIHZhciByYWRpdXN2MyA9IHBvc2l0aW9uLnN1YnRyYWN0KGNlbnRlcik7XG4gICAgICAgIHZhciByYWRpdXMgPSByYWRpdXN2My5sZW5ndGgoKTtcblxuICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLmFjb3MocmFkaXVzdjMueCAvIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KHJhZGl1c3YzLngsIDIpICtcbiAgICAgICAgICAgIE1hdGgucG93KHJhZGl1c3YzLnosIDIpXG4gICAgICAgICkpO1xuICAgICAgICBpZiAocmFkaXVzdjMueiA8IDApIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDIqTWF0aC5QSSAtIHRoaXMuYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJldGEgPSBNYXRoLmFjb3MocmFkaXVzdjMueSAvIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdhbHBoYSc6IGFscGhhLFxuICAgICAgICAgICAgJ2JldGEnOiBiZXRhLFxuICAgICAgICAgICAgJ3JhZGl1cyc6IHJhZGl1c1xuICAgICAgICB9O1xuICAgIH07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5IaWtlckNhbWVyYS5qc1xuICpcbiAqIEhpa2VyQ2FtZXJhIGNsYXNzIDpcbiAqICBJdCBpcyBhIGNhbWVyYSB3aGljaCBsb29rIGxpa2UgdGhlIEZyZWVDYW1lcmEgb2YgQmFieWxvbkpTLlxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vQmFieWxvbkpTL0JhYnlsb24uanMvd2lraS8wNS1DYW1lcmFzLlxuICpcbiAqICBUaGUgbWFqb3IgZGlmZmVyZW5jZXMgaXMgdGhhbiBhbGwgbW92ZXMgaGF2ZSBiZWVuIHJlcGxhY2VkIGJ5IHNvbWVcbiAqICBhbmltYXRpb24gY29udHJvbHMuIEluIGVmZmVjdCB0aGlzIGNhbWVyYSB3YXMgZG9uZSB0byBmb2xsb3cgYSBwYXRoLlxuICpcbiAqICBBZnRlciBpbnN0YW50aWF0ZSB0aGUgY2FtZXJhLCBzZXQgdGhlIGNvbW1hbmRzIGFuZCBzZXQgdGhlIHBhdGggd2l0aFxuICogIHNldFBhdGgoKSBmdW5jdGlvbiwgd2UgY2FuIHBsYXksIHBhdXNlLCBzdG9wLCByZXdpbmQgYW5kIG1vdmUgZm9yd2FyZCB0aGVcbiAqICBjYW1lcmEgYWxvbmcgdGhpcyBwYXRoIGFzIHdlIHdhbnQuXG4gKlxuICpcbiAqICBCZXdhcmUgISB0aGlzIGNhbWVyYSB3aWxsIG5lZWQgdG8gaGF2ZSBpbXBvcnRlZCB0aGVzZSBsaWJyYXJpZXMgOlxuXG48c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2dzYXAvbGF0ZXN0L2Vhc2luZy9FYXNlUGFjay5taW4uanNcIj48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZ3NhcC9sYXRlc3QvVHdlZW5MaXRlLm1pbi5qc1wiPjwvc2NyaXB0PlxuPHNjcmlwdCBzcmM9XCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9nc2FwL2xhdGVzdC9UaW1lbGluZUxpdGUubWluLmpzXCI+PC9zY3JpcHQ+XG48c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2dzYXAvbGF0ZXN0L3BsdWdpbnMvQmV6aWVyUGx1Z2luLm1pbi5qc1wiPjwvc2NyaXB0PlxuPHNjcmlwdCBzcmM9XCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9nc2FwL2xhdGVzdC9wbHVnaW5zL0RpcmVjdGlvbmFsUm90YXRpb25QbHVnaW4ubWluLmpzXCI+PC9zY3JpcHQ+XG5cbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEgPSBmdW5jdGlvbiAobmFtZSwgcG9zaXRpb24sIHNjZW5lKSB7XG4gICAgICAgIEJBQllMT04uQ2FtZXJhLmNhbGwodGhpcywgbmFtZSwgcG9zaXRpb24sIHNjZW5lKTtcblxuICAgICAgICB0aGlzLmNhbWVyYVJvdGF0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMigwLCAwKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5rZXlzUGxheVBhdXNlID0gWzMyXTtcbiAgICAgICAgdGhpcy5rZXlzU3RvcCAgPSBbMTNdO1xuICAgICAgICB0aGlzLmtleXNSZXdpbmQgPSBbNDBdO1xuICAgICAgICB0aGlzLmtleXNGb3J3YXJkID0gWzM4XTtcblxuICAgICAgICAvLyBJbnRlcm5hbHNcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdNYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhbU1hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZVBvaW50ID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRSZWZlcmVuY2VQb2ludCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2xvb2tBdFRlbXAgPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3RlbXBNYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbFxuICAgICAgICB0aGlzLl9wYXRoID0gW107XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2xkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZW5naHRPZkJlemllciA9IDA7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uVHdlZW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9yb3RhdGlvblR3ZWVuID0gbnVsbDtcbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCQUJZTE9OLkNhbWVyYS5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWVtYmVyc1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5yZXR1cm5TcGVlZCA9IDIwMDA7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmZvbGxvd1NwZWVkID0gMjA7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmNoZWNrQ29sbGlzaW9ucyA9IGZhbHNlO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5hcHBseUdyYXZpdHkgPSBmYWxzZTtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUubm9Sb3RhdGlvbkNvbnN0cmFpbnQgPSBmYWxzZTtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuYW5ndWxhclNlbnNpYmlsaXR5ID0gMjAwMC4wO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5sb2NrZWRUYXJnZXQgPSBudWxsO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5vbkNvbGxpZGUgPSBudWxsO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS53aGVlbFByZWNpc2lvbiA9IDAuMztcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuaW5lcnRpYWxSYWRpdXNPZmZzZXQgPSAwO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5sb3dlclJhZGl1c0xpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUudXBwZXJSYWRpdXNMaW1pdCA9IG51bGw7XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9ja2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tlZFRhcmdldC5wb3NpdGlvbiB8fCB0aGlzLmxvY2tlZFRhcmdldDtcbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuX2luaXRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB0aGlzLl9jYWNoZS5yb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUgPSBmdW5jdGlvbiAoaWdub3JlUGFyZW50Q2xhc3MpIHtcbiAgICAgICAgaWYgKCFpZ25vcmVQYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl91cGRhdGVDYWNoZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2tlZFRhcmdldFBvc2l0aW9uID0gdGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgaWYgKCFsb2NrZWRUYXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID0gbG9ja2VkVGFyZ2V0UG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5jb3B5RnJvbShsb2NrZWRUYXJnZXRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZS5yb3RhdGlvbi5jb3B5RnJvbSh0aGlzLnJvdGF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gU3luY2hyb25pemVkXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXguY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2tlZFRhcmdldFBvc2l0aW9uID0gdGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA/IHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5lcXVhbHMobG9ja2VkVGFyZ2V0UG9zaXRpb24pIDogIWxvY2tlZFRhcmdldFBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgdGhpcy5fY2FjaGUucm90YXRpb24uZXF1YWxzKHRoaXMucm90YXRpb24pO1xuICAgIH07XG5cbiAgICAvLyBUYXJnZXRcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB0aGlzLnVwVmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIEJBQllMT04uTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB0aGlzLnVwVmVjdG9yLCB0aGlzLl9jYW1NYXRyaXgpO1xuICAgICAgICB0aGlzLl9jYW1NYXRyaXguaW52ZXJ0KCk7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi54ID0gTWF0aC5hdGFuKHRoaXMuX2NhbU1hdHJpeC5tWzZdIC8gdGhpcy5fY2FtTWF0cml4Lm1bMTBdKTtcblxuICAgICAgICB2YXIgdkRpciA9IHRhcmdldC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAodkRpci54ID49IDAuMCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gKC1NYXRoLmF0YW4odkRpci56IC8gdkRpci54KSArIE1hdGguUEkgLyAyLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gKC1NYXRoLmF0YW4odkRpci56IC8gdkRpci54KSAtIE1hdGguUEkgLyAyLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi56ID0gLU1hdGguYWNvcyhCQUJZTE9OLlZlY3RvcjMuRG90KG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMS4wLCAwKSwgdGhpcy51cFZlY3RvcikpO1xuXG4gICAgICAgIGlmIChpc05hTih0aGlzLnJvdGF0aW9uLngpKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMucm90YXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5yb3RhdGlvbi56KSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi56ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQ29udHJvbHNcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuYXR0YWNoQ29udHJvbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBlbmdpbmUgPSB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICBpZiAodGhpcy5fb25Nb3VzZURvd24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlVXAgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VPdXQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhhdC5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzUG9zaXRpb24gJiYgIWVuZ2luZS5pc1BvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIGlmICghZW5naW5lLmlzUG9pbnRlckxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGV2dC5jbGllbnRYIC0gcHJldmlvdXNQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gZXZ0LmNsaWVudFkgLSBwcmV2aW91c1Bvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGV2dC5tb3ZlbWVudFggfHwgZXZ0Lm1vek1vdmVtZW50WCB8fCBldnQud2Via2l0TW92ZW1lbnRYIHx8IGV2dC5tc01vdmVtZW50WCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZID0gZXZ0Lm1vdmVtZW50WSB8fCBldnQubW96TW92ZW1lbnRZIHx8IGV2dC53ZWJraXRNb3ZlbWVudFkgfHwgZXZ0Lm1zTW92ZW1lbnRZIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5jYW1lcmFSb3RhdGlvbi55ICs9IG9mZnNldFggLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcbiAgICAgICAgICAgICAgICB0aGF0LmNhbWVyYVJvdGF0aW9uLnggKz0gb2Zmc2V0WSAvIHRoYXQuYW5ndWxhclNlbnNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoYXQuX3N0YXRlO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9wYXRoLmxlbmd0aCAmJiAhdGhhdC5faXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzUmV3aW5kLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJwYXVzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcInJld2luZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQua2V5c0ZvcndhcmQuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBcInBhdXNlXCIgfHwgc3RhdGUgPT0gXCJzdG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwiZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX29sZFN0YXRlICA9IG9sZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zdGF0ZSAgICAgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbktleVVwID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoYXQuX3N0YXRlO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9wYXRoLmxlbmd0aCAmJiAhdGhhdC5faXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBldnQua2V5Q29kZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzUGxheVBhdXNlLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJzdG9wXCIgfHwgc3RhdGUgPT0gXCJwYXVzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcInBsYXlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gXCJwbGF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGF1c2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGF0LmtleXNTdG9wLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJwbGF5XCIgfHwgc3RhdGUgPT0gXCJwYXVzZVwiIHx8ICFzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJzdG9wXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhhdC5rZXlzUmV3aW5kLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJyZXdpbmRcIiAmJiB0aGF0Ll90aW1lbGluZS5fdGltZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcInN0b3BcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09IFwicmV3aW5kXCIgJiYgdGhhdC5fdGltZWxpbmUuX3RpbWUgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwYXVzZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQua2V5c0ZvcndhcmQuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBcImZvcndhcmRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwYXVzZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX29sZFN0YXRlICA9IG9sZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zdGF0ZSAgICAgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbkxvc3RGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhhdC5jYW1lcmFSb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjIoMCwgMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5sb2FkUGF0aE9uVGltZWxpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhhdC5fb2xkU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoYXQuX3N0YXRlID0gXCJzdG9wXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fcG9zaXRpb25fdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9wb3NpdGlvbl90cmFuc2l0aW9uLmtpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX3JvdGF0aW9uX3RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fcm90YXRpb25fdHJhbnNpdGlvbi5raWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLl9vbk1vdXNlT3V0LCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuXG4gICAgICAgIEJBQllMT04uVG9vbHMuUmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5kZXRhY2hDb250cm9sID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkRWxlbWVudCAhPSBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMuX29uTW91c2VPdXQpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUpO1xuXG4gICAgICAgIEJBQllMT04uVG9vbHMuVW5yZWdpc3RlclRvcFJvb3RFdmVudHMoW1xuICAgICAgICAgICAgeyBuYW1lOiBcImtleWRvd25cIiwgaGFuZGxlcjogdGhpcy5fb25LZXlEb3duIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5dXBcIiwgaGFuZGxlcjogdGhpcy5fb25LZXlVcCB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImJsdXJcIiwgaGFuZGxlcjogdGhpcy5fb25Mb3N0Rm9jdXMgfVxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLl9hdHRhY2hlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fcmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIG5lZWRUb1JvdGF0ZSA9IChcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueCkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmNhbWVyYVJvdGF0aW9uLnkpID4gMFxuICAgICAgICApO1xuICAgICAgICB2YXIgc3RhdGVIYXZlQ2hhbmdlZCA9ICh0aGlzLl9vbGRTdGF0ZSAhPSB0aGlzLl9zdGF0ZSk7XG5cbiAgICAgICAgLy8gUm90YXRlXG4gICAgICAgIGlmIChuZWVkVG9Sb3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCArPSB0aGlzLmNhbWVyYVJvdGF0aW9uLng7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnkgKz0gdGhpcy5jYW1lcmFSb3RhdGlvbi55O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Sb3RhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSAoTWF0aC5QSSAvIDIpICogMC45NTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW9uLnggPiBsaW1pdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi54ID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb24ueCA8IC1saW1pdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi54ID0gLWxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmVydGlhXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5jYW1lcmFSb3RhdGlvbi54KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFSb3RhdGlvbi54ID0gMDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueSkgPCBCQUJZTE9OLkVuZ2luZS5lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhUm90YXRpb24uc2NhbGVJblBsYWNlKHRoaXMuaW5lcnRpYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGF0ZVxuICAgICAgICBpZiAoc3RhdGVIYXZlQ2hhbmdlZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5fb2xkU3RhdGUgKyBcIiB0byBcIiArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0b3BcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyh0aGlzLl9wYXRoWzBdLCB0aGlzLl9wYXRoWzFdLCB0aGlzLnJldHVyblNwZWVkLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdGltZWxpbmUucGF1c2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicGxheVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUucGxheSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwYXVzZVwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmV3aW5kXCIgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZvcndhcmRcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnBsYXkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJBQllMT04uVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoMCwgMCwgMSwgdGhpcy5fcmVmZXJlbmNlUG9pbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5sb2NrZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGVcbiAgICAgICAgICAgIGlmICh0aGlzLnVwVmVjdG9yLnggIT0gMCB8fCB0aGlzLnVwVmVjdG9yLnkgIT0gMS4wIHx8IHRoaXMudXBWZWN0b3IueiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguTG9va0F0TEhUb1JlZihCQUJZTE9OLlZlY3RvcjMuWmVybygpLCB0aGlzLl9yZWZlcmVuY2VQb2ludCwgdGhpcy51cFZlY3RvciwgdGhpcy5fbG9va0F0VGVtcCk7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksIHRoaXMucm90YXRpb24ueCwgdGhpcy5yb3RhdGlvbi56LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rQXRUZW1wLm11bHRpcGx5VG9SZWYodGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgsIHRoaXMuX3RlbXBNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvb2tBdFRlbXAuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcE1hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX2xvb2tBdFRlbXAsIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksIHRoaXMucm90YXRpb24ueCwgdGhpcy5yb3RhdGlvbi56LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMuX3JlZmVyZW5jZVBvaW50LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCwgdGhpcy5fdHJhbnNmb3JtZWRSZWZlcmVuY2VQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGluZyB0YXJnZXQgYW5kIGZpbmFsIG1hdHJpeFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRUb1JlZih0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50LCB0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQuY29weUZyb20odGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBCQUJZTE9OLk1hdHJpeC5Mb29rQXRMSFRvUmVmKHRoaXMucG9zaXRpb24sIHRoaXMuX2N1cnJlbnRUYXJnZXQsIHRoaXMudXBWZWN0b3IsIHRoaXMuX3ZpZXdNYXRyaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld01hdHJpeDtcbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbiAodmVydGljZXMpIHtcbiAgICAgICAgLy8gUmVpbml0aWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRoID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWxsIHBhdGggYXJyYXlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrPTIwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2godmVydGljZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJ0aWNlc1t2ZXJ0aWNlcy5sZW5ndGhdICE9IHBhdGhbcGF0aC5sZW5ndGhdKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2godmVydGljZXNbdmVydGljZXMubGVuZ3RoXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2FkIHRoaXMgcGF0aCBvbiB0aGUgdGltZWxpbmVcbiAgICAgICAgdGhpcy5fbGVuZ3RoT2ZCZXppZXIgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubG9hZFBhdGhPblRpbWVsaW5lICgpO1xuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUubG9hZFBhdGhPblRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBWZXJpZnkgaWYgcGF0aCBhbmQgbGVuZ3RoT2ZCZXppZXIgZXhpc3RcbiAgICAgICAgaWYgKCF0aGlzLl9wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9sZW5ndGhPZkJlemllcikge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoT2ZCZXppZXIgPSB0aGlzLl9wYXRoLmxlbmd0aCAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWluaXRpYWxpemUgdGltZWxpbmVcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUua2lsbCgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBuZXcgVGltZWxpbmVMaXRlKHtvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll9vbkNvbXBsZXRlVGltZWxpbmUoKTtcbiAgICAgICAgfX0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxzIHBhcmFtZXRlcnMgb2YgYW5pbWF0aW9uXG4gICAgICAgIHZhciBxdWFudGl0eSA9IHRoaXMuX2xlbmd0aE9mQmV6aWVyO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9sZW5ndGhPZkJlemllciAvIHRoaXMuZm9sbG93U3BlZWQ7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuX3BhdGhbMF0ueCxcbiAgICAgICAgICAgIHk6IHRoaXMuX3BhdGhbMF0ueSxcbiAgICAgICAgICAgIHo6IHRoaXMuX3BhdGhbMF0uelxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZXMgdGhlIEJlemllciBjdXJ2ZVxuICAgICAgICB2YXIgdHdlZW4gPSBUd2VlbkxpdGUudG8ocG9zaXRpb24sIHF1YW50aXR5LCB7YmV6aWVyOiB0aGlzLl9wYXRoLCBlYXNlOkxpbmVhci5lYXNlTm9uZX0pO1xuICAgICAgICB2YXIgaSwgZCA9IDIwO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIEJlemllciBjdXJ2ZSBvbiB0aW1lbGluZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVhbnRpdHktZDsgaSsrKSB7XG4gICAgICAgICAgICB0d2Vlbi50aW1lKGkpOyAvLyBKdW1wcyB0byB0aGUgYXBwcm9wcmlhdGUgdGltZSBpbiB0aGUgdHdlZW4sIGNhdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiB2YXJpYWJsZSB0byBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IF8uY2xvbmUocG9zaXRpb24pO1xuICAgICAgICAgICAgdHdlZW4udGltZShpK2QpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBfLmNsb25lKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciByb3RhdGlvbl95ID0gUkFORE8uVXRpbHMuYW5nbGVGcm9tQXhpcyhjdXJyZW50UG9zaXRpb24sIGN1cnJlbnRUYXJnZXQsIEJBQllMT04uQXhpcy5ZKTtcblxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuYWRkKFtcbiAgICAgICAgICAgICAgICBUd2VlbkxpdGUudG8odGhpcy5wb3NpdGlvbiwgKGR1cmF0aW9uIC8gcXVhbnRpdHkpLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICB5OiBjdXJyZW50UG9zaXRpb24ueSArIFJBTkRPLlNFVFRJTkdTLkNBTV9PRkZTRVQsXG4gICAgICAgICAgICAgICAgICAgIHo6IGN1cnJlbnRQb3NpdGlvbi56LFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBcIkxpbmVhci5lYXNlTm9uZVwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgVHdlZW5MaXRlLnRvKHRoaXMucm90YXRpb24sIChkdXJhdGlvbiAvIHF1YW50aXR5KSwge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25hbFJvdGF0aW9uIDp7IHk6IChyb3RhdGlvbl95ICtcIl9zaG9ydFwiKSwgdXNlUmFkaWFuczp0cnVlfSAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IFwiTGluZWFyLmVhc2VOb25lXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBxdWFudGl0eSkge1xuICAgICAgICAgICAgdHdlZW4udGltZShpKyspO1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuYWRkKFxuICAgICAgICAgICAgICAgIFR3ZWVuTGl0ZS50byh0aGlzLnBvc2l0aW9uLCAoZHVyYXRpb24gLyBxdWFudGl0eSksIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSArIFJBTkRPLlNFVFRJTkdTLkNBTV9PRkZTRVQsXG4gICAgICAgICAgICAgICAgICAgIHo6IHBvc2l0aW9uLnosXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IFwiTGluZWFyLmVhc2VOb25lXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuaW1hdGlvbiBwYXVzZWQgYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLl90aW1lbGluZS5wYXVzZSgwKTtcbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5fb25Db21wbGV0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFwic3RvcFwiO1xuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKGZ1dHVyZVBvc2l0aW9uLCBmdXR1cmVUYXJnZXQsIHNwZWVkLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciB5X3JvdGF0aW9uID0gUkFORE8uVXRpbHMuYW5nbGVGcm9tQXhpcyhmdXR1cmVQb3NpdGlvbiwgZnV0dXJlVGFyZ2V0LCBCQUJZTE9OLkF4aXMuWSk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKHRoaXMucG9zaXRpb24sIGZ1dHVyZVBvc2l0aW9uKTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblxuICAgICAgICAvLyBUcmFuc2xhdGlvblxuICAgICAgICB0aGlzLl9wb3NpdGlvblR3ZWVuID0gVHdlZW5MaXRlLnRvKHRoaXMucG9zaXRpb24sIGR1cmF0aW9uLCB7XG4gICAgICAgICAgICB4OiBmdXR1cmVQb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogZnV0dXJlUG9zaXRpb24ueSArIFJBTkRPLlNFVFRJTkdTLkNBTV9PRkZTRVQsXG4gICAgICAgICAgICB6OiBmdXR1cmVQb3NpdGlvbi56LFxuICAgICAgICAgICAgZWFzZTogJ2Vhc2UtaW4nLFxuICAgICAgICAgICAgb25Db21wbGV0ZSA6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yob25Db21wbGV0ZSkgPT09IFwiZnVuY3Rpb25cIikgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSb3RhdGlvblxuICAgICAgICB0aGlzLl9yb3RhdGlvblR3ZWVuID0gVHdlZW5MaXRlLnRvKHRoaXMucm90YXRpb24sIGR1cmF0aW9uLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb25hbFJvdGF0aW9uIDoge1xuICAgICAgICAgICAgICAgIHg6IFwiMF9zaG9ydFwiLFxuICAgICAgICAgICAgICAgIHk6ICh5X3JvdGF0aW9uICsgXCJfc2hvcnRcIiksXG4gICAgICAgICAgICAgICAgejogXCIwX3Nob3J0XCIsXG4gICAgICAgICAgICAgICAgdXNlUmFkaWFucyA6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYXNlOiAnZWFzZS1pbidcbiAgICAgICAgfSk7XG4gICAgfTtcbn07IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLkRlbS5qc1xuICpcbiAqIERlbSBjbGFzcyA6XG4gKiAgUGVybWl0ZXMgdGhlIGNyZWF0aW9uIG9mIGEgRGlnaXRhbCBFbGV2YXRpb24gTW9kZWwgaW4gM0RcbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgLyogQ29uc3RydWN0b3IgKi9cbiAgICBSQU5ETy5EZW0gPSBmdW5jdGlvbiAoZXh0ZW50LCBhbHRpdHVkZXMsIG9mZnNldHMsIHNjZW5lKSB7XG4gICAgICAgIC8qIEF0dHJpYnV0ZXMgZGVjbGFyYXRpb24gKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gdGhpcy5fcHJlcGFyZUV4dGVudChleHRlbnQsIG9mZnNldHMpO1xuICAgICAgICB0aGlzLl9hbHRpdHVkZXMgPSBhbHRpdHVkZXNcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuX3RpbGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLl9taW5fdGhpY2tuZXNzID0gUkFORE8uU0VUVElOR1MuTUlOX1RISUNLTkVTUztcblxuICAgICAgICB0aGlzLmdyb3VuZCA9IG5ldyBCQUJZTE9OLk1lc2goXCJEaWdpdGFsIEVsZXZhdGlvbiBNb2RlbFwiLCBzY2VuZSk7XG4gICAgICAgIHRoaXMuc2lkZXMgID0gbmV3IEJBQllMT04uTWVzaChcIlNpZGVzXCIsIHNjZW5lKTtcbiAgICAgICAgdGhpcy5zY2FsZVZpZXdlciA9IG51bGw7XG5cbiAgICAgICAgLyogSW5pdGlhbGl6YXRpb24gKi9cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfTtcblxuICAgIC8qIE1ldGhvZHMgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FkanVzdFpvb20gKCk7XG5cbiAgICAgICAgdmFyIHRpbGVDb250YWluZXIgPSBuZXcgUkFORE8uVGlsZUNvbnRhaW5lcihcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVhbEV4dGVudCgpLFxuICAgICAgICAgICAgdGhpcy5fYWx0aXR1ZGVzLFxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0c1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl90aWxlcyA9IHRpbGVDb250YWluZXIuX3RpbGVzO1xuICAgICAgICB0aGlzLl9mcmFtZSA9IHRpbGVDb250YWluZXIuZ2V0RnJhbWUoKTtcblxuICAgICAgICB0aGlzLmJ1aWxkR3JvdW5kKCk7XG4gICAgICAgIHRoaXMuYnVpbGRTaWRlcygpO1xuICAgICAgICB0aGlzLmJ1aWxkQmFzZW1lbnQoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBSQU5ETy5EZW0uX3ByZXBhcmVFeHRlbnQoKSA6IHRyYW5zbGF0ZSBleHRlbnQgb2YgdGhlIG9mZnNldHMgaW4gcGFyYW1ldGVyc1xuICAgICAqICAtIGV4dGVudCA6IGV4dGVudCB0byB0cmFuc2xhdGVcbiAgICAgKiAgLSBvZmZzZXRzIDogdmFsdWVzIG9mIHRoZSB0cmFuc2xhdGlvblxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuX3ByZXBhcmVFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvZmZzZXRzKSB7XG4gICAgICAgIGV4dGVudC54Lm1pbiArPSBvZmZzZXRzLng7XG4gICAgICAgIGV4dGVudC54Lm1heCArPSBvZmZzZXRzLng7XG4gICAgICAgIGV4dGVudC56Lm1pbiArPSBvZmZzZXRzLno7XG4gICAgICAgIGV4dGVudC56Lm1heCArPSBvZmZzZXRzLno7XG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUkFORE8uRGVtLl9hZGp1c3Rab29tKCkgOiBhZGp1c3QgdGhlIHRpbGUncyB6b29tIGFjY29yZGluZyB0aGUgZXh0ZW50IG9mIHRoZSBERU1cbiAgICAgKiAgTW9yZSB0aGUgREVNIGlzIGxhcmdlLCBtb3JlIHRoZSB6b29tIGRlY3JlYXNlZCBhbmQgc28gdGlsZXMgYXJlIGJpZ2dlci5cbiAgICAgKlxuICAgICAqIE5CIDogSXQgdGFrZSBpbiBjb3VudCB0aGUgUkFORE8uU0VUVElOR1MuVElMRV9OVU1CRVJfTElNSVQgd2hpY2ggY29ycmVzcG9uZCB0byB0aGVcbiAgICAgKiBsaW1pdCBudW1iZXIgb2YgdGlsZXMuIFRoaXMgbnVtYmVyIGNhbiBiZSBjaGFuZ2VkIGluIGNvbnZlbmllbmNlIGJlZm9yZSBsYXVuY2ggdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuX2FkanVzdFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChSQU5ETy5VdGlscy5nZXROdW1iZXJPZlRpbGVzKFJBTkRPLlNFVFRJTkdTLlRJTEVfWk9PTSwgdGhpcy5nZXRSZWFsRXh0ZW50KCkpID4gUkFORE8uU0VUVElOR1MuVElMRV9OVU1CRVJfTElNSVQpIHtcbiAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTLlRJTEVfWk9PTSAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5idWlsZEdyb3VuZCgpIDogYnVpbGQgdGhlIGdyb3VuZCBvZiB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5idWlsZEdyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gR3JvdW5kIGJ1aWxkaW5nLi4uXG4gICAgICAgIGNvbnNvbGUubG9nKFwiR3JvdW5kIGJ1aWxkaW5nLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYWxsIHRpbGVzXG4gICAgICAgIGZvciAodmFyIGl0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgbWVzaFRpbGUgPSB0aGlzLl9idWlsZFRpbGUodGhpcy5fdGlsZXNbaXRdKTtcbiAgICAgICAgICAgIG1lc2hUaWxlLnBhcmVudCA9IHRoaXMuZ3JvdW5kO1xuXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBmdXR1cmUgdGlsZSdzIHRleHR1cmVcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVUZXh0dXJlKHRoaXMuX3RpbGVzW2l0XS5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHcm91bmQgYnVpbHQgIVxuICAgICAgICBjb25zb2xlLmxvZyhcIkdyb3VuZCBidWlsdCAhIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uYnVpbGRTaWRlcygpIDogYnVpbGQgZm91ciBzaWRlcyBvZiB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5idWlsZFNpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTaWRlcyBidWlsZGluZy4uLlxuICAgICAgICBjb25zb2xlLmxvZyhcIlNpZGVzIGJ1aWxkaW5nLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuXG4gICAgICAgIHZhciBhbHRfbWluID0gLSB0aGlzLl9taW5fdGhpY2tuZXNzO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgZGlmZmVyZW50cyBzaWRlc1xuICAgICAgICB2YXIgZV9zaWRlID0gdGhpcy5fYnVpbGRTaWRlKFwiRWFzdCBTaWRlXCIsICB0aGlzLl9mcmFtZS5lYXN0LCAgYWx0X21pbiwgZmFsc2UpO1xuICAgICAgICB2YXIgd19zaWRlID0gdGhpcy5fYnVpbGRTaWRlKFwiV2VzdCBTaWRlXCIsICB0aGlzLl9mcmFtZS53ZXN0LCAgYWx0X21pbiwgdHJ1ZSApO1xuICAgICAgICB2YXIgbl9zaWRlID0gdGhpcy5fYnVpbGRTaWRlKFwiTm9ydGggU2lkZVwiLCB0aGlzLl9mcmFtZS5ub3J0aCwgYWx0X21pbiwgZmFsc2UpO1xuICAgICAgICB2YXIgc19zaWRlID0gdGhpcy5fYnVpbGRTaWRlKFwiU291dGggU2lkZVwiLCB0aGlzLl9mcmFtZS5zb3V0aCwgYWx0X21pbiwgdHJ1ZSApO1xuXG4gICAgICAgIC8vIFNldCBzaWRlcyBjb250YWluZXIgYXMgcGFyZW50IG9mIHNpZGVzXG4gICAgICAgIGVfc2lkZS5wYXJlbnQgPSB0aGlzLnNpZGVzO1xuICAgICAgICB3X3NpZGUucGFyZW50ID0gdGhpcy5zaWRlcztcbiAgICAgICAgbl9zaWRlLnBhcmVudCA9IHRoaXMuc2lkZXM7XG4gICAgICAgIHNfc2lkZS5wYXJlbnQgPSB0aGlzLnNpZGVzO1xuXG4gICAgICAgIC8vIFNpZGVzIGJ1aWx0ICFcbiAgICAgICAgY29uc29sZS5sb2coXCJTaWRlcyBidWlsdCAhIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uYnVpbGRCYXNlbWVudCgpIDogYnVpbGQgdGhlIGJhc2VtZW50IG9mIHRoZSBERU1cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLmJ1aWxkQmFzZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2VtZW50IGJ1aWxkaW5nLi4uXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQmFzZW1lbnQgYnVpbGRpbmcuLi4gXCIgKyAoRGF0ZS5ub3coKSAtIFJBTkRPLlNUQVJUX1RJTUUpICk7XG5cbiAgICAgICAgdmFyIEEgPSB7XG4gICAgICAgICAgICAneCcgOiB0aGlzLl9leHRlbnQueC5taW4sXG4gICAgICAgICAgICAneScgOiB0aGlzLl9leHRlbnQuei5taW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEIgPSB7XG4gICAgICAgICAgICAneCcgOiB0aGlzLl9leHRlbnQueC5tYXgsXG4gICAgICAgICAgICAneScgOiB0aGlzLl9leHRlbnQuei5taW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEMgPSB7XG4gICAgICAgICAgICAneCcgOiB0aGlzLl9leHRlbnQueC5tYXgsXG4gICAgICAgICAgICAneScgOiB0aGlzLl9leHRlbnQuei5tYXhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEQgPSB7XG4gICAgICAgICAgICAneCcgOiB0aGlzLl9leHRlbnQueC5taW4sXG4gICAgICAgICAgICAneScgOiB0aGlzLl9leHRlbnQuei5tYXhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJhc2VtZW50ID0gUkFORE8uVXRpbHMuY3JlYXRlR3JvdW5kRnJvbUV4dGVudCAoXG4gICAgICAgICAgICBcIkRFTSBCYXNlbWVudFwiLCBBLCBCLCBDLCBELCAxLCAxLCB0aGlzLl9zY2VuZVxuICAgICAgICApO1xuICAgICAgICBiYXNlbWVudC5tYXRlcmlhbCA9IG5ldyBCQUJZTE9OLlN0YW5kYXJkTWF0ZXJpYWwoXCJCYXNlbWVudCBNYXRlcmlhbFwiLCB0aGlzLl9zY2VuZSk7XG4gICAgICAgIGJhc2VtZW50Lm1hdGVyaWFsLmRpZmZ1c2VUZXh0dXJlID0gbmV3IEJBQllMT04uVGV4dHVyZShcbiAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTLlNJREVfVEVYX1VSTCxcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lXG4gICAgICAgICk7XG4gICAgICAgIGJhc2VtZW50LnBvc2l0aW9uLnkgLT0gdGhpcy5fbWluX3RoaWNrbmVzcztcblxuICAgICAgICAvLyBCYXNlbWVudCBidWlsdCAhXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQmFzZW1lbnQgYnVpbHQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLl9idWlsZFRpbGUoKSA6IGJ1aWxkIGEgdGlsZSBvZiB0aGUgREVNXG4gICAgICogICAgICAtIGRhdGEgOiBkYXRhIG9mIGEgdGlsZVxuICAgICAqXG4gICAgICogIHJldHVybiB0aGUgdGlsZSBtZXNoXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5fYnVpbGRUaWxlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHNjZW5lICAgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIGVuZ2luZSAgPSBzY2VuZS5nZXRFbmdpbmUoKTtcbiAgICAgICAgdmFyIHRoYXQgICAgPSB0aGlzO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgVGlsZVxuICAgICAgICB2YXIgdGlsZSA9IFJBTkRPLlV0aWxzLmNyZWF0ZUdyb3VuZEZyb21HcmlkKFxuICAgICAgICAgICAgXCJUaWxlXCIsXG4gICAgICAgICAgICBkYXRhLmdyaWQsXG4gICAgICAgICAgICBzY2VuZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlY29tcHV0ZXMgbm9ybWFscyBmb3IgbGlnaHRzIGFuZCBzaGFkb3dzXG4gICAgICAgIFJBTkRPLlV0aWxzLmNvbXB1dGVNZXNoTm9ybWFscyh0aWxlKVxuXG4gICAgICAgIC8vIFNldCBVdnMgZGF0YSBvZiB0aGUgdGlsZVxuICAgICAgICBSQU5ETy5VdGlscy5zZXRNZXNoVXZzKHRpbGUsIGRhdGEudXYpO1xuXG4gICAgICAgIC8vIEVuYWJsZXMgY29sbGlzaW9uc1xuICAgICAgICB0aWxlLmNoZWNrQ29sbGlzaW9ucyA9IHRydWU7XG5cbiAgICAgICAgLy8gTWF0ZXJpYWxcbiAgICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcIkRFTSAtIE1hdGVyaWFsXCIsIHNjZW5lKTtcbiAgICAgICAgbWF0ZXJpYWwud2lyZWZyYW1lID0gdHJ1ZTtcbiAgICAgICAgbWF0ZXJpYWwuYmFja0ZhY2VDdWxsaW5nID0gZmFsc2U7XG4gICAgICAgIHRpbGUubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5fYnVpbGRTaWRlKCkgOiBidWlsZCBhIHNpZGUgb2YgdGhlIERFTVxuICAgICAqICAgICAgLSBuYW1lOiBuYW1lIG9mIHRoZSBzaWRlXG4gICAgICogICAgICAtIGxpbmU6IEFycmF5IG9mIHBvaW50IGNvcnJlc3BvbmRpbmcgdG8gYSBib3JkZXIgb2YgdGhlIERFTVxuICAgICAqICAgICAgLSBhbHRfbWluOiBhbHRpdHVkZSBtaW5pbWFsZSBvZiB0aGUgREVNXG4gICAgICogICAgICAtIHJldmVyc2U6IEJvb2xlYW4sIGlmIHRydWUgcmV2ZXJzZSB0aGUgbGluZVxuICAgICAqXG4gICAgICogIHJldHVybiB0aGUgc2lkZSBtZXNoXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5fYnVpbGRTaWRlID0gZnVuY3Rpb24gKG5hbWUsIGxpbmUsIGFsdF9taW4sIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIHNjZW5lID0gdGhpcy5fc2NlbmU7XG5cbiAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgIGxpbmUucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBzaWRlXG4gICAgICAgIHZhciBzaWRlID0gUkFORE8uVXRpbHMuY3JlYXRlU2lkZUZyb21MaW5lKG5hbWUsIGxpbmUsIGFsdF9taW4sIHNjZW5lKTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlU2lkZVV2cyhzaWRlLCBsaW5lLCBhbHRfbWluKTtcblxuICAgICAgICAvLyBTaWRlIG1hdGVyaWFsXG4gICAgICAgIHNpZGUubWF0ZXJpYWwgPSBuZXcgQkFCWUxPTi5TdGFuZGFyZE1hdGVyaWFsKG5hbWUgKyBcIk1hdGVyaWFsXCIsIHNjZW5lKTtcbiAgICAgICAgc2lkZS5tYXRlcmlhbC5kaWZmdXNlVGV4dHVyZSA9IG5ldyBCQUJZTE9OLlRleHR1cmUoUkFORE8uU0VUVElOR1MuU0lERV9URVhfVVJMLCBzY2VuZSk7XG5cbiAgICAgICAgLy8gUmVjb21wdXRlcyBub3JtYWxzIGZvciBsaWdodHMgYW5kIHNoYWRvd3NcbiAgICAgICAgUkFORE8uVXRpbHMuY29tcHV0ZU1lc2hOb3JtYWxzKHNpZGUpO1xuXG4gICAgICAgIC8vIEVuYWJsZXMgY29sbGlzaW9uc1xuICAgICAgICBzaWRlLmNoZWNrQ29sbGlzaW9ucyA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHNpZGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5hcHBseVRleHR1cmVzKCkgOiBMb2FkIHRpbGUncyB0ZXh0dXJlcyBvdmVyIHRoZSBERU1cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLmFwcGx5VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGV4dHVyZXMgYXBwbGljYXRpb24gLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuXG4gICAgICAgIC8vfiAvLyBQcmVwYXJlIGFsbCB0ZXh0dXJlc1xuICAgICAgICAvL34gZm9yICh2YXIgaXQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIC8vfiB0aGlzLl9wcmVwYXJlVGV4dHVyZSh0aGlzLl90aWxlc1tpdF0uY29vcmRpbmF0ZXMpO1xuICAgICAgICAvL34gfVxuXG4gICAgICAgIHZhciBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuICAgICAgICB2YXIgbWVzaGVzID0gdGhpcy5ncm91bmQuZ2V0Q2hpbGRyZW4gKCk7XG4gICAgICAgIHZhciBmaW5hbFRleHR1cmVzID0gdGhpcy5fdGV4dHVyZXM7XG4gICAgICAgIHZhciBjaGVja2VkID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IGZpbmFsVGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiBmaW5hbFRleHR1cmVzKXtcbiAgICAgICAgICAgIGNoZWNrZWQucHVzaChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsb29wICgpe1xuICAgICAgICAgICAgdmFyIGl0ID0gMDtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IDUwO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXBwbHkgKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbnQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY250LS0gJiYgaXQgPCBmaW5hbFRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRbaXRdICYmIGZpbmFsVGV4dHVyZXNbaXRdLl90ZXh0dXJlLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRbaXRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIHdoZW4gaXQncyBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG1lc2hlc1tpdF0ubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5kaWZmdXNlVGV4dHVyZSA9IGZpbmFsVGV4dHVyZXNbaXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUud3JhcFUgPSBCQUJZTE9OLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5kaWZmdXNlVGV4dHVyZS53cmFwViA9IEJBQllMT04uVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXQgPCBmaW5hbFRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0IChhcHBseSwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCAobG9vcCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUZXh0dXJlcyBhcHBsaWVkICEgXCIgKyAoRGF0ZS5ub3coKSAtIFJBTkRPLlNUQVJUX1RJTUUpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9vcCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uX3ByZXBhcmVUZXh0dXJlKCkgOiBQcmVwYXJlIGEgdGlsZSBvZiB0ZXh0dXJlcyBmb3IgdGhlIERFTSBhbmQgYWRkXG4gICAgICogIGl0IHRvIHRoZSB0ZXh0dXJlcyBBcnJheS5cbiAgICAgKiAgICAgIC0gY29vcmRpbmF0ZXMgOiBjb29yZGluYXRlcyBvZiBhIHRpbGVcbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuX3ByZXBhcmVUZXh0dXJlID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuICAgICAgICB2YXIgZW5naW5lID0gc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIHZhciB1cmwgPSBSQU5ETy5VdGlscy5yZXBsYWNlVXJsQ29vcmRpbmF0ZXMoXG4gICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5USUxFX1RFWF9VUkwsXG4gICAgICAgICAgICBjb29yZGluYXRlcy56LFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueCxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMucHVzaChuZXcgQkFCWUxPTi5UZXh0dXJlKHVybCwgc2NlbmUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLl9jb21wdXRlU2lkZVV2cygpIDogQ29tcHV0ZXMgdXZzIHZhbHVlcyBvZiBhIHNpZGVcbiAgICAgKiAgICAgIC0gc2lkZSA6IHNpZGUgbWVzaFxuICAgICAqICAgICAgLSBsaW5lIDogbGluZSBvZiBhbHRpdHVkZXNcbiAgICAgKiAgICAgIC0gYWx0X21pbiA6IGl0IGlzIHRoZSBtaW5pbXVtIGFsdGl0dWRlIG9mIHRoZSBERU1cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLl9jb21wdXRlU2lkZVV2cyA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lLCBhbHRfbWluKSB7XG4gICAgICAgIHZhciBjVHlwZSA9ICd6JztcbiAgICAgICAgaWYgKGxpbmVbbGluZS5sZW5ndGgtMV0ueiAtIGxpbmVbMF0ueiA9PSAwKSB7XG4gICAgICAgICAgICBjVHlwZSA9ICd4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1ID0gW107XG4gICAgICAgIGZvciAodmFyIGl0IGluIGxpbmUpIHtcbiAgICAgICAgICAgIHUucHVzaChcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhsaW5lW2l0XVtjVHlwZV0gLSBsaW5lWzBdW2NUeXBlXSkgKlxuICAgICAgICAgICAgICAgIDEgLyAoTWF0aC5hYnMobGluZVtsaW5lLmxlbmd0aC0xXVtjVHlwZV0gLSBsaW5lWzBdW2NUeXBlXSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHV2ID0gW107XG4gICAgICAgIGZvciAodmFyIGl0IGluIHUpIHtcbiAgICAgICAgICAgIHV2LnB1c2godVtpdF0pOyAvLyB1IHZhbHVlXG4gICAgICAgICAgICB1di5wdXNoKChsaW5lW2l0XS55IC0gYWx0X21pbikvKHRoaXMuX2V4dGVudC55Lm1heCAtIGFsdF9taW4pKTsgLy8gdiB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGl0IGluIHUpIHtcbiAgICAgICAgICAgIHV2LnB1c2godVtpdF0pOyAvLyB1IHZhbHVlXG4gICAgICAgICAgICB1di5wdXNoKDApOyAvLyB2IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBzaWRlLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIHV2KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLmdldFJlYWxFeHRlbnQoKSA6IEdpdmUgdGhlIHJlYWwgZXh0ZW50IG9mIHRoZSBERU0sIGl0IG1lYW5zIHRoZVxuICAgICAqICBleHRlbnQgaW4gbWV0ZXJzIGluIHRoZSBvcmlnaW5hbCBwcm9qZWN0aW9uLlxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuZ2V0UmVhbEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHt9O1xuICAgICAgICBleHRlbnQueCA9IHt9O1xuICAgICAgICBleHRlbnQueSA9IHt9O1xuICAgICAgICBleHRlbnQueiA9IHt9O1xuICAgICAgICBleHRlbnQueC5taW4gPSB0aGlzLl9leHRlbnQueC5taW4gLSB0aGlzLl9vZmZzZXRzLng7XG4gICAgICAgIGV4dGVudC54Lm1heCA9IHRoaXMuX2V4dGVudC54Lm1heCAtIHRoaXMuX29mZnNldHMueDtcbiAgICAgICAgZXh0ZW50LnkubWluID0gdGhpcy5fZXh0ZW50LnkubWluO1xuICAgICAgICBleHRlbnQueS5tYXggPSB0aGlzLl9leHRlbnQueS5tYXg7XG4gICAgICAgIGV4dGVudC56Lm1pbiA9IHRoaXMuX2V4dGVudC56Lm1pbiAtIHRoaXMuX29mZnNldHMuejtcbiAgICAgICAgZXh0ZW50LnoubWF4ID0gdGhpcy5fZXh0ZW50LnoubWF4IC0gdGhpcy5fb2Zmc2V0cy56O1xuICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8pIHtcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgUkFORE8uRXZlbnRzID0ge307XG4gICAgLypcbiAgICAgKiBCaW5kIGFuZCBVbmJpbmQgZXZlbnRzXG4gICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8vIERPTSBMZXZlbCAyIEV2ZW50IG1vZGVsXG4gICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgUkFORE8uRXZlbnRzLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgUkFORE8uRXZlbnRzLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGZuKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUHJvcHJpZXRhcnkgbGVnYWN5IElFIE1vZGVsXG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgUkFORE8uRXZlbnRzLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGZuKSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGVsZW0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBib3VuZCk7XG4gICAgICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIFJBTkRPLkV2ZW50cy5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwib25cIiArIHR5cGUsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5Qb2kuanNcbiAqXG4gKiBQb2kgY2xhc3MgOlxuICogIFBlcm1pdGVzIHRoZSBidWlsZCBvZiBhIFBvaW50IG9mIEludGVyZXN0IGluIDNEXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uUG9pID0gZnVuY3Rpb24gKGlkLCBkYXRhLCBvZmZzZXRzLCBzY2VuZSkge1xuICAgICAgICB0aGlzLl9pZCAgICAgICAgICAgID0gaWRcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gICAgICA9IHtcbiAgICAgICAgICAgICd4JyA6IGRhdGEuY29vcmRpbmF0ZXMueCArIG9mZnNldHMueCxcbiAgICAgICAgICAgICd5JyA6IDAsXG4gICAgICAgICAgICAneicgOiBkYXRhLmNvb3JkaW5hdGVzLnogKyBvZmZzZXRzLnpcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbmFtZSAgICAgICAgICA9IGRhdGEucHJvcGVydGllcy5uYW1lO1xuICAgICAgICB0aGlzLl90eXBlICAgICAgICAgID0gZGF0YS5wcm9wZXJ0aWVzLnR5cGU7XG4gICAgICAgIHRoaXMuX2VsZXZhdGlvbiAgICAgPSBkYXRhLnByb3BlcnRpZXMuZWxldmF0aW9uO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiAgID0gZGF0YS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uIHx8IFJBTkRPLlNFVFRJTkdTLk5PX0RFU0NSSVBUSU9OX01FU1NBR0U7XG4gICAgICAgIHRoaXMuX3NjZW5lICAgICAgICAgPSBzY2VuZTtcblxuICAgICAgICB0aGlzLnBhbmVsICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5waWN0byAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc3BoZXJlICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdHRhY2hlZExpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfTtcblxuICAgIFJBTkRPLlBvaS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRQYW5lbCAoKTtcbiAgICAgICAgdGhpcy5fYnVpbGRTcGhlcmUgKCk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zY2VuZS5yZWdpc3RlckJlZm9yZVJlbmRlciggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fcmVnaXN0ZXJCZWZvcmVSZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5fYnVpbGRQYW5lbCgpIDogYnVpbGQgYSBQYW5lbCB3aXRoIGEgcGljdG8gd2hpY2ggZGVmaW5lcyB0aGUgdHlwZSBvZiBQT0lcbiAgICAgKi9cbiAgICBSQU5ETy5Qb2kucHJvdG90eXBlLl9idWlsZFBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NlbmUgICAgICAgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uICAgID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgIHZhciB0ZXh0ICAgICAgICA9IHRoaXMuX25hbWU7XG4gICAgICAgIHZhciBzcmMgICAgICAgICA9IFJBTkRPLlNFVFRJTkdTLlBJQ1RPX1BSRUZJWCArIHRoaXMuX3R5cGUucGljdG9ncmFtO1xuICAgICAgICB2YXIgaWQgICAgICAgICAgPSB0aGlzLl9pZDtcbiAgICAgICAgdmFyIGVsZXZhdGlvbiAgID0gdGhpcy5fZWxldmF0aW9uO1xuXG4gICAgICAgIC8vIFNpemUgb2YgcGFuZWwgKGluIHBpeGVsIGFuZCBpbiBtZXRlcnMpXG4gICAgICAgIHZhciBwYW5fc2l6ZSA9IHtcbiAgICAgICAgICAgIHB4OiB7XG4gICAgICAgICAgICAgICAgd2lkdGggOiA1MTIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogNTEyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbToge1xuICAgICAgICAgICAgICAgIHdpZHRoIDogUkFORE8uU0VUVElOR1MuUElDVE9fU0laRSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgOiBSQU5ETy5TRVRUSU5HUy5QSUNUT19TSVpFICsgMzBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2l6ZSBvZiB0aGUgcGljdG9ncmFtIChpbiBwaXhlbHMpXG4gICAgICAgIHZhciBwaWN0b19zaXplID0ge1xuICAgICAgICAgICAgd2lkdGggOiBwYW5fc2l6ZS5weC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA6IHBhbl9zaXplLnB4LmhlaWdodCAqIFJBTkRPLlNFVFRJTkdTLlBJQ1RPX1NJWkUgLyBwYW5fc2l6ZS5tLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEJ1aWxkaW5nIHBhbmVsIE1lc2hcbiAgICAgICAgdmFyIHBhbmVsID0gQkFCWUxPTi5NZXNoLkNyZWF0ZUdyb3VuZChcbiAgICAgICAgICAgIFwiUE9JIC0gUGFuZWxcIixcbiAgICAgICAgICAgIHBhbl9zaXplLm0ud2lkdGgsXG4gICAgICAgICAgICBwYW5fc2l6ZS5tLmhlaWdodCxcbiAgICAgICAgICAgIDIsIHNjZW5lXG4gICAgICAgICk7XG4gICAgICAgIHBhbmVsLmlkID0gaWQ7XG4gICAgICAgIHBhbmVsLnJvdGF0ZSAoQkFCWUxPTi5BeGlzLlgsIC1NYXRoLlBJLzIsIEJBQllMT04uU3BhY2UuTE9DQUwpO1xuICAgICAgICBwYW5lbC5wb3NpdGlvbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgcGFuZWwucG9zaXRpb24ueSA9IC0xMDAwO1xuICAgICAgICBwYW5lbC5wb3NpdGlvbi56ID0gcG9zaXRpb24uejtcbiAgICAgICAgcGFuZWwubWF0ZXJpYWwgPSBuZXcgQkFCWUxPTi5TdGFuZGFyZE1hdGVyaWFsKFwiUE9JIC0gUGFuZWwgLSBNYXRlcmlhbFwiLCBzY2VuZSk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcblxuICAgICAgICAvLyBQYW5lbCBUZXh0dXJlXG4gICAgICAgIHZhciBwYW5lbF90ZXggPSBuZXcgQkFCWUxPTi5EeW5hbWljVGV4dHVyZShcIlBPSSAtIFBhbmVsIC0gVGV4dHVyZVwiLCBwYW5fc2l6ZS5weC53aWR0aCwgc2NlbmUsIHRydWUpO1xuICAgICAgICBwYW5lbF90ZXguaGFzQWxwaGEgPSB0cnVlO1xuICAgICAgICBmaWxsUGFuZWxUZXh0dXJlKCk7XG5cbiAgICAgICAgLy8gQnVpbGRpbmcgcGljdG9ncmFtIENvbnRhaW5lclxuICAgICAgICB2YXIgcGljdG8gPSBCQUJZTE9OLk1lc2guQ3JlYXRlR3JvdW5kKFxuICAgICAgICAgICAgXCJQT0kgLSBQYW5lbFwiLFxuICAgICAgICAgICAgcGFuX3NpemUubS53aWR0aCxcbiAgICAgICAgICAgIHBhbl9zaXplLm0uaGVpZ2h0LFxuICAgICAgICAgICAgMiwgc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgcGljdG8uaWQgPSBpZDtcbiAgICAgICAgcGljdG8ubWF0ZXJpYWwgPSBuZXcgQkFCWUxPTi5TdGFuZGFyZE1hdGVyaWFsKFwiUE9JIC0gUGljdG8gLSBNYXRlcmlhbFwiLCBzY2VuZSk7XG4gICAgICAgIHBpY3RvLnJlbmRlcmluZ0dyb3VwSWQgPSAxO1xuICAgICAgICB0aGlzLnBpY3RvID0gcGljdG87XG4gICAgICAgIHBpY3RvLnBhcmVudCA9IHBhbmVsO1xuXG4gICAgICAgIC8vIFBpY3RvZ3JhbSBUZXh0dXJlXG4gICAgICAgIHZhciBwaWN0b190ZXggPSBuZXcgQkFCWUxPTi5EeW5hbWljVGV4dHVyZShcIlBPSSAtIFBpY3RvIC0gVGV4dHVyZVwiLCBwYW5fc2l6ZS5weC53aWR0aCwgc2NlbmUsIHRydWUpO1xuICAgICAgICBwaWN0b190ZXguaGFzQWxwaGEgPSB0cnVlO1xuICAgICAgICBmaWxsUGljdG9UZXh0dXJlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZmlsbFBpY3RvVGV4dHVyZSAoKSB7XG4gICAgICAgICAgICB2YXIgcGljdG9Db250ZXh0ID0gcGljdG9fdGV4LmdldENvbnRleHQoKTtcblxuICAgICAgICAgICAgLy8gTG9hZCB0aGUgcGljdG9ncmFtIG9uIHRoZSBwaWN0b2dyYW0gY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBpY3RvQ29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwaWN0b19zaXplLndpZHRoLCBwaWN0b19zaXplLmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgICAgICBwaWN0b0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHBpY3RvX3RleC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBwaWN0by5tYXRlcmlhbC5kaWZmdXNlVGV4dHVyZSA9IHBpY3RvX3RleDtcbiAgICAgICAgICAgICAgICBwaWN0by5tYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUgPSBwaWN0b190ZXg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBmaWxsUGFuZWxUZXh0dXJlICgpIHtcbiAgICAgICAgICAgIHZhciBwYW5lbENvbnRleHQgPSBwYW5lbF90ZXguZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICAvLyBEcmF3cyBiYWNrZ3JvdW5kIG9mIHRoZSBwaWN0b2dyYW0gb24gdGhlIHBhbmVsXG4gICAgICAgICAgICBwYW5lbENvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSlcIjtcbiAgICAgICAgICAgIFJBTkRPLlV0aWxzLnJvdW5kUmVjdChwYW5lbENvbnRleHQsIDAsIDAsIHBpY3RvX3NpemUud2lkdGgsIHBpY3RvX3NpemUuaGVpZ2h0LCBwYW5fc2l6ZS5weC53aWR0aC8xMCk7XG5cbiAgICAgICAgICAgIC8vIFNldCAmIGRyYXcgdGhlIHRleHQgb24gdGhlIHBhbmVsXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGVsZXZhdGlvbiArIFwibVwiO1xuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gKHBhbl9zaXplLnB4LmhlaWdodCAtIHBpY3RvX3NpemUuaGVpZ2h0KSAqIFJBTkRPLlNFVFRJTkdTLlBPSV9MQUJFTF9TQ0FMRSA7XG4gICAgICAgICAgICBwYW5lbENvbnRleHQuZm9udCA9IFwiYm9sZGVyIFwiICsgZm9udFNpemUgKyBcInB0IEFyaWFsXCI7XG4gICAgICAgICAgICBwYW5lbENvbnRleHQuZmlsbFN0eWxlID0gXCIjZmZmXCI7XG4gICAgICAgICAgICBwYW5lbENvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIHBhbmVsQ29udGV4dC5maWxsVGV4dCh0ZXh0LCBwYW5fc2l6ZS5weC53aWR0aC8yLCBwYW5fc2l6ZS5weC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHBhbmVsQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBwYW5lbF90ZXgudXBkYXRlKCk7XG4gICAgICAgICAgICBwYW5lbC5tYXRlcmlhbC5vcGFjaXR5VGV4dHVyZSAgID0gcGFuZWxfdGV4O1xuICAgICAgICAgICAgcGFuZWwubWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlICA9IHBhbmVsX3RleDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uUG9pLl9idWlsZFNwaGVyZSgpIDogYnVpbGQgYSBTcGhlcmUgd2hpY2ggd2lsbCBiZSBvbiB0aGUgcmVhbCBwb3NpdGlvblxuICAgICAqICBvZiB0aGUgUE9JIG9uIHRoZSBERU0uXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5fYnVpbGRTcGhlcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2VuZSAgICAgICA9IHRoaXMuX3NjZW5lO1xuICAgICAgICB2YXIgcG9zaXRpb24gICAgPSB0aGlzLl9wb3NpdGlvbjtcblxuICAgICAgICB2YXIgc3BoZXJlID0gQkFCWUxPTi5NZXNoLkNyZWF0ZVNwaGVyZShcbiAgICAgICAgICAgIFwiUE9JIC0gU3BoZXJlXCIsIDEwLCBSQU5ETy5TRVRUSU5HUy5QT0lfU0laRSwgc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgc3BoZXJlLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcbiAgICAgICAgICAgIFwiUE9JIC0gU3BoZXJlIC0gTWF0ZXJpYWxcIiwgc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgc3BoZXJlLm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG5ldyBCQUJZTE9OLkNvbG9yMygxLCAxLCAxKTtcbiAgICAgICAgc3BoZXJlLm1hdGVyaWFsLmVtaXNzaXZlQ29sb3IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMSwgMSwgMSk7XG4gICAgICAgIHRoaXMuc3BoZXJlID0gc3BoZXJlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5Qb2kuX3JlZ2lzdGVyQmVmb3JlUmVuZGVyKCkgOiBmdW5jdGlvbiB0byBjYWxsIGJlZm9yZSBlYWNoIHNjZW5lIHJlbmRlclxuICAgICAqL1xuICAgIFJBTkRPLlBvaS5wcm90b3R5cGUuX3JlZ2lzdGVyQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NlbmUgICAgICAgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIHBhbmVsICAgICAgID0gdGhpcy5wYW5lbDtcbiAgICAgICAgdmFyIHBpY3RvICAgICAgID0gdGhpcy5waWN0bztcblxuICAgICAgICAvLyBDb250cm9scyB2aXNpYmlsaXR5IGFjY29yZGluZyB0aGUgRGlzdGFuY2UgZnJvbSBjYW1lcmFcbiAgICAgICAgaWYgKEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZShwYW5lbC5wb3NpdGlvbiwgc2NlbmUuYWN0aXZlQ2FtZXJhLnBvc2l0aW9uKSA8IDMwMCkge1xuICAgICAgICAgICAgcGFuZWwuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBwaWN0by5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhbmVsLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBwaWN0by5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udHJvbHMgcGFuZWwgb3JpZW50YXRpb25cbiAgICAgICAgcGFuZWwubG9va0F0KHNjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbiwgMCwgLU1hdGguUEkvMiwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5kcmFwZSgpIDogZHJhcGUgdGhlIFBPSSBvdmVyIHRoZSBERU1cbiAgICAgKiAgICAgIC0gZ3JvdW5kIDogZ3JvdW5kIG9mIHRoZSBERU1cbiAgICAgKi9cbiAgICBSQU5ETy5Qb2kucHJvdG90eXBlLmRyYXBlID0gZnVuY3Rpb24gKGdyb3VuZCkge1xuICAgICAgICBSQU5ETy5VdGlscy5kcmFwZVBvaW50KHRoaXMucGFuZWwucG9zaXRpb24sIGdyb3VuZCwgUkFORE8uU0VUVElOR1MuUE9JX09GRlNFVCk7XG4gICAgICAgIHRoaXMuc3BoZXJlLnBvc2l0aW9uID0gdGhpcy5wYW5lbC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICB0aGlzLnNwaGVyZS5wb3NpdGlvbi55IC09IFJBTkRPLlNFVFRJTkdTLlBPSV9PRkZTRVQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5vbk1vdXNlRG93bkhhbmRsZXIoKSA6IGNhbGxiYWNrIHRvIHJ1biBpZiB0aGUgbW91c2UgaXMgZG93biBvdmVyIGEgcGljdG9cbiAgICAgKiAgICAgIC0gZXZ0OiBldmVudCBpbmZvcm1hdGlvbnNcbiAgICAgKi9cbiAgICBSQU5ETy5Qb2kucHJvdG90eXBlLm9uTW91c2VEb3duSGFuZGxlciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgalF1ZXJ5KCcucG9pLS1jbGlja2VkJykudGV4dCh0aGlzLl9uYW1lICsgJyAoJyArIHRoaXMuX2VsZXZhdGlvbiArICdtICknKTtcbiAgICAgICAgalF1ZXJ5KCcucG9pLS1jbGlja2VkJykuY3NzKCdsZWZ0JywgZXZ0LmNsaWVudFggLSAyMCArICdweCcpO1xuICAgICAgICBqUXVlcnkoJy5wb2ktLWNsaWNrZWQnKS5jc3MoJ3RvcCcsICBldnQuY2xpZW50WSAtIDQwICsgJ3B4Jyk7XG4gICAgICAgIGpRdWVyeSgnLnBvaS0tY2xpY2tlZCcpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICAgIGpRdWVyeSgnLnBvaV9zaWRlIGgyJykuaHRtbCh0aGlzLl9uYW1lICk7XG4gICAgICAgIGpRdWVyeSgnLnBvaV9zaWRlIC5kZXNjcmlwdGlvbicpLmh0bWwodGhpcy5fZGVzY3JpcHRpb24pO1xuICAgICAgICBqUXVlcnkoJy5wb2lfc2lkZScpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICAgIGpRdWVyeSgnLmludGVyZmFjZScpLmNzcygnd2lkdGgnLCAnODAlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5vbk1vdXNlT3ZlckhhbmRsZXIoKSA6IGNhbGxiYWNrIHRvIHJ1biBpZiB0aGUgbW91c2UgaXMgb3ZlciBhIHBpY3RvXG4gICAgICogICAgICAtIGV2dDogZXZlbnQgaW5mb3JtYXRpb25zXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5vbk1vdXNlT3ZlckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGpRdWVyeSgnLnBvaS0taG92ZXInKS50ZXh0KHRoaXMuX25hbWUgKyAnICgnICsgdGhpcy5fZWxldmF0aW9uICsgJ20gKScpO1xuICAgICAgICBqUXVlcnkoJy5wb2ktLWhvdmVyJykuY3NzKCdsZWZ0JywgZXZ0LmNsaWVudFggLSAyMCArICdweCcpO1xuICAgICAgICBqUXVlcnkoJy5wb2ktLWhvdmVyJykuY3NzKCd0b3AnLCAgZXZ0LmNsaWVudFkgLSA0MCArICdweCcpO1xuICAgICAgICBqUXVlcnkoJy5wb2ktLWhvdmVyJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cbiAgICAgICAgalF1ZXJ5KCcjY2FudmFzX3JlbmRlcmVyJylbMF0uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH07XG5cbiAgICAvKiogU3RhdGljXG4gICAgICogUkFORE8uUG9pLnJ1bk1vdXNlTGlzdGVuZXIoKSA6IFN0YXRpYyBmdW5jdGlvbiB3aGljaCBydW4gYWxsIG1vdXNlXG4gICAgICogIGxpc3RlbmVycyBsaW5rZWQgdG8gUE9Jcywgd2UgZ2l2ZSBpdCBhIFBPSSdzIGFycmF5IGFuZCBpdCBhZGRzXG4gICAgICogIG1vdXNlIGV2ZW50cyBvdmVyIGFsbCBpdHMgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAgICAgIC0gY2FudmFzIDogY2FudmFzIHdoZXJlIHRoZSBzY2VuZSBpc1xuICAgICAqICAgICAgLSBwb2lzIDogYXJyYXkgb2YgUE9Jc1xuICAgICAqICAgICAgLSBzY2VuZSA6IHNjZW5lXG4gICAgICovXG4gICAgUkFORE8uUG9pLnJ1bk1vdXNlTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2FudmFzLCBwb2lzLCBzY2VuZSkge1xuICAgICAgICB2YXIgY2xpY2tlZElEO1xuXG4gICAgICAgIC8vIE1vdXNlRG93biBFdmVudCA6IGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBvdmVyIGEgUGljdG8gd2hlbiBNb3VzZSBsZWZ0IGNsaWNrIGlzIGRvd25cbiAgICAgICAgUkFORE8uRXZlbnRzLmFkZEV2ZW50KHdpbmRvdywgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIHBpY2tSZXN1bHQgPSBzY2VuZS5waWNrIChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgICAgICAgICAgdmFyIHBpY2tlZE1lc2ggPSBwaWNrUmVzdWx0LnBpY2tlZE1lc2g7XG5cbiAgICAgICAgICAgIGpRdWVyeSgnLnBvaS0taG92ZXInKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgalF1ZXJ5KCcucG9pLS1jbGlja2VkJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIGNsaWNrZWRJRCA9IC0xO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgY2xpY2sgaGl0cyBhIHBpY3RvZ3JhbSwgd2UgZGlzcGxheSBpbmZvcm1hdGlvbnMgb2YgUE9JXG4gICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5oaXQgJiYgcGlja2VkTWVzaC5uYW1lID09IFwiUE9JIC0gUGFuZWxcIikge1xuICAgICAgICAgICAgICAgIHBvaXNbcGlja2VkTWVzaC5pZF0ub25Nb3VzZURvd25IYW5kbGVyKGV2dCk7XG4gICAgICAgICAgICAgICAgY2xpY2tlZElEID0gcGlja2VkTWVzaC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW91c2VNb3ZlIEV2ZW50IDogYWx3YXlzIGNoZWNrIGlmIG1vdXNlIGlzIG92ZXIgYSBQaWN0b1xuICAgICAgICBSQU5ETy5FdmVudHMuYWRkRXZlbnQod2luZG93LCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICB2YXIgcGlja1Jlc3VsdCA9IHNjZW5lLnBpY2sgKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgICAgICB2YXIgcGlja2VkTWVzaCA9IHBpY2tSZXN1bHQucGlja2VkTWVzaDtcblxuICAgICAgICAgICAgalF1ZXJ5KCcucG9pLS1ob3ZlcicpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICBqUXVlcnkoJyNjYW52YXNfcmVuZGVyZXInKVswXS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgICAgIC8vIGlmIG1vdXNlIGlzIG92ZXIgYSBwaWN0b2dyYW0sIHdlIGRpc3BsYXkgaW5mb3JtYXRpb25zIG9mIFBPSVxuICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuaGl0ICYmIHBpY2tlZE1lc2gubmFtZSA9PSBcIlBPSSAtIFBhbmVsXCJcbiAgICAgICAgICAgICAgICAmJiBjbGlja2VkSUQgIT0gcGlja2VkTWVzaC5pZCkge1xuICAgICAgICAgICAgICAgIHBvaXNbcGlja2VkTWVzaC5pZF0ub25Nb3VzZU92ZXJIYW5kbGVyKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENsb3NlIGJ1dHRvbiBldmVudHMgb2YgdGhlIFBPSSBzaWRlXG4gICAgICAgIGpRdWVyeShcIi5jbG9zZV9idG5cIikub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgalF1ZXJ5KFwiLnBvaV9zaWRlXCIpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICBqUXVlcnkoJy5pbnRlcmZhY2UnKS5jc3MoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGpRdWVyeShcIi5jbG9zZV9idG5cIikubW91c2VvdmVyKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHRoaXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9KTtcbiAgICAgICAgalF1ZXJ5KFwiLmNsb3NlX2J0blwiKS5tb3VzZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbn07IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLlNjZW5lLmpzXG4gKlxuICogU2NlbmUgY2xhc3MgOlxuICogIFBlcm1pdGVzIHRoZSBjcmVhdGlvbiBhbmQgbWFuaXB1bGF0aW9uIG9mIGEgc2NlbmUgM0QgY29udGFpbmluZyAob3Igbm90KSA6XG4gKiAgICAgIC0gYSBEaWdpdGFsIEVsZXZhdGlvbiBNb2RlbFxuICogICAgICAtIGEgVHJlayB3aGljaCBpcyBkcmFwZWQgb3ZlciB0aGUgREVNXG4gKiAgICAgIC0gYSBzZXQgb2YgUG9pbnRzIE9mIEludGVyZXN0IGRyYXBlZCBvdmVyIHRoZSBERU0gdG9vXG4gKiAgICAgIC0gYSBzZXQgb2YgQ2FtZXJhc1xuICogICAgICAtIGEgc2V0IG9mIGxpZ2h0c1xuICpcbiAqIEBhdXRob3I6IEPDqWxpYW4gR0FSQ0lBXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uU2NlbmUgPSBmdW5jdGlvbiAoY2FudmFzLCBjYW1lcmFJRCkge1xuICAgICAgICAvLyBBdHRyaWJ1dGVzIGRlY2xhcmF0aW9uXG4gICAgICAgIHRoaXMuX2NhbnZhcyAgICA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5fY2FtZXJhSUQgID0gY2FtZXJhSUQ7XG5cbiAgICAgICAgdGhpcy5fZW5naW5lICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2NlbmUgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW1Db250YWluZXIgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cyAgICAgPSB7fTtcbiAgICAgICAgdGhpcy5kZW0gICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmVrICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2lzICAgICAgID0gW107XG5cbiAgICAgICAgdGhpcy5fZGVtX2RhdGEgID0ge307XG4gICAgICAgIHRoaXMuX3RyZWtfZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9wb2lzX2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyAgID0ge307XG4gICAgfTtcblxuXG4gICAgLyogTWV0aG9kcyAqL1xuICAgIFJBTkRPLlNjZW5lLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSQU5ETy5TVEFSVF9USU1FID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5fZW5naW5lID0gbmV3IEJBQllMT04uRW5naW5lKHRoaXMuX2NhbnZhcywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NjZW5lICA9IG5ldyBCQUJZTE9OLlNjZW5lKHRoaXMuX2VuZ2luZSk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgUkFORE8uRXZlbnRzLmFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoYXQuX2VuZ2luZS5yZXNpemUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2NlbmUuY2xlYXJDb2xvciA9IG5ldyBCQUJZTE9OLkNvbG9yNCgwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5fc2NlbmUuY29sbGlzaW9uc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9idWlsZExpZ2h0cygpO1xuICAgICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uU2NlbmUucHJvY2VzcygpIDogbGF1bmNoIHRoZSBidWlsZGluZyBwcm9jZXNzIG9mIHRoZSBzY2VuZVxuICAgICAqICBJdCBkaXNwbGF5cyA6XG4gICAgICogICAgICAgICAgLSBUZXJyYWluXG4gICAgICogICAgICAgICAgLSBUcmVrXG4gICAgICogICAgICAgICAgLSBQT0lzXG4gICAgICovXG4gICAgUkFORE8uU2NlbmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICBqUXVlcnkuZ2V0SlNPTihSQU5ETy5TRVRUSU5HUy5ERU1fVVJMKVxuICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuX3BhcnNlRGVtSnNvbihkYXRhKTtcbiAgICAgICAgICAgIHRoYXQuX2J1aWxkQ2FtZXJhcygpO1xuICAgICAgICAgfSlcbiAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0SlNPTihSQU5ETy5TRVRUSU5HUy5QUk9GSUxFX1VSTCk7XG4gICAgICAgICB9KVxuICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuX3BhcnNlVHJla0pzb24oZGF0YSk7XG4gICAgICAgICB9KVxuICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXRKU09OKFJBTkRPLlNFVFRJTkdTLlBPSV9VUkwpO1xuICAgICAgICAgfSlcbiAgICAgICAgIC5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGF0Ll9wYXJzZVBvaUpzb24oZGF0YSk7XG5cbiAgICAgICAgIH0pXG4gICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSdW4gcmVuZGVybG9vcFxuICAgICAgICAgICAgdGhhdC5fZW5naW5lLnJ1blJlbmRlckxvb3AoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2NlbmUucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVGlsZWQgREVNIG1lc2ggYnVpbGRpbmdcbiAgICAgICAgICAgIHRoYXQuZGVtID0gbmV3IFJBTkRPLkRlbShcbiAgICAgICAgICAgICAgICB0aGF0Ll9kZW1fZGF0YS5leHRlbnQsXG4gICAgICAgICAgICAgICAgdGhhdC5fZGVtX2RhdGEuYWx0aXR1ZGVzLFxuICAgICAgICAgICAgICAgIHRoYXQuX29mZnNldHMsXG4gICAgICAgICAgICAgICAgdGhhdC5fc2NlbmVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFRyZWsgYnVpbGRpbmdcbiAgICAgICAgICAgIHRoYXQudHJlayA9IG5ldyBSQU5ETy5UcmVrICAoXG4gICAgICAgICAgICAgICAgdGhhdC5fdHJla19kYXRhLFxuICAgICAgICAgICAgICAgIHRoYXQuX29mZnNldHMsXG4gICAgICAgICAgICAgICAgdGhhdC5fc2NlbmVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFBPSXMgYnVpbGRpbmdcbiAgICAgICAgICAgIHZhciBpZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGF0Ll9wb2lzX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkFORE8uVXRpbHMuaXNJbkV4dGVudCh0aGF0Ll9wb2lzX2RhdGFbaXRdLmNvb3JkaW5hdGVzLCB0aGF0LmRlbS5nZXRSZWFsRXh0ZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucG9pcy5wdXNoKG5ldyBSQU5ETy5Qb2koXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcG9pc19kYXRhW2l0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX29mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zY2VuZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSQU5ETy5Qb2kucnVuTW91c2VMaXN0ZW5lcih0aGF0Ll9jYW52YXMsIHRoYXQucG9pcywgdGhhdC5fc2NlbmUpO1xuXG4gICAgICAgICAgICAvLyBUbyBleGVjdXRlIHdoZW4gc2NlbmUgaXMgcmVhZHlcbiAgICAgICAgICAgIHRoYXQuX3NjZW5lLmV4ZWN1dGVXaGVuUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2V4ZWN1dGVXaGVuUmVhZHkgKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9idWlsZENhbWVyYXMoKSA6IGJ1aWxkcyBjYW1lcmFzIG9mIHRoZSBzY2VuZVxuICAgICAqXG4gICAgICogIElmIHRoZSBjYW1lcmEgSUQgaXMgbm90IGF2YWlsYWJsZSwgaXQgaXMgY2hhbmdlZCB0byBcImRlbW9fY2FtZXJhXCJcbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX2J1aWxkQ2FtZXJhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyYW1ldGVycyBmb3IgdGhlIENhbWVyYSBDb250YWluZXJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICdkZW1DZW50ZXInIDogdGhpcy5fZGVtX2RhdGEuY2VudGVyLFxuICAgICAgICAgICAgJ29mZnNldHMnICAgOiB0aGlzLl9vZmZzZXRzLFxuICAgICAgICAgICAgJ2RlbUV4dGVudCcgOiB0aGlzLl9kZW1fZGF0YS5leHRlbnQsXG4gICAgICAgICAgICAnZGVtQWx0aXR1ZGVzJzogdGhpcy5fZGVtX2RhdGEuYWx0aXR1ZGVzLFxuICAgICAgICAgICAgJ3N3aXRjaEVuYWJsZWQnIDogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBjb250YWluZXJcbiAgICAgICAgdGhpcy5jYW1Db250YWluZXIgPSBuZXcgUkFORE8uQ2FtZXJhQ29udGFpbmVyKHRoaXMuX2NhbnZhcywgdGhpcy5fc2NlbmUsIHBhcmFtcyk7XG5cbiAgICAgICAgLy8gQ29udHJvbCBjYW1lcmEgSUQgZW50ZXJlZCAoZXhhbWluZV9jYW1lcmEgYnkgZGVmYXVsdCkuLi5cbiAgICAgICAgaWYgKCFqUXVlcnkuaW5BcnJheSh0aGlzLl9jYW1lcmFJRCwgUkFORE8uQ2FtZXJhSURzKSlcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYUlEID0gXCJleGFtaW5lXCI7XG5cbiAgICAgICAgLy8gLi4uYW5kIHNldCBpdCBhcyBhY3RpdmVcbiAgICAgICAgdGhpcy5jYW1Db250YWluZXIuc2V0QWN0aXZlQ2FtZXJhICh0aGlzLl9jYW1lcmFJRCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9idWlsZExpZ2h0cygpIDogYnVpbGRzIHRoZSBkaWZmZXJlbnRzIGxpZ2h0cyBvZiB0aGUgc2NlbmVcbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX2J1aWxkTGlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLl9zY2VuZTtcblxuICAgICAgICAvLyBTdW5cbiAgICAgICAgdGhpcy5saWdodHMuc3VuID0gbGlnaHQgKFxuICAgICAgICAgICAgXCJTdW5cIiwgbmV3IEJBQllMT04uVmVjdG9yMygtNTAwLCAtMTAwMDAsIDApLCAxLjJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTaWRlIExpZ2h0IDFcbiAgICAgICAgdGhpcy5saWdodHMuc2lkZUxpZ2h0MSA9IGxpZ2h0IChcbiAgICAgICAgICAgIFwiU2lkZSBMaWdodCAxXCIsIG5ldyBCQUJZTE9OLlZlY3RvcjMoMSwgMCwgMC44KSwgMS4yXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU2lkZSBMaWdodCAyXG4gICAgICAgIHRoaXMubGlnaHRzLnNpZGVMaWdodDIgPSBsaWdodCAoXG4gICAgICAgICAgICBcIlNpZGUgTGlnaHQgMlwiLCBuZXcgQkFCWUxPTi5WZWN0b3IzKC0xLCAwLCAtMC44KSwgMS4yXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbGlnaHQoKSA6IHJldHVybiBhIGRpcmVjdGlvbmFsIGxpZ2h0XG4gICAgICAgIGZ1bmN0aW9uIGxpZ2h0IChuYW1lLCBkaXJlY3Rpb24sIGludGVuc2l0eSkge1xuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IEJBQllMT04uRGlyZWN0aW9uYWxMaWdodChcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBzY2VuZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpZ2h0LmludGVuc2l0eSA9IGludGVuc2l0eTtcbiAgICAgICAgICAgIGxpZ2h0LnNwZWN1bGFyID0gbmV3IEJBQllMT04uQ29sb3I0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9leGVjdXRlV2hlblJlYWR5KCkgOiBmdW5jdGlvbiB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBzY2VuZVxuICAgICAqICBpcyByZWFkeSwgaW4gb3RoZXIgd29yZHMsIHdoZW4gdGhlIHNjZW5lIGhhdmUgYnVpbHQgYWxsIGl0cyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX2V4ZWN1dGVXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2NlbmUgaXMgcmVhZHkgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICB2YXIgdHJlayAgICAgICAgICAgID0gdGhpcy50cmVrO1xuICAgICAgICB2YXIgY2FtQ29udGFpbmVyICAgID0gdGhpcy5jYW1Db250YWluZXI7XG4gICAgICAgIHZhciBsaWdodHMgICAgICAgICAgPSB0aGlzLmxpZ2h0cztcblxuICAgICAgICAvLyBJbml0IHNpZGVsaWdodHMgZXhjbHVkZWQgbWVzaGVzIGFycmF5cyB3aXRoIHRoZSB0aWxlc1xuICAgICAgICBsaWdodHMuc2lkZUxpZ2h0MS5leGNsdWRlZE1lc2hlcyA9IHRoaXMuZGVtLmdyb3VuZC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBsaWdodHMuc2lkZUxpZ2h0Mi5leGNsdWRlZE1lc2hlcyA9IHRoaXMuZGVtLmdyb3VuZC5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIC8vIEFwcGx5IERFTSB0ZXh0dXJlc1xuICAgICAgICB0aGlzLmRlbS5hcHBseVRleHR1cmVzKCk7XG5cbiAgICAgICAgLy8gRHJhcGUgdGhlIHRyZWsgd2l0aCBhbiBvbkNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgIHRyZWsuZHJhcGUodGhpcy5kZW0uZ3JvdW5kLCBvbkRyYXBlQ29tcGxldGUpO1xuXG4gICAgICAgIC8vIERyYXBlIFBPSVNcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGhpcy5wb2lzKSB7XG4gICAgICAgICAgICB0aGlzLnBvaXNbaXRdLmRyYXBlKHRoaXMuZGVtLmdyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkRyYXBlQ29tcGxldGUgKCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlcyB0cmVrIHZlcnRpY2VzIC4uLlxuICAgICAgICAgICAgdHJlay51cGRhdGVWZXJ0aWNlcygpO1xuXG4gICAgICAgICAgICAvLyAuLi4gdG8gZ2l2ZSB0aGVtIHRvIHRoZSBjYW1lcmEgY29udGFpbmVyIChmb3IgaGlrZXIgY2FtZXJhKVxuICAgICAgICAgICAgY2FtQ29udGFpbmVyLnNldEFuaW1hdGlvblBhdGgodHJlay5fdmVydGljZXMpO1xuXG4gICAgICAgICAgICAvLyBNZXJnZXMgdGhlIHRyZWsgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VzXG4gICAgICAgICAgICB0cmVrLm1lcmdlKCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBleGNsdWRlZCBtZXNoZXMgb2YgbGlnaHRzXG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UobGlnaHRzLnNpZGVMaWdodDEuZXhjbHVkZWRNZXNoZXMsIHRyZWsubWVyZ2VkVHJla3MpO1xuICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKGxpZ2h0cy5zaWRlTGlnaHQyLmV4Y2x1ZGVkTWVzaGVzLCB0cmVrLm1lcmdlZFRyZWtzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5TY2VuZS5fcGFyc2VEZW1Kc29uKCkgOiBwYXJzZSBkYXRhIGZyb20gdGhlIERFTSBqc29uXG4gICAgICogICAgICAtIGRhdGEgOiBkYXRhIGZyb20gREVNIGpzb25cbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX3BhcnNlRGVtSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIENvbnZlcnNpb25zXG4gICAgICAgIHZhciBtX2NlbnRlciA9IFJBTkRPLlV0aWxzLnRvTWV0ZXJzKGRhdGEuY2VudGVyKTtcbiAgICAgICAgdmFyIG1fZXh0ZW50ID0gUkFORE8uVXRpbHMuZ2V0TWV0ZXJzRXh0ZW50IChkYXRhLmV4dGVudCk7XG5cbiAgICAgICAgLy8gUmVjb3JkIERFTSBleHRlbnRcbiAgICAgICAgdGhpcy5fZGVtX2RhdGEuZXh0ZW50ID0gbV9leHRlbnQ7XG4gICAgICAgIHRoaXMuX2RlbV9kYXRhLmV4dGVudC55Lm1pbiAqPSBSQU5ETy5TRVRUSU5HUy5BTFRJVFVERVNfWl9TQ0FMRTtcbiAgICAgICAgdGhpcy5fZGVtX2RhdGEuZXh0ZW50LnkubWF4ICo9IFJBTkRPLlNFVFRJTkdTLkFMVElUVURFU19aX1NDQUxFO1xuXG4gICAgICAgIC8vIFJlY29yZCBERU0gYWx0aXR1ZGVzIHNjYWxlZFxuICAgICAgICB0aGlzLl9kZW1fZGF0YS5hbHRpdHVkZXMgPSBSQU5ETy5VdGlscy5zY2FsZUFycmF5MihcbiAgICAgICAgICAgIGRhdGEuYWx0aXR1ZGVzLFxuICAgICAgICAgICAgUkFORE8uU0VUVElOR1MuQUxUSVRVREVTX1pfU0NBTEVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSZWNvcmQgREVNIGNlbnRlclxuICAgICAgICB0aGlzLl9kZW1fZGF0YS5jZW50ZXIgPSB7XG4gICAgICAgICAgICAneCcgOiBtX2NlbnRlci54LFxuICAgICAgICAgICAgJ3knIDogKHRoaXMuX2RlbV9kYXRhLmV4dGVudC55Lm1pbiArIHRoaXMuX2RlbV9kYXRhLmV4dGVudC55Lm1heCkgLyAyLFxuICAgICAgICAgICAgJ3onIDogbV9jZW50ZXIueVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlY29yZHMgc2NlbmUgb2Zmc2V0c1xuICAgICAgICB0aGlzLl9vZmZzZXRzLnggPSAtbV9jZW50ZXIueDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cy56ID0gLW1fY2VudGVyLnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9wYXJzZVRyZWtKc29uKCkgOiBwYXJzZSBkYXRhIGZyb20gdGhlIFRyZWsgcHJvZmlsZSBqc29uXG4gICAgICogICAgICAtIGRhdGEgOiBkYXRhIGZyb20gVHJlayBwcm9maWxlIGpzb25cbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX3BhcnNlVHJla0pzb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgIGZvciAodmFyIGl0IGluIGRhdGEucHJvZmlsZSl7XG4gICAgICAgICAgICB2YXIgdG1wID0ge1xuICAgICAgICAgICAgICAgICdsbmcnIDogZGF0YS5wcm9maWxlW2l0XVsyXVswXSxcbiAgICAgICAgICAgICAgICAnbGF0JyA6IGRhdGEucHJvZmlsZVtpdF1bMl1bMV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFdlIHRha2Ugb25seSB4IGFuZCB6IHZhbHVlcyAobm90IHRoZSBhbHRpdHVkZXMpXG4gICAgICAgICAgICB0bXAgPSBSQU5ETy5VdGlscy50b01ldGVycyh0bXApO1xuXG4gICAgICAgICAgICAvLyB0b01ldGVycygpIGdpdmUgeC15LWNvb3JkaW5hdGVzIGFuZCBiYWJ5bG9uIHRha2UgeC16LWNvb3JkaW5hdGVzXG4gICAgICAgICAgICB0bXAueiA9IHRtcC55O1xuICAgICAgICAgICAgZGVsZXRlIHRtcFtcInlcIl07XG5cbiAgICAgICAgICAgIC8vIFJlY29yZFxuICAgICAgICAgICAgdGhpcy5fdHJla19kYXRhLnB1c2godG1wKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5TY2VuZS5fcGFyc2VQb2lKc29uKCkgOiBwYXJzZSBkYXRhIGZyb20gdGhlIFBPSSBqc29uXG4gICAgICogICAgICAtIGRhdGEgOiBkYXRhIGZyb20gUE9JIGpzb25cbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX3BhcnNlUG9pSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGl0IGluIGRhdGEuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZGF0YS5mZWF0dXJlc1tpdF07XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnNpb25cbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IFJBTkRPLlV0aWxzLnRvTWV0ZXJzKHtcbiAgICAgICAgICAgICAgICAnbG5nJyA6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICAgICAgJ2xhdCcgOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjb3JkXG4gICAgICAgICAgICB0aGlzLl9wb2lzX2RhdGEucHVzaCAoe1xuICAgICAgICAgICAgICAgICdjb29yZGluYXRlcycgOiB7XG4gICAgICAgICAgICAgICAgICAgICd4JzogY29vcmRpbmF0ZXMueCxcbiAgICAgICAgICAgICAgICAgICAgJ3onOiBjb29yZGluYXRlcy55XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcycgOiBmZWF0dXJlLnByb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07IiwiLy8gUmFuZG8uU2V0dGluZ3MuanNcbi8vIEdlbmVyYWwgc2V0dGluZ3NcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuICAgIFJBTkRPLlNFVFRJTkdTID0ge307XG5cbiAgICAvLyBMaW5rc1xuICAgIFJBTkRPLlNFVFRJTkdTLklNQUdFU19GT0xERVIgPSAnJztcbiAgICBSQU5ETy5TRVRUSU5HUy5ERU1fVVJMID0gJyc7IC8vIFVybCBvZiB0aGUgREVNIGpzb25cbiAgICBSQU5ETy5TRVRUSU5HUy5QUk9GSUxFX1VSTCA9ICcnOyAvLyBVcmwgb2YgdGhlIHRyZWsncyBwcm9maWxlIGpzb25cbiAgICBSQU5ETy5TRVRUSU5HUy5USUxFX1RFWF9VUkwgPSAnJzsgLy8gVXJsIG9mIGEgdGlsZSB0ZXh0dXJlXG4gICAgUkFORE8uU0VUVElOR1MuU0lERV9URVhfVVJMID0gJyc7IC8vIFVybCBvZiB0aGUgc2lkZSB0ZXh0dXJlXG4gICAgUkFORE8uU0VUVElOR1MuVElMRV9URVhfVVJMX1NVQkRPTUFJTlMgPSBbJ2EnLCAnYicsICdjJ107XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgLy8gQ2FtZXJhXG4gICAgUkFORE8uU0VUVElOR1MuQ0FNX09GRlNFVCA9IDIwMDsgLy8gQ2FtZXJhJ3MgYWx0aXR1ZGUgb2Zmc2V0IChpbiBtZXRlcnMpXG5cbiAgICBSQU5ETy5TRVRUSU5HUy5IQ0FNX0ZPTExPV19TUEVFRCA9IDE1OyAvLyBIaWtlckNhbWVyYSBzcGVlZCB3aGVuIGl0IGZvbGxvd3MgdHJla1xuICAgIFJBTkRPLlNFVFRJTkdTLkhDQU1fUkVUVVJOX1NQRUVEID0gMTUwMDsgLy8gSGlrZXJDYW1lcmEgc3BlZWQgd2hlbiBpdCBjb21lcyBiYWNrIHRvIGRlZmF1bHRcbiAgICBSQU5ETy5TRVRUSU5HUy5DQU1fU1BFRURfRiA9IDUwOyAgLy8gQ2FtZXJhIHNwZWVkIGluIEZseWluZyBtb2RlKGZyb20gMCB0byBpbmZpbml0eSAhKVxuICAgIFJBTkRPLlNFVFRJTkdTLkNPTExJU0lPTlNfT0ZGU0VUID0gMTUwO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICAgIC8vIEdlb21ldHJ5XG4gICAgUkFORE8uU0VUVElOR1MuQUxUSVRVREVTX1pfU0NBTEUgPSAxLjQ7XG4gICAgUkFORE8uU0VUVElOR1MuTElNSVRfVkVSVF9CWV9NRVNIID0gNjU1MzY7XG4gICAgUkFORE8uU0VUVElOR1MuVFJFS19TUEhfVEVTU0VMID0gNTtcbiAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX0NZTF9URVNTRUwgPSAyMDtcbiAgICBSQU5ETy5TRVRUSU5HUy5NSU5fVEhJQ0tORVNTID0gMjAwOyAvLyBNaW5pbXVtIHRoaWNrbmVzcyBvZiB0aGUgREVNXG4gICAgUkFORE8uU0VUVElOR1MuVFJFS19PRkZTRVQgPSAyOyAvLyBUcmVrJ3MgYWx0aXR1ZGUgb2Zmc2V0IChpbiBtZXRlcnMpXG5cbiAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX0NPTE9SID0gbmV3IEJBQllMT04uQ29sb3IzKDAuMSwgMC42LCAwLjIpOyAvLyBUcmVrIGNvbG9yIChncmVlbilcbiAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBCQUJZTE9OLkNvbG9yMygwLjEsMC42LDAuMik7IC8vIGdyZWVuXG4gICAgICAgICAgICAgICAgICAgICAvLyBuZXcgQkFCWUxPTi5Db2xvcjMoMC44LDAsMC4yKTsgLy8gZnVzY2hpYVxuICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IEJBQllMT04uQ29sb3IzKDAuOSwwLjUsMCk7IC8vIG9yYW5nZVxuXG4gICAgUkFORE8uU0VUVElOR1MuVFJFS19XSURUSCA9IDEwOyAvLyBUcmVrIHdpZHRoIChpbiBtZXRlcnMpXG5cbiAgICBSQU5ETy5TRVRUSU5HUy5USUxFX1pPT00gPSAxNztcbiAgICBSQU5ETy5TRVRUSU5HUy5USUxFX05VTUJFUl9MSU1JVCA9IDIwMDtcblxuICAgIFJBTkRPLlNFVFRJTkdTLlBPSV9PRkZTRVQgPSAxMDA7XG4gICAgUkFORE8uU0VUVElOR1MuUE9JX0ZPUk0xID0ge1xuICAgICAgICBvYmplY3ROYW1lIDogJycgLFxuICAgICAgICBmb2xkZXI6ICdibGVuZGVyLycsXG4gICAgICAgIGZpbGVOYW1lOiAncG9pLmJhYnlsb24nXG4gICAgfTtcbiAgICBSQU5ETy5TRVRUSU5HUy5QT0lfU0laRSA9IDIwO1xuICAgIFJBTkRPLlNFVFRJTkdTLlBPSV9MQUJFTF9TQ0FMRSA9IDE7XG4gICAgUkFORE8uU0VUVElOR1MuUElDVE9fU0laRSA9IDEwMDtcbiAgICBSQU5ETy5TRVRUSU5HUy5QSUNUT19QUkVGSVggPSAnJztcblxuICAgIFJBTkRPLlNFVFRJTkdTLk5PX0RFU0NSSVBUSU9OX01FU1NBR0UgPSAnPHA+UGFzIGRlIGRlc2NyaXB0aW9uIGxpw6llIMOgIGNlIHBvaW50IGRcXCdpbnTDqXLDqnQuPC9wPic7XG4gICAgUkFORE8uU0VUVElOR1MuQ0FNRVJBX01FU1NBR0VTID0ge1xuICAgICAgICAnYmlyZCcgOiAnT24gcGV1dCBzdXJ2b2xlciBsZSB0ZXJyYWluIHRlbCB1biBvaXNlYXUsIHRvdXJuZXIgbGEgdMOqdGUsIG1vbnRlciwgZGVzY2VuZHJlIGV0IHNlIGTDqXBsYWNlciAhJyxcbiAgICAgICAgJ2V4YW1pbmUnIDogJ09uIHBldXQgZXhhbWluZXIgbGUgdGVycmFpbiBlbiBsZSB0b3VybmFudCBkYW5zIHRvdXMgbGVzIHNlbnMuJyxcbiAgICAgICAgJ2hpa2VyJyA6ICdJY2kgb24gZXN0IGRhbnMgbGEgcGVhdSBkXFwndW4gcmFuZG9ubmV1ciwgb24gc3VpdCBzYW5zIGVmZm9ydCBsXFwnYXZhbmNlbWVudCBkZSBsXFwnaXRpbsOpcmFpcmUsIGVuIHByb2ZpdGFudCBkZSBsYSB2dWUuJ1xuICAgIH07XG5cbiAgICByZXR1cm4gUkFORE87XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLlRpbGVDb250YWluZXIuanNcbiAqXG4gKiBUaWxlQ29udGFpbmVyIGNsYXNzIDpcbiAqICBDb250YWlucyBhbGwgZGF0YSBmb3IgdGhlIGJ1aWxkIG9mIGEgdGlsZWQgRGlnaXRhbCBFbGV2YXRpb24gTW9kZWxcbiAqXG4gKiBAYXV0aG9yOiBDw6lsaWFuIEdBUkNJQVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUkFORE8pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChleHRlbnQsIGFsdGl0dWRlcywgb2Zmc2V0cykge1xuICAgICAgICAvKiBBdHRyaWJ1dGVzIGRlY2xhcmF0aW9uICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IF8uY2xvbmUoZXh0ZW50KTtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGVzID0gXy5jbG9uZShhbHRpdHVkZXMpO1xuICAgICAgICB0aGlzLl9vZmZzZXRzID0gXy5jbG9uZShvZmZzZXRzKTtcbiAgICAgICAgdGhpcy5fZ3JpZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbGVzID0ge307XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH07XG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlVGlsZXMoKTtcbiAgICAgICAgdGhpcy5fam9pblRpbGVzKCk7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVTaXplKCk7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVVdnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci5fZ2VuZXJhdGVUaWxlcygpIDogZ2VuZXJhdGVzIGFuIGFycmF5IG9mIHRpbGVzIHdoaWNoIGFyZSBqcyBvYmplY3RzXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuX2dlbmVyYXRlVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB6b29tID0gUkFORE8uU0VUVElOR1MuVElMRV9aT09NO1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl90aWxlcztcbiAgICAgICAgdmFyIGNvbCwgcm93O1xuXG4gICAgICAgIHRoaXMuX2dyaWQgPSBSQU5ETy5VdGlscy5jcmVhdGVFbGV2YXRpb25HcmlkKFxuICAgICAgICAgICAgdGhpcy5fZXh0ZW50LngubWluLFxuICAgICAgICAgICAgdGhpcy5fZXh0ZW50LngubWF4LFxuICAgICAgICAgICAgdGhpcy5fZXh0ZW50LnoubWluLFxuICAgICAgICAgICAgdGhpcy5fZXh0ZW50LnoubWF4LFxuICAgICAgICAgICAgdGhpcy5fYWx0aXR1ZGVzXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuXG4gICAgICAgIHZhciBjdXJyX2luZGV4LCAgcHJldl9pbmRleCAgPSBudWxsLFxuICAgICAgICAgICAgY3Vycl9wb2ludCwgIHByZXZfcG9pbnQgID0gbnVsbCxcbiAgICAgICAgICAgIGN1cnJfdGlsZV9uLCBwcmV2X3RpbGVfbiA9IG51bGwsXG4gICAgICAgICAgICBsaW5lX3RtcCA9IFtdLFxuICAgICAgICAgICAgbmV3X2xpbmUgPSB0cnVlO1xuXG4gICAgICAgIC8vIFN1YmRpdmlkZSBncmlkIGluIHRpbGVzXG4gICAgICAgIGZvciAocm93IGluIGdyaWQpIHtcbiAgICAgICAgICAgIGZvciAoY29sIGluIGdyaWRbcm93XSkge1xuICAgICAgICAgICAgICAgIGN1cnJfcG9pbnQgPSBncmlkW3Jvd11bY29sXTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IHRpbGUgbnVtYmVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICBjdXJyX3RpbGVfbiA9IFJBTkRPLlV0aWxzLm1ldGVyczJudW0oY3Vycl9wb2ludC54LCBjdXJyX3BvaW50LnosIHpvb20pO1xuICAgICAgICAgICAgICAgIGN1cnJfaW5kZXggPSBcIlwiICsgem9vbSArIFwiL1wiICsgY3Vycl90aWxlX24ueHRpbGUgKyBcIi9cIiArIGN1cnJfdGlsZV9uLnl0aWxlO1xuXG4gICAgICAgICAgICAgICAgLy8gdGlsZXNbXCJ6L3gveVwiXSBleGlzdHMgb3Igbm90XG4gICAgICAgICAgICAgICAgdGlsZXNbY3Vycl9pbmRleF0gPSB0aWxlc1tjdXJyX2luZGV4XSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGlsZXNbY3Vycl9pbmRleF0pLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgdGlsZXNbY3Vycl9pbmRleF0uZ3JpZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aWxlc1tjdXJyX2luZGV4XS5jb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IHpvb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJyX3RpbGVfbi54dGlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN1cnJfdGlsZV9uLnl0aWxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBpbmRleCBleGlzdHMgYW5kIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgICAgICAgICAgaWYgKCBwcmV2X2luZGV4ICE9IG51bGwgJiYgcHJldl9pbmRleCAhPSBjdXJyX2luZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlc1twcmV2X2luZGV4XS5ncmlkLnB1c2gobGluZV90bXApOyAvLyBwdXNoIHRoZSBsaW5lIGludG8gcHJldmlvdXMgdGlsZVxuICAgICAgICAgICAgICAgICAgICBsaW5lX3RtcCA9IFtdOyAvLyByZXNldCB0aGUgbGluZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmVfdG1wLnB1c2goXy5jbG9uZShjdXJyX3BvaW50KSk7XG5cbiAgICAgICAgICAgICAgICBwcmV2X2luZGV4ID0gY3Vycl9pbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2X3BvaW50ID0gY3Vycl9wb2ludDtcbiAgICAgICAgICAgICAgICBuZXdfbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByZXZfdGlsZV9uID0gY3Vycl90aWxlX247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdfbGluZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXNoIHRoZSBsYXN0IGxpbmUgb2YgdGhlIGxhc3QgdGlsZVxuICAgICAgICB0aWxlc1tjdXJyX2luZGV4XS5ncmlkLnB1c2gobGluZV90bXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5UaWxlQ29udGFpbmVyLl9qb2luVGlsZXMoKSA6IGpvaW5zIHRpbGVzIGRhdGFcbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5fam9pblRpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl90aWxlcztcbiAgICAgICAgdmFyIGNvbCwgcm93LCBpdDtcblxuICAgICAgICAvLyBKb2lucyBFYXN0IGFuZCBXZXN0IHNpZGVzIG9mIHRpbGVzXG4gICAgICAgIGZvciAoaXQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50X3RpbGUgPSB0aWxlc1tpdF07XG4gICAgICAgICAgICB2YXIgbmV4dF9jb29yZCA9IHtcbiAgICAgICAgICAgICAgICB6OiBjdXJyZW50X3RpbGUuY29vcmRpbmF0ZXMueixcbiAgICAgICAgICAgICAgICB4OiBjdXJyZW50X3RpbGUuY29vcmRpbmF0ZXMueCArIDEsXG4gICAgICAgICAgICAgICAgeTogY3VycmVudF90aWxlLmNvb3JkaW5hdGVzLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbmV4dF9pbmRleCA9IFwiXCIgICsgbmV4dF9jb29yZC56ICsgXCIvXCIgKyBuZXh0X2Nvb3JkLnggKyBcIi9cIiArIG5leHRfY29vcmQueSArIFwiXCI7XG5cbiAgICAgICAgICAgIC8vIGlmIG5leHQgdGlsZSBleGlzdFxuICAgICAgICAgICAgaWYgKHRpbGVzW25leHRfaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfZ3JpZCA9IGN1cnJlbnRfdGlsZS5ncmlkO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X2dyaWQgPSB0aWxlc1tuZXh0X2luZGV4XS5ncmlkO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggcm93IGluIHRoZSBjdXJyZW50IHRpbGUgZ3JpZFxuICAgICAgICAgICAgICAgIGZvciAocm93IGluIGN1cnJlbnRfZ3JpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldl9wb2ludCA9IGN1cnJlbnRfZ3JpZFtyb3ddW2N1cnJlbnRfZ3JpZFtyb3ddLmxlbmd0aC0xXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRfcG9pbnQgPSBuZXh0X2dyaWRbcm93XVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IFJBTkRPLlV0aWxzLm1pZGRsZShwcmV2X3BvaW50LCBuZXh0X3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ncmlkW3Jvd10ucHVzaChtaWQpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0X2dyaWRbcm93XS5zcGxpY2UoMCwgMCwgXy5jbG9uZShtaWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKb2lucyBOb3J0aCBhbmQgU291dGggc2lkZXMgb2YgdGlsZXNcbiAgICAgICAgZm9yIChpdCBpbiB0aWxlcykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfdGlsZSA9IF8uY2xvbmUodGlsZXNbaXRdKTtcbiAgICAgICAgICAgIHZhciBuZXh0X2Nvb3JkID0ge1xuICAgICAgICAgICAgICAgIHo6IGN1cnJlbnRfdGlsZS5jb29yZGluYXRlcy56LFxuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRfdGlsZS5jb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgIHk6IGN1cnJlbnRfdGlsZS5jb29yZGluYXRlcy55ICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBuZXh0X2luZGV4ID0gXCJcIiAgKyBuZXh0X2Nvb3JkLnogKyBcIi9cIiArIG5leHRfY29vcmQueCArIFwiL1wiICsgbmV4dF9jb29yZC55ICsgXCJcIjtcblxuICAgICAgICAgICAgaWYgKHRpbGVzW25leHRfaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfdGlsZSA9IHRpbGVzW25leHRfaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgbGluZSBvZiBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgICB2YXIgcHJldl9saW5lID0gXy5jbG9uZShjdXJyZW50X3RpbGUuZ3JpZFswXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBMYXN0IGxpbmUgb2YgbmV4dCB0aWxlXG4gICAgICAgICAgICAgICAgdmFyIG5leHRfbGluZSA9IF8uY2xvbmUobmV4dF90aWxlLmdyaWRbbmV4dF90aWxlLmdyaWQubGVuZ3RoLTFdKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBsaW5lIHBsYWNlZCBvbiB0aGUgbWlkZGxlIG9mIHRoZSBib3RoIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0d28gdmFyaWFibGVzIHRvIHN0b3JlIHRoaXMgbGluZVxuICAgICAgICAgICAgICAgIHZhciBtZWRfbGluZTEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbWVkX2xpbmUyID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHByZXZfbGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gUkFORE8uVXRpbHMubWlkZGxlKHByZXZfbGluZVtpXSwgbmV4dF9saW5lW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgbWVkX2xpbmUxLnB1c2goXy5jbG9uZShtaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbWVkX2xpbmUyLnB1c2goXy5jbG9uZShtaWQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJtZWRpYW4gbGluZVwiIGdvIHRvIHRoZSBzb3V0aCBvZiBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgICBjdXJyZW50X3RpbGUuZ3JpZC5zcGxpY2UoMCwgMCwgbWVkX2xpbmUxKTtcbiAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIHRvIHRoZSBub3J0aCBvZiBuZXh0IHRpbGVcbiAgICAgICAgICAgICAgICBuZXh0X3RpbGUuZ3JpZC5wdXNoKG1lZF9saW5lMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci5fY29tcHV0ZVNpemUoKSA6IGNvbXB1dGVzIGhlaWdodCBhbmQgd2lkdGggb2YgZWFjaCB0aWxlIGFuZCBhZGQgaXQgdG8gdGhlIHRpbGVzIGRhdGEgY29udGFpbmVyXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuX2NvbXB1dGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl90aWxlcztcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGlsZXNbaXRdO1xuICAgICAgICAgICAgdmFyIGdyaWQgPSB0aWxlLmdyaWQ7XG4gICAgICAgICAgICB2YXIgbiA9IGdyaWQubGVuZ3RoLTE7XG4gICAgICAgICAgICB2YXIgbSA9IGdyaWRbMF0ubGVuZ3RoLTE7XG4gICAgICAgICAgICB0aWxlLnNpemUgPSB7XG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6IGdyaWRbMF1bbV0ueCAtIGdyaWRbMF1bMF0ueCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogZ3JpZFtuXVswXS56IC0gZ3JpZFswXVswXS56XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRpbGVDb250YWluZXIuX2NvbXB1dGVVdnMoKSA6ICBjb21wdXRlcyB1diB2YWx1ZXMgb2YgZWFjaCB0aWxlIGFuZCBhZGQgaXQgdG8gdGhlIHRpbGVzIGRhdGEgY29udGFpbmVyXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuX2NvbXB1dGVVdnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuXG4gICAgICAgIHZhciBtYXhfd2lkdGggPSBfLm1heCh0aWxlcywgZnVuY3Rpb24odGlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLnNpemUud2lkdGg7XG4gICAgICAgIH0pLnNpemUud2lkdGg7XG5cbiAgICAgICAgdmFyIG1heF9oZWlnaHQgPSBfLm1heCh0aWxlcywgZnVuY3Rpb24odGlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlLnNpemUuaGVpZ2h0O1xuICAgICAgICB9KS5zaXplLmhlaWdodDtcblxuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnRJblRpbGVzQ29vcmRpbmF0ZXMoKTtcblxuICAgICAgICAvLyBGaWxsIHRoZSB1diBkYXRhIG9mIHRpbGVzXG4gICAgICAgIGZvciAodmFyIGl0IGluIHRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2l0XTtcbiAgICAgICAgICAgIHRpbGUudXYgPSB7fTtcblxuICAgICAgICAgICAgLy8gRmlsbCB1IGFycmF5XG4gICAgICAgICAgICBpZiAodGlsZS5jb29yZGluYXRlcy54ID09IGV4dGVudC54Lm1pbikgeyAvLyBFYXN0IHRpbGVzXG4gICAgICAgICAgICAgICAgdGlsZS51di51ID0gdVZhbHVlcyh0aWxlLCBtYXhfd2lkdGgsIFwiZWFzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbGUuY29vcmRpbmF0ZXMueCA9PSBleHRlbnQueC5tYXgpIHsgLy8gV2VzdCB0aWxlc1xuICAgICAgICAgICAgICAgIHRpbGUudXYudSA9IHVWYWx1ZXModGlsZSwgbWF4X3dpZHRoLCBcIndlc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gSW50ZXJpb3IgdGlsZXNcbiAgICAgICAgICAgICAgICB0aWxlLnV2LnUgPSB1VmFsdWVzKHRpbGUsIHRpbGUuc2l6ZS53aWR0aCwgXCJub3JtYWxcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgdiBhcnJheVxuICAgICAgICAgICAgaWYgKHRpbGUuY29vcmRpbmF0ZXMueSA9PSBleHRlbnQueS5taW4pIHsgLy8gTm9ydGggdGlsZXNcbiAgICAgICAgICAgICAgICB0aWxlLnV2LnYgPSB2VmFsdWVzKHRpbGUsIG1heF9oZWlnaHQsIFwibm9ydGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aWxlLmNvb3JkaW5hdGVzLnkgPT0gZXh0ZW50LnkubWF4KSB7IC8vIFNvdXRoIHRpbGVzXG4gICAgICAgICAgICAgICAgdGlsZS51di52ID0gdlZhbHVlcyh0aWxlLCBtYXhfaGVpZ2h0LCBcInNvdXRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIEludGVyaW9yIHRpbGVzXG4gICAgICAgICAgICAgICAgdGlsZS51di52ID0gdlZhbHVlcyh0aWxlLCB0aWxlLnNpemUuaGVpZ2h0LCBcIm5vcm1hbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVWYWx1ZXModGlsZSwgd2lkdGgsIHN0cmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RyaW5nKSA9PT0gJ3VuZGVmaW5lZCcpIHN0cmluZyA9IFwibm9ybWFsXCI7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICAgICAgICBzdHJpbmcgPT0gXCJlYXN0XCIgfHwgc3RyaW5nID09IFwibm9ybWFsXCIgfHwgc3RyaW5nID09IFwid2VzdFwiLFxuICAgICAgICAgICAgICAgIFwidVZhbHVlcygpIGZ1bmN0aW9uIHVuY29ycmVjdGx5IHVzZWRcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHN0cmluZyA9PSBcIndlc3RcIikge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IFwibm9ybWFsXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gdGlsZS5ncmlkWzBdLmxlbmd0aC0xO1xuICAgICAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZWFzdFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB1W25dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gbi0xOyBjb2wgPj0gMDsgY29sLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcnRfeCA9IHRpbGUuZ3JpZFswXVtjb2xdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnh0X3ggPSB0aWxlLmdyaWRbMF1bY29sKzFdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB1W2NvbF0gPSB1W2NvbCsxXSAtIChNYXRoLmFicyhueHRfeCAtIGNydF94KS93aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB1WzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMTsgY29sIDw9IG47IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3J0X3ggPSB0aWxlLmdyaWRbMF1bY29sXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBydl94ID0gdGlsZS5ncmlkWzBdW2NvbC0xXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdVtjb2xdID0gdVtjb2wtMV0gKyAoTWF0aC5hYnMocHJ2X3ggLSBjcnRfeCkvd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdlZhbHVlcyh0aWxlLCBoZWlnaHQsIHN0cmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoc3RyaW5nKSA9PT0gJ3VuZGVmaW5lZCcpIHN0cmluZyA9IFwibm9ybWFsXCI7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgICAgICAgICBzdHJpbmcgPT0gXCJzb3V0aFwiIHx8IHN0cmluZyA9PSBcIm5vcm1hbFwiIHx8IHN0cmluZyA9PSBcIm5vcnRoXCIsXG4gICAgICAgICAgICAgICAgXCJ1VmFsdWVzKCkgZnVuY3Rpb24gdW5jb3JyZWN0bHkgdXNlZFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoc3RyaW5nID09IFwibm9ydGhcIikge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IFwibm9ybWFsXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtID0gdGlsZS5ncmlkLmxlbmd0aC0xO1xuICAgICAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic291dGhcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdlttXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IG0tMTsgcm93ID49IDA7IHJvdy0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3J0X3ogPSB0aWxlLmdyaWRbcm93XVswXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG54dF96ID0gdGlsZS5ncmlkW3JvdysxXVswXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgdltyb3ddID0gdltyb3crMV0gLSAoTWF0aC5hYnMobnh0X3ogLSBjcnRfeikvaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2WzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMTsgcm93IDw9IG07IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3J0X3ogPSB0aWxlLmdyaWRbcm93XVswXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBydl96ID0gdGlsZS5ncmlkW3Jvdy0xXVswXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgdltyb3ddID0gdltyb3ctMV0gKyAoTWF0aC5hYnMocHJ2X3ogLSBjcnRfeikvaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRpbGVDb250YWluZXIudHJhbnNsYXRlKCkgOiB0cmFuc2xhdGUgdGhlIFRpbGVzIGRhdGEgb2YgdGhlIG9mZnNldHMgYXR0cmlidXRlIG9yIG9mXG4gICAgICogdGhlIG9mZnNldHMgZ2l2ZW4gaW4gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIFJBTkRPLlRpbGVDb250YWluZXIucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHksIGR6KSB7XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IHt9O1xuICAgICAgICB2YXIgY29sLCByb3c7XG5cbiAgICAgICAgaWYgKHR5cGVvZihkeCkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgb2Zmc2V0cy54ID0gdGhpcy5fb2Zmc2V0cy54O1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXRzLnggPSBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoZHkpID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIG9mZnNldHMueSA9IHRoaXMuX29mZnNldHMueTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0cy55ID0gZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGR6KSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICBvZmZzZXRzLnogPSB0aGlzLl9vZmZzZXRzLno7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIG9mZnNldHMueiA9IGR6O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhbnNsYXRlcyB0aGUgdGlsZXMgcG9zaXRpb25zIG9mIHRoZSBvZmZzZXRzXG4gICAgICAgIGZvciAodmFyIGl0IGluIHRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRpbGVzW2l0XS5ncmlkO1xuICAgICAgICAgICAgZm9yIChyb3cgaW4gZ3JpZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29sIGluIGdyaWRbcm93XSkge1xuICAgICAgICAgICAgICAgICAgICBncmlkW3Jvd11bY29sXS54ICs9IG9mZnNldHMueDtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0ueiArPSBvZmZzZXRzLno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRpbGVDb250YWluZXIuZ2V0RnJhbWUoKSA6IGdldCB0aGUgZnJhbWUgb2YgdGhlIERFTSBjb21wb3NlZCBieSA0IGxpbmVzXG4gICAgICogIGVhc3QsIHdlc3QsIG5vcnRoLCBhbmQgc291dGguXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IHt9O1xuICAgICAgICBmcmFtZS5lYXN0ICA9IFtdO1xuICAgICAgICBmcmFtZS53ZXN0ICA9IFtdO1xuICAgICAgICBmcmFtZS5ub3J0aCA9IFtdO1xuICAgICAgICBmcmFtZS5zb3V0aCA9IFtdO1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl90aWxlcztcbiAgICAgICAgdmFyIGNvbCwgcm93O1xuXG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudEluVGlsZXNDb29yZGluYXRlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGl0IGluIHRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2l0XTtcbiAgICAgICAgICAgIGlmICggdGlsZS5jb29yZGluYXRlcy54ID09IGV4dGVudC54Lm1heCApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdF9jb2wgPSB0aWxlLmdyaWRbMF0ubGVuZ3RoIC0xO1xuICAgICAgICAgICAgICAgIGZvciAocm93IGluIHRpbGUuZ3JpZCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5lYXN0LnB1c2godGlsZS5ncmlkW3Jvd11bbGFzdF9jb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRpbGUuY29vcmRpbmF0ZXMueCA9PSBleHRlbnQueC5taW4gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0X2NvbCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChyb3cgaW4gdGlsZS5ncmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLndlc3QucHVzaCh0aWxlLmdyaWRbcm93XVtmaXJzdF9jb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRpbGUuY29vcmRpbmF0ZXMueSA9PSBleHRlbnQueS5taW4gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3Rfcm93ID0gdGlsZS5ncmlkLmxlbmd0aC0xO1xuICAgICAgICAgICAgICAgIGZvciAoY29sIGluIHRpbGUuZ3JpZFtsYXN0X3Jvd10pe1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5zb3V0aC5wdXNoKHRpbGUuZ3JpZFtsYXN0X3Jvd11bY29sXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB0aWxlLmNvb3JkaW5hdGVzLnkgPT0gZXh0ZW50LnkubWF4ICkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdF9yb3cgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29sIGluIHRpbGUuZ3JpZFtmaXJzdF9yb3ddKXtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUubm9ydGgucHVzaCh0aWxlLmdyaWRbZmlyc3Rfcm93XVtjb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRpbGVDb250YWluZXIuZ2V0RXh0ZW50SW5UaWxlc0Nvb3JkaW5hdGVzKCkgOiBnZXQgdGhlIHggYW5kIHkgZXh0ZW50IGluIHRpbGUnc1xuICAgICAqIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUuZ2V0RXh0ZW50SW5UaWxlc0Nvb3JkaW5hdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlsZUV4dGVudCA9IHt9O1xuICAgICAgICB0aWxlRXh0ZW50LnggPSB7fTtcbiAgICAgICAgdGlsZUV4dGVudC55ID0ge307XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuXG4gICAgICAgIC8vIFggZXh0ZW50XG4gICAgICAgIHRpbGVFeHRlbnQueC5taW4gPSBfLm1pbih0aWxlcywgZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWxlLmNvb3JkaW5hdGVzLng7XG4gICAgICAgIH0pLmNvb3JkaW5hdGVzLng7XG5cbiAgICAgICAgdGlsZUV4dGVudC54Lm1heCA9IF8ubWF4KHRpbGVzLCBmdW5jdGlvbiAodGlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbGUuY29vcmRpbmF0ZXMueDtcbiAgICAgICAgfSkuY29vcmRpbmF0ZXMueDtcblxuICAgICAgICAvLyBZIGV4dGVudFxuICAgICAgICB0aWxlRXh0ZW50LnkubWluID0gXy5taW4odGlsZXMsIGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlsZS5jb29yZGluYXRlcy55O1xuICAgICAgICB9KS5jb29yZGluYXRlcy55O1xuICAgICAgICB0aWxlRXh0ZW50LnkubWF4ID0gXy5tYXgodGlsZXMsIGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlsZS5jb29yZGluYXRlcy55O1xuICAgICAgICB9KS5jb29yZGluYXRlcy55O1xuXG4gICAgICAgIHJldHVybiB0aWxlRXh0ZW50O1xuICAgIH07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5UcmVrLmpzXG4gKlxuICogVHJlayBjbGFzcyA6XG4gKiAgUGVybWl0ZXMgdGhlIGJ1aWxkIG9mIGEgVHJlayBpbiAzRFxuICpcbiAqIEBhdXRob3I6IEPDqWxpYW4gR0FSQ0lBXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFJBTkRPLCBCQUJZTE9OKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG5cbiAgICAvKiBDb25zdHJ1Y3RvciAqL1xuICAgIFJBTkRPLlRyZWsgPSBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0cywgc2NlbmUpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB0aGlzLl9wcmVwYXJlVmVydGljZXMoZGF0YSwgb2Zmc2V0cyk7XG4gICAgICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG5cbiAgICAgICAgdGhpcy5zcGhlcmVzICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuY3lsaW5kZXJzICAgPSBudWxsO1xuICAgICAgICB0aGlzLm1hdGVyaWFsICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZWRUcmVrcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH07XG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uVHJlay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBCQUJZTE9OLlN0YW5kYXJkTWF0ZXJpYWwoXCJUcmVrIE1hdGVyaWFsXCIsIHRoaXMuX3NjZW5lKVxuICAgICAgICB0aGlzLm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IFJBTkRPLlNFVFRJTkdTLlRSRUtfQ09MT1I7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZW1pc3NpdmVDb2xvciA9IFJBTkRPLlNFVFRJTkdTLlRSRUtfQ09MT1I7XG5cbiAgICAgICAgdGhpcy5idWlsZFRyZWsgKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRyZWsuX3ByZXBhcmVWZXJ0aWNlcygpIDogdHJhbnNsYXRlIHRoZSBUcmVrIGRhdGEgb2YgdGhlIG9mZnNldHMgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiByZXR1cm4gdGhlIGFycmF5IG9mIHZlcnRpY2VzXG4gICAgICovXG4gICAgUkFORE8uVHJlay5wcm90b3R5cGUuX3ByZXBhcmVWZXJ0aWNlcyA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXRzKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IF8ubWFwKGRhdGEsIF8uY2xvbmUpO1xuXG4gICAgICAgIGZvciAodmFyIGl0IGluIHZlcnRpY2VzKXtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS54ICs9IG9mZnNldHMueDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS55ID0gMDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS56ICs9IG9mZnNldHMuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRyZWsuYnVpbGRUcmVrKCkgOiBidWlsZHMgdGhlIHRyZWsgd2l0aCBzcGhlcmVzIGFuZCBjeWxpbmRlcnNcbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5idWlsZFRyZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRyZWsgYnVpbGRpbmcgLi4uXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJlayBidWlsZGluZy4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICAgICAgdmFyIHZlcnRpY2VzICAgID0gdGhpcy5fdmVydGljZXM7XG4gICAgICAgIHZhciBzY2VuZSAgICAgICA9IHRoaXMuX3NjZW5lO1xuICAgICAgICB2YXIgbWF0ZXJpYWwgICAgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgICB2YXIgc3BoZXJlcyAgICAgPSBuZXcgQkFCWUxPTi5NZXNoKFwiVFJFSyAtIFNwaGVyZXNcIiwgc2NlbmUpO1xuICAgICAgICB2YXIgY3lsaW5kZXJzICAgPSBuZXcgQkFCWUxPTi5NZXNoKFwiVFJFSyAtIEN5bGluZGVyc1wiLCBzY2VuZSk7XG4gICAgICAgIHZhciBuX3NwaCA9IDAsIG5fY3lsID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTcGhlcmUodmVydGV4KSB7XG4gICAgICAgICAgICBuX3NwaCsrO1xuICAgICAgICAgICAgdmFyIHNwaGVyZSA9IEJBQllMT04uTWVzaC5DcmVhdGVTcGhlcmUoXG4gICAgICAgICAgICAgICAgXCJTcGhlcmUgXCIgKyBuX3NwaCxcbiAgICAgICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX1NQSF9URVNTRUwsXG4gICAgICAgICAgICAgICAgUkFORE8uU0VUVElOR1MuVFJFS19XSURUSCxcbiAgICAgICAgICAgICAgICBzY2VuZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgc3BoZXJlLnBvc2l0aW9uICA9IHZlcnRleDtcbiAgICAgICAgICAgIHNwaGVyZS5tYXRlcmlhbCAgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIHNwaGVyZS5wYXJlbnQgICAgPSBzcGhlcmVzO1xuICAgICAgICAgICAgc3BoZXJlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUN5bGluZGVyKHZlcnRleEEsIHZlcnRleEIpIHtcbiAgICAgICAgICAgIG5fY3lsKys7XG4gICAgICAgICAgICB2YXIgY3lsX2hlaWdodCA9IEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZSh2ZXJ0ZXhBLCB2ZXJ0ZXhCKTtcbiAgICAgICAgICAgIHZhciBjeWxpbmRlciA9IEJBQllMT04uTWVzaC5DcmVhdGVDeWxpbmRlcihcbiAgICAgICAgICAgICAgICBcIkN5bGluZGVyIFwiICsgbl9jeWwsXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX1dJRFRILFxuICAgICAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTLlRSRUtfV0lEVEgsXG4gICAgICAgICAgICAgICAgUkFORE8uU0VUVElOR1MuVFJFS19DWUxfVEVTU0VMLFxuICAgICAgICAgICAgICAgIHNjZW5lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjeWxpbmRlci5tYXRlcmlhbCAgID0gbWF0ZXJpYWw7XG4gICAgICAgICAgICBjeWxpbmRlci5wYXJlbnQgICAgID0gY3lsaW5kZXJzO1xuICAgICAgICAgICAgY3lsaW5kZXIuaXNWaXNpYmxlICA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwcmV2LCBjdXJyID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdmVydGljZXMpe1xuICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICB2YXIgY3VyciA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaXRdLngsXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaXRdLnksXG4gICAgICAgICAgICAgICAgdmVydGljZXNbaXRdLnpcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNyZWF0ZVNwaGVyZShjdXJyKTtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ3lsaW5kZXIocHJldiwgY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmVrIGJ1aWx0ICFcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmVrIGJ1aWx0ICEgXCIgKyAoRGF0ZS5ub3coKSAtIFJBTkRPLlNUQVJUX1RJTUUpICk7XG5cbiAgICAgICAgdGhpcy5zcGhlcmVzID0gc3BoZXJlcztcbiAgICAgICAgdGhpcy5jeWxpbmRlcnMgPSBjeWxpbmRlcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRyZWsuZHJhcGUoKSA6IGRyYXBlIHRoZSB0cmVrIG92ZXIgdGhlIGdyb3VuZFxuICAgICAqICAgICAgLSBncm91bmQgOiBNZXNoIGluIHdoaWNoIHdlIGRyYXBlIHNwaGVyZXNcbiAgICAgKiAgICAgIC0gb25Db21wbGV0ZSA6IGNhbGxiYWNrIGNhbGxlZCBhdCB0aGUgZW5kIG9mIHRoZSBSQU5ETy5UcmVrLnByb3RvdHlwZS5cbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5kcmFwZSA9IGZ1bmN0aW9uIChncm91bmQsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIHNwaGVyZXMgICAgID0gdGhpcy5zcGhlcmVzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBjeWxpbmRlcnMgICA9IHRoaXMuY3lsaW5kZXJzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciB0cmVrX2xlbmd0aCA9IHNwaGVyZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggICAgICAgPSAwO1xuICAgICAgICB2YXIgY2h1bmsgICAgICAgPSAxMDA7IC8vIEJ5IGNodW5rcyBvZiAxMDAgcG9pbnRzXG4gICAgICAgIHZhciB0aGF0ICAgICAgICA9IHRoaXM7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJUcmVrIGFkanVzdG1lbnRzIC4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICAgICAgZHJhcGVDaHVuaygpO1xuXG4gICAgICAgIC8vIFN0ZXAgMSA6IGRyYXBlIHRoZSBzcGhlcmVzIG92ZXIgdGhlIGdyb3VuZFxuICAgICAgICBmdW5jdGlvbiBkcmFwZUNodW5rICgpIHtcbiAgICAgICAgICAgIHZhciBjbnQgPSBjaHVuaztcbiAgICAgICAgICAgIHdoaWxlIChjbnQtLSAmJiBpbmRleCA8IHRyZWtfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgUkFORE8uVXRpbHMuZHJhcGVQb2ludChzcGhlcmVzW2luZGV4XS5wb3NpdGlvbiwgZ3JvdW5kLCBSQU5ETy5TRVRUSU5HUy5UUkVLX09GRlNFVCk7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRyZWtfbGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRyYXBlQ2h1bmssIDEpO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBlbmQgb2YgZHJhcGluZyB3ZSBwbGFjZSBjeWxpbmRlcnNcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHBsYWNlQ3lsaW5kZXJzLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdGVwIDIgOiBQbGFjZSBhbGwgY3lsaW5kZXJzIGJldHdlZW4gZWFjaCBwYWlycyBvZiBzcGhlcmVzXG4gICAgICAgIGZ1bmN0aW9uIHBsYWNlQ3lsaW5kZXJzICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJla19sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgUkFORE8uVXRpbHMucGxhY2VDeWxpbmRlcihcbiAgICAgICAgICAgICAgICAgICAgY3lsaW5kZXJzW2ldLFxuICAgICAgICAgICAgICAgICAgICBzcGhlcmVzW2ldLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzcGhlcmVzW2krMV0ucG9zaXRpb25cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyZWsgYWRqdXN0ZWQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay5tZXJnZSgpIDogbWVyZ2UgYWxsIGVsZW1lbnRzIChzcGhlcmVzIGFuZCBjeWxpbmRlcnMpIG9mIHRoZSBUcmVrXG4gICAgICovXG4gICAgUkFORE8uVHJlay5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJlayBtZXJnaW5nIC4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICAgICAgdmFyIHNjZW5lICAgICAgID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIHZhciBzcGhlcmVzICAgICA9IHRoaXMuc3BoZXJlcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICB2YXIgY3lsaW5kZXJzICAgPSB0aGlzLmN5bGluZGVycy5nZXRDaGlsZHJlbigpO1xuICAgICAgICB2YXIgbWVzaGVzICAgICAgPSBzcGhlcmVzLmNvbmNhdChjeWxpbmRlcnMpO1xuICAgICAgICB2YXIgbGltaXQgICAgICAgPSBSQU5ETy5TRVRUSU5HUy5MSU1JVF9WRVJUX0JZX01FU0g7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIG5NZXJnZWRUcmVrID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnQgKz0gbWVzaGVzW2ldLmdldFRvdGFsVmVydGljZXMoKTtcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGJ1ZmZlciBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICBpZiAoY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIG1lc2hlc1tpXS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChtZXNoZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgYnVmZmVyIHdpbGwgbm90IGJlIGFjY2VwdGFibGVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vLi4uIHNvIHdlIG1lcmdlIGFsbCBtZXNoZXMgb2YgYnVmZmVyXG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlZFRyZWsgPSBuZXcgQkFCWUxPTi5NZXNoKFxuICAgICAgICAgICAgICAgICAgICBcIk1lcmdlZCBUcmVrIFwiICsgbk1lcmdlZFRyZWsrKywgc2NlbmVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFJBTkRPLlV0aWxzLm1lcmdlTWVzaGVzKG1lcmdlZFRyZWssIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgbWVyZ2VkVHJlay5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZWRUcmVrcy5wdXNoKG1lcmdlZFRyZWspO1xuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgd2UgcHVzaCB0aGUgY3VycmVudCBtZXNoIGluIGEgbmV3IGVtcHR5IGJ1ZmZlclxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG1lc2hlc1tpXSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSBtZXNoZXNbaV0uZ2V0VG90YWxWZXJ0aWNlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGNvdW50IG5ldmVyIHJlYWNoZWQgdGhlIGxpbWl0XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRUcmVrID0gbmV3IEJBQllMT04uTWVzaChcbiAgICAgICAgICAgICAgICBcIk1lcmdlZCBUcmVrIFwiICsgbk1lcmdlZFRyZWsrKywgc2NlbmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSQU5ETy5VdGlscy5tZXJnZU1lc2hlcyhtZXJnZWRUcmVrLCBidWZmZXIpO1xuICAgICAgICAgICAgbWVyZ2VkVHJlay5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VkVHJla3MucHVzaChtZXJnZWRUcmVrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIlRyZWsgbWVyZ2VkICEgXCIgKyAoRGF0ZS5ub3coKSAtIFJBTkRPLlNUQVJUX1RJTUUpICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRyZWsudXBkYXRlVmVydGljZXMoKSA6IHVwZGF0ZSB0aGlzLl92ZXJ0aWNlcyBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS51cGRhdGVWZXJ0aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzICAgID0gdGhpcy5fdmVydGljZXM7XG4gICAgICAgIHZhciBzcGhlcmVzICAgICA9IHRoaXMuc3BoZXJlcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCh2ZXJ0aWNlcy5sZW5ndGggPT0gc3BoZXJlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiBzcGhlcmVzKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpdF0ueCA9IHNwaGVyZXNbaXRdLnBvc2l0aW9uLng7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpdF0ueSA9IHNwaGVyZXNbaXRdLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpdF0ueiA9IHNwaGVyZXNbaXRdLnBvc2l0aW9uLno7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay5nZXRUb3RhbFZlcnRpY2VzKCkgOiBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgdHJlay5cbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5nZXRUb3RhbFZlcnRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BoZXJlc0FycmF5ICAgID0gdGhpcy5zcGhlcmVzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBjeWxpbmRlcnNBcnJheSAgPSB0aGlzLmN5bGluZGVycy5nZXRDaGlsZHJlbigpO1xuICAgICAgICB2YXIgbWVzaGVzICAgICAgICAgID0gc3BoZXJlc0FycmF5LmNvbmNhdChjeWxpbmRlcnNBcnJheSk7XG5cbiAgICAgICAgdmFyIHRvdGFsVmVydGljZXMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiBtZXNoZXMpIHtcbiAgICAgICAgICAgIHRvdGFsVmVydGljZXMgKz0gbWVzaGVzW2l0XS5nZXRUb3RhbFZlcnRpY2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWxWZXJ0aWNlcztcbiAgICB9O1xufTsiLCIvLyBSYW5kby5VdGlscy5qc1xuLy8gUmFuZG8gdXRpbGl0aWVzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIFJBTkRPLlV0aWxzID0ge307XG5cbiAgICAvKioqKiAgICBCQUJZTE9OIGV4dGVudHMgICAgICoqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiAgY3JlYXRlR3JvdW5kRnJvbUV4dGVudCgpOiBDcmVhdGUgYSBncm91bmQgZnJvbSBhbiBleHRlbnQgb2YgNCBwb2ludHNcbiAgICAgKiAgICAgIC0gbmFtZSA6IE5hbWUgb2YgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gQSA6IG5vcnRod2VzdCB2ZXJ0ZXhcbiAgICAgKiAgICAgIC0gQiA6IG5vcnRoZWFzdCB2ZXJ0ZXhcbiAgICAgKiAgICAgIC0gQyA6IHNvdXRoZWFzdCB2ZXJ0ZXhcbiAgICAgKiAgICAgIC0gRCA6IHNvdXRod2VzdCB2ZXJ0ZXhcbiAgICAgKiAgICAgIC0gd19zdWJkaXZpc2lvbnMgOiBOdW1iZXIgb2YgV2lkdGgncyBzdWJkaXZpc2lvbnMgaW4gdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gaF9zdWJkaXZpc2lvbnMgOiBOdW1iZXIgb2YgSGVpZ2h0J3Mgc3ViZGl2aXNpb25zIGluIHRoZSBuZXcgR3JvdW5kXG4gICAgICogICAgICAtIHNjZW5lIDogU2NlbmUgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gdXBkYXRhYmxlIDpcbiAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIFJBTkRPLlV0aWxzLmNyZWF0ZUdyb3VuZEZyb21FeHRlbnQgPSBmdW5jdGlvbiAobmFtZSwgQSwgQiwgQywgRCwgd19zdWJkaXZpc2lvbnMsIGhfc3ViZGl2aXNpb25zLCBzY2VuZSwgdXBkYXRhYmxlKSB7XG4gICAgICAgIHZhciBncm91bmQgPSBuZXcgQkFCWUxPTi5Hcm91bmRNZXNoKG5hbWUsIHNjZW5lKTtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciB1dnMgPSBbXTtcbiAgICAgICAgdmFyIHJvdywgY29sO1xuXG4gICAgICAgIHZhciBncmlkID0gUkFORE8uVXRpbHMuY3JlYXRlRmxhdEdyaWQoQSwgQiwgQywgRCwgd19zdWJkaXZpc2lvbnMrIDEsIGhfc3ViZGl2aXNpb25zKyAxKTtcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPD0gaF9zdWJkaXZpc2lvbnM7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8PSB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBncmlkW3Jvd11bY29sXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAxLjAsIDApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xuICAgICAgICAgICAgICAgIHV2cy5wdXNoKGNvbCAvIHdfc3ViZGl2aXNpb25zLCAxLjAgLSByb3cgLyBoX3N1YmRpdmlzaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIHBvc2l0aW9ucywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLCBub3JtYWxzLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlVWS2luZCwgdXZzLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0SW5kaWNlcyhpbmRpY2VzKTtcblxuICAgICAgICByZXR1cm4gZ3JvdW5kO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgY3JlYXRlR3JvdW5kRnJvbUdyaWQoKTogQ3JlYXRlIGEgZ3JvdW5kIGZyb20gYSBncmlkIG9mIDJEIHBvaW50c1xuICAgICAqICAgICAgLSBuYW1lIDogTmFtZSBvZiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSBncmlkIDogZ3JpZCBvZiAyZCBwb2ludHMgKGVhY2ggcG9pbnQgY29udGFpbnMgYSB4IGFuZCBhIHkpXG4gICAgICogICAgICAtIHNjZW5lIDogU2NlbmUgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gdXBkYXRhYmxlIDpcbiAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIFJBTkRPLlV0aWxzLmNyZWF0ZUdyb3VuZEZyb21HcmlkID0gZnVuY3Rpb24gKG5hbWUsIGdyaWQsIHNjZW5lLCB1cGRhdGFibGUpIHtcbiAgICAgICAgdmFyIGdyb3VuZCA9IG5ldyBCQUJZTE9OLkdyb3VuZE1lc2gobmFtZSwgc2NlbmUpO1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xuICAgICAgICB2YXIgcm93LCBjb2w7XG5cbiAgICAgICAgdmFyIGhfc3ViZGl2aXNpb25zID0gZ3JpZC5sZW5ndGgtMTtcbiAgICAgICAgdmFyIHdfc3ViZGl2aXNpb25zID0gZ3JpZFswXS5sZW5ndGgtMTtcblxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8PSBoX3N1YmRpdmlzaW9uczsgcm93KyspIHtcbiAgICAgICAgICAgIHdfc3ViZGl2aXNpb25zID0gZ3JpZFtyb3ddLmxlbmd0aC0xO1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPD0gd19zdWJkaXZpc2lvbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZ3JpZFtoX3N1YmRpdmlzaW9ucyAtIHJvd11bY29sXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAxLjAsIDApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG4gICAgICAgICAgICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xuICAgICAgICAgICAgICAgIHV2cy5wdXNoKGNvbCAvIHdfc3ViZGl2aXNpb25zLCAxLjAgLSByb3cgLyBoX3N1YmRpdmlzaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgd19zdWJkaXZpc2lvbnMgPSBncmlkW3Jvd10ubGVuZ3RoLTE7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHdfc3ViZGl2aXNpb25zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG5cbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCwgcG9zaXRpb25zLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsIG5vcm1hbHMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kLCB1dnMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRJbmRpY2VzKGluZGljZXMpO1xuXG4gICAgICAgIHJldHVybiBncm91bmQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBjcmVhdGVHcm91bmRGcm9tVmVydGljZXMoKTogQ3JlYXRlIGEgZ3JvdW5kIGZyb20gYW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKiAgICAgIC0gbmFtZSA6IE5hbWUgb2YgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gdmVydGljZXMgOiBBcnJheSBvZiB2ZXJ0aWNlcyBpbiBCQUJZTE9OLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQgZm9ybWF0XG4gICAgICogICAgICAtIHdfc3ViZGl2aXNpb25zIDogTnVtYmVyIG9mIFdpZHRoJ3Mgc3ViZGl2aXNpb25zIGluIHRoZSBuZXcgR3JvdW5kXG4gICAgICogICAgICAtIGhfc3ViZGl2aXNpb25zIDogTnVtYmVyIG9mIEhlaWdodCdzIHN1YmRpdmlzaW9ucyBpbiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSBzY2VuZSA6IFNjZW5lIHdoaWNoIGNvbnRhaW5zIHRoZSBuZXcgR3JvdW5kXG4gICAgICogICAgICAtIHVwZGF0YWJsZSA6XG4gICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBSQU5ETy5VdGlscy5jcmVhdGVHcm91bmRGcm9tVmVydGljZXMgPSBmdW5jdGlvbiggbmFtZSwgdmVydGljZXMsIHdfc3ViZGl2aXNpb25zLCBoX3N1YmRpdmlzaW9ucywgc2NlbmUsIHVwZGF0YWJsZSkge1xuICAgICAgICBjb25zb2xlLmFzc2VydCh2ZXJ0aWNlcy5sZW5ndGglMyA9PSAwKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKHZlcnRpY2VzLmxlbmd0aC8zKSA9PSB3X3N1YmRpdmlzaW9ucypoX3N1YmRpdmlzaW9ucyxcbiAgICAgICAgKHZlcnRpY2VzLmxlbmd0aC8zKSArIFwiIT1cIiArIHdfc3ViZGl2aXNpb25zICsgXCIqXCIgKyBoX3N1YmRpdmlzaW9ucyk7XG5cbiAgICAgICAgdmFyIGdyb3VuZCA9IEJBQllMT04uR3JvdW5kTWVzaChuYW1lLCBzY2VuZSk7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgICAgICB2YXIgdXZzID0gW107XG4gICAgICAgIHZhciByb3csIGNvbDtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDw9IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPD0gd19zdWJkaXZpc2lvbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMS4wLCAwKTtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpKzFdLCB2ZXJ0aWNlc1tpKzJdKTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG4gICAgICAgICAgICAgICAgdXZzLnB1c2goY29sIC8gd19zdWJkaXZpc2lvbnMsIDEuMCAtIHJvdyAvIGhfc3ViZGl2aXNpb25zKTtcbiAgICAgICAgICAgICAgICBpKz0zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBoX3N1YmRpdmlzaW9uczsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgd19zdWJkaXZpc2lvbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcblxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCBwb3NpdGlvbnMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCwgbm9ybWFscywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIHV2cywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldEluZGljZXMoaW5kaWNlcyk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VuZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIGNyZWF0ZVNpZGVGcm9tTGluZSgpOiBDcmVhdGUgYSBzaWRlIG9mIHRoZSBERU0gZnJvbSBhIGxpbmUgb2YgcG9pbnRzICh0b3AgbGluZSlcbiAgICAgKiAgICAgIC0gbmFtZSA6IE5hbWUgb2YgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gbGluZSA6IEFycmF5IG9mIHBvaW50cyBbe3g6ICx5OiAsejogfSwgLi4uXVxuICAgICAqICAgICAgLSBiYXNlIDogQWx0aXR1ZGUgb2YgdGhlIGJhc2UgbGluZVxuICAgICAqICAgICAgLSBzY2VuZSA6IFNjZW5lIHdoaWNoIGNvbnRhaW5zIHRoZSBuZXcgc2lkZVxuICAgICAqICAgICAgLSB1cGRhdGFibGUgOlxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuY3JlYXRlU2lkZUZyb21MaW5lID0gZnVuY3Rpb24gKG5hbWUsIGxpbmUsIGJhc2UsIHNjZW5lLCB1cGRhdGFibGUpIHtcbiAgICAgICAgdmFyIHNpZGUgPSBuZXcgQkFCWUxPTi5Hcm91bmRNZXNoKG5hbWUsIHNjZW5lKTtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciB1dnMgPSBbXTtcbiAgICAgICAgdmFyIHJvdywgY29sO1xuXG4gICAgICAgIHZhciBoX3N1YmRpdmlzaW9ucyA9IDFcbiAgICAgICAgdmFyIHdfc3ViZGl2aXNpb25zID0gbGluZS5sZW5ndGgtMTtcblxuICAgICAgICAvLyBQb3NpdGlvbnMsIG5vcm1hbHMsIGFuZCB1dnNcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPD0gaF9zdWJkaXZpc2lvbnM7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8PSB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBsaW5lW2NvbF07XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMS4wLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChyb3cgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbi54LCBiYXNlLCBwb3NpdGlvbi56KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG4gICAgICAgICAgICAgICAgdXZzLnB1c2goY29sIC8gd19zdWJkaXZpc2lvbnMsIDEuMCAtIHJvdy8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZGljZXNcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBoX3N1YmRpdmlzaW9uczsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgd19zdWJkaXZpc2lvbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcblxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNpZGUuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCwgcG9zaXRpb25zLCB1cGRhdGFibGUpO1xuICAgICAgICBzaWRlLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLCBub3JtYWxzLCB1cGRhdGFibGUpO1xuICAgICAgICBzaWRlLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIHV2cywgdXBkYXRhYmxlKTtcbiAgICAgICAgc2lkZS5zZXRJbmRpY2VzKGluZGljZXMpO1xuXG4gICAgICAgIHJldHVybiBzaWRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBwbGFjZUN5bGluZGVyKClcbiAgICAgKiAgICAgIC0gY3lsaW5kZXIgKEJBQllMT04uTWVzaCk6IEJBQllMT04gQ3lsaW5kZXIgb2JqZWN0XG4gICAgICogICAgICAtIEEgKEJBQllMT04uVmVjdG9yMyk6ICAgICBGaXJzdCBQb2ludFxuICAgICAqICAgICAgLSBCIChCQUJZTE9OLlZlY3RvcjMpOiAgICAgU2Vjb25kIFBvaW50XG4gICAgICpcbiAgICAgKiBQbGFjZSB0aGUgY3lsaW5kZXIgYmV0d2VlbiBib3RoIHBvaW50c1xuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIFJBTkRPLlV0aWxzLnBsYWNlQ3lsaW5kZXIgPSBmdW5jdGlvbiAoY3lsaW5kZXIsIEEsIEIpIHtcbiAgICAgICAgLy8gSW5pdGlhbCBwb3NpdGlvbiBhdCB0aGUgY2VudGVyIG9mIHRoZSBBQiB2ZWN0b3JcbiAgICAgICAgY3lsaW5kZXIucG9zaXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKFxuICAgICAgICAgICAgKEEueCtCLngpLzIsXG4gICAgICAgICAgICAoQS55K0IueSkvMixcbiAgICAgICAgICAgIChBLnorQi56KS8yXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHNjYWxlIG9mIGN5bGluZGVyXG4gICAgICAgIHZhciBuZXdfaGVpZ2h0ID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKEEsIEIpO1xuICAgICAgICBjeWxpbmRlci5zY2FsaW5nLnkgPSBuZXdfaGVpZ2h0O1xuXG4gICAgICAgIC8vIEZpcnN0IHJvdGF0aW9uXG4gICAgICAgIHZhciBhbmdsZTEgPSBSQU5ETy5VdGlscy5hbmdsZUZyb21BeGlzKEEsIEIsIEJBQllMT04uQXhpcy5YKTtcbiAgICAgICAgY3lsaW5kZXIucm90YXRlKFxuICAgICAgICAgICAgQkFCWUxPTi5BeGlzLlgsXG4gICAgICAgICAgICBhbmdsZTEsXG4gICAgICAgICAgICBCQUJZTE9OLlNwYWNlLkxPQ0FMXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU2Vjb25kIHJvdGF0aW9uXG4gICAgICAgIHZhciBIID0gbmV3IEJBQllMT04uVmVjdG9yMyhBLngsQi55LEIueik7XG4gICAgICAgIHZhciBhbmdsZTIgPSBSQU5ETy5VdGlscy5hbmdsZUZyb21Qb2ludHMoQSwgQiwgSCk7XG4gICAgICAgIGN5bGluZGVyLnJvdGF0ZShcbiAgICAgICAgICAgIEJBQllMT04uQXhpcy5aLFxuICAgICAgICAgICAgYW5nbGUyLFxuICAgICAgICAgICAgQkFCWUxPTi5TcGFjZS5MT0NBTFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjeWxpbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZU1lc2hOb3JtYWxzKCkgOiByZWNvbXB1dGUgbm9ybWFscyBvZiBhIG1lc2ggKGZvciB0aGUgc2hhZG93cyBhZnRlcilcbiAgICAgKiAgICAgIC0gbWVzaDogbWVzaCB0byByZWNvbXB1dGVcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5jb21wdXRlTWVzaE5vcm1hbHMgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBCQUJZTE9OLlZlcnRleERhdGEuRXh0cmFjdEZyb21NZXNoIChtZXNoKTtcbiAgICAgICAgQkFCWUxPTi5WZXJ0ZXhEYXRhLkNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLnBvc2l0aW9ucywgdmVydGljZXMuaW5kaWNlcywgdmVydGljZXMubm9ybWFscyk7XG4gICAgICAgIHZlcnRpY2VzLmFwcGx5VG9NZXNoKG1lc2gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXRNZXNoVXZzKCkgOiBzZXQgdGhlIG1lc2ggdXZzIHRha2luZyBmcm9tIHRoZSBvYmplY3QgdXYgdGFrZW4gaW4gcGFyYW1ldGVyXG4gICAgICogICAgICBtZXNoOiBiYWJ5bG9uIG1lc2hcbiAgICAgKiAgICAgIHV2czogb2JqZWN0IGpzIGNvbnRhaW5pbmcgdXZzIHZhbHVlc1xuICAgICAqXG4gICAgICogTkI6IGZvcm1hdCBvZiB1diBvYmplY3QgcGFyYW1ldGVyIDpcbiAgICAgKiAgICAgIHV2ID0ge1xuICAgICAqICAgICAgICAgIHU6IFtdLFxuICAgICAqICAgICAgICAgIHY6IFtdXG4gICAgICogICAgICB9XG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuc2V0TWVzaFV2cyA9IGZ1bmN0aW9uIChtZXNoLCB1dikge1xuICAgICAgICB2YXIgdXZfYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIGNvbCwgcm93O1xuICAgICAgICBmb3IgKHJvdyBpbiB1di52KSB7XG4gICAgICAgICAgICBmb3IgKGNvbCBpbiB1di51KSB7XG4gICAgICAgICAgICAgICAgdXZfYXJyYXkucHVzaCh1di51W2NvbF0pO1xuICAgICAgICAgICAgICAgIHV2X2FycmF5LnB1c2godXYudltyb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICAgICAgbWVzaC5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kKS5sZW5ndGggPT0gdXZfYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgXCJzZXRNZXNoVXZzKCkgOiB1dnMgaW4gcGFyYW1ldGVyIGFyZSBub3Qgd2VsbCBzaXplZFwiXG4gICAgICAgICk7XG5cbiAgICAgICAgbWVzaC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kLCB1dl9hcnJheSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlV0aWxzLm1lcmdlTWVzaGVzKCkgOiBNZXJnZSBhIG1lc2ggYXJyYXkgaW4gb25seSBvbmUgbWVzaC4gSXQgcGVybWl0ZXNcbiAgICAgKiB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cbiAgICAgKiAgICAgIC0gbmV3TWVzaCA6IGZ1dHVyZSBtZXJnZWQgTWVzaFxuICAgICAqICAgICAgLSBhcnJheU9iaiA6IGFycmF5IG9mIE1lc2hlcyB0byBtZXJnZVxuICAgICAqXG4gICAgICogRnVuY3Rpb24gZGlyZWN0bHkgaW5zcGlyZWQgZnJvbSBEYXZpZCBDYXR1aGUncyBvbmUgaW4gdGhlIGdpdGh1YiB3aWtpIG9mIEJhYnlsb25KU1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9CYWJ5bG9uSlMvQmFieWxvbi5qcy93aWtpL0hvdy10by1tZXJnZS1tZXNoZXNcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5tZXJnZU1lc2hlcyA9IGZ1bmN0aW9uIChuZXdNZXNoLCBhcnJheU9iaikge1xuICAgICAgICB2YXIgYXJyYXlQb3MgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5Tm9ybWFsID0gW107XG4gICAgICAgIHZhciBhcnJheVV2ID0gW107XG4gICAgICAgIHZhciBhcnJheVV2MiA9IFtdO1xuICAgICAgICB2YXIgYXJyYXlDb2xvciA9IFtdO1xuICAgICAgICB2YXIgYXJyYXlNYXRyaWNlc0luZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5TWF0cmljZXNXZWlnaHRzID0gW107XG4gICAgICAgIHZhciBhcnJheUluZGljZSA9IFtdO1xuICAgICAgICB2YXIgc2F2ZWRQb3NpdGlvbiA9IFtdO1xuICAgICAgICB2YXIgc2F2ZWROb3JtYWwgPSBbXTtcbiAgICAgICAgdmFyIFVWS2luZCA9IHRydWU7XG4gICAgICAgIHZhciBVVjJLaW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIENvbG9yS2luZCA9IHRydWU7XG4gICAgICAgIHZhciBNYXRyaWNlc0luZGljZXNLaW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIE1hdHJpY2VzV2VpZ2h0c0tpbmQgPSB0cnVlO1xuICAgICAgICB2YXIgaSA9IDAsIGl0O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgIT0gYXJyYXlPYmoubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWFycmF5T2JqW2ldLmlzVmVydGljZXNEYXRhUHJlc2VudChbQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kXSkpXG4gICAgICAgICAgICAgICAgVVZLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWFycmF5T2JqW2ldLmlzVmVydGljZXNEYXRhUHJlc2VudChbQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVYyS2luZF0pKVxuICAgICAgICAgICAgICAgIFVWMktpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghYXJyYXlPYmpbaV0uaXNWZXJ0aWNlc0RhdGFQcmVzZW50KFtCQUJZTE9OLlZlcnRleEJ1ZmZlci5Db2xvcktpbmRdKSlcbiAgICAgICAgICAgICAgICBDb2xvcktpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghYXJyYXlPYmpbaV0uaXNWZXJ0aWNlc0RhdGFQcmVzZW50KFtCQUJZTE9OLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kXSkpXG4gICAgICAgICAgICAgICAgTWF0cmljZXNJbmRpY2VzS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFhcnJheU9ialtpXS5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoW0JBQllMT04uVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmRdKSlcbiAgICAgICAgICAgICAgICBNYXRyaWNlc1dlaWdodHNLaW5kID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpICE9IGFycmF5T2JqLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZSA9IDA7XG4gICAgICAgICAgICB2YXIgaXRlciA9IDA7XG4gICAgICAgICAgICBhcnJheVBvc1tpXSA9IGFycmF5T2JqW2ldLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpO1xuICAgICAgICAgICAgYXJyYXlOb3JtYWxbaV0gPSBhcnJheU9ialtpXS5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCk7XG4gICAgICAgICAgICBpZiAoVVZLaW5kKVxuICAgICAgICAgICAgICAgIGFycmF5VXYgPSBhcnJheVV2LmNvbmNhdChhcnJheU9ialtpXS5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSk7XG4gICAgICAgICAgICBpZiAoVVYyS2luZClcbiAgICAgICAgICAgICAgICBhcnJheVV2MiA9IGFycmF5VXYyLmNvbmNhdChhcnJheU9ialtpXS5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkpO1xuICAgICAgICAgICAgaWYgKENvbG9yS2luZClcbiAgICAgICAgICAgICAgICBhcnJheUNvbG9yID0gYXJyYXlDb2xvci5jb25jYXQoYXJyYXlPYmpbaV0uZ2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLkNvbG9yS2luZCkpO1xuICAgICAgICAgICAgaWYgKE1hdHJpY2VzSW5kaWNlc0tpbmQpXG4gICAgICAgICAgICAgICAgYXJyYXlNYXRyaWNlc0luZGljZXMgPSBhcnJheU1hdHJpY2VzSW5kaWNlcy5jb25jYXQoYXJyYXlPYmpbaV0uZ2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpKTtcbiAgICAgICAgICAgIGlmIChNYXRyaWNlc1dlaWdodHNLaW5kKVxuICAgICAgICAgICAgICAgIGFycmF5TWF0cmljZXNXZWlnaHRzID0gYXJyYXlNYXRyaWNlc1dlaWdodHMuY29uY2F0KGFycmF5T2JqW2ldLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSk7XG5cbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IHNhdmVkUG9zaXRpb24ubGVuZ3RoIC8gMztcblxuICAgICAgICAgICAgYXJyYXlPYmpbaV0uY29tcHV0ZVdvcmxkTWF0cml4KHRydWUpO1xuICAgICAgICAgICAgdmFyIHdvcmxkTWF0cml4ID0gYXJyYXlPYmpbaV0uZ2V0V29ybGRNYXRyaXgoKTtcblxuICAgICAgICAgICAgd2hpbGUgKGl0ZSA8IGFycmF5UG9zW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKG5ldyBCQUJZTE9OLlZlY3RvcjMoYXJyYXlQb3NbaV1baXRlXSwgYXJyYXlQb3NbaV1baXRlICsgMV0sIGFycmF5UG9zW2ldW2l0ZSArIDJdKSwgd29ybGRNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHNhdmVkUG9zaXRpb24ucHVzaCh2ZXJ0ZXgueCk7XG4gICAgICAgICAgICAgICAgc2F2ZWRQb3NpdGlvbi5wdXNoKHZlcnRleC55KTtcbiAgICAgICAgICAgICAgICBzYXZlZFBvc2l0aW9uLnB1c2godmVydGV4LnopO1xuICAgICAgICAgICAgICAgIGl0ZSA9IGl0ZSArIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaXRlciA8IGFycmF5Tm9ybWFsW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChuZXcgQkFCWUxPTi5WZWN0b3IzKGFycmF5Tm9ybWFsW2ldW2l0ZXJdLCBhcnJheU5vcm1hbFtpXVtpdGVyICsgMV0sIGFycmF5Tm9ybWFsW2ldW2l0ZXIgKyAyXSksIHdvcmxkTWF0cml4KTtcbiAgICAgICAgICAgICAgICBzYXZlZE5vcm1hbC5wdXNoKHZlcnRleC54KTtcbiAgICAgICAgICAgICAgICBzYXZlZE5vcm1hbC5wdXNoKHZlcnRleC55KTtcbiAgICAgICAgICAgICAgICBzYXZlZE5vcm1hbC5wdXNoKHZlcnRleC56KTtcbiAgICAgICAgICAgICAgICBpdGVyID0gaXRlciArIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gYXJyYXlPYmpbaV0uZ2V0SW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIGZvciAoaXQgPSAwIDsgaXQgIT0gdG1wLmxlbmd0aDsgaXQrKykge1xuICAgICAgICAgICAgICAgICAgICB0bXBbaXRdID0gdG1wW2l0XSArIG1heFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheUluZGljZSA9IGFycmF5SW5kaWNlLmNvbmNhdCh0bXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlJbmRpY2UgPSBhcnJheU9ialtpXS5nZXRJbmRpY2VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5T2JqW2ldLmRpc3Bvc2UoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWVzaC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCBzYXZlZFBvc2l0aW9uLCBmYWxzZSk7XG4gICAgICAgIG5ld01lc2guc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsIHNhdmVkTm9ybWFsLCBmYWxzZSk7XG4gICAgICAgIGlmIChhcnJheVV2Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIGFycmF5VXYsIGZhbHNlKTtcbiAgICAgICAgaWYgKGFycmF5VXYyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVjJLaW5kLCBhcnJheVV2MiwgZmFsc2UpO1xuICAgICAgICBpZiAoYXJyYXlDb2xvci5sZW5ndGggPiAwKVxuICAgICAgICAgICAgbmV3TWVzaC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kLCBhcnJheUNvbG9yLCBmYWxzZSk7XG4gICAgICAgIGlmIChhcnJheU1hdHJpY2VzSW5kaWNlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgbmV3TWVzaC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCwgYXJyYXlNYXRyaWNlc0luZGljZXMsIGZhbHNlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0cmljZXNXZWlnaHRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kLCBhcnJheU1hdHJpY2VzV2VpZ2h0cywgZmFsc2UpO1xuXG4gICAgICAgIG5ld01lc2guc2V0SW5kaWNlcyhhcnJheUluZGljZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlV0aWxzLmdldFNpemUgKCkgOiBnZXQgdGhlIHNpemUgb2YgYSBtZXNoXG4gICAgICogICAgICAtIG1lc2ggOiBtZXNoXG4gICAgICpcbiAgICAgKiByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIGRlZXAgb2YgdGhlIG1lc2hcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5nZXRTaXplID0gZnVuY3Rpb24gKG1lc2gpIHtcbiAgICAgICAgdmFyIG1pbm1heCA9IEJBQllMT04uTWVzaC5NaW5NYXgoW21lc2hdKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3dpZHRoJyAgOiAobWlubWF4Lm1heC54IC0gbWlubWF4Lm1pbi54KSAsXG4gICAgICAgICAgICAnaGVpZ2h0JyA6IChtaW5tYXgubWF4LnkgLSBtaW5tYXgubWluLnkpICxcbiAgICAgICAgICAgICdkZWVwJyAgIDogKG1pbm1heC5tYXgueiAtIG1pbm1heC5taW4ueilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5VdGlscy5pc0luRXh0ZW50KCkgOlxuICAgICAqICByZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIGluIHRoZSBnaXZlbiBleHRlbnRcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5pc0luRXh0ZW50ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBleHRlbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggPj0gZXh0ZW50LngubWluICYmXG4gICAgICAgICAgICBjb29yZGluYXRlcy54IDw9IGV4dGVudC54Lm1heCAmJlxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueiA+PSBleHRlbnQuei5taW4gJiZcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnogPD0gZXh0ZW50LnoubWF4XG4gICAgICAgICApPyB0cnVlOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVXRpbHMuZ2V0TnVtYmVyT2ZUaWxlcygpIDogcmV0dXJuIHRoZSBudW1iZXIgb2YgdGlsZXMgYWNjb3JkaW5nIGEgem9vbSBsZXZlbCBhbmRcbiAgICAgKiBhIG1ldGVycyBleHRlbnQuXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuZ2V0TnVtYmVyT2ZUaWxlcyA9IGZ1bmN0aW9uICh6b29tLCBleHRlbnQpIHtcbiAgICAgICAgdmFyIHhUaWxlTWluID0gUkFORE8uVXRpbHMubWV0ZXJzMm51bSAoZXh0ZW50LngubWluLCBleHRlbnQuei5taW4sIHpvb20pLnh0aWxlO1xuICAgICAgICB2YXIgeFRpbGVNYXggPSBSQU5ETy5VdGlscy5tZXRlcnMybnVtIChleHRlbnQueC5tYXgsIGV4dGVudC56Lm1heCwgem9vbSkueHRpbGU7XG4gICAgICAgIHZhciB5VGlsZU1pbiA9IFJBTkRPLlV0aWxzLm1ldGVyczJudW0gKGV4dGVudC54Lm1pbiwgZXh0ZW50LnoubWluLCB6b29tKS55dGlsZTtcbiAgICAgICAgdmFyIHlUaWxlTWF4ID0gUkFORE8uVXRpbHMubWV0ZXJzMm51bSAoZXh0ZW50LngubWF4LCBleHRlbnQuei5tYXgsIHpvb20pLnl0aWxlO1xuICAgICAgICByZXR1cm4gKHhUaWxlTWF4IC0geFRpbGVNaW4gKyAxKSAqICh5VGlsZU1pbiAtIHlUaWxlTWF4ICsgMSk7XG4gICAgfTtcblxuICAgIC8qKioqICAgIEdFT01FVFJZICAgICAqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqdGVzdGVkXG4gICAgICogbWlkZGxlKCk6XG4gICAgICogICAgICBBOiBmaXJzdCBwb2ludFxuICAgICAqICAgICAgQjogc2Vjb25kIHBvaW50XG4gICAgICpcbiAgICAgKiByZXR1cm4gdGhlIG1pZGRsZSBvZiB0aGUgc2VnbWVudCBmb3JtIGJ5IEEgYW5kIEJcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5taWRkbGUgPSBmdW5jdGlvbiAoQSwgQikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKEEueCtCLngpLzIsXG4gICAgICAgICAgICB5OiAoQS55K0IueSkvMixcbiAgICAgICAgICAgIHo6IChBLnorQi56KS8yXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKnRlc3RlZFxuICAgICAqIHN1YmRpdmlkZSgpIDogIGludGVycG9sYXRlIGEgc2VnbWVudCBiZXR3ZWVuIDIgcG9pbnRzIEEgYW5kIEJcbiAgICAgKiAgICAgIC0gbiA6IG51bWJlciBvZiBwb2ludHMgZXhwZWN0ZWQgaW4gcmVzdWx0XG4gICAgICogICAgICAtIEEgOiBmaXJzdCBwb2ludFxuICAgICAqICAgICAgLSBCIDogc2Vjb25kIHBvaW50XG4gICAgICpcbiAgICAgKiByZXR1cm4gYW4gYXJyYXkgb2YgcG9pbnRcbiAgICAgKlxuICAgICAqIE5CIDogcG9pbnRzIGFyZSBpbiB0aGUgZm9ybWF0IDogeyB4IDogLi4gLCB5IDogLi4gfVxuICAgICAqXG4gICAgICpcbiAgICAgKiBleGFtcGxlIDpcbiAgICAgKlxuICAgICAqICAgICAgICAgKiBCICAgICAgICAgICAgICAgICAgICogQlxuICAgICAqICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgL1xuICAgICAqICAgICAgIC8gICAgICBuID0gNCAgICAgICAgICAqIE0yXG4gICAgICogICAgICAvICAgICAgLS0tLT4gICAgICAgICAgL1xuICAgICAqICAgICAvICAgICAgICAgICAgICAgICAgICAgKiBNMVxuICAgICAqICAgIC8gICAgICAgICAgICAgICAgICAgICAvXG4gICAgICogQSAqICAgICAgICAgICAgICAgICAgICBBKlxuICAgICAqXG4gICAgICogICAgICAgICAgcmVzdWx0IDogW0EsIE0xLCBNMiwgQl1cbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnN1YmRpdmlkZSA9IGZ1bmN0aW9uIChuLCBBLCBCKSB7XG5cbiAgICAgICAgaWYgKG48PTApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmIChuPT0xKSByZXR1cm4gQTtcblxuICAgICAgICBpZiAobj09MikgcmV0dXJuIFtBLEJdO1xuXG4gICAgICAgIGlmIChuPj0zKSB7XG4gICAgICAgICAgICB2YXIgZHggPSAoQi54LUEueCkvKG4tMSk7XG4gICAgICAgICAgICB2YXIgZHkgPSAoQi55LUEueSkvKG4tMSk7XG5cbiAgICAgICAgICAgIHZhciB4ID0gQS54O1xuICAgICAgICAgICAgdmFyIHkgPSBBLnk7XG5cbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHJlcy5wdXNoKEEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG4tMjsgaSsrKXtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgICAgIHkgKz0gZHk7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAneCcgOiB4LFxuICAgICAgICAgICAgICAgICAgICAneScgOiB5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChCKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKip0ZXN0ZWRcbiAgICAgKiBjcmVhdGVHcmlkKCkgOiBjcmVhdGUgYSBncmlkIG9mIHBvaW50cyBmb3IgYWxsIHR5cGUgb2YgcXVhZHJpbGF0ZXJlcywgaW4gcGFydGljdWxhclxuICAgICAqICB0aGVzZSB3aGljaCBhcmUgbm90IHNxdWFyZSBvciByZWN0YW5nbGUuXG4gICAgICogICAgICAtIEEsIEIsIEMsIEQgOiAgdmVydGljZXMgb2YgcXVhZHJpbGF0ZXJlIHRvIHN1YmRpdmlkZVxuICAgICAqICAgICAgLSBuX3ZlcnRpIDogICAgIG51bWJlciBvZiBwb2ludHMgaW4gdmVydGljYWwgc2l6ZVxuICAgICAqICAgICAgLSBuX2hvcml6IDogICAgIG51bWJlciBvZiBwb2ludHMgaW4gaG9yaXpvbnRhbCBzaXplXG4gICAgICpcbiAgICAgKlxuICAgICAqIE5CIDogKiBuX3ZlcnRpIGFuZCBuX2hvcml6IGNhbm5vdCBiZSBpbnZlcnRcbiAgICAgKiAgICAgICogdGhlIG9yZGVyIG9mIGlucHV0IHBvaW50cyBpcyBhbHNvIGltcG9ydGFudCwgaXQgZGV0ZXJtaW5lc1xuICAgICAqIHRoZSBvcmRlciBvZiBvdXRwdXQgcG9pbnRzIDpcbiAgICAgKiAgW0EsIC4uLi4sIEIsICAgIC0+IGZpcnN0IGxpbmVcbiAgICAgKiAgIC4uLi4uLi4uLi4sXG4gICAgICogICBELCAuLi4uLCBDXSAgICAtPiBsYXN0IGxpbmVcbiAgICAgKlxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBxdWFkcmlsYXRlcmUgOlxuICAgICAqIEQgKi0tLS0tLS0tLS0tLS0tLS0tLSogQ1xuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgKiAgIHwgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgKiAgIHwgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqIEEgKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qIEJcbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmNyZWF0ZUZsYXRHcmlkID0gZnVuY3Rpb24gKEEsIEIsIEMsIEQsIG5faG9yaXosIG5fdmVydGkpIHtcbiAgICAgICAgaWYobl92ZXJ0aTw9MCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmKG5faG9yaXo8PTApIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIHN1YmRpdmlkZSBib3RoIHNpZGVzIG9mIHRoZSBxdWFkXG4gICAgICAgIHZhciB3ZXN0X3NpZGUgPSBSQU5ETy5VdGlscy5zdWJkaXZpZGUobl92ZXJ0aSwgQSwgRCk7XG4gICAgICAgIHZhciBlYXN0X3NpZGUgPSBSQU5ETy5VdGlscy5zdWJkaXZpZGUobl92ZXJ0aSwgQiwgQyk7XG4gICAgICAgIHZhciBncmlkID0gW107XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHdlc3Rfc2lkZS5sZW5ndGggPT0gZWFzdF9zaWRlLmxlbmd0aCxcbiAgICAgICAgICAgIFwiY3JlYXRlR3JpZCA6IHdlc3Rfc2lkZS5sZW5ndGggIT0gZWFzdF9zaWRlLmxlbmd0aCBcXG5cIiArXG4gICAgICAgICAgICB3ZXN0X3NpZGUubGVuZ3RoICtcbiAgICAgICAgICAgIFwiICE9IFwiICtcbiAgICAgICAgICAgIGVhc3Rfc2lkZS5sZW5ndGhcbiAgICAgICAgKTtcblxuXG4gICAgICAgIGZvciAodmFyIGo9MDsgaiA8IG5fdmVydGk7IGorKyl7XG4gICAgICAgICAgICAvLyBzdWJpZGl2aWRlIGxpbmVzXG4gICAgICAgICAgICB2YXIgbGluZSA9IFJBTkRPLlV0aWxzLnN1YmRpdmlkZShuX2hvcml6LCB3ZXN0X3NpZGVbal0sIGVhc3Rfc2lkZVtqXSk7XG4gICAgICAgICAgICBncmlkLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmNyZWF0ZUVsZXZhdGlvbkdyaWQgPSBmdW5jdGlvbiAoeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgYWx0aXR1ZGVzKSB7XG4gICAgICAgIHZhciBBID0ge1xuICAgICAgICAgICAgJ3gnIDogeG1pbixcbiAgICAgICAgICAgICd5JyA6IHltaW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEIgPSB7XG4gICAgICAgICAgICAneCcgOiB4bWF4LFxuICAgICAgICAgICAgJ3knIDogeW1pblxuICAgICAgICB9O1xuICAgICAgICB2YXIgQyA9IHtcbiAgICAgICAgICAgICd4JyA6IHhtYXgsXG4gICAgICAgICAgICAneScgOiB5bWF4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBEID0ge1xuICAgICAgICAgICAgJ3gnIDogeG1pbixcbiAgICAgICAgICAgICd5JyA6IHltYXhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJvdywgY29sO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgZ3JpZCBmcm9tIGV4dGVudCBkYXRhc1xuICAgICAgICB2YXIgZ3JpZCA9IFJBTkRPLlV0aWxzLmNyZWF0ZUZsYXRHcmlkKFxuICAgICAgICAgICAgQSwgQiwgQywgRCxcbiAgICAgICAgICAgIGFsdGl0dWRlc1swXS5sZW5ndGgsXG4gICAgICAgICAgICBhbHRpdHVkZXMubGVuZ3RoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR2l2ZXMgYWx0aXR1ZGVzIHRvIHRoZSBncmlkXG4gICAgICAgIGZvciAocm93IGluIGFsdGl0dWRlcyl7XG4gICAgICAgICAgICBmb3IgKGNvbCBpbiBhbHRpdHVkZXNbcm93XSl7XG4gICAgICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0ueiA9IGdyaWRbcm93XVtjb2xdLnk7XG4gICAgICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0ueSA9IGFsdGl0dWRlc1tyb3ddW2NvbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfTtcblxuICAgIC8qKnRlc3RlZFxuICAgICAqIGFuZ2xlRnJvbUF4aXMoKTogZ2V0IGFuIGFuZ2xlIGZvciBhIHJvdGF0aW9uXG4gICAgICogICAgICAtIEEgICAgIChCQUJZTE9OLlZlY3RvcjMpIDogRmlyc3QgcG9pbnRcbiAgICAgKiAgICAgIC0gQiAgICAgKEJBQllMT04uVmVjdG9yMykgOiBTZWNvbmQgcG9pbnRcbiAgICAgKiAgICAgIC0gYXhpcyAgKEJBQllMT04uVmVjdG9yMykgOiBBeGlzIG9mIHJvdGF0aW9uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgd2l0aCBhIHJvdGF0aW9uIGFyb3VuZCB5IGF4aXNcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgXyB6XG4gICAgICogICAgICAgLi0+ICAgICAgICAgICB8XG4gICAgICogICAgICAvICAgICAgICAgICAgICB8ICAgICAqIEJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfC8gICAgICAgICAgICAgICB4XG4gICAgICogICAgICAgLS0tLS0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0tPlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfEFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKlxuICAgICAqIE5CIDogSXQgdXNlcyBnbG9iYWwgYXhpcyBvbmx5XG4gICAgICogICgxLCAwLCAwKSwgKDAsIDEsIDApLCBvciAoMCwgMCwgMSlcbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmFuZ2xlRnJvbUF4aXMgPSBmdW5jdGlvbiAoQSwgQiwgYXhpcykge1xuICAgICAgICB2YXIgYW5nbGUsIEFILCBBQjtcbiAgICAgICAgc3dpdGNoIChheGlzKXtcbiAgICAgICAgICAgIGNhc2UgQkFCWUxPTi5BeGlzLlggOlxuICAgICAgICAgICAgICAgIGlmKEEueSA9PSBCLnkgJiYgQS56ID09IEIueikgLy8gSXQgZG9uJ3QgbmVlZCByb3RhdGlvbiBhcm91bmQgWFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBBSCA9IEIueS1BLnk7XG4gICAgICAgICAgICAgICAgQUIgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KEIueS1BLnksIDIpK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhCLnotQS56LCAyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoQUgvQUIpO1xuICAgICAgICAgICAgICAgIGlmIChCLnogPCBBLnopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJBQllMT04uQXhpcy5ZIDpcbiAgICAgICAgICAgICAgICBpZihBLnggPT0gQi54ICYmIEEueiA9PSBCLnopIC8vIEl0IGRvbid0IG5lZWQgcm90YXRpb24gYXJvdW5kIFlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgQUggPSBCLnotQS56O1xuICAgICAgICAgICAgICAgIEFCID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhCLnotQS56LCAyKStcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coQi54LUEueCwgMilcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoQUgvQUIpO1xuICAgICAgICAgICAgICAgIC8vaWYgKGFuZ2xlID4gTWF0aC5QSS8yKVxuICAgICAgICAgICAgICAgICAgICAvL2FuZ2xlID0gLSgoTWF0aC5QSS8yKS1hbmdsZSlcbiAgICAgICAgICAgICAgICBpZiAoQi54IDwgQS54KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCQUJZTE9OLkF4aXMuWiA6XG4gICAgICAgICAgICAgICAgaWYoQS54ID09IEIueCAmJiBBLnkgPT0gQi55KSAvLyBJdCBkb24ndCBuZWVkIHJvdGF0aW9uIGFyb3VuZCBaXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBBSCA9IEIueC1BLng7XG4gICAgICAgICAgICAgICAgQUIgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KEIueC1BLngsIDIpK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhCLnktQS55LCAyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoQUgvQUIpO1xuICAgICAgICAgICAgICAgIGlmIChCLnkgPCBBLnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFuZ2xlRnJvbVBvaW50cygpIDogZ2V0IGFuIGFuZ2xlIGZyb20gMyBwb2ludHMgZm9yIGEgcm90YXRpb24gYXJvdW5kIGFuIGF4aXNcbiAgICAgKiAgb3J0aG9nb25hbCBvZiB0aGUgcGxhbiBmb3JtZWQgYnkgdGhlIDMgcG9pbnRzXG4gICAgICogICAgICAtIEEgKEJBQllMT04uVmVjdG9yMykgOiBGaXJzdCBwb2ludFxuICAgICAqICAgICAgLSBCIChCQUJZTE9OLlZlY3RvcjMpIDogU2Vjb25kIHBvaW50XG4gICAgICogICAgICAtIEggKEJBQllMT04uVmVjdG9yMykgOiBPcnRob2dvbmFsIHByb2plY3Rpb24gb2YgQiBvdmVyIHRoZSBheGlzXG4gICAgICpcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgd2l0aCBhIHJvdGF0aW9uIGFyb3VuZCB6IGF4aXNcbiAgICAgKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgXyB4XG4gICAgICogICAgICAgLi0+ICAgICAgICAgICB8XG4gICAgICogICAgICAvICAgICAgICAgICAgSCAqICAgICAqIEJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgIC9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHwgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfC8gICAgICAgICAgICAgICB5XG4gICAgICogICAgICAgLS0tLS0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0tPlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfEFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKlxuICAgICAqIE5CIDogSXQgaXMgdXNlZCB3aGVuIHdlIGRvbid0IGhhdmUgZXNwZWNpYWxseSBjbGFzc2ljYWwgZ2xvYmFsIGF4aXMuIEZvciBleGFtcGxlXG4gICAgICogYWZ0ZXIgYSBmaXJzdCByb3RhdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmFuZ2xlRnJvbVBvaW50cyA9IGZ1bmN0aW9uIChBLCBCLCBIKSB7XG4gICAgICAgIHZhciBBSCA9IEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZShBLCBIKTtcbiAgICAgICAgdmFyIEFCID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKEEsIEIpO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFjb3MoQUgvQUIpO1xuXG4gICAgICAgIC8vIENoZWNrIHRoZSBzaWduXG4gICAgICAgIGlmIChILnggPCBCLngpXG4gICAgICAgICAgICByZXR1cm4gLWFuZ2xlO1xuICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgfTtcblxuICAgIFJBTkRPLlV0aWxzLnJvdW5kUmVjdCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3LCBoLCByYWRpdXMpIHtcbiAgICAgICAgdmFyIHIgPSB4ICsgdztcbiAgICAgICAgdmFyIGIgPSB5ICsgaDtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGg9XCI0XCI7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgrcmFkaXVzLCB5KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oci1yYWRpdXMsIHkpO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ociwgeSwgciwgeStyYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyLCB5K2gtcmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHIsIGIsIHItcmFkaXVzLCBiKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCtyYWRpdXMsIGIpO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeCwgYiwgeCwgYi1yYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5K3JhZGl1cyk7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4K3JhZGl1cywgeSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpXG4gICAgfTtcblxuICAgIC8qKnRlc3RlZFxuICAgICAqICBzY2FsZUFycmF5MigpIDogbXVsdGlwbHkgYWxsIHZhbHVlcyBvZiAyLWRpbWVuc2lvbnMgYXJyYXkgYnkgYSBzY2FsZSB2YWx1ZVxuICAgICAqICAgICAgLSBhcnJheTIgOiBvcmlnaW5hbCBhcnJheVxuICAgICAqICAgICAgLSBzY2FsZSA6IHNjYWxlIHZhbHVlXG4gICAgICpcbiAgICAgKiByZXR1cm4gYSBuZXcgYXJyYXkgd2hpY2ggY29udGFpbnMgYWxsIHZhbHVlcyBvZiBhcnJheTIgbXVsdGlwbGllZFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnNjYWxlQXJyYXkyID0gZnVuY3Rpb24gKGFycmF5Miwgc2NhbGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciByb3cgaW4gYXJyYXkyKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgY29sIGluIGFycmF5Mltyb3ddKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGFycmF5Mltyb3ddW2NvbF0gKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cblxuICAgIC8qKioqICAgIEdFVFRFUlMgICAgICoqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKip0ZXN0ZWRcbiAgICAgKiBnZXRVcmxGcm9tQ29vcmRpbmF0ZXMoKTogZ2V0IHRoZSB1cmwgb2YgYSB0aWxlIHRleHR1cmVcbiAgICAgKiAgICAgIHogOiBsZXZlbCBvZiB6b29tXG4gICAgICogICAgICB4IDogeCBjb29yZGluYXRlcyBvZiB0aWxlXG4gICAgICogICAgICB5IDogeSBjb29yZGluYXRlcyBvZiB0aWxlXG4gICAgICpcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5yZXBsYWNlVXJsQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAodXJsLCB6LCB4LCB5KSB7XG4gICAgICAgIHZhciBzdWJkb21haW5zID0gUkFORE8uU0VUVElOR1MuVElMRV9URVhfVVJMX1NVQkRPTUFJTlMsXG4gICAgICAgICAgICBpbmRleCA9IE1hdGguYWJzKHggKyB5KSAlIHN1YmRvbWFpbnMubGVuZ3RoLFxuICAgICAgICAgICAgc3ViZG9tYWluID0gc3ViZG9tYWluc1tpbmRleF07XG5cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXCJ7c31cIiwgc3ViZG9tYWluKTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXCJ7en1cIiwgeik7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFwie3h9XCIsIHgpO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcInt5fVwiLCB5KTtcblxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuXG4gICAgLyoqKiogICAgQ09OVkVSU0lPTlMgICAgICoqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKip0ZXN0ZWRcbiAgICAgKiB0b01ldGVycygpIDogY29udmVydCBhIHBvaW50IGluIGxhdGl0dWRlL2xvbmdpdHVkZSB0byB4L3kgbWV0ZXJzIGNvb3JkaW5hdGVzXG4gICAgICogICAgICAtIGxhdGxuZyA6IHBvaW50IGluIGxhdC9sbmdcbiAgICAgKlxuICAgICAqIHJldHVybiBhIHBvaW50IGluIG1ldGVyc1xuICAgICAqXG4gICAgICogeyBsYXQgOiAuLiAsIGxuZyA6IC4uIH0gIC0tLT4geyB4IDogLi4gLCB5IDogLi4gfVxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnRvTWV0ZXJzID0gZnVuY3Rpb24gKGxhdGxuZykge1xuXG4gICAgICAgIHZhciBSID0gNjM3ODEzNztcblxuICAgICAgICB2YXIgZCA9IE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciBtYXggPSAxIC0gMSpNYXRoLnBvdygxMCwgLTE1KTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGgubWF4KE1hdGgubWluKE1hdGguc2luKGxhdGxuZy5sYXQgKiBkKSwgbWF4KSwgLW1heCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHggOiBSICogbGF0bG5nLmxuZyAqIGQsXG4gICAgICAgICAgICB5IDogUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKnRlc3RlZFxuICAgICAqIHRvTGF0bG5nKCkgOiBjb252ZXJ0IGEgcG9pbnQgaW4geC95IG1ldGVycyBjb29yZGluYXRlcyB0byBsYXRpdHVkZS9sb25naXR1ZGVcbiAgICAgKiAgICAgIC0gcG9pbnQgOiBwb2ludCBpbiB4L3kgbWV0ZXJzIGNvb3JkaW5hdGVzXG4gICAgICpcbiAgICAgKiByZXR1cm4gYSBwb2ludCBpbiBsYXQvbG9uZ1xuICAgICAqXG4gICAgICogeyB4IDogLi4gLCB5IDogLi4gfSAgLS0tPiAgeyBsYXQgOiAuLiAsIGxuZyA6IC4uIH1cbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy50b0xhdGxuZyA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgICAgIHZhciBSID0gNjM3ODEzNztcblxuICAgICAgICB2YXIgZCA9IDE4MCAvIE1hdGguUEk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhdDogKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIFIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcbiAgICAgICAgICAgIGxuZzogcG9pbnQueCAqIGQgLyBSXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0TWV0ZXJzRXh0ZW50KCkgOiBnZXQgdGhlIGV4dGVudCBvZiB0aGUgREVNIGluIG1ldGVyc1xuICAgICAqICAgICAgLSBleHRlbnQgOiBleHRlbnQgb2YgdGhlIERFTSBpbiBsYXRpdHVkZXMvbG9uZ2l0dWRlc1xuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmdldE1ldGVyc0V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQpIHtcbiAgICAgICAgdmFyIG53ID0gUkFORE8uVXRpbHMudG9NZXRlcnMoZXh0ZW50Lm5vcnRod2VzdCk7XG4gICAgICAgIHZhciBuZSA9IFJBTkRPLlV0aWxzLnRvTWV0ZXJzKGV4dGVudC5ub3J0aGVhc3QpO1xuICAgICAgICB2YXIgc3cgPSBSQU5ETy5VdGlscy50b01ldGVycyhleHRlbnQuc291dGh3ZXN0KTtcbiAgICAgICAgdmFyIHNlID0gUkFORE8uVXRpbHMudG9NZXRlcnMoZXh0ZW50LnNvdXRoZWFzdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd4JyA6IHtcbiAgICAgICAgICAgICAgICAnbWluJyA6IE1hdGgubWluKG53LngsIHN3LngpLFxuICAgICAgICAgICAgICAgICdtYXgnIDogTWF0aC5taW4obmUueCwgc2UueClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAneScgOiBleHRlbnQuYWx0aXR1ZGVzLFxuICAgICAgICAgICAgJ3onIDoge1xuICAgICAgICAgICAgICAgICdtaW4nIDogTWF0aC5taW4oc3cueSwgc2UueSksXG4gICAgICAgICAgICAgICAgJ21heCcgOiBNYXRoLm1pbihudy55LCBuZS55KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtZXRlcnMybnVtKCk6IGdldCB0aGUgdGlsZSBudW1iZXIgb2YgdGhlIHRpbGUgY29udGFpbmluZyBhIHBvaW50XG4gICAgICogIGluIGEgY2VydGFpbiBsZXZlbCBvZiB6b29tXG4gICAgICogICAgICAtIHg6IHggY29vcmRpbmF0ZSBvZiBwb2ludCAoaW4gbWV0ZXJzKVxuICAgICAqICAgICAgLSB5OiB5IGNvb3JkaW5hdGUgb2YgcG9pbnQgKGluIG1ldGVycylcbiAgICAgKiAgICAgIC0gem9vbTogem9vbSBsZXZlbFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLm1ldGVyczJudW0gPSBmdW5jdGlvbiAoeCwgeSwgem9vbSkge1xuICAgICAgICB2YXIgdG1wX2xsID0gUkFORE8uVXRpbHMudG9MYXRsbmcoe1xuICAgICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICAgJ3knOiB5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUkFORE8uVXRpbHMuZGVnMm51bSh0bXBfbGwubGF0LCB0bXBfbGwubG5nLCB6b29tKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVnMm51bSgpOiBnZXQgdGhlIHRpbGUgbnVtYmVyIG9mIHRoZSB0aWxlIGNvbnRhaW5pbmcgYSBwb2ludFxuICAgICAqICBpbiBhIGNlcnRhaW4gbGV2ZWwgb2Ygem9vbVxuICAgICAqICAgICAgLSBsYXRfZGVnOiBsYXRpdHVkZSAgY29vcmRpbmF0ZSBvZiBwb2ludCAoaW4gZGVncmVlcylcbiAgICAgKiAgICAgIC0gbG5nX2RlZzogbG9uZ2l0dWRlIGNvb3JkaW5hdGUgb2YgcG9pbnQgKGluIGRlZ3JlZXMpXG4gICAgICogICAgICAtIHpvb206IHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5kZWcybnVtID0gZnVuY3Rpb24gKGxhdF9kZWcsIGxuZ19kZWcsIHpvb20pIHtcbiAgICAgICAgdmFyIGxhdF9yYWQgPSBsYXRfZGVnKk1hdGguUEkvMTgwO1xuICAgICAgICB2YXIgbiA9IE1hdGgucG93KDIuMCwgem9vbSk7XG4gICAgICAgIHZhciB4dGlsZSA9IE1hdGguZmxvb3IoKGxuZ19kZWcgKyAxODAuMCkgLyAzNjAuMCAqIG4pO1xuICAgICAgICB2YXIgeXRpbGUgPSBNYXRoLmZsb29yKCgxLjAgLSBNYXRoLmxvZyhNYXRoLnRhbihsYXRfcmFkKSArICgxIC8gTWF0aC5jb3MobGF0X3JhZCkpKSAvIE1hdGguUEkpIC8gMi4wICogbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInh0aWxlXCI6IHh0aWxlLFxuICAgICAgICAgICAgXCJ5dGlsZVwiOiB5dGlsZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByYWQybnVtKCk6IGdldCB0aGUgdGlsZSBudW1iZXIgb2YgdGhlIHRpbGUgY29udGFpbmluZyBhIHBvaW50XG4gICAgICogIGluIGEgY2VydGFpbiBsZXZlbCBvZiB6b29tXG4gICAgICogICAgICAtIGxhdF9yYWQ6IGxhdGl0dWRlICBjb29yZGluYXRlIG9mIHBvaW50IChpbiByYWRpYW5zKVxuICAgICAqICAgICAgLSBsbmdfcmFkOiBsb25naXR1ZGUgY29vcmRpbmF0ZSBvZiBwb2ludCAoaW4gcmFkaWFucylcbiAgICAgKiAgICAgIC0gem9vbTogem9vbSBsZXZlbFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnJhZDJudW0gPSBmdW5jdGlvbiAobGF0X3JhZCwgbG5nX3JhZCwgem9vbSkge1xuICAgICAgICB2YXIgbGF0X2RlZyA9IGxhdF9yYWQqMTgwL01hdGguUEk7XG4gICAgICAgIHZhciBsbmdfZGVnID0gbG5nX3JhZCoxODAvTWF0aC5QSTtcbiAgICAgICAgdmFyIG4gPSBNYXRoLnBvdygyLjAsIHpvb20pO1xuICAgICAgICB2YXIgeHRpbGUgPSBNYXRoLmZsb29yKChsbmdfZGVnICsgMTgwLjApIC8gMzYwLjAgKiBuKTtcbiAgICAgICAgdmFyIHl0aWxlID0gTWF0aC5mbG9vcigoMS4wIC0gTWF0aC5sb2coTWF0aC50YW4obGF0X3JhZCkgKyAoMSAvIE1hdGguY29zKGxhdF9yYWQpKSkgLyBNYXRoLlBJKSAvIDIuMCAqIG4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ4dGlsZVwiOiB4dGlsZSxcbiAgICAgICAgICAgIFwieXRpbGVcIjogeXRpbGVcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICAvKioqKiAgICBUUkFOU0xBVElPTlMgICAgICoqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiBkcmFwZVBvaW50KCkgOiBkcmFwZSBhIHBvaW50IG92ZXIgdGhlIGdyb3VuZFxuICAgICAqICAgICAgLSBwb2ludDogcG9pbnQgdG8gZHJhcGVcbiAgICAgKiAgICAgIC0gZGVtOiBncm91bmRcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5kcmFwZVBvaW50ID0gZnVuY3Rpb24gKHBvaW50LCBkZW0sIG9mZnNldCkge1xuICAgICAgICB2YXIgaXQ7XG4gICAgICAgIGlmICh0eXBlb2Yob2Zmc2V0KSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZGVtLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciByYXkgPSAgbmV3IEJBQllMT04uUmF5KHBvaW50LCBCQUJZTE9OLkF4aXMuWSk7XG4gICAgICAgIGZvciAoaXQgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBwaWNrID0gY2hpbGRyZW5baXRdLmludGVyc2VjdHMocmF5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChwaWNrLnBpY2tlZFBvaW50KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQueSA9IHBpY2sucGlja2VkUG9pbnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcbiIsIi8qIVxuICogVkVSU0lPTjogYmV0YSAxLjMuNFxuICogREFURTogMjAxNC0xMS0xNVxuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL3d3dy5ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0XHR2YXIgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0X3IxID0gW10sXG5cdFx0XHRfcjIgPSBbXSxcblx0XHRcdF9yMyA9IFtdLFxuXHRcdFx0X2NvclByb3BzID0ge30sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0U2VnbWVudCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0dGhpcy5hID0gYTtcblx0XHRcdFx0dGhpcy5iID0gYjtcblx0XHRcdFx0dGhpcy5jID0gYztcblx0XHRcdFx0dGhpcy5kID0gZDtcblx0XHRcdFx0dGhpcy5kYSA9IGQgLSBhO1xuXHRcdFx0XHR0aGlzLmNhID0gYyAtIGE7XG5cdFx0XHRcdHRoaXMuYmEgPSBiIC0gYTtcblx0XHRcdH0sXG5cdFx0XHRfY29ycmVsYXRlID0gXCIseCx5LHosbGVmdCx0b3AscmlnaHQsYm90dG9tLG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxwYWRkaW5nTGVmdCxwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLGJhY2tncm91bmRQb3NpdGlvbixiYWNrZ3JvdW5kUG9zaXRpb25feSxcIixcblx0XHRcdGN1YmljVG9RdWFkcmF0aWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHZhciBxMSA9IHthOmF9LFxuXHRcdFx0XHRcdHEyID0ge30sXG5cdFx0XHRcdFx0cTMgPSB7fSxcblx0XHRcdFx0XHRxNCA9IHtjOmR9LFxuXHRcdFx0XHRcdG1hYiA9IChhICsgYikgLyAyLFxuXHRcdFx0XHRcdG1iYyA9IChiICsgYykgLyAyLFxuXHRcdFx0XHRcdG1jZCA9IChjICsgZCkgLyAyLFxuXHRcdFx0XHRcdG1hYmMgPSAobWFiICsgbWJjKSAvIDIsXG5cdFx0XHRcdFx0bWJjZCA9IChtYmMgKyBtY2QpIC8gMixcblx0XHRcdFx0XHRtOCA9IChtYmNkIC0gbWFiYykgLyA4O1xuXHRcdFx0XHRxMS5iID0gbWFiICsgKGEgLSBtYWIpIC8gNDtcblx0XHRcdFx0cTIuYiA9IG1hYmMgKyBtODtcblx0XHRcdFx0cTEuYyA9IHEyLmEgPSAocTEuYiArIHEyLmIpIC8gMjtcblx0XHRcdFx0cTIuYyA9IHEzLmEgPSAobWFiYyArIG1iY2QpIC8gMjtcblx0XHRcdFx0cTMuYiA9IG1iY2QgLSBtODtcblx0XHRcdFx0cTQuYiA9IG1jZCArIChkIC0gbWNkKSAvIDQ7XG5cdFx0XHRcdHEzLmMgPSBxNC5hID0gKHEzLmIgKyBxNC5iKSAvIDI7XG5cdFx0XHRcdHJldHVybiBbcTEsIHEyLCBxMywgcTRdO1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oYSwgY3VydmluZXNzLCBxdWFkLCBiYXNpYywgY29ycmVsYXRlKSB7XG5cdFx0XHRcdHZhciBsID0gYS5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdGlpID0gMCxcblx0XHRcdFx0XHRjcDEgPSBhWzBdLmEsXG5cdFx0XHRcdFx0aSwgcDEsIHAyLCBwMywgc2VnLCBtMSwgbTIsIG1tLCBjcDIsIHFiLCByMSwgcjIsIHRsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdFx0cDEgPSBzZWcuYTtcblx0XHRcdFx0XHRwMiA9IHNlZy5kO1xuXHRcdFx0XHRcdHAzID0gYVtpaSsxXS5kO1xuXG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cjEgPSBfcjFbaV07XG5cdFx0XHRcdFx0XHRyMiA9IF9yMltpXTtcblx0XHRcdFx0XHRcdHRsID0gKChyMiArIHIxKSAqIGN1cnZpbmVzcyAqIDAuMjUpIC8gKGJhc2ljID8gMC41IDogX3IzW2ldIHx8IDAuNSk7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIxICE9PSAwID8gdGwgLyByMSA6IDApKTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjIgIT09IDAgPyB0bCAvIHIyIDogMCkpO1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArICgoKG0yIC0gbTEpICogKChyMSAqIDMgLyAocjEgKyByMikpICsgMC41KSAvIDQpIHx8IDApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgbTIpIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bTEgKz0gbW07XG5cdFx0XHRcdFx0bTIgKz0gbW07XG5cblx0XHRcdFx0XHRzZWcuYyA9IGNwMiA9IG0xO1xuXHRcdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDEgPSBzZWcuYSArIChzZWcuYyAtIHNlZy5hKSAqIDAuNjsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYiBvbiBhIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYyBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlSW4gb3IgRWxhc3RpYy5lYXNlSW4gd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGJlZ2lubmluZywgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWcuZGEgPSBwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5jYSA9IGNwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHAxO1xuXG5cdFx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhwMSwgY3AxLCBjcDIsIHAyKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdFx0XHRpaSArPSA0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpaSsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNwMSA9IG0yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0c2VnLmMgPSBjcDEgKyAoc2VnLmQgLSBjcDEpICogMC40OyAvL2luc3RlYWQgb2YgcGxhY2luZyBjIG9uIGQgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBiIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoaWNoIGdvZXMgQkVZT05EIHRoZSBlbmQsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdHNlZy5kYSA9IHNlZy5kIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5jYSA9IHNlZy5jIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHNlZy5hO1xuXHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhzZWcuYSwgY3AxLCBzZWcuYywgc2VnLmQpO1xuXHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VBbmNob3JzID0gZnVuY3Rpb24odmFsdWVzLCBwLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsLCBpLCBwMSwgcDIsIHAzLCB0bXA7XG5cdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHRcdGkgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tpXVtwXSkgKSA9PT0gXCJzdHJpbmdcIikgaWYgKHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tpXVtwXSA9IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpOyAvL2FjY29tbW9kYXRlIHJlbGF0aXZlIHZhbHVlcy4gRG8gaXQgaW5saW5lIGluc3RlYWQgb2YgYnJlYWtpbmcgaXQgb3V0IGludG8gYSBmdW5jdGlvbiBmb3Igc3BlZWQgcmVhc29uc1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDI7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdGFbMF0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbMF1bcF0sIDAsIDAsIHZhbHVlc1sobCA8IC0xKSA/IDAgOiAxXVtwXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHAxID0gdmFsdWVzW2ldW3BdO1xuXHRcdFx0XHRcdHAyID0gdmFsdWVzW2krMV1bcF07XG5cdFx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHAxLCAwLCAwLCBwMik7XG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cDMgPSB2YWx1ZXNbaSsyXVtwXTtcblx0XHRcdFx0XHRcdF9yMVtpXSA9IChfcjFbaV0gfHwgMCkgKyAocDIgLSBwMSkgKiAocDIgLSBwMSk7XG5cdFx0XHRcdFx0XHRfcjJbaV0gPSAoX3IyW2ldIHx8IDApICsgKHAzIC0gcDIpICogKHAzIC0gcDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQodmFsdWVzW2ldW3BdLCAwLCAwLCB2YWx1ZXNbaSsxXVtwXSk7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdGJlemllclRocm91Z2ggPSBmdW5jdGlvbih2YWx1ZXMsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGZpcnN0ID0gcHJlcGVuZCB8fCB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0aSwgcCwgYSwgaiwgciwgbCwgc2VhbWxlc3MsIGxhc3Q7XG5cdFx0XHRcdGNvcnJlbGF0ZSA9ICh0eXBlb2YoY29ycmVsYXRlKSA9PT0gXCJzdHJpbmdcIikgPyBcIixcIitjb3JyZWxhdGUrXCIsXCIgOiBfY29ycmVsYXRlO1xuXHRcdFx0XHRpZiAoY3VydmluZXNzID09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJ2aW5lc3MgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMgYXJlIGlkZW50aWNhbCAod2VsbCwgd2l0aGluIDAuMDUpLiBJZiBzbywgbWFrZSBzZWFtbGVzcyBieSBhcHBlbmRpbmcgdGhlIHNlY29uZCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdmFsdWVzIGFycmF5IGFuZCB0aGUgMm5kLXRvLWxhc3QgZWxlbWVudCB0byB0aGUgdmVyeSBiZWdpbm5pbmcgKHdlJ2xsIHJlbW92ZSB0aG9zZSBzZWdtZW50cyBsYXRlcilcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0c2VhbWxlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoZmlyc3RbcF0gLSBsYXN0W3BdKSA+IDAuMDUpIHsgLy9idWlsZCBpbiBhIHRvbGVyYW5jZSBvZiArLy0wLjA1IHRvIGFjY29tbW9kYXRlIHJvdW5kaW5nIGVycm9ycy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBzZXQgYW4gb2JqZWN0J3MgcG9zaXRpb24gdG8gNC45NDUsIEZsYXNoIHdpbGwgbWFrZSBpdCA0Ljlcblx0XHRcdFx0XHRcdFx0c2VhbWxlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzLmNvbmNhdCgpOyAvL2R1cGxpY2F0ZSB0aGUgYXJyYXkgdG8gYXZvaWQgY29udGFtaW5hdGluZyB0aGUgb3JpZ2luYWwgd2hpY2ggdGhlIHVzZXIgbWF5IGJlIHJldXNpbmcgZm9yIG90aGVyIHR3ZWVuc1xuXHRcdFx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnVuc2hpZnQocHJlcGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZXNbMV0pO1xuXHRcdFx0XHRcdFx0cHJlcGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gM107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9yMS5sZW5ndGggPSBfcjIubGVuZ3RoID0gX3IzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRfY29yUHJvcHNbcF0gPSAoY29ycmVsYXRlLmluZGV4T2YoXCIsXCIrcCtcIixcIikgIT09IC0xKTtcblx0XHRcdFx0XHRvYmpbcF0gPSBfcGFyc2VBbmNob3JzKHZhbHVlcywgcCwgX2NvclByb3BzW3BdLCBwcmVwZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gX3IxLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0X3IxW2ldID0gTWF0aC5zcXJ0KF9yMVtpXSk7XG5cdFx0XHRcdFx0X3IyW2ldID0gTWF0aC5zcXJ0KF9yMltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFiYXNpYykge1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2NvclByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSBvYmpbcHJvcHNbaV1dO1xuXHRcdFx0XHRcdFx0XHRsID0gYS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ciA9IGFbaisxXS5kYSAvIF9yMltqXSArIGFbal0uZGEgLyBfcjFbal07XG5cdFx0XHRcdFx0XHRcdFx0X3IzW2pdID0gKF9yM1tqXSB8fCAwKSArIHIgKiByO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGkgPSBfcjMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0X3IzW2ldID0gTWF0aC5zcXJ0KF9yM1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdGogPSBxdWFkcmF0aWMgPyA0IDogMTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdGEgPSBvYmpbcF07XG5cdFx0XHRcdFx0X2NhbGN1bGF0ZUNvbnRyb2xQb2ludHMoYSwgY3VydmluZXNzLCBxdWFkcmF0aWMsIGJhc2ljLCBfY29yUHJvcHNbcF0pOyAvL3RoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgX3BhcnNlQW5jaG9ycygpIGFuZCBfc2V0U2VnbWVudFJhdGlvcygpIHJhbiBmaXJzdCBzbyB0aGF0IF9yMSwgX3IyLCBhbmQgX3IzIHZhbHVlcyBhcmUgcG9wdWxhdGVkIGZvciBhbGwgcHJvcGVydGllc1xuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoMCwgaik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShhLmxlbmd0aCAtIGosIGopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUJlemllckRhdGEgPSBmdW5jdGlvbih2YWx1ZXMsIHR5cGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJzb2Z0XCI7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRpbmMgPSAodHlwZSA9PT0gXCJjdWJpY1wiKSA/IDMgOiAyLFxuXHRcdFx0XHRcdHNvZnQgPSAodHlwZSA9PT0gXCJzb2Z0XCIpLFxuXHRcdFx0XHRcdHByb3BzID0gW10sXG5cdFx0XHRcdFx0YSwgYiwgYywgZCwgY3VyLCBpLCBqLCBsLCBwLCBjbnQsIHRtcDtcblx0XHRcdFx0aWYgKHNvZnQgJiYgcHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFsdWVzID09IG51bGwgfHwgdmFsdWVzLmxlbmd0aCA8IGluYyArIDEpIHsgdGhyb3cgXCJpbnZhbGlkIEJlemllciBkYXRhXCI7IH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdG9ialtwXSA9IGN1ciA9IFtdO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0YSA9IChwcmVwZW5kID09IG51bGwpID8gdmFsdWVzW2pdW3BdIDogKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tqXVtwXSkgKSA9PT0gXCJzdHJpbmdcIiAmJiB0bXAuY2hhckF0KDEpID09PSBcIj1cIikgPyBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKSA6IE51bWJlcih0bXApO1xuXHRcdFx0XHRcdFx0aWYgKHNvZnQpIGlmIChqID4gMSkgaWYgKGogPCBsIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRjdXJbY250KytdID0gKGEgKyBjdXJbY250LTJdKSAvIDI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJbY250KytdID0gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bCA9IGNudCAtIGluYyArIDE7XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaiArPSBpbmMpIHtcblx0XHRcdFx0XHRcdGEgPSBjdXJbal07XG5cdFx0XHRcdFx0XHRiID0gY3VyW2orMV07XG5cdFx0XHRcdFx0XHRjID0gY3VyW2orMl07XG5cdFx0XHRcdFx0XHRkID0gKGluYyA9PT0gMikgPyAwIDogY3VyW2orM107XG5cdFx0XHRcdFx0XHRjdXJbY250KytdID0gdG1wID0gKGluYyA9PT0gMykgPyBuZXcgU2VnbWVudChhLCBiLCBjLCBkKSA6IG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VyLmxlbmd0aCA9IGNudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSxcblx0XHRcdF9hZGRDdWJpY0xlbmd0aHMgPSBmdW5jdGlvbihhLCBzdGVwcywgcmVzb2x1dGlvbikge1xuXHRcdFx0XHR2YXIgaW5jID0gMSAvIHJlc29sdXRpb24sXG5cdFx0XHRcdFx0aiA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGQsIGQxLCBzLCBkYSwgY2EsIGJhLCBwLCBpLCBpbnYsIGJleiwgaW5kZXg7XG5cdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdGJleiA9IGFbal07XG5cdFx0XHRcdFx0cyA9IGJlei5hO1xuXHRcdFx0XHRcdGRhID0gYmV6LmQgLSBzO1xuXHRcdFx0XHRcdGNhID0gYmV6LmMgLSBzO1xuXHRcdFx0XHRcdGJhID0gYmV6LmIgLSBzO1xuXHRcdFx0XHRcdGQgPSBkMSA9IDA7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8PSByZXNvbHV0aW9uOyBpKyspIHtcblx0XHRcdFx0XHRcdHAgPSBpbmMgKiBpO1xuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHA7XG5cdFx0XHRcdFx0XHRkID0gZDEgLSAoZDEgPSAocCAqIHAgKiBkYSArIDMgKiBpbnYgKiAocCAqIGNhICsgaW52ICogYmEpKSAqIHApO1xuXHRcdFx0XHRcdFx0aW5kZXggPSBqICogcmVzb2x1dGlvbiArIGkgLSAxO1xuXHRcdFx0XHRcdFx0c3RlcHNbaW5kZXhdID0gKHN0ZXBzW2luZGV4XSB8fCAwKSArIGQgKiBkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUxlbmd0aERhdGEgPSBmdW5jdGlvbihvYmosIHJlc29sdXRpb24pIHtcblx0XHRcdFx0cmVzb2x1dGlvbiA9IHJlc29sdXRpb24gPj4gMCB8fCA2O1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGxlbmd0aHMgPSBbXSxcblx0XHRcdFx0XHRkID0gMCxcblx0XHRcdFx0XHR0b3RhbCA9IDAsXG5cdFx0XHRcdFx0dGhyZXNob2xkID0gcmVzb2x1dGlvbiAtIDEsXG5cdFx0XHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdFx0XHRjdXJMUyA9IFtdLCAvL2N1cnJlbnQgbGVuZ3RoIHNlZ21lbnRzIGFycmF5XG5cdFx0XHRcdFx0cCwgaSwgbCwgaW5kZXg7XG5cdFx0XHRcdGZvciAocCBpbiBvYmopIHtcblx0XHRcdFx0XHRfYWRkQ3ViaWNMZW5ndGhzKG9ialtwXSwgYSwgcmVzb2x1dGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZCArPSBNYXRoLnNxcnQoYVtpXSk7XG5cdFx0XHRcdFx0aW5kZXggPSBpICUgcmVzb2x1dGlvbjtcblx0XHRcdFx0XHRjdXJMU1tpbmRleF0gPSBkO1xuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHR0b3RhbCArPSBkO1xuXHRcdFx0XHRcdFx0aW5kZXggPSAoaSAvIHJlc29sdXRpb24pID4+IDA7XG5cdFx0XHRcdFx0XHRzZWdtZW50c1tpbmRleF0gPSBjdXJMUztcblx0XHRcdFx0XHRcdGxlbmd0aHNbaW5kZXhdID0gdG90YWw7XG5cdFx0XHRcdFx0XHRkID0gMDtcblx0XHRcdFx0XHRcdGN1ckxTID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7bGVuZ3RoOnRvdGFsLCBsZW5ndGhzOmxlbmd0aHMsIHNlZ21lbnRzOnNlZ21lbnRzfTtcblx0XHRcdH0sXG5cblxuXG5cdFx0XHRCZXppZXJQbHVnaW4gPSBfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdFx0XHRwcm9wTmFtZTogXCJiZXppZXJcIixcblx0XHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdFx0dmVyc2lvbjogXCIxLjMuNFwiLFxuXHRcdFx0XHRcdEFQSTogMixcblx0XHRcdFx0XHRnbG9iYWw6dHJ1ZSxcblxuXHRcdFx0XHRcdC8vZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRpZiAodmFycyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdHZhcnMgPSB7dmFsdWVzOnZhcnN9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fZnVuYyA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcm91bmQgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lUmVzID0gKHZhcnMudGltZVJlc29sdXRpb24gPT0gbnVsbCkgPyA2IDogcGFyc2VJbnQodmFycy50aW1lUmVzb2x1dGlvbiwgMTApO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhcnMudmFsdWVzIHx8IFtdLFxuXHRcdFx0XHRcdFx0XHRmaXJzdCA9IHt9LFxuXHRcdFx0XHRcdFx0XHRzZWNvbmQgPSB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0XHRcdGF1dG9Sb3RhdGUgPSB2YXJzLmF1dG9Sb3RhdGUgfHwgdHdlZW4udmFycy5vcmllbnRUb0Jlemllcixcblx0XHRcdFx0XHRcdFx0cCwgaXNGdW5jLCBpLCBqLCBwcmVwZW5kO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA/IChhdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXkpID8gYXV0b1JvdGF0ZSA6IFtbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLCgoYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKGF1dG9Sb3RhdGUpIHx8IDApXV0gOiBudWxsO1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIHNlY29uZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHRpc0Z1bmMgPSB0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpO1xuXHRcdFx0XHRcdFx0XHRmaXJzdFtwXSA9ICghaXNGdW5jKSA/IHBhcnNlRmxvYXQodGFyZ2V0W3BdKSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFwcmVwZW5kKSBpZiAoZmlyc3RbcF0gIT09IHZhbHVlc1swXVtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXBlbmQgPSBmaXJzdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fYmV6aWVycyA9ICh2YXJzLnR5cGUgIT09IFwiY3ViaWNcIiAmJiB2YXJzLnR5cGUgIT09IFwicXVhZHJhdGljXCIgJiYgdmFycy50eXBlICE9PSBcInNvZnRcIikgPyBiZXppZXJUaHJvdWdoKHZhbHVlcywgaXNOYU4odmFycy5jdXJ2aW5lc3MpID8gMSA6IHZhcnMuY3VydmluZXNzLCBmYWxzZSwgKHZhcnMudHlwZSA9PT0gXCJ0aHJ1QmFzaWNcIiksIHZhcnMuY29ycmVsYXRlLCBwcmVwZW5kKSA6IF9wYXJzZUJlemllckRhdGEodmFsdWVzLCB2YXJzLnR5cGUsIGZpcnN0KTtcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ0NvdW50ID0gdGhpcy5fYmV6aWVyc1twXS5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZCA9IF9wYXJzZUxlbmd0aERhdGEodGhpcy5fYmV6aWVycywgdGhpcy5fdGltZVJlcyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aCA9IGxkLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RocyA9IGxkLmxlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnRzID0gbGQuc2VnbWVudHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gdGhpcy5fbGkgPSB0aGlzLl9zMSA9IHRoaXMuX3NpID0gMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSB0aGlzLl9sZW5ndGhzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSB0aGlzLl9zZWdtZW50c1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSB0aGlzLl9jdXJTZWdbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3ByZWMgPSAxIC8gdGhpcy5fY3VyU2VnLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChhdXRvUm90YXRlID0gdGhpcy5fYXV0b1JvdGF0ZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9ucyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIShhdXRvUm90YXRlWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPSBbYXV0b1JvdGF0ZV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSA9IGF1dG9Sb3RhdGUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVtqXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV0gPSB0aGlzLl9mdW5jW3BdID8gdGhpcy5fZnVuY1twXS5jYWxsKHRoaXMuX3RhcmdldCkgOiB0aGlzLl90YXJnZXRbcF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0UmF0aW8gPSB0d2Vlbi52YXJzLnJ1bkJhY2t3YXJkcyA/IDEgOiAwOyAvL3dlIGRldGVybWluZSB0aGUgc3RhcnRpbmcgcmF0aW8gd2hlbiB0aGUgdHdlZW4gaW5pdHMgd2hpY2ggaXMgYWx3YXlzIDAgdW5sZXNzIHRoZSB0d2VlbiBoYXMgcnVuQmFja3dhcmRzOnRydWUgKGluZGljYXRpbmcgaXQncyBhIGZyb20oKSB0d2VlbikgaW4gd2hpY2ggY2FzZSBpdCdzIDEuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ0NvdW50LFxuXHRcdFx0XHRcdFx0XHRmdW5jID0gdGhpcy5fZnVuYyxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRub3RTdGFydCA9ICh2ICE9PSB0aGlzLl9zdGFydFJhdGlvKSxcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXgsIGludiwgaSwgcCwgYiwgdCwgdmFsLCBsLCBsZW5ndGhzLCBjdXJTZWc7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSAodiA8IDApID8gMCA6ICh2ID49IDEpID8gc2VnbWVudHMgLSAxIDogKHNlZ21lbnRzICogdikgPj4gMDtcblx0XHRcdFx0XHRcdFx0dCA9ICh2IC0gKGN1ckluZGV4ICogKDEgLyBzZWdtZW50cykpKSAqIHNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGVuZ3RocyA9IHRoaXMuX2xlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdGN1clNlZyA9IHRoaXMuX2N1clNlZztcblx0XHRcdFx0XHRcdFx0diAqPSB0aGlzLl9sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9saTtcblx0XHRcdFx0XHRcdFx0Ly9maW5kIHRoZSBhcHByb3ByaWF0ZSBzZWdtZW50IChpZiB0aGUgY3VycmVudGx5IGNhY2hlZCBvbmUgaXNuJ3QgY29ycmVjdClcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9sMiAmJiBpIDwgc2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IHNlZ21lbnRzIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX2wyID0gbGVuZ3Roc1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSBsZW5ndGhzW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnWyh0aGlzLl9zMSA9IHRoaXMuX3NpID0gMCldO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9sMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fbDEgPSBsZW5ndGhzWy0taV0pID49IHYpIHsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9sMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gbGVuZ3Roc1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbKHRoaXMuX3NpID0gY3VyU2VnLmxlbmd0aCAtIDEpIC0gMV0gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1t0aGlzLl9zaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHQvL25vdyBmaW5kIHRoZSBhcHByb3ByaWF0ZSBzdWItc2VnbWVudCAod2Ugc3BsaXQgaXQgaW50byB0aGUgbnVtYmVyIG9mIHBpZWNlcyB0aGF0IHdhcyBkZWZpbmVkIGJ5IFwicHJlY2lzaW9uXCIgYW5kIG1lYXN1cmVkIGVhY2ggb25lKVxuXHRcdFx0XHRcdFx0XHR2IC09IHRoaXMuX2wxO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fc2k7XG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fczIgJiYgaSA8IGN1clNlZy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IGN1clNlZy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fczIgPSBjdXJTZWdbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9zMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fczEgPSBjdXJTZWdbLS1pXSkgPj0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9zMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0ID0gKGkgKyAodiAtIHRoaXMuX3MxKSAvICh0aGlzLl9zMiAtIHRoaXMuX3MxKSkgKiB0aGlzLl9wcmVjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHQ7XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1twXVtjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdHZhbCA9ICh0ICogdCAqIGIuZGEgKyAzICogaW52ICogKHQgKiBiLmNhICsgaW52ICogYi5iYSkpICogdCArIGIuYTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3JvdW5kW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl9hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhciA9IHRoaXMuX2F1dG9Sb3RhdGUsXG5cdFx0XHRcdFx0XHRcdFx0YjIsIHgxLCB5MSwgeDIsIHkyLCBhZGQsIGNvbnY7XG5cdFx0XHRcdFx0XHRcdGkgPSBhci5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBhcltpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHRhZGQgPSBhcltpXVszXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSAoYXJbaV1bNF0gPT09IHRydWUpID8gMSA6IF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzBdXTtcblx0XHRcdFx0XHRcdFx0XHRiMiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMV1dO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGIgJiYgYjIpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgcHJvcGVydGllcyBnb3Qgb3ZlcndyaXR0ZW4uXG5cdFx0XHRcdFx0XHRcdFx0XHRiID0gYltjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdFx0XHRiMiA9IGIyW2N1ckluZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eDEgPSBiLmEgKyAoYi5iIC0gYi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiA9IGIuYiArIChiLmMgLSBiLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgxICs9ICh4MiAtIHgxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiArPSAoKGIuYyArIChiLmQgLSBiLmMpICogdCkgLSB4MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR5MSA9IGIyLmEgKyAoYjIuYiAtIGIyLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyID0gYjIuYiArIChiMi5jIC0gYjIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTEgKz0gKHkyIC0geTEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyICs9ICgoYjIuYyArIChiMi5kIC0gYjIuYykgKiB0KSAtIHkyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IG5vdFN0YXJ0ID8gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIGNvbnYgKyBhZGQgOiB0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZnVuY1twXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSA9IHZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdHAgPSBCZXppZXJQbHVnaW4ucHJvdG90eXBlO1xuXG5cblx0XHRCZXppZXJQbHVnaW4uYmV6aWVyVGhyb3VnaCA9IGJlemllclRocm91Z2g7XG5cdFx0QmV6aWVyUGx1Z2luLmN1YmljVG9RdWFkcmF0aWMgPSBjdWJpY1RvUXVhZHJhdGljO1xuXHRcdEJlemllclBsdWdpbi5fYXV0b0NTUyA9IHRydWU7IC8vaW5kaWNhdGVzIHRoYXQgdGhpcyBwbHVnaW4gY2FuIGJlIGluc2VydGVkIGludG8gdGhlIFwiY3NzXCIgb2JqZWN0IHVzaW5nIHRoZSBhdXRvQ1NTIGZlYXR1cmUgb2YgVHdlZW5MaXRlXG5cdFx0QmV6aWVyUGx1Z2luLnF1YWRyYXRpY1RvQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdH07XG5cblx0XHRCZXppZXJQbHVnaW4uX2Nzc1JlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgQ1NTUGx1Z2luID0gX2dsb2JhbHMuQ1NTUGx1Z2luO1xuXHRcdFx0aWYgKCFDU1NQbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIF9pbnRlcm5hbHMgPSBDU1NQbHVnaW4uX2ludGVybmFscyxcblx0XHRcdFx0X3BhcnNlVG9Qcm94eSA9IF9pbnRlcm5hbHMuX3BhcnNlVG9Qcm94eSxcblx0XHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8sXG5cdFx0XHRcdENTU1Byb3BUd2VlbiA9IF9pbnRlcm5hbHMuQ1NTUHJvcFR3ZWVuO1xuXHRcdFx0X2ludGVybmFscy5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiZXppZXJcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwcm9wLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRlID0ge3ZhbHVlczplfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbHVnaW4gPSBuZXcgQmV6aWVyUGx1Z2luKCk7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBlLnZhbHVlcyxcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzID0gW10sXG5cdFx0XHRcdFx0diA9IHt9LFxuXHRcdFx0XHRcdGksIHAsIGRhdGE7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRcdGRhdGEgPSBfcGFyc2VUb1Byb3h5KHQsIHZhbHVlc1tpXSwgY3NzcCwgcHQsIHBsdWdpbiwgKGwgIT09IGkpKTtcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXNbaV0gPSBkYXRhLmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gZSkge1xuXHRcdFx0XHRcdHZbcF0gPSBlW3BdOyAvL2R1cGxpY2F0ZSB0aGUgdmFycyBvYmplY3QgYmVjYXVzZSB3ZSBuZWVkIHRvIGFsdGVyIHNvbWUgdGhpbmdzIHdoaWNoIHdvdWxkIGNhdXNlIHByb2JsZW1zIGlmIHRoZSB1c2VyIHBsYW5zIHRvIHJldXNlIHRoZSBzYW1lIHZhcnMgb2JqZWN0IGZvciBhbm90aGVyIHR3ZWVuLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHYudmFsdWVzID0gcGx1Z2luVmFsdWVzO1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgXCJiZXppZXJcIiwgMCwgMCwgZGF0YS5wdCwgMik7XG5cdFx0XHRcdHB0LmRhdGEgPSBkYXRhO1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldFBsdWdpblJhdGlvO1xuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlID09PSAwKSB7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlICYmICEodi5hdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0aSA9ICh2LmF1dG9Sb3RhdGUgPT09IHRydWUpID8gMCA6IE51bWJlcih2LmF1dG9Sb3RhdGUpO1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IChkYXRhLmVuZC5sZWZ0ICE9IG51bGwpID8gW1tcImxlZnRcIixcInRvcFwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiAoZGF0YS5lbmQueCAhPSBudWxsKSA/IFtbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRpZiAoIWNzc3AuX3RyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0Y3NzcC5fZW5hYmxlVHJhbnNmb3JtcyhmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEuYXV0b1JvdGF0ZSA9IGNzc3AuX3RhcmdldC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luLl9vbkluaXRUd2VlbihkYXRhLnByb3h5LCB2LCBjc3NwLl90d2Vlbik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH19KTtcblx0XHR9O1xuXG5cdFx0cC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCwgdmFsdWUpIHtcblx0XHRcdHZhciBvcCA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRpID0gb3AubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsb29rdXBbb3BbaV1dIHx8IGxvb2t1cC5iZXppZXIgfHwgbG9va3VwLmJlemllclRocm91Z2gpIHtcblx0XHRcdFx0XHR0aGlzLl9yb3VuZFtvcFtpXV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX3Byb3BzLFxuXHRcdFx0XHRwLCBpO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2JlemllcnMpIHtcblx0XHRcdFx0aWYgKHAgaW4gbG9va3VwKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2JlemllcnNbcF07XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2Z1bmNbcF07XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKGFbaV0gPT09IHApIHtcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3VwZXIuX2tpbGwuY2FsbCh0aGlzLCBsb29rdXApO1xuXHRcdH07XG5cbn0pOyBpZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH1cblxuLy9leHBvcnQgdG8gQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZSAocHJlY3Vyc29yIHRvIGZ1bGwgbW9kdWxhciBidWlsZCBzeXN0ZW0gY29taW5nIGF0IGEgbGF0ZXIgZGF0ZSlcbihmdW5jdGlvbihuYW1lKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIChfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzIHx8IF9nc1Njb3BlKVtuYW1lXTtcblx0fTtcblx0aWYgKHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgeyAvL0FNRFxuXHRcdGRlZmluZShbXCJUd2VlbkxpdGVcIl0sIGdldEdsb2JhbCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9ub2RlXG5cdFx0cmVxdWlyZShcIi4uL1R3ZWVuTGl0ZS5qc1wiKTtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdldEdsb2JhbCgpO1xuXHR9XG59KFwiQmV6aWVyUGx1Z2luXCIpKTtcbiIsIi8qIVxuICogVkVSU0lPTjogYmV0YSAwLjIuMVxuICogREFURTogMjAxNC0wNy0xN1xuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL3d3dy5ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0cHJvcE5hbWU6IFwiZGlyZWN0aW9uYWxSb3RhdGlvblwiLFxuXHRcdHZlcnNpb246IFwiMC4yLjFcIixcblx0XHRBUEk6IDIsXG5cblx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YWx1ZSA9IHtyb3RhdGlvbjp2YWx1ZX07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbmFscyA9IHt9O1xuXHRcdFx0dmFyIGNhcCA9ICh2YWx1ZS51c2VSYWRpYW5zID09PSB0cnVlKSA/IE1hdGguUEkgKiAyIDogMzYwLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0cCwgdiwgc3RhcnQsIGVuZCwgZGlmLCBzcGxpdDtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAocCAhPT0gXCJ1c2VSYWRpYW5zXCIpIHtcblx0XHRcdFx0XHRzcGxpdCA9ICh2YWx1ZVtwXSArIFwiXCIpLnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHR2ID0gc3BsaXRbMF07XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KCAodHlwZW9mKHRhcmdldFtwXSkgIT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbcF0gOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCkgKTtcblx0XHRcdFx0XHRlbmQgPSB0aGlzLmZpbmFsc1twXSA9ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHN0YXJ0ICsgcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IE51bWJlcih2KSB8fCAwO1xuXHRcdFx0XHRcdGRpZiA9IGVuZCAtIHN0YXJ0O1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHYgPSBzcGxpdC5qb2luKFwiX1wiKTtcblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaWYgPiBtaW4gfHwgZGlmIDwgLW1pbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzdGFydCwgc3RhcnQgKyBkaWYsIHApO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdHNldDogZnVuY3Rpb24ocmF0aW8pIHtcblx0XHRcdHZhciBwdDtcblx0XHRcdGlmIChyYXRpbyAhPT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsIHJhdGlvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odGhpcy5maW5hbHNbcHQucF0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdGhpcy5maW5hbHNbcHQucF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSkuX2F1dG9DU1MgPSB0cnVlO1xuXG59KTsgaWYgKF9nc1Njb3BlLl9nc0RlZmluZSkgeyBfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpOyB9IiwiLyohXG4gKiBWRVJTSU9OOiBiZXRhIDEuMTUuMlxuICogREFURTogMjAxNS0wMS0yN1xuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJlYXNpbmcuQmFja1wiLCBbXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oRWFzZSkge1xuXHRcdFxuXHRcdHZhciB3ID0gKF9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHMgfHwgX2dzU2NvcGUpLFxuXHRcdFx0Z3MgPSB3LmNvbS5ncmVlbnNvY2ssXG5cdFx0XHRfMlBJID0gTWF0aC5QSSAqIDIsXG5cdFx0XHRfSEFMRl9QSSA9IE1hdGguUEkgLyAyLFxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzLFxuXHRcdFx0X2NyZWF0ZSA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbigpe30sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyIHx8IGZ1bmN0aW9uKCl7fSwgLy9wdXQgYW4gZW1wdHkgZnVuY3Rpb24gaW4gcGxhY2UganVzdCBhcyBhIHNhZmV0eSBtZWFzdXJlIGluIGNhc2Ugc29tZW9uZSBsb2FkcyBhbiBPTEQgdmVyc2lvbiBvZiBUd2VlbkxpdGUuanMgd2hlcmUgRWFzZS5yZWdpc3RlciBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0X3dyYXAgPSBmdW5jdGlvbihuYW1lLCBFYXNlT3V0LCBFYXNlSW4sIEVhc2VJbk91dCwgYWxpYXNlcykge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCB7XG5cdFx0XHRcdFx0ZWFzZU91dDpuZXcgRWFzZU91dCgpLFxuXHRcdFx0XHRcdGVhc2VJbjpuZXcgRWFzZUluKCksXG5cdFx0XHRcdFx0ZWFzZUluT3V0Om5ldyBFYXNlSW5PdXQoKVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0X2Vhc2VSZWcoQywgbmFtZSk7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdEVhc2VQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHZhbHVlLCBuZXh0KSB7XG5cdFx0XHRcdHRoaXMudCA9IHRpbWU7XG5cdFx0XHRcdHRoaXMudiA9IHZhbHVlO1xuXHRcdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRcdHRoaXMubmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLmMgPSBuZXh0LnYgLSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLmdhcCA9IG5leHQudCAtIHRpbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vQmFja1xuXHRcdFx0X2NyZWF0ZUJhY2sgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMSA9IChvdmVyc2hvb3QgfHwgb3ZlcnNob290ID09PSAwKSA/IG92ZXJzaG9vdCA6IDEuNzAxNTg7XG5cdFx0XHRcdFx0XHR0aGlzLl9wMiA9IHRoaXMuX3AxICogMS41MjU7XG5cdFx0XHRcdFx0fSwgdHJ1ZSksIFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEMob3ZlcnNob290KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXG5cdFx0XHRCYWNrID0gX3dyYXAoXCJCYWNrXCIsXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCA9IHAgLSAxKSAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwICsgdGhpcy5fcDEpICsgMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHAgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCAtIHRoaXMuX3AxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBwICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgLSB0aGlzLl9wMikgOiAwLjUgKiAoKHAgLT0gMikgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCArIHRoaXMuX3AyKSArIDIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSxcblxuXG5cdFx0XHQvL1Nsb3dNb1xuXHRcdFx0U2xvd01vID0gX2NsYXNzKFwiZWFzaW5nLlNsb3dNb1wiLCBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRcdHBvd2VyID0gKHBvd2VyIHx8IHBvd2VyID09PSAwKSA/IHBvd2VyIDogMC43O1xuXHRcdFx0XHRpZiAobGluZWFyUmF0aW8gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMC43O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVhclJhdGlvID4gMSkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wID0gKGxpbmVhclJhdGlvICE9PSAxKSA/IHBvd2VyIDogMDtcblx0XHRcdFx0dGhpcy5fcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDI7XG5cdFx0XHRcdHRoaXMuX3AyID0gbGluZWFyUmF0aW87XG5cdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDEgKyB0aGlzLl9wMjtcblx0XHRcdFx0dGhpcy5fY2FsY0VuZCA9ICh5b3lvTW9kZSA9PT0gdHJ1ZSk7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdHAgPSBTbG93TW8ucHJvdG90eXBlID0gbmV3IEVhc2UoKSxcblx0XHRcdFN0ZXBwZWRFYXNlLCBSb3VnaEVhc2UsIF9jcmVhdGVFbGFzdGljO1xuXHRcdFx0XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNsb3dNbztcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHIgPSBwICsgKDAuNSAtIHApICogdGhpcy5fcDtcblx0XHRcdGlmIChwIDwgdGhpcy5fcDEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHApIDogciAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwICogcCAqIHAgKiByKTtcblx0XHRcdH0gZWxzZSBpZiAocCA+IHRoaXMuX3AzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwIDogciArICgocCAtIHIpICogKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgKiBwICogcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgOiByO1xuXHRcdH07XG5cdFx0U2xvd01vLmVhc2UgPSBuZXcgU2xvd01vKDAuNywgMC43KTtcblx0XHRcblx0XHRwLmNvbmZpZyA9IFNsb3dNby5jb25maWcgPSBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKTtcblx0XHR9O1xuXG5cblx0XHQvL1N0ZXBwZWRFYXNlXG5cdFx0U3RlcHBlZEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuU3RlcHBlZEVhc2VcIiwgZnVuY3Rpb24oc3RlcHMpIHtcblx0XHRcdFx0c3RlcHMgPSBzdGVwcyB8fCAxO1xuXHRcdFx0XHR0aGlzLl9wMSA9IDEgLyBzdGVwcztcblx0XHRcdFx0dGhpcy5fcDIgPSBzdGVwcyArIDE7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHRwID0gU3RlcHBlZEVhc2UucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcdFxuXHRcdHAuY29uc3RydWN0b3IgPSBTdGVwcGVkRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHAgPCAwKSB7XG5cdFx0XHRcdHAgPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChwID49IDEpIHtcblx0XHRcdFx0cCA9IDAuOTk5OTk5OTk5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICgodGhpcy5fcDIgKiBwKSA+PiAwKSAqIHRoaXMuX3AxO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBTdGVwcGVkRWFzZS5jb25maWcgPSBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0cmV0dXJuIG5ldyBTdGVwcGVkRWFzZShzdGVwcyk7XG5cdFx0fTtcblxuXG5cdFx0Ly9Sb3VnaEVhc2Vcblx0XHRSb3VnaEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuUm91Z2hFYXNlXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHRhcGVyID0gdmFycy50YXBlciB8fCBcIm5vbmVcIixcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwb2ludHMgPSAodmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdFx0aSA9IHBvaW50cyxcblx0XHRcdFx0cmFuZG9taXplID0gKHZhcnMucmFuZG9taXplICE9PSBmYWxzZSksXG5cdFx0XHRcdGNsYW1wID0gKHZhcnMuY2xhbXAgPT09IHRydWUpLFxuXHRcdFx0XHR0ZW1wbGF0ZSA9ICh2YXJzLnRlbXBsYXRlIGluc3RhbmNlb2YgRWFzZSkgPyB2YXJzLnRlbXBsYXRlIDogbnVsbCxcblx0XHRcdFx0c3RyZW5ndGggPSAodHlwZW9mKHZhcnMuc3RyZW5ndGgpID09PSBcIm51bWJlclwiKSA/IHZhcnMuc3RyZW5ndGggKiAwLjQgOiAwLjQsXG5cdFx0XHRcdHgsIHksIGJ1bXAsIGludlgsIG9iaiwgcG50O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogKDEgLyBwb2ludHMpICogaTtcblx0XHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUuZ2V0UmF0aW8oeCkgOiB4O1xuXHRcdFx0XHRpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdFx0aW52WCA9IDEgLSB4O1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0XHRidW1wID0geCAqIHggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh4IDwgMC41KSB7ICAvL1wiYm90aFwiIChzdGFydClcblx0XHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvL1wiYm90aFwiIChlbmQpXG5cdFx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0XHR5ICs9IChNYXRoLnJhbmRvbSgpICogYnVtcCkgLSAoYnVtcCAqIDAuNSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSAlIDIpIHtcblx0XHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSAtPSBidW1wICogMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGFtcCkge1xuXHRcdFx0XHRcdGlmICh5ID4gMSkge1xuXHRcdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5IDwgMCkge1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbY250KytdID0ge3g6eCwgeTp5fTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnggLSBiLng7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRcdGkgPSBwb2ludHM7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0b2JqID0gYVtpXTtcblx0XHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludChvYmoueCwgb2JqLnksIHBudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZXYgPSBuZXcgRWFzZVBvaW50KDAsIDAsIChwbnQudCAhPT0gMCkgPyBwbnQgOiBwbnQubmV4dCk7XG5cdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFJvdWdoRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBSb3VnaEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwbnQgPSB0aGlzLl9wcmV2O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcHJldiA9IHBudDtcblx0XHRcdHJldHVybiAocG50LnYgKyAoKHAgLSBwbnQudCkgLyBwbnQuZ2FwKSAqIHBudC5jKTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBSb3VnaEVhc2UodmFycyk7XG5cdFx0fTtcblx0XHRSb3VnaEVhc2UuZWFzZSA9IG5ldyBSb3VnaEVhc2UoKTtcblxuXG5cdFx0Ly9Cb3VuY2Vcblx0XHRfd3JhcChcIkJvdW5jZVwiLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKChwID0gMSAtIHApIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiBwICogcCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1KTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0dmFyIGludmVydCA9IChwIDwgMC41KTtcblx0XHRcdFx0aWYgKGludmVydCkge1xuXHRcdFx0XHRcdHAgPSAxIC0gKHAgKiAyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gKHAgKiAyKSAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpbnZlcnQgPyAoMSAtIHApICogMC41IDogcCAqIDAuNSArIDAuNTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9DSVJDXG5cdFx0X3dyYXAoXCJDaXJjXCIsXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtIChwID0gcCAtIDEpICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIChwICogcCkpIC0gMSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwKj0yKSA8IDEpID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHAgKiBwKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKHAgLT0gMikgKiBwKSArIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0VsYXN0aWNcblx0XHRfY3JlYXRlRWxhc3RpYyA9IGZ1bmN0aW9uKG4sIGYsIGRlZikge1xuXHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRcdHRoaXMuX3AxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDE7IC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRcdFx0dGhpcy5fcDIgPSAocGVyaW9kIHx8IGRlZikgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpO1xuXHRcdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gdGhpcy5fcDEpIHx8IDApO1xuXHRcdFx0XHRcdHRoaXMuX3AyID0gXzJQSSAvIHRoaXMuX3AyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQyhhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIEM7XG5cdFx0fTtcblx0XHRfd3JhcChcIkVsYXN0aWNcIixcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSArIDE7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLSh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSk7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAtMC41ICogKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMikpIDogdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKihwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKiAwLjUgKyAxO1xuXHRcdFx0fSwgMC40NSlcblx0XHQpO1xuXG5cblx0XHQvL0V4cG9cblx0XHRfd3JhcChcIkV4cG9cIixcblx0XHRcdF9jcmVhdGUoXCJFeHBvT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9JblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIC0gMC4wMDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vU2luZVxuXHRcdF93cmFwKFwiU2luZVwiLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4ocCAqIF9IQUxGX1BJKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtTWF0aC5jb3MocCAqIF9IQUxGX1BJKSArIDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogcCkgLSAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdF9jbGFzcyhcImVhc2luZy5FYXNlTG9va3VwXCIsIHtcblx0XHRcdFx0ZmluZDpmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVhc2UubWFwW3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblxuXHRcdC8vcmVnaXN0ZXIgdGhlIG5vbi1zdGFuZGFyZCBlYXNlc1xuXHRcdF9lYXNlUmVnKHcuU2xvd01vLCBcIlNsb3dNb1wiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFJvdWdoRWFzZSwgXCJSb3VnaEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhTdGVwcGVkRWFzZSwgXCJTdGVwcGVkRWFzZVwiLCBcImVhc2UsXCIpO1xuXHRcdFxuXHRcdHJldHVybiBCYWNrO1xuXHRcdFxuXHR9LCB0cnVlKTtcblxufSk7IGlmIChfZ3NTY29wZS5fZ3NEZWZpbmUpIHsgX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKTsgfSIsIi8qIVxuICogVkVSU0lPTjogMS4xNi4xXG4gKiBEQVRFOiAyMDE1LTAzLTEzXG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVMaXRlXCIsIFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKEFuaW1hdGlvbiwgU2ltcGxlVGltZWxpbmUsIFR3ZWVuTGl0ZSkge1xuXG5cdFx0dmFyIFRpbWVsaW5lTGl0ZSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0U2ltcGxlVGltZWxpbmUuY2FsbCh0aGlzLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gKHRoaXMudmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLnNtb290aENoaWxkVGltaW5nID0gKHRoaXMudmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3NvcnRDaGlsZHJlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuXHRcdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0XHR2YWwsIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2KSB7XG5cdFx0XHRcdFx0dmFsID0gdltwXTtcblx0XHRcdFx0XHRpZiAoX2lzQXJyYXkodmFsKSkgaWYgKHZhbC5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR2W3BdID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzQXJyYXkodi50d2VlbnMpKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGQodi50d2VlbnMsIDAsIHYuYWxpZ24sIHYuc3RhZ2dlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2ludGVybmFscyA9IFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzID0ge30sXG5cdFx0XHRfaXNTZWxlY3RvciA9IFR3ZWVuTGl0ZUludGVybmFscy5pc1NlbGVjdG9yLFxuXHRcdFx0X2lzQXJyYXkgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNBcnJheSxcblx0XHRcdF9sYXp5VHdlZW5zID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMsXG5cdFx0XHRfbGF6eVJlbmRlciA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5UmVuZGVyLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfY29weSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0dmFyIGNvcHkgPSB7fSwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29weTtcblx0XHRcdH0sXG5cdFx0XHRfcGF1c2VDYWxsYmFjayA9IF9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayA9IGZ1bmN0aW9uKHR3ZWVuLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0XHR2YXIgdGwgPSB0d2Vlbi5fdGltZWxpbmUsXG5cdFx0XHRcdFx0dGltZSA9IHRsLl90b3RhbFRpbWUsXG5cdFx0XHRcdFx0c3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZSxcblx0XHRcdFx0XHRyZXZlcnNlZCA9ICh0d2Vlbi5fcmF3UHJldlRpbWUgPCAwIHx8ICh0d2Vlbi5fcmF3UHJldlRpbWUgPT09IDAgJiYgdGwuX3JldmVyc2VkKSksLy9kb24ndCB1c2UgdHdlZW4ucmF0aW8gYmVjYXVzZSBpZiB0aGUgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBvbiB0b3Agb2YgdGhlIGFkZFBhdXNlKCksIHJhdGlvIHdpbGwgYmUgMSBldmVuIGlmIHRoZSBtYXN0ZXIgdGltZWxpbmUgd2FzIHJldmVyc2VkICh3aGljaCBpcyBjb3JyZWN0KS4gVGhlIGtleSBoZXJlIGlzIHRvIHNlbnNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBsYXloZWFkLlxuXHRcdFx0XHRcdG5leHQgPSByZXZlcnNlZCA/IDAgOiBfdGlueU51bSxcblx0XHRcdFx0XHRwcmV2ID0gcmV2ZXJzZWQgPyBfdGlueU51bSA6IDAsXG5cdFx0XHRcdFx0c2libGluZztcblx0XHRcdFx0aWYgKGNhbGxiYWNrIHx8ICF0aGlzLl9mb3JjaW5nUGxheWhlYWQpIHsgLy9pZiB0aGUgdXNlciBjYWxscyBhIG1ldGhvZCB0aGF0IG1vdmVzIHRoZSBwbGF5aGVhZCAobGlrZSBwcm9ncmVzcygpIG9yIHRpbWUoKSksIGl0IHNob3VsZCBob25vciB0aGF0IGFuZCBza2lwIGFueSBwYXVzZXMgKGFsdGhvdWdoIGlmIHRoZXJlJ3MgYSBjYWxsYmFjayBwb3NpdGlvbmVkIGF0IHRoYXQgcGF1c2UsIGl0IG11c3QganVtcCB0aGVyZSBhbmQgbWFrZSB0aGUgY2FsbCB0byBlbnN1cmUgdGhlIHRpbWUgaXMgRVhBQ1RMWSB3aGF0IGl0IGlzIHN1cHBvc2VkIHRvIGJlLCBhbmQgdGhlbiBwcm9jZWVkIHRvIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBiZWluZyBmb3JjZWQpLiBPdGhlcndpc2UsIGltYWdpbmUgcGxhY2luZyBhIHBhdXNlIGluIHRoZSBtaWRkbGUgb2YgYSB0aW1lbGluZSBhbmQgdGhlbiBkb2luZyB0aW1lbGluZS5wcm9ncmVzcygwLjkpIC0gaXQgd291bGQgZ2V0IHN0dWNrIHdoZXJlIHRoZSBwYXVzZSBpcy5cblx0XHRcdFx0XHR0bC5wYXVzZShzdGFydFRpbWUpO1xuXHRcdFx0XHRcdC8vbm93IGZpbmQgc2libGluZyB0d2VlbnMgdGhhdCBhcmUgRVhBQ1RMWSBhdCB0aGUgc2FtZSBzcG90IG9uIHRoZSB0aW1lbGluZSBhbmQgYWRqdXN0IHRoZSBfcmF3UHJldlRpbWUgc28gdGhhdCB0aGV5IGZpcmUgKG9yIGRvbid0IGZpcmUpIGNvcnJlY3RseSBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaXMgaXMgcHJpbWFyaWx5IHRvIGFjY29tbW9kYXRlIHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyB0aGF0IGFyZSBwb3NpdGlvbmVkIHJpZ2h0IG9uIHRvcCBvZiBhIHBhdXNlLiBGb3IgZXhhbXBsZSwgdGwudG8oLi4uKS5jYWxsKC4uLikuYWRkUGF1c2UoLi4uKS5jYWxsKC4uLikgLSBub3RpY2UgdGhhdCB0aGVyZSdzIGEgY2FsbCgpIG9uIGVhY2ggc2lkZSBvZiB0aGUgcGF1c2UsIHNvIHdoZW4gaXQncyBydW5uaW5nIGZvcndhcmQgaXQgc2hvdWxkIGNhbGwgdGhlIGZpcnN0IG9uZSBhbmQgdGhlbiBwYXVzZSwgYW5kIHRoZW4gd2hlbiByZXN1bWVkLCBjYWxsIHRoZSBvdGhlci4gWmVyby1kdXJhdGlvbiB0d2VlbnMgdXNlIF9yYXdQcmV2VGltZSB0byBzZW5zZSBtb21lbnR1bSBmaWd1cmUgb3V0IGlmIGV2ZW50cyB3ZXJlIHN1cHByZXNzZWQgd2hlbiBhcnJpdmluZyBkaXJlY3RseSBvbiB0b3Agb2YgdGhhdCB0aW1lLlxuXHRcdFx0XHRcdHNpYmxpbmcgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0XHR3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLl9zdGFydFRpbWUgPT09IHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0c2libGluZy5fcmF3UHJldlRpbWUgPSBwcmV2O1xuXHRcdFx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcuX3ByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNpYmxpbmcgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHR3aGlsZSAoc2libGluZyAmJiBzaWJsaW5nLl9zdGFydFRpbWUgPT09IHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0c2libGluZy5fcmF3UHJldlRpbWUgPSBuZXh0O1xuXHRcdFx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoc2NvcGUgfHwgdGwsIHBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9mb3JjaW5nUGxheWhlYWQgfHwgIXRsLl9wYXVzZWQpIHsgLy90aGUgY2FsbGJhY2sgY291bGQgaGF2ZSBjYWxsZWQgcmVzdW1lKCkuXG5cdFx0XHRcdFx0XHR0bC5zZWVrKHRpbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRwID0gVGltZWxpbmVMaXRlLnByb3RvdHlwZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpO1xuXG5cdFx0VGltZWxpbmVMaXRlLnZlcnNpb24gPSBcIjEuMTYuMVwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZUxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gcC5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cblx0XHQvKiBtaWdodCB1c2UgbGF0ZXIuLi5cblx0XHQvL3RyYW5zbGF0ZXMgYSBsb2NhbCB0aW1lIGluc2lkZSBhbiBhbmltYXRpb24gdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUsIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlcy5cblx0XHRmdW5jdGlvbiBsb2NhbFRvR2xvYmFsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHR0aW1lID0gKHRpbWUgLyBhbmltYXRpb24uX3RpbWVTY2FsZSkgKyBhbmltYXRpb24uX3N0YXJ0VGltZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXG5cdFx0Ly90cmFuc2xhdGVzIHRoZSBzdXBwbGllZCB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHRpbWUgaW5zaWRlIGEgcGFydGljdWxhciBhbmltYXRpb24sIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlc1xuXHRcdGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdFx0dGltZSAtPSBsb2NhbFRvR2xvYmFsKDAsIGFuaW1hdGlvbik7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHNjYWxlICo9IGFuaW1hdGlvbi5fdGltZVNjYWxlO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZSAqIHNjYWxlO1xuXHRcdH1cblx0XHQqL1xuXG5cdFx0cC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggbmV3IEVuZ2luZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB2YXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoICgodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZSkuZnJvbSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHRvVmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBFbmdpbmUuZnJvbVRvKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHRvVmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHtvbkNvbXBsZXRlOm9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVQYXJhbXM6b25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZVNjb3BlOm9uQ29tcGxldGVBbGxTY29wZSwgc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkgeyAvL3NlbnNlcyBpZiB0aGUgdGFyZ2V0cyBvYmplY3QgaXMgYSBzZWxlY3Rvci4gSWYgaXQgaXMsIHdlIHNob3VsZCB0cmFuc2xhdGUgaXQgaW50byBhbiBhcnJheS5cblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdH1cblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodmFycy5zdGFydEF0KSB7XG5cdFx0XHRcdFx0dmFycy5zdGFydEF0ID0gX2NvcHkodmFycy5zdGFydEF0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bC50byh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgX2NvcHkodmFycyksIGkgKiBzdGFnZ2VyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0bCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblxuXHRcdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwb3NpdGlvbikge1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlKTtcblx0XHRcdGlmICh2YXJzLmltbWVkaWF0ZVJlbmRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHBvc2l0aW9uID09PSB0aGlzLl90aW1lICYmICF0aGlzLl9wYXVzZWQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0VGltZWxpbmVMaXRlLmV4cG9ydFJvb3QgPSBmdW5jdGlvbih2YXJzLCBpZ25vcmVEZWxheWVkQ2FsbHMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0aWYgKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUodmFycyksXG5cdFx0XHRcdHJvb3QgPSB0bC5fdGltZWxpbmUsXG5cdFx0XHRcdHR3ZWVuLCBuZXh0O1xuXHRcdFx0aWYgKGlnbm9yZURlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGlnbm9yZURlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyb290Ll9yZW1vdmUodGwsIHRydWUpO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IDA7XG5cdFx0XHR0bC5fcmF3UHJldlRpbWUgPSB0bC5fdGltZSA9IHRsLl90b3RhbFRpbWUgPSByb290Ll90aW1lO1xuXHRcdFx0dHdlZW4gPSByb290Ll9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdGlmICghaWdub3JlRGVsYXllZENhbGxzIHx8ICEodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUgJiYgdHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSB7XG5cdFx0XHRcdFx0dGwuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRyb290LmFkZCh0bCwgMCk7XG5cdFx0XHRyZXR1cm4gdGw7XG5cdFx0fTtcblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIGN1clRpbWUsIGwsIGksIGNoaWxkLCB0bCwgYmVmb3JlUmF3VGltZTtcblx0XHRcdGlmICh0eXBlb2YocG9zaXRpb24pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG5cdFx0XHRcdGlmICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHRcdGFsaWduID0gYWxpZ24gfHwgXCJub3JtYWxcIjtcblx0XHRcdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0XHRcdGN1clRpbWUgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRsID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChfaXNBcnJheShjaGlsZCA9IHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZCA9IG5ldyBUaW1lbGluZUxpdGUoe3R3ZWVuczpjaGlsZH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5hZGQoY2hpbGQsIGN1clRpbWUpO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihjaGlsZCkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mKGNoaWxkKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGlnbiA9PT0gXCJzZXF1ZW5jZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGNoaWxkLl9zdGFydFRpbWUgLT0gY2hpbGQuZGVsYXkoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyVGltZSArPSBzdGFnZ2VyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGFiZWwodmFsdWUsIHBvc2l0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3coXCJDYW5ub3QgYWRkIFwiICsgdmFsdWUgKyBcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdmFsdWUsIHBvc2l0aW9uKTtcblxuXHRcdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgdGhpcy5fdGltZSA9PT0gdGhpcy5fZHVyYXRpb24pIGlmICghdGhpcy5fcGF1c2VkKSBpZiAodGhpcy5fZHVyYXRpb24gPCB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0XHR0bCA9IHRoaXM7XG5cdFx0XHRcdGJlZm9yZVJhd1RpbWUgPSAodGwucmF3VGltZSgpID4gdmFsdWUuX3N0YXJ0VGltZSk7IC8vaWYgdGhlIHR3ZWVuIGlzIHBsYWNlZCBvbiB0aGUgdGltZWxpbmUgc28gdGhhdCBpdCBzdGFydHMgQkVGT1JFIHRoZSBjdXJyZW50IHJhd1RpbWUsIHdlIHNob3VsZCBhbGlnbiB0aGUgcGxheWhlYWQgKG1vdmUgdGhlIHRpbWVsaW5lKS4gVGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB1c2VycyB3aWxsIGNyZWF0ZSBhIHRpbWVsaW5lLCBsZXQgaXQgZmluaXNoLCBhbmQgbXVjaCBsYXRlciBhcHBlbmQgYSB0d2VlbiBhbmQgZXhwZWN0IGl0IHRvIHJ1biBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gaXRzIGVuZCBzdGF0ZS4gV2hpbGUgdGVjaG5pY2FsbHkgb25lIGNvdWxkIGFyZ3VlIHRoYXQgaXQgc2hvdWxkIGp1bXAgdG8gaXRzIGVuZCBzdGF0ZSwgdGhhdCdzIG5vdCB3aGF0IHVzZXJzIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdGlmIChiZWZvcmVSYXdUaW1lICYmIHRsLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRsLl9nYykge1xuXHRcdFx0XHRcdFx0dGwuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZW1vdmUodmFsdWUsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdHZhciBpID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZSh2YWx1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwodmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMua2lsbChudWxsLCB2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0U2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9yZW1vdmUuY2FsbCh0aGlzLCB0d2Vlbiwgc2tpcERpc2FibGUpO1xuXHRcdFx0dmFyIGxhc3QgPSB0aGlzLl9sYXN0O1xuXHRcdFx0aWYgKCFsYXN0KSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID4gbGFzdC5fc3RhcnRUaW1lICsgbGFzdC5fdG90YWxEdXJhdGlvbiAvIGxhc3QuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldE9yTGFiZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB2YWx1ZSkpO1xuXHRcdH07XG5cblx0XHRwLmluc2VydCA9IHAuaW5zZXJ0TXVsdGlwbGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHBvc2l0aW9uIHx8IDAsIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKHR3ZWVucywgb2Zmc2V0T3JMYWJlbCwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0d2VlbnMsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdHdlZW5zKSwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hZGRQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0dmFyIHQgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgX3BhdXNlQ2FsbGJhY2ssIFtcIntzZWxmfVwiLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZV0sIHRoaXMpO1xuXHRcdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7IC8vIHdlIHVzZSB0aGlzIGZsYWcgaW4gVHdlZW5MaXRlJ3MgcmVuZGVyKCkgbWV0aG9kIHRvIGlkZW50aWZ5IGl0IGFzIGEgc3BlY2lhbCBjYXNlIHRoYXQgc2hvdWxkbid0IGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2aXJ0dWFsIHBsYXloZWFkIGlzIExFQVZJTkcgdGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSBwYXVzZSBpcywgb3RoZXJ3aXNlIHRpbWVsaW5lLmFkZFBhdXNlKDEpLnBsYXkoMSkgd291bGQgZW5kIHVwIHBhdXNlZCBvbiB0aGUgdmVyeSBuZXh0IHRpY2suXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sYWJlbHNbbGFiZWxdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxUaW1lID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiAodGhpcy5fbGFiZWxzW2xhYmVsXSAhPSBudWxsKSA/IHRoaXMuX2xhYmVsc1tsYWJlbF0gOiAtMTtcblx0XHR9O1xuXG5cdFx0cC5fcGFyc2VUaW1lT3JMYWJlbCA9IGZ1bmN0aW9uKHRpbWVPckxhYmVsLCBvZmZzZXRPckxhYmVsLCBhcHBlbmRJZkFic2VudCwgaWdub3JlKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdC8vaWYgd2UncmUgYWJvdXQgdG8gYWRkIGEgdHdlZW4vdGltZWxpbmUgKG9yIGFuIGFycmF5IG9mIHRoZW0pIHRoYXQncyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIHJlbW92ZSBpdCBmaXJzdCBzbyB0aGF0IGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGR1cmF0aW9uKCkuXG5cdFx0XHRpZiAoaWdub3JlIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHR0aGlzLnJlbW92ZShpZ25vcmUpO1xuXHRcdFx0fSBlbHNlIGlmIChpZ25vcmUgJiYgKChpZ25vcmUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKGlnbm9yZS5wdXNoICYmIF9pc0FycmF5KGlnbm9yZSkpKSkge1xuXHRcdFx0XHRpID0gaWdub3JlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGlnbm9yZVtpXSBpbnN0YW5jZW9mIEFuaW1hdGlvbiAmJiBpZ25vcmVbaV0udGltZWxpbmUgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG9mZnNldE9yTGFiZWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG9mZnNldE9yTGFiZWwsIChhcHBlbmRJZkFic2VudCAmJiB0eXBlb2YodGltZU9yTGFiZWwpID09PSBcIm51bWJlclwiICYmIHRoaXMuX2xhYmVsc1tvZmZzZXRPckxhYmVsXSA9PSBudWxsKSA/IHRpbWVPckxhYmVsIC0gdGhpcy5kdXJhdGlvbigpIDogMCwgYXBwZW5kSWZBYnNlbnQpO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0T3JMYWJlbCA9IG9mZnNldE9yTGFiZWwgfHwgMDtcblx0XHRcdGlmICh0eXBlb2YodGltZU9yTGFiZWwpID09PSBcInN0cmluZ1wiICYmIChpc05hTih0aW1lT3JMYWJlbCkgfHwgdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSAhPSBudWxsKSkgeyAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuXHRcdFx0XHRpID0gdGltZU9yTGFiZWwuaW5kZXhPZihcIj1cIik7XG5cdFx0XHRcdGlmIChpID09PSAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhcHBlbmRJZkFic2VudCA/ICh0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdID0gdGhpcy5kdXJhdGlvbigpICsgb2Zmc2V0T3JMYWJlbCkgOiBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSArIG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2Zmc2V0T3JMYWJlbCA9IHBhcnNlSW50KHRpbWVPckxhYmVsLmNoYXJBdChpLTEpICsgXCIxXCIsIDEwKSAqIE51bWJlcih0aW1lT3JMYWJlbC5zdWJzdHIoaSsxKSk7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gKGkgPiAxKSA/IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwodGltZU9yTGFiZWwuc3Vic3RyKDAsIGktMSksIDAsIGFwcGVuZElmQWJzZW50KSA6IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH0gZWxzZSBpZiAodGltZU9yTGFiZWwgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1iZXIodGltZU9yTGFiZWwpICsgb2Zmc2V0T3JMYWJlbDtcblx0XHR9O1xuXG5cdFx0cC5zZWVrID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoKHR5cGVvZihwb3NpdGlvbikgPT09IFwibnVtYmVyXCIpID8gcG9zaXRpb24gOiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKSwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSkpO1xuXHRcdH07XG5cblx0XHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZShwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0cHJldlN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRwcmV2VGltZVNjYWxlID0gdGhpcy5fdGltZVNjYWxlLFxuXHRcdFx0XHRwcmV2UGF1c2VkID0gdGhpcy5fcGF1c2VkLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2U7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1cikge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICh0aW1lID09PSAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lIDwgMCB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmICh0aGlzLl9yYXdQcmV2VGltZSAhPT0gdGltZSAmJiB0aGlzLl9maXJzdCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fcmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR0aW1lID0gdG90YWxEdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgLSBzb21ldGltZXMgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcyB3ZXJlIG5vdCBiZWluZyBmdWxseSBjb21wbGV0ZWQgKHRoZWlyIHByb2dyZXNzIG1pZ2h0IGJlIDAuOTk5OTk5OTk5OTk5OTk4IGluc3RlYWQgb2YgMSBiZWNhdXNlIHdoZW4gX3RpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lIGlzIHBlcmZvcm1lZCwgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdvdWxkIHJldHVybiBhIHZhbHVlIHRoYXQgd2FzIFNMSUdIVExZIG9mZikuIFRyeSAoOTk5OTk5OTk5OTk5LjcgLSA5OTk5OTk5OTk5OTkpICogMSA9IDAuNjk5OTUxMTcxODc1IGluc3RlYWQgb2YgMC43LlxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAodGhpcy5fZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgIT09IF90aW55TnVtICYmICh0aGlzLl9yYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID49IDApKSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiB0aGlzLl9yZXZlcnNlZCkgeyAvL2Vuc3VyZXMgcHJvcGVyIEdDIGlmIGEgdGltZWxpbmUgaXMgcmVzdW1lZCBhZnRlciBpdCdzIGZpbmlzaGVkIHJldmVyc2luZy5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmF3UHJldlRpbWUgPj0gMCAmJiB0aGlzLl9maXJzdCkgeyAvL3doZW4gZ29pbmcgYmFjayBiZXlvbmQgdGhlIHN0YXJ0LCBmb3JjZSBhIHJlbmRlciBzbyB0aGF0IHplcm8tZHVyYXRpb24gdHdlZW5zIHRoYXQgc2l0IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyByZW5kZXIgdGhlaXIgc3RhcnQgdmFsdWVzIHByb3Blcmx5LiBPdGhlcndpc2UsIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IGF0IHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUsIGFuZCB0aGVuIG1vdmVzIGJhY2t3YXJkcywgdGhlIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSBiZWdpbm5pbmcgd291bGQgc3RpbGwgYmUgYXQgdGhlaXIgZW5kIHN0YXRlLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLnZhcnMub25TdGFydC5hcHBseSh0aGlzLnZhcnMub25TdGFydFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblN0YXJ0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmdcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSB0aGlzLl90aW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzW2NhbGxiYWNrXS5hcHBseSh0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlNjb3BlXCJdIHx8IHRoaXMsIHRoaXMudmFyc1tjYWxsYmFjayArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9oYXNQYXVzZWRDaGlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9wYXVzZWQgfHwgKCh0d2VlbiBpbnN0YW5jZW9mIFRpbWVsaW5lTGl0ZSkgJiYgdHdlZW4uX2hhc1BhdXNlZENoaWxkKCkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IC05OTk5OTk5OTk5O1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0Y250ID0gMDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHQvL2RvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdGlmICh0d2VlbnMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGltZWxpbmVzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5lc3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0d2Vlbi5nZXRDaGlsZHJlbih0cnVlLCB0d2VlbnMsIHRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgbmVzdGVkKSB7XG5cdFx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLl9nYyxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHR0d2VlbnMsIGk7XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCB0cnVlKTsgLy9nZXRUd2VlbnNPZigpIGZpbHRlcnMgb3V0IGRpc2FibGVkIHR3ZWVucywgYW5kIHdlIGhhdmUgdG8gbWFyayB0aGVtIGFzIF9nYyA9IHRydWUgd2hlbiB0aGUgdGltZWxpbmUgY29tcGxldGVzIGluIG9yZGVyIHRvIGFsbG93IGNsZWFuIGdhcmJhZ2UgY29sbGVjdGlvbiwgc28gdGVtcG9yYXJpbHkgcmUtZW5hYmxlIHRoZSB0aW1lbGluZSBoZXJlLlxuXHRcdFx0fVxuXHRcdFx0dHdlZW5zID0gVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCk7XG5cdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLnRpbWVsaW5lID09PSB0aGlzIHx8IChuZXN0ZWQgJiYgdGhpcy5fY29udGFpbnModHdlZW5zW2ldKSkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAucmVjZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjZW50O1xuXHRcdH07XG5cblx0XHRwLl9jb250YWlucyA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0XHR2YXIgdGwgPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bCkge1xuXHRcdFx0XHRpZiAodGwgPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bCA9IHRsLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgMDtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRsYWJlbHMgPSB0aGlzLl9sYWJlbHMsXG5cdFx0XHRcdHA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdHR3ZWVuLl9zdGFydFRpbWUgKz0gYW1vdW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWRqdXN0TGFiZWxzKSB7XG5cdFx0XHRcdGZvciAocCBpbiBsYWJlbHMpIHtcblx0XHRcdFx0XHRpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHRcdGxhYmVsc1twXSArPSBhbW91bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0aWYgKCF2YXJzICYmICF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciB0d2VlbnMgPSAoIXRhcmdldCkgPyB0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKSA6IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0KSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldLl9raWxsKHZhcnMsIHRhcmdldCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbihsYWJlbHMpIHtcblx0XHRcdHZhciB0d2VlbnMgPSB0aGlzLmdldENoaWxkcmVuKGZhbHNlLCB0cnVlLCB0cnVlKSxcblx0XHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbnNbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChsYWJlbHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uaW52YWxpZGF0ZSgpO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpOztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoZW5hYmxlZCA9PT0gdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGVuYWJsZWQsIHRydWUpO1xuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLCBlbmFibGVkLCBpZ25vcmVUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSB0cnVlO1xuXHRcdFx0dmFyIHZhbCA9IEFuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9mb3JjaW5nUGxheWhlYWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpOyAvL2p1c3QgdHJpZ2dlcnMgcmVjYWxjdWxhdGlvblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmR1cmF0aW9uKCkgIT09IDAgJiYgdmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50aW1lU2NhbGUodGhpcy5fZHVyYXRpb24gLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR2YXIgbWF4ID0gMCxcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdCxcblx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDk5OTk5OTk5OTk5OSxcblx0XHRcdFx0XHRcdHByZXYsIGVuZDtcblx0XHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRcdHByZXYgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIHR3ZWVuJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID4gcHJldlN0YXJ0ICYmIHRoaXMuX3NvcnRDaGlsZHJlbiAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWRkKHR3ZWVuLCB0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA8IDAgJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cblx0XHRcdFx0XHRcdFx0bWF4IC09IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSB0d2Vlbi5fc3RhcnRUaW1lIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hpZnRDaGlsZHJlbigtdHdlZW4uX3N0YXJ0VGltZSwgZmFsc2UsIC05OTk5OTk5OTk5KTtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVuZCA9IHR3ZWVuLl9zdGFydFRpbWUgKyAodHdlZW4uX3RvdGFsRHVyYXRpb24gLyB0d2Vlbi5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdGlmIChlbmQgPiBtYXgpIHtcblx0XHRcdFx0XHRcdFx0bWF4ID0gZW5kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHdlZW4gPSBwcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBtYXg7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRvdGFsRHVyYXRpb24oKSAhPT0gMCkgaWYgKHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX3RvdGFsRHVyYXRpb24gLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZSkgeyAvL2lmIHRoZXJlJ3MgYSBwYXVzZSBkaXJlY3RseSBhdCB0aGUgc3BvdCBmcm9tIHdoZXJlIHdlJ3JlIHVucGF1c2luZywgc2tpcCBpdC5cblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID09PSB0aW1lICYmIHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcmF3UHJldlRpbWUgPSAwOyAvL3JlbWVtYmVyLCBfcmF3UHJldlRpbWUgaXMgaG93IHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyBzZW5zZSBkaXJlY3Rpb25hbGl0eSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZpcmUuIElmIF9yYXdQcmV2VGltZSBpcyB0aGUgc2FtZSBhcyBfc3RhcnRUaW1lIG9uIHRoZSBuZXh0IHJlbmRlciwgaXQgd29uJ3QgZmlyZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudXNlc0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0bCA9PT0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQgPyB0aGlzLl90b3RhbFRpbWUgOiAodGhpcy5fdGltZWxpbmUucmF3VGltZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZTtcblxuXHR9LCB0cnVlKTtcblxuXG59KTsgaWYgKF9nc1Njb3BlLl9nc0RlZmluZSkgeyBfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpOyB9XG5cbi8vZXhwb3J0IHRvIEFNRC9SZXF1aXJlSlMgYW5kIENvbW1vbkpTL05vZGUgKHByZWN1cnNvciB0byBmdWxsIG1vZHVsYXIgYnVpbGQgc3lzdGVtIGNvbWluZyBhdCBhIGxhdGVyIGRhdGUpXG4oZnVuY3Rpb24obmFtZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFscyB8fCBfZ3NTY29wZSlbbmFtZV07XG5cdH07XG5cdGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgLy9BTURcblx0XHRkZWZpbmUoW1wiVHdlZW5MaXRlXCJdLCBnZXRHbG9iYWwpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vbm9kZVxuXHRcdHJlcXVpcmUoXCIuL1R3ZWVuTGl0ZS5qc1wiKTsgLy9kZXBlbmRlbmN5XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnZXRHbG9iYWwoKTtcblx0fVxufShcIlRpbWVsaW5lTGl0ZVwiKSk7XG4iLCIvKiFcbiAqIFZFUlNJT046IDEuMTYuMVxuICogREFURTogMjAxNS0wMy0xM1xuICogVVBEQVRFUyBBTkQgRE9DUyBBVDogaHR0cDovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIG1vZHVsZU5hbWUpIHtcblxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfZ2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgfHwgd2luZG93O1xuXHRcdGlmIChfZ2xvYmFscy5Ud2VlbkxpdGUpIHtcblx0XHRcdHJldHVybjsgLy9pbiBjYXNlIHRoZSBjb3JlIHNldCBvZiBjbGFzc2VzIGlzIGFscmVhZHkgbG9hZGVkLCBkb24ndCBpbnN0YW50aWF0ZSB0d2ljZS5cblx0XHR9XG5cdFx0dmFyIF9uYW1lc3BhY2UgPSBmdW5jdGlvbihucykge1xuXHRcdFx0XHR2YXIgYSA9IG5zLnNwbGl0KFwiLlwiKSxcblx0XHRcdFx0XHRwID0gX2dsb2JhbHMsIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cFthW2ldXSA9IHAgPSBwW2FbaV1dIHx8IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdGdzID0gX25hbWVzcGFjZShcImNvbS5ncmVlbnNvY2tcIiksXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdF9lbXB0eUZ1bmMgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0X2lzQXJyYXkgPSAoZnVuY3Rpb24oKSB7IC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBpZnJhbWUgZW52aXJvbm1lbnRzIHdoZXJlIHRoZSBBcnJheSBnbG9iYWwgaXNuJ3Qgc2hhcmVkLCB0aHVzIGlmIHRoZSBvYmplY3Qgb3JpZ2luYXRlcyBpbiBhIGRpZmZlcmVudCB3aW5kb3cvaWZyYW1lLCBcIihvYmogaW5zdGFuY2VvZiBBcnJheSlcIiB3aWxsIGV2YWx1YXRlIGZhbHNlLiBXZSBhZGRlZCBzb21lIHNwZWVkIG9wdGltaXphdGlvbnMgdG8gYXZvaWQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCkgdW5sZXNzIGl0J3MgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIFZFUlkgc2xvdyAobGlrZSAyMHggc2xvd2VyKVxuXHRcdFx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRcdFx0XHRcdGFycmF5ID0gdG9TdHJpbmcuY2FsbChbXSk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5IHx8ICh0eXBlb2Yob2JqKSA9PT0gXCJvYmplY3RcIiAmJiAhIW9iai5wdXNoICYmIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gYXJyYXkpKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSksXG5cdFx0XHRhLCBpLCBwLCBfdGlja2VyLCBfdGlja2VyQWN0aXZlLFxuXHRcdFx0X2RlZkxvb2t1cCA9IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdFx0ICogRGVmaW5lcyBhIEdyZWVuU29jayBjbGFzcywgb3B0aW9uYWxseSB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyB0aGF0IG11c3QgYmUgaW5zdGFudGlhdGVkIGZpcnN0IGFuZCBwYXNzZWQgaW50byB0aGUgZGVmaW5pdGlvbi5cblx0XHRcdCAqIFRoaXMgYWxsb3dzIHVzZXJzIHRvIGxvYWQgR3JlZW5Tb2NrIEpTIGZpbGVzIGluIGFueSBvcmRlciBldmVuIGlmIHRoZXkgaGF2ZSBpbnRlcmRlcGVuZGVuY2llcyAobGlrZSBDU1NQbHVnaW4gZXh0ZW5kcyBUd2VlblBsdWdpbiB3aGljaCBpc1xuXHRcdFx0ICogaW5zaWRlIFR3ZWVuTGl0ZS5qcywgYnV0IGlmIENTU1BsdWdpbiBpcyBsb2FkZWQgZmlyc3QsIGl0IHNob3VsZCB3YWl0IHRvIHJ1biBpdHMgY29kZSB1bnRpbCBUd2VlbkxpdGUuanMgbG9hZHMgYW5kIGluc3RhbnRpYXRlcyBUd2VlblBsdWdpblxuXHRcdFx0ICogYW5kIHRoZW4gcGFzcyBUd2VlblBsdWdpbiB0byBDU1NQbHVnaW4ncyBkZWZpbml0aW9uKS4gVGhpcyBpcyBhbGwgZG9uZSBhdXRvbWF0aWNhbGx5IGFuZCBpbnRlcm5hbGx5LlxuXHRcdFx0ICpcblx0XHRcdCAqIEV2ZXJ5IGRlZmluaXRpb24gd2lsbCBiZSBhZGRlZCB0byBhIFwiY29tLmdyZWVuc29ja1wiIGdsb2JhbCBvYmplY3QgKHR5cGljYWxseSB3aW5kb3csIGJ1dCBpZiBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdCBpcyBmb3VuZCxcblx0XHRcdCAqIGl0IHdpbGwgZ28gdGhlcmUgYXMgb2YgdjEuNykuIEZvciBleGFtcGxlLCBUd2VlbkxpdGUgd2lsbCBiZSBmb3VuZCBhdCB3aW5kb3cuY29tLmdyZWVuc29jay5Ud2VlbkxpdGUgYW5kIHNpbmNlIGl0J3MgYSBnbG9iYWwgY2xhc3MgdGhhdCBzaG91bGQgYmUgYXZhaWxhYmxlIGFueXdoZXJlLFxuXHRcdFx0ICogaXQgaXMgQUxTTyByZWZlcmVuY2VkIGF0IHdpbmRvdy5Ud2VlbkxpdGUuIEhvd2V2ZXIgc29tZSBjbGFzc2VzIGFyZW4ndCBjb25zaWRlcmVkIGdsb2JhbCwgbGlrZSB0aGUgYmFzZSBjb20uZ3JlZW5zb2NrLmNvcmUuQW5pbWF0aW9uIGNsYXNzLCBzb1xuXHRcdFx0ICogdGhvc2Ugd2lsbCBvbmx5IGJlIGF0IHRoZSBwYWNrYWdlIGxpa2Ugd2luZG93LmNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24uIEFnYWluLCBpZiB5b3UgZGVmaW5lIGEgR3JlZW5Tb2NrR2xvYmFscyBvYmplY3Qgb24gdGhlIHdpbmRvdywgZXZlcnl0aGluZ1xuXHRcdFx0ICogZ2V0cyB0dWNrZWQgbmVhdGx5IGluc2lkZSB0aGVyZSBpbnN0ZWFkIG9mIG9uIHRoZSB3aW5kb3cgZGlyZWN0bHkuIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBhZHZhbmNlZCB0aGluZ3MgbGlrZSBsb2FkIG11bHRpcGxlIHZlcnNpb25zIG9mIEdyZWVuU29ja1xuXHRcdFx0ICogZmlsZXMgYW5kIHB1dCB0aGVtIGludG8gZGlzdGluY3Qgb2JqZWN0cyAoaW1hZ2luZSBhIGJhbm5lciBhZCB1c2VzIGEgbmV3ZXIgdmVyc2lvbiBidXQgdGhlIG1haW4gc2l0ZSB1c2VzIGFuIG9sZGVyIG9uZSkuIEluIHRoYXQgY2FzZSwgeW91IGNvdWxkXG5cdFx0XHQgKiBzYW5kYm94IHRoZSBiYW5uZXIgb25lIGxpa2U6XG5cdFx0XHQgKlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB2YXIgZ3MgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9OyAvL3RoZSBuZXdlciB2ZXJzaW9uIHdlJ3JlIGFib3V0IHRvIGxvYWQgY291bGQgbm93IGJlIHJlZmVyZW5jZWQgaW4gYSBcImdzXCIgb2JqZWN0LCBsaWtlIGdzLlR3ZWVuTGl0ZS50byguLi4pLiBVc2Ugd2hhdGV2ZXIgYWxpYXMgeW91IHdhbnQgYXMgbG9uZyBhcyBpdCdzIHVuaXF1ZSwgXCJnc1wiIG9yIFwiYmFubmVyXCIgb3Igd2hhdGV2ZXIuXG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQgc3JjPVwianMvZ3JlZW5zb2NrL3YxLjcvVHdlZW5NYXguanNcIj48L3NjcmlwdD5cblx0XHRcdCAqIDxzY3JpcHQ+XG5cdFx0XHQgKiAgICAgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuX2dzUXVldWUgPSB3aW5kb3cuX2dzRGVmaW5lID0gbnVsbDsgLy9yZXNldCBpdCBiYWNrIHRvIG51bGwgKGFsb25nIHdpdGggdGhlIHNwZWNpYWwgX2dzUXVldWUgdmFyaWFibGUpIHNvIHRoYXQgdGhlIG5leHQgbG9hZCBvZiBUd2Vlbk1heCBhZmZlY3RzIHRoZSB3aW5kb3cgYW5kIHdlIGNhbiByZWZlcmVuY2UgdGhpbmdzIGRpcmVjdGx5IGxpa2UgVHdlZW5MaXRlLnRvKC4uLilcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNi9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICBncy5Ud2VlbkxpdGUudG8oLi4uKTsgLy93b3VsZCB1c2UgdjEuN1xuXHRcdFx0ICogICAgIFR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS42XG5cdFx0XHQgKiA8L3NjcmlwdD5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5zIFRoZSBuYW1lc3BhY2Ugb2YgdGhlIGNsYXNzIGRlZmluaXRpb24sIGxlYXZpbmcgb2ZmIFwiY29tLmdyZWVuc29jay5cIiBhcyB0aGF0J3MgYXNzdW1lZC4gRm9yIGV4YW1wbGUsIFwiVHdlZW5MaXRlXCIgb3IgXCJwbHVnaW5zLkNTU1BsdWdpblwiIG9yIFwiZWFzaW5nLkJhY2tcIi5cblx0XHRcdCAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBkZXBlbmRlbmNpZXMgQW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIChkZXNjcmliZWQgYXMgdGhlaXIgbmFtZXNwYWNlcyBtaW51cyBcImNvbS5ncmVlbnNvY2suXCIgcHJlZml4KS4gRm9yIGV4YW1wbGUgW1wiVHdlZW5MaXRlXCIsXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJjb3JlLkFuaW1hdGlvblwiXVxuXHRcdFx0ICogQHBhcmFtIHshZnVuY3Rpb24oKTpPYmplY3R9IGZ1bmMgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBhbmQgcGFzc2VkIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXMgd2hpY2ggd2lsbCByZXR1cm4gdGhlIGFjdHVhbCBjbGFzcyBmb3IgdGhpcyBkZWZpbml0aW9uLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gZ2xvYmFsIElmIHRydWUsIHRoZSBjbGFzcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnbG9iYWwgc2NvcGUgKHR5cGljYWxseSB3aW5kb3cgdW5sZXNzIHlvdSBkZWZpbmUgYSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyBvYmplY3QpXG5cdFx0XHQgKi9cblx0XHRcdERlZmluaXRpb24gPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0dGhpcy5zYyA9IChfZGVmTG9va3VwW25zXSkgPyBfZGVmTG9va3VwW25zXS5zYyA6IFtdOyAvL3N1YmNsYXNzZXNcblx0XHRcdFx0X2RlZkxvb2t1cFtuc10gPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmdzQ2xhc3MgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZ1bmMgPSBmdW5jO1xuXHRcdFx0XHR2YXIgX2NsYXNzZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uKGluaXQpIHtcblx0XHRcdFx0XHR2YXIgaSA9IGRlcGVuZGVuY2llcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRtaXNzaW5nID0gaSxcblx0XHRcdFx0XHRcdGN1ciwgYSwgbiwgY2w7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1ciA9IF9kZWZMb29rdXBbZGVwZW5kZW5jaWVzW2ldXSB8fCBuZXcgRGVmaW5pdGlvbihkZXBlbmRlbmNpZXNbaV0sIFtdKSkuZ3NDbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfY2xhc3Nlc1tpXSA9IGN1ci5nc0NsYXNzO1xuXHRcdFx0XHRcdFx0XHRtaXNzaW5nLS07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluaXQpIHtcblx0XHRcdFx0XHRcdFx0Y3VyLnNjLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtaXNzaW5nID09PSAwICYmIGZ1bmMpIHtcblx0XHRcdFx0XHRcdGEgPSAoXCJjb20uZ3JlZW5zb2NrLlwiICsgbnMpLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0XHRcdG4gPSBhLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2wgPSBfbmFtZXNwYWNlKGEuam9pbihcIi5cIikpW25dID0gdGhpcy5nc0NsYXNzID0gZnVuYy5hcHBseShmdW5jLCBfY2xhc3Nlcyk7XG5cblx0XHRcdFx0XHRcdC8vZXhwb3J0cyB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcblx0XHRcdFx0XHRcdGlmIChnbG9iYWwpIHtcblx0XHRcdFx0XHRcdFx0X2dsb2JhbHNbbl0gPSBjbDsgLy9wcm92aWRlcyBhIHdheSB0byBhdm9pZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1haW4gY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgUG93ZXIxLCBTdHJvbmcsIGV0Yy4gYXJlIGFkZGVkIHRvIHdpbmRvdyB1bmxlc3MgYSBHcmVlblNvY2tHbG9iYWxzIGlzIGRlZmluZWQuIFNvIGlmIHlvdSB3YW50IHRvIGhhdmUgdGhpbmdzIGFkZGVkIHRvIGEgY3VzdG9tIG9iamVjdCBpbnN0ZWFkLCBqdXN0IGRvIHNvbWV0aGluZyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge30gYmVmb3JlIGxvYWRpbmcgYW55IEdyZWVuU29jayBmaWxlcy4gWW91IGNhbiBldmVuIHNldCB1cCBhbiBhbGlhcyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93cy5ncyA9IHt9IHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgZXZlcnl0aGluZyBsaWtlIGdzLlR3ZWVuTGl0ZS4gQWxzbyByZW1lbWJlciB0aGF0IEFMTCBjbGFzc2VzIGFyZSBhZGRlZCB0byB0aGUgd2luZG93LmNvbS5ncmVlbnNvY2sgb2JqZWN0IChpbiB0aGVpciByZXNwZWN0aXZlIHBhY2thZ2VzLCBsaWtlIGNvbS5ncmVlbnNvY2suZWFzaW5nLlBvd2VyMSwgY29tLmdyZWVuc29jay5Ud2VlbkxpdGUsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuXHRcdFx0XHRcdFx0XHRcdGRlZmluZSgod2luZG93LkdyZWVuU29ja0FNRFBhdGggPyB3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCArIFwiL1wiIDogXCJcIikgKyBucy5zcGxpdChcIi5cIikucG9wKCksIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsOyB9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChucyA9PT0gbW9kdWxlTmFtZSAmJiB0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyl7IC8vbm9kZVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gY2w7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNjLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2NbaV0uY2hlY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuY2hlY2sodHJ1ZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3VzZWQgdG8gY3JlYXRlIERlZmluaXRpb24gaW5zdGFuY2VzICh3aGljaCBiYXNpY2FsbHkgcmVnaXN0ZXJzIGEgY2xhc3MgdGhhdCBoYXMgZGVwZW5kZW5jaWVzKS5cblx0XHRcdF9nc0RlZmluZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWZpbml0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2EgcXVpY2sgd2F5IHRvIGNyZWF0ZSBhIGNsYXNzIHRoYXQgZG9lc24ndCBoYXZlIGFueSBkZXBlbmRlbmNpZXMuIFJldHVybnMgdGhlIGNsYXNzLCBidXQgZmlyc3QgcmVnaXN0ZXJzIGl0IGluIHRoZSBHcmVlblNvY2sgbmFtZXNwYWNlIHNvIHRoYXQgb3RoZXIgY2xhc3NlcyBjYW4gZ3JhYiBpdCAob3RoZXIgY2xhc3NlcyBtaWdodCBiZSBkZXBlbmRlbnQgb24gdGhlIGNsYXNzKS5cblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyA9IGZ1bmN0aW9uKG5zLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0ZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0X2dzRGVmaW5lKG5zLCBbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmM7IH0sIGdsb2JhbCk7XG5cdFx0XHRcdHJldHVybiBmdW5jO1xuXHRcdFx0fTtcblxuXHRcdF9nc0RlZmluZS5nbG9iYWxzID0gX2dsb2JhbHM7XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIF9iYXNlUGFyYW1zID0gWzAsIDAsIDEsIDFdLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuRWFzZVwiLCBmdW5jdGlvbihmdW5jLCBleHRyYVBhcmFtcywgdHlwZSwgcG93ZXIpIHtcblx0XHRcdFx0dGhpcy5fZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3Bvd2VyID0gcG93ZXIgfHwgMDtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gZXh0cmFQYXJhbXMgPyBfYmFzZVBhcmFtcy5jb25jYXQoZXh0cmFQYXJhbXMpIDogX2Jhc2VQYXJhbXM7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9lYXNlTWFwID0gRWFzZS5tYXAgPSB7fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVhc2UsIG5hbWVzLCB0eXBlcywgY3JlYXRlKSB7XG5cdFx0XHRcdHZhciBuYSA9IG5hbWVzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRpID0gbmEubGVuZ3RoLFxuXHRcdFx0XHRcdHRhID0gKHR5cGVzIHx8IFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRlLCBuYW1lLCBqLCB0eXBlO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFbaV07XG5cdFx0XHRcdFx0ZSA9IGNyZWF0ZSA/IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCBudWxsLCB0cnVlKSA6IGdzLmVhc2luZ1tuYW1lXSB8fCB7fTtcblx0XHRcdFx0XHRqID0gdGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRhW2pdO1xuXHRcdFx0XHRcdFx0X2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgdHlwZV0gPSBfZWFzZU1hcFt0eXBlICsgbmFtZV0gPSBlW3R5cGVdID0gZWFzZS5nZXRSYXRpbyA/IGVhc2UgOiBlYXNlW3R5cGVdIHx8IG5ldyBlYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IEVhc2UucHJvdG90eXBlO1xuXHRcdHAuX2NhbGNFbmQgPSBmYWxzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHRoaXMuX2Z1bmMpIHtcblx0XHRcdFx0dGhpcy5fcGFyYW1zWzBdID0gcDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2Z1bmMuYXBwbHkobnVsbCwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cHcgPSB0aGlzLl9wb3dlcixcblx0XHRcdFx0ciA9ICh0ID09PSAxKSA/IDEgLSBwIDogKHQgPT09IDIpID8gcCA6IChwIDwgMC41KSA/IHAgKiAyIDogKDEgLSBwKSAqIDI7XG5cdFx0XHRpZiAocHcgPT09IDEpIHtcblx0XHRcdFx0ciAqPSByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMikge1xuXHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMykge1xuXHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDQpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgLSByIDogKHQgPT09IDIpID8gciA6IChwIDwgMC41KSA/IHIgLyAyIDogMSAtIChyIC8gMik7XG5cdFx0fTtcblxuXHRcdC8vY3JlYXRlIGFsbCB0aGUgc3RhbmRhcmQgZWFzZXMgbGlrZSBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBhbmQgUG93ZXI0IChlYWNoIHdpdGggZWFzZUluLCBlYXNlT3V0LCBhbmQgZWFzZUluT3V0KVxuXHRcdGEgPSBbXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHAgPSBhW2ldK1wiLFBvd2VyXCIraTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwxLGkpLCBwLCBcImVhc2VPdXRcIiwgdHJ1ZSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMixpKSwgcCwgXCJlYXNlSW5cIiArICgoaSA9PT0gMCkgPyBcIixlYXNlTm9uZVwiIDogXCJcIikpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDMsaSksIHAsIFwiZWFzZUluT3V0XCIpO1xuXHRcdH1cblx0XHRfZWFzZU1hcC5saW5lYXIgPSBncy5lYXNpbmcuTGluZWFyLmVhc2VJbjtcblx0XHRfZWFzZU1hcC5zd2luZyA9IGdzLmVhc2luZy5RdWFkLmVhc2VJbk91dDsgLy9mb3IgalF1ZXJ5IGZvbGtzXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50RGlzcGF0Y2hlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEV2ZW50RGlzcGF0Y2hlciA9IF9jbGFzcyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIiwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG5cdFx0fSk7XG5cdFx0cCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgc2NvcGUsIHVzZVBhcmFtLCBwcmlvcml0eSkge1xuXHRcdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGlzdGVuZXIsIGk7XG5cdFx0XHRpZiAobGlzdCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IGxpc3QgPSBbXTtcblx0XHRcdH1cblx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lci5jID09PSBjYWxsYmFjayAmJiBsaXN0ZW5lci5zID09PSBzY29wZSkge1xuXHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwICYmIGxpc3RlbmVyLnByIDwgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHRpbmRleCA9IGkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNwbGljZShpbmRleCwgMCwge2M6Y2FsbGJhY2ssIHM6c2NvcGUsIHVwOnVzZVBhcmFtLCBwcjpwcmlvcml0eX0pO1xuXHRcdFx0aWYgKHRoaXMgPT09IF90aWNrZXIgJiYgIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaTtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uYyA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aSwgdCwgbGlzdGVuZXI7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHQgPSB0aGlzLl9ldmVudFRhcmdldDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcikge1xuXHRcdFx0XHRcdFx0aWYgKGxpc3RlbmVyLnVwKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQsIHt0eXBlOnR5cGUsIHRhcmdldDp0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaWNrZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuIFx0XHR2YXIgX3JlcUFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2dldFRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSxcblx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKTtcblxuXHRcdC8vbm93IHRyeSB0byBkZXRlcm1pbmUgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgY2FuY2VsQW5pbWF0aW9uRnJhbWUgZnVuY3Rpb25zIGFuZCBpZiBub25lIGFyZSBmb3VuZCwgd2UnbGwgdXNlIGEgc2V0VGltZW91dCgpL2NsZWFyVGltZW91dCgpIHBvbHlmaWxsLlxuXHRcdGEgPSBbXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSAmJiAhX3JlcUFuaW1GcmFtZSkge1xuXHRcdFx0X3JlcUFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0XHRfY2FuY2VsQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8IHdpbmRvd1thW2ldICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG5cdFx0fVxuXG5cdFx0X2NsYXNzKFwiVGlja2VyXCIsIGZ1bmN0aW9uKGZwcywgdXNlUkFGKSB7XG5cdFx0XHR2YXIgX3NlbGYgPSB0aGlzLFxuXHRcdFx0XHRfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcblx0XHRcdFx0X3VzZVJBRiA9ICh1c2VSQUYgIT09IGZhbHNlICYmIF9yZXFBbmltRnJhbWUpLFxuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gNTAwLFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSAzMyxcblx0XHRcdFx0X3RpY2tXb3JkID0gXCJ0aWNrXCIsIC8vaGVscHMgcmVkdWNlIGdjIGJ1cmRlblxuXHRcdFx0XHRfZnBzLCBfcmVxLCBfaWQsIF9nYXAsIF9uZXh0VGltZSxcblx0XHRcdFx0X3RpY2sgPSBmdW5jdGlvbihtYW51YWwpIHtcblx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcblx0XHRcdFx0XHRcdG92ZXJsYXAsIGRpc3BhdGNoO1xuXHRcdFx0XHRcdGlmIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0X3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdF9zZWxmLnRpbWUgPSAoX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lKSAvIDEwMDA7XG5cdFx0XHRcdFx0b3ZlcmxhcCA9IF9zZWxmLnRpbWUgLSBfbmV4dFRpbWU7XG5cdFx0XHRcdFx0aWYgKCFfZnBzIHx8IG92ZXJsYXAgPiAwIHx8IG1hbnVhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZnJhbWUrKztcblx0XHRcdFx0XHRcdF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDAuMDA0IDogX2dhcCAtIG92ZXJsYXApO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWFudWFsICE9PSB0cnVlKSB7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cdFx0XHRcdFx0XHRfaWQgPSBfcmVxKF90aWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5kaXNwYXRjaEV2ZW50KF90aWNrV29yZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRFdmVudERpc3BhdGNoZXIuY2FsbChfc2VsZik7XG5cdFx0XHRfc2VsZi50aW1lID0gX3NlbGYuZnJhbWUgPSAwO1xuXHRcdFx0X3NlbGYudGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGljayh0cnVlKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdFx0X2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAoMSAvIF90aW55TnVtKTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnNsZWVwID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfaWQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV91c2VSQUYgfHwgIV9jYW5jZWxBbmltRnJhbWUpIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoX2lkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfY2FuY2VsQW5pbUZyYW1lKF9pZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IF9lbXB0eUZ1bmM7XG5cdFx0XHRcdF9pZCA9IG51bGw7XG5cdFx0XHRcdGlmIChfc2VsZiA9PT0gX3RpY2tlcikge1xuXHRcdFx0XHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYud2FrZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX2lkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0X3NlbGYuc2xlZXAoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChfc2VsZi5mcmFtZSA+IDEwKSB7IC8vZG9uJ3QgdHJpZ2dlciBsYWdTbW9vdGhpbmcgaWYgd2UncmUganVzdCB3YWtpbmcgdXAsIGFuZCBtYWtlIHN1cmUgdGhhdCBhdCBsZWFzdCAxMCBmcmFtZXMgaGF2ZSBlbGFwc2VkIGJlY2F1c2Ugb2YgdGhlIGlPUyBidWcgdGhhdCB3ZSB3b3JrIGFyb3VuZCBiZWxvdyB3aXRoIHRoZSAxLjUtc2Vjb25kIHNldFRpbW91dCgpLlxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlID0gX2dldFRpbWUoKSAtIF9sYWdUaHJlc2hvbGQgKyA1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXEgPSAoX2ZwcyA9PT0gMCkgPyBfZW1wdHlGdW5jIDogKCFfdXNlUkFGIHx8ICFfcmVxQW5pbUZyYW1lKSA/IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHNldFRpbWVvdXQoZiwgKChfbmV4dFRpbWUgLSBfc2VsZi50aW1lKSAqIDEwMDAgKyAxKSB8IDApOyB9IDogX3JlcUFuaW1GcmFtZTtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RpY2soMik7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi5mcHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2Zwcztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZnBzID0gdmFsdWU7XG5cdFx0XHRcdF9nYXAgPSAxIC8gKF9mcHMgfHwgNjApO1xuXHRcdFx0XHRfbmV4dFRpbWUgPSB0aGlzLnRpbWUgKyBfZ2FwO1xuXHRcdFx0XHRfc2VsZi53YWtlKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi51c2VSQUYgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3VzZVJBRjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHRfdXNlUkFGID0gdmFsdWU7XG5cdFx0XHRcdF9zZWxmLmZwcyhfZnBzKTtcblx0XHRcdH07XG5cdFx0XHRfc2VsZi5mcHMoZnBzKTtcblxuXHRcdFx0Ly9hIGJ1ZyBpbiBpT1MgNiBTYWZhcmkgb2NjYXNpb25hbGx5IHByZXZlbnRzIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJvbSB3b3JraW5nIGluaXRpYWxseSwgc28gd2UgdXNlIGEgMS41LXNlY29uZCB0aW1lb3V0IHRoYXQgYXV0b21hdGljYWxseSBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQoKSBpZiBpdCBzZW5zZXMgdGhpcyBjb25kaXRpb24uXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3VzZVJBRiAmJiBfc2VsZi5mcmFtZSA8IDUpIHtcblx0XHRcdFx0XHRfc2VsZi51c2VSQUYoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxNTAwKTtcblx0XHR9KTtcblxuXHRcdHAgPSBncy5UaWNrZXIucHJvdG90eXBlID0gbmV3IGdzLmV2ZW50cy5FdmVudERpc3BhdGNoZXIoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gZ3MuVGlja2VyO1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBbmltYXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBBbmltYXRpb24gPSBfY2xhc3MoXCJjb3JlLkFuaW1hdGlvblwiLCBmdW5jdGlvbihkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnMgPSB2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRcdFx0dGhpcy5fZGVsYXkgPSBOdW1iZXIodmFycy5kZWxheSkgfHwgMDtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlID0gMTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9ICh2YXJzLnJldmVyc2VkID09PSB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIV9yb290VGltZWxpbmUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBpT1MgNiBTYWZhcmkpIHNodXQgZG93biBKYXZhU2NyaXB0IGV4ZWN1dGlvbiB3aGVuIHRoZSB0YWIgaXMgZGlzYWJsZWQgYW5kIHRoZXkgW29jY2FzaW9uYWxseV0gbmVnbGVjdCB0byBzdGFydCB1cCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYWdhaW4gd2hlbiByZXR1cm5pbmcgLSB0aGlzIGNvZGUgZW5zdXJlcyB0aGF0IHRoZSBlbmdpbmUgc3RhcnRzIHVwIGFnYWluIHByb3Blcmx5LlxuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRsID0gdGhpcy52YXJzLnVzZUZyYW1lcyA/IF9yb290RnJhbWVzVGltZWxpbmUgOiBfcm9vdFRpbWVsaW5lO1xuXHRcdFx0XHR0bC5hZGQodGhpcywgdGwuX3RpbWUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnZhcnMucGF1c2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0X3RpY2tlciA9IEFuaW1hdGlvbi50aWNrZXIgPSBuZXcgZ3MuVGlja2VyKCk7XG5cdFx0cCA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cdFx0cC5fZGlydHkgPSBwLl9nYyA9IHAuX2luaXR0ZWQgPSBwLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRwLl90b3RhbFRpbWUgPSBwLl90aW1lID0gMDtcblx0XHRwLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdHAuX25leHQgPSBwLl9sYXN0ID0gcC5fb25VcGRhdGUgPSBwLl90aW1lbGluZSA9IHAudGltZWxpbmUgPSBudWxsO1xuXHRcdHAuX3BhdXNlZCA9IGZhbHNlO1xuXG5cblx0XHQvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TKSBvY2Nhc2lvbmFsbHkgZHJvcCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGV2ZW50IHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgdGFiIGFuZCB0aGVuIGNvbWVzIGJhY2sgYWdhaW4sIHNvIHdlIHVzZSBhIDItc2Vjb25kIHNldFRpbWVvdXQoKSB0byBzZW5zZSBpZi93aGVuIHRoYXQgY29uZGl0aW9uIG9jY3VycyBhbmQgdGhlbiB3YWtlKCkgdGhlIHRpY2tlci5cblx0XHR2YXIgX2NoZWNrVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3RpY2tlckFjdGl2ZSAmJiBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUgPiAyMDAwKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dChfY2hlY2tUaW1lb3V0LCAyMDAwKTtcblx0XHRcdH07XG5cdFx0X2NoZWNrVGltZW91dCgpO1xuXG5cblx0XHRwLnBsYXkgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucGF1c2UgPSBmdW5jdGlvbihhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoYXRUaW1lICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlc3VtZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0aW1lKSwgc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN0YXJ0ID0gZnVuY3Rpb24oaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKChmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdC8vc3R1YiAtIHdlIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIHN1YmNsYXNzZXMuXG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdGhpcy5fZ2MgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSwgLy90aGUgMiByb290IHRpbWVsaW5lcyB3b24ndCBoYXZlIGEgX3RpbWVsaW5lOyB0aGV5J3JlIGFsd2F5cyBhY3RpdmUuXG5cdFx0XHRcdHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cmF3VGltZTtcblx0XHRcdHJldHVybiAoIXRsIHx8ICghdGhpcy5fZ2MgJiYgIXRoaXMuX3BhdXNlZCAmJiB0bC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gdGwucmF3VGltZSgpKSA+PSBzdGFydFRpbWUgJiYgcmF3VGltZSA8IHN0YXJ0VGltZSArIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdGhpcy5fdGltZVNjYWxlKSk7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2djID0gIWVuYWJsZWQ7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRpZiAoaWdub3JlVGltZWxpbmUgIT09IHRydWUpIHtcblx0XHRcdFx0aWYgKGVuYWJsZWQgJiYgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5hZGQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFlbmFibGVkICYmIHRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fdW5jYWNoZSA9IGZ1bmN0aW9uKGluY2x1ZGVTZWxmKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fc3dhcFNlbGZJblBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0dmFyIGkgPSBwYXJhbXMubGVuZ3RoLFxuXHRcdFx0XHRjb3B5ID0gcGFyYW1zLmNvbmNhdCgpO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwYXJhbXNbaV0gPT09IFwie3NlbGZ9XCIpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fTtcblxuLy8tLS0tQW5pbWF0aW9uIGdldHRlcnMvc2V0dGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdGlmICgodHlwZSB8fCBcIlwiKS5zdWJzdHIoMCwyKSA9PT0gXCJvblwiKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzO1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2W3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHZbdHlwZV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dlt0eXBlXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiUGFyYW1zXCJdID0gKF9pc0FycmF5KHBhcmFtcykgJiYgcGFyYW1zLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpID8gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyhwYXJhbXMpIDogcGFyYW1zO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiU2NvcGVcIl0gPSBzY29wZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJvblVwZGF0ZVwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kZWxheTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR0aGlzLnN0YXJ0VGltZSggdGhpcy5fc3RhcnRUaW1lICsgdmFsdWUgLSB0aGlzLl9kZWxheSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7IC8vdHJ1ZSBpbiBjYXNlIGl0J3MgYSBUd2Vlbk1heCBvciBUaW1lbGluZU1heCB0aGF0IGhhcyBhIHJlcGVhdCAtIHdlJ2xsIG5lZWQgdG8gcmVmcmVzaCB0aGUgdG90YWxEdXJhdGlvbi5cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgaWYgKHRoaXMuX3RpbWUgPiAwKSBpZiAodGhpcy5fdGltZSA8IHRoaXMuX2R1cmF0aW9uKSBpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lICogKHZhbHVlIC8gdGhpcy5fZHVyYXRpb24pLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMuZHVyYXRpb24odmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikgPyB0aGlzLl9kdXJhdGlvbiA6IHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0dGltZSArPSB0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdG90YWxEdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24sXG5cdFx0XHRcdFx0XHR0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdGlmICh0aW1lID4gdG90YWxEdXJhdGlvbiAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHRcdHRpbWUgPSB0b3RhbER1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSAodGhpcy5fcGF1c2VkID8gdGhpcy5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdGhpcy5fcmV2ZXJzZWQgPyB0aW1lIDogdG90YWxEdXJhdGlvbiAtIHRpbWUpIC8gdGhpcy5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRpZiAoIXRsLl9kaXJ0eSkgeyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cblx0XHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnRUaW1lIG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lLl90aW1lICE9PSAodGwuX3N0YXJ0VGltZSArIHRsLl90b3RhbFRpbWUpIC8gdGwuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gdGltZSB8fCB0aGlzLl9kdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucHJvZ3Jlc3MgPSBwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuc3RhcnRUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLnRpbWVsaW5lKSBpZiAodGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdFx0dGhpcy50aW1lbGluZS5hZGQodGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZW5kVGltZSA9IGZ1bmN0aW9uKGluY2x1ZGVSZXBlYXRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lICsgKChpbmNsdWRlUmVwZWF0cyAhPSBmYWxzZSkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHAudGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUgJiYgdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dmFyIHBhdXNlVGltZSA9IHRoaXMuX3BhdXNlVGltZSxcblx0XHRcdFx0XHR0ID0gKHBhdXNlVGltZSB8fCBwYXVzZVRpbWUgPT09IDApID8gcGF1c2VUaW1lIDogdGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSgoKHRoaXMuX3RpbWVsaW5lICYmICF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRoaXMuX3RvdGFsVGltZSA6IHRoaXMuX3RvdGFsVGltZSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsXG5cdFx0XHRcdHJhdywgZWxhcHNlZDtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9wYXVzZWQpIGlmICh0bCkge1xuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmF3ID0gdGwucmF3VGltZSgpO1xuXHRcdFx0XHRlbGFwc2VkID0gcmF3IC0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIHRsLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcGF1c2VUaW1lID0gdmFsdWUgPyByYXcgOiBudWxsO1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIGVsYXBzZWQgIT09IDAgJiYgdGhpcy5faW5pdHRlZCAmJiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcigodGwuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLl90b3RhbFRpbWUgOiAocmF3IC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX3RpbWVTY2FsZSksIHRydWUsIHRydWUpOyAvL2luIGNhc2UgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgY2hhbmdlZCB2aWEgc29tZSBvdGhlciB0d2VlbiBvciBtYW51YWwgdXBkYXRlIGJ5IHRoZSB1c2VyLCB3ZSBzaG91bGQgZm9yY2UgYSByZW5kZXIuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9nYyAmJiAhdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW1wbGVUaW1lbGluZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFNpbXBsZVRpbWVsaW5lID0gX2NsYXNzKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCAwLCB2YXJzKTtcblx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHRwID0gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTaW1wbGVUaW1lbGluZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRwLl9maXJzdCA9IHAuX2xhc3QgPSBwLl9yZWNlbnQgPSBudWxsO1xuXHRcdHAuX3NvcnRDaGlsZHJlbiA9IGZhbHNlO1xuXG5cdFx0cC5hZGQgPSBwLmluc2VydCA9IGZ1bmN0aW9uKGNoaWxkLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBwcmV2VHdlZW4sIHN0O1xuXHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSA9IE51bWJlcihwb3NpdGlvbiB8fCAwKSArIGNoaWxkLl9kZWxheTtcblx0XHRcdGlmIChjaGlsZC5fcGF1c2VkKSBpZiAodGhpcyAhPT0gY2hpbGQuX3RpbWVsaW5lKSB7IC8vd2Ugb25seSBhZGp1c3QgdGhlIF9wYXVzZVRpbWUgaWYgaXQgd2Fzbid0IGluIHRoaXMgdGltZWxpbmUgYWxyZWFkeS4gUmVtZW1iZXIsIHNvbWV0aW1lcyBhIHR3ZWVuIHdpbGwgYmUgaW5zZXJ0ZWQgYWdhaW4gaW50byB0aGUgc2FtZSB0aW1lbGluZSB3aGVuIGl0cyBzdGFydFRpbWUgaXMgY2hhbmdlZCBzbyB0aGF0IHRoZSB0d2VlbnMgaW4gdGhlIFRpbWVsaW5lTGl0ZS9NYXggYXJlIHJlLW9yZGVyZWQgcHJvcGVybHkgaW4gdGhlIGxpbmtlZCBsaXN0IChzbyBldmVyeXRoaW5nIHJlbmRlcnMgaW4gdGhlIHByb3BlciBvcmRlcikuXG5cdFx0XHRcdGNoaWxkLl9wYXVzZVRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKCh0aGlzLnJhd1RpbWUoKSAtIGNoaWxkLl9zdGFydFRpbWUpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQudGltZWxpbmUpIHtcblx0XHRcdFx0Y2hpbGQudGltZWxpbmUuX3JlbW92ZShjaGlsZCwgdHJ1ZSk7IC8vcmVtb3ZlcyBmcm9tIGV4aXN0aW5nIHRpbWVsaW5lIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IGFkZGVkIHRvIHRoaXMgb25lLlxuXHRcdFx0fVxuXHRcdFx0Y2hpbGQudGltZWxpbmUgPSBjaGlsZC5fdGltZWxpbmUgPSB0aGlzO1xuXHRcdFx0aWYgKGNoaWxkLl9nYykge1xuXHRcdFx0XHRjaGlsZC5fZW5hYmxlZCh0cnVlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHByZXZUd2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAodGhpcy5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdHN0ID0gY2hpbGQuX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHByZXZUd2VlbiAmJiBwcmV2VHdlZW4uX3N0YXJ0VGltZSA+IHN0KSB7XG5cdFx0XHRcdFx0cHJldlR3ZWVuID0gcHJldlR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlR3ZWVuKSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gcHJldlR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRwcmV2VHdlZW4uX25leHQgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQuX25leHQpIHtcblx0XHRcdFx0Y2hpbGQuX25leHQuX3ByZXYgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2xhc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNoaWxkLl9wcmV2ID0gcHJldlR3ZWVuO1xuXHRcdFx0dGhpcy5fcmVjZW50ID0gY2hpbGQ7XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdGlmICh0d2Vlbi50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRpZiAoIXNraXBEaXNhYmxlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHR3ZWVuLl9wcmV2KSB7XG5cdFx0XHRcdFx0dHdlZW4uX3ByZXYuX25leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbi5fbmV4dCkge1xuXHRcdFx0XHRcdHR3ZWVuLl9uZXh0Ll9wcmV2ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbGFzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9sYXN0ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4uX25leHQgPSB0d2Vlbi5fcHJldiA9IHR3ZWVuLnRpbWVsaW5lID0gbnVsbDtcblx0XHRcdFx0aWYgKHR3ZWVuID09PSB0aGlzLl9yZWNlbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bmV4dDtcblx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0aWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHRpbWUgPj0gdHdlZW4uX3N0YXJ0VGltZSAmJiAhdHdlZW4uX3BhdXNlZCkpIHtcblx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yYXdUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdH07XG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUd2VlbkxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBUd2VlbkxpdGUgPSBfY2xhc3MoXCJUd2VlbkxpdGVcIiwgZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMucmVuZGVyID0gVHdlZW5MaXRlLnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cblx0XHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblxuXHRcdFx0XHR2YXIgaXNTZWxlY3RvciA9ICh0YXJnZXQuanF1ZXJ5IHx8ICh0YXJnZXQubGVuZ3RoICYmIHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldFswXSAmJiAodGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgKHRhcmdldFswXS5ub2RlVHlwZSAmJiB0YXJnZXRbMF0uc3R5bGUgJiYgIXRhcmdldC5ub2RlVHlwZSkpKSksXG5cdFx0XHRcdFx0b3ZlcndyaXRlID0gdGhpcy52YXJzLm92ZXJ3cml0ZSxcblx0XHRcdFx0XHRpLCB0YXJnLCB0YXJnZXRzO1xuXG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZSA9IChvdmVyd3JpdGUgPT0gbnVsbCkgPyBfb3ZlcndyaXRlTG9va3VwW1R3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlXSA6ICh0eXBlb2Yob3ZlcndyaXRlKSA9PT0gXCJudW1iZXJcIikgPyBvdmVyd3JpdGUgPj4gMCA6IF9vdmVyd3JpdGVMb29rdXBbb3ZlcndyaXRlXTtcblxuXHRcdFx0XHRpZiAoKGlzU2VsZWN0b3IgfHwgdGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkgfHwgKHRhcmdldC5wdXNoICYmIF9pc0FycmF5KHRhcmdldCkpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gX3NsaWNlKHRhcmdldCk7ICAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IFtdO1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRhcmcgPSB0YXJnZXRzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCF0YXJnKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaS0tXSA9IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnKTsgLy9pbiBjYXNlIGl0J3MgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mKHRhcmcpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSsxLCAxKTsgLy90byBhdm9pZCBhbiBlbmRsZXNzIGxvb3AgKGNhbid0IGltYWdpbmUgd2h5IHRoZSBzZWxlY3RvciB3b3VsZCByZXR1cm4gYSBzdHJpbmcsIGJ1dCBqdXN0IGluIGNhc2UpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmcubGVuZ3RoICYmIHRhcmcgIT09IHdpbmRvdyAmJiB0YXJnWzBdICYmICh0YXJnWzBdID09PSB3aW5kb3cgfHwgKHRhcmdbMF0ubm9kZVR5cGUgJiYgdGFyZ1swXS5zdHlsZSAmJiAhdGFyZy5ub2RlVHlwZSkpKSB7IC8vaW4gY2FzZSB0aGUgdXNlciBpcyBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHNlbGVjdG9yIG9iamVjdHMgKGxpa2UgalF1ZXJ5IG9iamVjdHMpLCB3ZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIGxldmVsIGFuZCBwdWxsIHRoaW5ncyBvdXQgaWYgbmVjZXNzYXJ5LiBBbHNvIG5vdGUgdGhhdCA8c2VsZWN0PiBlbGVtZW50cyBwYXNzIGFsbCB0aGUgY3JpdGVyaWEgcmVnYXJkaW5nIGxlbmd0aCBhbmQgdGhlIGZpcnN0IGNoaWxkIGhhdmluZyBzdHlsZSwgc28gd2UgbXVzdCBhbHNvIGNoZWNrIHRvIGVuc3VyZSB0aGUgdGFyZ2V0IGlzbid0IGFuIEhUTUwgbm9kZSBpdHNlbGYuXG5cdFx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGktLSwgMSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldHMgPSB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoX3NsaWNlKHRhcmcpKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnLCB0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3NbaV0ubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZywgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3NbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BMb29rdXAgPSB7fTtcblx0XHRcdFx0XHR0aGlzLl9zaWJsaW5ncyA9IF9yZWdpc3Rlcih0YXJnZXQsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRlID09PSAxKSBpZiAodGhpcy5fc2libGluZ3MubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0X2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgbnVsbCwgMSwgdGhpcy5fc2libGluZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fZGVsYXkgPT09IDAgJiYgdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfaXNTZWxlY3RvciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuICh2ICYmIHYubGVuZ3RoICYmIHYgIT09IHdpbmRvdyAmJiB2WzBdICYmICh2WzBdID09PSB3aW5kb3cgfHwgKHZbMF0ubm9kZVR5cGUgJiYgdlswXS5zdHlsZSAmJiAhdi5ub2RlVHlwZSkpKTsgLy93ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIGlmIHRoZSB0YXJnZXQgaXMgd2luZG93IGZyb20gd2l0aGluIGFuIGlmcmFtZSwgb3RoZXJ3aXNlIGl0IHdpbGwgdHJpZ2dlciBhIHNlY3VyaXR5IGVycm9yIGluIHNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxuXHRcdFx0fSxcblx0XHRcdF9hdXRvQ1NTID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRcdHZhciBjc3MgPSB7fSxcblx0XHRcdFx0XHRwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gJiYgKCEocCBpbiB0YXJnZXQpIHx8IHAgPT09IFwidHJhbnNmb3JtXCIgfHwgcCA9PT0gXCJ4XCIgfHwgcCA9PT0gXCJ5XCIgfHwgcCA9PT0gXCJ3aWR0aFwiIHx8IHAgPT09IFwiaGVpZ2h0XCIgfHwgcCA9PT0gXCJjbGFzc05hbWVcIiB8fCBwID09PSBcImJvcmRlclwiKSAmJiAoIV9wbHVnaW5zW3BdIHx8IChfcGx1Z2luc1twXSAmJiBfcGx1Z2luc1twXS5fYXV0b0NTUykpKSB7IC8vbm90ZTogPGltZz4gZWxlbWVudHMgY29udGFpbiByZWFkLW9ubHkgXCJ4XCIgYW5kIFwieVwiIHByb3BlcnRpZXMuIFdlIHNob3VsZCBhbHNvIHByaW9yaXRpemUgZWRpdGluZyBjc3Mgd2lkdGgvaGVpZ2h0IHJhdGhlciB0aGFuIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdGNzc1twXSA9IHZhcnNbcF07XG5cdFx0XHRcdFx0XHRkZWxldGUgdmFyc1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycy5jc3MgPSBjc3M7XG5cdFx0XHR9O1xuXG5cdFx0cCA9IFR3ZWVuTGl0ZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblxuLy8tLS0tVHdlZW5MaXRlIGRlZmF1bHRzLCBvdmVyd3JpdGUgbWFuYWdlbWVudCwgYW5kIHJvb3QgdXBkYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLnJhdGlvID0gMDtcblx0XHRwLl9maXJzdFBUID0gcC5fdGFyZ2V0cyA9IHAuX292ZXJ3cml0dGVuUHJvcHMgPSBwLl9zdGFydEF0ID0gbnVsbDtcblx0XHRwLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gcC5fbGF6eSA9IGZhbHNlO1xuXG5cdFx0VHdlZW5MaXRlLnZlcnNpb24gPSBcIjEuMTYuMVwiO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA9IHAuX2Vhc2UgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAxKTtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdE92ZXJ3cml0ZSA9IFwiYXV0b1wiO1xuXHRcdFR3ZWVuTGl0ZS50aWNrZXIgPSBfdGlja2VyO1xuXHRcdFR3ZWVuTGl0ZS5hdXRvU2xlZXAgPSAxMjA7XG5cdFx0VHdlZW5MaXRlLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdF90aWNrZXIubGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5IHx8IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cdFx0XHRpZiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdHJldHVybiBzZWxlY3RvcihlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodHlwZW9mKGRvY3VtZW50KSA9PT0gXCJ1bmRlZmluZWRcIikgPyBlIDogKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGUpIDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X2ludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzID0ge2lzQXJyYXk6X2lzQXJyYXksIGlzU2VsZWN0b3I6X2lzU2VsZWN0b3IsIGxhenlUd2VlbnM6X2xhenlUd2VlbnN9LCAvL2dpdmVzIHVzIGEgd2F5IHRvIGV4cG9zZSBjZXJ0YWluIHByaXZhdGUgdmFsdWVzIHRvIG90aGVyIEdyZWVuU29jayBjbGFzc2VzIHdpdGhvdXQgY29udGFtaW5hdGluZyB0aGEgbWFpbiBUd2VlbkxpdGUgb2JqZWN0LlxuXHRcdFx0X3BsdWdpbnMgPSBUd2VlbkxpdGUuX3BsdWdpbnMgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cCA9IF9pbnRlcm5hbHMudHdlZW5Mb29rdXAgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cE51bSA9IDAsXG5cdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IF9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyA9IHtlYXNlOjEsIGRlbGF5OjEsIG92ZXJ3cml0ZToxLCBvbkNvbXBsZXRlOjEsIG9uQ29tcGxldGVQYXJhbXM6MSwgb25Db21wbGV0ZVNjb3BlOjEsIHVzZUZyYW1lczoxLCBydW5CYWNrd2FyZHM6MSwgc3RhcnRBdDoxLCBvblVwZGF0ZToxLCBvblVwZGF0ZVBhcmFtczoxLCBvblVwZGF0ZVNjb3BlOjEsIG9uU3RhcnQ6MSwgb25TdGFydFBhcmFtczoxLCBvblN0YXJ0U2NvcGU6MSwgb25SZXZlcnNlQ29tcGxldGU6MSwgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSwgb25SZXZlcnNlQ29tcGxldGVTY29wZToxLCBvblJlcGVhdDoxLCBvblJlcGVhdFBhcmFtczoxLCBvblJlcGVhdFNjb3BlOjEsIGVhc2VQYXJhbXM6MSwgeW95bzoxLCBpbW1lZGlhdGVSZW5kZXI6MSwgcmVwZWF0OjEsIHJlcGVhdERlbGF5OjEsIGRhdGE6MSwgcGF1c2VkOjEsIHJldmVyc2VkOjEsIGF1dG9DU1M6MSwgbGF6eToxLCBvbk92ZXJ3cml0ZToxfSxcblx0XHRcdF9vdmVyd3JpdGVMb29rdXAgPSB7bm9uZTowLCBhbGw6MSwgYXV0bzoyLCBjb25jdXJyZW50OjMsIGFsbE9uU3RhcnQ6NCwgcHJlZXhpc3Rpbmc6NSwgXCJ0cnVlXCI6MSwgXCJmYWxzZVwiOjB9LFxuXHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfcm9vdFRpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9uZXh0R0NGcmFtZSA9IDMwLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBfaW50ZXJuYWxzLmxhenlSZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGkgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdFx0dHdlZW47XG5cdFx0XHRcdF9sYXp5TG9va3VwID0ge307XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHR3ZWVuID0gX2xhenlUd2VlbnNbaV07XG5cdFx0XHRcdFx0aWYgKHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXHRcdFx0fTtcblxuXHRcdF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIudGltZTtcblx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLmZyYW1lO1xuXHRcdF9yb290VGltZWxpbmUuX2FjdGl2ZSA9IF9yb290RnJhbWVzVGltZWxpbmUuX2FjdGl2ZSA9IHRydWU7XG5cdFx0c2V0VGltZW91dChfbGF6eVJlbmRlciwgMSk7IC8vb24gc29tZSBtb2JpbGUgZGV2aWNlcywgdGhlcmUgaXNuJ3QgYSBcInRpY2tcIiBiZWZvcmUgY29kZSBydW5zIHdoaWNoIG1lYW5zIGFueSBsYXp5IHJlbmRlcnMgd291bGRuJ3QgcnVuIGJlZm9yZSB0aGUgbmV4dCBvZmZpY2lhbCBcInRpY2tcIi5cblxuXHRcdEFuaW1hdGlvbi5fdXBkYXRlUm9vdCA9IFR3ZWVuTGl0ZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGEsIHA7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pZiBjb2RlIGlzIHJ1biBvdXRzaWRlIG9mIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCwgdGhlcmUgbWF5IGJlIHR3ZWVucyBxdWV1ZWQgQUZURVIgdGhlIGVuZ2luZSByZWZyZXNoZWQsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGFueSBwZW5kaW5nIHJlbmRlcnMgb2NjdXIgYmVmb3JlIHdlIHJlZnJlc2ggYWdhaW4uXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcm9vdFRpbWVsaW5lLnJlbmRlcigoX3RpY2tlci50aW1lIC0gX3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290VGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIuZnJhbWUgLSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RGcmFtZXNUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHsgLy9kdW1wIGdhcmJhZ2UgZXZlcnkgMTIwIGZyYW1lcyBvciB3aGF0ZXZlciB0aGUgdXNlciBzZXRzIFR3ZWVuTGl0ZS5hdXRvU2xlZXAgdG9cblx0XHRcdFx0XHRfbmV4dEdDRnJhbWUgPSBfdGlja2VyLmZyYW1lICsgKHBhcnNlSW50KFR3ZWVuTGl0ZS5hdXRvU2xlZXAsIDEwKSB8fCAxMjApO1xuXHRcdFx0XHRcdGZvciAocCBpbiBfdHdlZW5Mb29rdXApIHtcblx0XHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbcF0udHdlZW5zO1xuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIF90d2Vlbkxvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgbm8gbW9yZSB0d2VlbnMgaW4gdGhlIHJvb3QgdGltZWxpbmVzLCBvciBpZiB0aGV5J3JlIGFsbCBwYXVzZWQsIG1ha2UgdGhlIF90aW1lciBzbGVlcCB0byByZWR1Y2UgbG9hZCBvbiB0aGUgQ1BVIHNsaWdodGx5XG5cdFx0XHRcdFx0cCA9IF9yb290VGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHRcdGlmICghcCB8fCBwLl9wYXVzZWQpIGlmIChUd2VlbkxpdGUuYXV0b1NsZWVwICYmICFfcm9vdEZyYW1lc1RpbWVsaW5lLl9maXJzdCAmJiBfdGlja2VyLl9saXN0ZW5lcnMudGljay5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHdoaWxlIChwICYmIHAuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0XHRwID0gcC5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghcCkge1xuXHRcdFx0XHRcdFx0XHRfdGlja2VyLnNsZWVwKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0X3RpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBBbmltYXRpb24uX3VwZGF0ZVJvb3QpO1xuXG5cdFx0dmFyIF9yZWdpc3RlciA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHNjcnViKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRhcmdldC5fZ3NUd2VlbklELCBhLCBpO1xuXHRcdFx0XHRpZiAoIV90d2Vlbkxvb2t1cFtpZCB8fCAodGFyZ2V0Ll9nc1R3ZWVuSUQgPSBpZCA9IFwidFwiICsgKF90d2Vlbkxvb2t1cE51bSsrKSldKSB7XG5cdFx0XHRcdFx0X3R3ZWVuTG9va3VwW2lkXSA9IHt0YXJnZXQ6dGFyZ2V0LCB0d2VlbnM6W119O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbikge1xuXHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdFx0XHRhWyhpID0gYS5sZW5ndGgpXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdGlmIChzY3J1Yikge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdH0sXG5cblx0XHRcdF9vbk92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBvdmVyd3JpdHRlblR3ZWVuLnZhcnMub25PdmVyd3JpdGUsIHIxLCByMjtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMSA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuYyA9IFR3ZWVuTGl0ZS5vbk92ZXJ3cml0ZTtcblx0XHRcdFx0aWYgKGZ1bmMpIHtcblx0XHRcdFx0XHRyMiA9IGZ1bmMob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChyMSAhPT0gZmFsc2UgJiYgcjIgIT09IGZhbHNlKTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlPdmVyd3JpdGUgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBwcm9wcywgbW9kZSwgc2libGluZ3MpIHtcblx0XHRcdFx0dmFyIGksIGNoYW5nZWQsIGN1clR3ZWVuLCBsO1xuXHRcdFx0XHRpZiAobW9kZSA9PT0gMSB8fCBtb2RlID49IDQpIHtcblx0XHRcdFx0XHRsID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyVHdlZW4gPSBzaWJsaW5nc1tpXSkgIT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghY3VyVHdlZW4uX2djKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF9vbk92ZXJ3cml0ZShjdXJUd2VlbiwgdHdlZW4pICYmIGN1clR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL05PVEU6IEFkZCAwLjAwMDAwMDAwMDEgdG8gb3ZlcmNvbWUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHRoYXQgY2FuIGNhdXNlIHRoZSBzdGFydFRpbWUgdG8gYmUgVkVSWSBzbGlnaHRseSBvZmYgKHdoZW4gYSB0d2VlbidzIHRpbWUoKSBpcyBzZXQgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdHZhciBzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lICsgX3RpbnlOdW0sXG5cdFx0XHRcdFx0b3ZlcmxhcHMgPSBbXSxcblx0XHRcdFx0XHRvQ291bnQgPSAwLFxuXHRcdFx0XHRcdHplcm9EdXIgPSAodHdlZW4uX2R1cmF0aW9uID09PSAwKSxcblx0XHRcdFx0XHRnbG9iYWxTdGFydDtcblx0XHRcdFx0aSA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSA9PT0gdHdlZW4gfHwgY3VyVHdlZW4uX2djIHx8IGN1clR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdC8vaWdub3JlXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fdGltZWxpbmUgIT09IHR3ZWVuLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsU3RhcnQgPSBnbG9iYWxTdGFydCB8fCBfY2hlY2tPdmVybGFwKHR3ZWVuLCAwLCB6ZXJvRHVyKTtcblx0XHRcdFx0XHRcdGlmIChfY2hlY2tPdmVybGFwKGN1clR3ZWVuLCBnbG9iYWxTdGFydCwgemVyb0R1cikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IHN0YXJ0VGltZSkgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgKyBjdXJUd2Vlbi50b3RhbER1cmF0aW9uKCkgLyBjdXJUd2Vlbi5fdGltZVNjYWxlID4gc3RhcnRUaW1lKSBpZiAoISgoemVyb0R1ciB8fCAhY3VyVHdlZW4uX2luaXR0ZWQpICYmIHN0YXJ0VGltZSAtIGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gMC4wMDAwMDAwMDAyKSkge1xuXHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSA9IG9Db3VudDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y3VyVHdlZW4gPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRpZiAobW9kZSA9PT0gMikgaWYgKGN1clR3ZWVuLl9raWxsKHByb3BzLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb2RlICE9PSAyIHx8ICghY3VyVHdlZW4uX2ZpcnN0UFQgJiYgY3VyVHdlZW4uX2luaXR0ZWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiAmJiAhX29uT3ZlcndyaXRlKGN1clR3ZWVuLCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKSkgeyAvL2lmIGFsbCBwcm9wZXJ0eSB0d2VlbnMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0X2NoZWNrT3ZlcmxhcCA9IGZ1bmN0aW9uKHR3ZWVuLCByZWZlcmVuY2UsIHplcm9EdXIpIHtcblx0XHRcdFx0dmFyIHRsID0gdHdlZW4uX3RpbWVsaW5lLFxuXHRcdFx0XHRcdHRzID0gdGwuX3RpbWVTY2FsZSxcblx0XHRcdFx0XHR0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHQgKz0gdGwuX3N0YXJ0VGltZTtcblx0XHRcdFx0XHR0cyAqPSB0bC5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdGlmICh0bC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLTEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dCAvPSB0cztcblx0XHRcdFx0cmV0dXJuICh0ID4gcmVmZXJlbmNlKSA/IHQgLSByZWZlcmVuY2UgOiAoKHplcm9EdXIgJiYgdCA9PT0gcmVmZXJlbmNlKSB8fCAoIXR3ZWVuLl9pbml0dGVkICYmIHQgLSByZWZlcmVuY2UgPCAyICogX3RpbnlOdW0pKSA/IF90aW55TnVtIDogKCh0ICs9IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIHR3ZWVuLl90aW1lU2NhbGUgLyB0cykgPiByZWZlcmVuY2UgKyBfdGlueU51bSkgPyAwIDogdCAtIHJlZmVyZW5jZSAtIF90aW55TnVtO1xuXHRcdFx0fTtcblxuXG4vLy0tLS0gVHdlZW5MaXRlIGluc3RhbmNlIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuX2luaXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRvcCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMsXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSAhIXYuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRlYXNlID0gdi5lYXNlLFxuXHRcdFx0XHRpLCBpbml0UGx1Z2lucywgcHQsIHAsIHN0YXJ0VmFycztcblx0XHRcdGlmICh2LnN0YXJ0QXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vaWYgd2UndmUgcnVuIGEgc3RhcnRBdCBwcmV2aW91c2x5ICh3aGVuIHRoZSB0d2VlbiBpbnN0YW50aWF0ZWQpLCB3ZSBzaG91bGQgcmV2ZXJ0IGl0IHNvIHRoYXQgdGhlIHZhbHVlcyByZS1pbnN0YW50aWF0ZSBjb3JyZWN0bHkgcGFydGljdWxhcmx5IGZvciByZWxhdGl2ZSB0d2VlbnMuIFdpdGhvdXQgdGhpcywgYSBUd2VlbkxpdGUuZnJvbVRvKG9iaiwgMSwge3g6XCIrPTEwMFwifSwge3g6XCItPTEwMFwifSksIGZvciBleGFtcGxlLCB3b3VsZCBhY3R1YWxseSBqdW1wIHRvICs9MjAwIGJlY2F1c2UgdGhlIHN0YXJ0QXQgd291bGQgcnVuIHR3aWNlLCBkb3VibGluZyB0aGUgcmVsYXRpdmUgY2hhbmdlLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycyA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdi5zdGFydEF0KSB7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCAxLCBmcm9tLCB0bykuZnJvbVRvKGUsIDEsIHRvLCBmcm9tKTtcblx0XHRcdFx0XHRzdGFydFZhcnNbcF0gPSB2LnN0YXJ0QXRbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzLm92ZXJ3cml0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGFydFZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0c3RhcnRWYXJzLmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRzdGFydFZhcnMuc3RhcnRBdCA9IHN0YXJ0VmFycy5kZWxheSA9IG51bGw7IC8vbm8gbmVzdGluZyBvZiBzdGFydEF0IG9iamVjdHMgYWxsb3dlZCAob3RoZXJ3aXNlIGl0IGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3ApLlxuXHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBzdGFydFZhcnMpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmVMaXRlL01heCBpbnN0YW5jZXMgd2hlcmUgaW1tZWRpYXRlUmVuZGVyIHdhcyBmYWxzZSAod2hpY2ggaXMgdGhlIGRlZmF1bHQgaW4gdGhlIGNvbnZlbmllbmNlIG1ldGhvZHMgbGlrZSBmcm9tKCkpLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZHVyICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmVMaXRlIG9yIFRpbWVsaW5lTWF4LCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2LnJ1bkJhY2t3YXJkcyAmJiBkdXIgIT09IDApIHtcblx0XHRcdFx0Ly9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSAhPT0gMCkgeyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXHRcdFx0XHRcdFx0aW1tZWRpYXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHYpIHsgLy9jb3B5IHByb3BzIGludG8gYSBuZXcgb2JqZWN0IGFuZCBza2lwIGFueSByZXNlcnZlZCBwcm9wcywgb3RoZXJ3aXNlIG9uQ29tcGxldGUgb3Igb25VcGRhdGUgb3Igb25TdGFydCBjb3VsZCBmaXJlLiBXZSBzaG91bGQsIGhvd2V2ZXIsIHBlcm1pdCBhdXRvQ1NTIHRvIGdvIHRocm91Z2guXG5cdFx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdIHx8IHAgPT09IFwiYXV0b0NTU1wiKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gdltwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQub3ZlcndyaXRlID0gMDtcblx0XHRcdFx0XHRwdC5kYXRhID0gXCJpc0Zyb21TdGFydFwiOyAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cblx0XHRcdFx0XHRwdC5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0XHRwdC5pbW1lZGlhdGVSZW5kZXIgPSBpbW1lZGlhdGU7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgcmVuZGVyIGltbWVkaWF0ZWx5IGJ5IGRlZmF1bHQsIGJ1dCBpZiB3ZSdyZSBub3Qgc3BlY2lmaWNhbGx5IGluc3RydWN0ZWQgdG8gcmVuZGVyIHRoaXMgdHdlZW4gaW1tZWRpYXRlbHksIHdlIHNob3VsZCBza2lwIHRoaXMgYW5kIG1lcmVseSBfaW5pdCgpIHRvIHJlY29yZCB0aGUgc3RhcnRpbmcgdmFsdWVzIChyZW5kZXJpbmcgdGhlbSBpbW1lZGlhdGVseSB3b3VsZCBwdXNoIHRoZW0gdG8gY29tcGxldGlvbiB3aGljaCBpcyB3YXN0ZWZ1bCBpbiB0aGF0IGNhc2UgLSB3ZSdkIGhhdmUgdG8gcmVuZGVyKC0xKSBpbW1lZGlhdGVseSBhZnRlcilcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gVHdlZW5MaXRlLnRvKHRoaXMudGFyZ2V0LCAwLCBwdCk7XG5cdFx0XHRcdFx0aWYgKCFpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2luaXQoKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5fZW5hYmxlZChmYWxzZSk7IC8vbm8gbmVlZCB0byBoYXZlIHRoZSB0d2VlbiByZW5kZXIgb24gdGhlIG5leHQgY3ljbGUuIERpc2FibGUgaXQgYmVjYXVzZSB3ZSdsbCBhbHdheXMgbWFudWFsbHkgY29udHJvbCB0aGUgcmVuZGVycyBvZiB0aGUgX3N0YXJ0QXQgdHdlZW4uXG5cdFx0XHRcdFx0XHRpZiAodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlID0gKCFlYXNlKSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6IChlYXNlIGluc3RhbmNlb2YgRWFzZSkgPyBlYXNlIDogKHR5cGVvZihlYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKGVhc2UsIHYuZWFzZVBhcmFtcykgOiBfZWFzZU1hcFtlYXNlXSB8fCBUd2VlbkxpdGUuZGVmYXVsdEVhc2U7XG5cdFx0XHRpZiAodi5lYXNlUGFyYW1zIGluc3RhbmNlb2YgQXJyYXkgJiYgZWFzZS5jb25maWcpIHtcblx0XHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UuY29uZmlnLmFwcGx5KGVhc2UsIHYuZWFzZVBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlVHlwZSA9IHRoaXMuX2Vhc2UuX3R5cGU7XG5cdFx0XHR0aGlzLl9lYXNlUG93ZXIgPSB0aGlzLl9lYXNlLl9wb3dlcjtcblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5faW5pdFByb3BzKCB0aGlzLl90YXJnZXRzW2ldLCAodGhpcy5fcHJvcExvb2t1cFtpXSA9IHt9KSwgdGhpcy5fc2libGluZ3NbaV0sIChvcCA/IG9wW2ldIDogbnVsbCkpICkge1xuXHRcdFx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0aGlzLl9pbml0UHJvcHModGhpcy50YXJnZXQsIHRoaXMuX3Byb3BMb29rdXAsIHRoaXMuX3NpYmxpbmdzLCBvcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0UGx1Z2lucykge1xuXHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIiwgdGhpcyk7IC8vcmVvcmRlcnMgdGhlIGFycmF5IGluIG9yZGVyIG9mIHByaW9yaXR5LiBVc2VzIGEgc3RhdGljIFR3ZWVuUGx1Z2luIG1ldGhvZCBpbiBvcmRlciB0byBtaW5pbWl6ZSBmaWxlIHNpemUgaW4gVHdlZW5MaXRlXG5cdFx0XHR9XG5cdFx0XHRpZiAob3ApIGlmICghdGhpcy5fZmlyc3RQVCkgaWYgKHR5cGVvZih0aGlzLnRhcmdldCkgIT09IFwiZnVuY3Rpb25cIikgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiwga2lsbCB0aGUgdHdlZW4uIElmIHRoZSB0YXJnZXQgaXMgYSBmdW5jdGlvbiwgaXQncyBwcm9iYWJseSBhIGRlbGF5ZWRDYWxsIHNvIGxldCBpdCBsaXZlLlxuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodi5ydW5CYWNrd2FyZHMpIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRwdC5zICs9IHB0LmM7XG5cdFx0XHRcdFx0cHQuYyA9IC1wdC5jO1xuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX29uVXBkYXRlID0gdi5vblVwZGF0ZTtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdH07XG5cblx0XHRwLl9pbml0UHJvcHMgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKSB7XG5cdFx0XHR2YXIgcCwgaSwgaW5pdFBsdWdpbnMsIHBsdWdpbiwgcHQsIHY7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdKSB7XG5cdFx0XHRcdF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy52YXJzLmNzcykgaWYgKHRhcmdldC5zdHlsZSkgaWYgKHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldC5ub2RlVHlwZSkgaWYgKF9wbHVnaW5zLmNzcykgaWYgKHRoaXMudmFycy5hdXRvQ1NTICE9PSBmYWxzZSkgeyAvL2l0J3Mgc28gY29tbW9uIHRvIHVzZSBUd2VlbkxpdGUvTWF4IHRvIGFuaW1hdGUgdGhlIGNzcyBvZiBET00gZWxlbWVudHMsIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgdGhhdCdzIHdoYXQgaXMgaW50ZW5kZWQgKGEgY29udmVuaWVuY2Ugc28gdGhhdCB1c2VycyBkb24ndCBoYXZlIHRvIHdyYXAgdGhpbmdzIGluIGNzczp7fSwgYWx0aG91Z2ggd2Ugc3RpbGwgcmVjb21tZW5kIGl0IGZvciBhIHNsaWdodCBwZXJmb3JtYW5jZSBib29zdCBhbmQgYmV0dGVyIHNwZWNpZmljaXR5KS4gTm90ZTogd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBvbiB0aGUgd2luZG93IGluc2lkZSBhbiBpZnJhbWUuXG5cdFx0XHRcdF9hdXRvQ1NTKHRoaXMudmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB0aGlzLnZhcnMpIHtcblx0XHRcdFx0diA9IHRoaXMudmFyc1twXTtcblx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0aWYgKHYpIGlmICgodiBpbnN0YW5jZW9mIEFycmF5KSB8fCAodi5wdXNoICYmIF9pc0FycmF5KHYpKSkgaWYgKHYuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzW3BdID0gdiA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModiwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twXSgpKS5fb25Jbml0VHdlZW4odGFyZ2V0LCB0aGlzLnZhcnNbcF0sIHRoaXMpKSB7XG5cblx0XHRcdFx0XHQvL3QgLSB0YXJnZXQgXHRcdFtvYmplY3RdXG5cdFx0XHRcdFx0Ly9wIC0gcHJvcGVydHkgXHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9zIC0gc3RhcnRcdFx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vYyAtIGNoYW5nZVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdC8vZiAtIGlzRnVuY3Rpb25cdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vbiAtIG5hbWVcdFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcGcgLSBpc1BsdWdpbiBcdFtib29sZWFuXVxuXHRcdFx0XHRcdC8vcHIgLSBwcmlvcml0eVx0XHRbbnVtYmVyXVxuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHtfbmV4dDp0aGlzLl9maXJzdFBULCB0OnBsdWdpbiwgcDpcInNldFJhdGlvXCIsIHM6MCwgYzoxLCBmOnRydWUsIG46cCwgcGc6dHJ1ZSwgcHI6cGx1Z2luLl9wcmlvcml0eX07XG5cdFx0XHRcdFx0aSA9IHBsdWdpbi5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cHJvcExvb2t1cFtwbHVnaW4uX292ZXJ3cml0ZVByb3BzW2ldXSA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX3ByaW9yaXR5IHx8IHBsdWdpbi5fb25Jbml0QWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdGluaXRQbHVnaW5zID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fb25EaXNhYmxlIHx8IHBsdWdpbi5fb25FbmFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwcm9wTG9va3VwW3BdID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDp0YXJnZXQsIHA6cCwgZjoodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIiksIG46cCwgcGc6ZmFsc2UsIHByOjB9O1xuXHRcdFx0XHRcdHB0LnMgPSAoIXB0LmYpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdHB0LmMgPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodi5zdWJzdHIoMikpIDogKE51bWJlcih2KSAtIHB0LnMpIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0KSBpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvdmVyd3JpdHRlblByb3BzKSBpZiAodGhpcy5fa2lsbChvdmVyd3JpdHRlblByb3BzLCB0YXJnZXQpKSB7IC8vYW5vdGhlciB0d2VlbiBtYXkgaGF2ZSB0cmllZCB0byBvdmVyd3JpdGUgcHJvcGVydGllcyBvZiB0aGlzIHR3ZWVuIGJlZm9yZSBpbml0KCkgd2FzIGNhbGxlZCAobGlrZSBpZiB0d28gdHdlZW5zIHN0YXJ0IGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBvbmUgY3JlYXRlZCBzZWNvbmQgd2lsbCBydW4gZmlyc3QpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fb3ZlcndyaXRlID4gMSkgaWYgKHRoaXMuX2ZpcnN0UFQpIGlmIChzaWJsaW5ncy5sZW5ndGggPiAxKSBpZiAoX2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgcHJvcExvb2t1cCwgdGhpcy5fb3ZlcndyaXRlLCBzaWJsaW5ncykpIHtcblx0XHRcdFx0dGhpcy5fa2lsbChwcm9wTG9va3VwLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UFQpIGlmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkgeyAvL3plcm8gZHVyYXRpb24gdHdlZW5zIGRvbid0IGxhenkgcmVuZGVyIGJ5IGRlZmF1bHQ7IGV2ZXJ5dGhpbmcgZWxzZSBkb2VzLlxuXHRcdFx0XHRfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluaXRQbHVnaW5zO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgcmF3UHJldlRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSBkdXJhdGlvbikge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygxKSA6IDE7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQgKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwIHx8IHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgIShwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSA9PT0gXCJpc1BhdXNlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0aW1lIC8gZHVyYXRpb24sIHR5cGUgPSB0aGlzLl9lYXNlVHlwZSwgcG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdF9sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkgeyAvL2luIGNhc2UgYSBsYXp5IHJlbmRlciBpcyBwZW5kaW5nLCB3ZSBzaG91bGQgZmx1c2ggaXQgYmVjYXVzZSB0aGUgbmV3IHJlbmRlciBpcyBvY2N1cnJpbmcgbm93IChpbWFnaW5lIGEgbGF6eSB0d2VlbiBpbnN0YW50aWF0aW5nIGFuZCB0aGVuIGltbWVkaWF0ZWx5IHRoZSB1c2VyIGNhbGxzIHR3ZWVuLnNlZWsodHdlZW4uZHVyYXRpb24oKSksIHNraXBwaW5nIHRvIHRoZSBlbmQgLSB0aGUgZW5kIHJlbmRlciB3b3VsZCBiZSBmb3JjZWQsIGFuZCB0aGVuIGlmIHdlIGRpZG4ndCBmbHVzaCB0aGUgbGF6eSByZW5kZXIsIGl0J2QgZmlyZSBBRlRFUiB0aGUgc2VlaygpLCByZW5kZXJpbmcgaXQgYXQgdGhlIHdyb25nIHRpbWUuXG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy52YXJzLm9uU3RhcnQuYXBwbHkodGhpcy52YXJzLm9uU3RhcnRTY29wZSB8fCB0aGlzLCB0aGlzLnZhcnMub25TdGFydFBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdGltZSAhPT0gcHJldlRpbWUgfHwgaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMuX29uVXBkYXRlLmFwcGx5KHRoaXMudmFycy5vblVwZGF0ZVNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblVwZGF0ZVBhcmFtcyB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vLTAuMDAwMSBpcyBhIHNwZWNpYWwgdmFsdWUgdGhhdCB3ZSB1c2Ugd2hlbiBsb29waW5nIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHJlcGVhdGVkIFRpbWVsaW5lTWF4LCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZG4ndCByZW5kZXIgdGhlIF9zdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLnZhcnNbY2FsbGJhY2tdLmFwcGx5KHRoaXMudmFyc1tjYWxsYmFjayArIFwiU2NvcGVcIl0gfHwgdGhpcywgdGhpcy52YXJzW2NhbGxiYWNrICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQsIG92ZXJ3cml0aW5nVHdlZW4pIHtcblx0XHRcdGlmICh2YXJzID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhcnMgPT0gbnVsbCkgaWYgKHRhcmdldCA9PSBudWxsIHx8IHRhcmdldCA9PT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/ICh0YXJnZXQgfHwgdGhpcy5fdGFyZ2V0cyB8fCB0aGlzLnRhcmdldCkgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgaSwgb3ZlcndyaXR0ZW5Qcm9wcywgcCwgcHQsIHByb3BMb29rdXAsIGNoYW5nZWQsIGtpbGxQcm9wcywgcmVjb3JkLCBraWxsZWQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9raWxsKHZhcnMsIHRhcmdldFtpXSkpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCBbXTtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwO1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BMb29rdXApIHtcblx0XHRcdFx0XHRraWxsUHJvcHMgPSB2YXJzIHx8IHByb3BMb29rdXA7XG5cdFx0XHRcdFx0cmVjb3JkID0gKHZhcnMgIT09IG92ZXJ3cml0dGVuUHJvcHMgJiYgb3ZlcndyaXR0ZW5Qcm9wcyAhPT0gXCJhbGxcIiAmJiB2YXJzICE9PSBwcm9wTG9va3VwICYmICh0eXBlb2YodmFycykgIT09IFwib2JqZWN0XCIgfHwgIXZhcnMuX3RlbXBLaWxsKSk7IC8vX3RlbXBLaWxsIGlzIGEgc3VwZXItc2VjcmV0IHdheSB0byBkZWxldGUgYSBwYXJ0aWN1bGFyIHR3ZWVuaW5nIHByb3BlcnR5IGJ1dCBOT1QgaGF2ZSBpdCByZW1lbWJlcmVkIGFzIGFuIG9mZmljaWFsIG92ZXJ3cml0dGVuIHByb3BlcnR5IChsaWtlIGluIEJlemllclBsdWdpbilcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRpbmdUd2VlbiAmJiAoVHdlZW5MaXRlLm9uT3ZlcndyaXRlIHx8IHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BMb29rdXBbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWtpbGxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2lsbGVkID0gW107XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGtpbGxlZC5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIV9vbk92ZXJ3cml0ZSh0aGlzLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZCkpIHsgLy9pZiB0aGUgb25PdmVyd3JpdGUgcmV0dXJuZWQgZmFsc2UsIHRoYXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIG92ZXJ3cml0aW5nIChjYW5jZWwgaXQpLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aWYgKChwdCA9IHByb3BMb29rdXBbcF0pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5wZyAmJiBwdC50Ll9raWxsKGtpbGxQcm9wcykpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTsgLy9zb21lIHBsdWdpbnMgbmVlZCB0byBiZSBub3RpZmllZCBzbyB0aGV5IGNhbiBwZXJmb3JtIGNsZWFudXAgdGFza3MgZmlyc3Rcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnBnIHx8IHB0LnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHByb3BMb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbcF0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcnN0UFQgJiYgdGhpcy5faW5pdHRlZCkgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdGhpcy5fYWN0aXZlID0gdGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9ICh0aGlzLl90YXJnZXRzKSA/IHt9IDogW107XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHR0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuYWJsZWQgJiYgdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZ2V0c1tpXSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRoaXMudGFyZ2V0LCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSBpZiAodGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRyZXR1cm4gVHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KChlbmFibGVkID8gXCJfb25FbmFibGVcIiA6IFwiX29uRGlzYWJsZVwiKSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG4vLy0tLS1Ud2VlbkxpdGUgc3RhdGljIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFR3ZWVuTGl0ZS50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBvbkNvbXBsZXRlU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6c2NvcGUsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlKSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIGEsIGosIHQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdGEgPSBbXTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0YSA9IGEuY29uY2F0KFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXRbaV0sIG9ubHlBY3RpdmUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdC8vbm93IGdldCByaWQgb2YgYW55IGR1cGxpY2F0ZXMgKHR3ZWVucyBvZiBhcnJheXMgb2Ygb2JqZWN0cyBjb3VsZCBjYXVzZSBkdXBsaWNhdGVzKVxuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0ID0gYVtpXTtcblx0XHRcdFx0XHRqID0gaTtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0ID09PSBhW2pdKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YSA9IF9yZWdpc3Rlcih0YXJnZXQpLmNvbmNhdCgpO1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChhW2ldLl9nYyB8fCAob25seUFjdGl2ZSAmJiAhYVtpXS5pc0FjdGl2ZSgpKSkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5raWxsRGVsYXllZENhbGxzVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUsIHZhcnMpIHtcblx0XHRcdGlmICh0eXBlb2Yob25seUFjdGl2ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFycyA9IG9ubHlBY3RpdmU7IC8vZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChiZWZvcmUgXCJvbmx5QWN0aXZlXCIgcGFyYW1ldGVyIHdhcyBpbnNlcnRlZClcblx0XHRcdFx0b25seUFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCBvbmx5QWN0aXZlKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGFbaV0uX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuUGx1Z2luICAgKGNvdWxkIGVhc2lseSBiZSBzcGxpdCBvdXQgYXMgYSBzZXBhcmF0ZSBmaWxlL2NsYXNzLCBidXQgaW5jbHVkZWQgZm9yIGVhc2Ugb2YgdXNlIChzbyB0aGF0IHBlb3BsZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW5vdGhlciBzY3JpcHQgY2FsbCBiZWZvcmUgbG9hZGluZyBwbHVnaW5zIHdoaWNoIGlzIGVhc3kgdG8gZm9yZ2V0KVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuUGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLCBmdW5jdGlvbihwcm9wcywgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IChwcm9wcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcE5hbWUgPSB0aGlzLl9vdmVyd3JpdGVQcm9wc1swXTtcblx0XHRcdFx0XHR0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0cCA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRUd2VlblBsdWdpbi52ZXJzaW9uID0gXCIxLjEwLjFcIjtcblx0XHRUd2VlblBsdWdpbi5BUEkgPSAyO1xuXHRcdHAuX2ZpcnN0UFQgPSBudWxsO1xuXG5cdFx0cC5fYWRkVHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIG92ZXJ3cml0ZVByb3AsIHJvdW5kKSB7XG5cdFx0XHR2YXIgYywgcHQ7XG5cdFx0XHRpZiAoZW5kICE9IG51bGwgJiYgKGMgPSAodHlwZW9mKGVuZCkgPT09IFwibnVtYmVyXCIgfHwgZW5kLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gTnVtYmVyKGVuZCkgLSBzdGFydCA6IHBhcnNlSW50KGVuZC5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKGVuZC5zdWJzdHIoMikpKSkge1xuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSB7X25leHQ6dGhpcy5fZmlyc3RQVCwgdDp0YXJnZXQsIHA6cHJvcCwgczpzdGFydCwgYzpjLCBmOih0eXBlb2YodGFyZ2V0W3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHI6cm91bmR9O1xuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHR2YWw7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0dmFsID0gcHQuYyAqIHYgKyBwdC5zO1xuXHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7IC8vcHJldmVudHMgaXNzdWVzIHdpdGggY29udmVydGluZyB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gc3RyaW5ncyBpbiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHZhbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgYSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtwdC5uXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAobG9va3VwW3RoaXMuX3Byb3BOYW1lXSB8fCAocHQubiAhPSBudWxsICYmIGxvb2t1cFsgcHQubi5zcGxpdCh0aGlzLl9wcm9wTmFtZSArIFwiX1wiKS5qb2luKFwiXCIpIF0pKSB7IC8vc29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZlcnkgcGx1Z2luLXNwZWNpZmljIGFkZCBhIHByZWZpeCBuYW1lZCBhZnRlciB0aGUgX3Byb3BOYW1lIHBsdXMgYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBpZ25vcmUgdGhhdCBleHRyYSBzdHVmZiBoZXJlLlxuXHRcdFx0XHRcdHB0LnIgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQgPSBmdW5jdGlvbih0eXBlLCB0d2Vlbikge1xuXHRcdFx0dmFyIHB0ID0gdHdlZW4uX2ZpcnN0UFQsXG5cdFx0XHRcdGNoYW5nZWQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gXCJfb25Jbml0QWxsUHJvcHNcIikge1xuXHRcdFx0XHQvL3NvcnRzIHRoZSBQcm9wVHdlZW4gbGlua2VkIGxpc3QgaW4gb3JkZXIgb2YgcHJpb3JpdHkgYmVjYXVzZSBzb21lIHBsdWdpbnMgbmVlZCB0byByZW5kZXIgZWFybGllci9sYXRlciB0aGFuIG90aGVycywgbGlrZSBNb3Rpb25CbHVyUGx1Z2luIGFwcGxpZXMgaXRzIGVmZmVjdHMgYWZ0ZXIgYWxsIHgveS9hbHBoYSB0d2VlbnMgaGF2ZSByZW5kZXJlZCBvbiBlYWNoIGZyYW1lLlxuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRuZXh0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0cHQyID0gZmlyc3Q7XG5cdFx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuXHRcdFx0XHRcdFx0cHQyID0gcHQyLl9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkpIHtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcnN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSBwdDIpKSB7XG5cdFx0XHRcdFx0XHRwdDIuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGFzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5wZykgaWYgKHR5cGVvZihwdC50W3R5cGVdKSA9PT0gXCJmdW5jdGlvblwiKSBpZiAocHQudFt0eXBlXSgpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZSA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHRcdHZhciBpID0gcGx1Z2lucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBsdWdpbnNbaV0uQVBJID09PSBUd2VlblBsdWdpbi5BUEkpIHtcblx0XHRcdFx0XHRfcGx1Z2luc1sobmV3IHBsdWdpbnNbaV0oKSkuX3Byb3BOYW1lXSA9IHBsdWdpbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0XHQvL3Byb3ZpZGVzIGEgbW9yZSBjb25jaXNlIHdheSB0byBkZWZpbmUgcGx1Z2lucyB0aGF0IGhhdmUgbm8gZGVwZW5kZW5jaWVzIGJlc2lkZXMgVHdlZW5QbHVnaW4gYW5kIFR3ZWVuTGl0ZSwgd3JhcHBpbmcgY29tbW9uIGJvaWxlcnBsYXRlIHN0dWZmIGludG8gb25lIGZ1bmN0aW9uIChhZGRlZCBpbiAxLjkuMCkuIFlvdSBkb24ndCBORUVEIHRvIHVzZSB0aGlzIHRvIGRlZmluZSBhIHBsdWdpbiAtIHRoZSBvbGQgd2F5IHN0aWxsIHdvcmtzIGFuZCBjYW4gYmUgdXNlZnVsIGluIGNlcnRhaW4gKHJhcmUpIHNpdHVhdGlvbnMuXG5cdFx0X2dzRGVmaW5lLnBsdWdpbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdFx0aWYgKCFjb25maWcgfHwgIWNvbmZpZy5wcm9wTmFtZSB8fCAhY29uZmlnLmluaXQgfHwgIWNvbmZpZy5BUEkpIHsgdGhyb3cgXCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiOyB9XG5cdFx0XHR2YXIgcHJvcE5hbWUgPSBjb25maWcucHJvcE5hbWUsXG5cdFx0XHRcdHByaW9yaXR5ID0gY29uZmlnLnByaW9yaXR5IHx8IDAsXG5cdFx0XHRcdG92ZXJ3cml0ZVByb3BzID0gY29uZmlnLm92ZXJ3cml0ZVByb3BzLFxuXHRcdFx0XHRtYXAgPSB7aW5pdDpcIl9vbkluaXRUd2VlblwiLCBzZXQ6XCJzZXRSYXRpb1wiLCBraWxsOlwiX2tpbGxcIiwgcm91bmQ6XCJfcm91bmRQcm9wc1wiLCBpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LFxuXHRcdFx0XHRQbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlwiICsgcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zdWJzdHIoMSkgKyBcIlBsdWdpblwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdGVQcm9wcyB8fCBbXTtcblx0XHRcdFx0XHR9LCAoY29uZmlnLmdsb2JhbCA9PT0gdHJ1ZSkpLFxuXHRcdFx0XHRwID0gUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihwcm9wTmFtZSksXG5cdFx0XHRcdHByb3A7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gUGx1Z2luO1xuXHRcdFx0UGx1Z2luLkFQSSA9IGNvbmZpZy5BUEk7XG5cdFx0XHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoY29uZmlnW3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cFttYXBbcHJvcF1dID0gY29uZmlnW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRQbHVnaW4udmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uO1xuXHRcdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW1BsdWdpbl0pO1xuXHRcdFx0cmV0dXJuIFBsdWdpbjtcblx0XHR9O1xuXG5cblx0XHQvL25vdyBydW4gdGhyb3VnaCBhbGwgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGFuZCBpZiBhbnkgYXJlIG1pc3NpbmcsIGxvZyB0aGF0IHRvIHRoZSBjb25zb2xlIGFzIGEgd2FybmluZy4gVGhpcyBpcyB3aHkgaXQncyBiZXN0IHRvIGhhdmUgVHdlZW5MaXRlIGxvYWQgbGFzdCAtIGl0IGNhbiBjaGVjayBhbGwgdGhlIGRlcGVuZGVuY2llcyBmb3IgeW91LlxuXHRcdGEgPSB3aW5kb3cuX2dzUXVldWU7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGFbaV0oKTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiBfZGVmTG9va3VwKSB7XG5cdFx0XHRcdGlmICghX2RlZkxvb2t1cFtwXS5mdW5jKSB7XG5cdFx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKFwiR1NBUCBlbmNvdW50ZXJlZCBtaXNzaW5nIGRlcGVuZGVuY3k6IGNvbS5ncmVlbnNvY2suXCIgKyBwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF90aWNrZXJBY3RpdmUgPSBmYWxzZTsgLy9lbnN1cmVzIHRoYXQgdGhlIGZpcnN0IG9mZmljaWFsIGFuaW1hdGlvbiBmb3JjZXMgYSB0aWNrZXIudGljaygpIHRvIHVwZGF0ZSB0aGUgdGltZSB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZFxuXG59KSgodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3csIFwiVHdlZW5MaXRlXCIpOyIsIi8qISBCYWJ5bG9uIDIwMTQtMDgtMDggKi9cbnZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBhJiYoYT0wKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9MCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTApLHRoaXMucj1hLHRoaXMuZz1iLHRoaXMuYj1jfXJldHVybiBhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwie1I6IFwiK3RoaXMucitcIiBHOlwiK3RoaXMuZytcIiBCOlwiK3RoaXMuYitcIn1cIn0sYS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApLGFbYl09dGhpcy5yLGFbYisxXT10aGlzLmcsYVtiKzJdPXRoaXMuYn0sYS5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLnRvQXJyYXkoYSwwKSxhfSxhLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy5yKmIucix0aGlzLmcqYi5nLHRoaXMuYipiLmIpfSxhLnByb3RvdHlwZS5tdWx0aXBseVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5yPXRoaXMuciphLnIsYi5nPXRoaXMuZyphLmcsYi5iPXRoaXMuYiphLmJ9LGEucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmdGhpcy5yPT09YS5yJiZ0aGlzLmc9PT1hLmcmJnRoaXMuYj09PWEuYn0sYS5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMucipiLHRoaXMuZypiLHRoaXMuYipiKX0sYS5wcm90b3R5cGUuc2NhbGVUb1JlZj1mdW5jdGlvbihhLGIpe2Iucj10aGlzLnIqYSxiLmc9dGhpcy5nKmEsYi5iPXRoaXMuYiphfSxhLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMucitiLnIsdGhpcy5nK2IuZyx0aGlzLmIrYi5iKX0sYS5wcm90b3R5cGUuYWRkVG9SZWY9ZnVuY3Rpb24oYSxiKXtiLnI9dGhpcy5yK2EucixiLmc9dGhpcy5nK2EuZyxiLmI9dGhpcy5iK2EuYn0sYS5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMuci1iLnIsdGhpcy5nLWIuZyx0aGlzLmItYi5iKX0sYS5wcm90b3R5cGUuc3VidHJhY3RUb1JlZj1mdW5jdGlvbihhLGIpe2Iucj10aGlzLnItYS5yLGIuZz10aGlzLmctYS5nLGIuYj10aGlzLmItYS5ifSxhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLnIsdGhpcy5nLHRoaXMuYil9LGEucHJvdG90eXBlLmNvcHlGcm9tPWZ1bmN0aW9uKGEpe3RoaXMucj1hLnIsdGhpcy5nPWEuZyx0aGlzLmI9YS5ifSxhLnByb3RvdHlwZS5jb3B5RnJvbUZsb2F0cz1mdW5jdGlvbihhLGIsYyl7dGhpcy5yPWEsdGhpcy5nPWIsdGhpcy5iPWN9LGEuRnJvbUFycmF5PWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYShiWzBdLGJbMV0sYlsyXSl9LGEuRnJvbUludHM9ZnVuY3Rpb24oYixjLGQpe3JldHVybiBuZXcgYShiLzI1NSxjLzI1NSxkLzI1NSl9LGEuTGVycD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9Yi5yKyhjLnItYi5yKSpkLGY9Yi5nKyhjLmctYi5nKSpkLGc9Yi5iKyhjLmItYi5iKSpkO3JldHVybiBuZXcgYShlLGYsZyl9LGEuUmVkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDEsMCwwKX0sYS5HcmVlbj1mdW5jdGlvbigpe3JldHVybiBuZXcgYSgwLDEsMCl9LGEuQmx1ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYSgwLDAsMSl9LGEuQmxhY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMCwwLDApfSxhLldoaXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDEsMSwxKX0sYS5QdXJwbGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoLjUsMCwuNSl9LGEuTWFnZW50YT1mdW5jdGlvbigpe3JldHVybiBuZXcgYSgxLDAsMSl9LGEuWWVsbG93PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDEsMSwwKX0sYS5HcmF5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKC41LC41LC41KX0sYX0oKTthLkNvbG9yMz1iO3ZhciBjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyxkKXt0aGlzLnI9YSx0aGlzLmc9Yix0aGlzLmI9Yyx0aGlzLmE9ZH1yZXR1cm4gYi5wcm90b3R5cGUuYWRkSW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLnIrPWEucix0aGlzLmcrPWEuZyx0aGlzLmIrPWEuYix0aGlzLmErPWEuYX0sYi5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLnRvQXJyYXkoYSwwKSxhfSxiLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9MCksYVtiXT10aGlzLnIsYVtiKzFdPXRoaXMuZyxhW2IrMl09dGhpcy5iLGFbYiszXT10aGlzLmF9LGIucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIodGhpcy5yK2Eucix0aGlzLmcrYS5nLHRoaXMuYithLmIsdGhpcy5hK2EuYSl9LGIucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLnItYS5yLHRoaXMuZy1hLmcsdGhpcy5iLWEuYix0aGlzLmEtYS5hKX0sYi5wcm90b3R5cGUuc3VidHJhY3RUb1JlZj1mdW5jdGlvbihhLGIpe2Iucj10aGlzLnItYS5yLGIuZz10aGlzLmctYS5nLGIuYj10aGlzLmItYS5iLGIuYT10aGlzLmEtYS5hfSxiLnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIodGhpcy5yKmEsdGhpcy5nKmEsdGhpcy5iKmEsdGhpcy5hKmEpfSxiLnByb3RvdHlwZS5zY2FsZVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5yPXRoaXMuciphLGIuZz10aGlzLmcqYSxiLmI9dGhpcy5iKmEsYi5hPXRoaXMuYSphfSxiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwie1I6IFwiK3RoaXMucitcIiBHOlwiK3RoaXMuZytcIiBCOlwiK3RoaXMuYitcIiBBOlwiK3RoaXMuYStcIn1cIn0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIodGhpcy5yLHRoaXMuZyx0aGlzLmIsdGhpcy5hKX0sYi5MZXJwPWZ1bmN0aW9uKGMsZCxlKXt2YXIgZj1uZXcgYigwLDAsMCwwKTtyZXR1cm4gYS5Db2xvcjQuTGVycFRvUmVmKGMsZCxlLGYpLGZ9LGIuTGVycFRvUmVmPWZ1bmN0aW9uKGEsYixjLGQpe2Qucj1hLnIrKGIuci1hLnIpKmMsZC5nPWEuZysoYi5nLWEuZykqYyxkLmI9YS5iKyhiLmItYS5iKSpjLGQuYT1hLmErKGIuYS1hLmEpKmN9LGIuRnJvbUFycmF5PWZ1bmN0aW9uKGEsYyl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTApLG5ldyBiKGFbY10sYVtjKzFdLGFbYysyXSxhW2MrM10pfSxiLkZyb21JbnRzPWZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiBuZXcgYihhLzI1NSxjLzI1NSxkLzI1NSxlLzI1NSl9LGJ9KCk7YS5Db2xvcjQ9Yzt2YXIgZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXt0aGlzLng9YSx0aGlzLnk9Yn1yZXR1cm4gYS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIntYOiBcIit0aGlzLngrXCIgWTpcIit0aGlzLnkrXCJ9XCJ9LGEucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj0wKSxhW2JdPXRoaXMueCxhW2IrMV09dGhpcy55fSxhLnByb3RvdHlwZS5hc0FycmF5PWZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIHRoaXMudG9BcnJheShhLDApLGF9LGEucHJvdG90eXBlLmNvcHlGcm9tPWZ1bmN0aW9uKGEpe3RoaXMueD1hLngsdGhpcy55PWEueX0sYS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLngrYi54LHRoaXMueStiLnkpfSxhLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy54LWIueCx0aGlzLnktYi55KX0sYS5wcm90b3R5cGUubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKC10aGlzLngsLXRoaXMueSl9LGEucHJvdG90eXBlLnNjYWxlSW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLngqPWEsdGhpcy55Kj1hfSxhLnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy54KmIsdGhpcy55KmIpfSxhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnRoaXMueD09PWEueCYmdGhpcy55PT09YS55fSxhLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSl9LGEucHJvdG90eXBlLmxlbmd0aFNxdWFyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55fSxhLnByb3RvdHlwZS5ub3JtYWxpemU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxlbmd0aCgpO2lmKDAhPT1hKXt2YXIgYj0xL2E7dGhpcy54Kj1iLHRoaXMueSo9Yn19LGEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKHRoaXMueCx0aGlzLnkpfSxhLlplcm89ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMCwwKX0sYS5Gcm9tQXJyYXk9ZnVuY3Rpb24oYixjKXtyZXR1cm4gY3x8KGM9MCksbmV3IGEoYltjXSxiW2MrMV0pfSxhLkNhdG11bGxSb209ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1mKmYsaD1mKmcsaT0uNSooMipjLngrKC1iLngrZC54KSpmKygyKmIueC01KmMueCs0KmQueC1lLngpKmcrKC1iLngrMypjLngtMypkLngrZS54KSpoKSxqPS41KigyKmMueSsoLWIueStkLnkpKmYrKDIqYi55LTUqYy55KzQqZC55LWUueSkqZysoLWIueSszKmMueS0zKmQueStlLnkpKmgpO3JldHVybiBuZXcgYShpLGopfSxhLkNsYW1wPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1iLng7ZT1lPmQueD9kLng6ZSxlPWU8Yy54P2MueDplO3ZhciBmPWIueTtyZXR1cm4gZj1mPmQueT9kLnk6ZixmPWY8Yy55P2MueTpmLG5ldyBhKGUsZil9LGEuSGVybWl0ZT1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPWYqZixoPWYqZyxpPTIqaC0zKmcrMSxqPS0yKmgrMypnLGs9aC0yKmcrZixsPWgtZyxtPWIueCppK2QueCpqK2MueCprK2UueCpsLG49Yi55KmkrZC55KmorYy55KmsrZS55Kmw7cmV0dXJuIG5ldyBhKG0sbil9LGEuTGVycD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9Yi54KyhjLngtYi54KSpkLGY9Yi55KyhjLnktYi55KSpkO3JldHVybiBuZXcgYShlLGYpfSxhLkRvdD1mdW5jdGlvbihhLGIpe3JldHVybiBhLngqYi54K2EueSpiLnl9LGEuTm9ybWFsaXplPWZ1bmN0aW9uKGEpe3ZhciBiPWEuY2xvbmUoKTtyZXR1cm4gYi5ub3JtYWxpemUoKSxifSxhLk1pbmltaXplPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi54PGMueD9iLng6Yy54LGU9Yi55PGMueT9iLnk6Yy55O3JldHVybiBuZXcgYShkLGUpfSxhLk1heGltaXplPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi54PmMueD9iLng6Yy54LGU9Yi55PmMueT9iLnk6Yy55O3JldHVybiBuZXcgYShkLGUpfSxhLlRyYW5zZm9ybT1mdW5jdGlvbihiLGMpe3ZhciBkPWIueCpjLm1bMF0rYi55KmMubVs0XSxlPWIueCpjLm1bMV0rYi55KmMubVs1XTtyZXR1cm4gbmV3IGEoZCxlKX0sYS5EaXN0YW5jZT1mdW5jdGlvbihiLGMpe3JldHVybiBNYXRoLnNxcnQoYS5EaXN0YW5jZVNxdWFyZWQoYixjKSl9LGEuRGlzdGFuY2VTcXVhcmVkPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS54LWIueCxkPWEueS1iLnk7cmV0dXJuIGMqYytkKmR9LGF9KCk7YS5WZWN0b3IyPWQ7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjKXt0aGlzLng9YSx0aGlzLnk9Yix0aGlzLno9Y31yZXR1cm4gYi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIntYOiBcIit0aGlzLngrXCIgWTpcIit0aGlzLnkrXCIgWjpcIit0aGlzLnorXCJ9XCJ9LGIucHJvdG90eXBlLmFzQXJyYXk9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy50b0FycmF5KGEsMCksYX0sYi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApLGFbYl09dGhpcy54LGFbYisxXT10aGlzLnksYVtiKzJdPXRoaXMuen0sYi5wcm90b3R5cGUuYWRkSW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLngrPWEueCx0aGlzLnkrPWEueSx0aGlzLnorPWEuen0sYi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLngrYS54LHRoaXMueSthLnksdGhpcy56K2Eueil9LGIucHJvdG90eXBlLmFkZFRvUmVmPWZ1bmN0aW9uKGEsYil7Yi54PXRoaXMueCthLngsYi55PXRoaXMueSthLnksYi56PXRoaXMueithLnp9LGIucHJvdG90eXBlLnN1YnRyYWN0SW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLngtPWEueCx0aGlzLnktPWEueSx0aGlzLnotPWEuen0sYi5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMueC1hLngsdGhpcy55LWEueSx0aGlzLnotYS56KX0sYi5wcm90b3R5cGUuc3VidHJhY3RUb1JlZj1mdW5jdGlvbihhLGIpe2IueD10aGlzLngtYS54LGIueT10aGlzLnktYS55LGIuej10aGlzLnotYS56fSxiLnByb3RvdHlwZS5zdWJ0cmFjdEZyb21GbG9hdHM9ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBuZXcgYih0aGlzLngtYSx0aGlzLnktYyx0aGlzLnotZCl9LGIucHJvdG90eXBlLnN1YnRyYWN0RnJvbUZsb2F0c1RvUmVmPWZ1bmN0aW9uKGEsYixjLGQpe2QueD10aGlzLngtYSxkLnk9dGhpcy55LWIsZC56PXRoaXMuei1jfSxiLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIoLXRoaXMueCwtdGhpcy55LC10aGlzLnopfSxiLnByb3RvdHlwZS5zY2FsZUluUGxhY2U9ZnVuY3Rpb24oYSl7dGhpcy54Kj1hLHRoaXMueSo9YSx0aGlzLnoqPWF9LGIucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLngqYSx0aGlzLnkqYSx0aGlzLnoqYSl9LGIucHJvdG90eXBlLnNjYWxlVG9SZWY9ZnVuY3Rpb24oYSxiKXtiLng9dGhpcy54KmEsYi55PXRoaXMueSphLGIuej10aGlzLnoqYX0sYi5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBhJiZ0aGlzLng9PT1hLngmJnRoaXMueT09PWEueSYmdGhpcy56PT09YS56fSxiLnByb3RvdHlwZS5lcXVhbHNXaXRoRXBzaWxvbj1mdW5jdGlvbihiKXtyZXR1cm4gTWF0aC5hYnModGhpcy54LWIueCk8YS5FbmdpbmUuRXBzaWxvbiYmTWF0aC5hYnModGhpcy55LWIueSk8YS5FbmdpbmUuRXBzaWxvbiYmTWF0aC5hYnModGhpcy56LWIueik8YS5FbmdpbmUuRXBzaWxvbn0sYi5wcm90b3R5cGUuZXF1YWxzVG9GbG9hdHM9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLng9PT1hJiZ0aGlzLnk9PT1iJiZ0aGlzLno9PT1jfSxiLnByb3RvdHlwZS5tdWx0aXBseUluUGxhY2U9ZnVuY3Rpb24oYSl7dGhpcy54Kj1hLngsdGhpcy55Kj1hLnksdGhpcy56Kj1hLnp9LGIucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLngqYS54LHRoaXMueSphLnksdGhpcy56KmEueil9LGIucHJvdG90eXBlLm11bHRpcGx5VG9SZWY9ZnVuY3Rpb24oYSxiKXtiLng9dGhpcy54KmEueCxiLnk9dGhpcy55KmEueSxiLno9dGhpcy56KmEuen0sYi5wcm90b3R5cGUubXVsdGlwbHlCeUZsb2F0cz1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIG5ldyBiKHRoaXMueCphLHRoaXMueSpjLHRoaXMueipkKX0sYi5wcm90b3R5cGUuZGl2aWRlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLngvYS54LHRoaXMueS9hLnksdGhpcy56L2Eueil9LGIucHJvdG90eXBlLmRpdmlkZVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi54PXRoaXMueC9hLngsYi55PXRoaXMueS9hLnksYi56PXRoaXMuei9hLnp9LGIucHJvdG90eXBlLk1pbmltaXplSW5QbGFjZT1mdW5jdGlvbihhKXthLng8dGhpcy54JiYodGhpcy54PWEueCksYS55PHRoaXMueSYmKHRoaXMueT1hLnkpLGEuejx0aGlzLnomJih0aGlzLno9YS56KX0sYi5wcm90b3R5cGUuTWF4aW1pemVJblBsYWNlPWZ1bmN0aW9uKGEpe2EueD50aGlzLngmJih0aGlzLng9YS54KSxhLnk+dGhpcy55JiYodGhpcy55PWEueSksYS56PnRoaXMueiYmKHRoaXMuej1hLnopfSxiLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56KX0sYi5wcm90b3R5cGUubGVuZ3RoU3F1YXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMuen0sYi5wcm90b3R5cGUubm9ybWFsaXplPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5sZW5ndGgoKTtpZigwIT09YSl7dmFyIGI9MS9hO3RoaXMueCo9Yix0aGlzLnkqPWIsdGhpcy56Kj1ifX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIodGhpcy54LHRoaXMueSx0aGlzLnopfSxiLnByb3RvdHlwZS5jb3B5RnJvbT1mdW5jdGlvbihhKXt0aGlzLng9YS54LHRoaXMueT1hLnksdGhpcy56PWEuen0sYi5wcm90b3R5cGUuY29weUZyb21GbG9hdHM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMueD1hLHRoaXMueT1iLHRoaXMuej1jfSxiLkZyb21BcnJheT1mdW5jdGlvbihhLGMpe3JldHVybiBjfHwoYz0wKSxuZXcgYihhW2NdLGFbYysxXSxhW2MrMl0pfSxiLkZyb21BcnJheVRvUmVmPWZ1bmN0aW9uKGEsYixjKXtjLng9YVtiXSxjLnk9YVtiKzFdLGMuej1hW2IrMl19LGIuRnJvbUZsb2F0QXJyYXlUb1JlZj1mdW5jdGlvbihhLGIsYyl7Yy54PWFbYl0sYy55PWFbYisxXSxjLno9YVtiKzJdfSxiLkZyb21GbG9hdHNUb1JlZj1mdW5jdGlvbihhLGIsYyxkKXtkLng9YSxkLnk9YixkLno9Y30sYi5aZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiKDAsMCwwKX0sYi5VcD1mdW5jdGlvbigpe3JldHVybiBuZXcgYigwLDEsMCl9LGIuVHJhbnNmb3JtQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oYSxjKXt2YXIgZD1iLlplcm8oKTtyZXR1cm4gYi5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKGEsYyxkKSxkfSxiLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWY9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWEueCpiLm1bMF0rYS55KmIubVs0XSthLnoqYi5tWzhdK2IubVsxMl0sZT1hLngqYi5tWzFdK2EueSpiLm1bNV0rYS56KmIubVs5XStiLm1bMTNdLGY9YS54KmIubVsyXSthLnkqYi5tWzZdK2EueipiLm1bMTBdK2IubVsxNF0sZz1hLngqYi5tWzNdK2EueSpiLm1bN10rYS56KmIubVsxMV0rYi5tWzE1XTtjLng9ZC9nLGMueT1lL2csYy56PWYvZ30sYi5UcmFuc2Zvcm1Db29yZGluYXRlc0Zyb21GbG9hdHNUb1JlZj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEqZC5tWzBdK2IqZC5tWzRdK2MqZC5tWzhdK2QubVsxMl0sZz1hKmQubVsxXStiKmQubVs1XStjKmQubVs5XStkLm1bMTNdLGg9YSpkLm1bMl0rYipkLm1bNl0rYypkLm1bMTBdK2QubVsxNF0saT1hKmQubVszXStiKmQubVs3XStjKmQubVsxMV0rZC5tWzE1XTtlLng9Zi9pLGUueT1nL2ksZS56PWgvaX0sYi5UcmFuc2Zvcm1Ob3JtYWw9ZnVuY3Rpb24oYSxjKXt2YXIgZD1iLlplcm8oKTtyZXR1cm4gYi5UcmFuc2Zvcm1Ob3JtYWxUb1JlZihhLGMsZCksZH0sYi5UcmFuc2Zvcm1Ob3JtYWxUb1JlZj1mdW5jdGlvbihhLGIsYyl7Yy54PWEueCpiLm1bMF0rYS55KmIubVs0XSthLnoqYi5tWzhdLGMueT1hLngqYi5tWzFdK2EueSpiLm1bNV0rYS56KmIubVs5XSxjLno9YS54KmIubVsyXSthLnkqYi5tWzZdK2EueipiLm1bMTBdfSxiLlRyYW5zZm9ybU5vcm1hbEZyb21GbG9hdHNUb1JlZj1mdW5jdGlvbihhLGIsYyxkLGUpe2UueD1hKmQubVswXStiKmQubVs0XStjKmQubVs4XSxlLnk9YSpkLm1bMV0rYipkLm1bNV0rYypkLm1bOV0sZS56PWEqZC5tWzJdK2IqZC5tWzZdK2MqZC5tWzEwXX0sYi5DYXRtdWxsUm9tPWZ1bmN0aW9uKGEsYyxkLGUsZil7dmFyIGc9ZipmLGg9ZipnLGk9LjUqKDIqYy54KygtYS54K2QueCkqZisoMiphLngtNSpjLngrNCpkLngtZS54KSpnKygtYS54KzMqYy54LTMqZC54K2UueCkqaCksaj0uNSooMipjLnkrKC1hLnkrZC55KSpmKygyKmEueS01KmMueSs0KmQueS1lLnkpKmcrKC1hLnkrMypjLnktMypkLnkrZS55KSpoKSxrPS41KigyKmMueisoLWEueitkLnopKmYrKDIqYS56LTUqYy56KzQqZC56LWUueikqZysoLWEueiszKmMuei0zKmQueitlLnopKmgpO3JldHVybiBuZXcgYihpLGosayl9LGIuQ2xhbXA9ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWEueDtlPWU+ZC54P2QueDplLGU9ZTxjLng/Yy54OmU7dmFyIGY9YS55O2Y9Zj5kLnk/ZC55OmYsZj1mPGMueT9jLnk6Zjt2YXIgZz1hLno7cmV0dXJuIGc9Zz5kLno/ZC56OmcsZz1nPGMuej9jLno6ZyxuZXcgYihlLGYsZyl9LGIuSGVybWl0ZT1mdW5jdGlvbihhLGMsZCxlLGYpe3ZhciBnPWYqZixoPWYqZyxpPTIqaC0zKmcrMSxqPS0yKmgrMypnLGs9aC0yKmcrZixsPWgtZyxtPWEueCppK2QueCpqK2MueCprK2UueCpsLG49YS55KmkrZC55KmorYy55KmsrZS55Kmwsbz1hLnoqaStkLnoqaitjLnoqaytlLnoqbDtyZXR1cm4gbmV3IGIobSxuLG8pfSxiLkxlcnA9ZnVuY3Rpb24oYSxjLGQpe3ZhciBlPWEueCsoYy54LWEueCkqZCxmPWEueSsoYy55LWEueSkqZCxnPWEueisoYy56LWEueikqZDtyZXR1cm4gbmV3IGIoZSxmLGcpfSxiLkRvdD1mdW5jdGlvbihhLGIpe3JldHVybiBhLngqYi54K2EueSpiLnkrYS56KmIuen0sYi5Dcm9zcz1mdW5jdGlvbihhLGMpe3ZhciBkPWIuWmVybygpO3JldHVybiBiLkNyb3NzVG9SZWYoYSxjLGQpLGR9LGIuQ3Jvc3NUb1JlZj1mdW5jdGlvbihhLGIsYyl7Yy54PWEueSpiLnotYS56KmIueSxjLnk9YS56KmIueC1hLngqYi56LGMuej1hLngqYi55LWEueSpiLnh9LGIuTm9ybWFsaXplPWZ1bmN0aW9uKGEpe3ZhciBjPWIuWmVybygpO3JldHVybiBiLk5vcm1hbGl6ZVRvUmVmKGEsYyksY30sYi5Ob3JtYWxpemVUb1JlZj1mdW5jdGlvbihhLGIpe2IuY29weUZyb20oYSksYi5ub3JtYWxpemUoKX0sYi5Qcm9qZWN0PWZ1bmN0aW9uKGMsZCxlLGYpe3ZhciBnPWYud2lkdGgsaD1mLmhlaWdodCxpPWYueCxqPWYueSxrPWEuTWF0cml4LkZyb21WYWx1ZXMoZy8yLDAsMCwwLDAsLWgvMiwwLDAsMCwwLDEsMCxpK2cvMixoLzIraiwwLDEpLGw9ZC5tdWx0aXBseShlKS5tdWx0aXBseShrKTtyZXR1cm4gYi5UcmFuc2Zvcm1Db29yZGluYXRlcyhjLGwpfSxiLlVucHJvamVjdD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dmFyIGg9ZS5tdWx0aXBseShmKS5tdWx0aXBseShnKTtoLmludmVydCgpLGIueD1iLngvYyoyLTEsYi55PS0oYi55L2QqMi0xKTt2YXIgaT1hLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXMoYixoKSxqPWIueCpoLm1bM10rYi55KmgubVs3XStiLnoqaC5tWzExXStoLm1bMTVdO3JldHVybiBhLlRvb2xzLldpdGhpbkVwc2lsb24oaiwxKSYmKGk9aS5zY2FsZSgxL2opKSxpfSxiLk1pbmltaXplPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jbG9uZSgpO3JldHVybiBjLk1pbmltaXplSW5QbGFjZShiKSxjfSxiLk1heGltaXplPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jbG9uZSgpO3JldHVybiBjLk1heGltaXplSW5QbGFjZShiKSxjfSxiLkRpc3RhbmNlPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIE1hdGguc3FydChiLkRpc3RhbmNlU3F1YXJlZChhLGMpKX0sYi5EaXN0YW5jZVNxdWFyZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLngtYi54LGQ9YS55LWIueSxlPWEuei1iLno7cmV0dXJuIGMqYytkKmQrZSplfSxiLkNlbnRlcj1mdW5jdGlvbihhLGIpe3ZhciBjPWEuYWRkKGIpO3JldHVybiBjLnNjYWxlSW5QbGFjZSguNSksY30sYn0oKTthLlZlY3RvcjM9ZTt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMsZCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGEmJihhPTApLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiJiYoYj0wKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9MCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGQmJihkPTApLHRoaXMueD1hLHRoaXMueT1iLHRoaXMuej1jLHRoaXMudz1kfXJldHVybiBhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwie1g6IFwiK3RoaXMueCtcIiBZOlwiK3RoaXMueStcIiBaOlwiK3RoaXMueitcIiBXOlwiK3RoaXMudytcIn1cIn0sYS5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLnddfSxhLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnRoaXMueD09PWEueCYmdGhpcy55PT09YS55JiZ0aGlzLno9PT1hLnomJnRoaXMudz09PWEud30sYS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcy54LHRoaXMueSx0aGlzLnosdGhpcy53KX0sYS5wcm90b3R5cGUuY29weUZyb209ZnVuY3Rpb24oYSl7dGhpcy54PWEueCx0aGlzLnk9YS55LHRoaXMuej1hLnosdGhpcy53PWEud30sYS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLngrYi54LHRoaXMueStiLnksdGhpcy56K2Iueix0aGlzLncrYi53KX0sYS5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMueC1iLngsdGhpcy55LWIueSx0aGlzLnotYi56LHRoaXMudy1iLncpfSxhLnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy54KmIsdGhpcy55KmIsdGhpcy56KmIsdGhpcy53KmIpfSxhLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYSgwLDAsMCwxKTtyZXR1cm4gdGhpcy5tdWx0aXBseVRvUmVmKGIsYyksY30sYS5wcm90b3R5cGUubXVsdGlwbHlUb1JlZj1mdW5jdGlvbihhLGIpe2IueD10aGlzLngqYS53K3RoaXMueSphLnotdGhpcy56KmEueSt0aGlzLncqYS54LGIueT0tdGhpcy54KmEueit0aGlzLnkqYS53K3RoaXMueiphLngrdGhpcy53KmEueSxiLno9dGhpcy54KmEueS10aGlzLnkqYS54K3RoaXMueiphLncrdGhpcy53KmEueixiLnc9LXRoaXMueCphLngtdGhpcy55KmEueS10aGlzLnoqYS56K3RoaXMudyphLnd9LGEucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyl9LGEucHJvdG90eXBlLm5vcm1hbGl6ZT1mdW5jdGlvbigpe3ZhciBhPTEvdGhpcy5sZW5ndGgoKTt0aGlzLngqPWEsdGhpcy55Kj1hLHRoaXMueio9YSx0aGlzLncqPWF9LGEucHJvdG90eXBlLnRvRXVsZXJBbmdsZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLngsYj10aGlzLnksYz10aGlzLnosZD10aGlzLncsZj1hKmEsZz1iKmIsaD1jKmMsaT1NYXRoLmF0YW4yKDIqKGIqZC1hKmMpLDEtMiooZytoKSksaj1NYXRoLmFzaW4oMiooYSpiK2MqZCkpLGs9TWF0aC5hdGFuMigyKihhKmQtYipjKSwxLTIqKGYraCkpLGw9YSpiK2MqZDtyZXR1cm4gbD4uNDk5PyhpPTIqTWF0aC5hdGFuMihhLGQpLGs9MCk6LS40OTk+bCYmKGk9LTIqTWF0aC5hdGFuMihhLGQpLGs9MCksbmV3IGUoaixpLGspfSxhLnByb3RvdHlwZS50b1JvdGF0aW9uTWF0cml4PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueCp0aGlzLngsYz10aGlzLnkqdGhpcy55LGQ9dGhpcy56KnRoaXMueixlPXRoaXMueCp0aGlzLnksZj10aGlzLnoqdGhpcy53LGc9dGhpcy56KnRoaXMueCxoPXRoaXMueSp0aGlzLncsaT10aGlzLnkqdGhpcy56LGo9dGhpcy54KnRoaXMudzthLm1bMF09MS0yKihjK2QpLGEubVsxXT0yKihlK2YpLGEubVsyXT0yKihnLWgpLGEubVszXT0wLGEubVs0XT0yKihlLWYpLGEubVs1XT0xLTIqKGQrYiksYS5tWzZdPTIqKGkraiksYS5tWzddPTAsYS5tWzhdPTIqKGcraCksYS5tWzldPTIqKGktaiksYS5tWzEwXT0xLTIqKGMrYiksYS5tWzExXT0wLGEubVsxMl09MCxhLm1bMTNdPTAsYS5tWzE0XT0wLGEubVsxNV09MX0sYS5wcm90b3R5cGUuZnJvbVJvdGF0aW9uTWF0cml4PWZ1bmN0aW9uKGEpe3ZhciBiLGM9YS5tLGQ9Y1swXSxlPWNbNF0sZj1jWzhdLGc9Y1sxXSxoPWNbNV0saT1jWzldLGo9Y1syXSxrPWNbNl0sbD1jWzEwXSxtPWQraCtsO3JldHVybiBtPjA/KGI9LjUvTWF0aC5zcXJ0KG0rMSksdGhpcy53PS4yNS9iLHRoaXMueD0oay1pKSpiLHRoaXMueT0oZi1qKSpiLHZvaWQodGhpcy56PShnLWUpKmIpKTpkPmgmJmQ+bD8oYj0yKk1hdGguc3FydCgxK2QtaC1sKSx0aGlzLnc9KGstaSkvYix0aGlzLng9LjI1KmIsdGhpcy55PShlK2cpL2Isdm9pZCh0aGlzLno9KGYraikvYikpOmg+bD8oYj0yKk1hdGguc3FydCgxK2gtZC1sKSx0aGlzLnc9KGYtaikvYix0aGlzLng9KGUrZykvYix0aGlzLnk9LjI1KmIsdm9pZCh0aGlzLno9KGkraykvYikpOihiPTIqTWF0aC5zcXJ0KDErbC1kLWgpLHRoaXMudz0oZy1lKS9iLHRoaXMueD0oZitqKS9iLHRoaXMueT0oaStrKS9iLHZvaWQodGhpcy56PS4yNSpiKSl9LGEuUm90YXRpb25BeGlzPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEsZT1NYXRoLnNpbihjLzIpO3JldHVybiBkLnc9TWF0aC5jb3MoYy8yKSxkLng9Yi54KmUsZC55PWIueSplLGQuej1iLnoqZSxkfSxhLkZyb21BcnJheT1mdW5jdGlvbihiLGMpe3JldHVybiBjfHwoYz0wKSxuZXcgYShiW2NdLGJbYysxXSxiW2MrMl0sYltjKzNdKX0sYS5Sb3RhdGlvbllhd1BpdGNoUm9sbD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IGE7cmV0dXJuIGEuUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZihiLGMsZCxlKSxlfSxhLlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9LjUqYyxmPS41KmIsZz0uNSphLGg9TWF0aC5zaW4oZSksaT1NYXRoLmNvcyhlKSxqPU1hdGguc2luKGYpLGs9TWF0aC5jb3MoZiksbD1NYXRoLnNpbihnKSxtPU1hdGguY29zKGcpO2QueD1tKmoqaStsKmsqaCxkLnk9bCprKmktbSpqKmgsZC56PW0qaypoLWwqaippLGQudz1tKmsqaStsKmoqaH0sYS5TbGVycD1mdW5jdGlvbihiLGMsZCl7dmFyIGUsZixnPWQsaD1iLngqYy54K2IueSpjLnkrYi56KmMueitiLncqYy53LGk9ITE7aWYoMD5oJiYoaT0hMCxoPS1oKSxoPi45OTk5OTkpZj0xLWcsZT1pPy1nOmc7ZWxzZXt2YXIgaj1NYXRoLmFjb3MoaCksaz0xL01hdGguc2luKGopO2Y9TWF0aC5zaW4oKDEtZykqaikqayxlPWk/LU1hdGguc2luKGcqaikqazpNYXRoLnNpbihnKmopKmt9cmV0dXJuIG5ldyBhKGYqYi54K2UqYy54LGYqYi55K2UqYy55LGYqYi56K2UqYy56LGYqYi53K2UqYy53KX0sYX0oKTthLlF1YXRlcm5pb249Zjt2YXIgZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLm09bmV3IEZsb2F0MzJBcnJheSgxNil9cmV0dXJuIGEucHJvdG90eXBlLmlzSWRlbnRpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMSE9dGhpcy5tWzBdfHwxIT10aGlzLm1bNV18fDEhPXRoaXMubVsxMF18fDEhPXRoaXMubVsxNV0/ITE6MCE9dGhpcy5tWzFdfHwwIT10aGlzLm1bMl18fDAhPXRoaXMubVszXXx8MCE9dGhpcy5tWzRdfHwwIT10aGlzLm1bNl18fDAhPXRoaXMubVs3XXx8MCE9dGhpcy5tWzhdfHwwIT10aGlzLm1bOV18fDAhPXRoaXMubVsxMV18fDAhPXRoaXMubVsxMl18fDAhPXRoaXMubVsxM118fDAhPXRoaXMubVsxNF0/ITE6ITB9LGEucHJvdG90eXBlLmRldGVybWluYW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5tWzEwXSp0aGlzLm1bMTVdLXRoaXMubVsxMV0qdGhpcy5tWzE0XSxiPXRoaXMubVs5XSp0aGlzLm1bMTVdLXRoaXMubVsxMV0qdGhpcy5tWzEzXSxjPXRoaXMubVs5XSp0aGlzLm1bMTRdLXRoaXMubVsxMF0qdGhpcy5tWzEzXSxkPXRoaXMubVs4XSp0aGlzLm1bMTVdLXRoaXMubVsxMV0qdGhpcy5tWzEyXSxlPXRoaXMubVs4XSp0aGlzLm1bMTRdLXRoaXMubVsxMF0qdGhpcy5tWzEyXSxmPXRoaXMubVs4XSp0aGlzLm1bMTNdLXRoaXMubVs5XSp0aGlzLm1bMTJdO3JldHVybiB0aGlzLm1bMF0qKHRoaXMubVs1XSphLXRoaXMubVs2XSpiK3RoaXMubVs3XSpjKS10aGlzLm1bMV0qKHRoaXMubVs0XSphLXRoaXMubVs2XSpkK3RoaXMubVs3XSplKSt0aGlzLm1bMl0qKHRoaXMubVs0XSpiLXRoaXMubVs1XSpkK3RoaXMubVs3XSpmKS10aGlzLm1bM10qKHRoaXMubVs0XSpjLXRoaXMubVs1XSplK3RoaXMubVs2XSpmKX0sYS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm19LGEucHJvdG90eXBlLmFzQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0FycmF5KCl9LGEucHJvdG90eXBlLmludmVydD1mdW5jdGlvbigpe3RoaXMuaW52ZXJ0VG9SZWYodGhpcyl9LGEucHJvdG90eXBlLmludmVydFRvUmVmPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubVswXSxjPXRoaXMubVsxXSxkPXRoaXMubVsyXSxlPXRoaXMubVszXSxmPXRoaXMubVs0XSxnPXRoaXMubVs1XSxoPXRoaXMubVs2XSxpPXRoaXMubVs3XSxqPXRoaXMubVs4XSxrPXRoaXMubVs5XSxsPXRoaXMubVsxMF0sbT10aGlzLm1bMTFdLG49dGhpcy5tWzEyXSxvPXRoaXMubVsxM10scD10aGlzLm1bMTRdLHE9dGhpcy5tWzE1XSxyPWwqcS1tKnAscz1rKnEtbSpvLHQ9aypwLWwqbyx1PWoqcS1tKm4sdj1qKnAtbCpuLHc9aipvLWsqbix4PWcqci1oKnMraSp0LHk9LShmKnItaCp1K2kqdiksej1mKnMtZyp1K2kqdyxBPS0oZip0LWcqditoKncpLEI9MS8oYip4K2MqeStkKnorZSpBKSxDPWgqcS1pKnAsRD1nKnEtaSpvLEU9ZypwLWgqbyxGPWYqcS1pKm4sRz1mKnAtaCpuLEg9ZipvLWcqbixJPWgqbS1pKmwsSj1nKm0taSprLEs9ZypsLWgqayxMPWYqbS1pKmosTT1mKmwtaCpqLE49ZiprLWcqajthLm1bMF09eCpCLGEubVs0XT15KkIsYS5tWzhdPXoqQixhLm1bMTJdPUEqQixhLm1bMV09LShjKnItZCpzK2UqdCkqQixhLm1bNV09KGIqci1kKnUrZSp2KSpCLGEubVs5XT0tKGIqcy1jKnUrZSp3KSpCLGEubVsxM109KGIqdC1jKnYrZCp3KSpCLGEubVsyXT0oYypDLWQqRCtlKkUpKkIsYS5tWzZdPS0oYipDLWQqRitlKkcpKkIsYS5tWzEwXT0oYipELWMqRitlKkgpKkIsYS5tWzE0XT0tKGIqRS1jKkcrZCpIKSpCLGEubVszXT0tKGMqSS1kKkorZSpLKSpCLGEubVs3XT0oYipJLWQqTCtlKk0pKkIsYS5tWzExXT0tKGIqSi1jKkwrZSpOKSpCLGEubVsxNV09KGIqSy1jKk0rZCpOKSpCfSxhLnByb3RvdHlwZS5zZXRUcmFuc2xhdGlvbj1mdW5jdGlvbihhKXt0aGlzLm1bMTJdPWEueCx0aGlzLm1bMTNdPWEueSx0aGlzLm1bMTRdPWEuen0sYS5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGE7cmV0dXJuIHRoaXMubXVsdGlwbHlUb1JlZihiLGMpLGN9LGEucHJvdG90eXBlLmNvcHlGcm9tPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wOzE2PmI7YisrKXRoaXMubVtiXT1hLm1bYl19LGEucHJvdG90eXBlLmNvcHlUb0FycmF5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGImJihiPTApO2Zvcih2YXIgYz0wOzE2PmM7YysrKWFbYitjXT10aGlzLm1bY119LGEucHJvdG90eXBlLm11bHRpcGx5VG9SZWY9ZnVuY3Rpb24oYSxiKXt0aGlzLm11bHRpcGx5VG9BcnJheShhLGIubSwwKX0sYS5wcm90b3R5cGUubXVsdGlwbHlUb0FycmF5PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLm1bMF0sZT10aGlzLm1bMV0sZj10aGlzLm1bMl0sZz10aGlzLm1bM10saD10aGlzLm1bNF0saT10aGlzLm1bNV0saj10aGlzLm1bNl0saz10aGlzLm1bN10sbD10aGlzLm1bOF0sbT10aGlzLm1bOV0sbj10aGlzLm1bMTBdLG89dGhpcy5tWzExXSxwPXRoaXMubVsxMl0scT10aGlzLm1bMTNdLHI9dGhpcy5tWzE0XSxzPXRoaXMubVsxNV0sdD1hLm1bMF0sdT1hLm1bMV0sdj1hLm1bMl0sdz1hLm1bM10seD1hLm1bNF0seT1hLm1bNV0sej1hLm1bNl0sQT1hLm1bN10sQj1hLm1bOF0sQz1hLm1bOV0sRD1hLm1bMTBdLEU9YS5tWzExXSxGPWEubVsxMl0sRz1hLm1bMTNdLEg9YS5tWzE0XSxJPWEubVsxNV07YltjXT1kKnQrZSp4K2YqQitnKkYsYltjKzFdPWQqdStlKnkrZipDK2cqRyxiW2MrMl09ZCp2K2UqeitmKkQrZypILGJbYyszXT1kKncrZSpBK2YqRStnKkksYltjKzRdPWgqdCtpKngraipCK2sqRixiW2MrNV09aCp1K2kqeStqKkMraypHLGJbYys2XT1oKnYraSp6K2oqRCtrKkgsYltjKzddPWgqdytpKkEraipFK2sqSSxiW2MrOF09bCp0K20qeCtuKkIrbypGLGJbYys5XT1sKnUrbSp5K24qQytvKkcsYltjKzEwXT1sKnYrbSp6K24qRCtvKkgsYltjKzExXT1sKncrbSpBK24qRStvKkksYltjKzEyXT1wKnQrcSp4K3IqQitzKkYsYltjKzEzXT1wKnUrcSp5K3IqQytzKkcsYltjKzE0XT1wKnYrcSp6K3IqRCtzKkgsYltjKzE1XT1wKncrcSpBK3IqRStzKkl9LGEucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmdGhpcy5tWzBdPT09YS5tWzBdJiZ0aGlzLm1bMV09PT1hLm1bMV0mJnRoaXMubVsyXT09PWEubVsyXSYmdGhpcy5tWzNdPT09YS5tWzNdJiZ0aGlzLm1bNF09PT1hLm1bNF0mJnRoaXMubVs1XT09PWEubVs1XSYmdGhpcy5tWzZdPT09YS5tWzZdJiZ0aGlzLm1bN109PT1hLm1bN10mJnRoaXMubVs4XT09PWEubVs4XSYmdGhpcy5tWzldPT09YS5tWzldJiZ0aGlzLm1bMTBdPT09YS5tWzEwXSYmdGhpcy5tWzExXT09PWEubVsxMV0mJnRoaXMubVsxMl09PT1hLm1bMTJdJiZ0aGlzLm1bMTNdPT09YS5tWzEzXSYmdGhpcy5tWzE0XT09PWEubVsxNF0mJnRoaXMubVsxNV09PT1hLm1bMTVdfSxhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBhLkZyb21WYWx1ZXModGhpcy5tWzBdLHRoaXMubVsxXSx0aGlzLm1bMl0sdGhpcy5tWzNdLHRoaXMubVs0XSx0aGlzLm1bNV0sdGhpcy5tWzZdLHRoaXMubVs3XSx0aGlzLm1bOF0sdGhpcy5tWzldLHRoaXMubVsxMF0sdGhpcy5tWzExXSx0aGlzLm1bMTJdLHRoaXMubVsxM10sdGhpcy5tWzE0XSx0aGlzLm1bMTVdKX0sYS5Gcm9tQXJyYXk9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYTtyZXR1cm4gY3x8KGM9MCksYS5Gcm9tQXJyYXlUb1JlZihiLGMsZCksZH0sYS5Gcm9tQXJyYXlUb1JlZj1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTA7MTY+ZDtkKyspYy5tW2RdPWFbZCtiXX0sYS5Gcm9tVmFsdWVzVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxKXtxLm1bMF09YSxxLm1bMV09YixxLm1bMl09YyxxLm1bM109ZCxxLm1bNF09ZSxxLm1bNV09ZixxLm1bNl09ZyxxLm1bN109aCxxLm1bOF09aSxxLm1bOV09aixxLm1bMTBdPWsscS5tWzExXT1sLHEubVsxMl09bSxxLm1bMTNdPW4scS5tWzE0XT1vLHEubVsxNV09cH0sYS5Gcm9tVmFsdWVzPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgsaSxqLGssbCxtLG4sbyxwLHEpe3ZhciByPW5ldyBhO3JldHVybiByLm1bMF09YixyLm1bMV09YyxyLm1bMl09ZCxyLm1bM109ZSxyLm1bNF09ZixyLm1bNV09ZyxyLm1bNl09aCxyLm1bN109aSxyLm1bOF09aixyLm1bOV09ayxyLm1bMTBdPWwsci5tWzExXT1tLHIubVsxMl09bixyLm1bMTNdPW8sci5tWzE0XT1wLHIubVsxNV09cSxyfSxhLklkZW50aXR5PWZ1bmN0aW9uKCl7cmV0dXJuIGEuRnJvbVZhbHVlcygxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKX0sYS5JZGVudGl0eVRvUmVmPWZ1bmN0aW9uKGIpe2EuRnJvbVZhbHVlc1RvUmVmKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEsYil9LGEuWmVybz1mdW5jdGlvbigpe3JldHVybiBhLkZyb21WYWx1ZXMoMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCl9LGEuUm90YXRpb25YPWZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhO3JldHVybiBhLlJvdGF0aW9uWFRvUmVmKGIsYyksY30sYS5Sb3RhdGlvblhUb1JlZj1mdW5jdGlvbihhLGIpe3ZhciBjPU1hdGguc2luKGEpLGQ9TWF0aC5jb3MoYSk7Yi5tWzBdPTEsYi5tWzE1XT0xLGIubVs1XT1kLGIubVsxMF09ZCxiLm1bOV09LWMsYi5tWzZdPWMsYi5tWzFdPTAsYi5tWzJdPTAsYi5tWzNdPTAsYi5tWzRdPTAsYi5tWzddPTAsYi5tWzhdPTAsYi5tWzExXT0wLGIubVsxMl09MCxiLm1bMTNdPTAsYi5tWzE0XT0wfSxhLlJvdGF0aW9uWT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYTtyZXR1cm4gYS5Sb3RhdGlvbllUb1JlZihiLGMpLGN9LGEuUm90YXRpb25ZVG9SZWY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NYXRoLnNpbihhKSxkPU1hdGguY29zKGEpO2IubVs1XT0xLGIubVsxNV09MSxiLm1bMF09ZCxiLm1bMl09LWMsYi5tWzhdPWMsYi5tWzEwXT1kLGIubVsxXT0wLGIubVszXT0wLGIubVs0XT0wLGIubVs2XT0wLGIubVs3XT0wLGIubVs5XT0wLGIubVsxMV09MCxiLm1bMTJdPTAsYi5tWzEzXT0wLGIubVsxNF09MH0sYS5Sb3RhdGlvblo9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGE7cmV0dXJuIGEuUm90YXRpb25aVG9SZWYoYixjKSxjfSxhLlJvdGF0aW9uWlRvUmVmPWZ1bmN0aW9uKGEsYil7dmFyIGM9TWF0aC5zaW4oYSksZD1NYXRoLmNvcyhhKTtiLm1bMTBdPTEsYi5tWzE1XT0xLGIubVswXT1kLGIubVsxXT1jLGIubVs0XT0tYyxiLm1bNV09ZCxiLm1bMl09MCxiLm1bM109MCxiLm1bNl09MCxiLm1bN109MCxiLm1bOF09MCxiLm1bOV09MCxiLm1bMTFdPTAsYi5tWzEyXT0wLGIubVsxM109MCxiLm1bMTRdPTB9LGEuUm90YXRpb25BeGlzPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9TWF0aC5zaW4oLWMpLGU9TWF0aC5jb3MoLWMpLGY9MS1lO2Iubm9ybWFsaXplKCk7dmFyIGc9YS5aZXJvKCk7cmV0dXJuIGcubVswXT1iLngqYi54KmYrZSxnLm1bMV09Yi54KmIueSpmLWIueipkLGcubVsyXT1iLngqYi56KmYrYi55KmQsZy5tWzNdPTAsZy5tWzRdPWIueSpiLngqZitiLnoqZCxnLm1bNV09Yi55KmIueSpmK2UsZy5tWzZdPWIueSpiLnoqZi1iLngqZCxnLm1bN109MCxnLm1bOF09Yi56KmIueCpmLWIueSpkLGcubVs5XT1iLnoqYi55KmYrYi54KmQsZy5tWzEwXT1iLnoqYi56KmYrZSxnLm1bMTFdPTAsZy5tWzE1XT0xLGd9LGEuUm90YXRpb25ZYXdQaXRjaFJvbGw9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPW5ldyBhO3JldHVybiBhLlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYoYixjLGQsZSksZX0sYS5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmPWZ1bmN0aW9uKGEsYixjLGQpe2YuUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZihhLGIsYyx0aGlzLl90ZW1wUXVhdGVybmlvbiksdGhpcy5fdGVtcFF1YXRlcm5pb24udG9Sb3RhdGlvbk1hdHJpeChkKX0sYS5TY2FsaW5nPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLlplcm8oKTtyZXR1cm4gYS5TY2FsaW5nVG9SZWYoYixjLGQsZSksZX0sYS5TY2FsaW5nVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCl7ZC5tWzBdPWEsZC5tWzFdPTAsZC5tWzJdPTAsZC5tWzNdPTAsZC5tWzRdPTAsZC5tWzVdPWIsZC5tWzZdPTAsZC5tWzddPTAsZC5tWzhdPTAsZC5tWzldPTAsZC5tWzEwXT1jLGQubVsxMV09MCxkLm1bMTJdPTAsZC5tWzEzXT0wLGQubVsxNF09MCxkLm1bMTVdPTF9LGEuVHJhbnNsYXRpb249ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuSWRlbnRpdHkoKTtyZXR1cm4gYS5UcmFuc2xhdGlvblRvUmVmKGIsYyxkLGUpLGV9LGEuVHJhbnNsYXRpb25Ub1JlZj1mdW5jdGlvbihiLGMsZCxlKXthLkZyb21WYWx1ZXNUb1JlZigxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxiLGMsZCwxLGUpfSxhLkxvb2tBdExIPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLlplcm8oKTtyZXR1cm4gYS5Mb29rQXRMSFRvUmVmKGIsYyxkLGUpLGV9LGEuTG9va0F0TEhUb1JlZj1mdW5jdGlvbihiLGMsZCxmKXtjLnN1YnRyYWN0VG9SZWYoYix0aGlzLl96QXhpcyksdGhpcy5fekF4aXMubm9ybWFsaXplKCksZS5Dcm9zc1RvUmVmKGQsdGhpcy5fekF4aXMsdGhpcy5feEF4aXMpLHRoaXMuX3hBeGlzLm5vcm1hbGl6ZSgpLGUuQ3Jvc3NUb1JlZih0aGlzLl96QXhpcyx0aGlzLl94QXhpcyx0aGlzLl95QXhpcyksdGhpcy5feUF4aXMubm9ybWFsaXplKCk7dmFyIGc9LWUuRG90KHRoaXMuX3hBeGlzLGIpLGg9LWUuRG90KHRoaXMuX3lBeGlzLGIpLGk9LWUuRG90KHRoaXMuX3pBeGlzLGIpO3JldHVybiBhLkZyb21WYWx1ZXNUb1JlZih0aGlzLl94QXhpcy54LHRoaXMuX3lBeGlzLngsdGhpcy5fekF4aXMueCwwLHRoaXMuX3hBeGlzLnksdGhpcy5feUF4aXMueSx0aGlzLl96QXhpcy55LDAsdGhpcy5feEF4aXMueix0aGlzLl95QXhpcy56LHRoaXMuX3pBeGlzLnosMCxnLGgsaSwxLGYpfSxhLk9ydGhvTEg9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9Mi9iLGc9Mi9jLGg9MS8oZS1kKSxpPWQvKGQtZSk7cmV0dXJuIGEuRnJvbVZhbHVlcyhmLDAsMCwwLDAsZywwLDAsMCwwLGgsMCwwLDAsaSwxKX0sYS5PcnRob09mZkNlbnRlckxIPWZ1bmN0aW9uKGIsYyxkLGUsZixnKXt2YXIgaD1hLlplcm8oKTtyZXR1cm4gYS5PcnRob09mZkNlbnRlckxIVG9SZWYoYixjLGQsZSxmLGcsaCksaH0sYS5PcnRob09mZkNlbnRlckxIVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7Zy5tWzBdPTIvKGItYSksZy5tWzFdPWcubVsyXT1nLm1bM109MCxnLm1bNV09Mi8oZC1jKSxnLm1bNF09Zy5tWzZdPWcubVs3XT0wLGcubVsxMF09LTEvKGUtZiksZy5tWzhdPWcubVs5XT1nLm1bMTFdPTAsZy5tWzEyXT0oYStiKS8oYS1iKSxnLm1bMTNdPShkK2MpLyhjLWQpLGcubVsxNF09ZS8oZS1mKSxnLm1bMTVdPTF9LGEuUGVyc3BlY3RpdmVMSD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1hLlplcm8oKTtyZXR1cm4gZi5tWzBdPTIqZC9iLGYubVsxXT1mLm1bMl09Zi5tWzNdPTAsZi5tWzVdPTIqZC9jLGYubVs0XT1mLm1bNl09Zi5tWzddPTAsZi5tWzEwXT0tZS8oZC1lKSxmLm1bOF09Zi5tWzldPTAsZi5tWzExXT0xLGYubVsxMl09Zi5tWzEzXT1mLm1bMTVdPTAsZi5tWzE0XT1kKmUvKGQtZSksZn0sYS5QZXJzcGVjdGl2ZUZvdkxIPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWEuWmVybygpO3JldHVybiBhLlBlcnNwZWN0aXZlRm92TEhUb1JlZihiLGMsZCxlLGYpLGZ9LGEuUGVyc3BlY3RpdmVGb3ZMSFRvUmVmPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9MS9NYXRoLnRhbiguNSphKTtlLm1bMF09Zi9iLGUubVsxXT1lLm1bMl09ZS5tWzNdPTAsZS5tWzVdPWYsZS5tWzRdPWUubVs2XT1lLm1bN109MCxlLm1bOF09ZS5tWzldPTAsZS5tWzEwXT0tZC8oYy1kKSxlLm1bMTFdPTEsZS5tWzEyXT1lLm1bMTNdPWUubVsxNV09MCxlLm1bMTRdPWMqZC8oYy1kKX0sYS5HZXRGaW5hbE1hdHJpeD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dmFyIGg9Yi53aWR0aCxpPWIuaGVpZ2h0LGo9Yi54LGs9Yi55LGw9YS5Gcm9tVmFsdWVzKGgvMiwwLDAsMCwwLC1pLzIsMCwwLDAsMCxnLWYsMCxqK2gvMixpLzIrayxmLDEpO3JldHVybiBjLm11bHRpcGx5KGQpLm11bHRpcGx5KGUpLm11bHRpcGx5KGwpfSxhLlRyYW5zcG9zZT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYTtyZXR1cm4gYy5tWzBdPWIubVswXSxjLm1bMV09Yi5tWzRdLGMubVsyXT1iLm1bOF0sYy5tWzNdPWIubVsxMl0sYy5tWzRdPWIubVsxXSxjLm1bNV09Yi5tWzVdLGMubVs2XT1iLm1bOV0sYy5tWzddPWIubVsxM10sYy5tWzhdPWIubVsyXSxjLm1bOV09Yi5tWzZdLGMubVsxMF09Yi5tWzEwXSxjLm1bMTFdPWIubVsxNF0sYy5tWzEyXT1iLm1bM10sYy5tWzEzXT1iLm1bN10sYy5tWzE0XT1iLm1bMTFdLGMubVsxNV09Yi5tWzE1XSxjfSxhLlJlZmxlY3Rpb249ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGE7cmV0dXJuIGEuUmVmbGVjdGlvblRvUmVmKGIsYyksY30sYS5SZWZsZWN0aW9uVG9SZWY9ZnVuY3Rpb24oYSxiKXthLm5vcm1hbGl6ZSgpO3ZhciBjPWEubm9ybWFsLngsZD1hLm5vcm1hbC55LGU9YS5ub3JtYWwueixmPS0yKmMsZz0tMipkLGg9LTIqZTtiLm1bMF09ZipjKzEsYi5tWzFdPWcqYyxiLm1bMl09aCpjLGIubVszXT0wLGIubVs0XT1mKmQsYi5tWzVdPWcqZCsxLGIubVs2XT1oKmQsYi5tWzddPTAsYi5tWzhdPWYqZSxiLm1bOV09ZyplLGIubVsxMF09aCplKzEsYi5tWzExXT0wLGIubVsxMl09ZiphLmQsYi5tWzEzXT1nKmEuZCxiLm1bMTRdPWgqYS5kLGIubVsxNV09MX0sYS5fdGVtcFF1YXRlcm5pb249bmV3IGYsYS5feEF4aXM9ZS5aZXJvKCksYS5feUF4aXM9ZS5aZXJvKCksYS5fekF4aXM9ZS5aZXJvKCksYX0oKTthLk1hdHJpeD1nO3ZhciBoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyxkKXt0aGlzLm5vcm1hbD1uZXcgZShhLGIsYyksdGhpcy5kPWR9cmV0dXJuIGIucHJvdG90eXBlLmFzQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5ub3JtYWwueCx0aGlzLm5vcm1hbC55LHRoaXMubm9ybWFsLnosdGhpcy5kXX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIodGhpcy5ub3JtYWwueCx0aGlzLm5vcm1hbC55LHRoaXMubm9ybWFsLnosdGhpcy5kKX0sYi5wcm90b3R5cGUubm9ybWFsaXplPWZ1bmN0aW9uKCl7dmFyIGE9TWF0aC5zcXJ0KHRoaXMubm9ybWFsLngqdGhpcy5ub3JtYWwueCt0aGlzLm5vcm1hbC55KnRoaXMubm9ybWFsLnkrdGhpcy5ub3JtYWwueip0aGlzLm5vcm1hbC56KSxiPTA7MCE9YSYmKGI9MS9hKSx0aGlzLm5vcm1hbC54Kj1iLHRoaXMubm9ybWFsLnkqPWIsdGhpcy5ub3JtYWwueio9Yix0aGlzLmQqPWJ9LGIucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbihiKXt2YXIgYz1hLk1hdHJpeC5UcmFuc3Bvc2UoYiksZD10aGlzLm5vcm1hbC54LGU9dGhpcy5ub3JtYWwueSxmPXRoaXMubm9ybWFsLnosZz10aGlzLmQsaD1kKmMubVswXStlKmMubVsxXStmKmMubVsyXStnKmMubVszXSxpPWQqYy5tWzRdK2UqYy5tWzVdK2YqYy5tWzZdK2cqYy5tWzddLGo9ZCpjLm1bOF0rZSpjLm1bOV0rZipjLm1bMTBdK2cqYy5tWzExXSxrPWQqYy5tWzEyXStlKmMubVsxM10rZipjLm1bMTRdK2cqYy5tWzE1XTtyZXR1cm4gbmV3IGEuUGxhbmUoaCxpLGosayl9LGIucHJvdG90eXBlLmRvdENvb3JkaW5hdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubm9ybWFsLngqYS54K3RoaXMubm9ybWFsLnkqYS55K3RoaXMubm9ybWFsLnoqYS56K3RoaXMuZH0sYi5wcm90b3R5cGUuY29weUZyb21Qb2ludHM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9Yi54LWEueCxmPWIueS1hLnksZz1iLnotYS56LGg9Yy54LWEueCxpPWMueS1hLnksaj1jLnotYS56LGs9ZipqLWcqaSxsPWcqaC1lKmosbT1lKmktZipoLG49TWF0aC5zcXJ0KGsqaytsKmwrbSptKTtkPTAhPW4/MS9uOjAsdGhpcy5ub3JtYWwueD1rKmQsdGhpcy5ub3JtYWwueT1sKmQsdGhpcy5ub3JtYWwuej1tKmQsdGhpcy5kPS0odGhpcy5ub3JtYWwueCphLngrdGhpcy5ub3JtYWwueSphLnkrdGhpcy5ub3JtYWwueiphLnopfSxiLnByb3RvdHlwZS5pc0Zyb250RmFjaW5nVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz1lLkRvdCh0aGlzLm5vcm1hbCxhKTtyZXR1cm4gYj49Y30sYi5wcm90b3R5cGUuc2lnbmVkRGlzdGFuY2VUbz1mdW5jdGlvbihhKXtyZXR1cm4gZS5Eb3QoYSx0aGlzLm5vcm1hbCkrdGhpcy5kfSxiLkZyb21BcnJheT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEuUGxhbmUoYlswXSxiWzFdLGJbMl0sYlszXSl9LGIuRnJvbVBvaW50cz1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IGEuUGxhbmUoMCwwLDAsMCk7cmV0dXJuIGUuY29weUZyb21Qb2ludHMoYixjLGQpLGV9LGIuRnJvbVBvc2l0aW9uQW5kTm9ybWFsPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuUGxhbmUoMCwwLDAsMCk7cmV0dXJuIGMubm9ybWFsaXplKCksZC5ub3JtYWw9YyxkLmQ9LShjLngqYi54K2MueSpiLnkrYy56KmIueiksZH0sYi5TaWduZWREaXN0YW5jZVRvUGxhbmVGcm9tUG9zaXRpb25BbmROb3JtYWw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPS0oYi54KmEueCtiLnkqYS55K2IueiphLnopO3JldHVybiBlLkRvdChjLGIpK2R9LGJ9KCk7YS5QbGFuZT1oO3ZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkKXt0aGlzLng9YSx0aGlzLnk9Yix0aGlzLndpZHRoPWMsdGhpcy5oZWlnaHQ9ZH1yZXR1cm4gYS5wcm90b3R5cGUudG9HbG9iYWw9ZnVuY3Rpb24oYil7dmFyIGM9Yi5nZXRSZW5kZXJXaWR0aCgpLGQ9Yi5nZXRSZW5kZXJIZWlnaHQoKTtyZXR1cm4gbmV3IGEodGhpcy54KmMsdGhpcy55KmQsdGhpcy53aWR0aCpjLHRoaXMuaGVpZ2h0KmQpfSxhfSgpO2EuVmlld3BvcnQ9aTt2YXIgaj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt9cmV0dXJuIGEuR2V0UGxhbmVzPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1bXSxkPTA7Nj5kO2QrKyljLnB1c2gobmV3IGgoMCwwLDAsMCkpO3JldHVybiBhLkdldFBsYW5lc1RvUmVmKGIsYyksY30sYS5HZXRQbGFuZXNUb1JlZj1mdW5jdGlvbihhLGIpe2JbMF0ubm9ybWFsLng9YS5tWzNdK2EubVsyXSxiWzBdLm5vcm1hbC55PWEubVs3XSthLm1bNl0sYlswXS5ub3JtYWwuej1hLm1bMTBdK2EubVsxMF0sYlswXS5kPWEubVsxNV0rYS5tWzE0XSxiWzBdLm5vcm1hbGl6ZSgpLGJbMV0ubm9ybWFsLng9YS5tWzNdLWEubVsyXSxiWzFdLm5vcm1hbC55PWEubVs3XS1hLm1bNl0sYlsxXS5ub3JtYWwuej1hLm1bMTFdLWEubVsxMF0sYlsxXS5kPWEubVsxNV0tYS5tWzE0XSxiWzFdLm5vcm1hbGl6ZSgpLGJbMl0ubm9ybWFsLng9YS5tWzNdK2EubVswXSxiWzJdLm5vcm1hbC55PWEubVs3XSthLm1bNF0sYlsyXS5ub3JtYWwuej1hLm1bMTFdK2EubVs4XSxiWzJdLmQ9YS5tWzE1XSthLm1bMTJdLGJbMl0ubm9ybWFsaXplKCksYlszXS5ub3JtYWwueD1hLm1bM10tYS5tWzBdLGJbM10ubm9ybWFsLnk9YS5tWzddLWEubVs0XSxiWzNdLm5vcm1hbC56PWEubVsxMV0tYS5tWzhdLGJbM10uZD1hLm1bMTVdLWEubVsxMl0sYlszXS5ub3JtYWxpemUoKSxiWzRdLm5vcm1hbC54PWEubVszXS1hLm1bMV0sYls0XS5ub3JtYWwueT1hLm1bN10tYS5tWzVdLGJbNF0ubm9ybWFsLno9YS5tWzExXS1hLm1bOV0sYls0XS5kPWEubVsxNV0tYS5tWzEzXSxiWzRdLm5vcm1hbGl6ZSgpLGJbNV0ubm9ybWFsLng9YS5tWzNdK2EubVsxXSxiWzVdLm5vcm1hbC55PWEubVs3XSthLm1bNV0sYls1XS5ub3JtYWwuej1hLm1bMTFdK2EubVs5XSxiWzVdLmQ9YS5tWzE1XSthLm1bMTNdLGJbNV0ubm9ybWFsaXplKCl9LGF9KCk7YS5GcnVzdHVtPWo7dmFyIGs9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYil7dGhpcy5vcmlnaW49YSx0aGlzLmRpcmVjdGlvbj1ifXJldHVybiBiLnByb3RvdHlwZS5pbnRlcnNlY3RzQm94TWluTWF4PWZ1bmN0aW9uKGEsYil7dmFyIGM9MCxkPU51bWJlci5NQVhfVkFMVUU7aWYoTWF0aC5hYnModGhpcy5kaXJlY3Rpb24ueCk8MWUtNyl7aWYodGhpcy5vcmlnaW4ueDxhLnh8fHRoaXMub3JpZ2luLng+Yi54KXJldHVybiExfWVsc2V7dmFyIGU9MS90aGlzLmRpcmVjdGlvbi54LGY9KGEueC10aGlzLm9yaWdpbi54KSplLGc9KGIueC10aGlzLm9yaWdpbi54KSplO2lmKGY+Zyl7dmFyIGg9ZjtmPWcsZz1ofWlmKGM9TWF0aC5tYXgoZixjKSxkPU1hdGgubWluKGcsZCksYz5kKXJldHVybiExfWlmKE1hdGguYWJzKHRoaXMuZGlyZWN0aW9uLnkpPDFlLTcpe2lmKHRoaXMub3JpZ2luLnk8YS55fHx0aGlzLm9yaWdpbi55PmIueSlyZXR1cm4hMX1lbHNlIGlmKGU9MS90aGlzLmRpcmVjdGlvbi55LGY9KGEueS10aGlzLm9yaWdpbi55KSplLGc9KGIueS10aGlzLm9yaWdpbi55KSplLGY+ZyYmKGg9ZixmPWcsZz1oKSxjPU1hdGgubWF4KGYsYyksZD1NYXRoLm1pbihnLGQpLGM+ZClyZXR1cm4hMTtpZihNYXRoLmFicyh0aGlzLmRpcmVjdGlvbi56KTwxZS03KXtpZih0aGlzLm9yaWdpbi56PGEuenx8dGhpcy5vcmlnaW4uej5iLnopcmV0dXJuITF9ZWxzZSBpZihlPTEvdGhpcy5kaXJlY3Rpb24ueixmPShhLnotdGhpcy5vcmlnaW4ueikqZSxnPShiLnotdGhpcy5vcmlnaW4ueikqZSxmPmcmJihoPWYsZj1nLGc9aCksYz1NYXRoLm1heChmLGMpLGQ9TWF0aC5taW4oZyxkKSxjPmQpcmV0dXJuITE7cmV0dXJuITB9LGIucHJvdG90eXBlLmludGVyc2VjdHNCb3g9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveE1pbk1heChhLm1pbmltdW0sYS5tYXhpbXVtKX0sYi5wcm90b3R5cGUuaW50ZXJzZWN0c1NwaGVyZT1mdW5jdGlvbihhKXt2YXIgYj1hLmNlbnRlci54LXRoaXMub3JpZ2luLngsYz1hLmNlbnRlci55LXRoaXMub3JpZ2luLnksZD1hLmNlbnRlci56LXRoaXMub3JpZ2luLnosZT1iKmIrYypjK2QqZCxmPWEucmFkaXVzKmEucmFkaXVzO2lmKGY+PWUpcmV0dXJuITA7dmFyIGc9Yip0aGlzLmRpcmVjdGlvbi54K2MqdGhpcy5kaXJlY3Rpb24ueStkKnRoaXMuZGlyZWN0aW9uLno7aWYoMD5nKXJldHVybiExO3ZhciBoPWUtZypnO3JldHVybiBmPj1ofSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGU9ZnVuY3Rpb24oYixjLGQpe3RoaXMuX2VkZ2UxfHwodGhpcy5fZWRnZTE9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9lZGdlMj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3B2ZWM9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90dmVjPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fcXZlYz1hLlZlY3RvcjMuWmVybygpKSxjLnN1YnRyYWN0VG9SZWYoYix0aGlzLl9lZGdlMSksZC5zdWJ0cmFjdFRvUmVmKGIsdGhpcy5fZWRnZTIpLGEuVmVjdG9yMy5Dcm9zc1RvUmVmKHRoaXMuZGlyZWN0aW9uLHRoaXMuX2VkZ2UyLHRoaXMuX3B2ZWMpO3ZhciBmPWUuRG90KHRoaXMuX2VkZ2UxLHRoaXMuX3B2ZWMpO2lmKDA9PT1mKXJldHVybiBudWxsO3ZhciBnPTEvZjt0aGlzLm9yaWdpbi5zdWJ0cmFjdFRvUmVmKGIsdGhpcy5fdHZlYyk7dmFyIGg9ZS5Eb3QodGhpcy5fdHZlYyx0aGlzLl9wdmVjKSpnO2lmKDA+aHx8aD4xKXJldHVybiBudWxsO2UuQ3Jvc3NUb1JlZih0aGlzLl90dmVjLHRoaXMuX2VkZ2UxLHRoaXMuX3F2ZWMpO3ZhciBpPWUuRG90KHRoaXMuZGlyZWN0aW9uLHRoaXMuX3F2ZWMpKmc7cmV0dXJuIDA+aXx8aCtpPjE/bnVsbDpuZXcgYS5JbnRlcnNlY3Rpb25JbmZvKGgsaSxlLkRvdCh0aGlzLl9lZGdlMix0aGlzLl9xdmVjKSpnKX0sYi5DcmVhdGVOZXc9ZnVuY3Rpb24oYyxkLGUsZixnLGgsaSl7dmFyIGo9YS5WZWN0b3IzLlVucHJvamVjdChuZXcgYS5WZWN0b3IzKGMsZCwwKSxlLGYsZyxoLGkpLGs9YS5WZWN0b3IzLlVucHJvamVjdChuZXcgYS5WZWN0b3IzKGMsZCwxKSxlLGYsZyxoLGkpLGw9ay5zdWJ0cmFjdChqKTtyZXR1cm4gbC5ub3JtYWxpemUoKSxuZXcgYihqLGwpfSxiLlRyYW5zZm9ybT1mdW5jdGlvbihjLGQpe3ZhciBlPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhjLm9yaWdpbixkKSxmPWEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwoYy5kaXJlY3Rpb24sZCk7cmV0dXJuIG5ldyBiKGUsZil9LGJ9KCk7YS5SYXk9ayxmdW5jdGlvbihhKXthW2EuTE9DQUw9MF09XCJMT0NBTFwiLGFbYS5XT1JMRD0xXT1cIldPUkxEXCJ9KGEuU3BhY2V8fChhLlNwYWNlPXt9KSk7dmFyIGw9KGEuU3BhY2UsZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7fXJldHVybiBiLlg9bmV3IGEuVmVjdG9yMygxLDAsMCksYi5ZPW5ldyBhLlZlY3RvcjMoMCwxLDApLGIuWj1uZXcgYS5WZWN0b3IzKDAsMCwxKSxifSgpKTthLkF4aXM9bH0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGIsYz02MCxkPVtdLGU9NjAsZj0wLGc9ZnVuY3Rpb24oYixjKXtyZXR1cm4gYj9iIGluc3RhbmNlb2YgYS5NZXNoP251bGw6YiBpbnN0YW5jZW9mIGEuU3ViTWVzaD9iLmNsb25lKGMpOmIuY2xvbmU/Yi5jbG9uZSgpOm51bGw6bnVsbH0saD1mdW5jdGlvbigpe2Z1bmN0aW9uIGgoKXt9cmV0dXJuIGguR2V0RmlsZW5hbWU9ZnVuY3Rpb24oYSl7dmFyIGI9YS5sYXN0SW5kZXhPZihcIi9cIik7cmV0dXJuIDA+Yj9hOmEuc3Vic3RyaW5nKGIrMSl9LGguR2V0RE9NVGV4dENvbnRlbnQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwiXCIsYz1hLmZpcnN0Q2hpbGQ7YzspMz09Yy5ub2RlVHlwZSYmKGIrPWMudGV4dENvbnRlbnQpLGM9Yy5uZXh0U2libGluZztyZXR1cm4gYn0saC5Ub0RlZ3JlZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIDE4MCphL01hdGguUEl9LGguVG9SYWRpYW5zPWZ1bmN0aW9uKGEpe3JldHVybiBhKk1hdGguUEkvMTgwfSxoLkV4dHJhY3RNaW5BbmRNYXhJbmRleGVkPWZ1bmN0aW9uKGIsYyxkLGUpe2Zvcih2YXIgZj1uZXcgYS5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSxnPW5ldyBhLlZlY3RvcjMoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUpLGg9ZDtkK2U+aDtoKyspe3ZhciBpPW5ldyBhLlZlY3RvcjMoYlszKmNbaF1dLGJbMypjW2hdKzFdLGJbMypjW2hdKzJdKTtmPWEuVmVjdG9yMy5NaW5pbWl6ZShpLGYpLGc9YS5WZWN0b3IzLk1heGltaXplKGksZyl9cmV0dXJue21pbmltdW06ZixtYXhpbXVtOmd9fSxoLkV4dHJhY3RNaW5BbmRNYXg9ZnVuY3Rpb24oYixjLGQpe2Zvcih2YXIgZT1uZXcgYS5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSxmPW5ldyBhLlZlY3RvcjMoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUpLGc9YztjK2Q+ZztnKyspe3ZhciBoPW5ldyBhLlZlY3RvcjMoYlszKmddLGJbMypnKzFdLGJbMypnKzJdKTtlPWEuVmVjdG9yMy5NaW5pbWl6ZShoLGUpLGY9YS5WZWN0b3IzLk1heGltaXplKGgsZil9cmV0dXJue21pbmltdW06ZSxtYXhpbXVtOmZ9fSxoLk1ha2VBcnJheT1mdW5jdGlvbihhLGIpe3JldHVybiBiPT09ITB8fHZvaWQgMCE9PWEmJm51bGwhPWE/QXJyYXkuaXNBcnJheShhKT9hOlthXTp2b2lkIDB9LGguR2V0UG9pbnRlclByZWZpeD1mdW5jdGlvbigpe3ZhciBhPVwicG9pbnRlclwiO3JldHVybiBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWR8fChhPVwibW91c2VcIiksYX0saC5RdWV1ZU5ld0ZyYW1lPWZ1bmN0aW9uKGEpe3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhKTp3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpOndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShhKTp3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lP3dpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk6d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk6d2luZG93LnNldFRpbWVvdXQoYSwxNil9LGguUmVxdWVzdEZ1bGxzY3JlZW49ZnVuY3Rpb24oYSl7YS5yZXF1ZXN0RnVsbHNjcmVlbj9hLnJlcXVlc3RGdWxsc2NyZWVuKCk6YS5tc1JlcXVlc3RGdWxsc2NyZWVuP2EubXNSZXF1ZXN0RnVsbHNjcmVlbigpOmEud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4/YS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpOmEubW96UmVxdWVzdEZ1bGxTY3JlZW4mJmEubW96UmVxdWVzdEZ1bGxTY3JlZW4oKX0saC5FeGl0RnVsbHNjcmVlbj1mdW5jdGlvbigpe2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuP2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk6ZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbj9kb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk6ZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbj9kb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKCk6ZG9jdW1lbnQubXNDYW5jZWxGdWxsU2NyZWVuJiZkb2N1bWVudC5tc0NhbmNlbEZ1bGxTY3JlZW4oKX0saC5DbGVhblVybD1mdW5jdGlvbihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoLyMvZ20sXCIlMjNcIil9LGguTG9hZEltYWdlPWZ1bmN0aW9uKGIsYyxkLGUpe2I9aC5DbGVhblVybChiKTt2YXIgZj1uZXcgSW1hZ2U7Zi5jcm9zc09yaWdpbj1cImFub255bW91c1wiLGYub25sb2FkPWZ1bmN0aW9uKCl7YyhmKX0sZi5vbmVycm9yPWZ1bmN0aW9uKGEpe2QoZixhKX07dmFyIGc9ZnVuY3Rpb24oKXtmLnNyYz1ifSxpPWZ1bmN0aW9uKCl7ZS5sb2FkSW1hZ2VGcm9tREIoYixmKX07aWYoZSYmZS5lbmFibGVUZXh0dXJlc09mZmxpbmUmJmEuRGF0YWJhc2UuaXNVQVN1cHBvcnRpbmdCbG9iU3RvcmFnZSllLm9wZW5Bc3luYyhpLGcpO2Vsc2UgaWYoLTE9PT1iLmluZGV4T2YoXCJmaWxlOlwiKSlnKCk7ZWxzZSB0cnl7dmFyIGosaz1iLnN1YnN0cmluZyg1KTt0cnl7aj1VUkwuY3JlYXRlT2JqZWN0VVJMKGEuRmlsZXNJbnB1dC5GaWxlc1RleHR1cmVzW2tdLHtvbmVUaW1lT25seTohMH0pfWNhdGNoKGwpe2o9VVJMLmNyZWF0ZU9iamVjdFVSTChhLkZpbGVzSW5wdXQuRmlsZXNUZXh0dXJlc1trXSl9Zi5zcmM9an1jYXRjaChtKXtoLkxvZyhcIkVycm9yIHdoaWxlIHRyeWluZyB0byBsb2FkIHRleHR1cmU6IFwiK2spLGYuc3JjPW51bGx9cmV0dXJuIGZ9LGguTG9hZEZpbGU9ZnVuY3Rpb24oYixjLGQsZSxmKXtiPWguQ2xlYW5VcmwoYik7XG52YXIgZz1mdW5jdGlvbigpe3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdCxnPWguQmFzZVVybCtiO2Uub3BlbihcIkdFVFwiLGcsITApLGYmJihlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIpLGUub25wcm9ncmVzcz1kLGUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoND09ZS5yZWFkeVN0YXRlKXtpZigyMDAhPWUuc3RhdHVzJiYhYS5Ub29scy5WYWxpZGF0ZVhIUkRhdGEoZSxmPzY6MSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3Igc3RhdHVzOiBcIitlLnN0YXR1cytcIiAtIFVuYWJsZSB0byBsb2FkIFwiK2cpO2MoZj9lLnJlc3BvbnNlOmUucmVzcG9uc2VUZXh0KX19LGUuc2VuZChudWxsKX0saT1mdW5jdGlvbigpe2UubG9hZEZpbGVGcm9tREIoYixjLGQsZyxmKX07aWYoLTEhPT1iLmluZGV4T2YoXCJmaWxlOlwiKSl7dmFyIGo9Yi5zdWJzdHJpbmcoNSk7YS5Ub29scy5SZWFkRmlsZShhLkZpbGVzSW5wdXQuRmlsZXNUb0xvYWRbal0sYyxkLCEwKX1lbHNlIGUmJmUuZW5hYmxlU2NlbmVPZmZsaW5lP2Uub3BlbkFzeW5jKGksZyk6ZygpfSxoLlJlYWRGaWxlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBGaWxlUmVhZGVyO2Uub25sb2FkPWZ1bmN0aW9uKGEpe2IoYS50YXJnZXQucmVzdWx0KX0sZS5vbnByb2dyZXNzPWMsZD9lLnJlYWRBc0FycmF5QnVmZmVyKGEpOmUucmVhZEFzVGV4dChhKX0saC5DaGVja0V4dGVuZHM9ZnVuY3Rpb24oYSxiLGMpe2EueDxiLngmJihiLng9YS54KSxhLnk8Yi55JiYoYi55PWEueSksYS56PGIueiYmKGIuej1hLnopLGEueD5jLngmJihjLng9YS54KSxhLnk+Yy55JiYoYy55PWEueSksYS56PmMueiYmKGMuej1hLnopfSxoLldpdGhpbkVwc2lsb249ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLWI7cmV0dXJuIGM+PS0xLjQwMTI5OGUtNDUmJjEuNDAxMjk4ZS00NT49Y30saC5EZWVwQ29weT1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGUgaW4gYSlpZigoXCJfXCIhPT1lWzBdfHxkJiYtMSE9PWQuaW5kZXhPZihlKSkmJighY3x8LTE9PT1jLmluZGV4T2YoZSkpKXt2YXIgZj1hW2VdLGg9dHlwZW9mIGY7aWYoXCJmdW5jdGlvblwiIT1oKWlmKFwib2JqZWN0XCI9PWgpaWYoZiBpbnN0YW5jZW9mIEFycmF5KXtpZihiW2VdPVtdLGYubGVuZ3RoPjApaWYoXCJvYmplY3RcIj09dHlwZW9mIGZbMF0pZm9yKHZhciBpPTA7aTxmLmxlbmd0aDtpKyspe3ZhciBqPWcoZltpXSxiKTstMT09PWJbZV0uaW5kZXhPZihqKSYmYltlXS5wdXNoKGopfWVsc2UgYltlXT1mLnNsaWNlKDApfWVsc2UgYltlXT1nKGYsYik7ZWxzZSBiW2VdPWZ9fSxoLklzRW1wdHk9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9LGguUmVnaXN0ZXJUb3BSb290RXZlbnRzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKGMubmFtZSxjLmhhbmRsZXIsITEpO3RyeXt3aW5kb3cucGFyZW50JiZ3aW5kb3cucGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoYy5uYW1lLGMuaGFuZGxlciwhMSl9Y2F0Y2goZCl7fX19LGguVW5yZWdpc3RlclRvcFJvb3RFdmVudHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPWFbYl07d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoYy5uYW1lLGMuaGFuZGxlcik7dHJ5e3dpbmRvdy5wYXJlbnQmJndpbmRvdy5wYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLm5hbWUsYy5oYW5kbGVyKX1jYXRjaChkKXt9fX0saC5HZXRGcHM9ZnVuY3Rpb24oKXtyZXR1cm4gZX0saC5HZXREZWx0YVRpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gZn0saC5fTWVhc3VyZUZwcz1mdW5jdGlvbigpe2QucHVzaCgobmV3IERhdGUpLmdldFRpbWUoKSk7dmFyIGE9ZC5sZW5ndGg7aWYoYT49MiYmKGY9ZFthLTFdLWRbYS0yXSksYT49Yyl7YT5jJiYoZC5zcGxpY2UoMCwxKSxhPWQubGVuZ3RoKTtmb3IodmFyIGI9MCxnPTA7YS0xPmc7ZysrKWIrPWRbZysxXS1kW2ddO2U9MWUzLyhiLyhhLTEpKX19LGguQ3JlYXRlU2NyZWVuc2hvdD1mdW5jdGlvbihjLGQsZSl7dmFyIGYsZyxpPWQuZ2V0U2NlbmUoKSxqPW51bGw7aWYoaS5hY3RpdmVDYW1lcmEhPT1kJiYoaj1pLmFjdGl2ZUNhbWVyYSxpLmFjdGl2ZUNhbWVyYT1kKSxlLnByZWNpc2lvbilmPU1hdGgucm91bmQoYy5nZXRSZW5kZXJXaWR0aCgpKmUucHJlY2lzaW9uKSxnPU1hdGgucm91bmQoZi9jLmdldEFzcGVjdFJhdGlvKGQpKSxlPXt3aWR0aDpmLGhlaWdodDpnfTtlbHNlIGlmKGUud2lkdGgmJmUuaGVpZ2h0KWY9ZS53aWR0aCxnPWUuaGVpZ2h0O2Vsc2UgaWYoZS53aWR0aCYmIWUuaGVpZ2h0KWY9ZS53aWR0aCxnPU1hdGgucm91bmQoZi9jLmdldEFzcGVjdFJhdGlvKGQpKSxlPXt3aWR0aDpmLGhlaWdodDpnfTtlbHNlIGlmKGUuaGVpZ2h0JiYhZS53aWR0aClnPWUuaGVpZ2h0LGY9TWF0aC5yb3VuZChnKmMuZ2V0QXNwZWN0UmF0aW8oZCkpLGU9e3dpZHRoOmYsaGVpZ2h0Omd9O2Vsc2V7aWYoaXNOYU4oZSkpcmV0dXJuIHZvaWQgaC5FcnJvcihcIkludmFsaWQgJ3NpemUnIHBhcmFtZXRlciAhXCIpO2c9ZSxmPWV9dmFyIGs9bmV3IGEuUmVuZGVyVGFyZ2V0VGV4dHVyZShcInNjcmVlblNob3RcIixlLGMuc2NlbmVzWzBdLCExLCExKTtrLnJlbmRlckxpc3Q9Yy5zY2VuZXNbMF0ubWVzaGVzLGsub25BZnRlclJlbmRlcj1mdW5jdGlvbigpe2Zvcih2YXIgYT00KmYsZD1nLzIsZT1jLnJlYWRQaXhlbHMoMCwwLGYsZyksaD0wO2Q+aDtoKyspZm9yKHZhciBpPTA7YT5pO2krKyl7dmFyIGo9aStoKmEsaz1nLWgtMSxsPWkrayphLG09ZVtqXTtlW2pdPWVbbF0sZVtsXT1tfWJ8fChiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpLGIud2lkdGg9ZixiLmhlaWdodD1nO3ZhciBuPWIuZ2V0Q29udGV4dChcIjJkXCIpLG89bi5jcmVhdGVJbWFnZURhdGEoZixnKTtvLmRhdGEuc2V0KGUpLG4ucHV0SW1hZ2VEYXRhKG8sMCwwKTt2YXIgcD1iLnRvRGF0YVVSTCgpO2lmKFwiZG93bmxvYWRcImluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKXt2YXIgcT13aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7cS5ocmVmPXA7dmFyIHI9bmV3IERhdGUscz1yLmdldEZ1bGxZZWFyKCkrXCIvXCIrci5nZXRNb250aCgpK1wiL1wiK3IuZ2V0RGF0ZSgpK1wiLVwiK3IuZ2V0SG91cnMoKStcIjpcIityLmdldE1pbnV0ZXMoKTtxLnNldEF0dHJpYnV0ZShcImRvd25sb2FkXCIsXCJzY3JlZW5zaG90LVwiK3MrXCIucG5nXCIpLHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHEpLHEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oKXtxLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocSl9KSxxLmNsaWNrKCl9ZWxzZXt2YXIgdD13aW5kb3cub3BlbihcIlwiKSx1PXQuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTt1LnNyYz1wLHQuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1KX19LGsucmVuZGVyKCEwKSxrLmRpc3Bvc2UoKSxqJiYoaS5hY3RpdmVDYW1lcmE9ail9LGguVmFsaWRhdGVYSFJEYXRhPWZ1bmN0aW9uKGIsYyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTcpO3RyeXtpZigxJmMpe2lmKGIucmVzcG9uc2VUZXh0JiZiLnJlc3BvbnNlVGV4dC5sZW5ndGg+MClyZXR1cm4hMDtpZigxPT09YylyZXR1cm4hMX1pZigyJmMpe3ZhciBkPWEuSW50ZXJuYWxzLlRHQVRvb2xzLkdldFRHQUhlYWRlcihiLnJlc3BvbnNlKTtpZihkLndpZHRoJiZkLmhlaWdodCYmZC53aWR0aD4wJiZkLmhlaWdodD4wKXJldHVybiEwO2lmKDI9PT1jKXJldHVybiExfWlmKDQmYyl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoYi5yZXNwb25zZSwwLDMpO3JldHVybiA2OD09ZVswXSYmNjg9PWVbMV0mJjgzPT1lWzJdPyEwOiExfX1jYXRjaChmKXt9cmV0dXJuITF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiTm9uZUxvZ0xldmVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9Ob25lTG9nTGV2ZWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJNZXNzYWdlTG9nTGV2ZWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX01lc3NhZ2VMb2dMZXZlbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIldhcm5pbmdMb2dMZXZlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fV2FybmluZ0xvZ0xldmVsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiRXJyb3JMb2dMZXZlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fRXJyb3JMb2dMZXZlbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkFsbExvZ0xldmVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9NZXNzYWdlTG9nTGV2ZWx8aC5fV2FybmluZ0xvZ0xldmVsfGguX0Vycm9yTG9nTGV2ZWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksaC5fRm9ybWF0TWVzc2FnZT1mdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtyZXR1cm4gMTA+YT9cIjBcIithOlwiXCIrYX0sYz1uZXcgRGF0ZTtyZXR1cm5cIkJKUyAtIFtcIitiKGMuZ2V0SG91cnMoKSkrXCI6XCIrYihjLmdldE1pbnV0ZXMoKSkrXCI6XCIrYihjLmdldFNlY29uZHMoKSkrXCJdOiBcIithfSxoLl9Mb2dEaXNhYmxlZD1mdW5jdGlvbigpe30saC5fTG9nRW5hYmxlZD1mdW5jdGlvbihhKXtjb25zb2xlLmxvZyhoLl9Gb3JtYXRNZXNzYWdlKGEpKX0saC5fV2FybkRpc2FibGVkPWZ1bmN0aW9uKCl7fSxoLl9XYXJuRW5hYmxlZD1mdW5jdGlvbihhKXtjb25zb2xlLndhcm4oaC5fRm9ybWF0TWVzc2FnZShhKSl9LGguX0Vycm9yRGlzYWJsZWQ9ZnVuY3Rpb24oKXt9LGguX0Vycm9yRW5hYmxlZD1mdW5jdGlvbihhKXtjb25zb2xlLmVycm9yKGguX0Zvcm1hdE1lc3NhZ2UoYSkpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkxvZ0xldmVsc1wiLHtzZXQ6ZnVuY3Rpb24oYSl7aC5Mb2c9KGEmaC5NZXNzYWdlTG9nTGV2ZWwpPT09aC5NZXNzYWdlTG9nTGV2ZWw/aC5fTG9nRW5hYmxlZDpoLl9Mb2dEaXNhYmxlZCxoLldhcm49KGEmaC5XYXJuaW5nTG9nTGV2ZWwpPT09aC5XYXJuaW5nTG9nTGV2ZWw/aC5fV2FybkVuYWJsZWQ6aC5fV2FybkRpc2FibGVkLGguRXJyb3I9KGEmaC5FcnJvckxvZ0xldmVsKT09PWguRXJyb3JMb2dMZXZlbD9oLl9FcnJvckVuYWJsZWQ6aC5fRXJyb3JEaXNhYmxlZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxoLkJhc2VVcmw9XCJcIixoLl9Ob25lTG9nTGV2ZWw9MCxoLl9NZXNzYWdlTG9nTGV2ZWw9MSxoLl9XYXJuaW5nTG9nTGV2ZWw9MixoLl9FcnJvckxvZ0xldmVsPTQsaC5Mb2c9aC5fTG9nRW5hYmxlZCxoLldhcm49aC5fV2FybkVuYWJsZWQsaC5FcnJvcj1oLl9FcnJvckVuYWJsZWQsaH0oKTthLlRvb2xzPWh9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEuY3JlYXRlU2hhZGVyKFwidmVydGV4XCI9PT1jP2EuVkVSVEVYX1NIQURFUjphLkZSQUdNRU5UX1NIQURFUik7aWYoYS5zaGFkZXJTb3VyY2UoZSwoZD9kK1wiXFxuXCI6XCJcIikrYiksYS5jb21waWxlU2hhZGVyKGUpLCFhLmdldFNoYWRlclBhcmFtZXRlcihlLGEuQ09NUElMRV9TVEFUVVMpKXRocm93IG5ldyBFcnJvcihhLmdldFNoYWRlckluZm9Mb2coZSkpO3JldHVybiBlfSxjPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1kLk5FQVJFU1QsZj1kLk5FQVJFU1Q7cmV0dXJuIGI9PT1hLlRleHR1cmUuQklMSU5FQVJfU0FNUExJTkdNT0RFPyhlPWQuTElORUFSLGY9Yz9kLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDpkLkxJTkVBUik6Yj09PWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFPyhlPWQuTElORUFSLGY9Yz9kLkxJTkVBUl9NSVBNQVBfTElORUFSOmQuTElORUFSKTpiPT09YS5UZXh0dXJlLk5FQVJFU1RfU0FNUExJTkdNT0RFJiYoZT1kLk5FQVJFU1QsZj1jP2QuTkVBUkVTVF9NSVBNQVBfTElORUFSOmQuTkVBUkVTVCkse21pbjpmLG1hZzplfX0sZD1mdW5jdGlvbihhLGIpe3ZhciBjPTE7ZG8gYyo9Mjt3aGlsZShhPmMpO3JldHVybiBjPmImJihjPWIpLGN9LGU9ZnVuY3Rpb24oYixlLGYsZyxoLGksaixrLGwsbSl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIG0mJihtPWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFKTt2YXIgbj1mLmdldEVuZ2luZSgpLG89ZChnLG4uZ2V0Q2FwcygpLm1heFRleHR1cmVTaXplKSxwPWQoaCxuLmdldENhcHMoKS5tYXhUZXh0dXJlU2l6ZSk7ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsYiksZS5waXhlbFN0b3JlaShlLlVOUEFDS19GTElQX1lfV0VCR0wsdm9pZCAwPT09aT8xOmk/MTowKSxsKG8scCk7dmFyIHE9YyhtLCFqLGUpO2UudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsZS5URVhUVVJFX01BR19GSUxURVIscS5tYWcpLGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsZS5URVhUVVJFX01JTl9GSUxURVIscS5taW4pLGp8fGt8fGUuZ2VuZXJhdGVNaXBtYXAoZS5URVhUVVJFXzJEKSxlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSxuLl9hY3RpdmVUZXh0dXJlc0NhY2hlPVtdLGIuX2Jhc2VXaWR0aD1nLGIuX2Jhc2VIZWlnaHQ9aCxiLl93aWR0aD1vLGIuX2hlaWdodD1wLGIuaXNSZWFkeT0hMCxmLl9yZW1vdmVQZW5kaW5nRGF0YShiKX0sZj1mdW5jdGlvbihiLGMsZCxlLGcsaCl7dmFyIGksaj1mdW5jdGlvbigpe2QucHVzaChpKSxlLl9yZW1vdmVQZW5kaW5nRGF0YShpKSxjIT1oLmxlbmd0aC0xP2YoYixjKzEsZCxlLGcsaCk6ZyhkKX0saz1mdW5jdGlvbigpe2UuX3JlbW92ZVBlbmRpbmdEYXRhKGkpfTtpPWEuVG9vbHMuTG9hZEltYWdlKGIraFtjXSxqLGssZS5kYXRhYmFzZSksZS5fYWRkUGVuZGluZ0RhdGEoaSl9LGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7fXJldHVybiBhfSgpO2EuRW5naW5lQ2FwYWJpbGl0aWVzPWc7dmFyIGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBoKGEsYixjKXt2YXIgZD10aGlzO3RoaXMuaXNGdWxsc2NyZWVuPSExLHRoaXMuaXNQb2ludGVyTG9jaz0hMSx0aGlzLmZvcmNlV2lyZWZyYW1lPSExLHRoaXMuY3VsbEJhY2tGYWNlcz0hMCx0aGlzLnJlbmRlckV2ZW5JbkJhY2tncm91bmQ9ITAsdGhpcy5zY2VuZXM9bmV3IEFycmF5LHRoaXMuX3dpbmRvd0lzQmFja2dyb3VuZD0hMSx0aGlzLl9ydW5uaW5nTG9vcD0hMSx0aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlPW5ldyBBcnJheSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlPW5ldyBBcnJheSx0aGlzLl9jb21waWxlZEVmZmVjdHM9e30sdGhpcy5fZGVwdGhNYXNrPSExLHRoaXMuX3JlbmRlcmluZ0NhbnZhcz1hLHRoaXMuX2NhbnZhc0NsaWVudFJlY3Q9dGhpcy5fcmVuZGVyaW5nQ2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGM9Y3x8e30sYy5hbnRpYWxpYXM9Yjt0cnl7dGhpcy5fZ2w9YS5nZXRDb250ZXh0KFwid2ViZ2xcIixjKXx8YS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsYyl9Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgbm90IHN1cHBvcnRlZFwiKX1pZighdGhpcy5fZ2wpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgbm90IHN1cHBvcnRlZFwiKTt0aGlzLl9vbkJsdXI9ZnVuY3Rpb24oKXtkLl93aW5kb3dJc0JhY2tncm91bmQ9ITB9LHRoaXMuX29uRm9jdXM9ZnVuY3Rpb24oKXtkLl93aW5kb3dJc0JhY2tncm91bmQ9ITF9LHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuX29uQmx1ciksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuX29uRm9jdXMpLHRoaXMuX3dvcmtpbmdDYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx0aGlzLl93b3JraW5nQ29udGV4dD10aGlzLl93b3JraW5nQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLl9oYXJkd2FyZVNjYWxpbmdMZXZlbD0xLyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSksdGhpcy5yZXNpemUoKSx0aGlzLl9jYXBzPW5ldyBnLHRoaXMuX2NhcHMubWF4VGV4dHVyZXNJbWFnZVVuaXRzPXRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy5fY2Fwcy5tYXhUZXh0dXJlU2l6ZT10aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX1RFWFRVUkVfU0laRSksdGhpcy5fY2Fwcy5tYXhDdWJlbWFwVGV4dHVyZVNpemU9dGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLHRoaXMuX2NhcHMubWF4UmVuZGVyVGV4dHVyZVNpemU9dGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9SRU5ERVJCVUZGRVJfU0laRSksdGhpcy5fY2Fwcy5zdGFuZGFyZERlcml2YXRpdmVzPW51bGwhPT10aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIiksdGhpcy5fY2Fwcy5zM3RjPXRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLHRoaXMuX2NhcHMudGV4dHVyZUZsb2F0PW51bGwhPT10aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSx0aGlzLl9jYXBzLnRleHR1cmVBbmlzb3Ryb3BpY0ZpbHRlckV4dGVuc2lvbj10aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIil8fHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIldFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIil8fHRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIiksdGhpcy5fY2Fwcy5tYXhBbmlzb3Ryb3B5PXRoaXMuX2NhcHMudGV4dHVyZUFuaXNvdHJvcGljRmlsdGVyRXh0ZW5zaW9uP3RoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9jYXBzLnRleHR1cmVBbmlzb3Ryb3BpY0ZpbHRlckV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpOjAsdGhpcy5fY2Fwcy5pbnN0YW5jZWRBcnJheXM9dGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSx0aGlzLnNldERlcHRoQnVmZmVyKCEwKSx0aGlzLnNldERlcHRoRnVuY3Rpb25Ub0xlc3NPckVxdWFsKCksdGhpcy5zZXREZXB0aFdyaXRlKCEwKSx0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2U9ZnVuY3Rpb24oKXt2b2lkIDAhPT1kb2N1bWVudC5mdWxsc2NyZWVuP2QuaXNGdWxsc2NyZWVuPWRvY3VtZW50LmZ1bGxzY3JlZW46dm9pZCAwIT09ZG9jdW1lbnQubW96RnVsbFNjcmVlbj9kLmlzRnVsbHNjcmVlbj1kb2N1bWVudC5tb3pGdWxsU2NyZWVuOnZvaWQgMCE9PWRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbj9kLmlzRnVsbHNjcmVlbj1kb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW46dm9pZCAwIT09ZG9jdW1lbnQubXNJc0Z1bGxTY3JlZW4mJihkLmlzRnVsbHNjcmVlbj1kb2N1bWVudC5tc0lzRnVsbFNjcmVlbiksZC5pc0Z1bGxzY3JlZW4mJmQuX3BvaW50ZXJMb2NrUmVxdWVzdGVkJiYoYS5yZXF1ZXN0UG9pbnRlckxvY2s9YS5yZXF1ZXN0UG9pbnRlckxvY2t8fGEubXNSZXF1ZXN0UG9pbnRlckxvY2t8fGEubW96UmVxdWVzdFBvaW50ZXJMb2NrfHxhLndlYmtpdFJlcXVlc3RQb2ludGVyTG9jayxhLnJlcXVlc3RQb2ludGVyTG9jayYmYS5yZXF1ZXN0UG9pbnRlckxvY2soKSl9LGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIix0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtc2Z1bGxzY3JlZW5jaGFuZ2VcIix0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsITEpLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2U9ZnVuY3Rpb24oKXtkLmlzUG9pbnRlckxvY2s9ZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50PT09YXx8ZG9jdW1lbnQud2Via2l0UG9pbnRlckxvY2tFbGVtZW50PT09YXx8ZG9jdW1lbnQubXNQb2ludGVyTG9ja0VsZW1lbnQ9PT1hfHxkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ9PT1hfSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxvY2tjaGFuZ2VcIix0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibXNwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3pwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UsITEpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkFMUEhBX0RJU0FCTEVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0FMUEhBX0RJU0FCTEV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJBTFBIQV9BRERcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0FMUEhBX0FERH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkFMUEhBX0NPTUJJTkVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0FMUEhBX0NPTUJJTkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJERUxBWUxPQURTVEFURV9OT05FXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9ERUxBWUxPQURTVEFURV9OT05FfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiREVMQVlMT0FEU1RBVEVfTE9BREVEXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9ERUxBWUxPQURTVEFURV9MT0FERUR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJERUxBWUxPQURTVEFURV9MT0FESU5HXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9ERUxBWUxPQURTVEFURV9MT0FESU5HfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9ERUxBWUxPQURTVEFURV9OT1RMT0FERUR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJWZXJzaW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVyblwiMS4xMy4wXCJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksaC5wcm90b3R5cGUuZ2V0QXNwZWN0UmF0aW89ZnVuY3Rpb24oYSl7dmFyIGI9YS52aWV3cG9ydDtyZXR1cm4gdGhpcy5nZXRSZW5kZXJXaWR0aCgpKmIud2lkdGgvKHRoaXMuZ2V0UmVuZGVySGVpZ2h0KCkqYi5oZWlnaHQpfSxoLnByb3RvdHlwZS5nZXRSZW5kZXJXaWR0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0P3RoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQuX3dpZHRoOnRoaXMuX3JlbmRlcmluZ0NhbnZhcy53aWR0aH0saC5wcm90b3R5cGUuZ2V0UmVuZGVySGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQ/dGhpcy5fY3VycmVudFJlbmRlclRhcmdldC5faGVpZ2h0OnRoaXMuX3JlbmRlcmluZ0NhbnZhcy5oZWlnaHR9LGgucHJvdG90eXBlLmdldFJlbmRlcmluZ0NhbnZhcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJpbmdDYW52YXN9LGgucHJvdG90eXBlLmdldFJlbmRlcmluZ0NhbnZhc0NsaWVudFJlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyaW5nQ2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfSxoLnByb3RvdHlwZS5zZXRIYXJkd2FyZVNjYWxpbmdMZXZlbD1mdW5jdGlvbihhKXt0aGlzLl9oYXJkd2FyZVNjYWxpbmdMZXZlbD1hLHRoaXMucmVzaXplKCl9LGgucHJvdG90eXBlLmdldEhhcmR3YXJlU2NhbGluZ0xldmVsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhcmR3YXJlU2NhbGluZ0xldmVsfSxoLnByb3RvdHlwZS5nZXRMb2FkZWRUZXh0dXJlc0NhY2hlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xvYWRlZFRleHR1cmVzQ2FjaGV9LGgucHJvdG90eXBlLmdldENhcHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2Fwc30saC5wcm90b3R5cGUuc2V0RGVwdGhGdW5jdGlvblRvR3JlYXRlcj1mdW5jdGlvbigpe3RoaXMuX2dsLmRlcHRoRnVuYyh0aGlzLl9nbC5HUkVBVEVSKX0saC5wcm90b3R5cGUuc2V0RGVwdGhGdW5jdGlvblRvR3JlYXRlck9yRXF1YWw9ZnVuY3Rpb24oKXt0aGlzLl9nbC5kZXB0aEZ1bmModGhpcy5fZ2wuR0VRVUFMKX0saC5wcm90b3R5cGUuc2V0RGVwdGhGdW5jdGlvblRvTGVzcz1mdW5jdGlvbigpe3RoaXMuX2dsLmRlcHRoRnVuYyh0aGlzLl9nbC5MRVNTKX0saC5wcm90b3R5cGUuc2V0RGVwdGhGdW5jdGlvblRvTGVzc09yRXF1YWw9ZnVuY3Rpb24oKXt0aGlzLl9nbC5kZXB0aEZ1bmModGhpcy5fZ2wuTEVRVUFMKX0saC5wcm90b3R5cGUuc3RvcFJlbmRlckxvb3A9ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJGdW5jdGlvbj1udWxsLHRoaXMuX3J1bm5pbmdMb29wPSExfSxoLnByb3RvdHlwZS5fcmVuZGVyTG9vcD1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz0hMDshdGhpcy5yZW5kZXJFdmVuSW5CYWNrZ3JvdW5kJiZ0aGlzLl93aW5kb3dJc0JhY2tncm91bmQmJihjPSExKSxjJiYodGhpcy5iZWdpbkZyYW1lKCksdGhpcy5fcmVuZGVyRnVuY3Rpb24mJnRoaXMuX3JlbmRlckZ1bmN0aW9uKCksdGhpcy5lbmRGcmFtZSgpKSx0aGlzLl9ydW5uaW5nTG9vcCYmYS5Ub29scy5RdWV1ZU5ld0ZyYW1lKGZ1bmN0aW9uKCl7Yi5fcmVuZGVyTG9vcCgpfSl9LGgucHJvdG90eXBlLnJ1blJlbmRlckxvb3A9ZnVuY3Rpb24oYil7dmFyIGM9dGhpczt0aGlzLl9ydW5uaW5nTG9vcD0hMCx0aGlzLl9yZW5kZXJGdW5jdGlvbj1iLGEuVG9vbHMuUXVldWVOZXdGcmFtZShmdW5jdGlvbigpe2MuX3JlbmRlckxvb3AoKX0pfSxoLnByb3RvdHlwZS5zd2l0Y2hGdWxsc2NyZWVuPWZ1bmN0aW9uKGIpe3RoaXMuaXNGdWxsc2NyZWVuP2EuVG9vbHMuRXhpdEZ1bGxzY3JlZW4oKToodGhpcy5fcG9pbnRlckxvY2tSZXF1ZXN0ZWQ9YixhLlRvb2xzLlJlcXVlc3RGdWxsc2NyZWVuKHRoaXMuX3JlbmRlcmluZ0NhbnZhcykpfSxoLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbihhLGIsYyl7dGhpcy5fZ2wuY2xlYXJDb2xvcihhLnIsYS5nLGEuYix2b2lkIDAhPT1hLmE/YS5hOjEpLHRoaXMuX2RlcHRoTWFzayYmdGhpcy5fZ2wuY2xlYXJEZXB0aCgxKTt2YXIgZD0wO2ImJihkfD10aGlzLl9nbC5DT0xPUl9CVUZGRVJfQklUKSxjJiZ0aGlzLl9kZXB0aE1hc2smJihkfD10aGlzLl9nbC5ERVBUSF9CVUZGRVJfQklUKSx0aGlzLl9nbC5jbGVhcihkKX0saC5wcm90b3R5cGUuc2V0Vmlld3BvcnQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWJ8fHRoaXMuX3JlbmRlcmluZ0NhbnZhcy53aWR0aCxlPWN8fHRoaXMuX3JlbmRlcmluZ0NhbnZhcy5oZWlnaHQsZj1hLnh8fDAsZz1hLnl8fDA7dGhpcy5fY2FjaGVkVmlld3BvcnQ9YSx0aGlzLl9nbC52aWV3cG9ydChmKmQsZyplLGQqYS53aWR0aCxlKmEuaGVpZ2h0KX0saC5wcm90b3R5cGUuc2V0RGlyZWN0Vmlld3BvcnQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5fY2FjaGVkVmlld3BvcnQ9bnVsbCx0aGlzLl9nbC52aWV3cG9ydChhLGIsYyxkKX0saC5wcm90b3R5cGUuYmVnaW5GcmFtZT1mdW5jdGlvbigpe2EuVG9vbHMuX01lYXN1cmVGcHMoKX0saC5wcm90b3R5cGUuZW5kRnJhbWU9ZnVuY3Rpb24oKXt0aGlzLmZsdXNoRnJhbWVidWZmZXIoKX0saC5wcm90b3R5cGUucmVzaXplPWZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyaW5nQ2FudmFzLndpZHRoPXRoaXMuX3JlbmRlcmluZ0NhbnZhcy5jbGllbnRXaWR0aC90aGlzLl9oYXJkd2FyZVNjYWxpbmdMZXZlbCx0aGlzLl9yZW5kZXJpbmdDYW52YXMuaGVpZ2h0PXRoaXMuX3JlbmRlcmluZ0NhbnZhcy5jbGllbnRIZWlnaHQvdGhpcy5faGFyZHdhcmVTY2FsaW5nTGV2ZWwsdGhpcy5fY2FudmFzQ2xpZW50UmVjdD10aGlzLl9yZW5kZXJpbmdDYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9LGgucHJvdG90eXBlLmJpbmRGcmFtZWJ1ZmZlcj1mdW5jdGlvbihhKXt0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0PWE7dmFyIGI9dGhpcy5fZ2w7Yi5iaW5kRnJhbWVidWZmZXIoYi5GUkFNRUJVRkZFUixhLl9mcmFtZWJ1ZmZlciksdGhpcy5fZ2wudmlld3BvcnQoMCwwLGEuX3dpZHRoLGEuX2hlaWdodCksdGhpcy53aXBlQ2FjaGVzKCl9LGgucHJvdG90eXBlLnVuQmluZEZyYW1lYnVmZmVyPWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQ9bnVsbCxhLmdlbmVyYXRlTWlwTWFwcyl7dmFyIGI9dGhpcy5fZ2w7Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsYSksYi5nZW5lcmF0ZU1pcG1hcChiLlRFWFRVUkVfMkQpLGIuYmluZFRleHR1cmUoYi5URVhUVVJFXzJELG51bGwpfXRoaXMuX2dsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9nbC5GUkFNRUJVRkZFUixudWxsKX0saC5wcm90b3R5cGUuZmx1c2hGcmFtZWJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuX2dsLmZsdXNoKCl9LGgucHJvdG90eXBlLnJlc3RvcmVEZWZhdWx0RnJhbWVidWZmZXI9ZnVuY3Rpb24oKXt0aGlzLl9nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fZ2wuRlJBTUVCVUZGRVIsbnVsbCksdGhpcy5zZXRWaWV3cG9ydCh0aGlzLl9jYWNoZWRWaWV3cG9ydCksdGhpcy53aXBlQ2FjaGVzKCl9LGgucHJvdG90eXBlLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmc9ZnVuY3Rpb24oKXt0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixudWxsKSx0aGlzLl9jYWNoZWRWZXJ0ZXhCdWZmZXJzPW51bGx9LGgucHJvdG90eXBlLmNyZWF0ZVZlcnRleEJ1ZmZlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYiksdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShhKSx0aGlzLl9nbC5TVEFUSUNfRFJBVyksdGhpcy5fcmVzZXRWZXJ0ZXhCdWZmZXJCaW5kaW5nKCksYi5yZWZlcmVuY2VzPTEsYn0saC5wcm90b3R5cGUuY3JlYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYiksdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYSx0aGlzLl9nbC5EWU5BTUlDX0RSQVcpLHRoaXMuX3Jlc2V0VmVydGV4QnVmZmVyQmluZGluZygpLGIucmVmZXJlbmNlcz0xLGJ9LGgucHJvdG90eXBlLnVwZGF0ZUR5bmFtaWNWZXJ0ZXhCdWZmZXI9ZnVuY3Rpb24oYSxiKXt0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixhKSxiIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P3RoaXMuX2dsLmJ1ZmZlclN1YkRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLDAsYik6dGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsMCxuZXcgRmxvYXQzMkFycmF5KGIpKSx0aGlzLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmcoKX0saC5wcm90b3R5cGUuX3Jlc2V0SW5kZXhCdWZmZXJCaW5kaW5nPWZ1bmN0aW9uKCl7dGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0aGlzLl9jYWNoZWRJbmRleEJ1ZmZlcj1udWxsfSxoLnByb3RvdHlwZS5jcmVhdGVJbmRleEJ1ZmZlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixiKSx0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG5ldyBVaW50MTZBcnJheShhKSx0aGlzLl9nbC5TVEFUSUNfRFJBVyksdGhpcy5fcmVzZXRJbmRleEJ1ZmZlckJpbmRpbmcoKSxiLnJlZmVyZW5jZXM9MSxifSxoLnByb3RvdHlwZS5iaW5kQnVmZmVycz1mdW5jdGlvbihhLGIsYyxkLGUpe2lmKHRoaXMuX2NhY2hlZFZlcnRleEJ1ZmZlcnMhPT1hfHx0aGlzLl9jYWNoZWRFZmZlY3RGb3JWZXJ0ZXhCdWZmZXJzIT09ZSl7dGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycz1hLHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnM9ZSx0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixhKTtmb3IodmFyIGY9MCxnPTA7ZzxjLmxlbmd0aDtnKyspe3ZhciBoPWUuZ2V0QXR0cmlidXRlTG9jYXRpb24oZyk7aD49MCYmdGhpcy5fZ2wudmVydGV4QXR0cmliUG9pbnRlcihoLGNbZ10sdGhpcy5fZ2wuRkxPQVQsITEsZCxmKSxmKz00KmNbZ119fXRoaXMuX2NhY2hlZEluZGV4QnVmZmVyIT09YiYmKHRoaXMuX2NhY2hlZEluZGV4QnVmZmVyPWIsdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixiKSl9LGgucHJvdG90eXBlLmJpbmRNdWx0aUJ1ZmZlcnM9ZnVuY3Rpb24oYSxiLGMpe2lmKHRoaXMuX2NhY2hlZFZlcnRleEJ1ZmZlcnMhPT1hfHx0aGlzLl9jYWNoZWRFZmZlY3RGb3JWZXJ0ZXhCdWZmZXJzIT09Yyl7dGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycz1hLHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnM9Yztmb3IodmFyIGQ9Yy5nZXRBdHRyaWJ1dGVzTmFtZXMoKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWMuZ2V0QXR0cmlidXRlTG9jYXRpb24oZSk7aWYoZj49MCl7dmFyIGc9YVtkW2VdXTtpZighZyljb250aW51ZTt2YXIgaD1nLmdldFN0cmlkZVNpemUoKTt0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixnLmdldEJ1ZmZlcigpKSx0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGYsaCx0aGlzLl9nbC5GTE9BVCwhMSw0KmgsMCl9fX10aGlzLl9jYWNoZWRJbmRleEJ1ZmZlciE9PWImJih0aGlzLl9jYWNoZWRJbmRleEJ1ZmZlcj1iLHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsYikpfSxoLnByb3RvdHlwZS5fcmVsZWFzZUJ1ZmZlcj1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZWZlcmVuY2VzLS0sMD09PWEucmVmZXJlbmNlcz8odGhpcy5fZ2wuZGVsZXRlQnVmZmVyKGEpLCEwKTohMX0saC5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2VzQnVmZmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO3JldHVybiBiLmNhcGFjaXR5PWEsdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYiksdGhpcy5fZ2wuYnVmZmVyRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYSx0aGlzLl9nbC5EWU5BTUlDX0RSQVcpLGJ9LGgucHJvdG90eXBlLmRlbGV0ZUluc3RhbmNlc0J1ZmZlcj1mdW5jdGlvbihhKXt0aGlzLl9nbC5kZWxldGVCdWZmZXIoYSl9LGgucHJvdG90eXBlLnVwZGF0ZUFuZEJpbmRJbnN0YW5jZXNCdWZmZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLGEpLHRoaXMuX2dsLmJ1ZmZlclN1YkRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLDAsYik7Zm9yKHZhciBkPTA7ND5kO2QrKyl7dmFyIGU9Y1tkXTt0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSx0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGUsNCx0aGlzLl9nbC5GTE9BVCwhMSw2NCwxNipkKSx0aGlzLl9jYXBzLmluc3RhbmNlZEFycmF5cy52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoZSwxKX19LGgucHJvdG90eXBlLnVuQmluZEluc3RhbmNlc0J1ZmZlcj1mdW5jdGlvbihhLGIpe3RoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLGEpO2Zvcih2YXIgYz0wOzQ+YztjKyspe3ZhciBkPWJbY107dGhpcy5fZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGQpLHRoaXMuX2NhcHMuaW5zdGFuY2VkQXJyYXlzLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShkLDApfX0saC5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gZD92b2lkIHRoaXMuX2NhcHMuaW5zdGFuY2VkQXJyYXlzLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKGE/dGhpcy5fZ2wuVFJJQU5HTEVTOnRoaXMuX2dsLkxJTkVTLGMsdGhpcy5fZ2wuVU5TSUdORURfU0hPUlQsMipiLGQpOnZvaWQgdGhpcy5fZ2wuZHJhd0VsZW1lbnRzKGE/dGhpcy5fZ2wuVFJJQU5HTEVTOnRoaXMuX2dsLkxJTkVTLGMsdGhpcy5fZ2wuVU5TSUdORURfU0hPUlQsMipiKX0saC5wcm90b3R5cGUuX3JlbGVhc2VFZmZlY3Q9ZnVuY3Rpb24oYSl7dGhpcy5fY29tcGlsZWRFZmZlY3RzW2EuX2tleV0mJihkZWxldGUgdGhpcy5fY29tcGlsZWRFZmZlY3RzW2EuX2tleV0sYS5nZXRQcm9ncmFtKCkmJnRoaXMuX2dsLmRlbGV0ZVByb2dyYW0oYS5nZXRQcm9ncmFtKCkpKX0saC5wcm90b3R5cGUuY3JlYXRlRWZmZWN0PWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgsaSl7dmFyIGo9Yi52ZXJ0ZXhFbGVtZW50fHxiLnZlcnRleHx8YixrPWIuZnJhZ21lbnRFbGVtZW50fHxiLmZyYWdtZW50fHxiLGw9aitcIitcIitrK1wiQFwiK2Y7aWYodGhpcy5fY29tcGlsZWRFZmZlY3RzW2xdKXJldHVybiB0aGlzLl9jb21waWxlZEVmZmVjdHNbbF07dmFyIG09bmV3IGEuRWZmZWN0KGIsYyxkLGUsdGhpcyxmLGcsaCxpKTtyZXR1cm4gbS5fa2V5PWwsdGhpcy5fY29tcGlsZWRFZmZlY3RzW2xdPW0sbX0saC5wcm90b3R5cGUuY3JlYXRlU2hhZGVyUHJvZ3JhbT1mdW5jdGlvbihhLGMsZCl7dmFyIGU9Yih0aGlzLl9nbCxhLFwidmVydGV4XCIsZCksZj1iKHRoaXMuX2dsLGMsXCJmcmFnbWVudFwiLGQpLGc9dGhpcy5fZ2wuY3JlYXRlUHJvZ3JhbSgpO3RoaXMuX2dsLmF0dGFjaFNoYWRlcihnLGUpLHRoaXMuX2dsLmF0dGFjaFNoYWRlcihnLGYpLHRoaXMuX2dsLmxpbmtQcm9ncmFtKGcpO3ZhciBoPXRoaXMuX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoZyx0aGlzLl9nbC5MSU5LX1NUQVRVUyk7aWYoIWgpe3ZhciBpPXRoaXMuX2dsLmdldFByb2dyYW1JbmZvTG9nKGcpO2lmKGkpdGhyb3cgbmV3IEVycm9yKGkpfXJldHVybiB0aGlzLl9nbC5kZWxldGVTaGFkZXIoZSksdGhpcy5fZ2wuZGVsZXRlU2hhZGVyKGYpLGd9LGgucHJvdG90eXBlLmdldFVuaWZvcm1zPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLGQ9MDtkPGIubGVuZ3RoO2QrKyljLnB1c2godGhpcy5fZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGEsYltkXSkpO3JldHVybiBjfSxoLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLGQ9MDtkPGIubGVuZ3RoO2QrKyl0cnl7Yy5wdXNoKHRoaXMuX2dsLmdldEF0dHJpYkxvY2F0aW9uKGEsYltkXSkpfWNhdGNoKGUpe2MucHVzaCgtMSl9cmV0dXJuIGN9LGgucHJvdG90eXBlLmVuYWJsZUVmZmVjdD1mdW5jdGlvbihhKXtpZihhJiZhLmdldEF0dHJpYnV0ZXNDb3VudCgpJiZ0aGlzLl9jdXJyZW50RWZmZWN0IT09YSl7dGhpcy5fdmVydGV4QXR0cmliQXJyYXlzPXRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c3x8W10sdGhpcy5fZ2wudXNlUHJvZ3JhbShhLmdldFByb2dyYW0oKSk7Zm9yKHZhciBiIGluIHRoaXMuX3ZlcnRleEF0dHJpYkFycmF5cyliPnRoaXMuX2dsLlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRHx8IXRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c1tiXXx8KHRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c1tiXT0hMSx0aGlzLl9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYikpO2Zvcih2YXIgYz1hLmdldEF0dHJpYnV0ZXNDb3VudCgpLGQ9MDtjPmQ7ZCsrKXt2YXIgZT1hLmdldEF0dHJpYnV0ZUxvY2F0aW9uKGQpO2U+PTAmJih0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXNbZV09ITAsdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZSkpfXRoaXMuX2N1cnJlbnRFZmZlY3Q9YX19LGgucHJvdG90eXBlLnNldEFycmF5PWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5fZ2wudW5pZm9ybTFmdihhLGIpfSxoLnByb3RvdHlwZS5zZXRNYXRyaWNlcz1mdW5jdGlvbihhLGIpe2EmJnRoaXMuX2dsLnVuaWZvcm1NYXRyaXg0ZnYoYSwhMSxiKX0saC5wcm90b3R5cGUuc2V0TWF0cml4PWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDRmdihhLCExLGIudG9BcnJheSgpKX0saC5wcm90b3R5cGUuc2V0RmxvYXQ9ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLl9nbC51bmlmb3JtMWYoYSxiKX0saC5wcm90b3R5cGUuc2V0RmxvYXQyPWZ1bmN0aW9uKGEsYixjKXthJiZ0aGlzLl9nbC51bmlmb3JtMmYoYSxiLGMpfSxoLnByb3RvdHlwZS5zZXRGbG9hdDM9ZnVuY3Rpb24oYSxiLGMsZCl7YSYmdGhpcy5fZ2wudW5pZm9ybTNmKGEsYixjLGQpfSxoLnByb3RvdHlwZS5zZXRCb29sPWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5fZ2wudW5pZm9ybTFpKGEsYil9LGgucHJvdG90eXBlLnNldEZsb2F0ND1mdW5jdGlvbihhLGIsYyxkLGUpe2EmJnRoaXMuX2dsLnVuaWZvcm00ZihhLGIsYyxkLGUpfSxoLnByb3RvdHlwZS5zZXRDb2xvcjM9ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLl9nbC51bmlmb3JtM2YoYSxiLnIsYi5nLGIuYil9LGgucHJvdG90eXBlLnNldENvbG9yND1mdW5jdGlvbihhLGIsYyl7YSYmdGhpcy5fZ2wudW5pZm9ybTRmKGEsYi5yLGIuZyxiLmIsYyl9LGgucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEpe3RoaXMuX2N1bGxpbmdTdGF0ZSE9PWEmJihhPyh0aGlzLl9nbC5jdWxsRmFjZSh0aGlzLmN1bGxCYWNrRmFjZXM/dGhpcy5fZ2wuQkFDSzp0aGlzLl9nbC5GUk9OVCksdGhpcy5fZ2wuZW5hYmxlKHRoaXMuX2dsLkNVTExfRkFDRSkpOnRoaXMuX2dsLmRpc2FibGUodGhpcy5fZ2wuQ1VMTF9GQUNFKSx0aGlzLl9jdWxsaW5nU3RhdGU9YSl9LGgucHJvdG90eXBlLnNldERlcHRoQnVmZmVyPWZ1bmN0aW9uKGEpe2E/dGhpcy5fZ2wuZW5hYmxlKHRoaXMuX2dsLkRFUFRIX1RFU1QpOnRoaXMuX2dsLmRpc2FibGUodGhpcy5fZ2wuREVQVEhfVEVTVCl9LGgucHJvdG90eXBlLnNldERlcHRoV3JpdGU9ZnVuY3Rpb24oYSl7dGhpcy5fZ2wuZGVwdGhNYXNrKGEpLHRoaXMuX2RlcHRoTWFzaz1hfSxoLnByb3RvdHlwZS5zZXRDb2xvcldyaXRlPWZ1bmN0aW9uKGEpe3RoaXMuX2dsLmNvbG9yTWFzayhhLGEsYSxhKX0saC5wcm90b3R5cGUuc2V0QWxwaGFNb2RlPWZ1bmN0aW9uKGIpe3N3aXRjaChiKXtjYXNlIGEuRW5naW5lLkFMUEhBX0RJU0FCTEU6dGhpcy5zZXREZXB0aFdyaXRlKCEwKSx0aGlzLl9nbC5kaXNhYmxlKHRoaXMuX2dsLkJMRU5EKTticmVhaztjYXNlIGEuRW5naW5lLkFMUEhBX0NPTUJJTkU6dGhpcy5zZXREZXB0aFdyaXRlKCExKSx0aGlzLl9nbC5ibGVuZEZ1bmNTZXBhcmF0ZSh0aGlzLl9nbC5TUkNfQUxQSEEsdGhpcy5fZ2wuT05FX01JTlVTX1NSQ19BTFBIQSx0aGlzLl9nbC5PTkUsdGhpcy5fZ2wuT05FKSx0aGlzLl9nbC5lbmFibGUodGhpcy5fZ2wuQkxFTkQpO2JyZWFrO2Nhc2UgYS5FbmdpbmUuQUxQSEFfQUREOnRoaXMuc2V0RGVwdGhXcml0ZSghMSksdGhpcy5fZ2wuYmxlbmRGdW5jU2VwYXJhdGUodGhpcy5fZ2wuT05FLHRoaXMuX2dsLk9ORSx0aGlzLl9nbC5aRVJPLHRoaXMuX2dsLk9ORSksdGhpcy5fZ2wuZW5hYmxlKHRoaXMuX2dsLkJMRU5EKX19LGgucHJvdG90eXBlLnNldEFscGhhVGVzdGluZz1mdW5jdGlvbihhKXt0aGlzLl9hbHBoYVRlc3Q9YX0saC5wcm90b3R5cGUuZ2V0QWxwaGFUZXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FscGhhVGVzdH0saC5wcm90b3R5cGUud2lwZUNhY2hlcz1mdW5jdGlvbigpe3RoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sdGhpcy5fY3VycmVudEVmZmVjdD1udWxsLHRoaXMuX2N1bGxpbmdTdGF0ZT1udWxsLHRoaXMuX2NhY2hlZFZlcnRleEJ1ZmZlcnM9bnVsbCx0aGlzLl9jYWNoZWRJbmRleEJ1ZmZlcj1udWxsLHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnM9bnVsbH0saC5wcm90b3R5cGUuc2V0U2FtcGxpbmdNb2RlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5fZ2w7ZC5iaW5kVGV4dHVyZShkLlRFWFRVUkVfMkQsYik7dmFyIGU9ZC5ORUFSRVNULGY9ZC5ORUFSRVNUO2M9PT1hLlRleHR1cmUuQklMSU5FQVJfU0FNUExJTkdNT0RFPyhlPWQuTElORUFSLGY9ZC5MSU5FQVIpOmM9PT1hLlRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSYmKGU9ZC5MSU5FQVIsZj1kLkxJTkVBUl9NSVBNQVBfTElORUFSKSxkLnRleFBhcmFtZXRlcmkoZC5URVhUVVJFXzJELGQuVEVYVFVSRV9NQUdfRklMVEVSLGUpLGQudGV4UGFyYW1ldGVyaShkLlRFWFRVUkVfMkQsZC5URVhUVVJFX01JTl9GSUxURVIsZiksZC5iaW5kVGV4dHVyZShkLlRFWFRVUkVfMkQsbnVsbCl9LGgucHJvdG90eXBlLmNyZWF0ZVRleHR1cmU9ZnVuY3Rpb24oYixjLGQsZixnKXt2YXIgaD10aGlzO1widW5kZWZpbmVkXCI9PXR5cGVvZiBnJiYoZz1hLlRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSk7dmFyIGk9dGhpcy5fZ2wuY3JlYXRlVGV4dHVyZSgpLGo9Yi5zdWJzdHIoYi5sZW5ndGgtNCw0KS50b0xvd2VyQ2FzZSgpLGs9dGhpcy5nZXRDYXBzKCkuczN0YyYmXCIuZGRzXCI9PT1qLGw9XCIudGdhXCI9PT1qO2lmKGYuX2FkZFBlbmRpbmdEYXRhKGkpLGkudXJsPWIsaS5ub01pcG1hcD1jLGkucmVmZXJlbmNlcz0xLHRoaXMuX2xvYWRlZFRleHR1cmVzQ2FjaGUucHVzaChpKSxsKWEuVG9vbHMuTG9hZEZpbGUoYixmdW5jdGlvbihiKXt2YXIgaj1uZXcgVWludDhBcnJheShiKSxrPWEuSW50ZXJuYWxzLlRHQVRvb2xzLkdldFRHQUhlYWRlcihqKTtlKGksaC5fZ2wsZixrLndpZHRoLGsuaGVpZ2h0LGQsYywhMSxmdW5jdGlvbigpe2EuSW50ZXJuYWxzLlRHQVRvb2xzLlVwbG9hZENvbnRlbnQoaC5fZ2wsail9LGcpfSxudWxsLGYuZGF0YWJhc2UsITApO2Vsc2UgaWYoaylhLlRvb2xzLkxvYWRGaWxlKGIsZnVuY3Rpb24oail7dmFyIGs9YS5JbnRlcm5hbHMuRERTVG9vbHMuR2V0RERTSW5mbyhqKSxsPShrLmlzUkdCfHxrLmlzTHVtaW5hbmNlfHxrLm1pcG1hcENvdW50PjEpJiYhYyYmay53aWR0aD4+ay5taXBtYXBDb3VudC0xPT0xO2UoaSxoLl9nbCxmLGsud2lkdGgsay5oZWlnaHQsZCwhbCxrLmlzRm91ckNDLGZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJsb2FkaW5nIFwiK2IpLGEuSW50ZXJuYWxzLkREU1Rvb2xzLlVwbG9hZEREU0xldmVscyhoLl9nbCxoLmdldENhcHMoKS5zM3RjLGosayxsLDEpfSxnKX0sbnVsbCxmLmRhdGFiYXNlLCEwKTtlbHNle3ZhciBtPWZ1bmN0aW9uKGEpe2UoaSxoLl9nbCxmLGEud2lkdGgsYS5oZWlnaHQsZCxjLCExLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS53aWR0aD09YiYmYS5oZWlnaHQ9PWM7ZHx8KGguX3dvcmtpbmdDYW52YXMud2lkdGg9YixoLl93b3JraW5nQ2FudmFzLmhlaWdodD1jLGguX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShhLDAsMCxhLndpZHRoLGEuaGVpZ2h0LDAsMCxiLGMpKSxoLl9nbC50ZXhJbWFnZTJEKGguX2dsLlRFWFRVUkVfMkQsMCxoLl9nbC5SR0JBLGguX2dsLlJHQkEsaC5fZ2wuVU5TSUdORURfQllURSxkP2E6aC5fd29ya2luZ0NhbnZhcyl9LGcpfSxuPWZ1bmN0aW9uKCl7Zi5fcmVtb3ZlUGVuZGluZ0RhdGEoaSl9O2EuVG9vbHMuTG9hZEltYWdlKGIsbSxuLGYuZGF0YWJhc2UpfXJldHVybiBpfSxoLnByb3RvdHlwZS5jcmVhdGVEeW5hbWljVGV4dHVyZT1mdW5jdGlvbihhLGIsZSxmKXt2YXIgZz10aGlzLl9nbC5jcmVhdGVUZXh0dXJlKCk7YT1kKGEsdGhpcy5fY2Fwcy5tYXhUZXh0dXJlU2l6ZSksYj1kKGIsdGhpcy5fY2Fwcy5tYXhUZXh0dXJlU2l6ZSksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxnKTt2YXIgaD1jKGYsZSx0aGlzLl9nbCk7cmV0dXJuIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsaC5tYWcpLHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX01JTl9GSUxURVIsaC5taW4pLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsbnVsbCksdGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZT1bXSxnLl9iYXNlV2lkdGg9YSxnLl9iYXNlSGVpZ2h0PWIsZy5fd2lkdGg9YSxnLl9oZWlnaHQ9YixnLmlzUmVhZHk9ITEsZy5nZW5lcmF0ZU1pcE1hcHM9ZSxnLnJlZmVyZW5jZXM9MSx0aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlLnB1c2goZyksZ30saC5wcm90b3R5cGUudXBkYXRlRHluYW1pY1RleHR1cmU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsYSksdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCxjPzE6MCksdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELDAsdGhpcy5fZ2wuUkdCQSx0aGlzLl9nbC5SR0JBLHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsYiksYS5nZW5lcmF0ZU1pcE1hcHMmJnRoaXMuX2dsLmdlbmVyYXRlTWlwbWFwKHRoaXMuX2dsLlRFWFRVUkVfMkQpLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsbnVsbCksdGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZT1bXSxhLmlzUmVhZHk9ITB9LGgucHJvdG90eXBlLnVwZGF0ZVZpZGVvVGV4dHVyZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxhKSx0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLGM/MDoxKSxiLnZpZGVvV2lkdGghPT1hLl93aWR0aHx8Yi52aWRlb0hlaWdodCE9PWEuX2hlaWdodD8oYS5fd29ya2luZ0NhbnZhc3x8KGEuX3dvcmtpbmdDYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxhLl93b3JraW5nQ29udGV4dD1hLl93b3JraW5nQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxhLl93b3JraW5nQ2FudmFzLndpZHRoPWEuX3dpZHRoLGEuX3dvcmtpbmdDYW52YXMuaGVpZ2h0PWEuX2hlaWdodCksYS5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGIsMCwwLGIudmlkZW9XaWR0aCxiLnZpZGVvSGVpZ2h0LDAsMCxhLl93aWR0aCxhLl9oZWlnaHQpLHRoaXMuX2dsLnRleEltYWdlMkQodGhpcy5fZ2wuVEVYVFVSRV8yRCwwLHRoaXMuX2dsLlJHQkEsdGhpcy5fZ2wuUkdCQSx0aGlzLl9nbC5VTlNJR05FRF9CWVRFLGEuX3dvcmtpbmdDYW52YXMpKTp0aGlzLl9nbC50ZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsMCx0aGlzLl9nbC5SR0JBLHRoaXMuX2dsLlJHQkEsdGhpcy5fZ2wuVU5TSUdORURfQllURSxiKSxhLmdlbmVyYXRlTWlwTWFwcyYmdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fZ2wuVEVYVFVSRV8yRCksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxudWxsKSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlPVtdLGEuaXNSZWFkeT0hMH0saC5wcm90b3R5cGUuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZT1mdW5jdGlvbihiLGQpe3ZhciBlPSExLGY9ITAsZz1hLlRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERTt2b2lkIDAhPT1kJiYoZT12b2lkIDA9PT1kLmdlbmVyYXRlTWlwTWFwcz9kOmQuZ2VuZXJhdGVNaXBtYXBzLGY9dm9pZCAwPT09ZC5nZW5lcmF0ZURlcHRoQnVmZmVyPyEwOmQuZ2VuZXJhdGVEZXB0aEJ1ZmZlcix2b2lkIDAhPT1kLnNhbXBsaW5nTW9kZSYmKGc9ZC5zYW1wbGluZ01vZGUpKTt2YXIgaD10aGlzLl9nbCxpPWguY3JlYXRlVGV4dHVyZSgpO2guYmluZFRleHR1cmUoaC5URVhUVVJFXzJELGkpO3ZhciBqPWIud2lkdGh8fGIsaz1iLmhlaWdodHx8YixsPWMoZyxlLGgpO2gudGV4UGFyYW1ldGVyaShoLlRFWFRVUkVfMkQsaC5URVhUVVJFX01BR19GSUxURVIsbC5tYWcpLGgudGV4UGFyYW1ldGVyaShoLlRFWFRVUkVfMkQsaC5URVhUVVJFX01JTl9GSUxURVIsbC5taW4pLGgudGV4UGFyYW1ldGVyaShoLlRFWFRVUkVfMkQsaC5URVhUVVJFX1dSQVBfUyxoLkNMQU1QX1RPX0VER0UpLGgudGV4UGFyYW1ldGVyaShoLlRFWFRVUkVfMkQsaC5URVhUVVJFX1dSQVBfVCxoLkNMQU1QX1RPX0VER0UpLGgudGV4SW1hZ2UyRChoLlRFWFRVUkVfMkQsMCxoLlJHQkEsaixrLDAsaC5SR0JBLGguVU5TSUdORURfQllURSxudWxsKTt2YXIgbTtmJiYobT1oLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGguYmluZFJlbmRlcmJ1ZmZlcihoLlJFTkRFUkJVRkZFUixtKSxoLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoaC5SRU5ERVJCVUZGRVIsaC5ERVBUSF9DT01QT05FTlQxNixqLGspKTt2YXIgbj1oLmNyZWF0ZUZyYW1lYnVmZmVyKCk7cmV0dXJuIGguYmluZEZyYW1lYnVmZmVyKGguRlJBTUVCVUZGRVIsbiksaC5mcmFtZWJ1ZmZlclRleHR1cmUyRChoLkZSQU1FQlVGRkVSLGguQ09MT1JfQVRUQUNITUVOVDAsaC5URVhUVVJFXzJELGksMCksZiYmaC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihoLkZSQU1FQlVGRkVSLGguREVQVEhfQVRUQUNITUVOVCxoLlJFTkRFUkJVRkZFUixtKSxoLmJpbmRUZXh0dXJlKGguVEVYVFVSRV8yRCxudWxsKSxoLmJpbmRSZW5kZXJidWZmZXIoaC5SRU5ERVJCVUZGRVIsbnVsbCksaC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixudWxsKSxpLl9mcmFtZWJ1ZmZlcj1uLGYmJihpLl9kZXB0aEJ1ZmZlcj1tKSxpLl93aWR0aD1qLGkuX2hlaWdodD1rLGkuaXNSZWFkeT0hMCxpLmdlbmVyYXRlTWlwTWFwcz1lLGkucmVmZXJlbmNlcz0xLHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sdGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZS5wdXNoKGkpLGl9LGgucHJvdG90eXBlLmNyZWF0ZUN1YmVUZXh0dXJlPWZ1bmN0aW9uKGIsYyxlLGcpe3ZhciBoPXRoaXMsaT10aGlzLl9nbCxqPWkuY3JlYXRlVGV4dHVyZSgpO2ouaXNDdWJlPSEwLGoudXJsPWIsai5yZWZlcmVuY2VzPTEsdGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZS5wdXNoKGopO3ZhciBrPWIuc3Vic3RyKGIubGVuZ3RoLTQsNCkudG9Mb3dlckNhc2UoKSxsPXRoaXMuZ2V0Q2FwcygpLnMzdGMmJlwiLmRkc1wiPT09aztyZXR1cm4gbD9hLlRvb2xzLkxvYWRGaWxlKGIsZnVuY3Rpb24oYil7dmFyIGM9YS5JbnRlcm5hbHMuRERTVG9vbHMuR2V0RERTSW5mbyhiKSxkPShjLmlzUkdCfHxjLmlzTHVtaW5hbmNlfHxjLm1pcG1hcENvdW50PjEpJiYhZztpLmJpbmRUZXh0dXJlKGkuVEVYVFVSRV9DVUJFX01BUCxqKSxpLnBpeGVsU3RvcmVpKGkuVU5QQUNLX0ZMSVBfWV9XRUJHTCwxKSxhLkludGVybmFscy5ERFNUb29scy5VcGxvYWRERFNMZXZlbHMoaC5fZ2wsaC5nZXRDYXBzKCkuczN0YyxiLGMsZCw2KSxnfHxjLmlzRm91ckNDfHwxIT1jLm1pcG1hcENvdW50fHxpLmdlbmVyYXRlTWlwbWFwKGkuVEVYVFVSRV9DVUJFX01BUCksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfTUFHX0ZJTFRFUixpLkxJTkVBUiksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixkP2kuTElORUFSX01JUE1BUF9MSU5FQVI6aS5MSU5FQVIpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX1dSQVBfUyxpLkNMQU1QX1RPX0VER0UpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX1dSQVBfVCxpLkNMQU1QX1RPX0VER0UpLGkuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLG51bGwpLGguX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sai5fd2lkdGg9Yy53aWR0aCxqLl9oZWlnaHQ9Yy5oZWlnaHQsai5pc1JlYWR5PSEwfSk6ZihiLDAsW10sYyxmdW5jdGlvbihhKXt2YXIgYj1kKGFbMF0ud2lkdGgsaC5fY2Fwcy5tYXhDdWJlbWFwVGV4dHVyZVNpemUpLGM9YjtoLl93b3JraW5nQ2FudmFzLndpZHRoPWIsaC5fd29ya2luZ0NhbnZhcy5oZWlnaHQ9Yzt2YXIgZT1baS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksaS5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osaS5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsaS5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksaS5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pdO2kuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLGopLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLDApO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKWguX3dvcmtpbmdDb250ZXh0LmRyYXdJbWFnZShhW2ZdLDAsMCxhW2ZdLndpZHRoLGFbZl0uaGVpZ2h0LDAsMCxiLGMpLGkudGV4SW1hZ2UyRChlW2ZdLDAsaS5SR0JBLGkuUkdCQSxpLlVOU0lHTkVEX0JZVEUsaC5fd29ya2luZ0NhbnZhcyk7Z3x8aS5nZW5lcmF0ZU1pcG1hcChpLlRFWFRVUkVfQ1VCRV9NQVApLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX01BR19GSUxURVIsaS5MSU5FQVIpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX01JTl9GSUxURVIsZz9pLkxJTkVBUjppLkxJTkVBUl9NSVBNQVBfTElORUFSKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFX0NVQkVfTUFQLGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFX0NVQkVfTUFQLGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKSxpLmJpbmRUZXh0dXJlKGkuVEVYVFVSRV9DVUJFX01BUCxudWxsKSxoLl9hY3RpdmVUZXh0dXJlc0NhY2hlPVtdLGouX3dpZHRoPWIsai5faGVpZ2h0PWMsai5pc1JlYWR5PSEwfSxlKSxqfSxoLnByb3RvdHlwZS5fcmVsZWFzZVRleHR1cmU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2w7YS5fZnJhbWVidWZmZXImJmIuZGVsZXRlRnJhbWVidWZmZXIoYS5fZnJhbWVidWZmZXIpLGEuX2RlcHRoQnVmZmVyJiZiLmRlbGV0ZVJlbmRlcmJ1ZmZlcihhLl9kZXB0aEJ1ZmZlciksYi5kZWxldGVUZXh0dXJlKGEpO2Zvcih2YXIgYz0wO2M8dGhpcy5fY2Fwcy5tYXhUZXh0dXJlc0ltYWdlVW5pdHM7YysrKXRoaXMuX2dsLmFjdGl2ZVRleHR1cmUodGhpcy5fZ2xbXCJURVhUVVJFXCIrY10pLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsbnVsbCksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCxudWxsKSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlW2NdPW51bGw7dmFyIGQ9dGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZS5pbmRleE9mKGEpOy0xIT09ZCYmdGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZS5zcGxpY2UoZCwxKX0saC5wcm90b3R5cGUuYmluZFNhbXBsZXJzPWZ1bmN0aW9uKGEpe3RoaXMuX2dsLnVzZVByb2dyYW0oYS5nZXRQcm9ncmFtKCkpO2Zvcih2YXIgYj1hLmdldFNhbXBsZXJzKCksYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1hLmdldFVuaWZvcm0oYltjXSk7dGhpcy5fZ2wudW5pZm9ybTFpKGQsYyl9dGhpcy5fY3VycmVudEVmZmVjdD1udWxsfSxoLnByb3RvdHlwZS5fYmluZFRleHR1cmU9ZnVuY3Rpb24oYSxiKXt0aGlzLl9nbC5hY3RpdmVUZXh0dXJlKHRoaXMuX2dsW1wiVEVYVFVSRVwiK2FdKSx0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELGIpLHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGVbYV09bnVsbH0saC5wcm90b3R5cGUuc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2Vzcz1mdW5jdGlvbihhLGIpe3RoaXMuX2JpbmRUZXh0dXJlKGEsYi5fdGV4dHVyZXMuZGF0YVtiLl9jdXJyZW50UmVuZGVyVGV4dHVyZUluZF0pfSxoLnByb3RvdHlwZS5zZXRUZXh0dXJlPWZ1bmN0aW9uKGIsYyl7aWYoISgwPmIpKXtpZighY3x8IWMuaXNSZWFkeSgpKXJldHVybiB2b2lkKG51bGwhPXRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGVbYl0mJih0aGlzLl9nbC5hY3RpdmVUZXh0dXJlKHRoaXMuX2dsW1wiVEVYVFVSRVwiK2JdKSx0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELG51bGwpLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCksdGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZVtiXT1udWxsKSk7aWYoYyBpbnN0YW5jZW9mIGEuVmlkZW9UZXh0dXJlKWMudXBkYXRlKCkmJih0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlW2JdPW51bGwpO2Vsc2UgaWYoYy5kZWxheUxvYWRTdGF0ZT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEKXJldHVybiB2b2lkIGMuZGVsYXlMb2FkKCk7aWYodGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZVtiXSE9Yyl7dGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZVtiXT1jO3ZhciBkPWMuZ2V0SW50ZXJuYWxUZXh0dXJlKCk7aWYodGhpcy5fZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLl9nbFtcIlRFWFRVUkVcIitiXSksZC5pc0N1YmUpe2lmKHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsZCksZC5fY2FjaGVkQ29vcmRpbmF0ZXNNb2RlIT09Yy5jb29yZGluYXRlc01vZGUpe2QuX2NhY2hlZENvb3JkaW5hdGVzTW9kZT1jLmNvb3JkaW5hdGVzTW9kZTt2YXIgZT1jLmNvb3JkaW5hdGVzTW9kZSE9PWEuVGV4dHVyZS5DVUJJQ19NT0RFJiZjLmNvb3JkaW5hdGVzTW9kZSE9PWEuVGV4dHVyZS5TS1lCT1hfTU9ERT90aGlzLl9nbC5SRVBFQVQ6dGhpcy5fZ2wuQ0xBTVBfVE9fRURHRTt0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsZSksdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFX0NVQkVfTUFQLHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9ULGUpfXRoaXMuX3NldEFuaXNvdHJvcGljTGV2ZWwodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCxjKX1lbHNle2lmKHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsZCksZC5fY2FjaGVkV3JhcFUhPT1jLndyYXBVKXN3aXRjaChkLl9jYWNoZWRXcmFwVT1jLndyYXBVLGMud3JhcFUpe2Nhc2UgYS5UZXh0dXJlLldSQVBfQUREUkVTU01PREU6dGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLHRoaXMuX2dsLlJFUEVBVCk7YnJlYWs7Y2FzZSBhLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU6dGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO2JyZWFrO2Nhc2UgYS5UZXh0dXJlLk1JUlJPUl9BRERSRVNTTU9ERTp0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsdGhpcy5fZ2wuTUlSUk9SRURfUkVQRUFUKX1pZihkLl9jYWNoZWRXcmFwViE9PWMud3JhcFYpc3dpdGNoKGQuX2NhY2hlZFdyYXBWPWMud3JhcFYsYy53cmFwVil7Y2FzZSBhLlRleHR1cmUuV1JBUF9BRERSRVNTTU9ERTp0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsdGhpcy5fZ2wuUkVQRUFUKTticmVhaztjYXNlIGEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERTp0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsdGhpcy5fZ2wuQ0xBTVBfVE9fRURHRSk7YnJlYWs7Y2FzZSBhLlRleHR1cmUuTUlSUk9SX0FERFJFU1NNT0RFOnRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCx0aGlzLl9nbC5NSVJST1JFRF9SRVBFQVQpXG59dGhpcy5fc2V0QW5pc290cm9waWNMZXZlbCh0aGlzLl9nbC5URVhUVVJFXzJELGMpfX19fSxoLnByb3RvdHlwZS5fc2V0QW5pc290cm9waWNMZXZlbD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX2NhcHMudGV4dHVyZUFuaXNvdHJvcGljRmlsdGVyRXh0ZW5zaW9uO2MmJmIuX2NhY2hlZEFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWwhPT1iLmFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWwmJih0aGlzLl9nbC50ZXhQYXJhbWV0ZXJmKGEsYy5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCxNYXRoLm1pbihiLmFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWwsdGhpcy5fY2Fwcy5tYXhBbmlzb3Ryb3B5KSksYi5fY2FjaGVkQW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbD1iLmFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWwpfSxoLnByb3RvdHlwZS5yZWFkUGl4ZWxzPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW5ldyBVaW50OEFycmF5KGQqYyo0KTtyZXR1cm4gdGhpcy5fZ2wucmVhZFBpeGVscygwLDAsYyxkLHRoaXMuX2dsLlJHQkEsdGhpcy5fZ2wuVU5TSUdORURfQllURSxlKSxlfSxoLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKHRoaXMuc3RvcFJlbmRlckxvb3AoKTt0aGlzLnNjZW5lcy5sZW5ndGg7KXRoaXMuc2NlbmVzWzBdLmRpc3Bvc2UoKTtmb3IodmFyIGEgaW4gdGhpcy5fY29tcGlsZWRFZmZlY3RzKXRoaXMuX2dsLmRlbGV0ZVByb2dyYW0odGhpcy5fY29tcGlsZWRFZmZlY3RzW2FdLl9wcm9ncmFtKTtmb3IodmFyIGIgaW4gdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzKWI+dGhpcy5fZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEfHwhdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzW2JdfHx0aGlzLl9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYik7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fb25CbHVyKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fb25Gb2N1cyksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIix0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1zZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsb2NrY2hhbmdlXCIsdGhpcy5fb25Qb2ludGVyTG9ja0NoYW5nZSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1zcG9pbnRlcmxvY2tjaGFuZ2VcIix0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW96cG9pbnRlcmxvY2tjaGFuZ2VcIix0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0cG9pbnRlcmxvY2tjaGFuZ2VcIix0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlKX0saC5pc1N1cHBvcnRlZD1mdW5jdGlvbigpe3RyeXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGI9YS5nZXRDb250ZXh0KFwid2ViZ2xcIil8fGEuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiKTtyZXR1cm4gbnVsbCE9YiYmISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0fWNhdGNoKGMpe3JldHVybiExfX0saC5fQUxQSEFfRElTQUJMRT0wLGguX0FMUEhBX0FERD0xLGguX0FMUEhBX0NPTUJJTkU9MixoLl9ERUxBWUxPQURTVEFURV9OT05FPTAsaC5fREVMQVlMT0FEU1RBVEVfTE9BREVEPTEsaC5fREVMQVlMT0FEU1RBVEVfTE9BRElORz0yLGguX0RFTEFZTE9BRFNUQVRFX05PVExPQURFRD00LGguRXBzaWxvbj0uMDAxLGguQ29sbGlzaW9uc0Vwc2lsb249LjAwMSxoLlNoYWRlcnNSZXBvc2l0b3J5PVwiQmFieWxvbi9TaGFkZXJzL1wiLGh9KCk7YS5FbmdpbmU9aH0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYil7dGhpcy5zdGF0ZT1cIlwiLHRoaXMuYW5pbWF0aW9ucz1uZXcgQXJyYXksdGhpcy5fY2hpbGRyZW5GbGFnPS0xLHRoaXMuX2lzRW5hYmxlZD0hMCx0aGlzLl9pc1JlYWR5PSEwLHRoaXMuX2N1cnJlbnRSZW5kZXJJZD0tMSx0aGlzLm5hbWU9YSx0aGlzLmlkPWEsdGhpcy5fc2NlbmU9Yix0aGlzLl9pbml0Q2FjaGUoKX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0U2NlbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NlbmV9LGIucHJvdG90eXBlLmdldEVuZ2luZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKX0sYi5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gYS5NYXRyaXguSWRlbnRpdHkoKX0sYi5wcm90b3R5cGUuX2luaXRDYWNoZT1mdW5jdGlvbigpe3RoaXMuX2NhY2hlPXt9LHRoaXMuX2NhY2hlLnBhcmVudD12b2lkIDB9LGIucHJvdG90eXBlLnVwZGF0ZUNhY2hlPWZ1bmN0aW9uKGEpeyhhfHwhdGhpcy5pc1N5bmNocm9uaXplZCgpKSYmKHRoaXMuX2NhY2hlLnBhcmVudD10aGlzLnBhcmVudCx0aGlzLl91cGRhdGVDYWNoZSgpKX0sYi5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlPWZ1bmN0aW9uKCl7fSxiLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sYi5wcm90b3R5cGUuaXNTeW5jaHJvbml6ZWRXaXRoUGFyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50Ll9jdXJyZW50UmVuZGVySWQ8PXRoaXMuX2N1cnJlbnRSZW5kZXJJZDohMH0sYi5wcm90b3R5cGUuaXNTeW5jaHJvbml6ZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5oYXNOZXdQYXJlbnQoKTtyZXR1cm4gYj1ifHwhdGhpcy5pc1N5bmNocm9uaXplZFdpdGhQYXJlbnQoKSxiPWJ8fCF0aGlzLl9pc1N5bmNocm9uaXplZCgpLGEmJnRoaXMudXBkYXRlQ2FjaGUoITApLCFifSxiLnByb3RvdHlwZS5oYXNOZXdQYXJlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2NhY2hlLnBhcmVudD09PXRoaXMucGFyZW50PyExOihhJiYodGhpcy5fY2FjaGUucGFyZW50PXRoaXMucGFyZW50KSwhMCl9LGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNSZWFkeX0sYi5wcm90b3R5cGUuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRW5hYmxlZD90aGlzLnBhcmVudD90aGlzLnBhcmVudC5pc0VuYWJsZWQoKTohMDohMX0sYi5wcm90b3R5cGUuc2V0RW5hYmxlZD1mdW5jdGlvbihhKXt0aGlzLl9pc0VuYWJsZWQ9YX0sYi5wcm90b3R5cGUuaXNEZXNjZW5kYW50T2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50PT09YT8hMDp0aGlzLnBhcmVudC5pc0Rlc2NlbmRhbnRPZihhKTohMX0sYi5wcm90b3R5cGUuX2dldERlc2NlbmRhbnRzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107ZC5pc0Rlc2NlbmRhbnRPZih0aGlzKSYmYi5wdXNoKGQpfX0sYi5wcm90b3R5cGUuZ2V0RGVzY2VuZGFudHM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5fZ2V0RGVzY2VuZGFudHModGhpcy5fc2NlbmUubWVzaGVzLGEpLHRoaXMuX2dldERlc2NlbmRhbnRzKHRoaXMuX3NjZW5lLmxpZ2h0cyxhKSx0aGlzLl9nZXREZXNjZW5kYW50cyh0aGlzLl9zY2VuZS5jYW1lcmFzLGEpLGF9LGIucHJvdG90eXBlLl9zZXRSZWFkeT1mdW5jdGlvbihhKXtpZihhIT10aGlzLl9pc1JlYWR5KXtpZighYSlyZXR1cm4gdm9pZCh0aGlzLl9pc1JlYWR5PSExKTt0aGlzLl9pc1JlYWR5PSEwLHRoaXMub25SZWFkeSYmdGhpcy5vblJlYWR5KHRoaXMpfX0sYn0oKTthLk5vZGU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyl7dGhpcy5taW5pbXVtPWIsdGhpcy5tYXhpbXVtPWMsdGhpcy5fdGVtcFJhZGl1c1ZlY3Rvcj1hLlZlY3RvcjMuWmVybygpO3ZhciBkPWEuVmVjdG9yMy5EaXN0YW5jZShiLGMpO3RoaXMuY2VudGVyPWEuVmVjdG9yMy5MZXJwKGIsYywuNSksdGhpcy5yYWRpdXM9LjUqZCx0aGlzLmNlbnRlcldvcmxkPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdXBkYXRlKGEuTWF0cml4LklkZW50aXR5KCkpfXJldHVybiBiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGIpe2EuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMuY2VudGVyLGIsdGhpcy5jZW50ZXJXb3JsZCksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbEZyb21GbG9hdHNUb1JlZigxLDEsMSxiLHRoaXMuX3RlbXBSYWRpdXNWZWN0b3IpLHRoaXMucmFkaXVzV29ybGQ9TWF0aC5tYXgoTWF0aC5hYnModGhpcy5fdGVtcFJhZGl1c1ZlY3Rvci54KSxNYXRoLmFicyh0aGlzLl90ZW1wUmFkaXVzVmVjdG9yLnkpLE1hdGguYWJzKHRoaXMuX3RlbXBSYWRpdXNWZWN0b3IueikpKnRoaXMucmFkaXVzfSxiLnByb3RvdHlwZS5pc0luRnJ1c3R1bT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDs2PmI7YisrKWlmKGFbYl0uZG90Q29vcmRpbmF0ZSh0aGlzLmNlbnRlcldvcmxkKTw9LXRoaXMucmFkaXVzV29ybGQpcmV0dXJuITE7cmV0dXJuITB9LGIucHJvdG90eXBlLmludGVyc2VjdHNQb2ludD1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmNlbnRlcldvcmxkLngtYi54LGQ9dGhpcy5jZW50ZXJXb3JsZC55LWIueSxlPXRoaXMuY2VudGVyV29ybGQuei1iLnosZj1NYXRoLnNxcnQoYypjK2QqZCtlKmUpO3JldHVybiBNYXRoLmFicyh0aGlzLnJhZGl1c1dvcmxkLWYpPGEuRW5naW5lLkVwc2lsb24/ITE6ITB9LGIuSW50ZXJzZWN0cz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuY2VudGVyV29ybGQueC1iLmNlbnRlcldvcmxkLngsZD1hLmNlbnRlcldvcmxkLnktYi5jZW50ZXJXb3JsZC55LGU9YS5jZW50ZXJXb3JsZC56LWIuY2VudGVyV29ybGQueixmPU1hdGguc3FydChjKmMrZCpkK2UqZSk7cmV0dXJuIGEucmFkaXVzV29ybGQrYi5yYWRpdXNXb3JsZDxmPyExOiEwfSxifSgpO2EuQm91bmRpbmdTcGhlcmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyl7dGhpcy5taW5pbXVtPWIsdGhpcy5tYXhpbXVtPWMsdGhpcy52ZWN0b3JzPW5ldyBBcnJheSx0aGlzLnZlY3RvcnNXb3JsZD1uZXcgQXJyYXksdGhpcy52ZWN0b3JzLnB1c2godGhpcy5taW5pbXVtLmNsb25lKCkpLHRoaXMudmVjdG9ycy5wdXNoKHRoaXMubWF4aW11bS5jbG9uZSgpKSx0aGlzLnZlY3RvcnMucHVzaCh0aGlzLm1pbmltdW0uY2xvbmUoKSksdGhpcy52ZWN0b3JzWzJdLng9dGhpcy5tYXhpbXVtLngsdGhpcy52ZWN0b3JzLnB1c2godGhpcy5taW5pbXVtLmNsb25lKCkpLHRoaXMudmVjdG9yc1szXS55PXRoaXMubWF4aW11bS55LHRoaXMudmVjdG9ycy5wdXNoKHRoaXMubWluaW11bS5jbG9uZSgpKSx0aGlzLnZlY3RvcnNbNF0uej10aGlzLm1heGltdW0ueix0aGlzLnZlY3RvcnMucHVzaCh0aGlzLm1heGltdW0uY2xvbmUoKSksdGhpcy52ZWN0b3JzWzVdLno9dGhpcy5taW5pbXVtLnosdGhpcy52ZWN0b3JzLnB1c2godGhpcy5tYXhpbXVtLmNsb25lKCkpLHRoaXMudmVjdG9yc1s2XS54PXRoaXMubWluaW11bS54LHRoaXMudmVjdG9ycy5wdXNoKHRoaXMubWF4aW11bS5jbG9uZSgpKSx0aGlzLnZlY3RvcnNbN10ueT10aGlzLm1pbmltdW0ueSx0aGlzLmNlbnRlcj10aGlzLm1heGltdW0uYWRkKHRoaXMubWluaW11bSkuc2NhbGUoLjUpLHRoaXMuZXh0ZW5kcz10aGlzLm1heGltdW0uc3VidHJhY3QodGhpcy5taW5pbXVtKS5zY2FsZSguNSksdGhpcy5kaXJlY3Rpb25zPVthLlZlY3RvcjMuWmVybygpLGEuVmVjdG9yMy5aZXJvKCksYS5WZWN0b3IzLlplcm8oKV07Zm9yKHZhciBkPTA7ZDx0aGlzLnZlY3RvcnMubGVuZ3RoO2QrKyl0aGlzLnZlY3RvcnNXb3JsZFtkXT1hLlZlY3RvcjMuWmVybygpO3RoaXMubWluaW11bVdvcmxkPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5tYXhpbXVtV29ybGQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl91cGRhdGUoYS5NYXRyaXguSWRlbnRpdHkoKSl9cmV0dXJuIGIucHJvdG90eXBlLmdldFdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dvcmxkTWF0cml4fSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGIpe2EuVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsdGhpcy5taW5pbXVtV29ybGQpLGEuVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsdGhpcy5tYXhpbXVtV29ybGQpO2Zvcih2YXIgYz0wO2M8dGhpcy52ZWN0b3JzLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMudmVjdG9yc1dvcmxkW2NdO2EuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMudmVjdG9yc1tjXSxiLGQpLGQueDx0aGlzLm1pbmltdW1Xb3JsZC54JiYodGhpcy5taW5pbXVtV29ybGQueD1kLngpLGQueTx0aGlzLm1pbmltdW1Xb3JsZC55JiYodGhpcy5taW5pbXVtV29ybGQueT1kLnkpLGQuejx0aGlzLm1pbmltdW1Xb3JsZC56JiYodGhpcy5taW5pbXVtV29ybGQuej1kLnopLGQueD50aGlzLm1heGltdW1Xb3JsZC54JiYodGhpcy5tYXhpbXVtV29ybGQueD1kLngpLGQueT50aGlzLm1heGltdW1Xb3JsZC55JiYodGhpcy5tYXhpbXVtV29ybGQueT1kLnkpLGQuej50aGlzLm1heGltdW1Xb3JsZC56JiYodGhpcy5tYXhpbXVtV29ybGQuej1kLnopfXRoaXMubWF4aW11bVdvcmxkLmFkZFRvUmVmKHRoaXMubWluaW11bVdvcmxkLHRoaXMuY2VudGVyKSx0aGlzLmNlbnRlci5zY2FsZUluUGxhY2UoLjUpLGEuVmVjdG9yMy5Gcm9tRmxvYXRBcnJheVRvUmVmKGIubSwwLHRoaXMuZGlyZWN0aW9uc1swXSksYS5WZWN0b3IzLkZyb21GbG9hdEFycmF5VG9SZWYoYi5tLDQsdGhpcy5kaXJlY3Rpb25zWzFdKSxhLlZlY3RvcjMuRnJvbUZsb2F0QXJyYXlUb1JlZihiLm0sOCx0aGlzLmRpcmVjdGlvbnNbMl0pLHRoaXMuX3dvcmxkTWF0cml4PWJ9LGIucHJvdG90eXBlLmlzSW5GcnVzdHVtPWZ1bmN0aW9uKGEpe3JldHVybiBiLklzSW5GcnVzdHVtKHRoaXMudmVjdG9yc1dvcmxkLGEpfSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzUG9pbnQ9ZnVuY3Rpb24oYil7dmFyIGM9YS5FbmdpbmUuRXBzaWxvbjtyZXR1cm4gdGhpcy5tYXhpbXVtV29ybGQueC1iLng8Y3x8Yz5iLngtdGhpcy5taW5pbXVtV29ybGQueD8hMTp0aGlzLm1heGltdW1Xb3JsZC55LWIueTxjfHxjPmIueS10aGlzLm1pbmltdW1Xb3JsZC55PyExOnRoaXMubWF4aW11bVdvcmxkLnotYi56PGN8fGM+Yi56LXRoaXMubWluaW11bVdvcmxkLno/ITE6ITB9LGIucHJvdG90eXBlLmludGVyc2VjdHNTcGhlcmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGIuSW50ZXJzZWN0c1NwaGVyZSh0aGlzLm1pbmltdW1Xb3JsZCx0aGlzLm1heGltdW1Xb3JsZCxhLmNlbnRlcldvcmxkLGEucmFkaXVzV29ybGQpfSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzTWluTWF4PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMubWF4aW11bVdvcmxkLng8YS54fHx0aGlzLm1pbmltdW1Xb3JsZC54PmIueD8hMTp0aGlzLm1heGltdW1Xb3JsZC55PGEueXx8dGhpcy5taW5pbXVtV29ybGQueT5iLnk/ITE6dGhpcy5tYXhpbXVtV29ybGQuejxhLnp8fHRoaXMubWluaW11bVdvcmxkLno+Yi56PyExOiEwfSxiLkludGVyc2VjdHM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5tYXhpbXVtV29ybGQueDxiLm1pbmltdW1Xb3JsZC54fHxhLm1pbmltdW1Xb3JsZC54PmIubWF4aW11bVdvcmxkLng/ITE6YS5tYXhpbXVtV29ybGQueTxiLm1pbmltdW1Xb3JsZC55fHxhLm1pbmltdW1Xb3JsZC55PmIubWF4aW11bVdvcmxkLnk/ITE6YS5tYXhpbXVtV29ybGQuejxiLm1pbmltdW1Xb3JsZC56fHxhLm1pbmltdW1Xb3JsZC56PmIubWF4aW11bVdvcmxkLno/ITE6ITB9LGIuSW50ZXJzZWN0c1NwaGVyZT1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1hLlZlY3RvcjMuQ2xhbXAoZCxiLGMpLGc9YS5WZWN0b3IzLkRpc3RhbmNlU3F1YXJlZChkLGYpO3JldHVybiBlKmU+PWd9LGIuSXNJbkZydXN0dW09ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDs2PmM7YysrKXtmb3IodmFyIGQ9OCxlPTA7OD5lJiZiW2NdLmRvdENvb3JkaW5hdGUoYVtlXSk8MDtlKyspLS1kO2lmKDA9PWQpcmV0dXJuITF9cmV0dXJuITB9LGJ9KCk7YS5Cb3VuZGluZ0JveD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiLGMpe3ZhciBkPWEuVmVjdG9yMy5Eb3QoYy5jZW50ZXIsYiksZT1NYXRoLmFicyhhLlZlY3RvcjMuRG90KGMuZGlyZWN0aW9uc1swXSxiKSkqYy5leHRlbmRzLngsZj1NYXRoLmFicyhhLlZlY3RvcjMuRG90KGMuZGlyZWN0aW9uc1sxXSxiKSkqYy5leHRlbmRzLnksZz1NYXRoLmFicyhhLlZlY3RvcjMuRG90KGMuZGlyZWN0aW9uc1syXSxiKSkqYy5leHRlbmRzLnosaD1lK2YrZztyZXR1cm57bWluOmQtaCxtYXg6ZCtofX0sYz1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4hKGE+ZHx8Yz5iKX0sZD1mdW5jdGlvbihhLGQsZSl7dmFyIGY9YihhLGQpLGc9YihhLGUpO3JldHVybiBjKGYubWluLGYubWF4LGcubWluLGcubWF4KX0sZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLm1pbmltdW09Yix0aGlzLm1heGltdW09Yyx0aGlzLmJvdW5kaW5nQm94PW5ldyBhLkJvdW5kaW5nQm94KGIsYyksdGhpcy5ib3VuZGluZ1NwaGVyZT1uZXcgYS5Cb3VuZGluZ1NwaGVyZShiLGMpfXJldHVybiBiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMuYm91bmRpbmdCb3guX3VwZGF0ZShhKSx0aGlzLmJvdW5kaW5nU3BoZXJlLl91cGRhdGUoYSl9LGIucHJvdG90eXBlLmlzSW5GcnVzdHVtPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmJvdW5kaW5nU3BoZXJlLmlzSW5GcnVzdHVtKGEpP3RoaXMuYm91bmRpbmdCb3guaXNJbkZydXN0dW0oYSk6ITF9LGIucHJvdG90eXBlLl9jaGVja0NvbGxpc2lvbj1mdW5jdGlvbihhKXtyZXR1cm4gYS5fY2FuRG9Db2xsaXNpb24odGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXJXb3JsZCx0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1c1dvcmxkLHRoaXMuYm91bmRpbmdCb3gubWluaW11bVdvcmxkLHRoaXMuYm91bmRpbmdCb3gubWF4aW11bVdvcmxkKX0sYi5wcm90b3R5cGUuaW50ZXJzZWN0c1BvaW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcldvcmxkJiZ0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNQb2ludChhKSYmdGhpcy5ib3VuZGluZ0JveC5pbnRlcnNlY3RzUG9pbnQoYSk/ITA6ITF9LGIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYixjKXtpZighdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXJXb3JsZHx8IWIuYm91bmRpbmdTcGhlcmUuY2VudGVyV29ybGQpcmV0dXJuITE7aWYoIWEuQm91bmRpbmdTcGhlcmUuSW50ZXJzZWN0cyh0aGlzLmJvdW5kaW5nU3BoZXJlLGIuYm91bmRpbmdTcGhlcmUpKXJldHVybiExO2lmKCFhLkJvdW5kaW5nQm94LkludGVyc2VjdHModGhpcy5ib3VuZGluZ0JveCxiLmJvdW5kaW5nQm94KSlyZXR1cm4hMTtpZighYylyZXR1cm4hMDt2YXIgZT10aGlzLmJvdW5kaW5nQm94LGY9Yi5ib3VuZGluZ0JveDtyZXR1cm4gZChlLmRpcmVjdGlvbnNbMF0sZSxmKSYmZChlLmRpcmVjdGlvbnNbMV0sZSxmKSYmZChlLmRpcmVjdGlvbnNbMl0sZSxmKSYmZChmLmRpcmVjdGlvbnNbMF0sZSxmKSYmZChmLmRpcmVjdGlvbnNbMV0sZSxmKSYmZChmLmRpcmVjdGlvbnNbMl0sZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzBdLGYuZGlyZWN0aW9uc1swXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzBdLGYuZGlyZWN0aW9uc1sxXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzBdLGYuZGlyZWN0aW9uc1syXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzFdLGYuZGlyZWN0aW9uc1swXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzFdLGYuZGlyZWN0aW9uc1sxXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzFdLGYuZGlyZWN0aW9uc1syXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzJdLGYuZGlyZWN0aW9uc1swXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzJdLGYuZGlyZWN0aW9uc1sxXSksZSxmKSYmZChhLlZlY3RvcjMuQ3Jvc3MoZS5kaXJlY3Rpb25zWzJdLGYuZGlyZWN0aW9uc1syXSksZSxmKT8hMDohMX0sYn0oKTthLkJvdW5kaW5nSW5mbz1lfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe2IuY2FsbCh0aGlzLGMsZCksdGhpcy5kaWZmdXNlPW5ldyBhLkNvbG9yMygxLDEsMSksdGhpcy5zcGVjdWxhcj1uZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMuaW50ZW5zaXR5PTEsdGhpcy5yYW5nZT1OdW1iZXIuTUFYX1ZBTFVFLHRoaXMuZXhjbHVkZWRNZXNoZXM9bmV3IEFycmF5LHRoaXMuX2V4Y2x1ZGVkTWVzaGVzSWRzPW5ldyBBcnJheSxkLmxpZ2h0cy5wdXNoKHRoaXMpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5nZXRTaGFkb3dHZW5lcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2hhZG93R2VuZXJhdG9yfSxjLnByb3RvdHlwZS50cmFuc2ZlclRvRWZmZWN0PWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5fZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gYS5NYXRyaXguSWRlbnRpdHkoKX0sYy5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXt0aGlzLl9jdXJyZW50UmVuZGVySWQ9dGhpcy5nZXRTY2VuZSgpLmdldFJlbmRlcklkKCk7dmFyIGI9dGhpcy5fZ2V0V29ybGRNYXRyaXgoKTtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4Pyh0aGlzLl9wYXJlbnRlZFdvcmxkTWF0cml4fHwodGhpcy5fcGFyZW50ZWRXb3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSxiLm11bHRpcGx5VG9SZWYodGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKSx0aGlzLl9wYXJlbnRlZFdvcmxkTWF0cml4KSx0aGlzLl9wYXJlbnRlZFdvcmxkTWF0cml4KTpifSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fc2hhZG93R2VuZXJhdG9yJiYodGhpcy5fc2hhZG93R2VuZXJhdG9yLmRpc3Bvc2UoKSx0aGlzLl9zaGFkb3dHZW5lcmF0b3I9bnVsbCk7dmFyIGE9dGhpcy5nZXRTY2VuZSgpLmxpZ2h0cy5pbmRleE9mKHRoaXMpO3RoaXMuZ2V0U2NlbmUoKS5saWdodHMuc3BsaWNlKGEsMSl9LGN9KGEuTm9kZSk7YS5MaWdodD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCl7Yi5jYWxsKHRoaXMsYSxkKSx0aGlzLnBvc2l0aW9uPWN9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLnRyYW5zZmVyVG9FZmZlY3Q9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4Pyh0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9ufHwodGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpKSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZih0aGlzLnBvc2l0aW9uLHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCksdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbiksdm9pZCBiLnNldEZsb2F0NChjLHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb24ueCx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uLnksdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbi56LDApKTp2b2lkIGIuc2V0RmxvYXQ0KGMsdGhpcy5wb3NpdGlvbi54LHRoaXMucG9zaXRpb24ueSx0aGlzLnBvc2l0aW9uLnosMCl9LGMucHJvdG90eXBlLmdldFNoYWRvd0dlbmVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxjLnByb3RvdHlwZS5fZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh8fCh0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSxhLk1hdHJpeC5UcmFuc2xhdGlvblRvUmVmKHRoaXMucG9zaXRpb24ueCx0aGlzLnBvc2l0aW9uLnksdGhpcy5wb3NpdGlvbi56LHRoaXMuX3dvcmxkTWF0cml4KSx0aGlzLl93b3JsZE1hdHJpeH0sY30oYS5MaWdodCk7YS5Qb2ludExpZ2h0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZixnKXtiLmNhbGwodGhpcyxhLGcpLHRoaXMucG9zaXRpb249Yyx0aGlzLmRpcmVjdGlvbj1kLHRoaXMuYW5nbGU9ZSx0aGlzLmV4cG9uZW50PWZ9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLnNldERpcmVjdGlvblRvVGFyZ2V0PWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmRpcmVjdGlvbj1hLlZlY3RvcjMuTm9ybWFsaXplKGIuc3VidHJhY3QodGhpcy5wb3NpdGlvbikpLHRoaXMuZGlyZWN0aW9ufSxjLnByb3RvdHlwZS50cmFuc2ZlclRvRWZmZWN0PWZ1bmN0aW9uKGIsYyxkKXt2YXIgZTtpZih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgpe3RoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9ufHwodGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSksdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbnx8KHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSk7dmFyIGY9dGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKTthLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZih0aGlzLnBvc2l0aW9uLGYsdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbiksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKHRoaXMuZGlyZWN0aW9uLGYsdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24pLGIuc2V0RmxvYXQ0KGMsdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbi54LHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb24ueSx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uLnosdGhpcy5leHBvbmVudCksZT1hLlZlY3RvcjMuTm9ybWFsaXplKHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKX1lbHNlIGIuc2V0RmxvYXQ0KGMsdGhpcy5wb3NpdGlvbi54LHRoaXMucG9zaXRpb24ueSx0aGlzLnBvc2l0aW9uLnosdGhpcy5leHBvbmVudCksZT1hLlZlY3RvcjMuTm9ybWFsaXplKHRoaXMuZGlyZWN0aW9uKTtiLnNldEZsb2F0NChkLGUueCxlLnksZS56LE1hdGguY29zKC41KnRoaXMuYW5nbGUpKX0sYy5wcm90b3R5cGUuX2dldFdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dvcmxkTWF0cml4fHwodGhpcy5fd29ybGRNYXRyaXg9YS5NYXRyaXguSWRlbnRpdHkoKSksYS5NYXRyaXguVHJhbnNsYXRpb25Ub1JlZih0aGlzLnBvc2l0aW9uLngsdGhpcy5wb3NpdGlvbi55LHRoaXMucG9zaXRpb24ueix0aGlzLl93b3JsZE1hdHJpeCksdGhpcy5fd29ybGRNYXRyaXh9LGN9KGEuTGlnaHQpO2EuU3BvdExpZ2h0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkKXtiLmNhbGwodGhpcyxhLGQpLHRoaXMuZGlyZWN0aW9uPWMsdGhpcy5wb3NpdGlvbj1jLnNjYWxlKC0xKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuc2V0RGlyZWN0aW9uVG9UYXJnZXQ9ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMuZGlyZWN0aW9uPWEuVmVjdG9yMy5Ob3JtYWxpemUoYi5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKSksdGhpcy5kaXJlY3Rpb259LGMucHJvdG90eXBlLl9jb21wdXRlVHJhbnNmb3JtZWRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXg/KHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb258fCh0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCkpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMucG9zaXRpb24sdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKSx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uKSwhMCk6ITF9LGMucHJvdG90eXBlLnRyYW5zZmVyVG9FZmZlY3Q9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4Pyh0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbnx8KHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uPWEuVmVjdG9yMy5aZXJvKCkpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxUb1JlZih0aGlzLmRpcmVjdGlvbix0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKSx2b2lkIGIuc2V0RmxvYXQ0KGMsdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24ueCx0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbi55LHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uLnosMSkpOnZvaWQgYi5zZXRGbG9hdDQoYyx0aGlzLmRpcmVjdGlvbi54LHRoaXMuZGlyZWN0aW9uLnksdGhpcy5kaXJlY3Rpb24ueiwxKX0sYy5wcm90b3R5cGUuX2dldFdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dvcmxkTWF0cml4fHwodGhpcy5fd29ybGRNYXRyaXg9YS5NYXRyaXguSWRlbnRpdHkoKSksYS5NYXRyaXguVHJhbnNsYXRpb25Ub1JlZih0aGlzLnBvc2l0aW9uLngsdGhpcy5wb3NpdGlvbi55LHRoaXMucG9zaXRpb24ueix0aGlzLl93b3JsZE1hdHJpeCksdGhpcy5fd29ybGRNYXRyaXh9LGN9KGEuTGlnaHQpO2EuRGlyZWN0aW9uYWxMaWdodD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYyxkKXt2YXIgZT10aGlzO3RoaXMuZmlsdGVyPWIuRklMVEVSX1ZBUklBTkNFU0hBRE9XTUFQLHRoaXMuX2RhcmtuZXNzPTAsdGhpcy5fdHJhbnNwYXJlbmN5U2hhZG93PSExLHRoaXMuX3ZpZXdNYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3RyYW5zZm9ybU1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fd29ybGRWaWV3UHJvamVjdGlvbj1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbGlnaHQ9ZCx0aGlzLl9zY2VuZT1kLmdldFNjZW5lKCksZC5fc2hhZG93R2VuZXJhdG9yPXRoaXMsdGhpcy5fc2hhZG93TWFwPW5ldyBhLlJlbmRlclRhcmdldFRleHR1cmUoZC5uYW1lK1wiX3NoYWRvd01hcFwiLGMsdGhpcy5fc2NlbmUsITEpLHRoaXMuX3NoYWRvd01hcC53cmFwVT1hLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREUsdGhpcy5fc2hhZG93TWFwLndyYXBWPWEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERSx0aGlzLl9zaGFkb3dNYXAucmVuZGVyUGFydGljbGVzPSExO3ZhciBmPWZ1bmN0aW9uKGIpe3ZhciBjPWIuZ2V0UmVuZGVyaW5nTWVzaCgpLGQ9ZS5fc2NlbmUsZj1kLmdldEVuZ2luZSgpO2Yuc2V0U3RhdGUoYi5nZXRNYXRlcmlhbCgpLmJhY2tGYWNlQ3VsbGluZyk7dmFyIGc9Yy5fZ2V0SW5zdGFuY2VzUmVuZGVyTGlzdChiLl9pZCk7aWYoIWcubXVzdFJldHVybil7dmFyIGg9bnVsbCE9PWYuZ2V0Q2FwcygpLmluc3RhbmNlZEFycmF5cyYmbnVsbCE9PWcudmlzaWJsZUluc3RhbmNlcztpZihlLmlzUmVhZHkoYixoKSl7Zi5lbmFibGVFZmZlY3QoZS5fZWZmZWN0KSxjLl9iaW5kKGIsZS5fZWZmZWN0LCExKTt2YXIgaT1iLmdldE1hdGVyaWFsKCk7aWYoZS5fZWZmZWN0LnNldE1hdHJpeChcInZpZXdQcm9qZWN0aW9uXCIsZS5nZXRUcmFuc2Zvcm1NYXRyaXgoKSksaSYmaS5uZWVkQWxwaGFUZXN0aW5nKCkpe3ZhciBqPWkuZ2V0QWxwaGFUZXN0VGV4dHVyZSgpO2UuX2VmZmVjdC5zZXRUZXh0dXJlKFwiZGlmZnVzZVNhbXBsZXJcIixqKSxlLl9lZmZlY3Quc2V0TWF0cml4KFwiZGlmZnVzZU1hdHJpeFwiLGouZ2V0VGV4dHVyZU1hdHJpeCgpKX12YXIgaz1jLnNrZWxldG9uJiZjLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSYmYy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCk7aWYoayYmZS5fZWZmZWN0LnNldE1hdHJpY2VzKFwibUJvbmVzXCIsYy5za2VsZXRvbi5nZXRUcmFuc2Zvcm1NYXRyaWNlcygpKSxoKWMuX3JlbmRlcldpdGhJbnN0YW5jZXMoYiwhMSxnLGUuX2VmZmVjdCxmKTtlbHNlIGlmKGcucmVuZGVyU2VsZltiLl9pZF0mJihlLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRcIixjLmdldFdvcmxkTWF0cml4KCkpLGMuX2RyYXcoYiwhMCkpLGcudmlzaWJsZUluc3RhbmNlc1tiLl9pZF0pZm9yKHZhciBsPTA7bDxnLnZpc2libGVJbnN0YW5jZXNbYi5faWRdLmxlbmd0aDtsKyspe3ZhciBtPWcudmlzaWJsZUluc3RhbmNlc1tiLl9pZF1bbF07ZS5fZWZmZWN0LnNldE1hdHJpeChcIndvcmxkXCIsbS5nZXRXb3JsZE1hdHJpeCgpKSxjLl9kcmF3KGIsITApfX1lbHNlIGUuX3NoYWRvd01hcC5yZXNldFJlZnJlc2hDb3VudGVyKCl9fTt0aGlzLl9zaGFkb3dNYXAuY3VzdG9tUmVuZGVyRnVuY3Rpb249ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2ZvcihkPTA7ZDxhLmxlbmd0aDtkKyspZihhLmRhdGFbZF0pO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspZihiLmRhdGFbZF0pO2lmKGUuX3RyYW5zcGFyZW5jeVNoYWRvdylmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWYoYy5kYXRhW2RdKX19cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiRklMVEVSX05PTkVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0ZJTFRFUl9OT05FfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiRklMVEVSX1ZBUklBTkNFU0hBRE9XTUFQXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9GSUxURVJfVkFSSUFOQ0VTSEFET1dNQVB9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJGSUxURVJfUE9JU1NPTlNBTVBMSU5HXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9GSUxURVJfUE9JU1NPTlNBTVBMSU5HfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcInVzZVZhcmlhbmNlU2hhZG93TWFwXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbHRlcj09PWIuRklMVEVSX1ZBUklBTkNFU0hBRE9XTUFQfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5maWx0ZXI9YT9iLkZJTFRFUl9WQVJJQU5DRVNIQURPV01BUDpiLkZJTFRFUl9OT05FfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcInVzZVBvaXNzb25TYW1wbGluZ1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maWx0ZXI9PT1iLkZJTFRFUl9QT0lTU09OU0FNUExJTkd9LHNldDpmdW5jdGlvbihhKXt0aGlzLmZpbHRlcj1hP2IuRklMVEVSX1BPSVNTT05TQU1QTElORzpiLkZJTFRFUl9OT05FfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oYixjKXt2YXIgZD1bXTt0aGlzLnVzZVZhcmlhbmNlU2hhZG93TWFwJiZkLnB1c2goXCIjZGVmaW5lIFZTTVwiKTt2YXIgZT1bYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kXSxmPWIuZ2V0TWVzaCgpLGc9Yi5nZXRNYXRlcmlhbCgpO2cmJmcubmVlZEFscGhhVGVzdGluZygpJiYoZC5wdXNoKFwiI2RlZmluZSBBTFBIQVRFU1RcIiksZi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSYmKGUucHVzaChhLlZlcnRleEJ1ZmZlci5VVktpbmQpLGQucHVzaChcIiNkZWZpbmUgVVYxXCIpKSxmLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSYmKGUucHVzaChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSxkLnB1c2goXCIjZGVmaW5lIFVWMlwiKSkpLGYuc2tlbGV0b24mJmYuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpJiZmLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSYmKGUucHVzaChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSxlLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCksZC5wdXNoKFwiI2RlZmluZSBCT05FU1wiKSxkLnB1c2goXCIjZGVmaW5lIEJvbmVzUGVyTWVzaCBcIisoZi5za2VsZXRvbi5ib25lcy5sZW5ndGgrMSkpKSxjJiYoZC5wdXNoKFwiI2RlZmluZSBJTlNUQU5DRVNcIiksZS5wdXNoKFwid29ybGQwXCIpLGUucHVzaChcIndvcmxkMVwiKSxlLnB1c2goXCJ3b3JsZDJcIiksZS5wdXNoKFwid29ybGQzXCIpKTt2YXIgaD1kLmpvaW4oXCJcXG5cIik7cmV0dXJuIHRoaXMuX2NhY2hlZERlZmluZXMhPWgmJih0aGlzLl9jYWNoZWREZWZpbmVzPWgsdGhpcy5fZWZmZWN0PXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmNyZWF0ZUVmZmVjdChcInNoYWRvd01hcFwiLGUsW1wid29ybGRcIixcIm1Cb25lc1wiLFwidmlld1Byb2plY3Rpb25cIixcImRpZmZ1c2VNYXRyaXhcIl0sW1wiZGlmZnVzZVNhbXBsZXJcIl0saCkpLHRoaXMuX2VmZmVjdC5pc1JlYWR5KCl9LGIucHJvdG90eXBlLmdldFNoYWRvd01hcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaGFkb3dNYXB9LGIucHJvdG90eXBlLmdldExpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xpZ2h0fSxiLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1NYXRyaXg9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl9saWdodC5wb3NpdGlvbixjPXRoaXMuX2xpZ2h0LmRpcmVjdGlvbjtpZih0aGlzLl9saWdodC5fY29tcHV0ZVRyYW5zZm9ybWVkUG9zaXRpb24oKSYmKGI9dGhpcy5fbGlnaHQuX3RyYW5zZm9ybWVkUG9zaXRpb24pLCEodGhpcy5fY2FjaGVkUG9zaXRpb24mJnRoaXMuX2NhY2hlZERpcmVjdGlvbiYmYi5lcXVhbHModGhpcy5fY2FjaGVkUG9zaXRpb24pJiZjLmVxdWFscyh0aGlzLl9jYWNoZWREaXJlY3Rpb24pKSl7dGhpcy5fY2FjaGVkUG9zaXRpb249Yi5jbG9uZSgpLHRoaXMuX2NhY2hlZERpcmVjdGlvbj1jLmNsb25lKCk7dmFyIGQ9dGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhO2EuTWF0cml4Lkxvb2tBdExIVG9SZWYoYix0aGlzLl9saWdodC5wb3NpdGlvbi5hZGQoYyksYS5WZWN0b3IzLlVwKCksdGhpcy5fdmlld01hdHJpeCksYS5NYXRyaXguUGVyc3BlY3RpdmVGb3ZMSFRvUmVmKE1hdGguUEkvMiwxLGQubWluWixkLm1heFosdGhpcy5fcHJvamVjdGlvbk1hdHJpeCksdGhpcy5fdmlld01hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX3Byb2plY3Rpb25NYXRyaXgsdGhpcy5fdHJhbnNmb3JtTWF0cml4KX1yZXR1cm4gdGhpcy5fdHJhbnNmb3JtTWF0cml4fSxiLnByb3RvdHlwZS5nZXREYXJrbmVzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kYXJrbmVzc30sYi5wcm90b3R5cGUuc2V0RGFya25lc3M9ZnVuY3Rpb24oYSl7YT49MT90aGlzLl9kYXJrbmVzcz0xOjA+PWEmJih0aGlzLl9kYXJrbmVzcz0wKSxlbHNldGhpcy5fZGFya25lc3M9YX0sYi5wcm90b3R5cGUuc2V0VHJhbnNwYXJlbmN5U2hhZG93PWZ1bmN0aW9uKGEpe3RoaXMuX3RyYW5zcGFyZW5jeVNoYWRvdz1hfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fc2hhZG93TWFwLmRpc3Bvc2UoKX0sYi5fRklMVEVSX05PTkU9MCxiLl9GSUxURVJfVkFSSUFOQ0VTSEFET1dNQVA9MSxiLl9GSUxURVJfUE9JU1NPTlNBTVBMSU5HPTIsYn0oKTthLlNoYWRvd0dlbmVyYXRvcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSl7Yi5jYWxsKHRoaXMsYyxlKSx0aGlzLmRpcmVjdGlvbj1kLHRoaXMuZ3JvdW5kQ29sb3I9bmV3IGEuQ29sb3IzKDAsMCwwKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuc2V0RGlyZWN0aW9uVG9UYXJnZXQ9ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMuZGlyZWN0aW9uPWEuVmVjdG9yMy5Ob3JtYWxpemUoYi5zdWJ0cmFjdChhLlZlY3RvcjMuWmVybygpKSksdGhpcy5kaXJlY3Rpb259LGMucHJvdG90eXBlLmdldFNoYWRvd0dlbmVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxjLnByb3RvdHlwZS50cmFuc2ZlclRvRWZmZWN0PWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLlZlY3RvcjMuTm9ybWFsaXplKHRoaXMuZGlyZWN0aW9uKTtiLnNldEZsb2F0NChjLGUueCxlLnksZS56LDApLGIuc2V0Q29sb3IzKGQsdGhpcy5ncm91bmRDb2xvci5zY2FsZSh0aGlzLmludGVuc2l0eSkpfSxjLnByb3RvdHlwZS5fZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh8fCh0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSx0aGlzLl93b3JsZE1hdHJpeH0sY30oYS5MaWdodCk7YS5IZW1pc3BoZXJpY0xpZ2h0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBhLng+Yy54K2Q/ITE6Yy54LWQ+Yi54PyExOmEueT5jLnkrZD8hMTpjLnktZD5iLnk/ITE6YS56PmMueitkPyExOmMuei1kPmIuej8hMTohMH0sYz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1iKmItNCphKmMsZj17cm9vdDowLGZvdW5kOiExfTtpZigwPmUpcmV0dXJuIGY7dmFyIGc9TWF0aC5zcXJ0KGUpLGg9KC1iLWcpLygyKmEpLGk9KC1iK2cpLygyKmEpO2lmKGg+aSl7dmFyIGo9aTtpPWgsaD1qfXJldHVybiBoPjAmJmQ+aD8oZi5yb290PWgsZi5mb3VuZD0hMCxmKTppPjAmJmQ+aT8oZi5yb290PWksZi5mb3VuZD0hMCxmKTpmfSxkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZCgpe3RoaXMucmFkaXVzPW5ldyBhLlZlY3RvcjMoMSwxLDEpLHRoaXMucmV0cnk9MCx0aGlzLmJhc2VQb2ludFdvcmxkPWEuVmVjdG9yMy5aZXJvKCksdGhpcy52ZWxvY2l0eVdvcmxkPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5ub3JtYWxpemVkVmVsb2NpdHk9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9jb2xsaXNpb25Qb2ludD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3BsYW5lSW50ZXJzZWN0aW9uUG9pbnQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90ZW1wVmVjdG9yPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdGVtcFZlY3RvcjI9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90ZW1wVmVjdG9yMz1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3RlbXBWZWN0b3I0PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fZWRnZT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2Jhc2VUb1ZlcnRleD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2Rlc3RpbmF0aW9uUG9pbnQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fZGlzcGxhY2VtZW50VmVjdG9yPWEuVmVjdG9yMy5aZXJvKCl9cmV0dXJuIGQucHJvdG90eXBlLl9pbml0aWFsaXplPWZ1bmN0aW9uKGIsYyxkKXt0aGlzLnZlbG9jaXR5PWMsYS5WZWN0b3IzLk5vcm1hbGl6ZVRvUmVmKGMsdGhpcy5ub3JtYWxpemVkVmVsb2NpdHkpLHRoaXMuYmFzZVBvaW50PWIsYi5tdWx0aXBseVRvUmVmKHRoaXMucmFkaXVzLHRoaXMuYmFzZVBvaW50V29ybGQpLGMubXVsdGlwbHlUb1JlZih0aGlzLnJhZGl1cyx0aGlzLnZlbG9jaXR5V29ybGQpLHRoaXMudmVsb2NpdHlXb3JsZExlbmd0aD10aGlzLnZlbG9jaXR5V29ybGQubGVuZ3RoKCksdGhpcy5lcHNpbG9uPWQsdGhpcy5jb2xsaXNpb25Gb3VuZD0hMX0sZC5wcm90b3R5cGUuX2NoZWNrUG9pbnRJblRyaWFuZ2xlPWZ1bmN0aW9uKGIsYyxkLGUsZil7Yy5zdWJ0cmFjdFRvUmVmKGIsdGhpcy5fdGVtcFZlY3RvciksZC5zdWJ0cmFjdFRvUmVmKGIsdGhpcy5fdGVtcFZlY3RvcjIpLGEuVmVjdG9yMy5Dcm9zc1RvUmVmKHRoaXMuX3RlbXBWZWN0b3IsdGhpcy5fdGVtcFZlY3RvcjIsdGhpcy5fdGVtcFZlY3RvcjQpO3ZhciBnPWEuVmVjdG9yMy5Eb3QodGhpcy5fdGVtcFZlY3RvcjQsZik7cmV0dXJuIDA+Zz8hMTooZS5zdWJ0cmFjdFRvUmVmKGIsdGhpcy5fdGVtcFZlY3RvcjMpLGEuVmVjdG9yMy5Dcm9zc1RvUmVmKHRoaXMuX3RlbXBWZWN0b3IyLHRoaXMuX3RlbXBWZWN0b3IzLHRoaXMuX3RlbXBWZWN0b3I0KSxnPWEuVmVjdG9yMy5Eb3QodGhpcy5fdGVtcFZlY3RvcjQsZiksMD5nPyExOihhLlZlY3RvcjMuQ3Jvc3NUb1JlZih0aGlzLl90ZW1wVmVjdG9yMyx0aGlzLl90ZW1wVmVjdG9yLHRoaXMuX3RlbXBWZWN0b3I0KSxnPWEuVmVjdG9yMy5Eb3QodGhpcy5fdGVtcFZlY3RvcjQsZiksZz49MCkpfSxkLnByb3RvdHlwZS5fY2FuRG9Db2xsaXNpb249ZnVuY3Rpb24oYyxkLGUsZil7dmFyIGc9YS5WZWN0b3IzLkRpc3RhbmNlKHRoaXMuYmFzZVBvaW50V29ybGQsYyksaD1NYXRoLm1heCh0aGlzLnJhZGl1cy54LHRoaXMucmFkaXVzLnksdGhpcy5yYWRpdXMueik7cmV0dXJuIGc+dGhpcy52ZWxvY2l0eVdvcmxkTGVuZ3RoK2grZD8hMTpiKGUsZix0aGlzLmJhc2VQb2ludFdvcmxkLHRoaXMudmVsb2NpdHlXb3JsZExlbmd0aCtoKT8hMDohMX0sZC5wcm90b3R5cGUuX3Rlc3RUcmlhbmdsZT1mdW5jdGlvbihiLGQsZSxmLGcpe3ZhciBoLGk9ITE7ZC5fdHJpYW5nbGVQbGFuZXN8fChkLl90cmlhbmdsZVBsYW5lcz1bXSksZC5fdHJpYW5nbGVQbGFuZXNbYl18fChkLl90cmlhbmdsZVBsYW5lc1tiXT1uZXcgYS5QbGFuZSgwLDAsMCwwKSxkLl90cmlhbmdsZVBsYW5lc1tiXS5jb3B5RnJvbVBvaW50cyhlLGYsZykpO3ZhciBqPWQuX3RyaWFuZ2xlUGxhbmVzW2JdO2lmKGQuZ2V0TWF0ZXJpYWwoKXx8ai5pc0Zyb250RmFjaW5nVG8odGhpcy5ub3JtYWxpemVkVmVsb2NpdHksMCkpe3ZhciBrPWouc2lnbmVkRGlzdGFuY2VUbyh0aGlzLmJhc2VQb2ludCksbD1hLlZlY3RvcjMuRG90KGoubm9ybWFsLHRoaXMudmVsb2NpdHkpO2lmKDA9PWwpe2lmKE1hdGguYWJzKGspPj0xKXJldHVybjtpPSEwLGg9MH1lbHNle2g9KC0xLWspL2w7dmFyIG09KDEtaykvbDtpZihoPm0pe3ZhciBuPW07bT1oLGg9bn1pZihoPjF8fDA+bSlyZXR1cm47MD5oJiYoaD0wKSxoPjEmJihoPTEpfXRoaXMuX2NvbGxpc2lvblBvaW50LmNvcHlGcm9tRmxvYXRzKDAsMCwwKTt2YXIgbz0hMSxwPTE7aWYoaXx8KHRoaXMuYmFzZVBvaW50LnN1YnRyYWN0VG9SZWYoai5ub3JtYWwsdGhpcy5fcGxhbmVJbnRlcnNlY3Rpb25Qb2ludCksdGhpcy52ZWxvY2l0eS5zY2FsZVRvUmVmKGgsdGhpcy5fdGVtcFZlY3RvciksdGhpcy5fcGxhbmVJbnRlcnNlY3Rpb25Qb2ludC5hZGRJblBsYWNlKHRoaXMuX3RlbXBWZWN0b3IpLHRoaXMuX2NoZWNrUG9pbnRJblRyaWFuZ2xlKHRoaXMuX3BsYW5lSW50ZXJzZWN0aW9uUG9pbnQsZSxmLGcsai5ub3JtYWwpJiYobz0hMCxwPWgsdGhpcy5fY29sbGlzaW9uUG9pbnQuY29weUZyb20odGhpcy5fcGxhbmVJbnRlcnNlY3Rpb25Qb2ludCkpKSwhbyl7dmFyIHE9dGhpcy52ZWxvY2l0eS5sZW5ndGhTcXVhcmVkKCkscj1xO3RoaXMuYmFzZVBvaW50LnN1YnRyYWN0VG9SZWYoZSx0aGlzLl90ZW1wVmVjdG9yKTt2YXIgcz0yKmEuVmVjdG9yMy5Eb3QodGhpcy52ZWxvY2l0eSx0aGlzLl90ZW1wVmVjdG9yKSx0PXRoaXMuX3RlbXBWZWN0b3IubGVuZ3RoU3F1YXJlZCgpLTEsdT1jKHIscyx0LHApO3UuZm91bmQmJihwPXUucm9vdCxvPSEwLHRoaXMuX2NvbGxpc2lvblBvaW50LmNvcHlGcm9tKGUpKSx0aGlzLmJhc2VQb2ludC5zdWJ0cmFjdFRvUmVmKGYsdGhpcy5fdGVtcFZlY3Rvcikscz0yKmEuVmVjdG9yMy5Eb3QodGhpcy52ZWxvY2l0eSx0aGlzLl90ZW1wVmVjdG9yKSx0PXRoaXMuX3RlbXBWZWN0b3IubGVuZ3RoU3F1YXJlZCgpLTEsdT1jKHIscyx0LHApLHUuZm91bmQmJihwPXUucm9vdCxvPSEwLHRoaXMuX2NvbGxpc2lvblBvaW50LmNvcHlGcm9tKGYpKSx0aGlzLmJhc2VQb2ludC5zdWJ0cmFjdFRvUmVmKGcsdGhpcy5fdGVtcFZlY3Rvcikscz0yKmEuVmVjdG9yMy5Eb3QodGhpcy52ZWxvY2l0eSx0aGlzLl90ZW1wVmVjdG9yKSx0PXRoaXMuX3RlbXBWZWN0b3IubGVuZ3RoU3F1YXJlZCgpLTEsdT1jKHIscyx0LHApLHUuZm91bmQmJihwPXUucm9vdCxvPSEwLHRoaXMuX2NvbGxpc2lvblBvaW50LmNvcHlGcm9tKGcpKSxmLnN1YnRyYWN0VG9SZWYoZSx0aGlzLl9lZGdlKSxlLnN1YnRyYWN0VG9SZWYodGhpcy5iYXNlUG9pbnQsdGhpcy5fYmFzZVRvVmVydGV4KTt2YXIgdj10aGlzLl9lZGdlLmxlbmd0aFNxdWFyZWQoKSx3PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLnZlbG9jaXR5KSx4PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLl9iYXNlVG9WZXJ0ZXgpO2lmKHI9diotcSt3Kncscz0yKnYqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX2Jhc2VUb1ZlcnRleCktMip3KngsdD12KigxLXRoaXMuX2Jhc2VUb1ZlcnRleC5sZW5ndGhTcXVhcmVkKCkpK3gqeCx1PWMocixzLHQscCksdS5mb3VuZCl7dmFyIHk9KHcqdS5yb290LXgpL3Y7eT49MCYmMT49eSYmKHA9dS5yb290LG89ITAsdGhpcy5fZWRnZS5zY2FsZUluUGxhY2UoeSksZS5hZGRUb1JlZih0aGlzLl9lZGdlLHRoaXMuX2NvbGxpc2lvblBvaW50KSl9Zy5zdWJ0cmFjdFRvUmVmKGYsdGhpcy5fZWRnZSksZi5zdWJ0cmFjdFRvUmVmKHRoaXMuYmFzZVBvaW50LHRoaXMuX2Jhc2VUb1ZlcnRleCksdj10aGlzLl9lZGdlLmxlbmd0aFNxdWFyZWQoKSx3PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLnZlbG9jaXR5KSx4PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLl9iYXNlVG9WZXJ0ZXgpLHI9diotcSt3Kncscz0yKnYqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX2Jhc2VUb1ZlcnRleCktMip3KngsdD12KigxLXRoaXMuX2Jhc2VUb1ZlcnRleC5sZW5ndGhTcXVhcmVkKCkpK3gqeCx1PWMocixzLHQscCksdS5mb3VuZCYmKHk9KHcqdS5yb290LXgpL3YseT49MCYmMT49eSYmKHA9dS5yb290LG89ITAsdGhpcy5fZWRnZS5zY2FsZUluUGxhY2UoeSksZi5hZGRUb1JlZih0aGlzLl9lZGdlLHRoaXMuX2NvbGxpc2lvblBvaW50KSkpLGUuc3VidHJhY3RUb1JlZihnLHRoaXMuX2VkZ2UpLGcuc3VidHJhY3RUb1JlZih0aGlzLmJhc2VQb2ludCx0aGlzLl9iYXNlVG9WZXJ0ZXgpLHY9dGhpcy5fZWRnZS5sZW5ndGhTcXVhcmVkKCksdz1hLlZlY3RvcjMuRG90KHRoaXMuX2VkZ2UsdGhpcy52ZWxvY2l0eSkseD1hLlZlY3RvcjMuRG90KHRoaXMuX2VkZ2UsdGhpcy5fYmFzZVRvVmVydGV4KSxyPXYqLXErdyp3LHM9Mip2KmEuVmVjdG9yMy5Eb3QodGhpcy52ZWxvY2l0eSx0aGlzLl9iYXNlVG9WZXJ0ZXgpLTIqdyp4LHQ9diooMS10aGlzLl9iYXNlVG9WZXJ0ZXgubGVuZ3RoU3F1YXJlZCgpKSt4KngsdT1jKHIscyx0LHApLHUuZm91bmQmJih5PSh3KnUucm9vdC14KS92LHk+PTAmJjE+PXkmJihwPXUucm9vdCxvPSEwLHRoaXMuX2VkZ2Uuc2NhbGVJblBsYWNlKHkpLGcuYWRkVG9SZWYodGhpcy5fZWRnZSx0aGlzLl9jb2xsaXNpb25Qb2ludCkpKX1pZihvKXt2YXIgej1wKnRoaXMudmVsb2NpdHkubGVuZ3RoKCk7KCF0aGlzLmNvbGxpc2lvbkZvdW5kfHx6PHRoaXMubmVhcmVzdERpc3RhbmNlKSYmKHRoaXMuaW50ZXJzZWN0aW9uUG9pbnQ/dGhpcy5pbnRlcnNlY3Rpb25Qb2ludC5jb3B5RnJvbSh0aGlzLl9jb2xsaXNpb25Qb2ludCk6dGhpcy5pbnRlcnNlY3Rpb25Qb2ludD10aGlzLl9jb2xsaXNpb25Qb2ludC5jbG9uZSgpLHRoaXMubmVhcmVzdERpc3RhbmNlPXosdGhpcy5jb2xsaXNpb25Gb3VuZD0hMCx0aGlzLmNvbGxpZGVkTWVzaD1kLmdldE1lc2goKSl9fX0sZC5wcm90b3R5cGUuX2NvbGxpZGU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2Zvcih2YXIgZz1kO2U+ZztnKz0zKXt2YXIgaD1iW2NbZ10tZl0saT1iW2NbZysxXS1mXSxqPWJbY1tnKzJdLWZdO3RoaXMuX3Rlc3RUcmlhbmdsZShnLGEsaixpLGgpfX0sZC5wcm90b3R5cGUuX2dldFJlc3BvbnNlPWZ1bmN0aW9uKGIsYyl7Yi5hZGRUb1JlZihjLHRoaXMuX2Rlc3RpbmF0aW9uUG9pbnQpLGMuc2NhbGVJblBsYWNlKHRoaXMubmVhcmVzdERpc3RhbmNlL2MubGVuZ3RoKCkpLHRoaXMuYmFzZVBvaW50LmFkZFRvUmVmKGMsYiksYi5zdWJ0cmFjdFRvUmVmKHRoaXMuaW50ZXJzZWN0aW9uUG9pbnQsdGhpcy5fc2xpZGVQbGFuZU5vcm1hbCksdGhpcy5fc2xpZGVQbGFuZU5vcm1hbC5ub3JtYWxpemUoKSx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsLnNjYWxlVG9SZWYodGhpcy5lcHNpbG9uLHRoaXMuX2Rpc3BsYWNlbWVudFZlY3RvciksYi5hZGRJblBsYWNlKHRoaXMuX2Rpc3BsYWNlbWVudFZlY3RvciksdGhpcy5pbnRlcnNlY3Rpb25Qb2ludC5hZGRJblBsYWNlKHRoaXMuX2Rpc3BsYWNlbWVudFZlY3RvciksdGhpcy5fc2xpZGVQbGFuZU5vcm1hbC5zY2FsZUluUGxhY2UoYS5QbGFuZS5TaWduZWREaXN0YW5jZVRvUGxhbmVGcm9tUG9zaXRpb25BbmROb3JtYWwodGhpcy5pbnRlcnNlY3Rpb25Qb2ludCx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsLHRoaXMuX2Rlc3RpbmF0aW9uUG9pbnQpKSx0aGlzLl9kZXN0aW5hdGlvblBvaW50LnN1YnRyYWN0SW5QbGFjZSh0aGlzLl9zbGlkZVBsYW5lTm9ybWFsKSx0aGlzLl9kZXN0aW5hdGlvblBvaW50LnN1YnRyYWN0VG9SZWYodGhpcy5pbnRlcnNlY3Rpb25Qb2ludCxjKX0sZH0oKTthLkNvbGxpZGVyPWR9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGQsZSxmKXtiLmNhbGwodGhpcyxkLGYpLHRoaXMucG9zaXRpb249ZSx0aGlzLnVwVmVjdG9yPWEuVmVjdG9yMy5VcCgpLHRoaXMub3J0aG9MZWZ0PW51bGwsdGhpcy5vcnRob1JpZ2h0PW51bGwsdGhpcy5vcnRob0JvdHRvbT1udWxsLHRoaXMub3J0aG9Ub3A9bnVsbCx0aGlzLmZvdj0uOCx0aGlzLm1pblo9LjEsdGhpcy5tYXhaPTFlMyx0aGlzLmluZXJ0aWE9LjksdGhpcy5tb2RlPWMuUEVSU1BFQ1RJVkVfQ0FNRVJBLHRoaXMuaXNJbnRlcm1lZGlhdGU9ITEsdGhpcy52aWV3cG9ydD1uZXcgYS5WaWV3cG9ydCgwLDAsMSwxKSx0aGlzLnN1YkNhbWVyYXM9W10sdGhpcy5sYXllck1hc2s9NDI5NDk2NzI5NSx0aGlzLl9jb21wdXRlZFZpZXdNYXRyaXg9YS5NYXRyaXguSWRlbnRpdHkoKSx0aGlzLl9wcm9qZWN0aW9uTWF0cml4PW5ldyBhLk1hdHJpeCx0aGlzLl9wb3N0UHJvY2Vzc2VzPW5ldyBBcnJheSx0aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzPVtdLGYuY2FtZXJhcy5wdXNoKHRoaXMpLGYuYWN0aXZlQ2FtZXJhfHwoZi5hY3RpdmVDYW1lcmE9dGhpcyl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9pbml0Q2FjaGU9ZnVuY3Rpb24oKXtiLnByb3RvdHlwZS5faW5pdENhY2hlLmNhbGwodGhpcyksdGhpcy5fY2FjaGUucG9zaXRpb249bmV3IGEuVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksdGhpcy5fY2FjaGUudXBWZWN0b3I9bmV3IGEuVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksdGhpcy5fY2FjaGUubW9kZT12b2lkIDAsdGhpcy5fY2FjaGUubWluWj12b2lkIDAsdGhpcy5fY2FjaGUubWF4Wj12b2lkIDAsdGhpcy5fY2FjaGUuZm92PXZvaWQgMCx0aGlzLl9jYWNoZS5hc3BlY3RSYXRpbz12b2lkIDAsdGhpcy5fY2FjaGUub3J0aG9MZWZ0PXZvaWQgMCx0aGlzLl9jYWNoZS5vcnRob1JpZ2h0PXZvaWQgMCx0aGlzLl9jYWNoZS5vcnRob0JvdHRvbT12b2lkIDAsdGhpcy5fY2FjaGUub3J0aG9Ub3A9dm9pZCAwLHRoaXMuX2NhY2hlLnJlbmRlcldpZHRoPXZvaWQgMCx0aGlzLl9jYWNoZS5yZW5kZXJIZWlnaHQ9dm9pZCAwfSxjLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGU9ZnVuY3Rpb24oYSl7YXx8Yi5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlLmNhbGwodGhpcyk7dmFyIGM9dGhpcy5nZXRFbmdpbmUoKTt0aGlzLl9jYWNoZS5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnBvc2l0aW9uKSx0aGlzLl9jYWNoZS51cFZlY3Rvci5jb3B5RnJvbSh0aGlzLnVwVmVjdG9yKSx0aGlzLl9jYWNoZS5tb2RlPXRoaXMubW9kZSx0aGlzLl9jYWNoZS5taW5aPXRoaXMubWluWix0aGlzLl9jYWNoZS5tYXhaPXRoaXMubWF4Wix0aGlzLl9jYWNoZS5mb3Y9dGhpcy5mb3YsdGhpcy5fY2FjaGUuYXNwZWN0UmF0aW89Yy5nZXRBc3BlY3RSYXRpbyh0aGlzKSx0aGlzLl9jYWNoZS5vcnRob0xlZnQ9dGhpcy5vcnRob0xlZnQsdGhpcy5fY2FjaGUub3J0aG9SaWdodD10aGlzLm9ydGhvUmlnaHQsdGhpcy5fY2FjaGUub3J0aG9Cb3R0b209dGhpcy5vcnRob0JvdHRvbSx0aGlzLl9jYWNoZS5vcnRob1RvcD10aGlzLm9ydGhvVG9wLHRoaXMuX2NhY2hlLnJlbmRlcldpZHRoPWMuZ2V0UmVuZGVyV2lkdGgoKSx0aGlzLl9jYWNoZS5yZW5kZXJIZWlnaHQ9Yy5nZXRSZW5kZXJIZWlnaHQoKX0sYy5wcm90b3R5cGUuX3VwZGF0ZUZyb21TY2VuZT1mdW5jdGlvbigpe3RoaXMudXBkYXRlQ2FjaGUoKSx0aGlzLl91cGRhdGUoKX0sYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU3luY2hyb25pemVkVmlld01hdHJpeCgpJiZ0aGlzLl9pc1N5bmNocm9uaXplZFByb2plY3Rpb25NYXRyaXgoKX0sYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeD1mdW5jdGlvbigpe3JldHVybiBiLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWQuY2FsbCh0aGlzKT90aGlzLl9jYWNoZS5wb3NpdGlvbi5lcXVhbHModGhpcy5wb3NpdGlvbikmJnRoaXMuX2NhY2hlLnVwVmVjdG9yLmVxdWFscyh0aGlzLnVwVmVjdG9yKSYmdGhpcy5pc1N5bmNocm9uaXplZFdpdGhQYXJlbnQoKTohMX0sYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkUHJvamVjdGlvbk1hdHJpeD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuX2NhY2hlLm1vZGU9PT10aGlzLm1vZGUmJnRoaXMuX2NhY2hlLm1pblo9PT10aGlzLm1pblomJnRoaXMuX2NhY2hlLm1heFo9PT10aGlzLm1heFo7aWYoIWIpcmV0dXJuITE7dmFyIGM9dGhpcy5nZXRFbmdpbmUoKTtyZXR1cm4gYj10aGlzLm1vZGU9PT1hLkNhbWVyYS5QRVJTUEVDVElWRV9DQU1FUkE/dGhpcy5fY2FjaGUuZm92PT09dGhpcy5mb3YmJnRoaXMuX2NhY2hlLmFzcGVjdFJhdGlvPT09Yy5nZXRBc3BlY3RSYXRpbyh0aGlzKTp0aGlzLl9jYWNoZS5vcnRob0xlZnQ9PT10aGlzLm9ydGhvTGVmdCYmdGhpcy5fY2FjaGUub3J0aG9SaWdodD09PXRoaXMub3J0aG9SaWdodCYmdGhpcy5fY2FjaGUub3J0aG9Cb3R0b209PT10aGlzLm9ydGhvQm90dG9tJiZ0aGlzLl9jYWNoZS5vcnRob1RvcD09PXRoaXMub3J0aG9Ub3AmJnRoaXMuX2NhY2hlLnJlbmRlcldpZHRoPT09Yy5nZXRSZW5kZXJXaWR0aCgpJiZ0aGlzLl9jYWNoZS5yZW5kZXJIZWlnaHQ9PT1jLmdldFJlbmRlckhlaWdodCgpfSxjLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5hdHRhY2hQb3N0UHJvY2Vzcz1mdW5jdGlvbihiLGMpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjJiYoYz1udWxsKSwhYi5pc1JldXNhYmxlKCkmJnRoaXMuX3Bvc3RQcm9jZXNzZXMuaW5kZXhPZihiKT4tMSlyZXR1cm4gYS5Ub29scy5FcnJvcihcIllvdSdyZSB0cnlpbmcgdG8gcmV1c2UgYSBwb3N0IHByb2Nlc3Mgbm90IGRlZmluZWQgYXMgcmV1c2FibGUuXCIpLDA7aWYobnVsbD09Y3x8MD5jKXJldHVybiB0aGlzLl9wb3N0UHJvY2Vzc2VzLnB1c2goYiksdGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5wdXNoKHRoaXMuX3Bvc3RQcm9jZXNzZXMubGVuZ3RoLTEpLHRoaXMuX3Bvc3RQcm9jZXNzZXMubGVuZ3RoLTE7dmFyIGQ9MDtpZih0aGlzLl9wb3N0UHJvY2Vzc2VzW2NdKXtmb3IodmFyIGU9dGhpcy5fcG9zdFByb2Nlc3Nlcy5sZW5ndGgtMSxmPWU7Zj49YysxOy0tZil0aGlzLl9wb3N0UHJvY2Vzc2VzW2YrMV09dGhpcy5fcG9zdFByb2Nlc3Nlc1tmXTtkPTF9Zm9yKGY9MDtmPHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMubGVuZ3RoOysrZilpZighKHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbZl08Yykpe2U9dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5sZW5ndGgtMTtmb3IodmFyIGc9ZTtnPj1mOy0tZyl0aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzW2crMV09dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlc1tnXStkO3RoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbZl09YzticmVha31kfHwtMSE9dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5pbmRleE9mKGMpfHx0aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLnB1c2goYyk7dmFyIGg9YytkO3JldHVybiB0aGlzLl9wb3N0UHJvY2Vzc2VzW2hdPWIsaH0sYy5wcm90b3R5cGUuZGV0YWNoUG9zdFByb2Nlc3M9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9bnVsbCk7dmFyIGM9W107aWYoYilmb3IoYj1iIGluc3RhbmNlb2YgQXJyYXk/YjpbYl0sZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgZD10aGlzLl9wb3N0UHJvY2Vzc2VzW2JbZl1dO2Q9PT1hPyhkZWxldGUgdGhpcy5fcG9zdFByb2Nlc3Nlc1tiW2ZdXSxnPXRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMuaW5kZXhPZihiW2ZdKSx0aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLnNwbGljZShnLDEpKTpjLnB1c2goZilcbn1lbHNlIGZvcih2YXIgZT10aGlzLl9wb3N0UHJvY2Vzc2VzLmxlbmd0aCxmPTA7ZT5mO2YrKylpZih0aGlzLl9wb3N0UHJvY2Vzc2VzW2ZdPT09YSl7ZGVsZXRlIHRoaXMuX3Bvc3RQcm9jZXNzZXNbZl07dmFyIGc9dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5pbmRleE9mKGYpO3RoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMuc3BsaWNlKGcsMSl9cmV0dXJuIGN9LGMucHJvdG90eXBlLmdldFdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7dGhpcy5fd29ybGRNYXRyaXh8fCh0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKTt2YXIgYj10aGlzLmdldFZpZXdNYXRyaXgoKTtyZXR1cm4gYi5pbnZlcnRUb1JlZih0aGlzLl93b3JsZE1hdHJpeCksdGhpcy5fd29ybGRNYXRyaXh9LGMucHJvdG90eXBlLl9nZXRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIGEuTWF0cml4LklkZW50aXR5KCl9LGMucHJvdG90eXBlLmdldFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4PXRoaXMuX2NvbXB1dGVWaWV3TWF0cml4KCksdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4JiYhdGhpcy5pc1N5bmNocm9uaXplZCgpPyh0aGlzLl93b3JsZE1hdHJpeHx8KHRoaXMuX3dvcmxkTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpLHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeC5pbnZlcnRUb1JlZih0aGlzLl93b3JsZE1hdHJpeCksdGhpcy5fd29ybGRNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeCksdGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4LmludmVydCgpLHRoaXMuX2N1cnJlbnRSZW5kZXJJZD10aGlzLmdldFNjZW5lKCkuZ2V0UmVuZGVySWQoKSx0aGlzLl9jb21wdXRlZFZpZXdNYXRyaXgpOnRoaXMuX2NvbXB1dGVkVmlld01hdHJpeH0sYy5wcm90b3R5cGUuX2NvbXB1dGVWaWV3TWF0cml4PWZ1bmN0aW9uKGEpe3JldHVybiFhJiZ0aGlzLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXgoKT90aGlzLl9jb21wdXRlZFZpZXdNYXRyaXg6KHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeD10aGlzLl9nZXRWaWV3TWF0cml4KCksdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4fHwodGhpcy5fY3VycmVudFJlbmRlcklkPXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpKSx0aGlzLl9jb21wdXRlZFZpZXdNYXRyaXgpfSxjLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uTWF0cml4PWZ1bmN0aW9uKGIpe2lmKCFiJiZ0aGlzLl9pc1N5bmNocm9uaXplZFByb2plY3Rpb25NYXRyaXgoKSlyZXR1cm4gdGhpcy5fcHJvamVjdGlvbk1hdHJpeDt2YXIgYz10aGlzLmdldEVuZ2luZSgpO2lmKHRoaXMubW9kZT09PWEuQ2FtZXJhLlBFUlNQRUNUSVZFX0NBTUVSQSlyZXR1cm4gdGhpcy5taW5aPD0wJiYodGhpcy5taW5aPS4xKSxhLk1hdHJpeC5QZXJzcGVjdGl2ZUZvdkxIVG9SZWYodGhpcy5mb3YsYy5nZXRBc3BlY3RSYXRpbyh0aGlzKSx0aGlzLm1pblosdGhpcy5tYXhaLHRoaXMuX3Byb2plY3Rpb25NYXRyaXgpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXg7dmFyIGQ9Yy5nZXRSZW5kZXJXaWR0aCgpLzIsZT1jLmdldFJlbmRlckhlaWdodCgpLzI7cmV0dXJuIGEuTWF0cml4Lk9ydGhvT2ZmQ2VudGVyTEhUb1JlZih0aGlzLm9ydGhvTGVmdHx8LWQsdGhpcy5vcnRob1JpZ2h0fHxkLHRoaXMub3J0aG9Cb3R0b218fC1lLHRoaXMub3J0aG9Ub3B8fGUsdGhpcy5taW5aLHRoaXMubWF4Wix0aGlzLl9wcm9qZWN0aW9uTWF0cml4KSx0aGlzLl9wcm9qZWN0aW9uTWF0cml4fSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTY2VuZSgpLmNhbWVyYXMuaW5kZXhPZih0aGlzKTt0aGlzLmdldFNjZW5lKCkuY2FtZXJhcy5zcGxpY2UoYSwxKTtmb3IodmFyIGI9MDtiPHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMubGVuZ3RoOysrYil0aGlzLl9wb3N0UHJvY2Vzc2VzW3RoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbYl1dLmRpc3Bvc2UodGhpcyl9LGMuUEVSU1BFQ1RJVkVfQ0FNRVJBPTAsYy5PUlRIT0dSQVBISUNfQ0FNRVJBPTEsY30oYS5Ob2RlKTthLkNhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSl7Yi5jYWxsKHRoaXMsYyxkLGUpLHRoaXMuY2FtZXJhRGlyZWN0aW9uPW5ldyBhLlZlY3RvcjMoMCwwLDApLHRoaXMuY2FtZXJhUm90YXRpb249bmV3IGEuVmVjdG9yMigwLDApLHRoaXMucm90YXRpb249bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5lbGxpcHNvaWQ9bmV3IGEuVmVjdG9yMyguNSwxLC41KSx0aGlzLmtleXNVcD1bMzhdLHRoaXMua2V5c0Rvd249WzQwXSx0aGlzLmtleXNMZWZ0PVszN10sdGhpcy5rZXlzUmlnaHQ9WzM5XSx0aGlzLnNwZWVkPTIsdGhpcy5jaGVja0NvbGxpc2lvbnM9ITEsdGhpcy5hcHBseUdyYXZpdHk9ITEsdGhpcy5ub1JvdGF0aW9uQ29uc3RyYWludD0hMSx0aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eT0yZTMsdGhpcy5sb2NrZWRUYXJnZXQ9bnVsbCx0aGlzLl9rZXlzPVtdLHRoaXMuX2NvbGxpZGVyPW5ldyBhLkNvbGxpZGVyLHRoaXMuX25lZWRNb3ZlRm9yR3Jhdml0eT0hMCx0aGlzLl9jdXJyZW50VGFyZ2V0PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdmlld01hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fY2FtTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9yZWZlcmVuY2VQb2ludD1uZXcgYS5WZWN0b3IzKDAsMCwxKSx0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fb2xkUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9kaWZmUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9uZXdQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2xvb2tBdFRlbXA9YS5NYXRyaXguWmVybygpLHRoaXMuX3RlbXBNYXRyaXg9YS5NYXRyaXguWmVybygpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NrZWRUYXJnZXQ/dGhpcy5sb2NrZWRUYXJnZXQucG9zaXRpb258fHRoaXMubG9ja2VkVGFyZ2V0Om51bGx9LGMucHJvdG90eXBlLl9pbml0Q2FjaGU9ZnVuY3Rpb24oKXtiLnByb3RvdHlwZS5faW5pdENhY2hlLmNhbGwodGhpcyksdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0PW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpLHRoaXMuX2NhY2hlLnJvdGF0aW9uPW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpfSxjLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGU9ZnVuY3Rpb24oYSl7YXx8Yi5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlLmNhbGwodGhpcyk7dmFyIGM9dGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtjP3RoaXMuX2NhY2hlLmxvY2tlZFRhcmdldD90aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQuY29weUZyb20oYyk6dGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0PWMuY2xvbmUoKTp0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQ9bnVsbCx0aGlzLl9jYWNoZS5yb3RhdGlvbi5jb3B5RnJvbSh0aGlzLnJvdGF0aW9uKX0sYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeD1mdW5jdGlvbigpe2lmKCFiLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4LmNhbGwodGhpcykpcmV0dXJuITE7dmFyIGE9dGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtyZXR1cm4odGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0P3RoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5lcXVhbHMoYSk6IWEpJiZ0aGlzLl9jYWNoZS5yb3RhdGlvbi5lcXVhbHModGhpcy5yb3RhdGlvbil9LGMucHJvdG90eXBlLl9jb21wdXRlTG9jYWxDYW1lcmFTcGVlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNwZWVkKihhLlRvb2xzLkdldERlbHRhVGltZSgpLygxMCphLlRvb2xzLkdldEZwcygpKSl9LGMucHJvdG90eXBlLnNldFRhcmdldD1mdW5jdGlvbihiKXt0aGlzLnVwVmVjdG9yLm5vcm1hbGl6ZSgpLGEuTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbixiLHRoaXMudXBWZWN0b3IsdGhpcy5fY2FtTWF0cml4KSx0aGlzLl9jYW1NYXRyaXguaW52ZXJ0KCksdGhpcy5yb3RhdGlvbi54PU1hdGguYXRhbih0aGlzLl9jYW1NYXRyaXgubVs2XS90aGlzLl9jYW1NYXRyaXgubVsxMF0pO3ZhciBjPWIuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7dGhpcy5yb3RhdGlvbi55PWMueD49MD8tTWF0aC5hdGFuKGMuei9jLngpK01hdGguUEkvMjotTWF0aC5hdGFuKGMuei9jLngpLU1hdGguUEkvMix0aGlzLnJvdGF0aW9uLno9LU1hdGguYWNvcyhhLlZlY3RvcjMuRG90KG5ldyBhLlZlY3RvcjMoMCwxLDApLHRoaXMudXBWZWN0b3IpKSxpc05hTih0aGlzLnJvdGF0aW9uLngpJiYodGhpcy5yb3RhdGlvbi54PTApLGlzTmFOKHRoaXMucm90YXRpb24ueSkmJih0aGlzLnJvdGF0aW9uLnk9MCksaXNOYU4odGhpcy5yb3RhdGlvbi56KSYmKHRoaXMucm90YXRpb24uej0wKX0sYy5wcm90b3R5cGUuZ2V0VGFyZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRUYXJnZXR9LGMucHJvdG90eXBlLmF0dGFjaENvbnRyb2w9ZnVuY3Rpb24oYixjKXt2YXIgZCxlPXRoaXMsZj10aGlzLmdldEVuZ2luZSgpO3RoaXMuX2F0dGFjaGVkRWxlbWVudHx8KHRoaXMuX2F0dGFjaGVkRWxlbWVudD1iLHZvaWQgMD09PXRoaXMuX29uTW91c2VEb3duJiYodGhpcy5fb25Nb3VzZURvd249ZnVuY3Rpb24oYSl7ZD17eDphLmNsaWVudFgseTphLmNsaWVudFl9LGN8fGEucHJldmVudERlZmF1bHQoKX0sdGhpcy5fb25Nb3VzZVVwPWZ1bmN0aW9uKGEpe2Q9bnVsbCxjfHxhLnByZXZlbnREZWZhdWx0KCl9LHRoaXMuX29uTW91c2VPdXQ9ZnVuY3Rpb24oYSl7ZD1udWxsLGUuX2tleXM9W10sY3x8YS5wcmV2ZW50RGVmYXVsdCgpfSx0aGlzLl9vbk1vdXNlTW92ZT1mdW5jdGlvbihhKXtpZihkfHxmLmlzUG9pbnRlckxvY2spe3ZhciBiLGc7Zi5pc1BvaW50ZXJMb2NrPyhiPWEubW92ZW1lbnRYfHxhLm1vek1vdmVtZW50WHx8YS53ZWJraXRNb3ZlbWVudFh8fGEubXNNb3ZlbWVudFh8fDAsZz1hLm1vdmVtZW50WXx8YS5tb3pNb3ZlbWVudFl8fGEud2Via2l0TW92ZW1lbnRZfHxhLm1zTW92ZW1lbnRZfHwwKTooYj1hLmNsaWVudFgtZC54LGc9YS5jbGllbnRZLWQueSksZS5jYW1lcmFSb3RhdGlvbi55Kz1iL2UuYW5ndWxhclNlbnNpYmlsaXR5LGUuY2FtZXJhUm90YXRpb24ueCs9Zy9lLmFuZ3VsYXJTZW5zaWJpbGl0eSxkPXt4OmEuY2xpZW50WCx5OmEuY2xpZW50WX0sY3x8YS5wcmV2ZW50RGVmYXVsdCgpfX0sdGhpcy5fb25LZXlEb3duPWZ1bmN0aW9uKGEpe2lmKC0xIT09ZS5rZXlzVXAuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c0Rvd24uaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c0xlZnQuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c1JpZ2h0LmluZGV4T2YoYS5rZXlDb2RlKSl7dmFyIGI9ZS5fa2V5cy5pbmRleE9mKGEua2V5Q29kZSk7LTE9PT1iJiZlLl9rZXlzLnB1c2goYS5rZXlDb2RlKSxjfHxhLnByZXZlbnREZWZhdWx0KCl9fSx0aGlzLl9vbktleVVwPWZ1bmN0aW9uKGEpe2lmKC0xIT09ZS5rZXlzVXAuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c0Rvd24uaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c0xlZnQuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWUua2V5c1JpZ2h0LmluZGV4T2YoYS5rZXlDb2RlKSl7dmFyIGI9ZS5fa2V5cy5pbmRleE9mKGEua2V5Q29kZSk7Yj49MCYmZS5fa2V5cy5zcGxpY2UoYiwxKSxjfHxhLnByZXZlbnREZWZhdWx0KCl9fSx0aGlzLl9vbkxvc3RGb2N1cz1mdW5jdGlvbigpe2UuX2tleXM9W119LHRoaXMuX3Jlc2V0PWZ1bmN0aW9uKCl7ZS5fa2V5cz1bXSxkPW51bGwsZS5jYW1lcmFEaXJlY3Rpb249bmV3IGEuVmVjdG9yMygwLDAsMCksZS5jYW1lcmFSb3RhdGlvbj1uZXcgYS5WZWN0b3IyKDAsMCl9KSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93biwhMSksYi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX29uTW91c2VVcCwhMSksYi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIix0aGlzLl9vbk1vdXNlT3V0LCExKSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSwhMSksYS5Ub29scy5SZWdpc3RlclRvcFJvb3RFdmVudHMoW3tuYW1lOlwia2V5ZG93blwiLGhhbmRsZXI6dGhpcy5fb25LZXlEb3dufSx7bmFtZTpcImtleXVwXCIsaGFuZGxlcjp0aGlzLl9vbktleVVwfSx7bmFtZTpcImJsdXJcIixoYW5kbGVyOnRoaXMuX29uTG9zdEZvY3VzfV0pKX0sYy5wcm90b3R5cGUuZGV0YWNoQ29udHJvbD1mdW5jdGlvbihiKXt0aGlzLl9hdHRhY2hlZEVsZW1lbnQ9PWImJihiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLl9vbk1vdXNlRG93biksYi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX29uTW91c2VVcCksYi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIix0aGlzLl9vbk1vdXNlT3V0KSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSksYS5Ub29scy5VbnJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbe25hbWU6XCJrZXlkb3duXCIsaGFuZGxlcjp0aGlzLl9vbktleURvd259LHtuYW1lOlwia2V5dXBcIixoYW5kbGVyOnRoaXMuX29uS2V5VXB9LHtuYW1lOlwiYmx1clwiLGhhbmRsZXI6dGhpcy5fb25Mb3N0Rm9jdXN9XSksdGhpcy5fYXR0YWNoZWRFbGVtZW50PW51bGwsdGhpcy5fcmVzZXQmJnRoaXMuX3Jlc2V0KCkpfSxjLnByb3RvdHlwZS5fY29sbGlkZVdpdGhXb3JsZD1mdW5jdGlvbihiKXt2YXIgYztjPXRoaXMucGFyZW50P2EuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0aGlzLnBvc2l0aW9uLHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCkpOnRoaXMucG9zaXRpb24sYy5zdWJ0cmFjdEZyb21GbG9hdHNUb1JlZigwLHRoaXMuZWxsaXBzb2lkLnksMCx0aGlzLl9vbGRQb3NpdGlvbiksdGhpcy5fY29sbGlkZXIucmFkaXVzPXRoaXMuZWxsaXBzb2lkLHRoaXMuZ2V0U2NlbmUoKS5fZ2V0TmV3UG9zaXRpb24odGhpcy5fb2xkUG9zaXRpb24sYix0aGlzLl9jb2xsaWRlciwzLHRoaXMuX25ld1Bvc2l0aW9uKSx0aGlzLl9uZXdQb3NpdGlvbi5zdWJ0cmFjdFRvUmVmKHRoaXMuX29sZFBvc2l0aW9uLHRoaXMuX2RpZmZQb3NpdGlvbiksdGhpcy5fZGlmZlBvc2l0aW9uLmxlbmd0aCgpPmEuRW5naW5lLkNvbGxpc2lvbnNFcHNpbG9uJiYodGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuX2RpZmZQb3NpdGlvbiksdGhpcy5vbkNvbGxpZGUmJnRoaXMub25Db2xsaWRlKHRoaXMuX2NvbGxpZGVyLmNvbGxpZGVkTWVzaCkpfSxjLnByb3RvdHlwZS5fY2hlY2tJbnB1dHM9ZnVuY3Rpb24oKXt0aGlzLl9sb2NhbERpcmVjdGlvbnx8KHRoaXMuX2xvY2FsRGlyZWN0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSk7Zm9yKHZhciBiPTA7Yjx0aGlzLl9rZXlzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX2tleXNbYl0sZD10aGlzLl9jb21wdXRlTG9jYWxDYW1lcmFTcGVlZCgpOy0xIT09dGhpcy5rZXlzTGVmdC5pbmRleE9mKGMpP3RoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKC1kLDAsMCk6LTEhPT10aGlzLmtleXNVcC5pbmRleE9mKGMpP3RoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKDAsMCxkKTotMSE9PXRoaXMua2V5c1JpZ2h0LmluZGV4T2YoYyk/dGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoZCwwLDApOi0xIT09dGhpcy5rZXlzRG93bi5pbmRleE9mKGMpJiZ0aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cygwLDAsLWQpLHRoaXMuZ2V0Vmlld01hdHJpeCgpLmludmVydFRvUmVmKHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKHRoaXMuX2xvY2FsRGlyZWN0aW9uLHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCx0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbiksdGhpcy5jYW1lcmFEaXJlY3Rpb24uYWRkSW5QbGFjZSh0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbil9fSxjLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fY2hlY2tJbnB1dHMoKTt2YXIgYj10aGlzLl9uZWVkTW92ZUZvckdyYXZpdHl8fE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLngpPjB8fE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnkpPjB8fE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnopPjAsYz1NYXRoLmFicyh0aGlzLmNhbWVyYVJvdGF0aW9uLngpPjB8fE1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueSk+MDtpZihiKWlmKHRoaXMuY2hlY2tDb2xsaXNpb25zJiZ0aGlzLmdldFNjZW5lKCkuY29sbGlzaW9uc0VuYWJsZWQpe2lmKHRoaXMuX2NvbGxpZGVXaXRoV29ybGQodGhpcy5jYW1lcmFEaXJlY3Rpb24pLHRoaXMuYXBwbHlHcmF2aXR5KXt2YXIgZD10aGlzLnBvc2l0aW9uO3RoaXMuX2NvbGxpZGVXaXRoV29ybGQodGhpcy5nZXRTY2VuZSgpLmdyYXZpdHkpLHRoaXMuX25lZWRNb3ZlRm9yR3Jhdml0eT0wIT1hLlZlY3RvcjMuRGlzdGFuY2VTcXVhcmVkKGQsdGhpcy5wb3NpdGlvbil9fWVsc2UgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuY2FtZXJhRGlyZWN0aW9uKTtpZihjJiYodGhpcy5yb3RhdGlvbi54Kz10aGlzLmNhbWVyYVJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi55Kz10aGlzLmNhbWVyYVJvdGF0aW9uLnksIXRoaXMubm9Sb3RhdGlvbkNvbnN0cmFpbnQpKXt2YXIgZT1NYXRoLlBJLzIqLjk1O3RoaXMucm90YXRpb24ueD5lJiYodGhpcy5yb3RhdGlvbi54PWUpLHRoaXMucm90YXRpb24ueDwtZSYmKHRoaXMucm90YXRpb24ueD0tZSl9YiYmKE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLngpPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmNhbWVyYURpcmVjdGlvbi54PTApLE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnkpPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmNhbWVyYURpcmVjdGlvbi55PTApLE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnopPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmNhbWVyYURpcmVjdGlvbi56PTApLHRoaXMuY2FtZXJhRGlyZWN0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWEpKSxjJiYoTWF0aC5hYnModGhpcy5jYW1lcmFSb3RhdGlvbi54KTxhLkVuZ2luZS5FcHNpbG9uJiYodGhpcy5jYW1lcmFSb3RhdGlvbi54PTApLE1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueSk8YS5FbmdpbmUuRXBzaWxvbiYmKHRoaXMuY2FtZXJhUm90YXRpb24ueT0wKSx0aGlzLmNhbWVyYVJvdGF0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWEpKX0sYy5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NrZWRUYXJnZXQ/dGhpcy5fY3VycmVudFRhcmdldC5jb3B5RnJvbSh0aGlzLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbigpKTooMCE9dGhpcy51cFZlY3Rvci54fHwxIT10aGlzLnVwVmVjdG9yLnl8fDAhPXRoaXMudXBWZWN0b3Iuej8oYS5NYXRyaXguTG9va0F0TEhUb1JlZihhLlZlY3RvcjMuWmVybygpLHRoaXMuX3JlZmVyZW5jZVBvaW50LHRoaXMudXBWZWN0b3IsdGhpcy5fbG9va0F0VGVtcCksYS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksdGhpcy5yb3RhdGlvbi54LHRoaXMucm90YXRpb24ueix0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCksdGhpcy5fbG9va0F0VGVtcC5tdWx0aXBseVRvUmVmKHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LHRoaXMuX3RlbXBNYXRyaXgpLHRoaXMuX2xvb2tBdFRlbXAuaW52ZXJ0KCksdGhpcy5fdGVtcE1hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX2xvb2tBdFRlbXAsdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpKTphLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi56LHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZih0aGlzLl9yZWZlcmVuY2VQb2ludCx0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCx0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50KSx0aGlzLnBvc2l0aW9uLmFkZFRvUmVmKHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQsdGhpcy5fY3VycmVudFRhcmdldCkpLGEuTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbix0aGlzLl9jdXJyZW50VGFyZ2V0LHRoaXMudXBWZWN0b3IsdGhpcy5fdmlld01hdHJpeCksdGhpcy5fdmlld01hdHJpeH0sY30oYS5DYW1lcmEpO2EuRnJlZUNhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCl7Yi5jYWxsKHRoaXMsYSxjLGQpLHRoaXMuX29mZnNldFg9bnVsbCx0aGlzLl9vZmZzZXRZPW51bGwsdGhpcy5fcG9pbnRlckNvdW50PTAsdGhpcy5fcG9pbnRlclByZXNzZWQ9W10sdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHk9MmU1LHRoaXMubW92ZVNlbnNpYmlsaXR5PTUwMH1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuYXR0YWNoQ29udHJvbD1mdW5jdGlvbihiLGMpe3ZhciBkLGU9dGhpczt0aGlzLl9hdHRhY2hlZENhbnZhc3x8KHRoaXMuX2F0dGFjaGVkQ2FudmFzPWIsdm9pZCAwPT09dGhpcy5fb25Qb2ludGVyRG93biYmKHRoaXMuX29uUG9pbnRlckRvd249ZnVuY3Rpb24oYSl7Y3x8YS5wcmV2ZW50RGVmYXVsdCgpLGUuX3BvaW50ZXJQcmVzc2VkLnB1c2goYS5wb2ludGVySWQpLDE9PT1lLl9wb2ludGVyUHJlc3NlZC5sZW5ndGgmJihkPXt4OmEuY2xpZW50WCx5OmEuY2xpZW50WX0pfSx0aGlzLl9vblBvaW50ZXJVcD1mdW5jdGlvbihhKXtjfHxhLnByZXZlbnREZWZhdWx0KCk7dmFyIGI9ZS5fcG9pbnRlclByZXNzZWQuaW5kZXhPZihhLnBvaW50ZXJJZCk7LTEhPT1iJiYoZS5fcG9pbnRlclByZXNzZWQuc3BsaWNlKGIsMSksMD09YiYmKGQ9bnVsbCxlLl9vZmZzZXRYPW51bGwsZS5fb2Zmc2V0WT1udWxsKSl9LHRoaXMuX29uUG9pbnRlck1vdmU9ZnVuY3Rpb24oYSl7aWYoY3x8YS5wcmV2ZW50RGVmYXVsdCgpLGQpe3ZhciBiPWUuX3BvaW50ZXJQcmVzc2VkLmluZGV4T2YoYS5wb2ludGVySWQpOzA9PWImJihlLl9vZmZzZXRYPWEuY2xpZW50WC1kLngsZS5fb2Zmc2V0WT0tKGEuY2xpZW50WS1kLnkpKX19LHRoaXMuX29uTG9zdEZvY3VzPWZ1bmN0aW9uKCl7ZS5fb2Zmc2V0WD1udWxsLGUuX29mZnNldFk9bnVsbH0pLGIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsdGhpcy5fb25Qb2ludGVyRG93biksYi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsdGhpcy5fb25Qb2ludGVyVXApLGIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdXRcIix0aGlzLl9vblBvaW50ZXJVcCksYi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIix0aGlzLl9vblBvaW50ZXJNb3ZlKSxhLlRvb2xzLlJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbe25hbWU6XCJibHVyXCIsaGFuZGxlcjp0aGlzLl9vbkxvc3RGb2N1c31dKSl9LGMucHJvdG90eXBlLmRldGFjaENvbnRyb2w9ZnVuY3Rpb24oYil7dGhpcy5fYXR0YWNoZWRDYW52YXM9PWImJihiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLHRoaXMuX29uUG9pbnRlckRvd24pLGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLHRoaXMuX29uUG9pbnRlclVwKSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3V0XCIsdGhpcy5fb25Qb2ludGVyVXApLGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsdGhpcy5fb25Qb2ludGVyTW92ZSksYS5Ub29scy5VbnJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbe25hbWU6XCJibHVyXCIsaGFuZGxlcjp0aGlzLl9vbkxvc3RGb2N1c31dKSx0aGlzLl9hdHRhY2hlZENhbnZhcz1udWxsKX0sYy5wcm90b3R5cGUuX2NoZWNrSW5wdXRzPWZ1bmN0aW9uKCl7aWYodGhpcy5fb2Zmc2V0WClpZih0aGlzLmNhbWVyYVJvdGF0aW9uLnkrPXRoaXMuX29mZnNldFgvdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHksdGhpcy5fcG9pbnRlclByZXNzZWQubGVuZ3RoPjEpdGhpcy5jYW1lcmFSb3RhdGlvbi54Kz0tdGhpcy5fb2Zmc2V0WS90aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eTtlbHNle3ZhciBiPXRoaXMuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkKCksYz1uZXcgYS5WZWN0b3IzKDAsMCxiKnRoaXMuX29mZnNldFkvdGhpcy5tb3ZlU2Vuc2liaWxpdHkpO2EuTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCwwLHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KSx0aGlzLmNhbWVyYURpcmVjdGlvbi5hZGRJblBsYWNlKGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhjLHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KSl9fSxjfShhLkZyZWVDYW1lcmEpO2EuVG91Y2hDYW1lcmE9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQpe3ZhciBlPXRoaXM7Yi5jYWxsKHRoaXMsYSxjLGQpLHRoaXMuX29mZnNldFg9bnVsbCx0aGlzLl9vZmZzZXRZPW51bGwsdGhpcy5fb3JpZW50YXRpb25HYW1tYT0wLHRoaXMuX29yaWVudGF0aW9uQmV0YT0wLHRoaXMuX2luaXRpYWxPcmllbnRhdGlvbkdhbW1hPTAsdGhpcy5faW5pdGlhbE9yaWVudGF0aW9uQmV0YT0wLHRoaXMuYW5ndWxhclNlbnNpYmlsaXR5PTFlNCx0aGlzLm1vdmVTZW5zaWJpbGl0eT01MCx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLGZ1bmN0aW9uKCl7ZS5faW5pdGlhbE9yaWVudGF0aW9uR2FtbWE9bnVsbH0sITEpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5fYXR0YWNoZWRDYW52YXN8fCh0aGlzLl9hdHRhY2hlZENhbnZhcz1hLHRoaXMuX29yaWVudGF0aW9uQ2hhbmdlZHx8KHRoaXMuX29yaWVudGF0aW9uQ2hhbmdlZD1mdW5jdGlvbihhKXtiLl9pbml0aWFsT3JpZW50YXRpb25HYW1tYXx8KGIuX2luaXRpYWxPcmllbnRhdGlvbkdhbW1hPWEuZ2FtbWEsYi5faW5pdGlhbE9yaWVudGF0aW9uQmV0YT1hLmJldGEpLGIuX29yaWVudGF0aW9uR2FtbWE9YS5nYW1tYSxiLl9vcmllbnRhdGlvbkJldGE9YS5iZXRhLGIuX29mZnNldFk9Yi5faW5pdGlhbE9yaWVudGF0aW9uQmV0YS1iLl9vcmllbnRhdGlvbkJldGEsYi5fb2Zmc2V0WD1iLl9pbml0aWFsT3JpZW50YXRpb25HYW1tYS1iLl9vcmllbnRhdGlvbkdhbW1hfSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLHRoaXMuX29yaWVudGF0aW9uQ2hhbmdlZCkpfSxjLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKGEpe3RoaXMuX2F0dGFjaGVkQ2FudmFzPT1hJiYod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLHRoaXMuX29yaWVudGF0aW9uQ2hhbmdlZCksdGhpcy5fYXR0YWNoZWRDYW52YXM9bnVsbCx0aGlzLl9vcmllbnRhdGlvbkdhbW1hPTAsdGhpcy5fb3JpZW50YXRpb25CZXRhPTAsdGhpcy5faW5pdGlhbE9yaWVudGF0aW9uR2FtbWE9MCx0aGlzLl9pbml0aWFsT3JpZW50YXRpb25CZXRhPTApfSxjLnByb3RvdHlwZS5fY2hlY2tJbnB1dHM9ZnVuY3Rpb24oKXtpZih0aGlzLl9vZmZzZXRYKXt0aGlzLmNhbWVyYVJvdGF0aW9uLnktPXRoaXMuX29mZnNldFgvdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHk7dmFyIGI9dGhpcy5fY29tcHV0ZUxvY2FsQ2FtZXJhU3BlZWQoKSxjPW5ldyBhLlZlY3RvcjMoMCwwLGIqdGhpcy5fb2Zmc2V0WS90aGlzLm1vdmVTZW5zaWJpbGl0eSk7YS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksdGhpcy5yb3RhdGlvbi54LDAsdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpLHRoaXMuY2FtZXJhRGlyZWN0aW9uLmFkZEluUGxhY2UoYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGMsdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpKX19LGN9KGEuRnJlZUNhbWVyYSk7YS5EZXZpY2VPcmllbnRhdGlvbkNhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9YS5Ub29scy5HZXRQb2ludGVyUHJlZml4KCksYz1mdW5jdGlvbihjKXtmdW5jdGlvbiBkKGIsZCxlLGYsZyxoKXtjLmNhbGwodGhpcyxiLGEuVmVjdG9yMy5aZXJvKCksaCksdGhpcy5hbHBoYT1kLHRoaXMuYmV0YT1lLHRoaXMucmFkaXVzPWYsdGhpcy50YXJnZXQ9Zyx0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQ9MCx0aGlzLmluZXJ0aWFsQmV0YU9mZnNldD0wLHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQ9MCx0aGlzLmxvd2VyQWxwaGFMaW1pdD1udWxsLHRoaXMudXBwZXJBbHBoYUxpbWl0PW51bGwsdGhpcy5sb3dlckJldGFMaW1pdD0uMDEsdGhpcy51cHBlckJldGFMaW1pdD1NYXRoLlBJLHRoaXMubG93ZXJSYWRpdXNMaW1pdD1udWxsLHRoaXMudXBwZXJSYWRpdXNMaW1pdD1udWxsLHRoaXMuYW5ndWxhclNlbnNpYmlsaXR5PTFlMyx0aGlzLndoZWVsUHJlY2lzaW9uPTMsdGhpcy5rZXlzVXA9WzM4XSx0aGlzLmtleXNEb3duPVs0MF0sdGhpcy5rZXlzTGVmdD1bMzddLHRoaXMua2V5c1JpZ2h0PVszOV0sdGhpcy56b29tT25GYWN0b3I9MSx0aGlzLl9rZXlzPVtdLHRoaXMuX3ZpZXdNYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuY2hlY2tDb2xsaXNpb25zPSExLHRoaXMuY29sbGlzaW9uUmFkaXVzPW5ldyBhLlZlY3RvcjMoLjUsLjUsLjUpLHRoaXMuX2NvbGxpZGVyPW5ldyBhLkNvbGxpZGVyLHRoaXMuX3ByZXZpb3VzUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9jb2xsaXNpb25WZWxvY2l0eT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX25ld1Bvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5nZXRWaWV3TWF0cml4KCl9cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLl9nZXRUYXJnZXRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRhcmdldC5wb3NpdGlvbnx8dGhpcy50YXJnZXR9LGQucHJvdG90eXBlLl9pbml0Q2FjaGU9ZnVuY3Rpb24oKXtjLnByb3RvdHlwZS5faW5pdENhY2hlLmNhbGwodGhpcyksdGhpcy5fY2FjaGUudGFyZ2V0PW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpLHRoaXMuX2NhY2hlLmFscGhhPXZvaWQgMCx0aGlzLl9jYWNoZS5iZXRhPXZvaWQgMCx0aGlzLl9jYWNoZS5yYWRpdXM9dm9pZCAwfSxkLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGU9ZnVuY3Rpb24oYSl7YXx8Yy5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlLmNhbGwodGhpcyksdGhpcy5fY2FjaGUudGFyZ2V0LmNvcHlGcm9tKHRoaXMuX2dldFRhcmdldFBvc2l0aW9uKCkpLHRoaXMuX2NhY2hlLmFscGhhPXRoaXMuYWxwaGEsdGhpcy5fY2FjaGUuYmV0YT10aGlzLmJldGEsdGhpcy5fY2FjaGUucmFkaXVzPXRoaXMucmFkaXVzfSxkLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIGMucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXguY2FsbCh0aGlzKT90aGlzLl9jYWNoZS50YXJnZXQuZXF1YWxzKHRoaXMuX2dldFRhcmdldFBvc2l0aW9uKCkpJiZ0aGlzLl9jYWNoZS5hbHBoYT09PXRoaXMuYWxwaGEmJnRoaXMuX2NhY2hlLmJldGE9PT10aGlzLmJldGEmJnRoaXMuX2NhY2hlLnJhZGl1cz09PXRoaXMucmFkaXVzOiExfSxkLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKGMsZCl7dmFyIGUsZixnPXRoaXM7aWYoIXRoaXMuX2F0dGFjaGVkRWxlbWVudCl7dGhpcy5fYXR0YWNoZWRFbGVtZW50PWM7dmFyIGg9dGhpcy5nZXRFbmdpbmUoKTt2b2lkIDA9PT10aGlzLl9vblBvaW50ZXJEb3duJiYodGhpcy5fb25Qb2ludGVyRG93bj1mdW5jdGlvbihhKXtmfHwoZj1hLnBvaW50ZXJJZCxlPXt4OmEuY2xpZW50WCx5OmEuY2xpZW50WX0sZHx8YS5wcmV2ZW50RGVmYXVsdCgpKX0sdGhpcy5fb25Qb2ludGVyVXA9ZnVuY3Rpb24oYSl7ZT1udWxsLGY9bnVsbCxkfHxhLnByZXZlbnREZWZhdWx0KCl9LHRoaXMuX29uUG9pbnRlck1vdmU9ZnVuY3Rpb24oYSl7aWYoZSYmZj09PWEucG9pbnRlcklkKXt2YXIgYj1hLmNsaWVudFgtZS54LGM9YS5jbGllbnRZLWUueTtnLmluZXJ0aWFsQWxwaGFPZmZzZXQtPWIvZy5hbmd1bGFyU2Vuc2liaWxpdHksZy5pbmVydGlhbEJldGFPZmZzZXQtPWMvZy5hbmd1bGFyU2Vuc2liaWxpdHksZT17eDphLmNsaWVudFgseTphLmNsaWVudFl9LGR8fGEucHJldmVudERlZmF1bHQoKX19LHRoaXMuX29uTW91c2VNb3ZlPWZ1bmN0aW9uKGEpe2lmKGguaXNQb2ludGVyTG9jayl7dmFyIGI9YS5tb3ZlbWVudFh8fGEubW96TW92ZW1lbnRYfHxhLndlYmtpdE1vdmVtZW50WHx8YS5tc01vdmVtZW50WHx8MCxjPWEubW92ZW1lbnRZfHxhLm1vek1vdmVtZW50WXx8YS53ZWJraXRNb3ZlbWVudFl8fGEubXNNb3ZlbWVudFl8fDA7Zy5pbmVydGlhbEFscGhhT2Zmc2V0LT1iL2cuYW5ndWxhclNlbnNpYmlsaXR5LGcuaW5lcnRpYWxCZXRhT2Zmc2V0LT1jL2cuYW5ndWxhclNlbnNpYmlsaXR5LGR8fGEucHJldmVudERlZmF1bHQoKX19LHRoaXMuX3doZWVsPWZ1bmN0aW9uKGEpe3ZhciBiPTA7YS53aGVlbERlbHRhP2I9YS53aGVlbERlbHRhLyg0MCpnLndoZWVsUHJlY2lzaW9uKTphLmRldGFpbCYmKGI9LWEuZGV0YWlsL2cud2hlZWxQcmVjaXNpb24pLGImJihnLmluZXJ0aWFsUmFkaXVzT2Zmc2V0Kz1iKSxhLnByZXZlbnREZWZhdWx0JiYoZHx8YS5wcmV2ZW50RGVmYXVsdCgpKX0sdGhpcy5fb25LZXlEb3duPWZ1bmN0aW9uKGEpe2lmKC0xIT09Zy5rZXlzVXAuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWcua2V5c0Rvd24uaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWcua2V5c0xlZnQuaW5kZXhPZihhLmtleUNvZGUpfHwtMSE9PWcua2V5c1JpZ2h0LmluZGV4T2YoYS5rZXlDb2RlKSl7dmFyIGI9Zy5fa2V5cy5pbmRleE9mKGEua2V5Q29kZSk7LTE9PT1iJiZnLl9rZXlzLnB1c2goYS5rZXlDb2RlKSxhLnByZXZlbnREZWZhdWx0JiYoZHx8YS5wcmV2ZW50RGVmYXVsdCgpKX19LHRoaXMuX29uS2V5VXA9ZnVuY3Rpb24oYSl7aWYoLTEhPT1nLmtleXNVcC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzRG93bi5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzTGVmdC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzUmlnaHQuaW5kZXhPZihhLmtleUNvZGUpKXt2YXIgYj1nLl9rZXlzLmluZGV4T2YoYS5rZXlDb2RlKTtiPj0wJiZnLl9rZXlzLnNwbGljZShiLDEpLGEucHJldmVudERlZmF1bHQmJihkfHxhLnByZXZlbnREZWZhdWx0KCkpfX0sdGhpcy5fb25Mb3N0Rm9jdXM9ZnVuY3Rpb24oKXtnLl9rZXlzPVtdLGY9bnVsbH0sdGhpcy5fb25HZXN0dXJlU3RhcnQ9ZnVuY3Rpb24oYSl7dm9pZCAwIT09d2luZG93Lk1TR2VzdHVyZSYmKGcuX01TR2VzdHVyZUhhbmRsZXJ8fChnLl9NU0dlc3R1cmVIYW5kbGVyPW5ldyBNU0dlc3R1cmUsZy5fTVNHZXN0dXJlSGFuZGxlci50YXJnZXQ9YyksZy5fTVNHZXN0dXJlSGFuZGxlci5hZGRQb2ludGVyKGEucG9pbnRlcklkKSl9LHRoaXMuX29uR2VzdHVyZT1mdW5jdGlvbihhKXtnLnJhZGl1cyo9YS5zY2FsZSxhLnByZXZlbnREZWZhdWx0JiYoZHx8KGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKSl9LHRoaXMuX3Jlc2V0PWZ1bmN0aW9uKCl7Zy5fa2V5cz1bXSxnLmluZXJ0aWFsQWxwaGFPZmZzZXQ9MCxnLmluZXJ0aWFsQmV0YU9mZnNldD0wLGcuaW5lcnRpYWxSYWRpdXNPZmZzZXQ9MCxlPW51bGwsZj1udWxsfSksYy5hZGRFdmVudExpc3RlbmVyKGIrXCJkb3duXCIsdGhpcy5fb25Qb2ludGVyRG93biwhMSksYy5hZGRFdmVudExpc3RlbmVyKGIrXCJ1cFwiLHRoaXMuX29uUG9pbnRlclVwLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoYitcIm91dFwiLHRoaXMuX29uUG9pbnRlclVwLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoYitcIm1vdmVcIix0aGlzLl9vblBvaW50ZXJNb3ZlLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9vbk1vdXNlTW92ZSwhMSksYy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLHRoaXMuX29uR2VzdHVyZVN0YXJ0LCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoXCJNU0dlc3R1cmVDaGFuZ2VcIix0aGlzLl9vbkdlc3R1cmUsITEpLGMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIix0aGlzLl93aGVlbCwhMSksYy5hZGRFdmVudExpc3RlbmVyKFwiRE9NTW91c2VTY3JvbGxcIix0aGlzLl93aGVlbCwhMSksYS5Ub29scy5SZWdpc3RlclRvcFJvb3RFdmVudHMoW3tuYW1lOlwia2V5ZG93blwiLGhhbmRsZXI6dGhpcy5fb25LZXlEb3dufSx7bmFtZTpcImtleXVwXCIsaGFuZGxlcjp0aGlzLl9vbktleVVwfSx7bmFtZTpcImJsdXJcIixoYW5kbGVyOnRoaXMuX29uTG9zdEZvY3VzfV0pfX0sZC5wcm90b3R5cGUuZGV0YWNoQ29udHJvbD1mdW5jdGlvbihjKXt0aGlzLl9hdHRhY2hlZEVsZW1lbnQ9PWMmJihjLnJlbW92ZUV2ZW50TGlzdGVuZXIoYitcImRvd25cIix0aGlzLl9vblBvaW50ZXJEb3duKSxjLnJlbW92ZUV2ZW50TGlzdGVuZXIoYitcInVwXCIsdGhpcy5fb25Qb2ludGVyVXApLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1wib3V0XCIsdGhpcy5fb25Qb2ludGVyVXApLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1wibW92ZVwiLHRoaXMuX29uUG9pbnRlck1vdmUpLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlKSxjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsdGhpcy5fb25HZXN0dXJlU3RhcnQpLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TR2VzdHVyZUNoYW5nZVwiLHRoaXMuX29uR2VzdHVyZSksYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLHRoaXMuX3doZWVsKSxjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLHRoaXMuX3doZWVsKSxhLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFt7bmFtZTpcImtleWRvd25cIixoYW5kbGVyOnRoaXMuX29uS2V5RG93bn0se25hbWU6XCJrZXl1cFwiLGhhbmRsZXI6dGhpcy5fb25LZXlVcH0se25hbWU6XCJibHVyXCIsaGFuZGxlcjp0aGlzLl9vbkxvc3RGb2N1c31dKSx0aGlzLl9NU0dlc3R1cmVIYW5kbGVyPW51bGwsdGhpcy5fYXR0YWNoZWRFbGVtZW50PW51bGwsdGhpcy5fcmVzZXQmJnRoaXMuX3Jlc2V0KCkpfSxkLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPTA7Yjx0aGlzLl9rZXlzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX2tleXNbYl07LTEhPT10aGlzLmtleXNMZWZ0LmluZGV4T2YoYyk/dGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0LT0uMDE6LTEhPT10aGlzLmtleXNVcC5pbmRleE9mKGMpP3RoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0LT0uMDE6LTEhPT10aGlzLmtleXNSaWdodC5pbmRleE9mKGMpP3RoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCs9LjAxOi0xIT09dGhpcy5rZXlzRG93bi5pbmRleE9mKGMpJiYodGhpcy5pbmVydGlhbEJldGFPZmZzZXQrPS4wMSl9KDAhPXRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldHx8MCE9dGhpcy5pbmVydGlhbEJldGFPZmZzZXR8fDAhPXRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQpJiYodGhpcy5hbHBoYSs9dGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0LHRoaXMuYmV0YSs9dGhpcy5pbmVydGlhbEJldGFPZmZzZXQsdGhpcy5yYWRpdXMtPXRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQsdGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0Kj10aGlzLmluZXJ0aWEsdGhpcy5pbmVydGlhbEJldGFPZmZzZXQqPXRoaXMuaW5lcnRpYSx0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0Kj10aGlzLmluZXJ0aWEsTWF0aC5hYnModGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0KTxhLkVuZ2luZS5FcHNpbG9uJiYodGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0PTApLE1hdGguYWJzKHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0KTxhLkVuZ2luZS5FcHNpbG9uJiYodGhpcy5pbmVydGlhbEJldGFPZmZzZXQ9MCksTWF0aC5hYnModGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCk8YS5FbmdpbmUuRXBzaWxvbiYmKHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQ9MCkpLHRoaXMubG93ZXJBbHBoYUxpbWl0JiZ0aGlzLmFscGhhPHRoaXMubG93ZXJBbHBoYUxpbWl0JiYodGhpcy5hbHBoYT10aGlzLmxvd2VyQWxwaGFMaW1pdCksdGhpcy51cHBlckFscGhhTGltaXQmJnRoaXMuYWxwaGE+dGhpcy51cHBlckFscGhhTGltaXQmJih0aGlzLmFscGhhPXRoaXMudXBwZXJBbHBoYUxpbWl0KSx0aGlzLmxvd2VyQmV0YUxpbWl0JiZ0aGlzLmJldGE8dGhpcy5sb3dlckJldGFMaW1pdCYmKHRoaXMuYmV0YT10aGlzLmxvd2VyQmV0YUxpbWl0KSx0aGlzLnVwcGVyQmV0YUxpbWl0JiZ0aGlzLmJldGE+dGhpcy51cHBlckJldGFMaW1pdCYmKHRoaXMuYmV0YT10aGlzLnVwcGVyQmV0YUxpbWl0KSx0aGlzLmxvd2VyUmFkaXVzTGltaXQmJnRoaXMucmFkaXVzPHRoaXMubG93ZXJSYWRpdXNMaW1pdCYmKHRoaXMucmFkaXVzPXRoaXMubG93ZXJSYWRpdXNMaW1pdCksdGhpcy51cHBlclJhZGl1c0xpbWl0JiZ0aGlzLnJhZGl1cz50aGlzLnVwcGVyUmFkaXVzTGltaXQmJih0aGlzLnJhZGl1cz10aGlzLnVwcGVyUmFkaXVzTGltaXQpfSxkLnByb3RvdHlwZS5zZXRQb3NpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1hLnN1YnRyYWN0KHRoaXMuX2dldFRhcmdldFBvc2l0aW9uKCkpO3RoaXMucmFkaXVzPWIubGVuZ3RoKCksdGhpcy5hbHBoYT1NYXRoLmFjb3MoYi54L01hdGguc3FydChNYXRoLnBvdyhiLngsMikrTWF0aC5wb3coYi56LDIpKSksYi56PDAmJih0aGlzLmFscGhhPTIqTWF0aC5QSS10aGlzLmFscGhhKSx0aGlzLmJldGE9TWF0aC5hY29zKGIueS90aGlzLnJhZGl1cyl9LGQucHJvdG90eXBlLl9nZXRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7dmFyIGI9TWF0aC5jb3ModGhpcy5hbHBoYSksYz1NYXRoLnNpbih0aGlzLmFscGhhKSxkPU1hdGguY29zKHRoaXMuYmV0YSksZT1NYXRoLnNpbih0aGlzLmJldGEpLGY9dGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKTtyZXR1cm4gZi5hZGRUb1JlZihuZXcgYS5WZWN0b3IzKHRoaXMucmFkaXVzKmIqZSx0aGlzLnJhZGl1cypkLHRoaXMucmFkaXVzKmMqZSksdGhpcy5wb3NpdGlvbiksdGhpcy5jaGVja0NvbGxpc2lvbnMmJih0aGlzLl9jb2xsaWRlci5yYWRpdXM9dGhpcy5jb2xsaXNpb25SYWRpdXMsdGhpcy5wb3NpdGlvbi5zdWJ0cmFjdFRvUmVmKHRoaXMuX3ByZXZpb3VzUG9zaXRpb24sdGhpcy5fY29sbGlzaW9uVmVsb2NpdHkpLHRoaXMuZ2V0U2NlbmUoKS5fZ2V0TmV3UG9zaXRpb24odGhpcy5fcHJldmlvdXNQb3NpdGlvbix0aGlzLl9jb2xsaXNpb25WZWxvY2l0eSx0aGlzLl9jb2xsaWRlciwzLHRoaXMuX25ld1Bvc2l0aW9uKSx0aGlzLl9uZXdQb3NpdGlvbi5lcXVhbHNXaXRoRXBzaWxvbih0aGlzLnBvc2l0aW9uKXx8KHRoaXMucG9zaXRpb24uY29weUZyb20odGhpcy5fcHJldmlvdXNQb3NpdGlvbiksdGhpcy5hbHBoYT10aGlzLl9wcmV2aW91c0FscGhhLHRoaXMuYmV0YT10aGlzLl9wcmV2aW91c0JldGEsdGhpcy5yYWRpdXM9dGhpcy5fcHJldmlvdXNSYWRpdXMsdGhpcy5vbkNvbGxpZGUmJnRoaXMub25Db2xsaWRlKHRoaXMuX2NvbGxpZGVyLmNvbGxpZGVkTWVzaCkpKSxhLk1hdHJpeC5Mb29rQXRMSFRvUmVmKHRoaXMucG9zaXRpb24sZix0aGlzLnVwVmVjdG9yLHRoaXMuX3ZpZXdNYXRyaXgpLHRoaXMuX3ByZXZpb3VzQWxwaGE9dGhpcy5hbHBoYSx0aGlzLl9wcmV2aW91c0JldGE9dGhpcy5iZXRhLHRoaXMuX3ByZXZpb3VzUmFkaXVzPXRoaXMucmFkaXVzLHRoaXMuX3ByZXZpb3VzUG9zaXRpb24uY29weUZyb20odGhpcy5wb3NpdGlvbiksdGhpcy5fdmlld01hdHJpeH0sZC5wcm90b3R5cGUuem9vbU9uPWZ1bmN0aW9uKGIpe2I9Ynx8dGhpcy5nZXRTY2VuZSgpLm1lc2hlczt2YXIgYz1hLk1lc2guTWluTWF4KGIpLGQ9YS5WZWN0b3IzLkRpc3RhbmNlKGMubWluLGMubWF4KTt0aGlzLnJhZGl1cz1kKnRoaXMuem9vbU9uRmFjdG9yLHRoaXMuZm9jdXNPbih7bWluOmMubWluLG1heDpjLm1heCxkaXN0YW5jZTpkfSl9LGQucHJvdG90eXBlLmZvY3VzT249ZnVuY3Rpb24oYil7dmFyIGMsZDt2b2lkIDA9PT1iLm1pbj8oYz1ifHx0aGlzLmdldFNjZW5lKCkubWVzaGVzLGM9YS5NZXNoLk1pbk1heChjKSxkPWEuVmVjdG9yMy5EaXN0YW5jZShjLm1pbixjLm1heCkpOihjPWIsZD1iLmRpc3RhbmNlKSx0aGlzLnRhcmdldD1hLk1lc2guQ2VudGVyKGMpLHRoaXMubWF4Wj0yKmR9LGR9KGEuQ2FtZXJhKTthLkFyY1JvdGF0ZUNhbWVyYT1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYil7dGhpcy5hdXRvQ2xlYXI9ITAsdGhpcy5jbGVhckNvbG9yPW5ldyBhLkNvbG9yMyguMiwuMiwuMyksdGhpcy5hbWJpZW50Q29sb3I9bmV3IGEuQ29sb3IzKDAsMCwwKSx0aGlzLmZvcmNlV2lyZWZyYW1lPSExLHRoaXMuY2FtZXJhVG9Vc2VGb3JQb2ludGVycz1udWxsLHRoaXMuZm9nTW9kZT1hLlNjZW5lLkZPR01PREVfTk9ORSx0aGlzLmZvZ0NvbG9yPW5ldyBhLkNvbG9yMyguMiwuMiwuMyksdGhpcy5mb2dEZW5zaXR5PS4xLHRoaXMuZm9nU3RhcnQ9MCx0aGlzLmZvZ0VuZD0xZTMsdGhpcy5saWdodHNFbmFibGVkPSEwLHRoaXMubGlnaHRzPW5ldyBBcnJheSx0aGlzLmNhbWVyYXM9bmV3IEFycmF5LHRoaXMuYWN0aXZlQ2FtZXJhcz1uZXcgQXJyYXksdGhpcy5tZXNoZXM9bmV3IEFycmF5LHRoaXMuX2dlb21ldHJpZXM9bmV3IEFycmF5LHRoaXMubWF0ZXJpYWxzPW5ldyBBcnJheSx0aGlzLm11bHRpTWF0ZXJpYWxzPW5ldyBBcnJheSx0aGlzLmRlZmF1bHRNYXRlcmlhbD1uZXcgYS5TdGFuZGFyZE1hdGVyaWFsKFwiZGVmYXVsdCBtYXRlcmlhbFwiLHRoaXMpLHRoaXMudGV4dHVyZXNFbmFibGVkPSEwLHRoaXMudGV4dHVyZXM9bmV3IEFycmF5LHRoaXMucGFydGljbGVzRW5hYmxlZD0hMCx0aGlzLnBhcnRpY2xlU3lzdGVtcz1uZXcgQXJyYXksdGhpcy5zcHJpdGVNYW5hZ2Vycz1uZXcgQXJyYXksdGhpcy5sYXllcnM9bmV3IEFycmF5LHRoaXMuc2tlbGV0b25zPW5ldyBBcnJheSx0aGlzLmxlbnNGbGFyZVN5c3RlbXM9bmV3IEFycmF5LHRoaXMuY29sbGlzaW9uc0VuYWJsZWQ9ITAsdGhpcy5ncmF2aXR5PW5ldyBhLlZlY3RvcjMoMCwtOSwwKSx0aGlzLnBvc3RQcm9jZXNzZXNFbmFibGVkPSEwLHRoaXMucmVuZGVyVGFyZ2V0c0VuYWJsZWQ9ITAsdGhpcy5jdXN0b21SZW5kZXJUYXJnZXRzPW5ldyBBcnJheSx0aGlzLmltcG9ydGVkTWVzaGVzRmlsZXM9bmV3IEFycmF5LHRoaXMuX2FjdGlvbk1hbmFnZXJzPW5ldyBBcnJheSx0aGlzLl9tZXNoZXNGb3JJbnRlcnNlY3Rpb25zPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl90b3RhbFZlcnRpY2VzPTAsdGhpcy5fYWN0aXZlVmVydGljZXM9MCx0aGlzLl9hY3RpdmVQYXJ0aWNsZXM9MCx0aGlzLl9sYXN0RnJhbWVEdXJhdGlvbj0wLHRoaXMuX2V2YWx1YXRlQWN0aXZlTWVzaGVzRHVyYXRpb249MCx0aGlzLl9yZW5kZXJUYXJnZXRzRHVyYXRpb249MCx0aGlzLl9wYXJ0aWNsZXNEdXJhdGlvbj0wLHRoaXMuX3JlbmRlckR1cmF0aW9uPTAsdGhpcy5fc3ByaXRlc0R1cmF0aW9uPTAsdGhpcy5fYW5pbWF0aW9uUmF0aW89MCx0aGlzLl9yZW5kZXJJZD0wLHRoaXMuX2V4ZWN1dGVXaGVuUmVhZHlUaW1lb3V0SWQ9LTEsdGhpcy5fdG9CZURpc3Bvc2VkPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl9vblJlYWR5Q2FsbGJhY2tzPW5ldyBBcnJheSx0aGlzLl9wZW5kaW5nRGF0YT1bXSx0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcz1uZXcgQXJyYXksdGhpcy5fYWN0aXZlTWVzaGVzPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl9wcm9jZXNzZWRNYXRlcmlhbHM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX3JlbmRlclRhcmdldHM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX2FjdGl2ZVBhcnRpY2xlU3lzdGVtcz1uZXcgYS5TbWFydEFycmF5KDI1NiksdGhpcy5fYWN0aXZlU2tlbGV0b25zPW5ldyBhLlNtYXJ0QXJyYXkoMzIpLHRoaXMuX2FjdGl2ZUFuaW1hdGFibGVzPW5ldyBBcnJheSx0aGlzLl90cmFuc2Zvcm1NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3NjYWxlZFBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fc2NhbGVkVmVsb2NpdHk9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9lbmdpbmU9YixiLnNjZW5lcy5wdXNoKHRoaXMpLHRoaXMuX3JlbmRlcmluZ01hbmFnZXI9bmV3IGEuUmVuZGVyaW5nTWFuYWdlcih0aGlzKSx0aGlzLnBvc3RQcm9jZXNzTWFuYWdlcj1uZXcgYS5Qb3N0UHJvY2Vzc01hbmFnZXIodGhpcyksdGhpcy5wb3N0UHJvY2Vzc1JlbmRlclBpcGVsaW5lTWFuYWdlcj1uZXcgYS5Qb3N0UHJvY2Vzc1JlbmRlclBpcGVsaW5lTWFuYWdlcix0aGlzLl9ib3VuZGluZ0JveFJlbmRlcmVyPW5ldyBhLkJvdW5kaW5nQm94UmVuZGVyZXIodGhpcyksdGhpcy5hdHRhY2hDb250cm9sKCl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcIm1lc2hVbmRlclBvaW50ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21lc2hVbmRlclBvaW50ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwicG9pbnRlclhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvaW50ZXJYfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcInBvaW50ZXJZXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyWX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveFJlbmRlcmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXJ9LGIucHJvdG90eXBlLmdldEVuZ2luZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmdpbmV9LGIucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG90YWxWZXJ0aWNlc30sYi5wcm90b3R5cGUuZ2V0QWN0aXZlVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWN0aXZlVmVydGljZXN9LGIucHJvdG90eXBlLmdldEFjdGl2ZVBhcnRpY2xlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hY3RpdmVQYXJ0aWNsZXN9LGIucHJvdG90eXBlLmdldExhc3RGcmFtZUR1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xhc3RGcmFtZUR1cmF0aW9ufSxiLnByb3RvdHlwZS5nZXRFdmFsdWF0ZUFjdGl2ZU1lc2hlc0R1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2V2YWx1YXRlQWN0aXZlTWVzaGVzRHVyYXRpb259LGIucHJvdG90eXBlLmdldEFjdGl2ZU1lc2hlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hY3RpdmVNZXNoZXN9LGIucHJvdG90eXBlLmdldFJlbmRlclRhcmdldHNEdXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJUYXJnZXRzRHVyYXRpb259LGIucHJvdG90eXBlLmdldFJlbmRlckR1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlckR1cmF0aW9ufSxiLnByb3RvdHlwZS5nZXRQYXJ0aWNsZXNEdXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJ0aWNsZXNEdXJhdGlvbn0sYi5wcm90b3R5cGUuZ2V0U3ByaXRlc0R1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nwcml0ZXNEdXJhdGlvbn0sYi5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uUmF0aW89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYW5pbWF0aW9uUmF0aW99LGIucHJvdG90eXBlLmdldFJlbmRlcklkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlcklkfSxiLnByb3RvdHlwZS5fdXBkYXRlUG9pbnRlclBvc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2VuZ2luZS5nZXRSZW5kZXJpbmdDYW52YXNDbGllbnRSZWN0KCk7dGhpcy5fcG9pbnRlclg9YS5jbGllbnRYLWIubGVmdCx0aGlzLl9wb2ludGVyWT1hLmNsaWVudFktYi50b3AsdGhpcy5jYW1lcmFUb1VzZUZvclBvaW50ZXJzJiYodGhpcy5fcG9pbnRlclg9dGhpcy5fcG9pbnRlclgtdGhpcy5jYW1lcmFUb1VzZUZvclBvaW50ZXJzLnZpZXdwb3J0LngqdGhpcy5fZW5naW5lLmdldFJlbmRlcldpZHRoKCksdGhpcy5fcG9pbnRlclk9dGhpcy5fcG9pbnRlclktdGhpcy5jYW1lcmFUb1VzZUZvclBvaW50ZXJzLnZpZXdwb3J0LnkqdGhpcy5fZW5naW5lLmdldFJlbmRlckhlaWdodCgpKX0sYi5wcm90b3R5cGUuYXR0YWNoQ29udHJvbD1mdW5jdGlvbigpe3ZhciBiPXRoaXM7dGhpcy5fb25Qb2ludGVyTW92ZT1mdW5jdGlvbihhKXt2YXIgYz1iLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCk7Yi5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGEpO3ZhciBkPWIucGljayhiLl9wb2ludGVyWCxiLl9wb2ludGVyWSxmdW5jdGlvbihhKXtyZXR1cm4gYS5pc1BpY2thYmxlJiZhLmlzVmlzaWJsZSYmYS5pc1JlYWR5KCkmJmEuYWN0aW9uTWFuYWdlciYmYS5hY3Rpb25NYW5hZ2VyLmhhc1BvaW50ZXJUcmlnZ2Vyc30sITEsYi5jYW1lcmFUb1VzZUZvclBvaW50ZXJzKTtkLmhpdD8oYi5zZXRQb2ludGVyT3Zlck1lc2goZC5waWNrZWRNZXNoKSxjLnN0eWxlLmN1cnNvcj1cInBvaW50ZXJcIixiLl9tZXNoVW5kZXJQb2ludGVyPWQucGlja2VkTWVzaCk6KGIuc2V0UG9pbnRlck92ZXJNZXNoKG51bGwpLGMuc3R5bGUuY3Vyc29yPVwiXCIsYi5fbWVzaFVuZGVyUG9pbnRlcj1udWxsKX0sdGhpcy5fb25Qb2ludGVyRG93bj1mdW5jdGlvbihjKXt2YXIgZD1udWxsO2Iub25Qb2ludGVyRG93bnx8KGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaXNQaWNrYWJsZSYmYS5pc1Zpc2libGUmJmEuaXNSZWFkeSgpJiZhLmFjdGlvbk1hbmFnZXImJmEuYWN0aW9uTWFuYWdlci5oYXNQaWNrVHJpZ2dlcnN9KSxiLl91cGRhdGVQb2ludGVyUG9zaXRpb24oYyk7dmFyIGU9Yi5waWNrKGIuX3BvaW50ZXJYLGIuX3BvaW50ZXJZLGQsITEsYi5jYW1lcmFUb1VzZUZvclBvaW50ZXJzKTtpZihlLmhpdCYmZS5waWNrZWRNZXNoLmFjdGlvbk1hbmFnZXIpe3N3aXRjaChjLmJ1dHRvbil7Y2FzZSAwOmUucGlja2VkTWVzaC5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PbkxlZnRQaWNrVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyhlLnBpY2tlZE1lc2gpKTticmVhaztjYXNlIDE6ZS5waWNrZWRNZXNoLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uQ2VudGVyUGlja1RyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXcoZS5waWNrZWRNZXNoKSk7YnJlYWs7Y2FzZSAyOmUucGlja2VkTWVzaC5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PblJpZ2h0UGlja1RyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXcoZS5waWNrZWRNZXNoKSl9ZS5waWNrZWRNZXNoLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uUGlja1RyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXcoZS5waWNrZWRNZXNoKSl9Yi5vblBvaW50ZXJEb3duJiZiLm9uUG9pbnRlckRvd24oYyxlKX0sdGhpcy5fb25LZXlEb3duPWZ1bmN0aW9uKGMpe2IuYWN0aW9uTWFuYWdlciYmYi5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PbktleURvd25UcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3RnJvbVNjZW5lKGIsYykpfSx0aGlzLl9vbktleVVwPWZ1bmN0aW9uKGMpe2IuYWN0aW9uTWFuYWdlciYmYi5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PbktleVVwVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ld0Zyb21TY2VuZShiLGMpKX07dmFyIGM9YS5Ub29scy5HZXRQb2ludGVyUHJlZml4KCk7dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpLmFkZEV2ZW50TGlzdGVuZXIoYytcIm1vdmVcIix0aGlzLl9vblBvaW50ZXJNb3ZlLCExKSx0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCkuYWRkRXZlbnRMaXN0ZW5lcihjK1wiZG93blwiLHRoaXMuX29uUG9pbnRlckRvd24sITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX29uS2V5RG93biwhMSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMuX29uS2V5VXAsITEpfSxiLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKCl7dmFyIGI9YS5Ub29scy5HZXRQb2ludGVyUHJlZml4KCk7dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpLnJlbW92ZUV2ZW50TGlzdGVuZXIoYitcIm1vdmVcIix0aGlzLl9vblBvaW50ZXJNb3ZlKSx0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1wiZG93blwiLHRoaXMuX29uUG9pbnRlckRvd24pLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX29uS2V5RG93biksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMuX29uS2V5VXApfSxiLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7aWYodGhpcy5fcGVuZGluZ0RhdGEubGVuZ3RoPjApcmV0dXJuITE7Zm9yKHZhciBiPTA7Yjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX2dlb21ldHJpZXNbYl07aWYoYy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURJTkcpcmV0dXJuITF9Zm9yKGI9MDtiPHRoaXMubWVzaGVzLmxlbmd0aDtiKyspe3ZhciBkPXRoaXMubWVzaGVzW2JdO2lmKCFkLmlzUmVhZHkoKSlyZXR1cm4hMTt2YXIgZT1kLm1hdGVyaWFsO2lmKGUmJiFlLmlzUmVhZHkoZCkpcmV0dXJuITF9cmV0dXJuITB9LGIucHJvdG90eXBlLnJlZ2lzdGVyQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKGEpe3RoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLnB1c2goYSl9LGIucHJvdG90eXBlLnVucmVnaXN0ZXJCZWZvcmVSZW5kZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3MuaW5kZXhPZihhKTtiPi0xJiZ0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcy5zcGxpY2UoYiwxKX0sYi5wcm90b3R5cGUuX2FkZFBlbmRpbmdEYXRhPWZ1bmN0aW9uKGEpe3RoaXMuX3BlbmRpbmdEYXRhLnB1c2goYSl9LGIucHJvdG90eXBlLl9yZW1vdmVQZW5kaW5nRGF0YT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9wZW5kaW5nRGF0YS5pbmRleE9mKGEpOy0xIT09YiYmdGhpcy5fcGVuZGluZ0RhdGEuc3BsaWNlKGIsMSl9LGIucHJvdG90eXBlLmdldFdhaXRpbmdJdGVtc0NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BlbmRpbmdEYXRhLmxlbmd0aH0sYi5wcm90b3R5cGUuZXhlY3V0ZVdoZW5SZWFkeT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuX29uUmVhZHlDYWxsYmFja3MucHVzaChhKSwtMT09PXRoaXMuX2V4ZWN1dGVXaGVuUmVhZHlUaW1lb3V0SWQmJih0aGlzLl9leGVjdXRlV2hlblJlYWR5VGltZW91dElkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLl9jaGVja0lzUmVhZHkoKX0sMTUwKSl9LGIucHJvdG90eXBlLl9jaGVja0lzUmVhZHk9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB0aGlzLmlzUmVhZHkoKT8odGhpcy5fb25SZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoKX0pLHRoaXMuX29uUmVhZHlDYWxsYmFja3M9W10sdm9pZCh0aGlzLl9leGVjdXRlV2hlblJlYWR5VGltZW91dElkPS0xKSk6dm9pZCh0aGlzLl9leGVjdXRlV2hlblJlYWR5VGltZW91dElkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthLl9jaGVja0lzUmVhZHkoKX0sMTUwKSl9LGIucHJvdG90eXBlLmJlZ2luQW5pbWF0aW9uPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgpe2lmKHZvaWQgMD09PWYmJihmPTEpLHRoaXMuc3RvcEFuaW1hdGlvbihiKSxofHwoaD1uZXcgYS5BbmltYXRhYmxlKHRoaXMsYixjLGQsZSxmLGcpKSxiLmFuaW1hdGlvbnMmJmguYXBwZW5kQW5pbWF0aW9ucyhiLGIuYW5pbWF0aW9ucyksYi5nZXRBbmltYXRhYmxlcylmb3IodmFyIGk9Yi5nZXRBbmltYXRhYmxlcygpLGo9MDtqPGkubGVuZ3RoO2orKyl0aGlzLmJlZ2luQW5pbWF0aW9uKGlbal0sYyxkLGUsZixnLGgpO3JldHVybiBofSxiLnByb3RvdHlwZS5iZWdpbkRpcmVjdEFuaW1hdGlvbj1mdW5jdGlvbihiLGMsZCxlLGYsZyxoKXt2b2lkIDA9PT1nJiYoZz0xKTt2YXIgaT1uZXcgYS5BbmltYXRhYmxlKHRoaXMsYixkLGUsZixnLGgsYyk7cmV0dXJuIGl9LGIucHJvdG90eXBlLmdldEFuaW1hdGFibGVCeVRhcmdldD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX2FjdGl2ZUFuaW1hdGFibGVzLmxlbmd0aDtiKyspaWYodGhpcy5fYWN0aXZlQW5pbWF0YWJsZXNbYl0udGFyZ2V0PT09YSlyZXR1cm4gdGhpcy5fYWN0aXZlQW5pbWF0YWJsZXNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLnN0b3BBbmltYXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRBbmltYXRhYmxlQnlUYXJnZXQoYSk7YiYmYi5zdG9wKCl9LGIucHJvdG90eXBlLl9hbmltYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYW5pbWF0aW9uU3RhcnREYXRlfHwodGhpcy5fYW5pbWF0aW9uU3RhcnREYXRlPShuZXcgRGF0ZSkuZ2V0VGltZSgpKTtmb3IodmFyIGE9KG5ldyBEYXRlKS5nZXRUaW1lKCksYj1hLXRoaXMuX2FuaW1hdGlvblN0YXJ0RGF0ZSxjPTA7Yzx0aGlzLl9hY3RpdmVBbmltYXRhYmxlcy5sZW5ndGg7YysrKXRoaXMuX2FjdGl2ZUFuaW1hdGFibGVzW2NdLl9hbmltYXRlKGIpfHwodGhpcy5fYWN0aXZlQW5pbWF0YWJsZXMuc3BsaWNlKGMsMSksYy0tKVxufSxiLnByb3RvdHlwZS5nZXRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXh9LGIucHJvdG90eXBlLmdldFByb2plY3Rpb25NYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvamVjdGlvbk1hdHJpeH0sYi5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybU1hdHJpeH0sYi5wcm90b3R5cGUuc2V0VHJhbnNmb3JtTWF0cml4PWZ1bmN0aW9uKGEsYil7dGhpcy5fdmlld01hdHJpeD1hLHRoaXMuX3Byb2plY3Rpb25NYXRyaXg9Yix0aGlzLl92aWV3TWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5fcHJvamVjdGlvbk1hdHJpeCx0aGlzLl90cmFuc2Zvcm1NYXRyaXgpfSxiLnByb3RvdHlwZS5zZXRBY3RpdmVDYW1lcmFCeUlEPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0Q2FtZXJhQnlJRChhKTtyZXR1cm4gYj8odGhpcy5hY3RpdmVDYW1lcmE9YixiKTpudWxsfSxiLnByb3RvdHlwZS5zZXRBY3RpdmVDYW1lcmFCeU5hbWU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDYW1lcmFCeU5hbWUoYSk7cmV0dXJuIGI/KHRoaXMuYWN0aXZlQ2FtZXJhPWIsYik6bnVsbH0sYi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5tYXRlcmlhbHMubGVuZ3RoO2IrKylpZih0aGlzLm1hdGVyaWFsc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubWF0ZXJpYWxzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRNYXRlcmlhbEJ5TmFtZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMubWF0ZXJpYWxzLmxlbmd0aDtiKyspaWYodGhpcy5tYXRlcmlhbHNbYl0ubmFtZT09PWEpcmV0dXJuIHRoaXMubWF0ZXJpYWxzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRDYW1lcmFCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5jYW1lcmFzLmxlbmd0aDtiKyspaWYodGhpcy5jYW1lcmFzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5jYW1lcmFzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRDYW1lcmFCeU5hbWU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmNhbWVyYXMubGVuZ3RoO2IrKylpZih0aGlzLmNhbWVyYXNbYl0ubmFtZT09PWEpcmV0dXJuIHRoaXMuY2FtZXJhc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0TGlnaHRCeU5hbWU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmxpZ2h0cy5sZW5ndGg7YisrKWlmKHRoaXMubGlnaHRzW2JdLm5hbWU9PT1hKXJldHVybiB0aGlzLmxpZ2h0c1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0TGlnaHRCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5saWdodHMubGVuZ3RoO2IrKylpZih0aGlzLmxpZ2h0c1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubGlnaHRzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRHZW9tZXRyeUJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtiKyspaWYodGhpcy5fZ2VvbWV0cmllc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLnB1c2hHZW9tZXRyeT1mdW5jdGlvbihhLGIpe3JldHVybiFiJiZ0aGlzLmdldEdlb21ldHJ5QnlJRChhLmlkKT8hMToodGhpcy5fZ2VvbWV0cmllcy5wdXNoKGEpLCEwKX0sYi5wcm90b3R5cGUuZ2V0R2VvbWV0cmllcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZW9tZXRyaWVzfSxiLnByb3RvdHlwZS5nZXRNZXNoQnlJRD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMubWVzaGVzLmxlbmd0aDtiKyspaWYodGhpcy5tZXNoZXNbYl0uaWQ9PT1hKXJldHVybiB0aGlzLm1lc2hlc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0TGFzdE1lc2hCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLm1lc2hlcy5sZW5ndGgtMTtiPj0wO2ItLSlpZih0aGlzLm1lc2hlc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubWVzaGVzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRMYXN0RW50cnlCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLm1lc2hlcy5sZW5ndGgtMTtiPj0wO2ItLSlpZih0aGlzLm1lc2hlc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubWVzaGVzW2JdO2ZvcihiPXRoaXMuY2FtZXJhcy5sZW5ndGgtMTtiPj0wO2ItLSlpZih0aGlzLmNhbWVyYXNbYl0uaWQ9PT1hKXJldHVybiB0aGlzLmNhbWVyYXNbYl07Zm9yKGI9dGhpcy5saWdodHMubGVuZ3RoLTE7Yj49MDtiLS0paWYodGhpcy5saWdodHNbYl0uaWQ9PT1hKXJldHVybiB0aGlzLmxpZ2h0c1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0TWVzaEJ5TmFtZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMubWVzaGVzLmxlbmd0aDtiKyspaWYodGhpcy5tZXNoZXNbYl0ubmFtZT09PWEpcmV0dXJuIHRoaXMubWVzaGVzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRMYXN0U2tlbGV0b25CeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLnNrZWxldG9ucy5sZW5ndGgtMTtiPj0wO2ItLSlpZih0aGlzLnNrZWxldG9uc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMuc2tlbGV0b25zW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRTa2VsZXRvbkJ5SWQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLnNrZWxldG9ucy5sZW5ndGg7YisrKWlmKHRoaXMuc2tlbGV0b25zW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5za2VsZXRvbnNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldFNrZWxldG9uQnlOYW1lPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5za2VsZXRvbnMubGVuZ3RoO2IrKylpZih0aGlzLnNrZWxldG9uc1tiXS5uYW1lPT09YSlyZXR1cm4gdGhpcy5za2VsZXRvbnNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmlzQWN0aXZlTWVzaD1mdW5jdGlvbihhKXtyZXR1cm4tMSE9PXRoaXMuX2FjdGl2ZU1lc2hlcy5pbmRleE9mKGEpfSxiLnByb3RvdHlwZS5fZXZhbHVhdGVTdWJNZXNoPWZ1bmN0aW9uKGEsYil7aWYoMT09Yi5zdWJNZXNoZXMubGVuZ3RofHxhLmlzSW5GcnVzdHVtKHRoaXMuX2ZydXN0dW1QbGFuZXMpKXt2YXIgYz1hLmdldE1hdGVyaWFsKCk7Yi5zaG93U3ViTWVzaGVzQm91bmRpbmdCb3gmJnRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXIucmVuZGVyTGlzdC5wdXNoKGEuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gpLGMmJihjLmdldFJlbmRlclRhcmdldFRleHR1cmVzJiYtMT09PXRoaXMuX3Byb2Nlc3NlZE1hdGVyaWFscy5pbmRleE9mKGMpJiYodGhpcy5fcHJvY2Vzc2VkTWF0ZXJpYWxzLnB1c2goYyksdGhpcy5fcmVuZGVyVGFyZ2V0cy5jb25jYXQoYy5nZXRSZW5kZXJUYXJnZXRUZXh0dXJlcygpKSksdGhpcy5fYWN0aXZlVmVydGljZXMrPWEudmVydGljZXNDb3VudCx0aGlzLl9yZW5kZXJpbmdNYW5hZ2VyLmRpc3BhdGNoKGEpKX19LGIucHJvdG90eXBlLl9ldmFsdWF0ZUFjdGl2ZU1lc2hlcz1mdW5jdGlvbigpe3RoaXMuX2FjdGl2ZU1lc2hlcy5yZXNldCgpLHRoaXMuX3JlbmRlcmluZ01hbmFnZXIucmVzZXQoKSx0aGlzLl9wcm9jZXNzZWRNYXRlcmlhbHMucmVzZXQoKSx0aGlzLl9hY3RpdmVQYXJ0aWNsZVN5c3RlbXMucmVzZXQoKSx0aGlzLl9hY3RpdmVTa2VsZXRvbnMucmVzZXQoKSx0aGlzLl9ib3VuZGluZ0JveFJlbmRlcmVyLnJlc2V0KCksdGhpcy5fZnJ1c3R1bVBsYW5lcz9hLkZydXN0dW0uR2V0UGxhbmVzVG9SZWYodGhpcy5fdHJhbnNmb3JtTWF0cml4LHRoaXMuX2ZydXN0dW1QbGFuZXMpOnRoaXMuX2ZydXN0dW1QbGFuZXM9YS5GcnVzdHVtLkdldFBsYW5lcyh0aGlzLl90cmFuc2Zvcm1NYXRyaXgpO3ZhciBiLGM7aWYodGhpcy5fc2VsZWN0aW9uT2N0cmVlKXt2YXIgZD10aGlzLl9zZWxlY3Rpb25PY3RyZWUuc2VsZWN0KHRoaXMuX2ZydXN0dW1QbGFuZXMpO2I9ZC5kYXRhLGM9ZC5sZW5ndGh9ZWxzZSBjPXRoaXMubWVzaGVzLmxlbmd0aCxiPXRoaXMubWVzaGVzO2Zvcih2YXIgZT0wO2M+ZTtlKyspe3ZhciBmPWJbZV07dGhpcy5fdG90YWxWZXJ0aWNlcys9Zi5nZXRUb3RhbFZlcnRpY2VzKCksZi5pc1JlYWR5KCkmJihmLmNvbXB1dGVXb3JsZE1hdHJpeCgpLGYuX3ByZUFjdGl2YXRlKCksZi5hY3Rpb25NYW5hZ2VyJiZmLmFjdGlvbk1hbmFnZXIuaGFzU3BlY2lmaWNUcmlnZ2VycyhbYS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyLGEuQWN0aW9uTWFuYWdlci5PbkludGVyc2VjdGlvbkV4aXRUcmlnZ2VyXSkmJnRoaXMuX21lc2hlc0ZvckludGVyc2VjdGlvbnMucHVzaE5vRHVwbGljYXRlKGYpLGYuaXNFbmFibGVkKCkmJmYuaXNWaXNpYmxlJiZmLnZpc2liaWxpdHk+MCYmMCE9KGYubGF5ZXJNYXNrJnRoaXMuYWN0aXZlQ2FtZXJhLmxheWVyTWFzaykmJmYuaXNJbkZydXN0dW0odGhpcy5fZnJ1c3R1bVBsYW5lcykmJih0aGlzLl9hY3RpdmVNZXNoZXMucHVzaChmKSxmLl9hY3RpdmF0ZSh0aGlzLl9yZW5kZXJJZCksdGhpcy5fYWN0aXZlTWVzaChmKSkpfXZhciBnPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2lmKHRoaXMucGFydGljbGVzRW5hYmxlZClmb3IodmFyIGg9MDtoPHRoaXMucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtoKyspe3ZhciBpPXRoaXMucGFydGljbGVTeXN0ZW1zW2hdO2kuaXNTdGFydGVkKCkmJighaS5lbWl0dGVyLnBvc2l0aW9ufHxpLmVtaXR0ZXImJmkuZW1pdHRlci5pc0VuYWJsZWQoKSkmJih0aGlzLl9hY3RpdmVQYXJ0aWNsZVN5c3RlbXMucHVzaChpKSxpLmFuaW1hdGUoKSl9dGhpcy5fcGFydGljbGVzRHVyYXRpb24rPShuZXcgRGF0ZSkuZ2V0VGltZSgpLWd9LGIucHJvdG90eXBlLl9hY3RpdmVNZXNoPWZ1bmN0aW9uKGEpe2lmKGEuc2tlbGV0b24mJnRoaXMuX2FjdGl2ZVNrZWxldG9ucy5wdXNoTm9EdXBsaWNhdGUoYS5za2VsZXRvbiksYS5zaG93Qm91bmRpbmdCb3gmJnRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXIucmVuZGVyTGlzdC5wdXNoKGEuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gpLGEuc3ViTWVzaGVzKXt2YXIgYixjO2lmKGEuX3N1Ym1lc2hlc09jdHJlZSYmYS51c2VPY3RyZWVGb3JSZW5kZXJpbmdTZWxlY3Rpb24pe3ZhciBkPWEuX3N1Ym1lc2hlc09jdHJlZS5zZWxlY3QodGhpcy5fZnJ1c3R1bVBsYW5lcyk7Yj1kLmxlbmd0aCxjPWQuZGF0YX1lbHNlIGM9YS5zdWJNZXNoZXMsYj1jLmxlbmd0aDtmb3IodmFyIGU9MDtiPmU7ZSsrKXt2YXIgZj1jW2VdO3RoaXMuX2V2YWx1YXRlU3ViTWVzaChmLGEpfX19LGIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeD1mdW5jdGlvbihhKXt0aGlzLnNldFRyYW5zZm9ybU1hdHJpeCh0aGlzLmFjdGl2ZUNhbWVyYS5nZXRWaWV3TWF0cml4KCksdGhpcy5hY3RpdmVDYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeChhKSl9LGIucHJvdG90eXBlLl9yZW5kZXJGb3JDYW1lcmE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZW5naW5lO2lmKHRoaXMuYWN0aXZlQ2FtZXJhPWEsIXRoaXMuYWN0aXZlQ2FtZXJhKXRocm93IG5ldyBFcnJvcihcIkFjdGl2ZSBjYW1lcmEgbm90IHNldFwiKTtiLnNldFZpZXdwb3J0KHRoaXMuYWN0aXZlQ2FtZXJhLnZpZXdwb3J0KSx0aGlzLl9yZW5kZXJJZCsrLHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCksdGhpcy5iZWZvcmVDYW1lcmFSZW5kZXImJnRoaXMuYmVmb3JlQ2FtZXJhUmVuZGVyKHRoaXMuYWN0aXZlQ2FtZXJhKTt2YXIgYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLl9ldmFsdWF0ZUFjdGl2ZU1lc2hlcygpLHRoaXMuX2V2YWx1YXRlQWN0aXZlTWVzaGVzRHVyYXRpb24rPShuZXcgRGF0ZSkuZ2V0VGltZSgpLWM7Zm9yKHZhciBkPTA7ZDx0aGlzLl9hY3RpdmVTa2VsZXRvbnMubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5fYWN0aXZlU2tlbGV0b25zLmRhdGFbZF07ZS5wcmVwYXJlKCl9Zm9yKHZhciBmPTA7Zjx0aGlzLmN1c3RvbVJlbmRlclRhcmdldHMubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5jdXN0b21SZW5kZXJUYXJnZXRzW2ZdO3RoaXMuX3JlbmRlclRhcmdldHMucHVzaChnKX12YXIgaD0obmV3IERhdGUpLmdldFRpbWUoKTtpZih0aGlzLnJlbmRlclRhcmdldHNFbmFibGVkKXtmb3IodmFyIGk9MDtpPHRoaXMuX3JlbmRlclRhcmdldHMubGVuZ3RoO2krKylnPXRoaXMuX3JlbmRlclRhcmdldHMuZGF0YVtpXSxnLl9zaG91bGRSZW5kZXIoKSYmKHRoaXMuX3JlbmRlcklkKyssZy5yZW5kZXIoKSk7dGhpcy5fcmVuZGVySWQrK310aGlzLl9yZW5kZXJUYXJnZXRzLmxlbmd0aD4wJiZiLnJlc3RvcmVEZWZhdWx0RnJhbWVidWZmZXIoKSx0aGlzLl9yZW5kZXJUYXJnZXRzRHVyYXRpb249KG5ldyBEYXRlKS5nZXRUaW1lKCktaCx0aGlzLnBvc3RQcm9jZXNzTWFuYWdlci5fcHJlcGFyZUZyYW1lKCk7dmFyIGo9KG5ldyBEYXRlKS5nZXRUaW1lKCk7aWYodGhpcy5sYXllcnMubGVuZ3RoKXtiLnNldERlcHRoQnVmZmVyKCExKTt2YXIgayxsO2ZvcihrPTA7azx0aGlzLmxheWVycy5sZW5ndGg7aysrKWw9dGhpcy5sYXllcnNba10sbC5pc0JhY2tncm91bmQmJmwucmVuZGVyKCk7Yi5zZXREZXB0aEJ1ZmZlcighMCl9dGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZW5kZXIobnVsbCxudWxsLCEwLCEwKSx0aGlzLl9ib3VuZGluZ0JveFJlbmRlcmVyLnJlbmRlcigpO2Zvcih2YXIgbT0wO208dGhpcy5sZW5zRmxhcmVTeXN0ZW1zLmxlbmd0aDttKyspdGhpcy5sZW5zRmxhcmVTeXN0ZW1zW21dLnJlbmRlcigpO2lmKHRoaXMubGF5ZXJzLmxlbmd0aCl7Zm9yKGIuc2V0RGVwdGhCdWZmZXIoITEpLGs9MDtrPHRoaXMubGF5ZXJzLmxlbmd0aDtrKyspbD10aGlzLmxheWVyc1trXSxsLmlzQmFja2dyb3VuZHx8bC5yZW5kZXIoKTtiLnNldERlcHRoQnVmZmVyKCEwKX10aGlzLl9yZW5kZXJEdXJhdGlvbis9KG5ldyBEYXRlKS5nZXRUaW1lKCktaix0aGlzLnBvc3RQcm9jZXNzTWFuYWdlci5fZmluYWxpemVGcmFtZShhLmlzSW50ZXJtZWRpYXRlKSx0aGlzLmFjdGl2ZUNhbWVyYS5fdXBkYXRlRnJvbVNjZW5lKCksdGhpcy5fcmVuZGVyVGFyZ2V0cy5yZXNldCgpLHRoaXMuYWZ0ZXJDYW1lcmFSZW5kZXImJnRoaXMuYWZ0ZXJDYW1lcmFSZW5kZXIodGhpcy5hY3RpdmVDYW1lcmEpfSxiLnByb3RvdHlwZS5fcHJvY2Vzc1N1YkNhbWVyYXM9ZnVuY3Rpb24oYSl7aWYoMD09YS5zdWJDYW1lcmFzLmxlbmd0aClyZXR1cm4gdm9pZCB0aGlzLl9yZW5kZXJGb3JDYW1lcmEoYSk7Zm9yKHZhciBiPTA7YjxhLnN1YkNhbWVyYXMubGVuZ3RoO2IrKyl0aGlzLl9yZW5kZXJGb3JDYW1lcmEoYS5zdWJDYW1lcmFzW2JdKTt0aGlzLmFjdGl2ZUNhbWVyYT1hLHRoaXMuc2V0VHJhbnNmb3JtTWF0cml4KHRoaXMuYWN0aXZlQ2FtZXJhLmdldFZpZXdNYXRyaXgoKSx0aGlzLmFjdGl2ZUNhbWVyYS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLHRoaXMuYWN0aXZlQ2FtZXJhLl91cGRhdGVGcm9tU2NlbmUoKX0sYi5wcm90b3R5cGUuX2NoZWNrSW50ZXJzZWN0aW9ucz1mdW5jdGlvbigpe2Zvcih2YXIgYj0wO2I8dGhpcy5fbWVzaGVzRm9ySW50ZXJzZWN0aW9ucy5sZW5ndGg7YisrKWZvcih2YXIgYz10aGlzLl9tZXNoZXNGb3JJbnRlcnNlY3Rpb25zLmRhdGFbYl0sZD0wO2Q8Yy5hY3Rpb25NYW5hZ2VyLmFjdGlvbnMubGVuZ3RoO2QrKyl7dmFyIGU9Yy5hY3Rpb25NYW5hZ2VyLmFjdGlvbnNbZF07aWYoZS50cmlnZ2VyPT1hLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FbnRlclRyaWdnZXJ8fGUudHJpZ2dlcj09YS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRXhpdFRyaWdnZXIpe3ZhciBmPWUuZ2V0VHJpZ2dlclBhcmFtZXRlcigpLGc9Zi5pbnRlcnNlY3RzTWVzaChjLCExKSxoPWMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzLmluZGV4T2YoZik7aWYoZyYmLTE9PT1oJiZlLnRyaWdnZXI9PWEuQWN0aW9uTWFuYWdlci5PbkludGVyc2VjdGlvbkVudGVyVHJpZ2dlciljLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3KGMpKSxjLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcy5wdXNoKGYpO2Vsc2UgaWYoIWcmJmg+LTEmJmUudHJpZ2dlcj09YS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRXhpdFRyaWdnZXIpe2MuYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyhjKSk7dmFyIGk9Yy5faW50ZXJzZWN0aW9uc0luUHJvZ3Jlc3MuaW5kZXhPZihmKTtpPi0xJiZjLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcy5zcGxpY2UoaSwxKX19fX0sYi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGM9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5fcGFydGljbGVzRHVyYXRpb249MCx0aGlzLl9zcHJpdGVzRHVyYXRpb249MCx0aGlzLl9hY3RpdmVQYXJ0aWNsZXM9MCx0aGlzLl9yZW5kZXJEdXJhdGlvbj0wLHRoaXMuX2V2YWx1YXRlQWN0aXZlTWVzaGVzRHVyYXRpb249MCx0aGlzLl90b3RhbFZlcnRpY2VzPTAsdGhpcy5fYWN0aXZlVmVydGljZXM9MCx0aGlzLl9tZXNoZXNGb3JJbnRlcnNlY3Rpb25zLnJlc2V0KCksdGhpcy5hY3Rpb25NYW5hZ2VyJiZ0aGlzLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uRXZlcnlGcmFtZVRyaWdnZXIsbnVsbCksdGhpcy5iZWZvcmVSZW5kZXImJnRoaXMuYmVmb3JlUmVuZGVyKCk7Zm9yKHZhciBkPTA7ZDx0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcy5sZW5ndGg7ZCsrKXRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzW2RdKCk7dmFyIGU9TWF0aC5tYXgoYi5NaW5EZWx0YVRpbWUsTWF0aC5taW4oYS5Ub29scy5HZXREZWx0YVRpbWUoKSxiLk1heERlbHRhVGltZSkpO3RoaXMuX2FuaW1hdGlvblJhdGlvPS4wNiplLHRoaXMuX2FuaW1hdGUoKSx0aGlzLl9waHlzaWNzRW5naW5lJiZ0aGlzLl9waHlzaWNzRW5naW5lLl9ydW5PbmVTdGVwKGUvMWUzKSx0aGlzLl9lbmdpbmUuY2xlYXIodGhpcy5jbGVhckNvbG9yLHRoaXMuYXV0b0NsZWFyfHx0aGlzLmZvcmNlV2lyZWZyYW1lLCEwKTtmb3IodmFyIGY9MDtmPHRoaXMubGlnaHRzLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMubGlnaHRzW2ZdLGg9Zy5nZXRTaGFkb3dHZW5lcmF0b3IoKTtnLmlzRW5hYmxlZCgpJiZoJiYtMSE9PWguZ2V0U2hhZG93TWFwKCkuZ2V0U2NlbmUoKS50ZXh0dXJlcy5pbmRleE9mKGguZ2V0U2hhZG93TWFwKCkpJiZ0aGlzLl9yZW5kZXJUYXJnZXRzLnB1c2goaC5nZXRTaGFkb3dNYXAoKSl9aWYodGhpcy5wb3N0UHJvY2Vzc1JlbmRlclBpcGVsaW5lTWFuYWdlci51cGRhdGUoKSx0aGlzLmFjdGl2ZUNhbWVyYXMubGVuZ3RoPjApZm9yKHZhciBpPXRoaXMuX3JlbmRlcklkLGo9MDtqPHRoaXMuYWN0aXZlQ2FtZXJhcy5sZW5ndGg7aisrKXRoaXMuX3JlbmRlcklkPWksdGhpcy5fcHJvY2Vzc1N1YkNhbWVyYXModGhpcy5hY3RpdmVDYW1lcmFzW2pdKTtlbHNlIHRoaXMuX3Byb2Nlc3NTdWJDYW1lcmFzKHRoaXMuYWN0aXZlQ2FtZXJhKTt0aGlzLl9jaGVja0ludGVyc2VjdGlvbnMoKSx0aGlzLmFmdGVyUmVuZGVyJiZ0aGlzLmFmdGVyUmVuZGVyKCk7Zm9yKHZhciBrPTA7azx0aGlzLl90b0JlRGlzcG9zZWQubGVuZ3RoO2srKyl0aGlzLl90b0JlRGlzcG9zZWQuZGF0YVtrXS5kaXNwb3NlKCksdGhpcy5fdG9CZURpc3Bvc2VkW2tdPW51bGw7dGhpcy5fdG9CZURpc3Bvc2VkLnJlc2V0KCksdGhpcy5fbGFzdEZyYW1lRHVyYXRpb249KG5ldyBEYXRlKS5nZXRUaW1lKCktY30sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYmVmb3JlUmVuZGVyPW51bGwsdGhpcy5hZnRlclJlbmRlcj1udWxsLHRoaXMuc2tlbGV0b25zPVtdLHRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXIuZGlzcG9zZSgpLHRoaXMub25EaXNwb3NlJiZ0aGlzLm9uRGlzcG9zZSgpLHRoaXMuZGV0YWNoQ29udHJvbCgpO3ZhciBhLGI9dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpO2ZvcihhPTA7YTx0aGlzLmNhbWVyYXMubGVuZ3RoO2ErKyl0aGlzLmNhbWVyYXNbYV0uZGV0YWNoQ29udHJvbChiKTtmb3IoO3RoaXMubGlnaHRzLmxlbmd0aDspdGhpcy5saWdodHNbMF0uZGlzcG9zZSgpO2Zvcig7dGhpcy5tZXNoZXMubGVuZ3RoOyl0aGlzLm1lc2hlc1swXS5kaXNwb3NlKCEwKTtmb3IoO3RoaXMuY2FtZXJhcy5sZW5ndGg7KXRoaXMuY2FtZXJhc1swXS5kaXNwb3NlKCk7Zm9yKDt0aGlzLm1hdGVyaWFscy5sZW5ndGg7KXRoaXMubWF0ZXJpYWxzWzBdLmRpc3Bvc2UoKTtmb3IoO3RoaXMucGFydGljbGVTeXN0ZW1zLmxlbmd0aDspdGhpcy5wYXJ0aWNsZVN5c3RlbXNbMF0uZGlzcG9zZSgpO2Zvcig7dGhpcy5zcHJpdGVNYW5hZ2Vycy5sZW5ndGg7KXRoaXMuc3ByaXRlTWFuYWdlcnNbMF0uZGlzcG9zZSgpO2Zvcig7dGhpcy5sYXllcnMubGVuZ3RoOyl0aGlzLmxheWVyc1swXS5kaXNwb3NlKCk7Zm9yKDt0aGlzLnRleHR1cmVzLmxlbmd0aDspdGhpcy50ZXh0dXJlc1swXS5kaXNwb3NlKCk7dGhpcy5wb3N0UHJvY2Vzc01hbmFnZXIuZGlzcG9zZSgpLHRoaXMuX3BoeXNpY3NFbmdpbmUmJnRoaXMuZGlzYWJsZVBoeXNpY3NFbmdpbmUoKSxhPXRoaXMuX2VuZ2luZS5zY2VuZXMuaW5kZXhPZih0aGlzKSx0aGlzLl9lbmdpbmUuc2NlbmVzLnNwbGljZShhLDEpLHRoaXMuX2VuZ2luZS53aXBlQ2FjaGVzKCl9LGIucHJvdG90eXBlLl9nZXROZXdQb3NpdGlvbj1mdW5jdGlvbihhLGIsYyxkLGUsZil7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGYmJihmPW51bGwpLGEuZGl2aWRlVG9SZWYoYy5yYWRpdXMsdGhpcy5fc2NhbGVkUG9zaXRpb24pLGIuZGl2aWRlVG9SZWYoYy5yYWRpdXMsdGhpcy5fc2NhbGVkVmVsb2NpdHkpLGMucmV0cnk9MCxjLmluaXRpYWxWZWxvY2l0eT10aGlzLl9zY2FsZWRWZWxvY2l0eSxjLmluaXRpYWxQb3NpdGlvbj10aGlzLl9zY2FsZWRQb3NpdGlvbix0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKHRoaXMuX3NjYWxlZFBvc2l0aW9uLHRoaXMuX3NjYWxlZFZlbG9jaXR5LGMsZCxlLGYpLGUubXVsdGlwbHlJblBsYWNlKGMucmFkaXVzKX0sYi5wcm90b3R5cGUuX2NvbGxpZGVXaXRoV29ybGQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBnJiYoZz1udWxsKTt2YXIgaD0xMCphLkVuZ2luZS5Db2xsaXNpb25zRXBzaWxvbjtpZihkLnJldHJ5Pj1lKXJldHVybiB2b2lkIGYuY29weUZyb20oYik7ZC5faW5pdGlhbGl6ZShiLGMsaCk7Zm9yKHZhciBpPTA7aTx0aGlzLm1lc2hlcy5sZW5ndGg7aSsrKXt2YXIgaj10aGlzLm1lc2hlc1tpXTtqLmlzRW5hYmxlZCgpJiZqLmNoZWNrQ29sbGlzaW9ucyYmai5zdWJNZXNoZXMmJmohPT1nJiZqLl9jaGVja0NvbGxpc2lvbihkKX1yZXR1cm4gZC5jb2xsaXNpb25Gb3VuZD8oKDAhPWMueHx8MCE9Yy55fHwwIT1jLnopJiZkLl9nZXRSZXNwb25zZShiLGMpLGMubGVuZ3RoKCk8PWg/dm9pZCBmLmNvcHlGcm9tKGIpOihkLnJldHJ5Kyssdm9pZCB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKGIsYyxkLGUsZixnKSkpOnZvaWQgYi5hZGRUb1JlZihjLGYpfSxiLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVNlbGVjdGlvbk9jdHJlZT1mdW5jdGlvbihiLGMpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBiJiYoYj02NCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTIpLHRoaXMuX3NlbGVjdGlvbk9jdHJlZXx8KHRoaXMuX3NlbGVjdGlvbk9jdHJlZT1uZXcgYS5PY3RyZWUoYS5PY3RyZWUuQ3JlYXRpb25GdW5jRm9yTWVzaGVzLGIsYykpO2Zvcih2YXIgZD1uZXcgYS5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSxlPW5ldyBhLlZlY3RvcjMoLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUsLU51bWJlci5NQVhfVkFMVUUpLGY9MDtmPHRoaXMubWVzaGVzLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMubWVzaGVzW2ZdO2cuY29tcHV0ZVdvcmxkTWF0cml4KCEwKTt2YXIgaD1nLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94Lm1pbmltdW1Xb3JsZCxpPWcuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gubWF4aW11bVdvcmxkO2EuVG9vbHMuQ2hlY2tFeHRlbmRzKGgsZCxlKSxhLlRvb2xzLkNoZWNrRXh0ZW5kcyhpLGQsZSl9cmV0dXJuIHRoaXMuX3NlbGVjdGlvbk9jdHJlZS51cGRhdGUoZCxlLHRoaXMubWVzaGVzKSx0aGlzLl9zZWxlY3Rpb25PY3RyZWV9LGIucHJvdG90eXBlLmNyZWF0ZVBpY2tpbmdSYXk9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9dGhpcy5fZW5naW5lO2lmKCFlKXtpZighdGhpcy5hY3RpdmVDYW1lcmEpdGhyb3cgbmV3IEVycm9yKFwiQWN0aXZlIGNhbWVyYSBub3Qgc2V0XCIpO2U9dGhpcy5hY3RpdmVDYW1lcmF9dmFyIGc9ZS52aWV3cG9ydCxoPWcudG9HbG9iYWwoZik7cmV0dXJuIGI9Yi90aGlzLl9lbmdpbmUuZ2V0SGFyZHdhcmVTY2FsaW5nTGV2ZWwoKS1oLngsYz1jL3RoaXMuX2VuZ2luZS5nZXRIYXJkd2FyZVNjYWxpbmdMZXZlbCgpLSh0aGlzLl9lbmdpbmUuZ2V0UmVuZGVySGVpZ2h0KCktaC55LWguaGVpZ2h0KSxhLlJheS5DcmVhdGVOZXcoYi93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxjL3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLGgud2lkdGgsaC5oZWlnaHQsZD9kOmEuTWF0cml4LklkZW50aXR5KCksZS5nZXRWaWV3TWF0cml4KCksZS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpfSxiLnByb3RvdHlwZS5faW50ZXJuYWxQaWNrPWZ1bmN0aW9uKGIsYyxkKXtmb3IodmFyIGU9bnVsbCxmPTA7Zjx0aGlzLm1lc2hlcy5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLm1lc2hlc1tmXTtpZihjKXtpZighYyhnKSljb250aW51ZX1lbHNlIGlmKCFnLmlzRW5hYmxlZCgpfHwhZy5pc1Zpc2libGV8fCFnLmlzUGlja2FibGUpY29udGludWU7dmFyIGg9Zy5nZXRXb3JsZE1hdHJpeCgpLGk9YihoKSxqPWcuaW50ZXJzZWN0cyhpLGQpO2lmKGomJmouaGl0JiYoZHx8bnVsbD09ZXx8IShqLmRpc3RhbmNlPj1lLmRpc3RhbmNlKSkmJihlPWosZCkpYnJlYWt9cmV0dXJuIGV8fG5ldyBhLlBpY2tpbmdJbmZvfSxiLnByb3RvdHlwZS5waWNrPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcztyZXR1cm4gdGhpcy5faW50ZXJuYWxQaWNrKGZ1bmN0aW9uKGMpe3JldHVybiBmLmNyZWF0ZVBpY2tpbmdSYXkoYSxiLGMsZSl9LGMsZCl9LGIucHJvdG90eXBlLnBpY2tXaXRoUmF5PWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9pbnRlcm5hbFBpY2soZnVuY3Rpb24oYyl7cmV0dXJuIGUuX3BpY2tXaXRoUmF5SW52ZXJzZU1hdHJpeHx8KGUuX3BpY2tXaXRoUmF5SW52ZXJzZU1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSxjLmludmVydFRvUmVmKGUuX3BpY2tXaXRoUmF5SW52ZXJzZU1hdHJpeCksYS5SYXkuVHJhbnNmb3JtKGIsZS5fcGlja1dpdGhSYXlJbnZlcnNlTWF0cml4KX0sYyxkKX0sYi5wcm90b3R5cGUuc2V0UG9pbnRlck92ZXJNZXNoPWZ1bmN0aW9uKGIpe3RoaXMuX3BvaW50ZXJPdmVyTWVzaCE9PWImJih0aGlzLl9wb2ludGVyT3Zlck1lc2gmJnRoaXMuX3BvaW50ZXJPdmVyTWVzaC5hY3Rpb25NYW5hZ2VyJiZ0aGlzLl9wb2ludGVyT3Zlck1lc2guYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25Qb2ludGVyT3V0VHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyh0aGlzLl9wb2ludGVyT3Zlck1lc2gpKSx0aGlzLl9wb2ludGVyT3Zlck1lc2g9Yix0aGlzLl9wb2ludGVyT3Zlck1lc2gmJnRoaXMuX3BvaW50ZXJPdmVyTWVzaC5hY3Rpb25NYW5hZ2VyJiZ0aGlzLl9wb2ludGVyT3Zlck1lc2guYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25Qb2ludGVyT3ZlclRyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXcodGhpcy5fcG9pbnRlck92ZXJNZXNoKSkpfSxiLnByb3RvdHlwZS5nZXRQb2ludGVyT3Zlck1lc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcG9pbnRlck92ZXJNZXNofSxiLnByb3RvdHlwZS5nZXRQaHlzaWNzRW5naW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BoeXNpY3NFbmdpbmV9LGIucHJvdG90eXBlLmVuYWJsZVBoeXNpY3M9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdGhpcy5fcGh5c2ljc0VuZ2luZT8hMDoodGhpcy5fcGh5c2ljc0VuZ2luZT1uZXcgYS5QaHlzaWNzRW5naW5lKGMpLHRoaXMuX3BoeXNpY3NFbmdpbmUuaXNTdXBwb3J0ZWQoKT8odGhpcy5fcGh5c2ljc0VuZ2luZS5faW5pdGlhbGl6ZShiKSwhMCk6KHRoaXMuX3BoeXNpY3NFbmdpbmU9bnVsbCwhMSkpfSxiLnByb3RvdHlwZS5kaXNhYmxlUGh5c2ljc0VuZ2luZT1mdW5jdGlvbigpe3RoaXMuX3BoeXNpY3NFbmdpbmUmJih0aGlzLl9waHlzaWNzRW5naW5lLmRpc3Bvc2UoKSx0aGlzLl9waHlzaWNzRW5naW5lPXZvaWQgMCl9LGIucHJvdG90eXBlLmlzUGh5c2ljc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fcGh5c2ljc0VuZ2luZX0sYi5wcm90b3R5cGUuc2V0R3Jhdml0eT1mdW5jdGlvbihhKXt0aGlzLl9waHlzaWNzRW5naW5lJiZ0aGlzLl9waHlzaWNzRW5naW5lLl9zZXRHcmF2aXR5KGEpfSxiLnByb3RvdHlwZS5jcmVhdGVDb21wb3VuZEltcG9zdG9yPWZ1bmN0aW9uKGEsYil7aWYoYS5wYXJ0cyYmKGI9YSxhPWEucGFydHMpLCF0aGlzLl9waHlzaWNzRW5naW5lKXJldHVybiBudWxsO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLm1lc2g7ZC5fcGh5c2ljSW1wb3N0b3I9YVtjXS5pbXBvc3RvcixkLl9waHlzaWNzTWFzcz1iLm1hc3MvYS5sZW5ndGgsZC5fcGh5c2ljc0ZyaWN0aW9uPWIuZnJpY3Rpb24sZC5fcGh5c2ljUmVzdGl0dXRpb249Yi5yZXN0aXR1dGlvbn1yZXR1cm4gdGhpcy5fcGh5c2ljc0VuZ2luZS5fcmVnaXN0ZXJNZXNoZXNBc0NvbXBvdW5kKGEsYil9LGIucHJvdG90eXBlLmRlbGV0ZUNvbXBvdW5kSW1wb3N0b3I9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPTA7YzxiLnBhcnRzLmxlbmd0aDtjKyspe3ZhciBkPWIucGFydHNbY10ubWVzaDtkLl9waHlzaWNJbXBvc3Rvcj1hLlBoeXNpY3NFbmdpbmUuTm9JbXBvc3Rvcix0aGlzLl9waHlzaWNzRW5naW5lLl91bnJlZ2lzdGVyTWVzaChkKX19LGIucHJvdG90eXBlLl9nZXRCeVRhZ3M9ZnVuY3Rpb24oYixjKXtpZih2b2lkIDA9PT1jKXJldHVybiBiO3ZhciBkPVtdO2Zvcih2YXIgZSBpbiBiKXt2YXIgZj1iW2VdO2EuVGFncy5NYXRjaGVzUXVlcnkoZixjKSYmZC5wdXNoKGYpfXJldHVybiBkfSxiLnByb3RvdHlwZS5nZXRNZXNoZXNCeVRhZ3M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2dldEJ5VGFncyh0aGlzLm1lc2hlcyxhKX0sYi5wcm90b3R5cGUuZ2V0Q2FtZXJhc0J5VGFncz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fZ2V0QnlUYWdzKHRoaXMuY2FtZXJhcyxhKX0sYi5wcm90b3R5cGUuZ2V0TGlnaHRzQnlUYWdzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9nZXRCeVRhZ3ModGhpcy5saWdodHMsYSl9LGIucHJvdG90eXBlLmdldE1hdGVyaWFsQnlUYWdzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9nZXRCeVRhZ3ModGhpcy5tYXRlcmlhbHMsYSkuY29uY2F0KHRoaXMuX2dldEJ5VGFncyh0aGlzLm11bHRpTWF0ZXJpYWxzLGEpKX0sYi5GT0dNT0RFX05PTkU9MCxiLkZPR01PREVfRVhQPTEsYi5GT0dNT0RFX0VYUDI9MixiLkZPR01PREVfTElORUFSPTMsYi5NaW5EZWx0YVRpbWU9MSxiLk1heERlbHRhVGltZT0xZTMsYn0oKTthLlNjZW5lPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihjLGQsZSxmLGcpe3N3aXRjaCh0aGlzLl9lbmdpbmU9YyBpbnN0YW5jZW9mIGEuTWVzaD9jLmdldFNjZW5lKCkuZ2V0RW5naW5lKCk6Yyx0aGlzLl91cGRhdGFibGU9Zix0aGlzLl9kYXRhPWQsZ3x8dGhpcy5jcmVhdGUoKSx0aGlzLl9raW5kPWUsZSl7Y2FzZSBiLlBvc2l0aW9uS2luZDp0aGlzLl9zdHJpZGVTaXplPTM7YnJlYWs7Y2FzZSBiLk5vcm1hbEtpbmQ6dGhpcy5fc3RyaWRlU2l6ZT0zO2JyZWFrO2Nhc2UgYi5VVktpbmQ6dGhpcy5fc3RyaWRlU2l6ZT0yO2JyZWFrO2Nhc2UgYi5VVjJLaW5kOnRoaXMuX3N0cmlkZVNpemU9MjticmVhaztjYXNlIGIuQ29sb3JLaW5kOnRoaXMuX3N0cmlkZVNpemU9MzticmVhaztjYXNlIGIuTWF0cmljZXNJbmRpY2VzS2luZDp0aGlzLl9zdHJpZGVTaXplPTQ7YnJlYWs7Y2FzZSBiLk1hdHJpY2VzV2VpZ2h0c0tpbmQ6dGhpcy5fc3RyaWRlU2l6ZT00fX1yZXR1cm4gYi5wcm90b3R5cGUuaXNVcGRhdGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXBkYXRhYmxlfSxiLnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhdGF9LGIucHJvdG90eXBlLmdldEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9idWZmZXJ9LGIucHJvdG90eXBlLmdldFN0cmlkZVNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RyaWRlU2l6ZX0sYi5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKGEpeyhhfHwhdGhpcy5fYnVmZmVyKSYmKGE9YXx8dGhpcy5fZGF0YSx0aGlzLl9idWZmZXJ8fCh0aGlzLl9idWZmZXI9dGhpcy5fdXBkYXRhYmxlP3RoaXMuX2VuZ2luZS5jcmVhdGVEeW5hbWljVmVydGV4QnVmZmVyKDQqYS5sZW5ndGgpOnRoaXMuX2VuZ2luZS5jcmVhdGVWZXJ0ZXhCdWZmZXIoYSkpLHRoaXMuX3VwZGF0YWJsZSYmKHRoaXMuX2VuZ2luZS51cGRhdGVEeW5hbWljVmVydGV4QnVmZmVyKHRoaXMuX2J1ZmZlcixhKSx0aGlzLl9kYXRhPWEpKX0sYi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMuY3JlYXRlKGEpfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fYnVmZmVyJiZ0aGlzLl9lbmdpbmUuX3JlbGVhc2VCdWZmZXIodGhpcy5fYnVmZmVyKSYmKHRoaXMuX2J1ZmZlcj1udWxsKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJQb3NpdGlvbktpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX1Bvc2l0aW9uS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk5vcm1hbEtpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX05vcm1hbEtpbmR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJVVktpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX1VWS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIlVWMktpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX1VWMktpbmR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJDb2xvcktpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0NvbG9yS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk1hdHJpY2VzSW5kaWNlc0tpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX01hdHJpY2VzSW5kaWNlc0tpbmR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJNYXRyaWNlc1dlaWdodHNLaW5kXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9NYXRyaWNlc1dlaWdodHNLaW5kfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIuX1Bvc2l0aW9uS2luZD1cInBvc2l0aW9uXCIsYi5fTm9ybWFsS2luZD1cIm5vcm1hbFwiLGIuX1VWS2luZD1cInV2XCIsYi5fVVYyS2luZD1cInV2MlwiLGIuX0NvbG9yS2luZD1cImNvbG9yXCIsYi5fTWF0cmljZXNJbmRpY2VzS2luZD1cIm1hdHJpY2VzSW5kaWNlc1wiLGIuX01hdHJpY2VzV2VpZ2h0c0tpbmQ9XCJtYXRyaWNlc1dlaWdodHNcIixifSgpO2EuVmVydGV4QnVmZmVyPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7Yi5jYWxsKHRoaXMsYyxkKSx0aGlzLnBvc2l0aW9uPW5ldyBhLlZlY3RvcjMoMCwwLDApLHRoaXMucm90YXRpb249bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5zY2FsaW5nPW5ldyBhLlZlY3RvcjMoMSwxLDEpLHRoaXMuYmlsbGJvYXJkTW9kZT1hLkFic3RyYWN0TWVzaC5CSUxMQk9BUkRNT0RFX05PTkUsdGhpcy52aXNpYmlsaXR5PTEsdGhpcy5pbmZpbml0ZURpc3RhbmNlPSExLHRoaXMuaXNWaXNpYmxlPSEwLHRoaXMuaXNQaWNrYWJsZT0hMCx0aGlzLnNob3dCb3VuZGluZ0JveD0hMSx0aGlzLnNob3dTdWJNZXNoZXNCb3VuZGluZ0JveD0hMSx0aGlzLm9uRGlzcG9zZT1udWxsLHRoaXMuY2hlY2tDb2xsaXNpb25zPSExLHRoaXMucmVuZGVyaW5nR3JvdXBJZD0wLHRoaXMucmVjZWl2ZVNoYWRvd3M9ITEsdGhpcy51c2VPY3RyZWVGb3JSZW5kZXJpbmdTZWxlY3Rpb249ITAsdGhpcy51c2VPY3RyZWVGb3JQaWNraW5nPSEwLHRoaXMudXNlT2N0cmVlRm9yQ29sbGlzaW9ucz0hMCx0aGlzLmxheWVyTWFzaz00Mjk0OTY3Mjk1LHRoaXMuX3BoeXNpY0ltcG9zdG9yPWEuUGh5c2ljc0VuZ2luZS5Ob0ltcG9zdG9yLHRoaXMuZWxsaXBzb2lkPW5ldyBhLlZlY3RvcjMoLjUsMSwuNSksdGhpcy5lbGxpcHNvaWRPZmZzZXQ9bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5fY29sbGlkZXI9bmV3IGEuQ29sbGlkZXIsdGhpcy5fb2xkUG9zaXRpb25Gb3JDb2xsaXNpb25zPW5ldyBhLlZlY3RvcjMoMCwwLDApLHRoaXMuX2RpZmZQb3NpdGlvbkZvckNvbGxpc2lvbnM9bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5fbmV3UG9zaXRpb25Gb3JDb2xsaXNpb25zPW5ldyBhLlZlY3RvcjMoMCwwLDApLHRoaXMuX2xvY2FsU2NhbGluZz1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbG9jYWxSb3RhdGlvbj1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbG9jYWxUcmFuc2xhdGlvbj1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbG9jYWxCaWxsYm9hcmQ9YS5NYXRyaXguWmVybygpLHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nPWEuTWF0cml4Llplcm8oKSx0aGlzLl9sb2NhbFBpdm90U2NhbGluZ1JvdGF0aW9uPWEuTWF0cml4Llplcm8oKSx0aGlzLl9sb2NhbFdvcmxkPWEuTWF0cml4Llplcm8oKSx0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fcm90YXRlWUJ5UEk9YS5NYXRyaXguUm90YXRpb25ZKE1hdGguUEkpLHRoaXMuX2Fic29sdXRlUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9jb2xsaXNpb25zVHJhbnNmb3JtTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9jb2xsaXNpb25zU2NhbGluZ01hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5faXNEaXJ0eT0hMSx0aGlzLl9waXZvdE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpLHRoaXMuX2lzRGlzcG9zZWQ9ITEsdGhpcy5fcmVuZGVySWQ9MCx0aGlzLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcz1uZXcgQXJyYXksZC5tZXNoZXMucHVzaCh0aGlzKX1yZXR1cm4gX19leHRlbmRzKGMsYiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJCSUxMQk9BUkRNT0RFX05PTkVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuX0JJTExCT0FSRE1PREVfTk9ORX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxcIkJJTExCT0FSRE1PREVfWFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5fQklMTEJPQVJETU9ERV9YfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwiQklMTEJPQVJETU9ERV9ZXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLl9CSUxMQk9BUkRNT0RFX1l9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJCSUxMQk9BUkRNT0RFX1pcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuX0JJTExCT0FSRE1PREVfWn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxcIkJJTExCT0FSRE1PREVfQUxMXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLl9CSUxMQk9BUkRNT0RFX0FMTH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxjLnByb3RvdHlwZS5nZXRUb3RhbFZlcnRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGMucHJvdG90eXBlLmdldEluZGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYy5wcm90b3R5cGUuZ2V0VmVydGljZXNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGMucHJvdG90eXBlLmlzVmVydGljZXNEYXRhUHJlc2VudD1mdW5jdGlvbigpe3JldHVybiExfSxjLnByb3RvdHlwZS5nZXRCb3VuZGluZ0luZm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRpbmdJbmZvfHx0aGlzLl91cGRhdGVCb3VuZGluZ0luZm8oKSx0aGlzLl9ib3VuZGluZ0luZm99LGMucHJvdG90eXBlLl9wcmVBY3RpdmF0ZT1mdW5jdGlvbigpe30sYy5wcm90b3R5cGUuX2FjdGl2YXRlPWZ1bmN0aW9uKGEpe3RoaXMuX3JlbmRlcklkPWF9LGMucHJvdG90eXBlLmdldFdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRSZW5kZXJJZCE9PXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpJiZ0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCgpLHRoaXMuX3dvcmxkTWF0cml4fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJ3b3JsZE1hdHJpeEZyb21DYWNoZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwiYWJzb2x1dGVQb3NpdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWJzb2x1dGVQb3NpdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxjLnByb3RvdHlwZS5yb3RhdGU9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMucm90YXRpb25RdWF0ZXJuaW9ufHwodGhpcy5yb3RhdGlvblF1YXRlcm5pb249YS5RdWF0ZXJuaW9uLlJvdGF0aW9uWWF3UGl0Y2hSb2xsKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi56KSx0aGlzLnJvdGF0aW9uPWEuVmVjdG9yMy5aZXJvKCkpLGQmJjAhPWQpe2lmKHRoaXMucGFyZW50KXt2YXIgZT10aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLmNsb25lKCk7ZS5pbnZlcnQoKSxiPWEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwoYixlKX1mPWEuUXVhdGVybmlvbi5Sb3RhdGlvbkF4aXMoYixjKSx0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj1mLm11bHRpcGx5KHRoaXMucm90YXRpb25RdWF0ZXJuaW9uKX1lbHNle3ZhciBmPWEuUXVhdGVybmlvbi5Sb3RhdGlvbkF4aXMoYixjKTt0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj10aGlzLnJvdGF0aW9uUXVhdGVybmlvbi5tdWx0aXBseShmKX19LGMucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5zY2FsZShiKTtpZihjJiYwIT1jKXRoaXMuc2V0QWJzb2x1dGVQb3NpdGlvbih0aGlzLmdldEFic29sdXRlUG9zaXRpb24oKS5hZGQoZCkpO2Vsc2V7dmFyIGU9dGhpcy5nZXRQb3NpdGlvbkV4cHJlc3NlZEluTG9jYWxTcGFjZSgpLmFkZChkKTt0aGlzLnNldFBvc2l0aW9uV2l0aExvY2FsVmVjdG9yKGUpfX0sYy5wcm90b3R5cGUuZ2V0QWJzb2x1dGVQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCgpLHRoaXMuX2Fic29sdXRlUG9zaXRpb259LGMucHJvdG90eXBlLnNldEFic29sdXRlUG9zaXRpb249ZnVuY3Rpb24oYil7aWYoYil7dmFyIGMsZCxlO2lmKHZvaWQgMD09PWIueCl7aWYoYXJndW1lbnRzLmxlbmd0aDwzKXJldHVybjtjPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxlPWFyZ3VtZW50c1syXX1lbHNlIGM9Yi54LGQ9Yi55LGU9Yi56O2lmKHRoaXMucGFyZW50KXt2YXIgZj10aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLmNsb25lKCk7Zi5pbnZlcnQoKTt2YXIgZz1uZXcgYS5WZWN0b3IzKGMsZCxlKTt0aGlzLnBvc2l0aW9uPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhnLGYpfWVsc2UgdGhpcy5wb3NpdGlvbi54PWMsdGhpcy5wb3NpdGlvbi55PWQsdGhpcy5wb3NpdGlvbi56PWV9fSxjLnByb3RvdHlwZS5zZXRQaXZvdE1hdHJpeD1mdW5jdGlvbihhKXt0aGlzLl9waXZvdE1hdHJpeD1hLHRoaXMuX2NhY2hlLnBpdm90TWF0cml4VXBkYXRlZD0hMH0sYy5wcm90b3R5cGUuZ2V0UGl2b3RNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGl2b3RNYXRyaXh9LGMucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZD1mdW5jdGlvbigpe2lmKHRoaXMuX2lzRGlydHkpcmV0dXJuITE7aWYodGhpcy5iaWxsYm9hcmRNb2RlIT09Yy5CSUxMQk9BUkRNT0RFX05PTkUpcmV0dXJuITE7aWYodGhpcy5fY2FjaGUucGl2b3RNYXRyaXhVcGRhdGVkKXJldHVybiExO2lmKHRoaXMuaW5maW5pdGVEaXN0YW5jZSlyZXR1cm4hMTtpZighdGhpcy5fY2FjaGUucG9zaXRpb24uZXF1YWxzKHRoaXMucG9zaXRpb24pKXJldHVybiExO2lmKHRoaXMucm90YXRpb25RdWF0ZXJuaW9uKXtpZighdGhpcy5fY2FjaGUucm90YXRpb25RdWF0ZXJuaW9uLmVxdWFscyh0aGlzLnJvdGF0aW9uUXVhdGVybmlvbikpcmV0dXJuITF9ZWxzZSBpZighdGhpcy5fY2FjaGUucm90YXRpb24uZXF1YWxzKHRoaXMucm90YXRpb24pKXJldHVybiExO3JldHVybiB0aGlzLl9jYWNoZS5zY2FsaW5nLmVxdWFscyh0aGlzLnNjYWxpbmcpPyEwOiExfSxjLnByb3RvdHlwZS5faW5pdENhY2hlPWZ1bmN0aW9uKCl7Yi5wcm90b3R5cGUuX2luaXRDYWNoZS5jYWxsKHRoaXMpLHRoaXMuX2NhY2hlLmxvY2FsTWF0cml4VXBkYXRlZD0hMSx0aGlzLl9jYWNoZS5wb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NhY2hlLnNjYWxpbmc9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9jYWNoZS5yb3RhdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NhY2hlLnJvdGF0aW9uUXVhdGVybmlvbj1uZXcgYS5RdWF0ZXJuaW9uKDAsMCwwLDApfSxjLnByb3RvdHlwZS5tYXJrQXNEaXJ0eT1mdW5jdGlvbihhKXtcInJvdGF0aW9uXCI9PT1hJiYodGhpcy5yb3RhdGlvblF1YXRlcm5pb249bnVsbCksdGhpcy5fY3VycmVudFJlbmRlcklkPU51bWJlci5NQVhfVkFMVUUsdGhpcy5faXNEaXJ0eT0hMH0sYy5wcm90b3R5cGUuX3VwZGF0ZUJvdW5kaW5nSW5mbz1mdW5jdGlvbigpe2lmKHRoaXMuX2JvdW5kaW5nSW5mbz10aGlzLl9ib3VuZGluZ0luZm98fG5ldyBhLkJvdW5kaW5nSW5mbyh0aGlzLmFic29sdXRlUG9zaXRpb24sdGhpcy5hYnNvbHV0ZVBvc2l0aW9uKSx0aGlzLl9ib3VuZGluZ0luZm8uX3VwZGF0ZSh0aGlzLndvcmxkTWF0cml4RnJvbUNhY2hlKSx0aGlzLnN1Yk1lc2hlcylmb3IodmFyIGI9MDtiPHRoaXMuc3ViTWVzaGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuc3ViTWVzaGVzW2JdO2MudXBkYXRlQm91bmRpbmdJbmZvKHRoaXMud29ybGRNYXRyaXhGcm9tQ2FjaGUpfX0sYy5wcm90b3R5cGUuY29tcHV0ZVdvcmxkTWF0cml4PWZ1bmN0aW9uKGIpe2lmKCFiJiYodGhpcy5fY3VycmVudFJlbmRlcklkPT10aGlzLmdldFNjZW5lKCkuZ2V0UmVuZGVySWQoKXx8dGhpcy5pc1N5bmNocm9uaXplZCghMCkpKXJldHVybiB0aGlzLl93b3JsZE1hdHJpeDtpZih0aGlzLl9jYWNoZS5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnBvc2l0aW9uKSx0aGlzLl9jYWNoZS5zY2FsaW5nLmNvcHlGcm9tKHRoaXMuc2NhbGluZyksdGhpcy5fY2FjaGUucGl2b3RNYXRyaXhVcGRhdGVkPSExLHRoaXMuX2N1cnJlbnRSZW5kZXJJZD10aGlzLmdldFNjZW5lKCkuZ2V0UmVuZGVySWQoKSx0aGlzLl9pc0RpcnR5PSExLGEuTWF0cml4LlNjYWxpbmdUb1JlZih0aGlzLnNjYWxpbmcueCx0aGlzLnNjYWxpbmcueSx0aGlzLnNjYWxpbmcueix0aGlzLl9sb2NhbFNjYWxpbmcpLHRoaXMucm90YXRpb25RdWF0ZXJuaW9uPyh0aGlzLnJvdGF0aW9uUXVhdGVybmlvbi50b1JvdGF0aW9uTWF0cml4KHRoaXMuX2xvY2FsUm90YXRpb24pLHRoaXMuX2NhY2hlLnJvdGF0aW9uUXVhdGVybmlvbi5jb3B5RnJvbSh0aGlzLnJvdGF0aW9uUXVhdGVybmlvbikpOihhLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi56LHRoaXMuX2xvY2FsUm90YXRpb24pLHRoaXMuX2NhY2hlLnJvdGF0aW9uLmNvcHlGcm9tKHRoaXMucm90YXRpb24pKSx0aGlzLmluZmluaXRlRGlzdGFuY2UmJiF0aGlzLnBhcmVudCl7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLmFjdGl2ZUNhbWVyYSxlPWQuZ2V0V29ybGRNYXRyaXgoKSxmPW5ldyBhLlZlY3RvcjMoZS5tWzEyXSxlLm1bMTNdLGUubVsxNF0pO2EuTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYodGhpcy5wb3NpdGlvbi54K2YueCx0aGlzLnBvc2l0aW9uLnkrZi55LHRoaXMucG9zaXRpb24ueitmLnosdGhpcy5fbG9jYWxUcmFuc2xhdGlvbil9ZWxzZSBhLk1hdHJpeC5UcmFuc2xhdGlvblRvUmVmKHRoaXMucG9zaXRpb24ueCx0aGlzLnBvc2l0aW9uLnksdGhpcy5wb3NpdGlvbi56LHRoaXMuX2xvY2FsVHJhbnNsYXRpb24pO2lmKHRoaXMuX3Bpdm90TWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5fbG9jYWxTY2FsaW5nLHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nKSx0aGlzLl9sb2NhbFBpdm90U2NhbGluZy5tdWx0aXBseVRvUmVmKHRoaXMuX2xvY2FsUm90YXRpb24sdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmdSb3RhdGlvbiksdGhpcy5iaWxsYm9hcmRNb2RlIT09Yy5CSUxMQk9BUkRNT0RFX05PTkUpe3ZhciBnPXRoaXMucG9zaXRpb24uY2xvbmUoKSxoPXRoaXMuZ2V0U2NlbmUoKS5hY3RpdmVDYW1lcmEucG9zaXRpb24uY2xvbmUoKTt0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQucG9zaXRpb24mJihnLmFkZEluUGxhY2UodGhpcy5wYXJlbnQucG9zaXRpb24pLGEuTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYoZy54LGcueSxnLnosdGhpcy5fbG9jYWxUcmFuc2xhdGlvbikpLCh0aGlzLmJpbGxib2FyZE1vZGUmYy5CSUxMQk9BUkRNT0RFX0FMTCk9PT1jLkJJTExCT0FSRE1PREVfQUxMP2g9dGhpcy5nZXRTY2VuZSgpLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbjoodGhpcy5iaWxsYm9hcmRNb2RlJmEuQWJzdHJhY3RNZXNoLkJJTExCT0FSRE1PREVfWCYmKGgueD1nLngrYS5FbmdpbmUuRXBzaWxvbiksdGhpcy5iaWxsYm9hcmRNb2RlJmEuQWJzdHJhY3RNZXNoLkJJTExCT0FSRE1PREVfWSYmKGgueT1nLnkrLjAwMSksdGhpcy5iaWxsYm9hcmRNb2RlJmEuQWJzdHJhY3RNZXNoLkJJTExCT0FSRE1PREVfWiYmKGguej1nLnorLjAwMSkpLGEuTWF0cml4Lkxvb2tBdExIVG9SZWYoZyxoLGEuVmVjdG9yMy5VcCgpLHRoaXMuX2xvY2FsQmlsbGJvYXJkKSx0aGlzLl9sb2NhbEJpbGxib2FyZC5tWzEyXT10aGlzLl9sb2NhbEJpbGxib2FyZC5tWzEzXT10aGlzLl9sb2NhbEJpbGxib2FyZC5tWzE0XT0wLHRoaXMuX2xvY2FsQmlsbGJvYXJkLmludmVydCgpLHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nUm90YXRpb24ubXVsdGlwbHlUb1JlZih0aGlzLl9sb2NhbEJpbGxib2FyZCx0aGlzLl9sb2NhbFdvcmxkKSx0aGlzLl9yb3RhdGVZQnlQSS5tdWx0aXBseVRvUmVmKHRoaXMuX2xvY2FsV29ybGQsdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmdSb3RhdGlvbil9cmV0dXJuIHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nUm90YXRpb24ubXVsdGlwbHlUb1JlZih0aGlzLl9sb2NhbFRyYW5zbGF0aW9uLHRoaXMuX2xvY2FsV29ybGQpLHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCYmdGhpcy5iaWxsYm9hcmRNb2RlPT09YS5BYnN0cmFjdE1lc2guQklMTEJPQVJETU9ERV9OT05FP3RoaXMuX2xvY2FsV29ybGQubXVsdGlwbHlUb1JlZih0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLHRoaXMuX3dvcmxkTWF0cml4KTp0aGlzLl93b3JsZE1hdHJpeC5jb3B5RnJvbSh0aGlzLl9sb2NhbFdvcmxkKSx0aGlzLl91cGRhdGVCb3VuZGluZ0luZm8oKSx0aGlzLl9hYnNvbHV0ZVBvc2l0aW9uLmNvcHlGcm9tRmxvYXRzKHRoaXMuX3dvcmxkTWF0cml4Lm1bMTJdLHRoaXMuX3dvcmxkTWF0cml4Lm1bMTNdLHRoaXMuX3dvcmxkTWF0cml4Lm1bMTRdKSx0aGlzLl93b3JsZE1hdHJpeH0sYy5wcm90b3R5cGUuc2V0UG9zaXRpb25XaXRoTG9jYWxWZWN0b3I9ZnVuY3Rpb24oYil7dGhpcy5jb21wdXRlV29ybGRNYXRyaXgoKSx0aGlzLnBvc2l0aW9uPWEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwoYix0aGlzLl9sb2NhbFdvcmxkKX0sYy5wcm90b3R5cGUuZ2V0UG9zaXRpb25FeHByZXNzZWRJbkxvY2FsU3BhY2U9ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCgpO3ZhciBiPXRoaXMuX2xvY2FsV29ybGQuY2xvbmUoKTtyZXR1cm4gYi5pbnZlcnQoKSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsKHRoaXMucG9zaXRpb24sYil9LGMucHJvdG90eXBlLmxvY2FsbHlUcmFuc2xhdGU9ZnVuY3Rpb24oYil7dGhpcy5jb21wdXRlV29ybGRNYXRyaXgoKSx0aGlzLnBvc2l0aW9uPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhiLHRoaXMuX2xvY2FsV29ybGQpfSxjLnByb3RvdHlwZS5sb29rQXQ9ZnVuY3Rpb24oYixjLGQsZSl7Yz1jfHwwLGQ9ZHx8MCxlPWV8fDA7dmFyIGY9Yi5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKSxnPS1NYXRoLmF0YW4yKGYueixmLngpLU1hdGguUEkvMixoPU1hdGguc3FydChmLngqZi54K2YueipmLnopLGk9TWF0aC5hdGFuMihmLnksaCk7dGhpcy5yb3RhdGlvblF1YXRlcm5pb249YS5RdWF0ZXJuaW9uLlJvdGF0aW9uWWF3UGl0Y2hSb2xsKGcrYyxpK2QsZSl9LGMucHJvdG90eXBlLmlzSW5GcnVzdHVtPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9ib3VuZGluZ0luZm8uaXNJbkZydXN0dW0oYSk/ITA6ITF9LGMucHJvdG90eXBlLmludGVyc2VjdHNNZXNoPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mbyYmYS5fYm91bmRpbmdJbmZvP3RoaXMuX2JvdW5kaW5nSW5mby5pbnRlcnNlY3RzKGEuX2JvdW5kaW5nSW5mbyxiKTohMX0sYy5wcm90b3R5cGUuaW50ZXJzZWN0c1BvaW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9ib3VuZGluZ0luZm8/dGhpcy5fYm91bmRpbmdJbmZvLmludGVyc2VjdHNQb2ludChhKTohMX0sYy5wcm90b3R5cGUuc2V0UGh5c2ljc1N0YXRlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLmdldFBoeXNpY3NFbmdpbmUoKTtpZihkKXtpZihiLmltcG9zdG9yJiYoYz1iLGI9Yi5pbXBvc3RvciksYj1ifHxhLlBoeXNpY3NFbmdpbmUuTm9JbXBvc3RvcixiPT09YS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3IpcmV0dXJuIHZvaWQgZC5fdW5yZWdpc3Rlck1lc2godGhpcyk7Yy5tYXNzPWMubWFzc3x8MCxjLmZyaWN0aW9uPWMuZnJpY3Rpb258fC4yLGMucmVzdGl0dXRpb249Yy5yZXN0aXR1dGlvbnx8LjksdGhpcy5fcGh5c2ljSW1wb3N0b3I9Yix0aGlzLl9waHlzaWNzTWFzcz1jLm1hc3MsdGhpcy5fcGh5c2ljc0ZyaWN0aW9uPWMuZnJpY3Rpb24sdGhpcy5fcGh5c2ljUmVzdGl0dXRpb249Yy5yZXN0aXR1dGlvbixkLl9yZWdpc3Rlck1lc2godGhpcyxiLGMpfX0sYy5wcm90b3R5cGUuZ2V0UGh5c2ljc0ltcG9zdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BoeXNpY0ltcG9zdG9yP3RoaXMuX3BoeXNpY0ltcG9zdG9yOmEuUGh5c2ljc0VuZ2luZS5Ob0ltcG9zdG9yfSxjLnByb3RvdHlwZS5nZXRQaHlzaWNzTWFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9waHlzaWNzTWFzcz90aGlzLl9waHlzaWNzTWFzczowfSxjLnByb3RvdHlwZS5nZXRQaHlzaWNzRnJpY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGh5c2ljc0ZyaWN0aW9uP3RoaXMuX3BoeXNpY3NGcmljdGlvbjowfSxjLnByb3RvdHlwZS5nZXRQaHlzaWNzUmVzdGl0dXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGh5c2ljUmVzdGl0dXRpb24/dGhpcy5fcGh5c2ljUmVzdGl0dXRpb246MH0sYy5wcm90b3R5cGUuYXBwbHlJbXB1bHNlPWZ1bmN0aW9uKGEsYil7dGhpcy5fcGh5c2ljSW1wb3N0b3ImJnRoaXMuZ2V0U2NlbmUoKS5nZXRQaHlzaWNzRW5naW5lKCkuX2FwcGx5SW1wdWxzZSh0aGlzLGEsYil9LGMucHJvdG90eXBlLnNldFBoeXNpY3NMaW5rV2l0aD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9waHlzaWNJbXBvc3RvciYmdGhpcy5nZXRTY2VuZSgpLmdldFBoeXNpY3NFbmdpbmUoKS5fY3JlYXRlTGluayh0aGlzLGEsYixjLGQpfSxjLnByb3RvdHlwZS51cGRhdGVQaHlzaWNzQm9keVBvc2l0aW9uPWZ1bmN0aW9uKCl7dGhpcy5fcGh5c2ljSW1wb3N0b3ImJnRoaXMuZ2V0U2NlbmUoKS5nZXRQaHlzaWNzRW5naW5lKCkuX3VwZGF0ZUJvZHlQb3NpdGlvbih0aGlzKX0sYy5wcm90b3R5cGUubW92ZVdpdGhDb2xsaXNpb25zPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO2Muc3VidHJhY3RGcm9tRmxvYXRzVG9SZWYoMCx0aGlzLmVsbGlwc29pZC55LDAsdGhpcy5fb2xkUG9zaXRpb25Gb3JDb2xsaXNpb25zKSx0aGlzLl9vbGRQb3NpdGlvbkZvckNvbGxpc2lvbnMuYWRkSW5QbGFjZSh0aGlzLmVsbGlwc29pZE9mZnNldCksdGhpcy5fY29sbGlkZXIucmFkaXVzPXRoaXMuZWxsaXBzb2lkLHRoaXMuZ2V0U2NlbmUoKS5fZ2V0TmV3UG9zaXRpb24odGhpcy5fb2xkUG9zaXRpb25Gb3JDb2xsaXNpb25zLGIsdGhpcy5fY29sbGlkZXIsMyx0aGlzLl9uZXdQb3NpdGlvbkZvckNvbGxpc2lvbnMsdGhpcyksdGhpcy5fbmV3UG9zaXRpb25Gb3JDb2xsaXNpb25zLnN1YnRyYWN0VG9SZWYodGhpcy5fb2xkUG9zaXRpb25Gb3JDb2xsaXNpb25zLHRoaXMuX2RpZmZQb3NpdGlvbkZvckNvbGxpc2lvbnMpLHRoaXMuX2RpZmZQb3NpdGlvbkZvckNvbGxpc2lvbnMubGVuZ3RoKCk+YS5FbmdpbmUuQ29sbGlzaW9uc0Vwc2lsb24mJnRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLl9kaWZmUG9zaXRpb25Gb3JDb2xsaXNpb25zKX0sYy5wcm90b3R5cGUuY3JlYXRlT3JVcGRhdGVTdWJtZXNoZXNPY3RyZWU9ZnVuY3Rpb24oYixjKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9NjQpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjJiYoYz0yKSx0aGlzLl9zdWJtZXNoZXNPY3RyZWV8fCh0aGlzLl9zdWJtZXNoZXNPY3RyZWU9bmV3IGEuT2N0cmVlKGEuT2N0cmVlLkNyZWF0aW9uRnVuY0ZvclN1Yk1lc2hlcyxiLGMpKSx0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCghMCk7dmFyIGQ9dGhpcy5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveDtyZXR1cm4gdGhpcy5fc3VibWVzaGVzT2N0cmVlLnVwZGF0ZShkLm1pbmltdW1Xb3JsZCxkLm1heGltdW1Xb3JsZCx0aGlzLnN1Yk1lc2hlcyksdGhpcy5fc3VibWVzaGVzT2N0cmVlfSxjLnByb3RvdHlwZS5fY29sbGlkZUZvclN1Yk1lc2g9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMuX2dlbmVyYXRlUG9pbnRzQXJyYXkoKSwhYi5fbGFzdENvbGxpZGVyV29ybGRWZXJ0aWNlc3x8IWIuX2xhc3RDb2xsaWRlclRyYW5zZm9ybU1hdHJpeC5lcXVhbHMoYykpe2IuX2xhc3RDb2xsaWRlclRyYW5zZm9ybU1hdHJpeD1jLmNsb25lKCksYi5fbGFzdENvbGxpZGVyV29ybGRWZXJ0aWNlcz1bXSxiLl90cmlhbmdsZVBsYW5lcz1bXTtmb3IodmFyIGU9Yi52ZXJ0aWNlc1N0YXJ0LGY9Yi52ZXJ0aWNlc1N0YXJ0K2IudmVydGljZXNDb3VudCxnPWU7Zj5nO2crKyliLl9sYXN0Q29sbGlkZXJXb3JsZFZlcnRpY2VzLnB1c2goYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMuX3Bvc2l0aW9uc1tnXSxjKSl9ZC5fY29sbGlkZShiLGIuX2xhc3RDb2xsaWRlcldvcmxkVmVydGljZXMsdGhpcy5nZXRJbmRpY2VzKCksYi5pbmRleFN0YXJ0LGIuaW5kZXhTdGFydCtiLmluZGV4Q291bnQsYi52ZXJ0aWNlc1N0YXJ0KX0sYy5wcm90b3R5cGUuX3Byb2Nlc3NDb2xsaXNpb25zRm9yU3ViTWVzaGVzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtpZih0aGlzLl9zdWJtZXNoZXNPY3RyZWUmJnRoaXMudXNlT2N0cmVlRm9yQ29sbGlzaW9ucyl7dmFyIGU9YS52ZWxvY2l0eVdvcmxkTGVuZ3RoK01hdGgubWF4KGEucmFkaXVzLngsYS5yYWRpdXMueSxhLnJhZGl1cy56KSxmPXRoaXMuX3N1Ym1lc2hlc09jdHJlZS5pbnRlcnNlY3RzKGEuYmFzZVBvaW50V29ybGQsZSk7ZD1mLmxlbmd0aCxjPWYuZGF0YX1lbHNlIGM9dGhpcy5zdWJNZXNoZXMsZD1jLmxlbmd0aDtmb3IodmFyIGc9MDtkPmc7ZysrKXt2YXIgaD1jW2ddO2Q+MSYmIWguX2NoZWNrQ29sbGlzaW9uKGEpfHx0aGlzLl9jb2xsaWRlRm9yU3ViTWVzaChoLGIsYSl9fSxjLnByb3RvdHlwZS5fY2hlY2tDb2xsaXNpb249ZnVuY3Rpb24oYil7dGhpcy5fYm91bmRpbmdJbmZvLl9jaGVja0NvbGxpc2lvbihiKSYmKGEuTWF0cml4LlNjYWxpbmdUb1JlZigxL2IucmFkaXVzLngsMS9iLnJhZGl1cy55LDEvYi5yYWRpdXMueix0aGlzLl9jb2xsaXNpb25zU2NhbGluZ01hdHJpeCksdGhpcy53b3JsZE1hdHJpeEZyb21DYWNoZS5tdWx0aXBseVRvUmVmKHRoaXMuX2NvbGxpc2lvbnNTY2FsaW5nTWF0cml4LHRoaXMuX2NvbGxpc2lvbnNUcmFuc2Zvcm1NYXRyaXgpLHRoaXMuX3Byb2Nlc3NDb2xsaXNpb25zRm9yU3ViTWVzaGVzKGIsdGhpcy5fY29sbGlzaW9uc1RyYW5zZm9ybU1hdHJpeCkpfSxjLnByb3RvdHlwZS5fZ2VuZXJhdGVQb2ludHNBcnJheT1mdW5jdGlvbigpe3JldHVybiExfSxjLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuUGlja2luZ0luZm87aWYoISh0aGlzLnN1Yk1lc2hlcyYmdGhpcy5fYm91bmRpbmdJbmZvJiZiLmludGVyc2VjdHNTcGhlcmUodGhpcy5fYm91bmRpbmdJbmZvLmJvdW5kaW5nU3BoZXJlKSYmYi5pbnRlcnNlY3RzQm94KHRoaXMuX2JvdW5kaW5nSW5mby5ib3VuZGluZ0JveCkpKXJldHVybiBkO2lmKCF0aGlzLl9nZW5lcmF0ZVBvaW50c0FycmF5KCkpcmV0dXJuIGQ7dmFyIGUsZixnPW51bGw7aWYodGhpcy5fc3VibWVzaGVzT2N0cmVlJiZ0aGlzLnVzZU9jdHJlZUZvclBpY2tpbmcpe3ZhciBoPWEuUmF5LlRyYW5zZm9ybShiLHRoaXMuZ2V0V29ybGRNYXRyaXgoKSksaT10aGlzLl9zdWJtZXNoZXNPY3RyZWUuaW50ZXJzZWN0c1JheShoKTtmPWkubGVuZ3RoLGU9aS5kYXRhfWVsc2UgZT10aGlzLnN1Yk1lc2hlcyxmPWUubGVuZ3RoO2Zvcih2YXIgaj0wO2Y+ajtqKyspe3ZhciBrPWVbal07aWYoIShmPjEpfHxrLmNhbkludGVyc2VjdHMoYikpe3ZhciBsPWsuaW50ZXJzZWN0cyhiLHRoaXMuX3Bvc2l0aW9ucyx0aGlzLmdldEluZGljZXMoKSxjKTtpZihsJiYoY3x8IWd8fGwuZGlzdGFuY2U8Zy5kaXN0YW5jZSkmJihnPWwsYykpYnJlYWt9fWlmKGcpe3ZhciBtPXRoaXMuZ2V0V29ybGRNYXRyaXgoKSxuPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhiLm9yaWdpbixtKSxvPWIuZGlyZWN0aW9uLmNsb25lKCk7by5ub3JtYWxpemUoKSxvPW8uc2NhbGUoZy5kaXN0YW5jZSk7dmFyIHA9YS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChvLG0pLHE9bi5hZGQocCk7cmV0dXJuIGQuaGl0PSEwLGQuZGlzdGFuY2U9YS5WZWN0b3IzLkRpc3RhbmNlKG4scSksZC5waWNrZWRQb2ludD1xLGQucGlja2VkTWVzaD10aGlzLGQuYnU9Zy5idSxkLmJ2PWcuYnYsZC5mYWNlSWQ9Zy5mYWNlSWQsZH1yZXR1cm4gZH0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYy5wcm90b3R5cGUucmVsZWFzZVN1Yk1lc2hlcz1mdW5jdGlvbigpe2lmKHRoaXMuc3ViTWVzaGVzKWZvcig7dGhpcy5zdWJNZXNoZXMubGVuZ3RoOyl0aGlzLnN1Yk1lc2hlc1swXS5kaXNwb3NlKCk7XG5lbHNlIHRoaXMuc3ViTWVzaGVzPW5ldyBBcnJheX0sYy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbihiKXtmb3IodGhpcy5nZXRQaHlzaWNzSW1wb3N0b3IoKSE9YS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3ImJnRoaXMuc2V0UGh5c2ljc1N0YXRlKGEuUGh5c2ljc0VuZ2luZS5Ob0ltcG9zdG9yKSxlPTA7ZTx0aGlzLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcy5sZW5ndGg7ZSsrKXt2YXIgYz10aGlzLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzc1tlXSxkPWMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzLmluZGV4T2YodGhpcyk7Yy5faW50ZXJzZWN0aW9uc0luUHJvZ3Jlc3Muc3BsaWNlKGQsMSl9dGhpcy5faW50ZXJzZWN0aW9uc0luUHJvZ3Jlc3M9W10sdGhpcy5yZWxlYXNlU3ViTWVzaGVzKCk7dmFyIGU9dGhpcy5nZXRTY2VuZSgpLm1lc2hlcy5pbmRleE9mKHRoaXMpO2lmKHRoaXMuZ2V0U2NlbmUoKS5tZXNoZXMuc3BsaWNlKGUsMSksYilmb3IoZT0wO2U8dGhpcy5nZXRTY2VuZSgpLm1lc2hlcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLmdldFNjZW5lKCkubWVzaGVzW2VdO2YucGFyZW50PT09dGhpcyYmKGYucGFyZW50PW51bGwsZi5jb21wdXRlV29ybGRNYXRyaXgoITApKX1lbHNle2ZvcihlPTA7ZTx0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtlKyspdGhpcy5nZXRTY2VuZSgpLnBhcnRpY2xlU3lzdGVtc1tlXS5lbWl0dGVyPT10aGlzJiYodGhpcy5nZXRTY2VuZSgpLnBhcnRpY2xlU3lzdGVtc1tlXS5kaXNwb3NlKCksZS0tKTt2YXIgZz10aGlzLmdldFNjZW5lKCkubWVzaGVzLnNsaWNlKDApO2ZvcihlPTA7ZTxnLmxlbmd0aDtlKyspZ1tlXS5wYXJlbnQ9PXRoaXMmJmdbZV0uZGlzcG9zZSgpfXRoaXMuX2lzRGlzcG9zZWQ9ITAsdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCl9LGMuX0JJTExCT0FSRE1PREVfTk9ORT0wLGMuX0JJTExCT0FSRE1PREVfWD0xLGMuX0JJTExCT0FSRE1PREVfWT0yLGMuX0JJTExCT0FSRE1PREVfWj00LGMuX0JJTExCT0FSRE1PREVfQUxMPTcsY30oYS5Ob2RlKTthLkFic3RyYWN0TWVzaD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dGhpcy5tdXN0UmV0dXJuPSExLHRoaXMudmlzaWJsZUluc3RhbmNlcz1uZXcgQXJyYXksdGhpcy5yZW5kZXJTZWxmPW5ldyBBcnJheX1yZXR1cm4gYX0oKTthLl9JbnN0YW5jZXNCYXRjaD1iO3ZhciBjPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoZCxlKXtjLmNhbGwodGhpcyxkLGUpLHRoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9ORSx0aGlzLmluc3RhbmNlcz1uZXcgQXJyYXksdGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3M9bmV3IEFycmF5LHRoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3M9bmV3IEFycmF5LHRoaXMuX3Zpc2libGVJbnN0YW5jZXM9e30sdGhpcy5fcmVuZGVySWRGb3JJbnN0YW5jZXM9bmV3IEFycmF5LHRoaXMuX2JhdGNoQ2FjaGU9bmV3IGIsdGhpcy5faW5zdGFuY2VzQnVmZmVyU2l6ZT0yMDQ4fXJldHVybiBfX2V4dGVuZHMoZCxjKSxkLnByb3RvdHlwZS5nZXRUb3RhbFZlcnRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJ5P3RoaXMuX2dlb21ldHJ5LmdldFRvdGFsVmVydGljZXMoKTowfSxkLnByb3RvdHlwZS5nZXRWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2dlb21ldHJ5P3RoaXMuX2dlb21ldHJ5LmdldFZlcnRpY2VzRGF0YShhKTpudWxsfSxkLnByb3RvdHlwZS5nZXRWZXJ0ZXhCdWZmZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2dlb21ldHJ5P3RoaXMuX2dlb21ldHJ5LmdldFZlcnRleEJ1ZmZlcihhKTp2b2lkIDB9LGQucHJvdG90eXBlLmlzVmVydGljZXNEYXRhUHJlc2VudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEpOnRoaXMuX2RlbGF5SW5mbz8tMSE9PXRoaXMuX2RlbGF5SW5mby5pbmRleE9mKGEpOiExfSxkLnByb3RvdHlwZS5nZXRWZXJ0aWNlc0RhdGFLaW5kcz1mdW5jdGlvbigpe2lmKCF0aGlzLl9nZW9tZXRyeSl7dmFyIGE9W107aWYodGhpcy5fZGVsYXlJbmZvKWZvcih2YXIgYiBpbiB0aGlzLl9kZWxheUluZm8pYS5wdXNoKGIpO3JldHVybiBhfXJldHVybiB0aGlzLl9nZW9tZXRyeS5nZXRWZXJ0aWNlc0RhdGFLaW5kcygpfSxkLnByb3RvdHlwZS5nZXRUb3RhbEluZGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkuZ2V0VG90YWxJbmRpY2VzKCk6MH0sZC5wcm90b3R5cGUuZ2V0SW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZW9tZXRyeT90aGlzLl9nZW9tZXRyeS5nZXRJbmRpY2VzKCk6W119LGQucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURJTkc/ITE6Yy5wcm90b3R5cGUuaXNSZWFkeS5jYWxsKHRoaXMpfSxkLnByb3RvdHlwZS5pc0Rpc3Bvc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRGlzcG9zZWR9LGQucHJvdG90eXBlLl9wcmVBY3RpdmF0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpO3RoaXMuX3ByZUFjdGl2YXRlSWQhPWEmJih0aGlzLl9wcmVBY3RpdmF0ZUlkPWEsdGhpcy5fdmlzaWJsZUluc3RhbmNlcz1udWxsKX0sZC5wcm90b3R5cGUuX3JlZ2lzdGVySW5zdGFuY2VGb3JSZW5kZXJJZD1mdW5jdGlvbihhLGIpe3RoaXMuX3Zpc2libGVJbnN0YW5jZXN8fCh0aGlzLl92aXNpYmxlSW5zdGFuY2VzPXt9LHRoaXMuX3Zpc2libGVJbnN0YW5jZXMuZGVmYXVsdFJlbmRlcklkPWIsdGhpcy5fdmlzaWJsZUluc3RhbmNlcy5zZWxmRGVmYXVsdFJlbmRlcklkPXRoaXMuX3JlbmRlcklkKSx0aGlzLl92aXNpYmxlSW5zdGFuY2VzW2JdfHwodGhpcy5fdmlzaWJsZUluc3RhbmNlc1tiXT1uZXcgQXJyYXkpLHRoaXMuX3Zpc2libGVJbnN0YW5jZXNbYl0ucHVzaChhKX0sZC5wcm90b3R5cGUucmVmcmVzaEJvdW5kaW5nSW5mbz1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCk7aWYoYil7dmFyIGM9YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KGIsMCx0aGlzLmdldFRvdGFsVmVydGljZXMoKSk7dGhpcy5fYm91bmRpbmdJbmZvPW5ldyBhLkJvdW5kaW5nSW5mbyhjLm1pbmltdW0sYy5tYXhpbXVtKX1pZih0aGlzLnN1Yk1lc2hlcylmb3IodmFyIGQ9MDtkPHRoaXMuc3ViTWVzaGVzLmxlbmd0aDtkKyspdGhpcy5zdWJNZXNoZXNbZF0ucmVmcmVzaEJvdW5kaW5nSW5mbygpO3RoaXMuX3VwZGF0ZUJvdW5kaW5nSW5mbygpfSxkLnByb3RvdHlwZS5fY3JlYXRlR2xvYmFsU3ViTWVzaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZ2V0VG90YWxWZXJ0aWNlcygpO3JldHVybiBiJiZ0aGlzLmdldEluZGljZXMoKT8odGhpcy5yZWxlYXNlU3ViTWVzaGVzKCksbmV3IGEuU3ViTWVzaCgwLDAsYiwwLHRoaXMuZ2V0VG90YWxJbmRpY2VzKCksdGhpcykpOm51bGx9LGQucHJvdG90eXBlLnN1YmRpdmlkZT1mdW5jdGlvbihiKXtpZighKDE+Yikpe2Zvcih2YXIgYz10aGlzLmdldFRvdGFsSW5kaWNlcygpLGQ9Yy9ifDAsZT0wO2QlMyE9MDspZCsrO3RoaXMucmVsZWFzZVN1Yk1lc2hlcygpO2Zvcih2YXIgZj0wO2I+ZiYmIShlPj1jKTtmKyspYS5TdWJNZXNoLkNyZWF0ZUZyb21JbmRpY2VzKDAsZSxNYXRoLm1pbihkLGMtZSksdGhpcyksZSs9ZDt0aGlzLnN5bmNocm9uaXplSW5zdGFuY2VzKCl9fSxkLnByb3RvdHlwZS5zZXRWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYixjLGQpe2lmKGIgaW5zdGFuY2VvZiBBcnJheSl7dmFyIGU9YztjPWIsYj1lLGEuVG9vbHMuV2FybihcIkRlcHJlY2F0ZWQgdXNhZ2Ugb2Ygc2V0VmVydGljZXNEYXRhIGRldGVjdGVkIChzaW5jZSB2MS4xMikuIEN1cnJlbnQgc2lnbmF0dXJlIGlzIHNldFZlcnRpY2VzRGF0YShraW5kLCBkYXRhLCB1cGRhdGFibGUpLlwiKX1pZih0aGlzLl9nZW9tZXRyeSl0aGlzLl9nZW9tZXRyeS5zZXRWZXJ0aWNlc0RhdGEoYixjLGQpO2Vsc2V7dmFyIGY9bmV3IGEuVmVydGV4RGF0YTtmLnNldChjLGIpO3ZhciBnPXRoaXMuZ2V0U2NlbmUoKTtuZXcgYS5HZW9tZXRyeShhLkdlb21ldHJ5LlJhbmRvbUlkKCksZyxmLGQsdGhpcyl9fSxkLnByb3RvdHlwZS51cGRhdGVWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5fZ2VvbWV0cnkmJihkPyh0aGlzLm1ha2VHZW9tZXRyeVVuaXF1ZSgpLHRoaXMudXBkYXRlVmVydGljZXNEYXRhKGEsYixjLCExKSk6dGhpcy5fZ2VvbWV0cnkudXBkYXRlVmVydGljZXNEYXRhKGEsYixjKSl9LGQucHJvdG90eXBlLm1ha2VHZW9tZXRyeVVuaXF1ZT1mdW5jdGlvbigpe2lmKHRoaXMuX2dlb21ldHJ5KXt2YXIgYj10aGlzLl9nZW9tZXRyeS5jb3B5KGEuR2VvbWV0cnkuUmFuZG9tSWQoKSk7Yi5hcHBseVRvTWVzaCh0aGlzKX19LGQucHJvdG90eXBlLnNldEluZGljZXM9ZnVuY3Rpb24oYil7aWYodGhpcy5fZ2VvbWV0cnkpdGhpcy5fZ2VvbWV0cnkuc2V0SW5kaWNlcyhiKTtlbHNle3ZhciBjPW5ldyBhLlZlcnRleERhdGE7Yy5pbmRpY2VzPWI7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpO25ldyBhLkdlb21ldHJ5KGEuR2VvbWV0cnkuUmFuZG9tSWQoKSxkLGMsITEsdGhpcyl9fSxkLnByb3RvdHlwZS5fYmluZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLGU9dGhpcy5fZ2VvbWV0cnkuZ2V0SW5kZXhCdWZmZXIoKTtjJiYoZT1hLmdldExpbmVzSW5kZXhCdWZmZXIodGhpcy5nZXRJbmRpY2VzKCksZCkpLGQuYmluZE11bHRpQnVmZmVycyh0aGlzLl9nZW9tZXRyeS5nZXRWZXJ0ZXhCdWZmZXJzKCksZSxiKX0sZC5wcm90b3R5cGUuX2RyYXc9ZnVuY3Rpb24oYSxiLGMpe2lmKHRoaXMuX2dlb21ldHJ5JiZ0aGlzLl9nZW9tZXRyeS5nZXRWZXJ0ZXhCdWZmZXJzKCkmJnRoaXMuX2dlb21ldHJ5LmdldEluZGV4QnVmZmVyKCkpe3ZhciBkPXRoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKTtkLmRyYXcoYixiP2EuaW5kZXhTdGFydDowLGI/YS5pbmRleENvdW50OmEubGluZXNJbmRleENvdW50LGMpfX0sZC5wcm90b3R5cGUucmVnaXN0ZXJCZWZvcmVSZW5kZXI9ZnVuY3Rpb24oYSl7dGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3MucHVzaChhKX0sZC5wcm90b3R5cGUudW5yZWdpc3RlckJlZm9yZVJlbmRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcy5pbmRleE9mKGEpO2I+LTEmJnRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLnNwbGljZShiLDEpfSxkLnByb3RvdHlwZS5yZWdpc3RlckFmdGVyUmVuZGVyPWZ1bmN0aW9uKGEpe3RoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3MucHVzaChhKX0sZC5wcm90b3R5cGUudW5yZWdpc3RlckFmdGVyUmVuZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3MuaW5kZXhPZihhKTtiPi0xJiZ0aGlzLl9vbkFmdGVyUmVuZGVyQ2FsbGJhY2tzLnNwbGljZShiLDEpfSxkLnByb3RvdHlwZS5fZ2V0SW5zdGFuY2VzUmVuZGVyTGlzdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldFNjZW5lKCk7aWYodGhpcy5fYmF0Y2hDYWNoZS5tdXN0UmV0dXJuPSExLHRoaXMuX2JhdGNoQ2FjaGUucmVuZGVyU2VsZlthXT10aGlzLmlzRW5hYmxlZCgpJiZ0aGlzLmlzVmlzaWJsZSx0aGlzLl9iYXRjaENhY2hlLnZpc2libGVJbnN0YW5jZXNbYV09bnVsbCx0aGlzLl92aXNpYmxlSW5zdGFuY2VzKXt2YXIgYz1iLmdldFJlbmRlcklkKCk7dGhpcy5fYmF0Y2hDYWNoZS52aXNpYmxlSW5zdGFuY2VzW2FdPXRoaXMuX3Zpc2libGVJbnN0YW5jZXNbY107dmFyIGQ9dGhpcy5fcmVuZGVySWQ7aWYoIXRoaXMuX2JhdGNoQ2FjaGUudmlzaWJsZUluc3RhbmNlc1thXSYmdGhpcy5fdmlzaWJsZUluc3RhbmNlcy5kZWZhdWx0UmVuZGVySWQmJih0aGlzLl9iYXRjaENhY2hlLnZpc2libGVJbnN0YW5jZXNbYV09dGhpcy5fdmlzaWJsZUluc3RhbmNlc1t0aGlzLl92aXNpYmxlSW5zdGFuY2VzLmRlZmF1bHRSZW5kZXJJZF0sYz10aGlzLl92aXNpYmxlSW5zdGFuY2VzLmRlZmF1bHRSZW5kZXJJZCxkPXRoaXMuX3Zpc2libGVJbnN0YW5jZXMuc2VsZkRlZmF1bHRSZW5kZXJJZCksdGhpcy5fYmF0Y2hDYWNoZS52aXNpYmxlSW5zdGFuY2VzW2FdJiZ0aGlzLl9iYXRjaENhY2hlLnZpc2libGVJbnN0YW5jZXNbYV0ubGVuZ3RoKXtpZih0aGlzLl9yZW5kZXJJZEZvckluc3RhbmNlc1thXT09PWMpcmV0dXJuIHRoaXMuX2JhdGNoQ2FjaGUubXVzdFJldHVybj0hMCx0aGlzLl9iYXRjaENhY2hlO2MhPT1kJiYodGhpcy5fYmF0Y2hDYWNoZS5yZW5kZXJTZWxmW2FdPSExKX10aGlzLl9yZW5kZXJJZEZvckluc3RhbmNlc1thXT1jfXJldHVybiB0aGlzLl9iYXRjaENhY2hlfSxkLnByb3RvdHlwZS5fcmVuZGVyV2l0aEluc3RhbmNlcz1mdW5jdGlvbihhLGIsYyxkLGUpe2Zvcih2YXIgZj10aGlzLmluc3RhbmNlcy5sZW5ndGgrMSxnPTE2KmYqNDt0aGlzLl9pbnN0YW5jZXNCdWZmZXJTaXplPGc7KXRoaXMuX2luc3RhbmNlc0J1ZmZlclNpemUqPTI7KCF0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyfHx0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyLmNhcGFjaXR5PHRoaXMuX2luc3RhbmNlc0J1ZmZlclNpemUpJiYodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlciYmZS5kZWxldGVJbnN0YW5jZXNCdWZmZXIodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlciksdGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlcj1lLmNyZWF0ZUluc3RhbmNlc0J1ZmZlcih0aGlzLl9pbnN0YW5jZXNCdWZmZXJTaXplKSx0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQXJyYXk9bmV3IEZsb2F0MzJBcnJheSh0aGlzLl9pbnN0YW5jZXNCdWZmZXJTaXplLzQpKTt2YXIgaD0wLGk9MCxqPXRoaXMuZ2V0V29ybGRNYXRyaXgoKTtjLnJlbmRlclNlbGZbYS5faWRdJiYoai5jb3B5VG9BcnJheSh0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQXJyYXksaCksaCs9MTYsaSsrKTt2YXIgaz1jLnZpc2libGVJbnN0YW5jZXNbYS5faWRdO2lmKGspZm9yKHZhciBsPTA7bDxrLmxlbmd0aDtsKyspe3ZhciBtPWtbbF07bS5nZXRXb3JsZE1hdHJpeCgpLmNvcHlUb0FycmF5KHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNBcnJheSxoKSxoKz0xNixpKyt9dmFyIG49ZC5nZXRBdHRyaWJ1dGVMb2NhdGlvbkJ5TmFtZShcIndvcmxkMFwiKSxvPWQuZ2V0QXR0cmlidXRlTG9jYXRpb25CeU5hbWUoXCJ3b3JsZDFcIikscD1kLmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lKFwid29ybGQyXCIpLHE9ZC5nZXRBdHRyaWJ1dGVMb2NhdGlvbkJ5TmFtZShcIndvcmxkM1wiKSxyPVtuLG8scCxxXTtlLnVwZGF0ZUFuZEJpbmRJbnN0YW5jZXNCdWZmZXIodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlcix0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQXJyYXksciksdGhpcy5fZHJhdyhhLCFiLGkpLGUudW5CaW5kSW5zdGFuY2VzQnVmZmVyKHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNCdWZmZXIscil9LGQucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldFNjZW5lKCksYz10aGlzLl9nZXRJbnN0YW5jZXNSZW5kZXJMaXN0KGEuX2lkKTtpZighYy5tdXN0UmV0dXJuJiZ0aGlzLl9nZW9tZXRyeSYmdGhpcy5fZ2VvbWV0cnkuZ2V0VmVydGV4QnVmZmVycygpJiZ0aGlzLl9nZW9tZXRyeS5nZXRJbmRleEJ1ZmZlcigpKXtmb3IodmFyIGQ9MDtkPHRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLmxlbmd0aDtkKyspdGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3NbZF0oKTt2YXIgZT1iLmdldEVuZ2luZSgpLGY9bnVsbCE9PWUuZ2V0Q2FwcygpLmluc3RhbmNlZEFycmF5cyYmbnVsbCE9PWMudmlzaWJsZUluc3RhbmNlc1thLl9pZF0sZz1hLmdldE1hdGVyaWFsKCk7aWYoZyYmZy5pc1JlYWR5KHRoaXMsZikpe2cuX3ByZUJpbmQoKTt2YXIgaD1nLmdldEVmZmVjdCgpLGk9ZS5mb3JjZVdpcmVmcmFtZXx8Zy53aXJlZnJhbWU7dGhpcy5fYmluZChhLGgsaSk7dmFyIGo9dGhpcy5nZXRXb3JsZE1hdHJpeCgpO2lmKGcuYmluZChqLHRoaXMpLGYpdGhpcy5fcmVuZGVyV2l0aEluc3RhbmNlcyhhLGksYyxoLGUpO2Vsc2UgaWYoYy5yZW5kZXJTZWxmW2EuX2lkXSYmdGhpcy5fZHJhdyhhLCFpKSxjLnZpc2libGVJbnN0YW5jZXNbYS5faWRdKWZvcih2YXIgaz0wO2s8Yy52aXNpYmxlSW5zdGFuY2VzW2EuX2lkXS5sZW5ndGg7aysrKXt2YXIgbD1jLnZpc2libGVJbnN0YW5jZXNbYS5faWRdW2tdO2o9bC5nZXRXb3JsZE1hdHJpeCgpLGcuYmluZE9ubHlXb3JsZE1hdHJpeChqKSx0aGlzLl9kcmF3KGEsIWkpfWZvcihnLnVuYmluZCgpLGQ9MDtkPHRoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3MubGVuZ3RoO2QrKyl0aGlzLl9vbkFmdGVyUmVuZGVyQ2FsbGJhY2tzW2RdKCl9fX0sZC5wcm90b3R5cGUuZ2V0RW1pdHRlZFBhcnRpY2xlU3lzdGVtcz1mdW5jdGlvbigpe2Zvcih2YXIgYT1uZXcgQXJyYXksYj0wO2I8dGhpcy5nZXRTY2VuZSgpLnBhcnRpY2xlU3lzdGVtcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zW2JdO2MuZW1pdHRlcj09PXRoaXMmJmEucHVzaChjKX1yZXR1cm4gYX0sZC5wcm90b3R5cGUuZ2V0SGllcmFyY2h5RW1pdHRlZFBhcnRpY2xlU3lzdGVtcz1mdW5jdGlvbigpe3ZhciBhPW5ldyBBcnJheSxiPXRoaXMuZ2V0RGVzY2VuZGFudHMoKTtiLnB1c2godGhpcyk7Zm9yKHZhciBjPTA7Yzx0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuZ2V0U2NlbmUoKS5wYXJ0aWNsZVN5c3RlbXNbY107LTEhPT1iLmluZGV4T2YoZC5lbWl0dGVyKSYmYS5wdXNoKGQpfXJldHVybiBhfSxkLnByb3RvdHlwZS5nZXRDaGlsZHJlbj1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxiPTA7Yjx0aGlzLmdldFNjZW5lKCkubWVzaGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuZ2V0U2NlbmUoKS5tZXNoZXNbYl07Yy5wYXJlbnQ9PXRoaXMmJmEucHVzaChjKX1yZXR1cm4gYX0sZC5wcm90b3R5cGUuX2NoZWNrRGVsYXlTdGF0ZT1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz10aGlzLGQ9dGhpcy5nZXRTY2VuZSgpO3RoaXMuX2dlb21ldHJ5P3RoaXMuX2dlb21ldHJ5LmxvYWQoZCk6Yy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PVExPQURFRCYmKGMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORyxkLl9hZGRQZW5kaW5nRGF0YShjKSxhLlRvb2xzLkxvYWRGaWxlKHRoaXMuZGVsYXlMb2FkaW5nRmlsZSxmdW5jdGlvbihjKXtiLl9kZWxheUxvYWRpbmdGdW5jdGlvbihKU09OLnBhcnNlKGMpLGIpLGIuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BREVELGQuX3JlbW92ZVBlbmRpbmdEYXRhKGIpfSxmdW5jdGlvbigpe30sZC5kYXRhYmFzZSkpfSxkLnByb3RvdHlwZS5pc0luRnJ1c3R1bT1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURJTkc/ITE6Yy5wcm90b3R5cGUuaXNJbkZydXN0dW0uY2FsbCh0aGlzLGIpPyh0aGlzLl9jaGVja0RlbGF5U3RhdGUoKSwhMCk6ITF9LGQucHJvdG90eXBlLnNldE1hdGVyaWFsQnlJRD1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5nZXRTY2VuZSgpLm1hdGVyaWFscyxjPTA7YzxiLmxlbmd0aDtjKyspaWYoYltjXS5pZD09YSlyZXR1cm4gdm9pZCh0aGlzLm1hdGVyaWFsPWJbY10pO3ZhciBkPXRoaXMuZ2V0U2NlbmUoKS5tdWx0aU1hdGVyaWFscztmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGRbY10uaWQ9PWEpcmV0dXJuIHZvaWQodGhpcy5tYXRlcmlhbD1kW2NdKX0sZC5wcm90b3R5cGUuZ2V0QW5pbWF0YWJsZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5tYXRlcmlhbCYmYS5wdXNoKHRoaXMubWF0ZXJpYWwpLGF9LGQucHJvdG90eXBlLmJha2VUcmFuc2Zvcm1JbnRvVmVydGljZXM9ZnVuY3Rpb24oYil7aWYodGhpcy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSl7dGhpcy5fcmVzZXRQb2ludHNBcnJheUNhY2hlKCk7Zm9yKHZhciBjPXRoaXMuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCksZD1bXSxlPTA7ZTxjLmxlbmd0aDtlKz0zKWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhhLlZlY3RvcjMuRnJvbUFycmF5KGMsZSksYikudG9BcnJheShkLGUpO2lmKHRoaXMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCxkLHRoaXMuZ2V0VmVydGV4QnVmZmVyKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkuaXNVcGRhdGFibGUoKSksdGhpcy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCkpe2ZvcihjPXRoaXMuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpLGU9MDtlPGMubGVuZ3RoO2UrPTMpYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChhLlZlY3RvcjMuRnJvbUFycmF5KGMsZSksYikudG9BcnJheShkLGUpO3RoaXMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsZCx0aGlzLmdldFZlcnRleEJ1ZmZlcihhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKS5pc1VwZGF0YWJsZSgpKX19fSxkLnByb3RvdHlwZS5fcmVzZXRQb2ludHNBcnJheUNhY2hlPWZ1bmN0aW9uKCl7dGhpcy5fcG9zaXRpb25zPW51bGx9LGQucHJvdG90eXBlLl9nZW5lcmF0ZVBvaW50c0FycmF5PWZ1bmN0aW9uKCl7aWYodGhpcy5fcG9zaXRpb25zKXJldHVybiEwO3RoaXMuX3Bvc2l0aW9ucz1bXTt2YXIgYj10aGlzLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpO2lmKCFiKXJldHVybiExO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7Yys9Myl0aGlzLl9wb3NpdGlvbnMucHVzaChhLlZlY3RvcjMuRnJvbUFycmF5KGIsYykpO3JldHVybiEwfSxkLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IGEuTWVzaChiLHRoaXMuZ2V0U2NlbmUoKSk7aWYodGhpcy5fZ2VvbWV0cnkuYXBwbHlUb01lc2goZSksYS5Ub29scy5EZWVwQ29weSh0aGlzLGUsW1wibmFtZVwiLFwibWF0ZXJpYWxcIixcInNrZWxldG9uXCJdLFtdKSxlLm1hdGVyaWFsPXRoaXMubWF0ZXJpYWwsYyYmKGUucGFyZW50PWMpLCFkKWZvcih2YXIgZj0wO2Y8dGhpcy5nZXRTY2VuZSgpLm1lc2hlcy5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmdldFNjZW5lKCkubWVzaGVzW2ZdO2cucGFyZW50PT10aGlzJiZnLmNsb25lKGcubmFtZSxlKX1mb3IoZj0wO2Y8dGhpcy5nZXRTY2VuZSgpLnBhcnRpY2xlU3lzdGVtcy5sZW5ndGg7ZisrKXt2YXIgaD10aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zW2ZdO2guZW1pdHRlcj09dGhpcyYmaC5jbG9uZShoLm5hbWUsZSl9cmV0dXJuIGUuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxlfSxkLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe2Zvcih0aGlzLl9nZW9tZXRyeSYmdGhpcy5fZ2VvbWV0cnkucmVsZWFzZUZvck1lc2godGhpcywhMCksdGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlciYmKHRoaXMuZ2V0RW5naW5lKCkuZGVsZXRlSW5zdGFuY2VzQnVmZmVyKHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNCdWZmZXIpLHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNCdWZmZXI9bnVsbCk7dGhpcy5pbnN0YW5jZXMubGVuZ3RoOyl0aGlzLmluc3RhbmNlc1swXS5kaXNwb3NlKCk7Yy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsYSl9LGQucHJvdG90eXBlLmNvbnZlcnRUb0ZsYXRTaGFkZWRNZXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPXRoaXMuZ2V0VmVydGljZXNEYXRhS2luZHMoKSxjPVtdLGQ9W10sZT1bXSxmPSExLGc9MDtnPGIubGVuZ3RoO2crKyl7dmFyIGg9YltnXSxpPXRoaXMuZ2V0VmVydGV4QnVmZmVyKGgpO2ghPT1hLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kPyhjW2hdPWksZFtoXT1jW2hdLmdldERhdGEoKSxlW2hdPVtdKTooZj1pLmlzVXBkYXRhYmxlKCksYi5zcGxpY2UoZywxKSxnLS0pfXZhciBqPXRoaXMuc3ViTWVzaGVzLnNsaWNlKDApLGs9dGhpcy5nZXRJbmRpY2VzKCksbD10aGlzLmdldFRvdGFsSW5kaWNlcygpO2ZvcihyPTA7bD5yO3IrKyl7dmFyIG09a1tyXTtmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKXtoPWJbZ107Zm9yKHZhciBuPWNbaF0uZ2V0U3RyaWRlU2l6ZSgpLG89MDtuPm87bysrKWVbaF0ucHVzaChkW2hdW20qbitvXSl9fWZvcih2YXIgcD1bXSxxPWVbYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kXSxyPTA7bD5yO3IrPTMpe2tbcl09cixrW3IrMV09cisxLGtbcisyXT1yKzI7Zm9yKHZhciBzPWEuVmVjdG9yMy5Gcm9tQXJyYXkocSwzKnIpLHQ9YS5WZWN0b3IzLkZyb21BcnJheShxLDMqKHIrMSkpLHU9YS5WZWN0b3IzLkZyb21BcnJheShxLDMqKHIrMikpLHY9cy5zdWJ0cmFjdCh0KSx3PXUuc3VidHJhY3QodCkseD1hLlZlY3RvcjMuTm9ybWFsaXplKGEuVmVjdG9yMy5Dcm9zcyh2LHcpKSx5PTA7Mz55O3krKylwLnB1c2goeC54KSxwLnB1c2goeC55KSxwLnB1c2goeC56KX1mb3IodGhpcy5zZXRJbmRpY2VzKGspLHRoaXMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQscCxmKSxnPTA7ZzxiLmxlbmd0aDtnKyspaD1iW2ddLHRoaXMuc2V0VmVydGljZXNEYXRhKGgsZVtoXSxjW2hdLmlzVXBkYXRhYmxlKCkpO3RoaXMucmVsZWFzZVN1Yk1lc2hlcygpO2Zvcih2YXIgej0wO3o8ai5sZW5ndGg7eisrKXt2YXIgQT1qW3pdO25ldyBhLlN1Yk1lc2goQS5tYXRlcmlhbEluZGV4LEEuaW5kZXhTdGFydCxBLmluZGV4Q291bnQsQS5pbmRleFN0YXJ0LEEuaW5kZXhDb3VudCx0aGlzKX10aGlzLnN5bmNocm9uaXplSW5zdGFuY2VzKCl9LGQucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlPWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYS5JbnN0YW5jZWRNZXNoKGIsdGhpcyl9LGQucHJvdG90eXBlLnN5bmNocm9uaXplSW5zdGFuY2VzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLmluc3RhbmNlcy5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmluc3RhbmNlc1thXTtiLl9zeW5jU3ViTWVzaGVzKCl9fSxkLkNyZWF0ZUJveD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1uZXcgYS5NZXNoKGIsZCksZz1hLlZlcnRleERhdGEuQ3JlYXRlQm94KGMpO3JldHVybiBnLmFwcGx5VG9NZXNoKGYsZSksZn0sZC5DcmVhdGVTcGhlcmU9ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1uZXcgYS5NZXNoKGIsZSksaD1hLlZlcnRleERhdGEuQ3JlYXRlU3BoZXJlKGMsZCk7cmV0dXJuIGguYXBwbHlUb01lc2goZyxmKSxnfSxkLkNyZWF0ZUN5bGluZGVyPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgsaSl7dm9pZCAwIT09aCYmaCBpbnN0YW5jZW9mIGEuU2NlbmV8fCh2b2lkIDAhPT1oJiYoaT1oKSxoPWcsZz0xKTt2YXIgaj1uZXcgYS5NZXNoKGIsaCksaz1hLlZlcnRleERhdGEuQ3JlYXRlQ3lsaW5kZXIoYyxkLGUsZixnKTtyZXR1cm4gay5hcHBseVRvTWVzaChqLGkpLGp9LGQuQ3JlYXRlVG9ydXM9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe3ZhciBoPW5ldyBhLk1lc2goYixmKSxpPWEuVmVydGV4RGF0YS5DcmVhdGVUb3J1cyhjLGQsZSk7cmV0dXJuIGkuYXBwbHlUb01lc2goaCxnKSxofSxkLkNyZWF0ZVRvcnVzS25vdD1mdW5jdGlvbihiLGMsZCxlLGYsZyxoLGksail7dmFyIGs9bmV3IGEuTWVzaChiLGkpLGw9YS5WZXJ0ZXhEYXRhLkNyZWF0ZVRvcnVzS25vdChjLGQsZSxmLGcsaCk7cmV0dXJuIGwuYXBwbHlUb01lc2goayxqKSxrfSxkLkNyZWF0ZUxpbmVzPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPW5ldyBhLkxpbmVzTWVzaChiLGQsZSksZz1hLlZlcnRleERhdGEuQ3JlYXRlTGluZXMoYyk7cmV0dXJuIGcuYXBwbHlUb01lc2goZixlKSxmfSxkLkNyZWF0ZVBsYW5lPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPW5ldyBhLk1lc2goYixkKSxnPWEuVmVydGV4RGF0YS5DcmVhdGVQbGFuZShjKTtyZXR1cm4gZy5hcHBseVRvTWVzaChmLGUpLGZ9LGQuQ3JlYXRlR3JvdW5kPWZ1bmN0aW9uKGIsYyxkLGUsZixnKXt2YXIgaD1uZXcgYS5Hcm91bmRNZXNoKGIsZik7aC5fc2V0UmVhZHkoITEpLGguX3N1YmRpdmlzaW9ucz1lO3ZhciBpPWEuVmVydGV4RGF0YS5DcmVhdGVHcm91bmQoYyxkLGUpO3JldHVybiBpLmFwcGx5VG9NZXNoKGgsZyksaC5fc2V0UmVhZHkoITApLGh9LGQuQ3JlYXRlVGlsZWRHcm91bmQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpLGope3ZhciBrPW5ldyBhLk1lc2goYixpKSxsPWEuVmVydGV4RGF0YS5DcmVhdGVUaWxlZEdyb3VuZChjLGQsZSxmLGcsaCk7cmV0dXJuIGwuYXBwbHlUb01lc2goayxqKSxrfSxkLkNyZWF0ZUdyb3VuZEZyb21IZWlnaHRNYXA9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpLGope3ZhciBrPW5ldyBhLkdyb3VuZE1lc2goYixpKTtrLl9zdWJkaXZpc2lvbnM9ZixrLl9zZXRSZWFkeSghMSk7dmFyIGw9ZnVuY3Rpb24oYil7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxpPWMuZ2V0Q29udGV4dChcIjJkXCIpLGw9Yi53aWR0aCxtPWIuaGVpZ2h0O2Mud2lkdGg9bCxjLmhlaWdodD1tLGkuZHJhd0ltYWdlKGIsMCwwKTt2YXIgbj1pLmdldEltYWdlRGF0YSgwLDAsbCxtKS5kYXRhLG89YS5WZXJ0ZXhEYXRhLkNyZWF0ZUdyb3VuZEZyb21IZWlnaHRNYXAoZCxlLGYsZyxoLG4sbCxtKTtvLmFwcGx5VG9NZXNoKGssaiksay5fc2V0UmVhZHkoITApfTtyZXR1cm4gYS5Ub29scy5Mb2FkSW1hZ2UoYyxsLGZ1bmN0aW9uKCl7fSxpLmRhdGFiYXNlKSxrfSxkLk1pbk1heD1mdW5jdGlvbihhKXt2YXIgYj1udWxsLGM9bnVsbDtmb3IodmFyIGQgaW4gYSl7dmFyIGU9YVtkXSxmPWUuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3g7Yj8oYi5NaW5pbWl6ZUluUGxhY2UoZi5taW5pbXVtV29ybGQpLGMuTWF4aW1pemVJblBsYWNlKGYubWF4aW11bVdvcmxkKSk6KGI9Zi5taW5pbXVtV29ybGQsYz1mLm1heGltdW1Xb3JsZCl9cmV0dXJue21pbjpiLG1heDpjfX0sZC5DZW50ZXI9ZnVuY3Rpb24oYil7dmFyIGM9dm9pZCAwIT09Yi5taW4/YjphLk1lc2guTWluTWF4KGIpO3JldHVybiBhLlZlY3RvcjMuQ2VudGVyKGMubWluLGMubWF4KX0sZH0oYS5BYnN0cmFjdE1lc2gpO2EuTWVzaD1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe2IuY2FsbCh0aGlzLGMsZCksdGhpcy5nZW5lcmF0ZU9jdHJlZT0hMSx0aGlzLl93b3JsZEludmVyc2U9bmV3IGEuTWF0cml4fXJldHVybiBfX2V4dGVuZHMoYyxiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJzdWJkaXZpc2lvbnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1YmRpdmlzaW9uc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxjLnByb3RvdHlwZS5vcHRpbWl6ZT1mdW5jdGlvbigpe3RoaXMuc3ViZGl2aWRlKHRoaXMuX3N1YmRpdmlzaW9ucyksdGhpcy5jcmVhdGVPclVwZGF0ZVN1Ym1lc2hlc09jdHJlZSgzMil9LGMucHJvdG90eXBlLmdldEhlaWdodEF0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYS5SYXkobmV3IGEuVmVjdG9yMyhiLHRoaXMuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gubWF4aW11bVdvcmxkLnkrMSxjKSxuZXcgYS5WZWN0b3IzKDAsLTEsMCkpO3RoaXMuZ2V0V29ybGRNYXRyaXgoKS5pbnZlcnRUb1JlZih0aGlzLl93b3JsZEludmVyc2UpLGQ9YS5SYXkuVHJhbnNmb3JtKGQsdGhpcy5fd29ybGRJbnZlcnNlKTt2YXIgZT10aGlzLmludGVyc2VjdHMoZCk7cmV0dXJuIGUuaGl0P2UucGlja2VkUG9pbnQueTowfSxjfShhLk1lc2gpO2EuR3JvdW5kTWVzaD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMpe2IuY2FsbCh0aGlzLGEsYy5nZXRTY2VuZSgpKSxjLmluc3RhbmNlcy5wdXNoKHRoaXMpLHRoaXMuX3NvdXJjZU1lc2g9Yyx0aGlzLnBvc2l0aW9uLmNvcHlGcm9tKGMucG9zaXRpb24pLHRoaXMucm90YXRpb24uY29weUZyb20oYy5yb3RhdGlvbiksdGhpcy5zY2FsaW5nLmNvcHlGcm9tKGMuc2NhbGluZyksYy5yb3RhdGlvblF1YXRlcm5pb24mJih0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj1jLnJvdGF0aW9uUXVhdGVybmlvbi5jbG9uZSgpKSx0aGlzLmluZmluaXRlRGlzdGFuY2U9Yy5pbmZpbml0ZURpc3RhbmNlLHRoaXMuc2V0UGl2b3RNYXRyaXgoYy5nZXRQaXZvdE1hdHJpeCgpKSx0aGlzLnJlZnJlc2hCb3VuZGluZ0luZm8oKSx0aGlzLl9zeW5jU3ViTWVzaGVzKCl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInJlY2VpdmVTaGFkb3dzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLnJlY2VpdmVTaGFkb3dzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcIm1hdGVyaWFsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLm1hdGVyaWFsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInZpc2liaWxpdHlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2gudmlzaWJpbGl0eX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJza2VsZXRvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5za2VsZXRvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxjLnByb3RvdHlwZS5nZXRUb3RhbFZlcnRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2guZ2V0VG90YWxWZXJ0aWNlcygpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJzb3VyY2VNZXNoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLmdldFZlcnRpY2VzRGF0YT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5nZXRWZXJ0aWNlc0RhdGEoYSl9LGMucHJvdG90eXBlLmlzVmVydGljZXNEYXRhUHJlc2VudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYSl9LGMucHJvdG90eXBlLmdldEluZGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5nZXRJbmRpY2VzKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcIl9wb3NpdGlvbnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2guX3Bvc2l0aW9uc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxjLnByb3RvdHlwZS5yZWZyZXNoQm91bmRpbmdJbmZvPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fc291cmNlTWVzaC5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtpZihiKXt2YXIgYz1hLlRvb2xzLkV4dHJhY3RNaW5BbmRNYXgoYiwwLHRoaXMuX3NvdXJjZU1lc2guZ2V0VG90YWxWZXJ0aWNlcygpKTt0aGlzLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGMubWluaW11bSxjLm1heGltdW0pfXRoaXMuX3VwZGF0ZUJvdW5kaW5nSW5mbygpfSxjLnByb3RvdHlwZS5fcHJlQWN0aXZhdGU9ZnVuY3Rpb24oKXt0aGlzLnNvdXJjZU1lc2guX3ByZUFjdGl2YXRlKCl9LGMucHJvdG90eXBlLl9hY3RpdmF0ZT1mdW5jdGlvbihhKXt0aGlzLnNvdXJjZU1lc2guX3JlZ2lzdGVySW5zdGFuY2VGb3JSZW5kZXJJZCh0aGlzLGEpfSxjLnByb3RvdHlwZS5fc3luY1N1Yk1lc2hlcz1mdW5jdGlvbigpe3RoaXMucmVsZWFzZVN1Yk1lc2hlcygpO2Zvcih2YXIgYT0wO2E8dGhpcy5fc291cmNlTWVzaC5zdWJNZXNoZXMubGVuZ3RoO2ErKyl0aGlzLl9zb3VyY2VNZXNoLnN1Yk1lc2hlc1thXS5jbG9uZSh0aGlzLHRoaXMuX3NvdXJjZU1lc2gpfSxjLnByb3RvdHlwZS5fZ2VuZXJhdGVQb2ludHNBcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLl9nZW5lcmF0ZVBvaW50c0FycmF5KCl9LGMucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzLl9zb3VyY2VNZXNoLmNyZWF0ZUluc3RhbmNlKGIpO2lmKGEuVG9vbHMuRGVlcENvcHkodGhpcyxlLFtcIm5hbWVcIl0sW10pLHRoaXMucmVmcmVzaEJvdW5kaW5nSW5mbygpLGMmJihlLnBhcmVudD1jKSwhZClmb3IodmFyIGY9MDtmPHRoaXMuZ2V0U2NlbmUoKS5tZXNoZXMubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5nZXRTY2VuZSgpLm1lc2hlc1tmXTtnLnBhcmVudD09dGhpcyYmZy5jbG9uZShnLm5hbWUsZSl9cmV0dXJuIGUuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxlfSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuX3NvdXJjZU1lc2guaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7dGhpcy5fc291cmNlTWVzaC5pbnN0YW5jZXMuc3BsaWNlKGMsMSksYi5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsYSl9LGN9KGEuQWJzdHJhY3RNZXNoKTthLkluc3RhbmNlZE1lc2g9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmLGcsaCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGgmJihoPSEwKSx0aGlzLm1hdGVyaWFsSW5kZXg9YSx0aGlzLnZlcnRpY2VzU3RhcnQ9Yix0aGlzLnZlcnRpY2VzQ291bnQ9Yyx0aGlzLmluZGV4U3RhcnQ9ZCx0aGlzLmluZGV4Q291bnQ9ZSx0aGlzLl9yZW5kZXJJZD0wLHRoaXMuX21lc2g9Zix0aGlzLl9yZW5kZXJpbmdNZXNoPWd8fGYsZi5zdWJNZXNoZXMucHVzaCh0aGlzKSx0aGlzLl9pZD1mLnN1Yk1lc2hlcy5sZW5ndGgtMSxoJiZ0aGlzLnJlZnJlc2hCb3VuZGluZ0luZm8oKX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0Qm91bmRpbmdJbmZvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mb30sYi5wcm90b3R5cGUuZ2V0TWVzaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9tZXNofSxiLnByb3RvdHlwZS5nZXRSZW5kZXJpbmdNZXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlcmluZ01lc2h9LGIucHJvdG90eXBlLmdldE1hdGVyaWFsPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fcmVuZGVyaW5nTWVzaC5tYXRlcmlhbDtpZihiJiZiIGluc3RhbmNlb2YgYS5NdWx0aU1hdGVyaWFsKXt2YXIgYz1iO3JldHVybiBjLmdldFN1Yk1hdGVyaWFsKHRoaXMubWF0ZXJpYWxJbmRleCl9cmV0dXJuIGI/Yjp0aGlzLl9tZXNoLmdldFNjZW5lKCkuZGVmYXVsdE1hdGVyaWFsfSxiLnByb3RvdHlwZS5yZWZyZXNoQm91bmRpbmdJbmZvPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fcmVuZGVyaW5nTWVzaC5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtpZighYilyZXR1cm4gdm9pZCh0aGlzLl9ib3VuZGluZ0luZm89dGhpcy5fbWVzaC5fYm91bmRpbmdJbmZvKTt2YXIgYyxkPXRoaXMuX3JlbmRlcmluZ01lc2guZ2V0SW5kaWNlcygpO2M9MD09PXRoaXMuaW5kZXhTdGFydCYmdGhpcy5pbmRleENvdW50PT09ZC5sZW5ndGg/YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KGIsdGhpcy52ZXJ0aWNlc1N0YXJ0LHRoaXMudmVydGljZXNDb3VudCk6YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4SW5kZXhlZChiLGQsdGhpcy5pbmRleFN0YXJ0LHRoaXMuaW5kZXhDb3VudCksdGhpcy5fYm91bmRpbmdJbmZvPW5ldyBhLkJvdW5kaW5nSW5mbyhjLm1pbmltdW0sYy5tYXhpbXVtKX0sYi5wcm90b3R5cGUuX2NoZWNrQ29sbGlzaW9uPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9ib3VuZGluZ0luZm8uX2NoZWNrQ29sbGlzaW9uKGEpfSxiLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ0luZm89ZnVuY3Rpb24oYSl7dGhpcy5fYm91bmRpbmdJbmZvfHx0aGlzLnJlZnJlc2hCb3VuZGluZ0luZm8oKSx0aGlzLl9ib3VuZGluZ0luZm8uX3VwZGF0ZShhKX0sYi5wcm90b3R5cGUuaXNJbkZydXN0dW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mby5pc0luRnJ1c3R1bShhKX0sYi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyaW5nTWVzaC5yZW5kZXIodGhpcyl9LGIucHJvdG90eXBlLmdldExpbmVzSW5kZXhCdWZmZXI9ZnVuY3Rpb24oYSxiKXtpZighdGhpcy5fbGluZXNJbmRleEJ1ZmZlcil7Zm9yKHZhciBjPVtdLGQ9dGhpcy5pbmRleFN0YXJ0O2Q8dGhpcy5pbmRleFN0YXJ0K3RoaXMuaW5kZXhDb3VudDtkKz0zKWMucHVzaChhW2RdLGFbZCsxXSxhW2QrMV0sYVtkKzJdLGFbZCsyXSxhW2RdKTt0aGlzLl9saW5lc0luZGV4QnVmZmVyPWIuY3JlYXRlSW5kZXhCdWZmZXIoYyksdGhpcy5saW5lc0luZGV4Q291bnQ9Yy5sZW5ndGh9cmV0dXJuIHRoaXMuX2xpbmVzSW5kZXhCdWZmZXJ9LGIucHJvdG90eXBlLmNhbkludGVyc2VjdHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW50ZXJzZWN0c0JveCh0aGlzLl9ib3VuZGluZ0luZm8uYm91bmRpbmdCb3gpfSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZT1udWxsLGY9dGhpcy5pbmRleFN0YXJ0O2Y8dGhpcy5pbmRleFN0YXJ0K3RoaXMuaW5kZXhDb3VudDtmKz0zKXt2YXIgZz1iW2NbZl1dLGg9YltjW2YrMV1dLGk9YltjW2YrMl1dLGo9YS5pbnRlcnNlY3RzVHJpYW5nbGUoZyxoLGkpO2lmKGomJihkfHwhZXx8ai5kaXN0YW5jZTxlLmRpc3RhbmNlKSYmKGU9aixlLmZhY2VJZD1mLzMsZCkpYnJlYWt9cmV0dXJuIGV9LGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGMsZCl7dmFyIGU9bmV3IGIodGhpcy5tYXRlcmlhbEluZGV4LHRoaXMudmVydGljZXNTdGFydCx0aGlzLnZlcnRpY2VzQ291bnQsdGhpcy5pbmRleFN0YXJ0LHRoaXMuaW5kZXhDb3VudCxjLGQsITEpO3JldHVybiBlLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKHRoaXMuX2JvdW5kaW5nSW5mby5taW5pbXVtLHRoaXMuX2JvdW5kaW5nSW5mby5tYXhpbXVtKSxlfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fbGluZXNJbmRleEJ1ZmZlciYmKHRoaXMuX21lc2guZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9saW5lc0luZGV4QnVmZmVyKSx0aGlzLl9saW5lc0luZGV4QnVmZmVyPW51bGwpO3ZhciBhPXRoaXMuX21lc2guc3ViTWVzaGVzLmluZGV4T2YodGhpcyk7dGhpcy5fbWVzaC5zdWJNZXNoZXMuc3BsaWNlKGEsMSl9LGIuQ3JlYXRlRnJvbUluZGljZXM9ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1OdW1iZXIuTUFYX1ZBTFVFLGg9LU51bWJlci5NQVhfVkFMVUU7Zj1mfHxlO2Zvcih2YXIgaT1mLmdldEluZGljZXMoKSxqPWM7YytkPmo7aisrKXt2YXIgaz1pW2pdO2c+ayYmKGc9ayksaz5oJiYoaD1rKX1yZXR1cm4gbmV3IGEuU3ViTWVzaChiLGcsaC1nKzEsYyxkLGUsZil9LGJ9KCk7YS5TdWJNZXNoPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiKXt0aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PTkUsdGhpcy5oYXNBbHBoYT0hMSx0aGlzLmdldEFscGhhRnJvbVJHQj0hMSx0aGlzLmxldmVsPTEsdGhpcy5pc0N1YmU9ITEsdGhpcy5pc1JlbmRlclRhcmdldD0hMSx0aGlzLmFuaW1hdGlvbnM9bmV3IEFycmF5LHRoaXMuY29vcmRpbmF0ZXNJbmRleD0wLHRoaXMuY29vcmRpbmF0ZXNNb2RlPWEuVGV4dHVyZS5FWFBMSUNJVF9NT0RFLHRoaXMud3JhcFU9YS5UZXh0dXJlLldSQVBfQUREUkVTU01PREUsdGhpcy53cmFwVj1hLlRleHR1cmUuV1JBUF9BRERSRVNTTU9ERSx0aGlzLmFuaXNvdHJvcGljRmlsdGVyaW5nTGV2ZWw9NCx0aGlzLl9zY2VuZT1iLHRoaXMuX3NjZW5lLnRleHR1cmVzLnB1c2godGhpcyl9cmV0dXJuIGIucHJvdG90eXBlLmdldFNjZW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjZW5lfSxiLnByb3RvdHlwZS5nZXRUZXh0dXJlTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldEludGVybmFsVGV4dHVyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlfSxiLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsYXlMb2FkU3RhdGU9PT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQ/ITA6dGhpcy5fdGV4dHVyZT90aGlzLl90ZXh0dXJlLmlzUmVhZHk6ITF9LGIucHJvdG90eXBlLmdldFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGV4dHVyZS5fd2lkdGg/e3dpZHRoOnRoaXMuX3RleHR1cmUuX3dpZHRoLGhlaWdodDp0aGlzLl90ZXh0dXJlLl9oZWlnaHR9OnRoaXMuX3RleHR1cmUuX3NpemU/e3dpZHRoOnRoaXMuX3RleHR1cmUuX3NpemUsaGVpZ2h0OnRoaXMuX3RleHR1cmUuX3NpemV9Ont3aWR0aDowLGhlaWdodDowfX0sYi5wcm90b3R5cGUuZ2V0QmFzZVNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5fdGV4dHVyZS5fc2l6ZT97d2lkdGg6dGhpcy5fdGV4dHVyZS5fc2l6ZSxoZWlnaHQ6dGhpcy5fdGV4dHVyZS5fc2l6ZX06e3dpZHRoOnRoaXMuX3RleHR1cmUuX2Jhc2VXaWR0aCxoZWlnaHQ6dGhpcy5fdGV4dHVyZS5fYmFzZUhlaWdodH06e3dpZHRoOjAsaGVpZ2h0OjB9fSxiLnByb3RvdHlwZS5fZ2V0RnJvbUNhY2hlPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmdldExvYWRlZFRleHR1cmVzQ2FjaGUoKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoZS51cmw9PT1hJiZlLm5vTWlwbWFwPT09YilyZXR1cm4gZS5yZWZlcmVuY2VzKyssZX1yZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZGVsYXlMb2FkPWZ1bmN0aW9uKCl7fSxiLnByb3RvdHlwZS5yZWxlYXNlSW50ZXJuYWxUZXh0dXJlPWZ1bmN0aW9uKCl7aWYodGhpcy5fdGV4dHVyZSl7dmFyIGE9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuZ2V0TG9hZGVkVGV4dHVyZXNDYWNoZSgpO2lmKHRoaXMuX3RleHR1cmUucmVmZXJlbmNlcy0tLDA9PXRoaXMuX3RleHR1cmUucmVmZXJlbmNlcyl7dmFyIGI9YS5pbmRleE9mKHRoaXMuX3RleHR1cmUpO2Euc3BsaWNlKGIsMSksdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VUZXh0dXJlKHRoaXMuX3RleHR1cmUpLGRlbGV0ZSB0aGlzLl90ZXh0dXJlfX19LGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9zY2VuZS50ZXh0dXJlcy5pbmRleE9mKHRoaXMpO2E+PTAmJnRoaXMuX3NjZW5lLnRleHR1cmVzLnNwbGljZShhLDEpLHZvaWQgMCE9PXRoaXMuX3RleHR1cmUmJih0aGlzLnJlbGVhc2VJbnRlcm5hbFRleHR1cmUoKSx0aGlzLm9uRGlzcG9zZSYmdGhpcy5vbkRpc3Bvc2UoKSl9LGJ9KCk7YS5CYXNlVGV4dHVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLmluZGV4PWIsdGhpcy5fb3BhcXVlU3ViTWVzaGVzPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcz1uZXcgYS5TbWFydEFycmF5KDI1NiksdGhpcy5fYWxwaGFUZXN0U3ViTWVzaGVzPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl9zY2VuZT1jfXJldHVybiBiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYixjKXtpZihiKXJldHVybiBiKHRoaXMuX29wYXF1ZVN1Yk1lc2hlcyx0aGlzLl9hbHBoYVRlc3RTdWJNZXNoZXMsdGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMsYyksITA7aWYoMD09PXRoaXMuX29wYXF1ZVN1Yk1lc2hlcy5sZW5ndGgmJjA9PT10aGlzLl9hbHBoYVRlc3RTdWJNZXNoZXMubGVuZ3RoJiYwPT09dGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMubGVuZ3RoKXJldHVybiExO3ZhciBkLGUsZj10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtmb3IoZD0wO2Q8dGhpcy5fb3BhcXVlU3ViTWVzaGVzLmxlbmd0aDtkKyspZT10aGlzLl9vcGFxdWVTdWJNZXNoZXMuZGF0YVtkXSx0aGlzLl9hY3RpdmVWZXJ0aWNlcys9ZS52ZXJ0aWNlc0NvdW50LGUucmVuZGVyKCk7Zm9yKGYuc2V0QWxwaGFUZXN0aW5nKCEwKSxkPTA7ZDx0aGlzLl9hbHBoYVRlc3RTdWJNZXNoZXMubGVuZ3RoO2QrKyllPXRoaXMuX2FscGhhVGVzdFN1Yk1lc2hlcy5kYXRhW2RdLHRoaXMuX2FjdGl2ZVZlcnRpY2VzKz1lLnZlcnRpY2VzQ291bnQsZS5yZW5kZXIoKTtpZihmLnNldEFscGhhVGVzdGluZyghMSksYyYmYygpLHRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLmxlbmd0aCl7Zm9yKGQ9MDtkPHRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLmxlbmd0aDtkKyspZT10aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcy5kYXRhW2RdLGUuX2Rpc3RhbmNlVG9DYW1lcmE9ZS5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ1NwaGVyZS5jZW50ZXJXb3JsZC5zdWJ0cmFjdCh0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEucG9zaXRpb24pLmxlbmd0aCgpO3ZhciBnPXRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLmRhdGEuc2xpY2UoMCx0aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcy5sZW5ndGgpO2ZvcihnLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5fZGlzdGFuY2VUb0NhbWVyYTxiLl9kaXN0YW5jZVRvQ2FtZXJhPzE6YS5fZGlzdGFuY2VUb0NhbWVyYT5iLl9kaXN0YW5jZVRvQ2FtZXJhPy0xOjB9KSxmLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9DT01CSU5FKSxkPTA7ZDxnLmxlbmd0aDtkKyspZT1nW2RdLHRoaXMuX2FjdGl2ZVZlcnRpY2VzKz1lLnZlcnRpY2VzQ291bnQsZS5yZW5kZXIoKTtmLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9ESVNBQkxFKX1yZXR1cm4hMH0sYi5wcm90b3R5cGUucHJlcGFyZT1mdW5jdGlvbigpe3RoaXMuX29wYXF1ZVN1Yk1lc2hlcy5yZXNldCgpLHRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLnJlc2V0KCksdGhpcy5fYWxwaGFUZXN0U3ViTWVzaGVzLnJlc2V0KCl9LGIucHJvdG90eXBlLmRpc3BhdGNoPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0TWF0ZXJpYWwoKSxjPWEuZ2V0TWVzaCgpO2IubmVlZEFscGhhQmxlbmRpbmcoKXx8Yy52aXNpYmlsaXR5PDE/KGIuYWxwaGE+MHx8Yy52aXNpYmlsaXR5PDEpJiZ0aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcy5wdXNoKGEpOmIubmVlZEFscGhhVGVzdGluZygpP3RoaXMuX2FscGhhVGVzdFN1Yk1lc2hlcy5wdXNoKGEpOnRoaXMuX29wYXF1ZVN1Yk1lc2hlcy5wdXNoKGEpfSxifSgpO2EuUmVuZGVyaW5nR3JvdXA9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3RoaXMuX3JlbmRlcmluZ0dyb3Vwcz1uZXcgQXJyYXksdGhpcy5fc2NlbmU9YX1yZXR1cm4gYi5wcm90b3R5cGUuX3JlbmRlclBhcnRpY2xlcz1mdW5jdGlvbihhLGIpe2lmKDAhPT10aGlzLl9zY2VuZS5fYWN0aXZlUGFydGljbGVTeXN0ZW1zLmxlbmd0aCl7Zm9yKHZhciBjPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGQ9MDtkPHRoaXMuX3NjZW5lLl9hY3RpdmVQYXJ0aWNsZVN5c3RlbXMubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5fc2NlbmUuX2FjdGl2ZVBhcnRpY2xlU3lzdGVtcy5kYXRhW2RdO2UucmVuZGVyaW5nR3JvdXBJZD09PWEmJih0aGlzLl9jbGVhckRlcHRoQnVmZmVyKCksZS5lbWl0dGVyLnBvc2l0aW9uJiZiJiYtMT09PWIuaW5kZXhPZihlLmVtaXR0ZXIpfHwodGhpcy5fc2NlbmUuX2FjdGl2ZVBhcnRpY2xlcys9ZS5yZW5kZXIoKSkpfXRoaXMuX3NjZW5lLl9wYXJ0aWNsZXNEdXJhdGlvbis9KG5ldyBEYXRlKS5nZXRUaW1lKCktY319LGIucHJvdG90eXBlLl9yZW5kZXJTcHJpdGVzPWZ1bmN0aW9uKGEpe2lmKDAhPT10aGlzLl9zY2VuZS5zcHJpdGVNYW5hZ2Vycy5sZW5ndGgpe2Zvcih2YXIgYj0obmV3IERhdGUpLmdldFRpbWUoKSxjPTA7Yzx0aGlzLl9zY2VuZS5zcHJpdGVNYW5hZ2Vycy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLl9zY2VuZS5zcHJpdGVNYW5hZ2Vyc1tjXTtkLnJlbmRlcmluZ0dyb3VwSWQ9PT1hJiYodGhpcy5fY2xlYXJEZXB0aEJ1ZmZlcigpLGQucmVuZGVyKCkpfXRoaXMuX3NjZW5lLl9zcHJpdGVzRHVyYXRpb24rPShuZXcgRGF0ZSkuZ2V0VGltZSgpLWJ9fSxiLnByb3RvdHlwZS5fY2xlYXJEZXB0aEJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuX2RlcHRoQnVmZmVyQWxyZWFkeUNsZWFuZWR8fCh0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5jbGVhcigwLCExLCEwKSx0aGlzLl9kZXB0aEJ1ZmZlckFscmVhZHlDbGVhbmVkPSEwKX0sYi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGIsYyxkLGUpe2Zvcih2YXIgZj10aGlzLGc9MDtnPGEuUmVuZGVyaW5nTWFuYWdlci5NQVhfUkVOREVSSU5HR1JPVVBTO2crKyl7dGhpcy5fZGVwdGhCdWZmZXJBbHJlYWR5Q2xlYW5lZD0hMTt2YXIgaD10aGlzLl9yZW5kZXJpbmdHcm91cHNbZ107aD8odGhpcy5fY2xlYXJEZXB0aEJ1ZmZlcigpLGgucmVuZGVyKGIsZnVuY3Rpb24oKXtlJiZmLl9yZW5kZXJTcHJpdGVzKGcpfSl8fHRoaXMuX3JlbmRlcmluZ0dyb3Vwcy5zcGxpY2UoZywxKSk6ZSYmdGhpcy5fcmVuZGVyU3ByaXRlcyhnKSxkJiZ0aGlzLl9yZW5kZXJQYXJ0aWNsZXMoZyxjKX19LGIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuX3JlbmRlcmluZ0dyb3Vwcyl7dmFyIGI9dGhpcy5fcmVuZGVyaW5nR3JvdXBzW2FdO2IucHJlcGFyZSgpfX0sYi5wcm90b3R5cGUuZGlzcGF0Y2g9ZnVuY3Rpb24oYil7dmFyIGM9Yi5nZXRNZXNoKCksZD1jLnJlbmRlcmluZ0dyb3VwSWR8fDA7dGhpcy5fcmVuZGVyaW5nR3JvdXBzW2RdfHwodGhpcy5fcmVuZGVyaW5nR3JvdXBzW2RdPW5ldyBhLlJlbmRlcmluZ0dyb3VwKGQsdGhpcy5fc2NlbmUpKSx0aGlzLl9yZW5kZXJpbmdHcm91cHNbZF0uZGlzcGF0Y2goYil9LGIuTUFYX1JFTkRFUklOR0dST1VQUz00LGJ9KCk7YS5SZW5kZXJpbmdNYW5hZ2VyPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGQsZSxmLGcsaCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGgmJihoPWMuVFJJTElORUFSX1NBTVBMSU5HTU9ERSksYi5jYWxsKHRoaXMsZSksdGhpcy51T2Zmc2V0PTAsdGhpcy52T2Zmc2V0PTAsdGhpcy51U2NhbGU9MSx0aGlzLnZTY2FsZT0xLHRoaXMudUFuZz0wLHRoaXMudkFuZz0wLHRoaXMud0FuZz0wLHRoaXMubmFtZT1kLHRoaXMudXJsPWQsdGhpcy5fbm9NaXBtYXA9Zix0aGlzLl9pbnZlcnRZPWcsdGhpcy5fc2FtcGxpbmdNb2RlPWgsZCYmKHRoaXMuX3RleHR1cmU9dGhpcy5fZ2V0RnJvbUNhY2hlKGQsZiksdGhpcy5fdGV4dHVyZXx8KGUudXNlRGVsYXllZFRleHR1cmVMb2FkaW5nP3RoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEOnRoaXMuX3RleHR1cmU9ZS5nZXRFbmdpbmUoKS5jcmVhdGVUZXh0dXJlKGQsZixnLGUsdGhpcy5fc2FtcGxpbmdNb2RlKSkpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5kZWxheUxvYWQ9ZnVuY3Rpb24oKXt0aGlzLmRlbGF5TG9hZFN0YXRlPT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQmJih0aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURFRCx0aGlzLl90ZXh0dXJlPXRoaXMuX2dldEZyb21DYWNoZSh0aGlzLnVybCx0aGlzLl9ub01pcG1hcCksdGhpcy5fdGV4dHVyZXx8KHRoaXMuX3RleHR1cmU9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLmNyZWF0ZVRleHR1cmUodGhpcy51cmwsdGhpcy5fbm9NaXBtYXAsdGhpcy5faW52ZXJ0WSx0aGlzLmdldFNjZW5lKCksdGhpcy5fc2FtcGxpbmdNb2RlKSkpfSxjLnByb3RvdHlwZS5fcHJlcGFyZVJvd0ZvclRleHR1cmVHZW5lcmF0aW9uPWZ1bmN0aW9uKGIsYyxkLGUpe2ItPXRoaXMudU9mZnNldCsuNSxjLT10aGlzLnZPZmZzZXQrLjUsZC09LjUsYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzRnJvbUZsb2F0c1RvUmVmKGIsYyxkLHRoaXMuX3Jvd0dlbmVyYXRpb25NYXRyaXgsZSksZS54Kj10aGlzLnVTY2FsZSxlLnkqPXRoaXMudlNjYWxlLGUueCs9LjUsZS55Kz0uNSxlLnorPS41fSxjLnByb3RvdHlwZS5nZXRUZXh0dXJlTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudU9mZnNldD09PXRoaXMuX2NhY2hlZFVPZmZzZXQmJnRoaXMudk9mZnNldD09PXRoaXMuX2NhY2hlZFZPZmZzZXQmJnRoaXMudVNjYWxlPT09dGhpcy5fY2FjaGVkVVNjYWxlJiZ0aGlzLnZTY2FsZT09PXRoaXMuX2NhY2hlZFZTY2FsZSYmdGhpcy51QW5nPT09dGhpcy5fY2FjaGVkVUFuZyYmdGhpcy52QW5nPT09dGhpcy5fY2FjaGVkVkFuZyYmdGhpcy53QW5nPT09dGhpcy5fY2FjaGVkV0FuZz90aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Oih0aGlzLl9jYWNoZWRVT2Zmc2V0PXRoaXMudU9mZnNldCx0aGlzLl9jYWNoZWRWT2Zmc2V0PXRoaXMudk9mZnNldCx0aGlzLl9jYWNoZWRVU2NhbGU9dGhpcy51U2NhbGUsdGhpcy5fY2FjaGVkVlNjYWxlPXRoaXMudlNjYWxlLHRoaXMuX2NhY2hlZFVBbmc9dGhpcy51QW5nLHRoaXMuX2NhY2hlZFZBbmc9dGhpcy52QW5nLHRoaXMuX2NhY2hlZFdBbmc9dGhpcy53QW5nLHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXh8fCh0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9yb3dHZW5lcmF0aW9uTWF0cml4PW5ldyBhLk1hdHJpeCx0aGlzLl90MD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3QxPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdDI9YS5WZWN0b3IzLlplcm8oKSksYS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnZBbmcsdGhpcy51QW5nLHRoaXMud0FuZyx0aGlzLl9yb3dHZW5lcmF0aW9uTWF0cml4KSx0aGlzLl9wcmVwYXJlUm93Rm9yVGV4dHVyZUdlbmVyYXRpb24oMCwwLDAsdGhpcy5fdDApLHRoaXMuX3ByZXBhcmVSb3dGb3JUZXh0dXJlR2VuZXJhdGlvbigxLDAsMCx0aGlzLl90MSksdGhpcy5fcHJlcGFyZVJvd0ZvclRleHR1cmVHZW5lcmF0aW9uKDAsMSwwLHRoaXMuX3QyKSx0aGlzLl90MS5zdWJ0cmFjdEluUGxhY2UodGhpcy5fdDApLHRoaXMuX3QyLnN1YnRyYWN0SW5QbGFjZSh0aGlzLl90MCksYS5NYXRyaXguSWRlbnRpdHlUb1JlZih0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bMF09dGhpcy5fdDEueCx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bMV09dGhpcy5fdDEueSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bMl09dGhpcy5fdDEueix0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bNF09dGhpcy5fdDIueCx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bNV09dGhpcy5fdDIueSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bNl09dGhpcy5fdDIueix0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bOF09dGhpcy5fdDAueCx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bOV09dGhpcy5fdDAueSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4Lm1bMTBdPXRoaXMuX3QwLnosdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCl9LGMucHJvdG90eXBlLmdldFJlZmxlY3Rpb25UZXh0dXJlTWF0cml4PWZ1bmN0aW9uKCl7aWYodGhpcy51T2Zmc2V0PT09dGhpcy5fY2FjaGVkVU9mZnNldCYmdGhpcy52T2Zmc2V0PT09dGhpcy5fY2FjaGVkVk9mZnNldCYmdGhpcy51U2NhbGU9PT10aGlzLl9jYWNoZWRVU2NhbGUmJnRoaXMudlNjYWxlPT09dGhpcy5fY2FjaGVkVlNjYWxlJiZ0aGlzLmNvb3JkaW5hdGVzTW9kZT09PXRoaXMuX2NhY2hlZENvb3JkaW5hdGVzTW9kZSlyZXR1cm4gdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeDtzd2l0Y2godGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeHx8KHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4PWEuTWF0cml4Llplcm8oKSksdGhpcy5jb29yZGluYXRlc01vZGUpe2Nhc2UgYS5UZXh0dXJlLlNQSEVSSUNBTF9NT0RFOmEuTWF0cml4LklkZW50aXR5VG9SZWYodGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCksdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFswXT0tLjUqdGhpcy51U2NhbGUsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFs1XT0tLjUqdGhpcy52U2NhbGUsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFsxMl09LjUrdGhpcy51T2Zmc2V0LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXhbMTNdPS41K3RoaXMudk9mZnNldDticmVhaztjYXNlIGEuVGV4dHVyZS5QTEFOQVJfTU9ERTphLk1hdHJpeC5JZGVudGl0eVRvUmVmKHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpLHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXhbMF09dGhpcy51U2NhbGUsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFs1XT10aGlzLnZTY2FsZSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzEyXT10aGlzLnVPZmZzZXQsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFsxM109dGhpcy52T2Zmc2V0O2JyZWFrO2Nhc2UgYS5UZXh0dXJlLlBST0pFQ1RJT05fTU9ERTphLk1hdHJpeC5JZGVudGl0eVRvUmVmKHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4KSx0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeC5tWzBdPS41LHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4Lm1bNV09LS41LHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4Lm1bMTBdPTAsdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgubVsxMl09LjUsdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgubVsxM109LjUsdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgubVsxNF09MSx0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeC5tWzE1XT0xLHRoaXMuZ2V0U2NlbmUoKS5nZXRQcm9qZWN0aW9uTWF0cml4KCkubXVsdGlwbHlUb1JlZih0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeCx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KTtcbmJyZWFrO2RlZmF1bHQ6YS5NYXRyaXguSWRlbnRpdHlUb1JlZih0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KX1yZXR1cm4gdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeH0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj1uZXcgYS5UZXh0dXJlKHRoaXMuX3RleHR1cmUudXJsLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9ub01pcG1hcCx0aGlzLl9pbnZlcnRZKTtyZXR1cm4gYi5oYXNBbHBoYT10aGlzLmhhc0FscGhhLGIubGV2ZWw9dGhpcy5sZXZlbCxiLndyYXBVPXRoaXMud3JhcFUsYi53cmFwVj10aGlzLndyYXBWLGIuY29vcmRpbmF0ZXNJbmRleD10aGlzLmNvb3JkaW5hdGVzSW5kZXgsYi5jb29yZGluYXRlc01vZGU9dGhpcy5jb29yZGluYXRlc01vZGUsYi51T2Zmc2V0PXRoaXMudU9mZnNldCxiLnZPZmZzZXQ9dGhpcy52T2Zmc2V0LGIudVNjYWxlPXRoaXMudVNjYWxlLGIudlNjYWxlPXRoaXMudlNjYWxlLGIudUFuZz10aGlzLnVBbmcsYi52QW5nPXRoaXMudkFuZyxiLndBbmc9dGhpcy53QW5nLGJ9LGMuTkVBUkVTVF9TQU1QTElOR01PREU9MSxjLkJJTElORUFSX1NBTVBMSU5HTU9ERT0yLGMuVFJJTElORUFSX1NBTVBMSU5HTU9ERT0zLGMuRVhQTElDSVRfTU9ERT0wLGMuU1BIRVJJQ0FMX01PREU9MSxjLlBMQU5BUl9NT0RFPTIsYy5DVUJJQ19NT0RFPTMsYy5QUk9KRUNUSU9OX01PREU9NCxjLlNLWUJPWF9NT0RFPTUsYy5DTEFNUF9BRERSRVNTTU9ERT0wLGMuV1JBUF9BRERSRVNTTU9ERT0xLGMuTUlSUk9SX0FERFJFU1NNT0RFPTIsY30oYS5CYXNlVGV4dHVyZSk7YS5UZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYpe2IuY2FsbCh0aGlzLGQpLHRoaXMuY29vcmRpbmF0ZXNNb2RlPWEuVGV4dHVyZS5DVUJJQ19NT0RFLHRoaXMubmFtZT1jLHRoaXMudXJsPWMsdGhpcy5fbm9NaXBtYXA9Zix0aGlzLmhhc0FscGhhPSExLHRoaXMuX3RleHR1cmU9dGhpcy5fZ2V0RnJvbUNhY2hlKGMsZiksZXx8KGU9W1wiX3B4LmpwZ1wiLFwiX3B5LmpwZ1wiLFwiX3B6LmpwZ1wiLFwiX254LmpwZ1wiLFwiX255LmpwZ1wiLFwiX256LmpwZ1wiXSksdGhpcy5fZXh0ZW5zaW9ucz1lLHRoaXMuX3RleHR1cmV8fChkLnVzZURlbGF5ZWRUZXh0dXJlTG9hZGluZz90aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PVExPQURFRDp0aGlzLl90ZXh0dXJlPWQuZ2V0RW5naW5lKCkuY3JlYXRlQ3ViZVRleHR1cmUoYyxkLGUsZikpLHRoaXMuaXNDdWJlPSEwLHRoaXMuX3RleHR1cmVNYXRyaXg9YS5NYXRyaXguSWRlbnRpdHkoKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj1uZXcgYS5DdWJlVGV4dHVyZSh0aGlzLnVybCx0aGlzLmdldFNjZW5lKCksdGhpcy5fZXh0ZW5zaW9ucyx0aGlzLl9ub01pcG1hcCk7cmV0dXJuIGIubGV2ZWw9dGhpcy5sZXZlbCxiLndyYXBVPXRoaXMud3JhcFUsYi53cmFwVj10aGlzLndyYXBWLGIuY29vcmRpbmF0ZXNJbmRleD10aGlzLmNvb3JkaW5hdGVzSW5kZXgsYi5jb29yZGluYXRlc01vZGU9dGhpcy5jb29yZGluYXRlc01vZGUsYn0sYy5wcm90b3R5cGUuZGVsYXlMb2FkPWZ1bmN0aW9uKCl7dGhpcy5kZWxheUxvYWRTdGF0ZT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEJiYodGhpcy5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FERUQsdGhpcy5fdGV4dHVyZT10aGlzLl9nZXRGcm9tQ2FjaGUodGhpcy51cmwsdGhpcy5fbm9NaXBtYXApLHRoaXMuX3RleHR1cmV8fCh0aGlzLl90ZXh0dXJlPXRoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKS5jcmVhdGVDdWJlVGV4dHVyZSh0aGlzLnVybCx0aGlzLmdldFNjZW5lKCksdGhpcy5fZXh0ZW5zaW9ucykpKX0sYy5wcm90b3R5cGUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGV4dHVyZU1hdHJpeH0sY30oYS5CYXNlVGV4dHVyZSk7YS5DdWJlVGV4dHVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmLGcpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBnJiYoZz0hMCksYi5jYWxsKHRoaXMsbnVsbCxlLCFmKSx0aGlzLnJlbmRlckxpc3Q9bmV3IEFycmF5LHRoaXMucmVuZGVyUGFydGljbGVzPSEwLHRoaXMucmVuZGVyU3ByaXRlcz0hMSx0aGlzLmNvb3JkaW5hdGVzTW9kZT1hLlRleHR1cmUuUFJPSkVDVElPTl9NT0RFLHRoaXMuX2N1cnJlbnRSZWZyZXNoSWQ9LTEsdGhpcy5fcmVmcmVzaFJhdGU9MSx0aGlzLm5hbWU9Yyx0aGlzLmlzUmVuZGVyVGFyZ2V0PSEwLHRoaXMuX3NpemU9ZCx0aGlzLl9nZW5lcmF0ZU1pcE1hcHM9Zix0aGlzLl9kb05vdENoYW5nZUFzcGVjdFJhdGlvPWcsdGhpcy5fdGV4dHVyZT1lLmdldEVuZ2luZSgpLmNyZWF0ZVJlbmRlclRhcmdldFRleHR1cmUoZCxmKSx0aGlzLl9yZW5kZXJpbmdNYW5hZ2VyPW5ldyBhLlJlbmRlcmluZ01hbmFnZXIoZSl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLnJlc2V0UmVmcmVzaENvdW50ZXI9ZnVuY3Rpb24oKXt0aGlzLl9jdXJyZW50UmVmcmVzaElkPS0xfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJyZWZyZXNoUmF0ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVmcmVzaFJhdGV9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9yZWZyZXNoUmF0ZT1hLHRoaXMucmVzZXRSZWZyZXNoQ291bnRlcigpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLl9zaG91bGRSZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4tMT09PXRoaXMuX2N1cnJlbnRSZWZyZXNoSWQ/KHRoaXMuX2N1cnJlbnRSZWZyZXNoSWQ9MSwhMCk6dGhpcy5yZWZyZXNoUmF0ZT09dGhpcy5fY3VycmVudFJlZnJlc2hJZD8odGhpcy5fY3VycmVudFJlZnJlc2hJZD0xLCEwKToodGhpcy5fY3VycmVudFJlZnJlc2hJZCsrLCExKX0sYy5wcm90b3R5cGUuZ2V0UmVuZGVyU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaXplfSxjLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oYSxiKXt0aGlzLnJlbGVhc2VJbnRlcm5hbFRleHR1cmUoKSx0aGlzLl90ZXh0dXJlPXRoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKGEsYil9LGMucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldFNjZW5lKCksYz1iLmdldEVuZ2luZSgpO2lmKHRoaXMuX3dhaXRpbmdSZW5kZXJMaXN0KXt0aGlzLnJlbmRlckxpc3Q9W107Zm9yKHZhciBkPTA7ZDx0aGlzLl93YWl0aW5nUmVuZGVyTGlzdC5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLl93YWl0aW5nUmVuZGVyTGlzdFtkXTt0aGlzLnJlbmRlckxpc3QucHVzaChiLmdldE1lc2hCeUlEKGUpKX1kZWxldGUgdGhpcy5fd2FpdGluZ1JlbmRlckxpc3R9aWYodGhpcy5yZW5kZXJMaXN0JiYwIT10aGlzLnJlbmRlckxpc3QubGVuZ3RoKXthJiZiLnBvc3RQcm9jZXNzTWFuYWdlci5fcHJlcGFyZUZyYW1lKHRoaXMuX3RleHR1cmUpfHxjLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl90ZXh0dXJlKSxjLmNsZWFyKGIuY2xlYXJDb2xvciwhMCwhMCksdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZXNldCgpO2Zvcih2YXIgZj0wO2Y8dGhpcy5yZW5kZXJMaXN0Lmxlbmd0aDtmKyspe3ZhciBnPXRoaXMucmVuZGVyTGlzdFtmXTtpZihnKXtpZighZy5pc1JlYWR5KCl8fGcubWF0ZXJpYWwmJiFnLm1hdGVyaWFsLmlzUmVhZHkoKSl7dGhpcy5yZXNldFJlZnJlc2hDb3VudGVyKCk7Y29udGludWV9aWYoZy5pc0VuYWJsZWQoKSYmZy5pc1Zpc2libGUmJmcuc3ViTWVzaGVzJiYwIT0oZy5sYXllck1hc2smYi5hY3RpdmVDYW1lcmEubGF5ZXJNYXNrKSl7Zy5fYWN0aXZhdGUoYi5nZXRSZW5kZXJJZCgpKTtmb3IodmFyIGg9MDtoPGcuc3ViTWVzaGVzLmxlbmd0aDtoKyspe3ZhciBpPWcuc3ViTWVzaGVzW2hdO2IuX2FjdGl2ZVZlcnRpY2VzKz1pLnZlcnRpY2VzQ291bnQsdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5kaXNwYXRjaChpKX19fX10aGlzLl9kb05vdENoYW5nZUFzcGVjdFJhdGlvfHxiLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCghMCksdGhpcy5vbkJlZm9yZVJlbmRlciYmdGhpcy5vbkJlZm9yZVJlbmRlcigpLHRoaXMuX3JlbmRlcmluZ01hbmFnZXIucmVuZGVyKHRoaXMuY3VzdG9tUmVuZGVyRnVuY3Rpb24sdGhpcy5yZW5kZXJMaXN0LHRoaXMucmVuZGVyUGFydGljbGVzLHRoaXMucmVuZGVyU3ByaXRlcyksYSYmYi5wb3N0UHJvY2Vzc01hbmFnZXIuX2ZpbmFsaXplRnJhbWUoITEsdGhpcy5fdGV4dHVyZSksdGhpcy5vbkFmdGVyUmVuZGVyJiZ0aGlzLm9uQWZ0ZXJSZW5kZXIoKSxjLnVuQmluZEZyYW1lYnVmZmVyKHRoaXMuX3RleHR1cmUpLHRoaXMuX2RvTm90Q2hhbmdlQXNwZWN0UmF0aW98fGIudXBkYXRlVHJhbnNmb3JtTWF0cml4KCEwKX19LGMucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5nZXRTaXplKCksYz1uZXcgYS5SZW5kZXJUYXJnZXRUZXh0dXJlKHRoaXMubmFtZSxiLndpZHRoLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9nZW5lcmF0ZU1pcE1hcHMpO3JldHVybiBjLmhhc0FscGhhPXRoaXMuaGFzQWxwaGEsYy5sZXZlbD10aGlzLmxldmVsLGMuY29vcmRpbmF0ZXNNb2RlPXRoaXMuY29vcmRpbmF0ZXNNb2RlLGMucmVuZGVyTGlzdD10aGlzLnJlbmRlckxpc3Quc2xpY2UoMCksY30sY30oYS5UZXh0dXJlKTthLlJlbmRlclRhcmdldFRleHR1cmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUsZil7dmFyIGc9dGhpcztiLmNhbGwodGhpcyxjLGQsZSxmLCEwKSx0aGlzLm1pcnJvclBsYW5lPW5ldyBhLlBsYW5lKDAsMSwwLDEpLHRoaXMuX3RyYW5zZm9ybU1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbWlycm9yTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLm9uQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKCl7YS5NYXRyaXguUmVmbGVjdGlvblRvUmVmKGcubWlycm9yUGxhbmUsZy5fbWlycm9yTWF0cml4KSxnLl9zYXZlZFZpZXdNYXRyaXg9ZS5nZXRWaWV3TWF0cml4KCksZy5fbWlycm9yTWF0cml4Lm11bHRpcGx5VG9SZWYoZy5fc2F2ZWRWaWV3TWF0cml4LGcuX3RyYW5zZm9ybU1hdHJpeCksZS5zZXRUcmFuc2Zvcm1NYXRyaXgoZy5fdHJhbnNmb3JtTWF0cml4LGUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKSxlLmNsaXBQbGFuZT1nLm1pcnJvclBsYW5lLGUuZ2V0RW5naW5lKCkuY3VsbEJhY2tGYWNlcz0hMX0sdGhpcy5vbkFmdGVyUmVuZGVyPWZ1bmN0aW9uKCl7ZS5zZXRUcmFuc2Zvcm1NYXRyaXgoZy5fc2F2ZWRWaWV3TWF0cml4LGUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKSxlLmdldEVuZ2luZSgpLmN1bGxCYWNrRmFjZXM9ITAsZGVsZXRlIGUuY2xpcFBsYW5lfX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmdldFNpemUoKSxjPW5ldyBhLk1pcnJvclRleHR1cmUodGhpcy5uYW1lLGIud2lkdGgsdGhpcy5nZXRTY2VuZSgpLHRoaXMuX2dlbmVyYXRlTWlwTWFwcyk7cmV0dXJuIGMuaGFzQWxwaGE9dGhpcy5oYXNBbHBoYSxjLmxldmVsPXRoaXMubGV2ZWwsYy5taXJyb3JQbGFuZT10aGlzLm1pcnJvclBsYW5lLmNsb25lKCksYy5yZW5kZXJMaXN0PXRoaXMucmVuZGVyTGlzdC5zbGljZSgwKSxjfSxjfShhLlJlbmRlclRhcmdldFRleHR1cmUpO2EuTWlycm9yVGV4dHVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmLGcpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBnJiYoZz1hLlRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSksYi5jYWxsKHRoaXMsbnVsbCxlLCFmKSx0aGlzLm5hbWU9Yyx0aGlzLndyYXBVPWEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERSx0aGlzLndyYXBWPWEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERSx0aGlzLl9nZW5lcmF0ZU1pcE1hcHM9ZixkLmdldENvbnRleHQ/KHRoaXMuX2NhbnZhcz1kLHRoaXMuX3RleHR1cmU9ZS5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVGV4dHVyZShkLndpZHRoLGQuaGVpZ2h0LGYsZykpOih0aGlzLl9jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx0aGlzLl90ZXh0dXJlPWQud2lkdGg/ZS5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVGV4dHVyZShkLndpZHRoLGQuaGVpZ2h0LGYsZyk6ZS5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVGV4dHVyZShkLGQsZixnKSk7dmFyIGg9dGhpcy5nZXRTaXplKCk7dGhpcy5fY2FudmFzLndpZHRoPWgud2lkdGgsdGhpcy5fY2FudmFzLmhlaWdodD1oLmhlaWdodCx0aGlzLl9jb250ZXh0PXRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIil9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLmdldENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGV4dH0sYy5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKS51cGRhdGVEeW5hbWljVGV4dHVyZSh0aGlzLl90ZXh0dXJlLHRoaXMuX2NhbnZhcyx2b2lkIDA9PT1hPyEwOmEpfSxjLnByb3RvdHlwZS5kcmF3VGV4dD1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt2YXIgaD10aGlzLmdldFNpemUoKTtpZihmJiYodGhpcy5fY29udGV4dC5maWxsU3R5bGU9Zix0aGlzLl9jb250ZXh0LmZpbGxSZWN0KDAsMCxoLndpZHRoLGguaGVpZ2h0KSksdGhpcy5fY29udGV4dC5mb250PWQsbnVsbD09PWIpe3ZhciBpPXRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoYSk7Yj0oaC53aWR0aC1pLndpZHRoKS8yfXRoaXMuX2NvbnRleHQuZmlsbFN0eWxlPWUsdGhpcy5fY29udGV4dC5maWxsVGV4dChhLGIsYyksdGhpcy51cGRhdGUoZyl9LGMucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5nZXRTaXplKCksYz1uZXcgYS5EeW5hbWljVGV4dHVyZSh0aGlzLm5hbWUsYi53aWR0aCx0aGlzLmdldFNjZW5lKCksdGhpcy5fZ2VuZXJhdGVNaXBNYXBzKTtyZXR1cm4gYy5oYXNBbHBoYT10aGlzLmhhc0FscGhhLGMubGV2ZWw9dGhpcy5sZXZlbCxjLndyYXBVPXRoaXMud3JhcFUsYy53cmFwVj10aGlzLndyYXBWLGN9LGN9KGEuVGV4dHVyZSk7YS5EeW5hbWljVGV4dHVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmLGcsaCxpKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgaSYmKGk9YS5UZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUpO3ZhciBqPXRoaXM7Yi5jYWxsKHRoaXMsbnVsbCxmLCFnLGgpLHRoaXMuX2F1dG9MYXVuY2g9ITAsdGhpcy5uYW1lPWMsdGhpcy53cmFwVT1hLlRleHR1cmUuV1JBUF9BRERSRVNTTU9ERSx0aGlzLndyYXBWPWEuVGV4dHVyZS5XUkFQX0FERFJFU1NNT0RFO3ZhciBrPWUud2lkdGh8fGUsbD1lLmhlaWdodHx8ZTt0aGlzLl90ZXh0dXJlPWYuZ2V0RW5naW5lKCkuY3JlYXRlRHluYW1pY1RleHR1cmUoayxsLGcsaSk7dmFyIG09dGhpcy5nZXRTaXplKCk7dGhpcy52aWRlbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiksdGhpcy52aWRlby53aWR0aD1tLndpZHRoLHRoaXMudmlkZW8uaGVpZ2h0PW0uaGVpZ2h0LHRoaXMudmlkZW8uYXV0b3BsYXk9ITEsdGhpcy52aWRlby5sb29wPSEwLHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsZnVuY3Rpb24oKXtqLl90ZXh0dXJlJiYoai5fdGV4dHVyZS5pc1JlYWR5PSEwKX0pLGQuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO2Iuc3JjPWEsai52aWRlby5hcHBlbmRDaGlsZChiKX0pLHRoaXMuX2xhc3RVcGRhdGU9KG5ldyBEYXRlKS5nZXRUaW1lKCl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX2F1dG9MYXVuY2gmJih0aGlzLl9hdXRvTGF1bmNoPSExLHRoaXMudmlkZW8ucGxheSgpKTt2YXIgYT0obmV3IERhdGUpLmdldFRpbWUoKTtyZXR1cm4gYS10aGlzLl9sYXN0VXBkYXRlPDE1PyExOih0aGlzLl9sYXN0VXBkYXRlPWEsdGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLnVwZGF0ZVZpZGVvVGV4dHVyZSh0aGlzLl90ZXh0dXJlLHRoaXMudmlkZW8sdGhpcy5faW52ZXJ0WSksITApfSxjfShhLlRleHR1cmUpO2EuVmlkZW9UZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyxkLGUsZixnLGgsaSl7dmFyIGo9dGhpczt0aGlzLl9pc1JlYWR5PSExLHRoaXMuX2NvbXBpbGF0aW9uRXJyb3I9XCJcIix0aGlzLl92YWx1ZUNhY2hlPVtdLHRoaXMuX2VuZ2luZT1lLHRoaXMubmFtZT1hLHRoaXMuZGVmaW5lcz1mLHRoaXMuX3VuaWZvcm1zTmFtZXM9Yy5jb25jYXQoZCksdGhpcy5fc2FtcGxlcnM9ZCx0aGlzLl9hdHRyaWJ1dGVzTmFtZXM9Yix0aGlzLm9uRXJyb3I9aSx0aGlzLm9uQ29tcGlsZWQ9aDt2YXIgayxsO2s9YS52ZXJ0ZXhFbGVtZW50P2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEudmVydGV4RWxlbWVudCk6YS52ZXJ0ZXh8fGEsbD1hLmZyYWdtZW50RWxlbWVudD9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhLmZyYWdtZW50RWxlbWVudCk6YS5mcmFnbWVudHx8YSx0aGlzLl9sb2FkVmVydGV4U2hhZGVyKGssZnVuY3Rpb24oYSl7ai5fbG9hZEZyYWdtZW50U2hhZGVyKGwsZnVuY3Rpb24oYyl7ai5fcHJlcGFyZUVmZmVjdChhLGMsYixmLGcpfSl9KX1yZXR1cm4gYi5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1JlYWR5fSxiLnByb3RvdHlwZS5nZXRQcm9ncmFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb2dyYW19LGIucHJvdG90eXBlLmdldEF0dHJpYnV0ZXNOYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzTmFtZXN9LGIucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzW2FdfSxiLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbkJ5TmFtZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9hdHRyaWJ1dGVzTmFtZXMuaW5kZXhPZihhKTtyZXR1cm4gdGhpcy5fYXR0cmlidXRlc1tiXX0sYi5wcm90b3R5cGUuZ2V0QXR0cmlidXRlc0NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RofSxiLnByb3RvdHlwZS5nZXRVbmlmb3JtSW5kZXg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3VuaWZvcm1zTmFtZXMuaW5kZXhPZihhKX0sYi5wcm90b3R5cGUuZ2V0VW5pZm9ybT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fdW5pZm9ybXNbdGhpcy5fdW5pZm9ybXNOYW1lcy5pbmRleE9mKGEpXX0sYi5wcm90b3R5cGUuZ2V0U2FtcGxlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2FtcGxlcnN9LGIucHJvdG90eXBlLmdldENvbXBpbGF0aW9uRXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29tcGlsYXRpb25FcnJvcn0sYi5wcm90b3R5cGUuX2xvYWRWZXJ0ZXhTaGFkZXI9ZnVuY3Rpb24oYixjKXtpZihiIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3ZhciBkPWEuVG9vbHMuR2V0RE9NVGV4dENvbnRlbnQoYik7cmV0dXJuIHZvaWQgYyhkKX1pZihhLkVmZmVjdC5TaGFkZXJzU3RvcmVbYitcIlZlcnRleFNoYWRlclwiXSlyZXR1cm4gdm9pZCBjKGEuRWZmZWN0LlNoYWRlcnNTdG9yZVtiK1wiVmVydGV4U2hhZGVyXCJdKTt2YXIgZTtlPVwiLlwiPT09YlswXT9iOmEuRW5naW5lLlNoYWRlcnNSZXBvc2l0b3J5K2IsYS5Ub29scy5Mb2FkRmlsZShlK1wiLnZlcnRleC5meFwiLGMpfSxiLnByb3RvdHlwZS5fbG9hZEZyYWdtZW50U2hhZGVyPWZ1bmN0aW9uKGIsYyl7aWYoYiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXt2YXIgZD1hLlRvb2xzLkdldERPTVRleHRDb250ZW50KGIpO3JldHVybiB2b2lkIGMoZCl9aWYoYS5FZmZlY3QuU2hhZGVyc1N0b3JlW2IrXCJQaXhlbFNoYWRlclwiXSlyZXR1cm4gdm9pZCBjKGEuRWZmZWN0LlNoYWRlcnNTdG9yZVtiK1wiUGl4ZWxTaGFkZXJcIl0pO3ZhciBlO2U9XCIuXCI9PT1iWzBdP2I6YS5FbmdpbmUuU2hhZGVyc1JlcG9zaXRvcnkrYixhLlRvb2xzLkxvYWRGaWxlKGUrXCIuZnJhZ21lbnQuZnhcIixjKX0sYi5wcm90b3R5cGUuX3ByZXBhcmVFZmZlY3Q9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe3RyeXt2YXIgaD10aGlzLl9lbmdpbmU7dGhpcy5fcHJvZ3JhbT1oLmNyZWF0ZVNoYWRlclByb2dyYW0oYixjLGUpLHRoaXMuX3VuaWZvcm1zPWguZ2V0VW5pZm9ybXModGhpcy5fcHJvZ3JhbSx0aGlzLl91bmlmb3Jtc05hbWVzKSx0aGlzLl9hdHRyaWJ1dGVzPWguZ2V0QXR0cmlidXRlcyh0aGlzLl9wcm9ncmFtLGQpO2Zvcih2YXIgaT0wO2k8dGhpcy5fc2FtcGxlcnMubGVuZ3RoO2krKyl7dmFyIGo9dGhpcy5nZXRVbmlmb3JtKHRoaXMuX3NhbXBsZXJzW2ldKTtudWxsPT1qJiYodGhpcy5fc2FtcGxlcnMuc3BsaWNlKGksMSksaS0tKX1oLmJpbmRTYW1wbGVycyh0aGlzKSx0aGlzLl9pc1JlYWR5PSEwLHRoaXMub25Db21waWxlZCYmdGhpcy5vbkNvbXBpbGVkKHRoaXMpfWNhdGNoKGspe2lmKCFnJiZmKXtmb3IoaT0wO2k8Zi5sZW5ndGg7aSsrKWU9ZS5yZXBsYWNlKGZbaV0sXCJcIik7dGhpcy5fcHJlcGFyZUVmZmVjdChiLGMsZCxlLGYsITApfWVsc2UgYS5Ub29scy5FcnJvcihcIlVuYWJsZSB0byBjb21waWxlIGVmZmVjdDogXCIrdGhpcy5uYW1lKSxhLlRvb2xzLkVycm9yKFwiRGVmaW5lczogXCIrZSksYS5Ub29scy5FcnJvcihcIk9wdGlvbmFsIGRlZmluZXM6IFwiK2YpLGEuVG9vbHMuRXJyb3IoXCJFcnJvcjogXCIray5tZXNzYWdlKSx0aGlzLl9jb21waWxhdGlvbkVycm9yPWsubWVzc2FnZSx0aGlzLm9uRXJyb3ImJnRoaXMub25FcnJvcih0aGlzLHRoaXMuX2NvbXBpbGF0aW9uRXJyb3IpfX0sYi5wcm90b3R5cGUuX2JpbmRUZXh0dXJlPWZ1bmN0aW9uKGEsYil7dGhpcy5fZW5naW5lLl9iaW5kVGV4dHVyZSh0aGlzLl9zYW1wbGVycy5pbmRleE9mKGEpLGIpfSxiLnByb3RvdHlwZS5zZXRUZXh0dXJlPWZ1bmN0aW9uKGEsYil7dGhpcy5fZW5naW5lLnNldFRleHR1cmUodGhpcy5fc2FtcGxlcnMuaW5kZXhPZihhKSxiKX0sYi5wcm90b3R5cGUuc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2Vzcz1mdW5jdGlvbihhLGIpe3RoaXMuX2VuZ2luZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzKHRoaXMuX3NhbXBsZXJzLmluZGV4T2YoYSksYil9LGIucHJvdG90eXBlLl9jYWNoZUZsb2F0Mj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0/KHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09Yix2b2lkKHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09YykpOnZvaWQodGhpcy5fdmFsdWVDYWNoZVthXT1bYixjXSl9LGIucHJvdG90eXBlLl9jYWNoZUZsb2F0Mz1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXT8odGhpcy5fdmFsdWVDYWNoZVthXVswXT1iLHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09Yyx2b2lkKHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMl09ZCkpOnZvaWQodGhpcy5fdmFsdWVDYWNoZVthXT1bYixjLGRdKX0sYi5wcm90b3R5cGUuX2NhY2hlRmxvYXQ0PWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0/KHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09Yix0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPWMsdGhpcy5fdmFsdWVDYWNoZVthXVsyXT1kLHZvaWQodGhpcy5fdmFsdWVDYWNoZVthXVszXT1lKSk6dm9pZCh0aGlzLl92YWx1ZUNhY2hlW2FdPVtiLGMsZCxlXSl9LGIucHJvdG90eXBlLnNldEFycmF5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2VuZ2luZS5zZXRBcnJheSh0aGlzLmdldFVuaWZvcm0oYSksYiksdGhpc30sYi5wcm90b3R5cGUuc2V0TWF0cmljZXM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fZW5naW5lLnNldE1hdHJpY2VzKHRoaXMuZ2V0VW5pZm9ybShhKSxiKSx0aGlzfSxiLnByb3RvdHlwZS5zZXRNYXRyaXg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fZW5naW5lLnNldE1hdHJpeCh0aGlzLmdldFVuaWZvcm0oYSksYiksdGhpc30sYi5wcm90b3R5cGUuc2V0RmxvYXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXT09PWI/dGhpczoodGhpcy5fdmFsdWVDYWNoZVthXT1iLHRoaXMuX2VuZ2luZS5zZXRGbG9hdCh0aGlzLmdldFVuaWZvcm0oYSksYiksdGhpcyl9LGIucHJvdG90eXBlLnNldEJvb2w9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXT09PWI/dGhpczoodGhpcy5fdmFsdWVDYWNoZVthXT1iLHRoaXMuX2VuZ2luZS5zZXRCb29sKHRoaXMuZ2V0VW5pZm9ybShhKSxiPzE6MCksdGhpcyl9LGIucHJvdG90eXBlLnNldFZlY3RvcjI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXVswXT09Yi54JiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPT1iLnk/dGhpczoodGhpcy5fY2FjaGVGbG9hdDIoYSxiLngsYi55KSx0aGlzLl9lbmdpbmUuc2V0RmxvYXQyKHRoaXMuZ2V0VW5pZm9ybShhKSxiLngsYi55KSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0RmxvYXQyPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXVswXT09YiYmdGhpcy5fdmFsdWVDYWNoZVthXVsxXT09Yz90aGlzOih0aGlzLl9jYWNoZUZsb2F0MihhLGIsYyksdGhpcy5fZW5naW5lLnNldEZsb2F0Mih0aGlzLmdldFVuaWZvcm0oYSksYixjKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0VmVjdG9yMz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzBdPT1iLngmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09PWIueSYmdGhpcy5fdmFsdWVDYWNoZVthXVsyXT09Yi56P3RoaXM6KHRoaXMuX2NhY2hlRmxvYXQzKGEsYi54LGIueSxiLnopLHRoaXMuX2VuZ2luZS5zZXRGbG9hdDModGhpcy5nZXRVbmlmb3JtKGEpLGIueCxiLnksYi56KSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0RmxvYXQzPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzBdPT1iJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPT1jJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzJdPT1kP3RoaXM6KHRoaXMuX2NhY2hlRmxvYXQzKGEsYixjLGQpLHRoaXMuX2VuZ2luZS5zZXRGbG9hdDModGhpcy5nZXRVbmlmb3JtKGEpLGIsYyxkKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0RmxvYXQ0PWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0mJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09PWImJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09PWMmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMl09PWQmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bM109PWU/dGhpczoodGhpcy5fY2FjaGVGbG9hdDQoYSxiLGMsZCxlKSx0aGlzLl9lbmdpbmUuc2V0RmxvYXQ0KHRoaXMuZ2V0VW5pZm9ybShhKSxiLGMsZCxlKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0Q29sb3IzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0mJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09PWIuciYmdGhpcy5fdmFsdWVDYWNoZVthXVsxXT09Yi5nJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzJdPT1iLmI/dGhpczoodGhpcy5fY2FjaGVGbG9hdDMoYSxiLnIsYi5nLGIuYiksdGhpcy5fZW5naW5lLnNldENvbG9yMyh0aGlzLmdldFVuaWZvcm0oYSksYiksdGhpcyl9LGIucHJvdG90eXBlLnNldENvbG9yND1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0mJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09PWIuciYmdGhpcy5fdmFsdWVDYWNoZVthXVsxXT09Yi5nJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzJdPT1iLmImJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bM109PWM/dGhpczoodGhpcy5fY2FjaGVGbG9hdDQoYSxiLnIsYi5nLGIuYixjKSx0aGlzLl9lbmdpbmUuc2V0Q29sb3I0KHRoaXMuZ2V0VW5pZm9ybShhKSxiLGMpLHRoaXMpfSxiLlNoYWRlcnNTdG9yZT17YW5hZ2x5cGhQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBsZWZ0U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgbGVmdEZyYWcgPSB0ZXh0dXJlMkQobGVmdFNhbXBsZXIsIHZVVik7XFxuICAgIGxlZnRGcmFnID0gdmVjNCgxLjAsIGxlZnRGcmFnLmcsIGxlZnRGcmFnLmIsIDEuMCk7XFxuXFxuXHR2ZWM0IHJpZ2h0RnJhZyA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWKTtcXG4gICAgcmlnaHRGcmFnID0gdmVjNChyaWdodEZyYWcuciwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmlnaHRGcmFnLnJnYiAqIGxlZnRGcmFnLnJnYiwgMS4wKTtcXG59XCIsYmxhY2tBbmRXaGl0ZVBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKSBcXG57XFxuXHRmbG9hdCBsdW1pbmFuY2UgPSBkb3QodGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYpLnJnYiwgdmVjMygwLjMsIDAuNTksIDAuMTEpKTtcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQobHVtaW5hbmNlLCBsdW1pbmFuY2UsIGx1bWluYW5jZSwgMS4wKTtcXG59XCIsYmx1clBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbi8vIFBhcmFtZXRlcnNcXG51bmlmb3JtIHZlYzIgc2NyZWVuU2l6ZTtcXG51bmlmb3JtIHZlYzIgZGlyZWN0aW9uO1xcbnVuaWZvcm0gZmxvYXQgYmx1cldpZHRoO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG5cdGZsb2F0IHdlaWdodHNbN107XFxuXHR3ZWlnaHRzWzBdID0gMC4wNTtcXG5cdHdlaWdodHNbMV0gPSAwLjE7XFxuXHR3ZWlnaHRzWzJdID0gMC4yO1xcblx0d2VpZ2h0c1szXSA9IDAuMztcXG5cdHdlaWdodHNbNF0gPSAwLjI7XFxuXHR3ZWlnaHRzWzVdID0gMC4xO1xcblx0d2VpZ2h0c1s2XSA9IDAuMDU7XFxuXFxuXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoMS4wIC8gc2NyZWVuU2l6ZS54LCAxLjAgLyBzY3JlZW5TaXplLnkpO1xcblx0dmVjMiB0ZXhlbFN0ZXAgPSB0ZXhlbFNpemUgKiBkaXJlY3Rpb24gKiBibHVyV2lkdGg7XFxuXHR2ZWMyIHN0YXJ0ID0gdlVWIC0gMy4wICogdGV4ZWxTdGVwO1xcblxcblx0dmVjNCBiYXNlQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcXG5cdHZlYzIgdGV4ZWxPZmZzZXQgPSB2ZWMyKDAuLCAwLik7XFxuXFxuXHRmb3IgKGludCBpID0gMDsgaSA8IDc7IGkrKylcXG5cdHtcXG5cdFx0YmFzZUNvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgc3RhcnQgKyB0ZXhlbE9mZnNldCkgKiB3ZWlnaHRzW2ldO1xcblx0XHR0ZXhlbE9mZnNldCArPSB0ZXhlbFN0ZXA7XFxuXHR9XFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBiYXNlQ29sb3I7XFxufVwiLGNvbG9yUGl4ZWxTaGFkZXI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuKTtcXG59XCIsY29sb3JWZXJ0ZXhTaGFkZXI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG4vLyBBdHRyaWJ1dGVzXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XFxuXFxuLy8gVW5pZm9ybXNcXG51bmlmb3JtIG1hdDQgd29ybGRWaWV3UHJvamVjdGlvbjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0Z2xfUG9zaXRpb24gPSB3b3JsZFZpZXdQcm9qZWN0aW9uICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsY29udm9sdXRpb25QaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG5cXG51bmlmb3JtIHZlYzIgc2NyZWVuU2l6ZTtcXG51bmlmb3JtIGZsb2F0IGtlcm5lbFs5XTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuXHR2ZWMyIG9uZVBpeGVsID0gdmVjMigxLjAsIDEuMCkgLyBzY3JlZW5TaXplO1xcblx0dmVjNCBjb2xvclN1bSA9XFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgb25lUGl4ZWwgKiB2ZWMyKC0xLCAtMSkpICoga2VybmVsWzBdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMCwgLTEpKSAqIGtlcm5lbFsxXSArXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgb25lUGl4ZWwgKiB2ZWMyKDEsIC0xKSkgKiBrZXJuZWxbMl0gK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIG9uZVBpeGVsICogdmVjMigtMSwgMCkpICoga2VybmVsWzNdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMCwgMCkpICoga2VybmVsWzRdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMSwgMCkpICoga2VybmVsWzVdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoLTEsIDEpKSAqIGtlcm5lbFs2XSArXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgb25lUGl4ZWwgKiB2ZWMyKDAsIDEpKSAqIGtlcm5lbFs3XSArXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgb25lUGl4ZWwgKiB2ZWMyKDEsIDEpKSAqIGtlcm5lbFs4XTtcXG5cXG5cdGZsb2F0IGtlcm5lbFdlaWdodCA9XFxuXHRcdGtlcm5lbFswXSArXFxuXHRcdGtlcm5lbFsxXSArXFxuXHRcdGtlcm5lbFsyXSArXFxuXHRcdGtlcm5lbFszXSArXFxuXHRcdGtlcm5lbFs0XSArXFxuXHRcdGtlcm5lbFs1XSArXFxuXHRcdGtlcm5lbFs2XSArXFxuXHRcdGtlcm5lbFs3XSArXFxuXHRcdGtlcm5lbFs4XTtcXG5cXG5cdGlmIChrZXJuZWxXZWlnaHQgPD0gMC4wKSB7XFxuXHRcdGtlcm5lbFdlaWdodCA9IDEuMDtcXG5cdH1cXG5cXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoKGNvbG9yU3VtIC8ga2VybmVsV2VpZ2h0KS5yZ2IsIDEpO1xcbn1cIixkZWZhdWx0UGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4jZGVmaW5lIE1BUF9FWFBMSUNJVFx0MC5cXG4jZGVmaW5lIE1BUF9TUEhFUklDQUxcdDEuXFxuI2RlZmluZSBNQVBfUExBTkFSXHRcdDIuXFxuI2RlZmluZSBNQVBfQ1VCSUNcdFx0My5cXG4jZGVmaW5lIE1BUF9QUk9KRUNUSU9OXHQ0LlxcbiNkZWZpbmUgTUFQX1NLWUJPWFx0XHQ1Llxcblxcbi8vIENvbnN0YW50c1xcbnVuaWZvcm0gdmVjMyB2RXllUG9zaXRpb247XFxudW5pZm9ybSB2ZWMzIHZBbWJpZW50Q29sb3I7XFxudW5pZm9ybSB2ZWM0IHZEaWZmdXNlQ29sb3I7XFxudW5pZm9ybSB2ZWM0IHZTcGVjdWxhckNvbG9yO1xcbnVuaWZvcm0gdmVjMyB2RW1pc3NpdmVDb2xvcjtcXG5cXG4vLyBJbnB1dFxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25XO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsVztcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblxcbi8vIExpZ2h0c1xcbiNpZmRlZiBMSUdIVDBcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTA7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UwO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjA7XFxuI2lmZGVmIFNIQURPVzBcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MDtcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMDtcXG51bmlmb3JtIGZsb2F0IGRhcmtuZXNzMDtcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUMFxcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24wO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQwXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDA7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUMVxcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMTtcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTE7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMTtcXG4jaWZkZWYgU0hBRE9XMVxcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQxO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIxO1xcbnVuaWZvcm0gZmxvYXQgZGFya25lc3MxO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQxXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjE7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDFcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMTtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQyXFxudW5pZm9ybSB2ZWM0IHZMaWdodERhdGEyO1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaWZmdXNlMjtcXG51bmlmb3JtIHZlYzMgdkxpZ2h0U3BlY3VsYXIyO1xcbiNpZmRlZiBTSEFET1cyXFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDI7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcjI7XFxudW5pZm9ybSBmbG9hdCBkYXJrbmVzczI7XFxuI2VuZGlmXFxuI2lmZGVmIFNQT1RMSUdIVDJcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlyZWN0aW9uMjtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMlxcbnVuaWZvcm0gdmVjMyB2TGlnaHRHcm91bmQyO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDNcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTM7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UzO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjM7XFxuI2lmZGVmIFNIQURPVzNcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MztcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMztcXG51bmlmb3JtIGZsb2F0IGRhcmtuZXNzMztcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUM1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24zO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQzXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDM7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG4jaWZkZWYgRElGRlVTRVxcbnZhcnlpbmcgdmVjMiB2RGlmZnVzZVVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB2RGlmZnVzZUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTUJJRU5UXFxudmFyeWluZyB2ZWMyIHZBbWJpZW50VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgYW1iaWVudFNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZBbWJpZW50SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE9QQUNJVFlcdFxcbnZhcnlpbmcgdmVjMiB2T3BhY2l0eVVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG9wYWNpdHlTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB2T3BhY2l0eUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBFTUlTU0lWRVxcbnZhcnlpbmcgdmVjMiB2RW1pc3NpdmVVVjtcXG51bmlmb3JtIHZlYzIgdkVtaXNzaXZlSW5mb3M7XFxudW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVTYW1wbGVyO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBTUEVDVUxBUlxcbnZhcnlpbmcgdmVjMiB2U3BlY3VsYXJVVjtcXG51bmlmb3JtIHZlYzIgdlNwZWN1bGFySW5mb3M7XFxudW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJTYW1wbGVyO1xcbiNlbmRpZlxcblxcbi8vIFJlZmxlY3Rpb25cXG4jaWZkZWYgUkVGTEVDVElPTlxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25VVlc7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSByZWZsZWN0aW9uQ3ViZVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgcmVmbGVjdGlvbjJEU2FtcGxlcjtcXG51bmlmb3JtIHZlYzMgdlJlZmxlY3Rpb25JbmZvcztcXG51bmlmb3JtIG1hdDQgcmVmbGVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdmlldztcXG5cXG52ZWMzIGNvbXB1dGVSZWZsZWN0aW9uQ29vcmRzKGZsb2F0IG1vZGUsIHZlYzQgd29ybGRQb3MsIHZlYzMgd29ybGROb3JtYWwpXFxue1xcblx0aWYgKG1vZGUgPT0gTUFQX1NQSEVSSUNBTClcXG5cdHtcXG5cdFx0dmVjMyBjb29yZHMgPSB2ZWMzKHZpZXcgKiB2ZWM0KHdvcmxkTm9ybWFsLCAwLjApKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAxLjApKTtcXG5cdH1cXG5cdGVsc2UgaWYgKG1vZGUgPT0gTUFQX1BMQU5BUilcXG5cdHtcXG5cdFx0dmVjMyB2aWV3RGlyID0gd29ybGRQb3MueHl6IC0gdkV5ZVBvc2l0aW9uO1xcblx0XHR2ZWMzIGNvb3JkcyA9IG5vcm1hbGl6ZShyZWZsZWN0KHZpZXdEaXIsIHdvcmxkTm9ybWFsKSk7XFxuXFxuXHRcdHJldHVybiB2ZWMzKHJlZmxlY3Rpb25NYXRyaXggKiB2ZWM0KGNvb3JkcywgMSkpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfQ1VCSUMpXFxuXHR7XFxuXHRcdHZlYzMgdmlld0RpciA9IHdvcmxkUG9zLnh5eiAtIHZFeWVQb3NpdGlvbjtcXG5cdFx0dmVjMyBjb29yZHMgPSByZWZsZWN0KHZpZXdEaXIsIHdvcmxkTm9ybWFsKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAwKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9QUk9KRUNUSU9OKVxcblx0e1xcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogKHZpZXcgKiB3b3JsZFBvcykpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfU0tZQk9YKVxcblx0e1xcblx0XHRyZXR1cm4gdlBvc2l0aW9uVVZXO1xcblx0fVxcblxcblx0cmV0dXJuIHZlYzMoMCwgMCwgMCk7XFxufVxcbiNlbmRpZlxcblxcbi8vIFNoYWRvd3NcXG4jaWZkZWYgU0hBRE9XU1xcblxcbmZsb2F0IHVucGFjayh2ZWM0IGNvbG9yKVxcbntcXG5cdGNvbnN0IHZlYzQgYml0U2hpZnQgPSB2ZWM0KDEuIC8gKDI1NS4gKiAyNTUuICogMjU1LiksIDEuIC8gKDI1NS4gKiAyNTUuKSwgMS4gLyAyNTUuLCAxLik7XFxuXHRyZXR1cm4gZG90KGNvbG9yLCBiaXRTaGlmdCk7XFxufVxcblxcbmZsb2F0IHVucGFja0hhbGYodmVjMiBjb2xvcilcXG57XFxuXHRyZXR1cm4gY29sb3IueCArIChjb2xvci55IC8gMjU1LjApO1xcbn1cXG5cXG5mbG9hdCBjb21wdXRlU2hhZG93KHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LCBzYW1wbGVyMkQgc2hhZG93U2FtcGxlciwgZmxvYXQgZGFya25lc3MpXFxue1xcblx0dmVjMyBkZXB0aCA9IHZQb3NpdGlvbkZyb21MaWdodC54eXogLyB2UG9zaXRpb25Gcm9tTGlnaHQudztcXG5cdHZlYzIgdXYgPSAwLjUgKiBkZXB0aC54eSArIHZlYzIoMC41LCAwLjUpO1xcblxcblx0aWYgKHV2LnggPCAwLiB8fCB1di54ID4gMS4wIHx8IHV2LnkgPCAwLiB8fCB1di55ID4gMS4wKVxcblx0e1xcblx0XHRyZXR1cm4gMS4wO1xcblx0fVxcblxcblx0ZmxvYXQgc2hhZG93ID0gdW5wYWNrKHRleHR1cmUyRChzaGFkb3dTYW1wbGVyLCB1dikpO1xcblxcblx0aWYgKGRlcHRoLnogPiBzaGFkb3cpXFxuXHR7XFxuXHRcdHJldHVybiBkYXJrbmVzcztcXG5cdH1cXG5cdHJldHVybiAxLjtcXG59XFxuXFxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhQQ0YodmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyKVxcbntcXG5cdHZlYzMgZGVwdGggPSB2UG9zaXRpb25Gcm9tTGlnaHQueHl6IC8gdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7XFxuXHR2ZWMyIHV2ID0gMC41ICogZGVwdGgueHkgKyB2ZWMyKDAuNSwgMC41KTtcXG5cXG5cdGlmICh1di54IDwgMC4gfHwgdXYueCA+IDEuMCB8fCB1di55IDwgMC4gfHwgdXYueSA+IDEuMClcXG5cdHtcXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cXG5cdGZsb2F0IHZpc2liaWxpdHkgPSAxLjtcXG5cXG5cdHZlYzIgcG9pc3NvbkRpc2tbNF07XFxuXHRwb2lzc29uRGlza1swXSA9IHZlYzIoLTAuOTQyMDE2MjQsIC0wLjM5OTA2MjE2KTtcXG5cdHBvaXNzb25EaXNrWzFdID0gdmVjMigwLjk0NTU4NjA5LCAtMC43Njg5MDcyNSk7XFxuXHRwb2lzc29uRGlza1syXSA9IHZlYzIoLTAuMDk0MTg0MTAxLCAtMC45MjkzODg3MCk7XFxuXHRwb2lzc29uRGlza1szXSA9IHZlYzIoMC4zNDQ5NTkzOCwgMC4yOTM4Nzc2MCk7XFxuXFxuXHQvLyBQb2lzc29uIFNhbXBsaW5nXFxuXHRmb3IgKGludCBpID0gMDsgaTw0OyBpKyspe1xcblx0XHRpZiAodW5wYWNrKHRleHR1cmUyRChzaGFkb3dTYW1wbGVyLCB1diArIHBvaXNzb25EaXNrW2ldIC8gMTUwMC4wKSkgIDwgIGRlcHRoLnope1xcblx0XHRcdHZpc2liaWxpdHkgLT0gMC4yO1xcblx0XHR9XFxuXHR9XFxuXHRyZXR1cm4gdmlzaWJpbGl0eTtcXG59XFxuXFxuLy8gVGhhbmtzIHRvIGh0dHA6Ly9kZXZtYXN0ZXIubmV0L1xcbmZsb2F0IENoZWJ5Y2hldkluZXF1YWxpdHkodmVjMiBtb21lbnRzLCBmbG9hdCB0KVxcbntcXG5cdGlmICh0IDw9IG1vbWVudHMueClcXG5cdHtcXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cXG5cdGZsb2F0IHZhcmlhbmNlID0gbW9tZW50cy55IC0gKG1vbWVudHMueCAqIG1vbWVudHMueCk7XFxuXHR2YXJpYW5jZSA9IG1heCh2YXJpYW5jZSwgMC4pO1xcblxcblx0ZmxvYXQgZCA9IHQgLSBtb21lbnRzLng7XFxuXHRyZXR1cm4gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkICogZCk7XFxufVxcblxcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LCBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcilcXG57XFxuXHR2ZWMzIGRlcHRoID0gdlBvc2l0aW9uRnJvbUxpZ2h0Lnh5eiAvIHZQb3NpdGlvbkZyb21MaWdodC53O1xcblx0dmVjMiB1diA9IDAuNSAqIGRlcHRoLnh5ICsgdmVjMigwLjUsIDAuNSk7XFxuXFxuXHRpZiAodXYueCA8IDAuIHx8IHV2LnggPiAxLjAgfHwgdXYueSA8IDAuIHx8IHV2LnkgPiAxLjApXFxuXHR7XFxuXHRcdHJldHVybiAxLjA7XFxuXHR9XFxuXFxuXHR2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsIHV2KTtcXG5cXG5cdHZlYzIgbW9tZW50cyA9IHZlYzIodW5wYWNrSGFsZih0ZXhlbC54eSksIHVucGFja0hhbGYodGV4ZWwuencpKTtcXG5cdHJldHVybiBjbGFtcCgxLjMgLSBDaGVieWNoZXZJbmVxdWFsaXR5KG1vbWVudHMsIGRlcHRoLnopLCAwLiwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXFxuLy8gQnVtcFxcbiNpZmRlZiBCVU1QXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcXG52YXJ5aW5nIHZlYzIgdkJ1bXBVVjtcXG51bmlmb3JtIHZlYzIgdkJ1bXBJbmZvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBidW1wU2FtcGxlcjtcXG5cXG4vLyBUaGFua3MgdG8gaHR0cDovL3d3dy50aGV0ZW50aHBsYW5ldC5kZS9hcmNoaXZlcy8xMTgwXFxubWF0MyBjb3RhbmdlbnRfZnJhbWUodmVjMyBub3JtYWwsIHZlYzMgcCwgdmVjMiB1dilcXG57XFxuXHQvLyBnZXQgZWRnZSB2ZWN0b3JzIG9mIHRoZSBwaXhlbCB0cmlhbmdsZVxcblx0dmVjMyBkcDEgPSBkRmR4KHApO1xcblx0dmVjMyBkcDIgPSBkRmR5KHApO1xcblx0dmVjMiBkdXYxID0gZEZkeCh1dik7XFxuXHR2ZWMyIGR1djIgPSBkRmR5KHV2KTtcXG5cXG5cdC8vIHNvbHZlIHRoZSBsaW5lYXIgc3lzdGVtXFxuXHR2ZWMzIGRwMnBlcnAgPSBjcm9zcyhkcDIsIG5vcm1hbCk7XFxuXHR2ZWMzIGRwMXBlcnAgPSBjcm9zcyhub3JtYWwsIGRwMSk7XFxuXHR2ZWMzIHRhbmdlbnQgPSBkcDJwZXJwICogZHV2MS54ICsgZHAxcGVycCAqIGR1djIueDtcXG5cdHZlYzMgYmlub3JtYWwgPSBkcDJwZXJwICogZHV2MS55ICsgZHAxcGVycCAqIGR1djIueTtcXG5cXG5cdC8vIGNvbnN0cnVjdCBhIHNjYWxlLWludmFyaWFudCBmcmFtZSBcXG5cdGZsb2F0IGludm1heCA9IGludmVyc2VzcXJ0KG1heChkb3QodGFuZ2VudCwgdGFuZ2VudCksIGRvdChiaW5vcm1hbCwgYmlub3JtYWwpKSk7XFxuXHRyZXR1cm4gbWF0Myh0YW5nZW50ICogaW52bWF4LCBiaW5vcm1hbCAqIGludm1heCwgbm9ybWFsKTtcXG59XFxuXFxudmVjMyBwZXJ0dXJiTm9ybWFsKHZlYzMgdmlld0RpcilcXG57XFxuXHR2ZWMzIG1hcCA9IHRleHR1cmUyRChidW1wU2FtcGxlciwgdkJ1bXBVVikueHl6ICogdkJ1bXBJbmZvcy55O1xcblx0bWFwID0gbWFwICogMjU1LiAvIDEyNy4gLSAxMjguIC8gMTI3LjtcXG5cdG1hdDMgVEJOID0gY290YW5nZW50X2ZyYW1lKHZOb3JtYWxXLCAtdmlld0RpciwgdkJ1bXBVVik7XFxuXHRyZXR1cm4gbm9ybWFsaXplKFRCTiAqIG1hcCk7XFxufVxcbiNlbmRpZlxcblxcbiNpZmRlZiBDTElQUExBTkVcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuLy8gRm9nXFxuI2lmZGVmIEZPR1xcblxcbiNkZWZpbmUgRk9HTU9ERV9OT05FICAgIDAuXFxuI2RlZmluZSBGT0dNT0RFX0VYUCAgICAgMS5cXG4jZGVmaW5lIEZPR01PREVfRVhQMiAgICAyLlxcbiNkZWZpbmUgRk9HTU9ERV9MSU5FQVIgIDMuXFxuI2RlZmluZSBFIDIuNzE4MjhcXG5cXG51bmlmb3JtIHZlYzQgdkZvZ0luZm9zO1xcbnVuaWZvcm0gdmVjMyB2Rm9nQ29sb3I7XFxudmFyeWluZyBmbG9hdCBmRm9nRGlzdGFuY2U7XFxuXFxuZmxvYXQgQ2FsY0ZvZ0ZhY3RvcigpXFxue1xcblx0ZmxvYXQgZm9nQ29lZmYgPSAxLjA7XFxuXHRmbG9hdCBmb2dTdGFydCA9IHZGb2dJbmZvcy55O1xcblx0ZmxvYXQgZm9nRW5kID0gdkZvZ0luZm9zLno7XFxuXHRmbG9hdCBmb2dEZW5zaXR5ID0gdkZvZ0luZm9zLnc7XFxuXFxuXHRpZiAoRk9HTU9ERV9MSU5FQVIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gKGZvZ0VuZCAtIGZGb2dEaXN0YW5jZSkgLyAoZm9nRW5kIC0gZm9nU3RhcnQpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAyID09IHZGb2dJbmZvcy54KVxcblx0e1xcblx0XHRmb2dDb2VmZiA9IDEuMCAvIHBvdyhFLCBmRm9nRGlzdGFuY2UgKiBmRm9nRGlzdGFuY2UgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXFxuXHRyZXR1cm4gY2xhbXAoZm9nQ29lZmYsIDAuMCwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXFxuLy8gTGlnaHQgQ29tcHV0aW5nXFxuc3RydWN0IGxpZ2h0aW5nSW5mb1xcbntcXG5cdHZlYzMgZGlmZnVzZTtcXG5cdHZlYzMgc3BlY3VsYXI7XFxufTtcXG5cXG5saWdodGluZ0luZm8gY29tcHV0ZUxpZ2h0aW5nKHZlYzMgdmlld0RpcmVjdGlvblcsIHZlYzMgdk5vcm1hbCwgdmVjNCBsaWdodERhdGEsIHZlYzMgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsIGZsb2F0IHJhbmdlKSB7XFxuXHRsaWdodGluZ0luZm8gcmVzdWx0O1xcblxcblx0dmVjMyBsaWdodFZlY3Rvclc7XFxuXHRmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cdGlmIChsaWdodERhdGEudyA9PSAwLilcXG5cdHtcXG5cdFx0dmVjMyBkaXJlY3Rpb24gPSBsaWdodERhdGEueHl6IC0gdlBvc2l0aW9uVztcXG5cXG5cdFx0YXR0ZW51YXRpb24gPSBtYXgoMC4sIDEuMCAtIGxlbmd0aChkaXJlY3Rpb24pIC8gcmFuZ2UpO1xcblx0XHRsaWdodFZlY3RvclcgPSBub3JtYWxpemUoZGlyZWN0aW9uKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0bGlnaHRWZWN0b3JXID0gbm9ybWFsaXplKC1saWdodERhdGEueHl6KTtcXG5cdH1cXG5cXG5cdC8vIGRpZmZ1c2VcXG5cdGZsb2F0IG5kbCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGxpZ2h0VmVjdG9yVykpO1xcblxcblx0Ly8gU3BlY3VsYXJcXG5cdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XICsgbGlnaHRWZWN0b3JXKTtcXG5cdGZsb2F0IHNwZWNDb21wID0gbWF4KDAuLCBkb3Qodk5vcm1hbCwgYW5nbGVXKSk7XFxuXHRzcGVjQ29tcCA9IHBvdyhzcGVjQ29tcCwgbWF4KDEuLCB2U3BlY3VsYXJDb2xvci5hKSk7XFxuXFxuXHRyZXN1bHQuZGlmZnVzZSA9IG5kbCAqIGRpZmZ1c2VDb2xvciAqIGF0dGVudWF0aW9uO1xcblx0cmVzdWx0LnNwZWN1bGFyID0gc3BlY0NvbXAgKiBzcGVjdWxhckNvbG9yICogYXR0ZW51YXRpb247XFxuXFxuXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5saWdodGluZ0luZm8gY29tcHV0ZVNwb3RMaWdodGluZyh2ZWMzIHZpZXdEaXJlY3Rpb25XLCB2ZWMzIHZOb3JtYWwsIHZlYzQgbGlnaHREYXRhLCB2ZWM0IGxpZ2h0RGlyZWN0aW9uLCB2ZWMzIGRpZmZ1c2VDb2xvciwgdmVjMyBzcGVjdWxhckNvbG9yLCBmbG9hdCByYW5nZSkge1xcblx0bGlnaHRpbmdJbmZvIHJlc3VsdDtcXG5cXG5cdHZlYzMgZGlyZWN0aW9uID0gbGlnaHREYXRhLnh5eiAtIHZQb3NpdGlvblc7XFxuXHR2ZWMzIGxpZ2h0VmVjdG9yVyA9IG5vcm1hbGl6ZShkaXJlY3Rpb24pO1xcblx0ZmxvYXQgYXR0ZW51YXRpb24gPSBtYXgoMC4sIDEuMCAtIGxlbmd0aChkaXJlY3Rpb24pIC8gcmFuZ2UpO1xcblxcblx0Ly8gZGlmZnVzZVxcblx0ZmxvYXQgY29zQW5nbGUgPSBtYXgoMC4sIGRvdCgtbGlnaHREaXJlY3Rpb24ueHl6LCBsaWdodFZlY3RvclcpKTtcXG5cdGZsb2F0IHNwb3RBdHRlbiA9IDAuMDtcXG5cXG5cdGlmIChjb3NBbmdsZSA+PSBsaWdodERpcmVjdGlvbi53KVxcblx0e1xcblx0XHRjb3NBbmdsZSA9IG1heCgwLiwgcG93KGNvc0FuZ2xlLCBsaWdodERhdGEudykpO1xcblx0XHRzcG90QXR0ZW4gPSBtYXgoMC4sIChjb3NBbmdsZSAtIGxpZ2h0RGlyZWN0aW9uLncpIC8gKDEuIC0gY29zQW5nbGUpKTtcXG5cXG5cdFx0Ly8gRGlmZnVzZVxcblx0XHRmbG9hdCBuZGwgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCAtbGlnaHREaXJlY3Rpb24ueHl6KSk7XFxuXFxuXHRcdC8vIFNwZWN1bGFyXFxuXHRcdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XIC0gbGlnaHREaXJlY3Rpb24ueHl6KTtcXG5cdFx0ZmxvYXQgc3BlY0NvbXAgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCBhbmdsZVcpKTtcXG5cdFx0c3BlY0NvbXAgPSBwb3coc3BlY0NvbXAsIHZTcGVjdWxhckNvbG9yLmEpO1xcblxcblx0XHRyZXN1bHQuZGlmZnVzZSA9IG5kbCAqIHNwb3RBdHRlbiAqIGRpZmZ1c2VDb2xvciAqIGF0dGVudWF0aW9uO1xcblx0XHRyZXN1bHQuc3BlY3VsYXIgPSBzcGVjQ29tcCAqIHNwZWN1bGFyQ29sb3IgKiBzcG90QXR0ZW4gKiBhdHRlbnVhdGlvbjtcXG5cXG5cdFx0cmV0dXJuIHJlc3VsdDtcXG5cdH1cXG5cXG5cdHJlc3VsdC5kaWZmdXNlID0gdmVjMygwLik7XFxuXHRyZXN1bHQuc3BlY3VsYXIgPSB2ZWMzKDAuKTtcXG5cXG5cdHJldHVybiByZXN1bHQ7XFxufVxcblxcbmxpZ2h0aW5nSW5mbyBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2ZWMzIHZpZXdEaXJlY3Rpb25XLCB2ZWMzIHZOb3JtYWwsIHZlYzQgbGlnaHREYXRhLCB2ZWMzIGRpZmZ1c2VDb2xvciwgdmVjMyBzcGVjdWxhckNvbG9yLCB2ZWMzIGdyb3VuZENvbG9yKSB7XFxuXHRsaWdodGluZ0luZm8gcmVzdWx0O1xcblxcblx0Ly8gRGlmZnVzZVxcblx0ZmxvYXQgbmRsID0gZG90KHZOb3JtYWwsIGxpZ2h0RGF0YS54eXopICogMC41ICsgMC41O1xcblxcblx0Ly8gU3BlY3VsYXJcXG5cdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XICsgbGlnaHREYXRhLnh5eik7XFxuXHRmbG9hdCBzcGVjQ29tcCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGFuZ2xlVykpO1xcblx0c3BlY0NvbXAgPSBwb3coc3BlY0NvbXAsIHZTcGVjdWxhckNvbG9yLmEpO1xcblxcblx0cmVzdWx0LmRpZmZ1c2UgPSBtaXgoZ3JvdW5kQ29sb3IsIGRpZmZ1c2VDb2xvciwgbmRsKTtcXG5cdHJlc3VsdC5zcGVjdWxhciA9IHNwZWNDb21wICogc3BlY3VsYXJDb2xvcjtcXG5cXG5cdHJldHVybiByZXN1bHQ7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXHQvLyBDbGlwIHBsYW5lXFxuI2lmZGVmIENMSVBQTEFORVxcblx0aWYgKGZDbGlwRGlzdGFuY2UgPiAwLjApXFxuXHRcdGRpc2NhcmQ7XFxuI2VuZGlmXFxuXFxuXHR2ZWMzIHZpZXdEaXJlY3Rpb25XID0gbm9ybWFsaXplKHZFeWVQb3NpdGlvbiAtIHZQb3NpdGlvblcpO1xcblxcblx0Ly8gQmFzZSBjb2xvclxcblx0dmVjNCBiYXNlQ29sb3IgPSB2ZWM0KDEuLCAxLiwgMS4sIDEuKTtcXG5cdHZlYzMgZGlmZnVzZUNvbG9yID0gdkRpZmZ1c2VDb2xvci5yZ2I7XFxuXFxuXHQvLyBBbHBoYVxcblx0ZmxvYXQgYWxwaGEgPSB2RGlmZnVzZUNvbG9yLmE7XFxuXFxuI2lmZGVmIFZFUlRFWENPTE9SXFxuXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBESUZGVVNFXFxuXHRiYXNlQ29sb3IgPSB0ZXh0dXJlMkQoZGlmZnVzZVNhbXBsZXIsIHZEaWZmdXNlVVYpO1xcblxcbiNpZmRlZiBBTFBIQVRFU1RcXG5cdGlmIChiYXNlQ29sb3IuYSA8IDAuNClcXG5cdFx0ZGlzY2FyZDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQUxQSEFGUk9NRElGRlVTRVxcblx0YWxwaGEgKj0gYmFzZUNvbG9yLmE7XFxuI2VuZGlmXFxuXFxuXHRiYXNlQ29sb3IucmdiICo9IHZEaWZmdXNlSW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cdC8vIEJ1bXBcXG5cdHZlYzMgbm9ybWFsVyA9IG5vcm1hbGl6ZSh2Tm9ybWFsVyk7XFxuXFxuI2lmZGVmIEJVTVBcXG5cdG5vcm1hbFcgPSBwZXJ0dXJiTm9ybWFsKHZpZXdEaXJlY3Rpb25XKTtcXG4jZW5kaWZcXG5cXG5cdC8vIEFtYmllbnQgY29sb3JcXG5cdHZlYzMgYmFzZUFtYmllbnRDb2xvciA9IHZlYzMoMS4sIDEuLCAxLik7XFxuXFxuI2lmZGVmIEFNQklFTlRcXG5cdGJhc2VBbWJpZW50Q29sb3IgPSB0ZXh0dXJlMkQoYW1iaWVudFNhbXBsZXIsIHZBbWJpZW50VVYpLnJnYiAqIHZBbWJpZW50SW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cdC8vIExpZ2h0aW5nXFxuXHR2ZWMzIGRpZmZ1c2VCYXNlID0gdmVjMygwLiwgMC4sIDAuKTtcXG5cdHZlYzMgc3BlY3VsYXJCYXNlID0gdmVjMygwLiwgMC4sIDAuKTtcXG5cdGZsb2F0IHNoYWRvdyA9IDEuO1xcblxcbiNpZmRlZiBMSUdIVDBcXG4jaWZkZWYgU1BPVExJR0hUMFxcblx0bGlnaHRpbmdJbmZvIGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMCwgdkxpZ2h0RGlyZWN0aW9uMCwgdkxpZ2h0RGlmZnVzZTAucmdiLCB2TGlnaHRTcGVjdWxhcjAsIHZMaWdodERpZmZ1c2UwLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQwXFxuXHRsaWdodGluZ0luZm8gaW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMCwgdkxpZ2h0RGlmZnVzZTAucmdiLCB2TGlnaHRTcGVjdWxhcjAsIHZMaWdodEdyb3VuZDApO1xcbiNlbmRpZlxcbiNpZmRlZiBQT0lOVERJUkxJR0hUMFxcblx0bGlnaHRpbmdJbmZvIGluZm8gPSBjb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaWZmdXNlMC5yZ2IsIHZMaWdodFNwZWN1bGFyMCwgdkxpZ2h0RGlmZnVzZTAuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzBcXG4jaWZkZWYgU0hBRE9XVlNNMFxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0MCwgc2hhZG93U2FtcGxlcjApO1xcbiNlbHNlXFxuXHQjaWZkZWYgU0hBRE9XUENGMFxcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFBDRih2UG9zaXRpb25Gcm9tTGlnaHQwLCBzaGFkb3dTYW1wbGVyMCk7XFxuXHQjZWxzZVxcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDAsIHNoYWRvd1NhbXBsZXIwLCBkYXJrbmVzczApO1xcblx0I2VuZGlmXFxuI2VuZGlmXFxuI2Vsc2VcXG5cdHNoYWRvdyA9IDEuO1xcbiNlbmRpZlxcblx0ZGlmZnVzZUJhc2UgKz0gaW5mby5kaWZmdXNlICogc2hhZG93O1xcblx0c3BlY3VsYXJCYXNlICs9IGluZm8uc3BlY3VsYXIgKiBzaGFkb3c7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUMVxcbiNpZmRlZiBTUE9UTElHSFQxXFxuXHRpbmZvID0gY29tcHV0ZVNwb3RMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTEsIHZMaWdodERpcmVjdGlvbjEsIHZMaWdodERpZmZ1c2UxLnJnYiwgdkxpZ2h0U3BlY3VsYXIxLCB2TGlnaHREaWZmdXNlMS5hKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMVxcblx0aW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlmZnVzZTEucmdiLCB2TGlnaHRTcGVjdWxhcjEsIHZMaWdodEdyb3VuZDEpO1xcbiNlbmRpZlxcbiNpZmRlZiBQT0lOVERJUkxJR0hUMVxcblx0aW5mbyA9IGNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTEsIHZMaWdodERpZmZ1c2UxLnJnYiwgdkxpZ2h0U3BlY3VsYXIxLCB2TGlnaHREaWZmdXNlMS5hKTtcXG4jZW5kaWZcXG4jaWZkZWYgU0hBRE9XMVxcbiNpZmRlZiBTSEFET1dWU00xXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFZTTSh2UG9zaXRpb25Gcm9tTGlnaHQxLCBzaGFkb3dTYW1wbGVyMSk7XFxuI2Vsc2VcXG5cdCNpZmRlZiBTSEFET1dQQ0YxXFxuXHRcdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoUENGKHZQb3NpdGlvbkZyb21MaWdodDEsIHNoYWRvd1NhbXBsZXIxKTtcXG5cdCNlbHNlXFxuXHRcdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3codlBvc2l0aW9uRnJvbUxpZ2h0MSwgc2hhZG93U2FtcGxlcjEsIGRhcmtuZXNzMSk7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvLmRpZmZ1c2UgKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mby5zcGVjdWxhciAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQyXFxuI2lmZGVmIFNQT1RMSUdIVDJcXG5cdGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMiwgdkxpZ2h0RGlyZWN0aW9uMiwgdkxpZ2h0RGlmZnVzZTIucmdiLCB2TGlnaHRTcGVjdWxhcjIsIHZMaWdodERpZmZ1c2UyLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQyXFxuXHRpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaWZmdXNlMi5yZ2IsIHZMaWdodFNwZWN1bGFyMiwgdkxpZ2h0R3JvdW5kMik7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQyXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMiwgdkxpZ2h0RGlmZnVzZTIucmdiLCB2TGlnaHRTcGVjdWxhcjIsIHZMaWdodERpZmZ1c2UyLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1cyXFxuI2lmZGVmIFNIQURPV1ZTTTJcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDIsIHNoYWRvd1NhbXBsZXIyKTtcXG4jZWxzZVxcblx0I2lmZGVmIFNIQURPV1BDRjJcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhQQ0YodlBvc2l0aW9uRnJvbUxpZ2h0Miwgc2hhZG93U2FtcGxlcjIpO1xcblx0I2Vsc2VcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQyLCBzaGFkb3dTYW1wbGVyMiwgZGFya25lc3MyKTtcXG5cdCNlbmRpZlx0XFxuI2VuZGlmXHRcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvLmRpZmZ1c2UgKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mby5zcGVjdWxhciAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQzXFxuI2lmZGVmIFNQT1RMSUdIVDNcXG5cdGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMywgdkxpZ2h0RGlyZWN0aW9uMywgdkxpZ2h0RGlmZnVzZTMucmdiLCB2TGlnaHRTcGVjdWxhcjMsIHZMaWdodERpZmZ1c2UzLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQzXFxuXHRpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEzLCB2TGlnaHREaWZmdXNlMy5yZ2IsIHZMaWdodFNwZWN1bGFyMywgdkxpZ2h0R3JvdW5kMyk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQzXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMywgdkxpZ2h0RGlmZnVzZTMucmdiLCB2TGlnaHRTcGVjdWxhcjMsIHZMaWdodERpZmZ1c2UzLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1czXFxuI2lmZGVmIFNIQURPV1ZTTTNcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDMsIHNoYWRvd1NhbXBsZXIzKTtcXG4jZWxzZVxcblx0I2lmZGVmIFNIQURPV1BDRjNcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhQQ0YodlBvc2l0aW9uRnJvbUxpZ2h0Mywgc2hhZG93U2FtcGxlcjMpO1xcblx0I2Vsc2VcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQzLCBzaGFkb3dTYW1wbGVyMywgZGFya25lc3MzKTtcXG5cdCNlbmRpZlx0XFxuI2VuZGlmXHRcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvLmRpZmZ1c2UgKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mby5zcGVjdWxhciAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG5cdC8vIFJlZmxlY3Rpb25cXG5cdHZlYzMgcmVmbGVjdGlvbkNvbG9yID0gdmVjMygwLiwgMC4sIDAuKTtcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcblx0dmVjMyB2UmVmbGVjdGlvblVWVyA9IGNvbXB1dGVSZWZsZWN0aW9uQ29vcmRzKHZSZWZsZWN0aW9uSW5mb3MueCwgdmVjNCh2UG9zaXRpb25XLCAxLjApLCBub3JtYWxXKTtcXG5cXG5cdGlmICh2UmVmbGVjdGlvbkluZm9zLnogIT0gMC4wKVxcblx0e1xcblx0XHRyZWZsZWN0aW9uQ29sb3IgPSB0ZXh0dXJlQ3ViZShyZWZsZWN0aW9uQ3ViZVNhbXBsZXIsIHZSZWZsZWN0aW9uVVZXKS5yZ2IgKiB2UmVmbGVjdGlvbkluZm9zLnkgKiBzaGFkb3c7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZlYzIgY29vcmRzID0gdlJlZmxlY3Rpb25VVlcueHk7XFxuXFxuXHRcdGlmICh2UmVmbGVjdGlvbkluZm9zLnggPT0gTUFQX1BST0pFQ1RJT04pXFxuXHRcdHtcXG5cdFx0XHRjb29yZHMgLz0gdlJlZmxlY3Rpb25VVlcuejtcXG5cdFx0fVxcblxcblx0XHRjb29yZHMueSA9IDEuMCAtIGNvb3Jkcy55O1xcblxcblx0XHRyZWZsZWN0aW9uQ29sb3IgPSB0ZXh0dXJlMkQocmVmbGVjdGlvbjJEU2FtcGxlciwgY29vcmRzKS5yZ2IgKiB2UmVmbGVjdGlvbkluZm9zLnkgKiBzaGFkb3c7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE9QQUNJVFlcXG5cdHZlYzQgb3BhY2l0eU1hcCA9IHRleHR1cmUyRChvcGFjaXR5U2FtcGxlciwgdk9wYWNpdHlVVik7XFxuXFxuI2lmZGVmIE9QQUNJVFlSR0JcXG5cdG9wYWNpdHlNYXAucmdiID0gb3BhY2l0eU1hcC5yZ2IgKiB2ZWMzKDAuMywgMC41OSwgMC4xMSk7XFxuXHRhbHBoYSAqPSAob3BhY2l0eU1hcC54ICsgb3BhY2l0eU1hcC55ICsgb3BhY2l0eU1hcC56KSogdk9wYWNpdHlJbmZvcy55O1xcbiNlbHNlXFxuXHRhbHBoYSAqPSBvcGFjaXR5TWFwLmEgKiB2T3BhY2l0eUluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXFxuI2VuZGlmXFxuXFxuXHQvLyBFbWlzc2l2ZVxcblx0dmVjMyBlbWlzc2l2ZUNvbG9yID0gdkVtaXNzaXZlQ29sb3I7XFxuI2lmZGVmIEVNSVNTSVZFXFxuXHRlbWlzc2l2ZUNvbG9yICs9IHRleHR1cmUyRChlbWlzc2l2ZVNhbXBsZXIsIHZFbWlzc2l2ZVVWKS5yZ2IgKiB2RW1pc3NpdmVJbmZvcy55O1xcbiNlbmRpZlxcblxcblx0Ly8gU3BlY3VsYXIgbWFwXFxuXHR2ZWMzIHNwZWN1bGFyQ29sb3IgPSB2U3BlY3VsYXJDb2xvci5yZ2I7XFxuI2lmZGVmIFNQRUNVTEFSXFxuXHRzcGVjdWxhckNvbG9yID0gdGV4dHVyZTJEKHNwZWN1bGFyU2FtcGxlciwgdlNwZWN1bGFyVVYpLnJnYiAqIHZTcGVjdWxhckluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBDb21wb3NpdGlvblxcblx0dmVjMyBmaW5hbERpZmZ1c2UgPSBjbGFtcChkaWZmdXNlQmFzZSAqIGRpZmZ1c2VDb2xvciArIGVtaXNzaXZlQ29sb3IgKyB2QW1iaWVudENvbG9yLCAwLjAsIDEuMCkgKiBiYXNlQ29sb3IucmdiO1xcblx0dmVjMyBmaW5hbFNwZWN1bGFyID0gc3BlY3VsYXJCYXNlICogc3BlY3VsYXJDb2xvcjtcXG5cXG5cdHZlYzQgY29sb3IgPSB2ZWM0KGZpbmFsRGlmZnVzZSAqIGJhc2VBbWJpZW50Q29sb3IgKyBmaW5hbFNwZWN1bGFyICsgcmVmbGVjdGlvbkNvbG9yLCBhbHBoYSk7XFxuXFxuI2lmZGVmIEZPR1xcblx0ZmxvYXQgZm9nID0gQ2FsY0ZvZ0ZhY3RvcigpO1xcblx0Y29sb3IucmdiID0gZm9nICogY29sb3IucmdiICsgKDEuMCAtIGZvZykgKiB2Rm9nQ29sb3I7XFxuI2VuZGlmXFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XCIsZGVmYXVsdFZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuI2lmZGVmIFVWMVxcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVVjJcXG5hdHRyaWJ1dGUgdmVjMiB1djI7XFxuI2VuZGlmXFxuI2lmZGVmIFZFUlRFWENPTE9SXFxuYXR0cmlidXRlIHZlYzMgY29sb3I7XFxuI2VuZGlmXFxuI2lmZGVmIEJPTkVTXFxuYXR0cmlidXRlIHZlYzQgbWF0cmljZXNJbmRpY2VzO1xcbmF0dHJpYnV0ZSB2ZWM0IG1hdHJpY2VzV2VpZ2h0cztcXG4jZW5kaWZcXG5cXG4vLyBVbmlmb3Jtc1xcblxcbiNpZmRlZiBJTlNUQU5DRVNcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDA7XFxuYXR0cmlidXRlIHZlYzQgd29ybGQxO1xcbmF0dHJpYnV0ZSB2ZWM0IHdvcmxkMjtcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDM7XFxuI2Vsc2VcXG51bmlmb3JtIG1hdDQgd29ybGQ7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qZWN0aW9uO1xcblxcbiNpZmRlZiBESUZGVVNFXFxudmFyeWluZyB2ZWMyIHZEaWZmdXNlVVY7XFxudW5pZm9ybSBtYXQ0IGRpZmZ1c2VNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHZEaWZmdXNlSW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFNQklFTlRcXG52YXJ5aW5nIHZlYzIgdkFtYmllbnRVVjtcXG51bmlmb3JtIG1hdDQgYW1iaWVudE1hdHJpeDtcXG51bmlmb3JtIHZlYzIgdkFtYmllbnRJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVxcbnZhcnlpbmcgdmVjMiB2T3BhY2l0eVVWO1xcbnVuaWZvcm0gbWF0NCBvcGFjaXR5TWF0cml4O1xcbnVuaWZvcm0gdmVjMiB2T3BhY2l0eUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBFTUlTU0lWRVxcbnZhcnlpbmcgdmVjMiB2RW1pc3NpdmVVVjtcXG51bmlmb3JtIHZlYzIgdkVtaXNzaXZlSW5mb3M7XFxudW5pZm9ybSBtYXQ0IGVtaXNzaXZlTWF0cml4O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBTUEVDVUxBUlxcbnZhcnlpbmcgdmVjMiB2U3BlY3VsYXJVVjtcXG51bmlmb3JtIHZlYzIgdlNwZWN1bGFySW5mb3M7XFxudW5pZm9ybSBtYXQ0IHNwZWN1bGFyTWF0cml4O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBCVU1QXFxudmFyeWluZyB2ZWMyIHZCdW1wVVY7XFxudW5pZm9ybSB2ZWMyIHZCdW1wSW5mb3M7XFxudW5pZm9ybSBtYXQ0IGJ1bXBNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJPTkVTXFxudW5pZm9ybSBtYXQ0IG1Cb25lc1tCb25lc1Blck1lc2hdO1xcbiNlbmRpZlxcblxcbi8vIE91dHB1dFxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25XO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsVztcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBDTElQUExBTkVcXG51bmlmb3JtIHZlYzQgdkNsaXBQbGFuZTtcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEZPR1xcbnZhcnlpbmcgZmxvYXQgZkZvZ0Rpc3RhbmNlO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBTSEFET1dTXFxuI2lmZGVmIExJR0hUMFxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDA7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDA7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMVxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDE7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDE7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMlxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDI7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDI7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUM1xcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDM7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDM7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uVVZXO1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXHRtYXQ0IGZpbmFsV29ybGQ7XFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG5cdHZQb3NpdGlvblVWVyA9IHBvc2l0aW9uO1xcbiNlbmRpZiBcXG5cXG4jaWZkZWYgQk9ORVNcXG5cdG1hdDQgbTAgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy54KV0gKiBtYXRyaWNlc1dlaWdodHMueDtcXG5cdG1hdDQgbTEgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy55KV0gKiBtYXRyaWNlc1dlaWdodHMueTtcXG5cdG1hdDQgbTIgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy56KV0gKiBtYXRyaWNlc1dlaWdodHMuejtcXG5cXG4jaWZkZWYgQk9ORVM0XFxuXHRtYXQ0IG0zID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMudyldICogbWF0cmljZXNXZWlnaHRzLnc7XFxuXHRmaW5hbFdvcmxkID0gd29ybGQgKiAobTAgKyBtMSArIG0yICsgbTMpO1xcbiNlbHNlXFxuXHRmaW5hbFdvcmxkID0gd29ybGQgKiAobTAgKyBtMSArIG0yKTtcXG4jZW5kaWYgXFxuXFxuI2Vsc2VcXG4jaWZkZWYgSU5TVEFOQ0VTXFxuXHRmaW5hbFdvcmxkID0gbWF0NCh3b3JsZDAsIHdvcmxkMSwgd29ybGQyLCB3b3JsZDMpO1xcbiNlbHNlXFxuXHRmaW5hbFdvcmxkID0gd29ybGQ7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXHRnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qZWN0aW9uICogZmluYWxXb3JsZCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxuXHR2ZWM0IHdvcmxkUG9zID0gZmluYWxXb3JsZCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXHR2UG9zaXRpb25XID0gdmVjMyh3b3JsZFBvcyk7XFxuXHR2Tm9ybWFsVyA9IG5vcm1hbGl6ZSh2ZWMzKGZpbmFsV29ybGQgKiB2ZWM0KG5vcm1hbCwgMC4wKSkpO1xcblxcblx0Ly8gVGV4dHVyZSBjb29yZGluYXRlc1xcbiNpZm5kZWYgVVYxXFxuXHR2ZWMyIHV2ID0gdmVjMigwLiwgMC4pO1xcbiNlbmRpZlxcbiNpZm5kZWYgVVYyXFxuXHR2ZWMyIHV2MiA9IHZlYzIoMC4sIDAuKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRElGRlVTRVxcblx0aWYgKHZEaWZmdXNlSW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dkRpZmZ1c2VVViA9IHZlYzIoZGlmZnVzZU1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZEaWZmdXNlVVYgPSB2ZWMyKGRpZmZ1c2VNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgQU1CSUVOVFxcblx0aWYgKHZBbWJpZW50SW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dkFtYmllbnRVViA9IHZlYzIoYW1iaWVudE1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZBbWJpZW50VVYgPSB2ZWMyKGFtYmllbnRNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVxcblx0aWYgKHZPcGFjaXR5SW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dk9wYWNpdHlVViA9IHZlYzIob3BhY2l0eU1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZPcGFjaXR5VVYgPSB2ZWMyKG9wYWNpdHlNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgRU1JU1NJVkVcXG5cdGlmICh2RW1pc3NpdmVJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2RW1pc3NpdmVVViA9IHZlYzIoZW1pc3NpdmVNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2RW1pc3NpdmVVViA9IHZlYzIoZW1pc3NpdmVNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgU1BFQ1VMQVJcXG5cdGlmICh2U3BlY3VsYXJJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2U3BlY3VsYXJVViA9IHZlYzIoc3BlY3VsYXJNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2U3BlY3VsYXJVViA9IHZlYzIoc3BlY3VsYXJNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgQlVNUFxcblx0aWYgKHZCdW1wSW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dkJ1bXBVViA9IHZlYzIoYnVtcE1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZCdW1wVVYgPSB2ZWMyKGJ1bXBNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG5cdC8vIENsaXAgcGxhbmVcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHRmQ2xpcERpc3RhbmNlID0gZG90KHdvcmxkUG9zLCB2Q2xpcFBsYW5lKTtcXG4jZW5kaWZcXG5cXG5cdC8vIEZvZ1xcbiNpZmRlZiBGT0dcXG5cdGZGb2dEaXN0YW5jZSA9ICh2aWV3ICogd29ybGRQb3MpLno7XFxuI2VuZGlmXFxuXFxuXHQvLyBTaGFkb3dzXFxuI2lmZGVmIFNIQURPV1NcXG4jaWZkZWYgTElHSFQwXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQwID0gbGlnaHRNYXRyaXgwICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMVxcblx0dlBvc2l0aW9uRnJvbUxpZ2h0MSA9IGxpZ2h0TWF0cml4MSAqIHdvcmxkUG9zO1xcbiNlbmRpZlxcbiNpZmRlZiBMSUdIVDJcXG5cdHZQb3NpdGlvbkZyb21MaWdodDIgPSBsaWdodE1hdHJpeDIgKiB3b3JsZFBvcztcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQzXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQzID0gbGlnaHRNYXRyaXgzICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuXHQvLyBWZXJ0ZXggY29sb3JcXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5cdHZDb2xvciA9IGNvbG9yO1xcbiNlbmRpZlxcbn1cIixkaXNwbGF5UGFzc1BpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHBhc3NTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHBhc3NTYW1wbGVyLCB2VVYpO1xcbn1cIixmaWx0ZXJQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG5cXG51bmlmb3JtIG1hdDQga2VybmVsTWF0cml4O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG5cdHZlYzMgYmFzZUNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYpLnJnYjtcXG5cdHZlYzMgdXBkYXRlZENvbG9yID0gKGtlcm5lbE1hdHJpeCAqIHZlYzQoYmFzZUNvbG9yLCAxLjApKS5yZ2I7XFxuXFxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVwZGF0ZWRDb2xvciwgMS4wKTtcXG59XCIsZnhhYVBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLzEyOC4wKVxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMC84LjApXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG5cXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxuXFxudm9pZCBtYWluKCl7XFxuXHR2ZWMyIGxvY2FsVGV4ZWxTaXplID0gdGV4ZWxTaXplO1xcblx0dmVjNCByZ2JOVyA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgKHZVViArIHZlYzIoLTEuMCwgLTEuMCkgKiBsb2NhbFRleGVsU2l6ZSkpO1xcblx0dmVjNCByZ2JORSA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgKHZVViArIHZlYzIoMS4wLCAtMS4wKSAqIGxvY2FsVGV4ZWxTaXplKSk7XFxuXHR2ZWM0IHJnYlNXID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCAodlVWICsgdmVjMigtMS4wLCAxLjApICogbG9jYWxUZXhlbFNpemUpKTtcXG5cdHZlYzQgcmdiU0UgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsICh2VVYgKyB2ZWMyKDEuMCwgMS4wKSAqIGxvY2FsVGV4ZWxTaXplKSk7XFxuXHR2ZWM0IHJnYk0gPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVik7XFxuXHR2ZWM0IGx1bWEgPSB2ZWM0KDAuMjk5LCAwLjU4NywgMC4xMTQsIDEuMCk7XFxuXHRmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xcblx0ZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG5cdGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuXHRmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xcblx0ZmxvYXQgbHVtYU0gPSBkb3QocmdiTSwgbHVtYSk7XFxuXHRmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xcblx0ZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG5cdHZlYzIgZGlyID0gdmVjMigtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpLCAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSkpO1xcblxcblx0ZmxvYXQgZGlyUmVkdWNlID0gbWF4KFxcblx0XHQobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSxcXG5cdFx0RlhBQV9SRURVQ0VfTUlOKTtcXG5cXG5cdGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcblx0ZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuXHRcdG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksXFxuXHRcdGRpciAqIHJjcERpck1pbikpICogbG9jYWxUZXhlbFNpemU7XFxuXFxuXHR2ZWM0IHJnYkEgPSAwLjUgKiAoXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkpO1xcblxcblx0dmVjNCByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAoXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgZGlyICogIC0wLjUpICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBkaXIgKiAwLjUpKTtcXG5cdGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcblx0aWYgKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKSB7XFxuXHRcdGdsX0ZyYWdDb2xvciA9IHJnYkE7XFxuXHR9XFxuXHRlbHNlIHtcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gcmdiQjtcXG5cdH1cXG59XCIsbGF5ZXJQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG5cXG4vLyBDb2xvclxcbnVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0dmVjNCBiYXNlQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVik7XFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBiYXNlQ29sb3IgKiBjb2xvcjtcXG59XCIsbGF5ZXJWZXJ0ZXhTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBBdHRyaWJ1dGVzXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxuLy8gVW5pZm9ybXNcXG51bmlmb3JtIG1hdDQgdGV4dHVyZU1hdHJpeDtcXG5cXG4vLyBPdXRwdXRcXG52YXJ5aW5nIHZlYzIgdlVWO1xcblxcbmNvbnN0IHZlYzIgbWFkZCA9IHZlYzIoMC41LCAwLjUpO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XHRcXG5cXG5cdHZVViA9IHZlYzIodGV4dHVyZU1hdHJpeCAqIHZlYzQocG9zaXRpb24gKiBtYWRkICsgbWFkZCwgMS4wLCAwLjApKTtcXG5cdGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xcbn1cIixsZWdhY3lkZWZhdWx0UGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4jZGVmaW5lIE1BUF9QUk9KRUNUSU9OXHQ0Llxcblxcbi8vIENvbnN0YW50c1xcbnVuaWZvcm0gdmVjMyB2RXllUG9zaXRpb247XFxudW5pZm9ybSB2ZWMzIHZBbWJpZW50Q29sb3I7XFxudW5pZm9ybSB2ZWM0IHZEaWZmdXNlQ29sb3I7XFxudW5pZm9ybSB2ZWM0IHZTcGVjdWxhckNvbG9yO1xcbnVuaWZvcm0gdmVjMyB2RW1pc3NpdmVDb2xvcjtcXG5cXG4vLyBJbnB1dFxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25XO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsVztcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblxcbi8vIExpZ2h0c1xcbiNpZmRlZiBMSUdIVDBcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTA7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UwO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjA7XFxuI2lmZGVmIFNIQURPVzBcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MDtcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMDtcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUMFxcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24wO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQwXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDA7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUMVxcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMTtcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTE7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMTtcXG4jaWZkZWYgU0hBRE9XMVxcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQxO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIxO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQxXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjE7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDFcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMTtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQyXFxudW5pZm9ybSB2ZWM0IHZMaWdodERhdGEyO1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaWZmdXNlMjtcXG51bmlmb3JtIHZlYzMgdkxpZ2h0U3BlY3VsYXIyO1xcbiNpZmRlZiBTSEFET1cyXFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDI7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcjI7XFxuI2VuZGlmXFxuI2lmZGVmIFNQT1RMSUdIVDJcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlyZWN0aW9uMjtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMlxcbnVuaWZvcm0gdmVjMyB2TGlnaHRHcm91bmQyO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDNcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTM7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UzO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjM7XFxuI2lmZGVmIFNIQURPVzNcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MztcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMztcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUM1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24zO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQzXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDM7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG4jaWZkZWYgRElGRlVTRVxcbnZhcnlpbmcgdmVjMiB2RGlmZnVzZVVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB2RGlmZnVzZUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTUJJRU5UXFxudmFyeWluZyB2ZWMyIHZBbWJpZW50VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgYW1iaWVudFNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZBbWJpZW50SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE9QQUNJVFlcdFxcbnZhcnlpbmcgdmVjMiB2T3BhY2l0eVVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG9wYWNpdHlTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB2T3BhY2l0eUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBSRUZMRUNUSU9OXFxudmFyeWluZyB2ZWMzIHZSZWZsZWN0aW9uVVZXO1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgcmVmbGVjdGlvbkN1YmVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHJlZmxlY3Rpb24yRFNhbXBsZXI7XFxudW5pZm9ybSB2ZWMzIHZSZWZsZWN0aW9uSW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEVNSVNTSVZFXFxudmFyeWluZyB2ZWMyIHZFbWlzc2l2ZVVWO1xcbnVuaWZvcm0gdmVjMiB2RW1pc3NpdmVJbmZvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZVNhbXBsZXI7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNQRUNVTEFSXFxudmFyeWluZyB2ZWMyIHZTcGVjdWxhclVWO1xcbnVuaWZvcm0gdmVjMiB2U3BlY3VsYXJJbmZvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhclNhbXBsZXI7XFxuI2VuZGlmXFxuXFxuLy8gU2hhZG93c1xcbiNpZmRlZiBTSEFET1dTXFxuXFxuZmxvYXQgdW5wYWNrKHZlYzQgY29sb3IpXFxue1xcblx0Y29uc3QgdmVjNCBiaXRTaGlmdCA9IHZlYzQoMS4gLyAoMjU1LiAqIDI1NS4gKiAyNTUuKSwgMS4gLyAoMjU1LiAqIDI1NS4pLCAxLiAvIDI1NS4sIDEuKTtcXG5cdHJldHVybiBkb3QoY29sb3IsIGJpdFNoaWZ0KTtcXG59XFxuXFxuZmxvYXQgdW5wYWNrSGFsZih2ZWMyIGNvbG9yKVxcbntcXG5cdHJldHVybiBjb2xvci54ICsgKGNvbG9yLnkgLyAyNTUuMCk7XFxufVxcblxcbmZsb2F0IGNvbXB1dGVTaGFkb3codmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyKVxcbntcXG5cdHZlYzMgZGVwdGggPSB2UG9zaXRpb25Gcm9tTGlnaHQueHl6IC8gdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7XFxuXHR2ZWMyIHV2ID0gMC41ICogZGVwdGgueHkgKyB2ZWMyKDAuNSwgMC41KTtcXG5cXG5cdGlmICh1di54IDwgMC4gfHwgdXYueCA+IDEuMCB8fCB1di55IDwgMC4gfHwgdXYueSA+IDEuMClcXG5cdHtcXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cXG5cdGZsb2F0IHNoYWRvdyA9IHVucGFjayh0ZXh0dXJlMkQoc2hhZG93U2FtcGxlciwgdXYpKTtcXG5cXG5cdGlmIChkZXB0aC56ID4gc2hhZG93KVxcblx0e1xcblx0XHRyZXR1cm4gMC47XFxuXHR9XFxuXHRyZXR1cm4gMS47XFxufVxcblxcbi8vIFRoYW5rcyB0byBodHRwOi8vZGV2bWFzdGVyLm5ldC9cXG5mbG9hdCBDaGVieWNoZXZJbmVxdWFsaXR5KHZlYzIgbW9tZW50cywgZmxvYXQgdClcXG57XFxuXHRpZiAodCA8PSBtb21lbnRzLngpXFxuXHR7XFxuXHRcdHJldHVybiAxLjA7XFxuXHR9XFxuXFxuXHRmbG9hdCB2YXJpYW5jZSA9IG1vbWVudHMueSAtIChtb21lbnRzLnggKiBtb21lbnRzLngpO1xcblx0dmFyaWFuY2UgPSBtYXgodmFyaWFuY2UsIDAuKTtcXG5cXG5cdGZsb2F0IGQgPSB0IC0gbW9tZW50cy54O1xcblx0cmV0dXJuIHZhcmlhbmNlIC8gKHZhcmlhbmNlICsgZCAqIGQpO1xcbn1cXG5cXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aFZTTSh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCwgc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIpXFxue1xcblx0dmVjMyBkZXB0aCA9IHZQb3NpdGlvbkZyb21MaWdodC54eXogLyB2UG9zaXRpb25Gcm9tTGlnaHQudztcXG5cdHZlYzIgdXYgPSAwLjUgKiBkZXB0aC54eSArIHZlYzIoMC41LCAwLjUpO1xcblxcblx0aWYgKHV2LnggPCAwLiB8fCB1di54ID4gMS4wIHx8IHV2LnkgPCAwLiB8fCB1di55ID4gMS4wKVxcblx0e1xcblx0XHRyZXR1cm4gMS4wO1xcblx0fVxcblxcblx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRChzaGFkb3dTYW1wbGVyLCB1dik7XFxuXFxuXHR2ZWMyIG1vbWVudHMgPSB2ZWMyKHVucGFja0hhbGYodGV4ZWwueHkpLCB1bnBhY2tIYWxmKHRleGVsLnp3KSk7XFxuXHRyZXR1cm4gY2xhbXAoMS4zIC0gQ2hlYnljaGV2SW5lcXVhbGl0eShtb21lbnRzLCBkZXB0aC56KSwgMC4sIDEuMCk7XFxufVxcbiNlbmRpZlxcblxcbiNpZmRlZiBDTElQUExBTkVcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuLy8gRm9nXFxuI2lmZGVmIEZPR1xcblxcbiNkZWZpbmUgRk9HTU9ERV9OT05FICAgIDAuXFxuI2RlZmluZSBGT0dNT0RFX0VYUCAgICAgMS5cXG4jZGVmaW5lIEZPR01PREVfRVhQMiAgICAyLlxcbiNkZWZpbmUgRk9HTU9ERV9MSU5FQVIgIDMuXFxuI2RlZmluZSBFIDIuNzE4MjhcXG5cXG51bmlmb3JtIHZlYzQgdkZvZ0luZm9zO1xcbnVuaWZvcm0gdmVjMyB2Rm9nQ29sb3I7XFxudmFyeWluZyBmbG9hdCBmRm9nRGlzdGFuY2U7XFxuXFxuZmxvYXQgQ2FsY0ZvZ0ZhY3RvcigpXFxue1xcblx0ZmxvYXQgZm9nQ29lZmYgPSAxLjA7XFxuXHRmbG9hdCBmb2dTdGFydCA9IHZGb2dJbmZvcy55O1xcblx0ZmxvYXQgZm9nRW5kID0gdkZvZ0luZm9zLno7XFxuXHRmbG9hdCBmb2dEZW5zaXR5ID0gdkZvZ0luZm9zLnc7XFxuXFxuXHRpZiAoRk9HTU9ERV9MSU5FQVIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gKGZvZ0VuZCAtIGZGb2dEaXN0YW5jZSkgLyAoZm9nRW5kIC0gZm9nU3RhcnQpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAyID09IHZGb2dJbmZvcy54KVxcblx0e1xcblx0XHRmb2dDb2VmZiA9IDEuMCAvIHBvdyhFLCBmRm9nRGlzdGFuY2UgKiBmRm9nRGlzdGFuY2UgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXFxuXHRyZXR1cm4gY2xhbXAoZm9nQ29lZmYsIDAuMCwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXFxuLy8gTGlnaHQgQ29tcHV0aW5nXFxubWF0MyBjb21wdXRlTGlnaHRpbmcodmVjMyB2aWV3RGlyZWN0aW9uVywgdmVjMyB2Tm9ybWFsLCB2ZWM0IGxpZ2h0RGF0YSwgdmVjNCBkaWZmdXNlQ29sb3IsIHZlYzMgc3BlY3VsYXJDb2xvcikge1xcblx0bWF0MyByZXN1bHQ7XFxuXFxuXHR2ZWMzIGxpZ2h0VmVjdG9yVztcXG5cdGlmIChsaWdodERhdGEudyA9PSAwLilcXG5cdHtcXG5cdFx0bGlnaHRWZWN0b3JXID0gbm9ybWFsaXplKGxpZ2h0RGF0YS54eXogLSB2UG9zaXRpb25XKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0bGlnaHRWZWN0b3JXID0gbm9ybWFsaXplKC1saWdodERhdGEueHl6KTtcXG5cdH1cXG5cXG5cdC8vIGRpZmZ1c2VcXG5cdGZsb2F0IG5kbCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGxpZ2h0VmVjdG9yVykpO1xcblxcblx0Ly8gU3BlY3VsYXJcXG5cdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XICsgbGlnaHRWZWN0b3JXKTtcXG5cdGZsb2F0IHNwZWNDb21wID0gbWF4KDAuLCBkb3Qodk5vcm1hbCwgYW5nbGVXKSk7XFxuXHRzcGVjQ29tcCA9IG1heCgwLiwgcG93KHNwZWNDb21wLCBtYXgoMS4wLCB2U3BlY3VsYXJDb2xvci5hKSkpO1xcblxcblx0cmVzdWx0WzBdID0gbmRsICogZGlmZnVzZUNvbG9yLnJnYjtcXG5cdHJlc3VsdFsxXSA9IHNwZWNDb21wICogc3BlY3VsYXJDb2xvcjtcXG5cdHJlc3VsdFsyXSA9IHZlYzMoMC4pO1xcblxcblx0cmV0dXJuIHJlc3VsdDtcXG59XFxuXFxubWF0MyBjb21wdXRlU3BvdExpZ2h0aW5nKHZlYzMgdmlld0RpcmVjdGlvblcsIHZlYzMgdk5vcm1hbCwgdmVjNCBsaWdodERhdGEsIHZlYzQgbGlnaHREaXJlY3Rpb24sIHZlYzQgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IpIHtcXG5cdG1hdDMgcmVzdWx0O1xcblxcblx0dmVjMyBsaWdodFZlY3RvclcgPSBub3JtYWxpemUobGlnaHREYXRhLnh5eiAtIHZQb3NpdGlvblcpO1xcblxcblx0Ly8gZGlmZnVzZVxcblx0ZmxvYXQgY29zQW5nbGUgPSBtYXgoMC4sIGRvdCgtbGlnaHREaXJlY3Rpb24ueHl6LCBsaWdodFZlY3RvclcpKTtcXG5cdGZsb2F0IHNwb3RBdHRlbiA9IDAuMDtcXG5cXG5cdGlmIChjb3NBbmdsZSA+PSBsaWdodERpcmVjdGlvbi53KVxcblx0e1xcblx0XHRjb3NBbmdsZSA9IG1heCgwLiwgcG93KGNvc0FuZ2xlLCBsaWdodERhdGEudykpO1xcblx0XHRzcG90QXR0ZW4gPSBtYXgoMC4sIChjb3NBbmdsZSAtIGxpZ2h0RGlyZWN0aW9uLncpIC8gKDEuIC0gY29zQW5nbGUpKTtcXG5cXG5cdFx0Ly8gRGlmZnVzZVxcblx0XHRmbG9hdCBuZGwgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCAtbGlnaHREaXJlY3Rpb24ueHl6KSk7XFxuXFxuXHRcdC8vIFNwZWN1bGFyXFxuXHRcdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XIC0gbGlnaHREaXJlY3Rpb24ueHl6KTtcXG5cdFx0ZmxvYXQgc3BlY0NvbXAgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCBhbmdsZVcpKTtcXG5cdFx0c3BlY0NvbXAgPSBwb3coc3BlY0NvbXAsIHZTcGVjdWxhckNvbG9yLmEpO1xcblxcblx0XHRyZXN1bHRbMF0gPSBuZGwgKiBzcG90QXR0ZW4gKiBkaWZmdXNlQ29sb3IucmdiO1xcblx0XHRyZXN1bHRbMV0gPSBzcGVjQ29tcCAqIHNwZWN1bGFyQ29sb3IgKiBzcG90QXR0ZW47XFxuXHRcdHJlc3VsdFsyXSA9IHZlYzMoMC4pO1xcblxcblx0XHRyZXR1cm4gcmVzdWx0O1xcblx0fVxcblxcblx0cmVzdWx0WzBdID0gdmVjMygwLik7XFxuXHRyZXN1bHRbMV0gPSB2ZWMzKDAuKTtcXG5cdHJlc3VsdFsyXSA9IHZlYzMoMC4pO1xcblxcblx0cmV0dXJuIHJlc3VsdDtcXG59XFxuXFxubWF0MyBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2ZWMzIHZpZXdEaXJlY3Rpb25XLCB2ZWMzIHZOb3JtYWwsIHZlYzQgbGlnaHREYXRhLCB2ZWM0IGRpZmZ1c2VDb2xvciwgdmVjMyBzcGVjdWxhckNvbG9yLCB2ZWMzIGdyb3VuZENvbG9yKSB7XFxuXHRtYXQzIHJlc3VsdDtcXG5cXG5cdC8vIERpZmZ1c2VcXG5cdGZsb2F0IG5kbCA9IGRvdCh2Tm9ybWFsLCBsaWdodERhdGEueHl6KSAqIDAuNSArIDAuNTtcXG5cXG5cdC8vIFNwZWN1bGFyXFxuXHR2ZWMzIGFuZ2xlVyA9IG5vcm1hbGl6ZSh2aWV3RGlyZWN0aW9uVyArIGxpZ2h0RGF0YS54eXopO1xcblx0ZmxvYXQgc3BlY0NvbXAgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCBhbmdsZVcpKTtcXG5cdHNwZWNDb21wID0gcG93KHNwZWNDb21wLCB2U3BlY3VsYXJDb2xvci5hKTtcXG5cXG5cdHJlc3VsdFswXSA9IG1peChncm91bmRDb2xvciwgZGlmZnVzZUNvbG9yLnJnYiwgbmRsKTtcXG5cdHJlc3VsdFsxXSA9IHNwZWNDb21wICogc3BlY3VsYXJDb2xvcjtcXG5cdHJlc3VsdFsyXSA9IHZlYzMoMC4pO1xcblxcblx0cmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdC8vIENsaXAgcGxhbmVcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHRpZiAoZkNsaXBEaXN0YW5jZSA+IDAuMClcXG5cdFx0ZGlzY2FyZDtcXG4jZW5kaWZcXG5cXG5cdHZlYzMgdmlld0RpcmVjdGlvblcgPSBub3JtYWxpemUodkV5ZVBvc2l0aW9uIC0gdlBvc2l0aW9uVyk7XFxuXFxuXHQvLyBCYXNlIGNvbG9yXFxuXHR2ZWM0IGJhc2VDb2xvciA9IHZlYzQoMS4sIDEuLCAxLiwgMS4pO1xcblx0dmVjMyBkaWZmdXNlQ29sb3IgPSB2RGlmZnVzZUNvbG9yLnJnYjtcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5cdGRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIERJRkZVU0VcXG5cdGJhc2VDb2xvciA9IHRleHR1cmUyRChkaWZmdXNlU2FtcGxlciwgdkRpZmZ1c2VVVik7XFxuXFxuI2lmZGVmIEFMUEhBVEVTVFxcblx0aWYgKGJhc2VDb2xvci5hIDwgMC40KVxcblx0XHRkaXNjYXJkO1xcbiNlbmRpZlxcblxcblx0YmFzZUNvbG9yLnJnYiAqPSB2RGlmZnVzZUluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBCdW1wXFxuXHR2ZWMzIG5vcm1hbFcgPSBub3JtYWxpemUodk5vcm1hbFcpO1xcblxcblx0Ly8gQW1iaWVudCBjb2xvclxcblx0dmVjMyBiYXNlQW1iaWVudENvbG9yID0gdmVjMygxLiwgMS4sIDEuKTtcXG5cXG4jaWZkZWYgQU1CSUVOVFxcblx0YmFzZUFtYmllbnRDb2xvciA9IHRleHR1cmUyRChhbWJpZW50U2FtcGxlciwgdkFtYmllbnRVVikucmdiICogdkFtYmllbnRJbmZvcy55O1xcbiNlbmRpZlxcblxcblx0Ly8gTGlnaHRpbmdcXG5cdHZlYzMgZGlmZnVzZUJhc2UgPSB2ZWMzKDAuLCAwLiwgMC4pO1xcblx0dmVjMyBzcGVjdWxhckJhc2UgPSB2ZWMzKDAuLCAwLiwgMC4pO1xcblx0ZmxvYXQgc2hhZG93ID0gMS47XFxuXFxuI2lmZGVmIExJR0hUMFxcbiNpZmRlZiBTUE9UTElHSFQwXFxuXHRtYXQzIGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMCwgdkxpZ2h0RGlyZWN0aW9uMCwgdkxpZ2h0RGlmZnVzZTAsIHZMaWdodFNwZWN1bGFyMCk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDBcXG5cdG1hdDMgaW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMCwgdkxpZ2h0RGlmZnVzZTAsIHZMaWdodFNwZWN1bGFyMCwgdkxpZ2h0R3JvdW5kMCk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQwXFxuXHRtYXQzIGluZm8gPSBjb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaWZmdXNlMCwgdkxpZ2h0U3BlY3VsYXIwKTtcXG4jZW5kaWZcXG4jaWZkZWYgU0hBRE9XMFxcbiNpZmRlZiBTSEFET1dWU00wXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFZTTSh2UG9zaXRpb25Gcm9tTGlnaHQwLCBzaGFkb3dTYW1wbGVyMCk7XFxuI2Vsc2VcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3codlBvc2l0aW9uRnJvbUxpZ2h0MCwgc2hhZG93U2FtcGxlcjApO1xcbiNlbmRpZlxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm9bMF0gKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mb1sxXSAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQxXFxuI2lmZGVmIFNQT1RMSUdIVDFcXG5cdGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlyZWN0aW9uMSwgdkxpZ2h0RGlmZnVzZTEsIHZMaWdodFNwZWN1bGFyMSk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDFcXG5cdGluZm8gPSBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTEsIHZMaWdodERpZmZ1c2UxLCB2TGlnaHRTcGVjdWxhcjEsIHZMaWdodEdyb3VuZDEpO1xcbiNlbmRpZlxcbiNpZmRlZiBQT0lOVERJUkxJR0hUMVxcblx0aW5mbyA9IGNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTEsIHZMaWdodERpZmZ1c2UxLCB2TGlnaHRTcGVjdWxhcjEpO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1cxXFxuI2lmZGVmIFNIQURPV1ZTTTFcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDEsIHNoYWRvd1NhbXBsZXIxKTtcXG4jZWxzZVxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQxLCBzaGFkb3dTYW1wbGVyMSk7XFxuI2VuZGlmXFxuI2Vsc2VcXG5cdHNoYWRvdyA9IDEuO1xcbiNlbmRpZlxcblx0ZGlmZnVzZUJhc2UgKz0gaW5mb1swXSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvWzFdICogc2hhZG93O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDJcXG4jaWZkZWYgU1BPVExJR0hUMlxcblx0aW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaXJlY3Rpb24yLCB2TGlnaHREaWZmdXNlMiwgdkxpZ2h0U3BlY3VsYXIyKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMlxcblx0aW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMiwgdkxpZ2h0RGlmZnVzZTIsIHZMaWdodFNwZWN1bGFyMiwgdkxpZ2h0R3JvdW5kMik7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQyXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMiwgdkxpZ2h0RGlmZnVzZTIsIHZMaWdodFNwZWN1bGFyMik7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzJcXG4jaWZkZWYgU0hBRE9XVlNNMlxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0Miwgc2hhZG93U2FtcGxlcjIpO1xcbiNlbHNlXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDIsIHNoYWRvd1NhbXBsZXIyKTtcXG4jZW5kaWZcdFxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm9bMF0gKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mb1sxXSAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQzXFxuI2lmZGVmIFNQT1RMSUdIVDNcXG5cdGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMywgdkxpZ2h0RGlyZWN0aW9uMywgdkxpZ2h0RGlmZnVzZTMsIHZMaWdodFNwZWN1bGFyMyk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDNcXG5cdGluZm8gPSBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTMsIHZMaWdodERpZmZ1c2UzLCB2TGlnaHRTcGVjdWxhcjMsIHZMaWdodEdyb3VuZDMpO1xcbiNlbmRpZlxcbiNpZmRlZiBQT0lOVERJUkxJR0hUM1xcblx0aW5mbyA9IGNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTMsIHZMaWdodERpZmZ1c2UzLCB2TGlnaHRTcGVjdWxhcjMpO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1czXFxuI2lmZGVmIFNIQURPV1ZTTTNcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDMsIHNoYWRvd1NhbXBsZXIzKTtcXG4jZWxzZVxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQzLCBzaGFkb3dTYW1wbGVyMyk7XFxuI2VuZGlmXHRcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvWzBdICogc2hhZG93O1xcblx0c3BlY3VsYXJCYXNlICs9IGluZm9bMV0gKiBzaGFkb3c7XFxuI2VuZGlmXFxuXFxuXHQvLyBSZWZsZWN0aW9uXFxuXHR2ZWMzIHJlZmxlY3Rpb25Db2xvciA9IHZlYzMoMC4sIDAuLCAwLik7XFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG5cdGlmICh2UmVmbGVjdGlvbkluZm9zLnogIT0gMC4wKVxcblx0e1xcblx0XHRyZWZsZWN0aW9uQ29sb3IgPSB0ZXh0dXJlQ3ViZShyZWZsZWN0aW9uQ3ViZVNhbXBsZXIsIHZSZWZsZWN0aW9uVVZXKS5yZ2IgKiB2UmVmbGVjdGlvbkluZm9zLnk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZlYzIgY29vcmRzID0gdlJlZmxlY3Rpb25VVlcueHk7XFxuXFxuXHRcdGlmICh2UmVmbGVjdGlvbkluZm9zLnggPT0gTUFQX1BST0pFQ1RJT04pXFxuXHRcdHtcXG5cdFx0XHRjb29yZHMgLz0gdlJlZmxlY3Rpb25VVlcuejtcXG5cdFx0fVxcblxcblx0XHRjb29yZHMueSA9IDEuMCAtIGNvb3Jkcy55O1xcblxcblx0XHRyZWZsZWN0aW9uQ29sb3IgPSB0ZXh0dXJlMkQocmVmbGVjdGlvbjJEU2FtcGxlciwgY29vcmRzKS5yZ2IgKiB2UmVmbGVjdGlvbkluZm9zLnk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuXHQvLyBBbHBoYVxcblx0ZmxvYXQgYWxwaGEgPSB2RGlmZnVzZUNvbG9yLmE7XFxuXFxuI2lmZGVmIE9QQUNJVFlcXG5cdHZlYzQgb3BhY2l0eU1hcCA9IHRleHR1cmUyRChvcGFjaXR5U2FtcGxlciwgdk9wYWNpdHlVVik7XFxuI2lmZGVmIE9QQUNJVFlSR0JcXG5cdG9wYWNpdHlNYXAucmdiID0gb3BhY2l0eU1hcC5yZ2IgKiB2ZWMzKDAuMywgMC41OSwgMC4xMSk7XFxuXHRhbHBoYSAqPSAob3BhY2l0eU1hcC54ICsgb3BhY2l0eU1hcC55ICsgb3BhY2l0eU1hcC56KSogdk9wYWNpdHlJbmZvcy55O1xcbiNlbHNlXFxuXHRhbHBoYSAqPSBvcGFjaXR5TWFwLmEgKiB2T3BhY2l0eUluZm9zLnk7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuXHQvLyBFbWlzc2l2ZVxcblx0dmVjMyBlbWlzc2l2ZUNvbG9yID0gdkVtaXNzaXZlQ29sb3I7XFxuI2lmZGVmIEVNSVNTSVZFXFxuXHRlbWlzc2l2ZUNvbG9yICs9IHRleHR1cmUyRChlbWlzc2l2ZVNhbXBsZXIsIHZFbWlzc2l2ZVVWKS5yZ2IgKiB2RW1pc3NpdmVJbmZvcy55O1xcbiNlbmRpZlxcblxcblx0Ly8gU3BlY3VsYXIgbWFwXFxuXHR2ZWMzIHNwZWN1bGFyQ29sb3IgPSB2U3BlY3VsYXJDb2xvci5yZ2I7XFxuI2lmZGVmIFNQRUNVTEFSXFxuXHRzcGVjdWxhckNvbG9yID0gdGV4dHVyZTJEKHNwZWN1bGFyU2FtcGxlciwgdlNwZWN1bGFyVVYpLnJnYiAqIHZTcGVjdWxhckluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBDb21wb3NpdGlvblxcblx0dmVjMyBmaW5hbERpZmZ1c2UgPSBjbGFtcChkaWZmdXNlQmFzZSAqIGRpZmZ1c2VDb2xvciArIGVtaXNzaXZlQ29sb3IgKyB2QW1iaWVudENvbG9yLCAwLjAsIDEuMCkgKiBiYXNlQ29sb3IucmdiO1xcblx0dmVjMyBmaW5hbFNwZWN1bGFyID0gc3BlY3VsYXJCYXNlICogc3BlY3VsYXJDb2xvcjtcXG5cXG5cdHZlYzQgY29sb3IgPSB2ZWM0KGZpbmFsRGlmZnVzZSAqIGJhc2VBbWJpZW50Q29sb3IgKyBmaW5hbFNwZWN1bGFyICsgcmVmbGVjdGlvbkNvbG9yLCBhbHBoYSk7XFxuXFxuI2lmZGVmIEZPR1xcblx0ZmxvYXQgZm9nID0gQ2FsY0ZvZ0ZhY3RvcigpO1xcblx0Y29sb3IucmdiID0gZm9nICogY29sb3IucmdiICsgKDEuMCAtIGZvZykgKiB2Rm9nQ29sb3I7XFxuI2VuZGlmXFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XCIsbGVnYWN5ZGVmYXVsdFZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbiNkZWZpbmUgTUFQX0VYUExJQ0lUXHQwLlxcbiNkZWZpbmUgTUFQX1NQSEVSSUNBTFx0MS5cXG4jZGVmaW5lIE1BUF9QTEFOQVJcdFx0Mi5cXG4jZGVmaW5lIE1BUF9DVUJJQ1x0XHQzLlxcbiNkZWZpbmUgTUFQX1BST0pFQ1RJT05cdDQuXFxuI2RlZmluZSBNQVBfU0tZQk9YXHRcdDUuXFxuXFxuLy8gQXR0cmlidXRlc1xcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG4jaWZkZWYgVVYxXFxuYXR0cmlidXRlIHZlYzIgdXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVWMlxcbmF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG4jZW5kaWZcXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5hdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgQk9ORVNcXG5hdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc0luZGljZXM7XFxuYXR0cmlidXRlIHZlYzQgbWF0cmljZXNXZWlnaHRzO1xcbiNlbmRpZlxcblxcbi8vIFVuaWZvcm1zXFxudW5pZm9ybSBtYXQ0IHdvcmxkO1xcbnVuaWZvcm0gbWF0NCB2aWV3O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvamVjdGlvbjtcXG5cXG4jaWZkZWYgRElGRlVTRVxcbnZhcnlpbmcgdmVjMiB2RGlmZnVzZVVWO1xcbnVuaWZvcm0gbWF0NCBkaWZmdXNlTWF0cml4O1xcbnVuaWZvcm0gdmVjMiB2RGlmZnVzZUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTUJJRU5UXFxudmFyeWluZyB2ZWMyIHZBbWJpZW50VVY7XFxudW5pZm9ybSBtYXQ0IGFtYmllbnRNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHZBbWJpZW50SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE9QQUNJVFlcXG52YXJ5aW5nIHZlYzIgdk9wYWNpdHlVVjtcXG51bmlmb3JtIG1hdDQgb3BhY2l0eU1hdHJpeDtcXG51bmlmb3JtIHZlYzIgdk9wYWNpdHlJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcbnVuaWZvcm0gdmVjMyB2RXllUG9zaXRpb247XFxudmFyeWluZyB2ZWMzIHZSZWZsZWN0aW9uVVZXO1xcbnVuaWZvcm0gdmVjMyB2UmVmbGVjdGlvbkluZm9zO1xcbnVuaWZvcm0gbWF0NCByZWZsZWN0aW9uTWF0cml4O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBFTUlTU0lWRVxcbnZhcnlpbmcgdmVjMiB2RW1pc3NpdmVVVjtcXG51bmlmb3JtIHZlYzIgdkVtaXNzaXZlSW5mb3M7XFxudW5pZm9ybSBtYXQ0IGVtaXNzaXZlTWF0cml4O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBTUEVDVUxBUlxcbnZhcnlpbmcgdmVjMiB2U3BlY3VsYXJVVjtcXG51bmlmb3JtIHZlYzIgdlNwZWN1bGFySW5mb3M7XFxudW5pZm9ybSBtYXQ0IHNwZWN1bGFyTWF0cml4O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBCVU1QXFxudmFyeWluZyB2ZWMyIHZCdW1wVVY7XFxudW5pZm9ybSB2ZWMyIHZCdW1wSW5mb3M7XFxudW5pZm9ybSBtYXQ0IGJ1bXBNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJPTkVTXFxudW5pZm9ybSBtYXQ0IG1Cb25lc1tCb25lc1Blck1lc2hdO1xcbiNlbmRpZlxcblxcbi8vIE91dHB1dFxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25XO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsVztcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBDTElQUExBTkVcXG51bmlmb3JtIHZlYzQgdkNsaXBQbGFuZTtcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEZPR1xcbnZhcnlpbmcgZmxvYXQgZkZvZ0Rpc3RhbmNlO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBTSEFET1dTXFxuI2lmZGVmIExJR0hUMFxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDA7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDA7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMVxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDE7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDE7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMlxcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDI7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDI7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUM1xcbnVuaWZvcm0gbWF0NCBsaWdodE1hdHJpeDM7XFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDM7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG52ZWMzIGNvbXB1dGVSZWZsZWN0aW9uQ29vcmRzKGZsb2F0IG1vZGUsIHZlYzQgd29ybGRQb3MsIHZlYzMgd29ybGROb3JtYWwpXFxue1xcblx0aWYgKG1vZGUgPT0gTUFQX1NQSEVSSUNBTClcXG5cdHtcXG5cdFx0dmVjMyBjb29yZHMgPSB2ZWMzKHZpZXcgKiB2ZWM0KHdvcmxkTm9ybWFsLCAwLjApKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAxLjApKTtcXG5cdH1cXG5cdGVsc2UgaWYgKG1vZGUgPT0gTUFQX1BMQU5BUilcXG5cdHtcXG5cdFx0dmVjMyB2aWV3RGlyID0gd29ybGRQb3MueHl6IC0gdkV5ZVBvc2l0aW9uO1xcblx0XHR2ZWMzIGNvb3JkcyA9IG5vcm1hbGl6ZShyZWZsZWN0KHZpZXdEaXIsIHdvcmxkTm9ybWFsKSk7XFxuXFxuXHRcdHJldHVybiB2ZWMzKHJlZmxlY3Rpb25NYXRyaXggKiB2ZWM0KGNvb3JkcywgMSkpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfQ1VCSUMpXFxuXHR7XFxuXHRcdHZlYzMgdmlld0RpciA9IHdvcmxkUG9zLnh5eiAtIHZFeWVQb3NpdGlvbjtcXG5cdFx0dmVjMyBjb29yZHMgPSByZWZsZWN0KHZpZXdEaXIsIHdvcmxkTm9ybWFsKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAwKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9QUk9KRUNUSU9OKVxcblx0e1xcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogKHZpZXcgKiB3b3JsZFBvcykpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfU0tZQk9YKVxcblx0e1xcblx0XHRyZXR1cm4gcG9zaXRpb247XFxuXHR9XFxuXFxuXHRyZXR1cm4gdmVjMygwLCAwLCAwKTtcXG59XFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdG1hdDQgZmluYWxXb3JsZDtcXG5cXG4jaWZkZWYgQk9ORVNcXG5cdG1hdDQgbTAgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy54KV0gKiBtYXRyaWNlc1dlaWdodHMueDtcXG5cdG1hdDQgbTEgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy55KV0gKiBtYXRyaWNlc1dlaWdodHMueTtcXG5cdG1hdDQgbTIgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy56KV0gKiBtYXRyaWNlc1dlaWdodHMuejtcXG5cXG4jaWZkZWYgQk9ORVM0XFxuXHRtYXQ0IG0zID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMudyldICogbWF0cmljZXNXZWlnaHRzLnc7XFxuXHRmaW5hbFdvcmxkID0gd29ybGQgKiAobTAgKyBtMSArIG0yICsgbTMpO1xcbiNlbHNlXFxuXHRmaW5hbFdvcmxkID0gd29ybGQgKiAobTAgKyBtMSArIG0yKTtcXG4jZW5kaWYgXFxuXFxuI2Vsc2VcXG5cdGZpbmFsV29ybGQgPSB3b3JsZDtcXG4jZW5kaWZcXG5cXG5cdGdsX1Bvc2l0aW9uID0gdmlld1Byb2plY3Rpb24gKiBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXG5cdHZlYzQgd29ybGRQb3MgPSBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cdHZQb3NpdGlvblcgPSB2ZWMzKHdvcmxkUG9zKTtcXG5cdHZOb3JtYWxXID0gbm9ybWFsaXplKHZlYzMoZmluYWxXb3JsZCAqIHZlYzQobm9ybWFsLCAwLjApKSk7XFxuXFxuXHQvLyBUZXh0dXJlIGNvb3JkaW5hdGVzXFxuI2lmbmRlZiBVVjFcXG5cdHZlYzIgdXYgPSB2ZWMyKDAuLCAwLik7XFxuI2VuZGlmXFxuI2lmbmRlZiBVVjJcXG5cdHZlYzIgdXYyID0gdmVjMigwLiwgMC4pO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBESUZGVVNFXFxuXHRpZiAodkRpZmZ1c2VJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2RGlmZnVzZVVWID0gdmVjMihkaWZmdXNlTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkRpZmZ1c2VVViA9IHZlYzIoZGlmZnVzZU1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBBTUJJRU5UXFxuXHRpZiAodkFtYmllbnRJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2QW1iaWVudFVWID0gdmVjMihhbWJpZW50TWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkFtYmllbnRVViA9IHZlYzIoYW1iaWVudE1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBPUEFDSVRZXFxuXHRpZiAodk9wYWNpdHlJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2T3BhY2l0eVVWID0gdmVjMihvcGFjaXR5TWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dk9wYWNpdHlVViA9IHZlYzIob3BhY2l0eU1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBSRUZMRUNUSU9OXFxuXHR2UmVmbGVjdGlvblVWVyA9IGNvbXB1dGVSZWZsZWN0aW9uQ29vcmRzKHZSZWZsZWN0aW9uSW5mb3MueCwgdmVjNCh2UG9zaXRpb25XLCAxLjApLCB2Tm9ybWFsVyk7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEVNSVNTSVZFXFxuXHRpZiAodkVtaXNzaXZlSW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dkVtaXNzaXZlVVYgPSB2ZWMyKGVtaXNzaXZlTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkVtaXNzaXZlVVYgPSB2ZWMyKGVtaXNzaXZlTWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNQRUNVTEFSXFxuXHRpZiAodlNwZWN1bGFySW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dlNwZWN1bGFyVVYgPSB2ZWMyKHNwZWN1bGFyTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dlNwZWN1bGFyVVYgPSB2ZWMyKHNwZWN1bGFyTWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJVTVBcXG5cdGlmICh2QnVtcEluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZCdW1wVVYgPSB2ZWMyKGJ1bXBNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2QnVtcFVWID0gdmVjMihidW1wTWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuXHQvLyBDbGlwIHBsYW5lXFxuI2lmZGVmIENMSVBQTEFORVxcblx0ZkNsaXBEaXN0YW5jZSA9IGRvdCh3b3JsZFBvcywgdkNsaXBQbGFuZSk7XFxuI2VuZGlmXFxuXFxuXHQvLyBGb2dcXG4jaWZkZWYgRk9HXFxuXHRmRm9nRGlzdGFuY2UgPSAodmlldyAqIHdvcmxkUG9zKS56O1xcbiNlbmRpZlxcblxcblx0Ly8gU2hhZG93c1xcbiNpZmRlZiBTSEFET1dTXFxuI2lmZGVmIExJR0hUMFxcblx0dlBvc2l0aW9uRnJvbUxpZ2h0MCA9IGxpZ2h0TWF0cml4MCAqIHdvcmxkUG9zO1xcbiNlbmRpZlxcbiNpZmRlZiBMSUdIVDFcXG5cdHZQb3NpdGlvbkZyb21MaWdodDEgPSBsaWdodE1hdHJpeDEgKiB3b3JsZFBvcztcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQyXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQyID0gbGlnaHRNYXRyaXgyICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUM1xcblx0dlBvc2l0aW9uRnJvbUxpZ2h0MyA9IGxpZ2h0TWF0cml4MyAqIHdvcmxkUG9zO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcblx0Ly8gVmVydGV4IGNvbG9yXFxuI2lmZGVmIFZFUlRFWENPTE9SXFxuXHR2Q29sb3IgPSBjb2xvcjtcXG4jZW5kaWZcXG59XCIsbGVuc0ZsYXJlUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxuXFxuLy8gQ29sb3JcXG51bmlmb3JtIHZlYzQgY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdHZlYzQgYmFzZUNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYpO1xcblxcblx0Z2xfRnJhZ0NvbG9yID0gYmFzZUNvbG9yICogY29sb3I7XFxufVwiLGxlbnNGbGFyZVZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXG4vLyBVbmlmb3Jtc1xcbnVuaWZvcm0gbWF0NCB2aWV3cG9ydE1hdHJpeDtcXG5cXG4vLyBPdXRwdXRcXG52YXJ5aW5nIHZlYzIgdlVWO1xcblxcbmNvbnN0IHZlYzIgbWFkZCA9IHZlYzIoMC41LCAwLjUpO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XHRcXG5cXG5cdHZVViA9IHBvc2l0aW9uICogbWFkZCArIG1hZGQ7XFxuXHRnbF9Qb3NpdGlvbiA9IHZpZXdwb3J0TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xcbn1cIixvY3VsdXNEaXN0b3J0aW9uQ29ycmVjdGlvblBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiBMZW5zQ2VudGVyO1xcbnVuaWZvcm0gdmVjMiBTY2FsZTtcXG51bmlmb3JtIHZlYzIgU2NhbGVJbjtcXG51bmlmb3JtIHZlYzQgSG1kV2FycFBhcmFtO1xcblxcbnZlYzIgSG1kV2FycCh2ZWMyIGluMDEpIHtcXG5cXG5cdHZlYzIgdGhldGEgPSAoaW4wMSAtIExlbnNDZW50ZXIpICogU2NhbGVJbjsgLy8gU2NhbGVzIHRvIFstMSwgMV1cXG5cdGZsb2F0IHJTcSA9IHRoZXRhLnggKiB0aGV0YS54ICsgdGhldGEueSAqIHRoZXRhLnk7XFxuXHR2ZWMyIHJ2ZWN0b3IgPSB0aGV0YSAqIChIbWRXYXJwUGFyYW0ueCArIEhtZFdhcnBQYXJhbS55ICogclNxICsgSG1kV2FycFBhcmFtLnogKiByU3EgKiByU3EgKyBIbWRXYXJwUGFyYW0udyAqIHJTcSAqIHJTcSAqIHJTcSk7XFxuXHRyZXR1cm4gTGVuc0NlbnRlciArIFNjYWxlICogcnZlY3RvcjtcXG59XFxuXFxuXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcblx0dmVjMiB0YyA9IEhtZFdhcnAodlVWKTtcXG5cdGlmICh0Yy54IDwwLjAgfHwgdGMueD4xLjAgfHwgdGMueTwwLjAgfHwgdGMueT4xLjApXFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG5cdGVsc2V7XFxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB0YykucmdiLCAxLjApO1xcblx0fVxcbn1cIixwYXJ0aWNsZXNQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnVuaWZvcm0gdmVjNCB0ZXh0dXJlTWFzaztcXG51bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlU2FtcGxlcjtcXG5cXG4jaWZkZWYgQ0xJUFBMQU5FXFxudmFyeWluZyBmbG9hdCBmQ2xpcERpc3RhbmNlO1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuI2lmZGVmIENMSVBQTEFORVxcblx0aWYgKGZDbGlwRGlzdGFuY2UgPiAwLjApXFxuXHRcdGRpc2NhcmQ7XFxuI2VuZGlmXFxuXHR2ZWM0IGJhc2VDb2xvciA9IHRleHR1cmUyRChkaWZmdXNlU2FtcGxlciwgdlVWKTtcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IChiYXNlQ29sb3IgKiB0ZXh0dXJlTWFzayArICh2ZWM0KDEuLCAxLiwgMS4sIDEuKSAtIHRleHR1cmVNYXNrKSkgKiB2Q29sb3I7XFxufVwiLHBhcnRpY2xlc1ZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5hdHRyaWJ1dGUgdmVjNCBvcHRpb25zO1xcblxcbi8vIFVuaWZvcm1zXFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxuXFxuLy8gT3V0cHV0XFxudmFyeWluZyB2ZWMyIHZVVjtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbiNpZmRlZiBDTElQUExBTkVcXG51bmlmb3JtIHZlYzQgdkNsaXBQbGFuZTtcXG51bmlmb3JtIG1hdDQgaW52VmlldztcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcdFxcblx0dmVjMyB2aWV3UG9zID0gKHZpZXcgKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7IFxcblx0dmVjMyBjb3JuZXJQb3M7XFxuXHRmbG9hdCBzaXplID0gb3B0aW9ucy55O1xcblx0ZmxvYXQgYW5nbGUgPSBvcHRpb25zLng7XFxuXHR2ZWMyIG9mZnNldCA9IG9wdGlvbnMuenc7XFxuXFxuXHRjb3JuZXJQb3MgPSB2ZWMzKG9mZnNldC54IC0gMC41LCBvZmZzZXQueSAgLSAwLjUsIDAuKSAqIHNpemU7XFxuXFxuXHQvLyBSb3RhdGVcXG5cdHZlYzMgcm90YXRlZENvcm5lcjtcXG5cdHJvdGF0ZWRDb3JuZXIueCA9IGNvcm5lclBvcy54ICogY29zKGFuZ2xlKSAtIGNvcm5lclBvcy55ICogc2luKGFuZ2xlKTtcXG5cdHJvdGF0ZWRDb3JuZXIueSA9IGNvcm5lclBvcy54ICogc2luKGFuZ2xlKSArIGNvcm5lclBvcy55ICogY29zKGFuZ2xlKTtcXG5cdHJvdGF0ZWRDb3JuZXIueiA9IDAuO1xcblxcblx0Ly8gUG9zaXRpb25cXG5cdHZpZXdQb3MgKz0gcm90YXRlZENvcm5lcjtcXG5cdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZlYzQodmlld1BvcywgMS4wKTsgICBcXG5cdFxcblx0dkNvbG9yID0gY29sb3I7XFxuXHR2VVYgPSBvZmZzZXQ7XFxuXFxuXHQvLyBDbGlwIHBsYW5lXFxuI2lmZGVmIENMSVBQTEFORVxcblx0dmVjNCB3b3JsZFBvcyA9IGludlZpZXcgKiB2ZWM0KHZpZXdQb3MsIDEuMCk7XFxuXHRmQ2xpcERpc3RhbmNlID0gZG90KHdvcmxkUG9zLCB2Q2xpcFBsYW5lKTtcXG4jZW5kaWZcXG59XCIscGFzc1BpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKSBcXG57XFxuXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVik7XFxufVwiLHBvc3Rwcm9jZXNzVmVydGV4U2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gQXR0cmlidXRlc1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcbi8vIE91dHB1dFxcbnZhcnlpbmcgdmVjMiB2VVY7XFxuXFxuY29uc3QgdmVjMiBtYWRkID0gdmVjMigwLjUsIDAuNSk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcdFxcblxcblx0dlVWID0gcG9zaXRpb24gKiBtYWRkICsgbWFkZDtcXG5cdGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1xcbn1cIixyZWZyYWN0aW9uUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgcmVmcmFjdGlvblNhbXBsZXI7XFxuXFxuLy8gUGFyYW1ldGVyc1xcbnVuaWZvcm0gdmVjMyBiYXNlQ29sb3I7XFxudW5pZm9ybSBmbG9hdCBkZXB0aDtcXG51bmlmb3JtIGZsb2F0IGNvbG9yTGV2ZWw7XFxuXFxudm9pZCBtYWluKCkge1xcblx0ZmxvYXQgcmVmID0gMS4wIC0gdGV4dHVyZTJEKHJlZnJhY3Rpb25TYW1wbGVyLCB2VVYpLnI7XFxuXFxuXHR2ZWMyIHV2ID0gdlVWIC0gdmVjMigwLjUpO1xcblx0dmVjMiBvZmZzZXQgPSB1diAqIGRlcHRoICogcmVmO1xcblx0dmVjMyBzb3VyY2VDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWIC0gb2Zmc2V0KS5yZ2I7XFxuXFxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHNvdXJjZUNvbG9yICsgc291cmNlQ29sb3IgKiByZWYgKiBjb2xvckxldmVsLCAxLjApO1xcbn1cIixzaGFkb3dNYXBQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZlYzQgcGFjayhmbG9hdCBkZXB0aClcXG57XFxuXHRjb25zdCB2ZWM0IGJpdE9mZnNldCA9IHZlYzQoMjU1LiAqIDI1NS4gKiAyNTUuLCAyNTUuICogMjU1LiwgMjU1LiwgMS4pO1xcblx0Y29uc3QgdmVjNCBiaXRNYXNrID0gdmVjNCgwLiwgMS4gLyAyNTUuLCAxLiAvIDI1NS4sIDEuIC8gMjU1Lik7XFxuXHRcXG5cdHZlYzQgY29tcCA9IG1vZChkZXB0aCAqIGJpdE9mZnNldCAqIHZlYzQoMjU0LiksIHZlYzQoMjU1LikpIC8gdmVjNCgyNTQuKTtcXG5cdGNvbXAgLT0gY29tcC54eHl6ICogYml0TWFzaztcXG5cdFxcblx0cmV0dXJuIGNvbXA7XFxufVxcblxcbi8vIFRoYW5rcyB0byBodHRwOi8vZGV2bWFzdGVyLm5ldC9cXG52ZWMyIHBhY2tIYWxmKGZsb2F0IGRlcHRoKSBcXG57IFxcblx0Y29uc3QgdmVjMiBiaXRPZmZzZXQgPSB2ZWMyKDEuMCAvIDI1NS4sIDAuKTtcXG5cdHZlYzIgY29sb3IgPSB2ZWMyKGRlcHRoLCBmcmFjdChkZXB0aCAqIDI1NS4pKTtcXG5cXG5cdHJldHVybiBjb2xvciAtIChjb2xvci55eSAqIGJpdE9mZnNldCk7XFxufVxcblxcbiNpZm5kZWYgVlNNXFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQUxQSEFURVNUXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlU2FtcGxlcjtcXG4jZW5kaWZcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuI2lmZGVmIEFMUEhBVEVTVFxcblx0aWYgKHRleHR1cmUyRChkaWZmdXNlU2FtcGxlciwgdlVWKS5hIDwgMC40KVxcblx0XHRkaXNjYXJkO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBWU01cXG5cdGZsb2F0IG1vbWVudDEgPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcblx0ZmxvYXQgbW9tZW50MiA9IG1vbWVudDEgKiBtb21lbnQxO1xcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChwYWNrSGFsZihtb21lbnQxKSwgcGFja0hhbGYobW9tZW50MikpO1xcbiNlbHNlXFxuXHRnbF9GcmFnQ29sb3IgPSBwYWNrKHZQb3NpdGlvbi56IC8gdlBvc2l0aW9uLncpO1xcbiNlbmRpZlxcbn1cIixzaGFkb3dNYXBWZXJ0ZXhTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBBdHRyaWJ1dGVcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG4jaWZkZWYgQk9ORVNcXG5hdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc0luZGljZXM7XFxuYXR0cmlidXRlIHZlYzQgbWF0cmljZXNXZWlnaHRzO1xcbiNlbmRpZlxcblxcbi8vIFVuaWZvcm1cXG4jaWZkZWYgSU5TVEFOQ0VTXFxuYXR0cmlidXRlIHZlYzQgd29ybGQwO1xcbmF0dHJpYnV0ZSB2ZWM0IHdvcmxkMTtcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDI7XFxuYXR0cmlidXRlIHZlYzQgd29ybGQzO1xcbiNlbHNlXFxudW5pZm9ybSBtYXQ0IHdvcmxkO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0NCB2aWV3UHJvamVjdGlvbjtcXG4jaWZkZWYgQk9ORVNcXG51bmlmb3JtIG1hdDQgbUJvbmVzW0JvbmVzUGVyTWVzaF07XFxuI2VuZGlmXFxuXFxuI2lmbmRlZiBWU01cXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTFBIQVRFU1RcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gbWF0NCBkaWZmdXNlTWF0cml4O1xcbiNpZmRlZiBVVjFcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG4jZW5kaWZcXG4jaWZkZWYgVVYyXFxuYXR0cmlidXRlIHZlYzIgdXYyO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4jaWZkZWYgSU5TVEFOQ0VTXFxuXHRtYXQ0IGZpbmFsV29ybGQgPSBtYXQ0KHdvcmxkMCwgd29ybGQxLCB3b3JsZDIsIHdvcmxkMyk7XFxuI2Vsc2VcXG5cdG1hdDQgZmluYWxXb3JsZCA9IHdvcmxkO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBCT05FU1xcblx0bWF0NCBtMCA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLngpXSAqIG1hdHJpY2VzV2VpZ2h0cy54O1xcblx0bWF0NCBtMSA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnkpXSAqIG1hdHJpY2VzV2VpZ2h0cy55O1xcblx0bWF0NCBtMiA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnopXSAqIG1hdHJpY2VzV2VpZ2h0cy56O1xcblx0bWF0NCBtMyA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLncpXSAqIG1hdHJpY2VzV2VpZ2h0cy53O1xcblx0ZmluYWxXb3JsZCA9IGZpbmFsV29ybGQgKiAobTAgKyBtMSArIG0yICsgbTMpO1xcblx0Z2xfUG9zaXRpb24gPSB2aWV3UHJvamVjdGlvbiAqIGZpbmFsV29ybGQgKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiNlbHNlXFxuI2lmbmRlZiBWU01cXG5cdHZQb3NpdGlvbiA9IHZpZXdQcm9qZWN0aW9uICogZmluYWxXb3JsZCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuI2VuZGlmXFxuXHRnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qZWN0aW9uICogZmluYWxXb3JsZCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFMUEhBVEVTVFxcbiNpZmRlZiBVVjFcXG5cdHZVViA9IHZlYzIoZGlmZnVzZU1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuI2VuZGlmXFxuI2lmZGVmIFVWMlxcblx0dlVWID0gdmVjMihkaWZmdXNlTWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuI2VuZGlmXFxuI2VuZGlmXFxufVwiLHNwcml0ZXNQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gYm9vbCBhbHBoYVRlc3Q7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVNhbXBsZXI7XFxuXFxuLy8gRm9nXFxuI2lmZGVmIEZPR1xcblxcbiNkZWZpbmUgRk9HTU9ERV9OT05FICAgIDAuXFxuI2RlZmluZSBGT0dNT0RFX0VYUCAgICAgMS5cXG4jZGVmaW5lIEZPR01PREVfRVhQMiAgICAyLlxcbiNkZWZpbmUgRk9HTU9ERV9MSU5FQVIgIDMuXFxuI2RlZmluZSBFIDIuNzE4MjhcXG5cXG51bmlmb3JtIHZlYzQgdkZvZ0luZm9zO1xcbnVuaWZvcm0gdmVjMyB2Rm9nQ29sb3I7XFxudmFyeWluZyBmbG9hdCBmRm9nRGlzdGFuY2U7XFxuXFxuZmxvYXQgQ2FsY0ZvZ0ZhY3RvcigpXFxue1xcblx0ZmxvYXQgZm9nQ29lZmYgPSAxLjA7XFxuXHRmbG9hdCBmb2dTdGFydCA9IHZGb2dJbmZvcy55O1xcblx0ZmxvYXQgZm9nRW5kID0gdkZvZ0luZm9zLno7XFxuXHRmbG9hdCBmb2dEZW5zaXR5ID0gdkZvZ0luZm9zLnc7XFxuXFxuXHRpZiAoRk9HTU9ERV9MSU5FQVIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gKGZvZ0VuZCAtIGZGb2dEaXN0YW5jZSkgLyAoZm9nRW5kIC0gZm9nU3RhcnQpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkpO1xcblx0fVxcblx0ZWxzZSBpZiAoRk9HTU9ERV9FWFAyID09IHZGb2dJbmZvcy54KVxcblx0e1xcblx0XHRmb2dDb2VmZiA9IDEuMCAvIHBvdyhFLCBmRm9nRGlzdGFuY2UgKiBmRm9nRGlzdGFuY2UgKiBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXFxuXHRyZXR1cm4gbWluKDEuLCBtYXgoMC4sIGZvZ0NvZWZmKSk7XFxufVxcbiNlbmRpZlxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXHR2ZWM0IGJhc2VDb2xvciA9IHRleHR1cmUyRChkaWZmdXNlU2FtcGxlciwgdlVWKTtcXG5cXG5cdGlmIChhbHBoYVRlc3QpIFxcblx0e1xcblx0XHRpZiAoYmFzZUNvbG9yLmEgPCAwLjk1KVxcblx0XHRcdGRpc2NhcmQ7XFxuXHR9XFxuXFxuXHRiYXNlQ29sb3IgKj0gdkNvbG9yO1xcblxcbiNpZmRlZiBGT0dcXG5cdGZsb2F0IGZvZyA9IENhbGNGb2dGYWN0b3IoKTtcXG5cdGJhc2VDb2xvci5yZ2IgPSBmb2cgKiBiYXNlQ29sb3IucmdiICsgKDEuMCAtIGZvZykgKiB2Rm9nQ29sb3I7XFxuI2VuZGlmXFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBiYXNlQ29sb3I7XFxufVwiLHNwcml0ZXNWZXJ0ZXhTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBBdHRyaWJ1dGVzXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzQgb3B0aW9ucztcXG5hdHRyaWJ1dGUgdmVjNCBjZWxsSW5mbztcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5cXG4vLyBVbmlmb3Jtc1xcbnVuaWZvcm0gdmVjMiB0ZXh0dXJlSW5mb3M7XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxuXFxuLy8gT3V0cHV0XFxudmFyeWluZyB2ZWMyIHZVVjtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbiNpZmRlZiBGT0dcXG52YXJ5aW5nIGZsb2F0IGZGb2dEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG52b2lkIG1haW4odm9pZCkge1x0XFxuXHR2ZWMzIHZpZXdQb3MgPSAodmlldyAqIHZlYzQocG9zaXRpb24sIDEuMCkpLnh5ejsgXFxuXHR2ZWMzIGNvcm5lclBvcztcXG5cdFxcblx0ZmxvYXQgYW5nbGUgPSBvcHRpb25zLng7XFxuXHRmbG9hdCBzaXplID0gb3B0aW9ucy55O1xcblx0dmVjMiBvZmZzZXQgPSBvcHRpb25zLnp3O1xcblx0dmVjMiB1dlNjYWxlID0gdGV4dHVyZUluZm9zLnh5O1xcblxcblx0Y29ybmVyUG9zID0gdmVjMyhvZmZzZXQueCAtIDAuNSwgb2Zmc2V0LnkgIC0gMC41LCAwLikgKiBzaXplO1xcblxcblx0Ly8gUm90YXRlXFxuXHR2ZWMzIHJvdGF0ZWRDb3JuZXI7XFxuXHRyb3RhdGVkQ29ybmVyLnggPSBjb3JuZXJQb3MueCAqIGNvcyhhbmdsZSkgLSBjb3JuZXJQb3MueSAqIHNpbihhbmdsZSk7XFxuXHRyb3RhdGVkQ29ybmVyLnkgPSBjb3JuZXJQb3MueCAqIHNpbihhbmdsZSkgKyBjb3JuZXJQb3MueSAqIGNvcyhhbmdsZSk7XFxuXHRyb3RhdGVkQ29ybmVyLnogPSAwLjtcXG5cXG5cdC8vIFBvc2l0aW9uXFxuXHR2aWV3UG9zICs9IHJvdGF0ZWRDb3JuZXI7XFxuXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2ZWM0KHZpZXdQb3MsIDEuMCk7ICAgXFxuXFxuXHQvLyBDb2xvclxcblx0dkNvbG9yID0gY29sb3I7XFxuXHRcXG5cdC8vIFRleHR1cmVcXG5cdHZlYzIgdXZPZmZzZXQgPSB2ZWMyKGFicyhvZmZzZXQueCAtIGNlbGxJbmZvLngpLCAxLjAgLSBhYnMob2Zmc2V0LnkgLSBjZWxsSW5mby55KSk7XFxuXFxuXHR2VVYgPSAodXZPZmZzZXQgKyBjZWxsSW5mby56dykgKiB1dlNjYWxlO1xcblxcblx0Ly8gRm9nXFxuI2lmZGVmIEZPR1xcblx0ZkZvZ0Rpc3RhbmNlID0gdmlld1Bvcy56O1xcbiNlbmRpZlxcbn1cIn0sYlxufSgpO2EuRWZmZWN0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyl7dGhpcy5uYW1lPWEsdGhpcy5jaGVja1JlYWR5T25FdmVyeUNhbGw9ITAsdGhpcy5jaGVja1JlYWR5T25seU9uY2U9ITEsdGhpcy5zdGF0ZT1cIlwiLHRoaXMuYWxwaGE9MSx0aGlzLndpcmVmcmFtZT0hMSx0aGlzLmJhY2tGYWNlQ3VsbGluZz0hMCx0aGlzLl93YXNQcmV2aW91c2x5UmVhZHk9ITEsdGhpcy5pZD1hLHRoaXMuX3NjZW5lPWIsY3x8Yi5tYXRlcmlhbHMucHVzaCh0aGlzKX1yZXR1cm4gYS5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiEwfSxhLnByb3RvdHlwZS5nZXRFZmZlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZWZmZWN0fSxhLnByb3RvdHlwZS5nZXRTY2VuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY2VuZX0sYS5wcm90b3R5cGUubmVlZEFscGhhQmxlbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbHBoYTwxfSxhLnByb3RvdHlwZS5uZWVkQWxwaGFUZXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGEucHJvdG90eXBlLmdldEFscGhhVGVzdFRleHR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYS5wcm90b3R5cGUudHJhY2tDcmVhdGlvbj1mdW5jdGlvbigpe30sYS5wcm90b3R5cGUuX3ByZUJpbmQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTthLmVuYWJsZUVmZmVjdCh0aGlzLl9lZmZlY3QpLGEuc2V0U3RhdGUodGhpcy5iYWNrRmFjZUN1bGxpbmcpfSxhLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5iaW5kT25seVdvcmxkTWF0cml4PWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS51bmJpbmQ9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fc2NlbmUubWF0ZXJpYWxzLmluZGV4T2YodGhpcyk7dGhpcy5fc2NlbmUubWF0ZXJpYWxzLnNwbGljZShiLDEpLGEmJnRoaXMuX2VmZmVjdCYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlRWZmZWN0KHRoaXMuX2VmZmVjdCksdGhpcy5fZWZmZWN0PW51bGwpLHRoaXMub25EaXNwb3NlJiZ0aGlzLm9uRGlzcG9zZSgpfSxhfSgpO2EuTWF0ZXJpYWw9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPTQsYz1mdW5jdGlvbihjKXtmdW5jdGlvbiBkKGIsZCl7dmFyIGU9dGhpcztjLmNhbGwodGhpcyxiLGQpLHRoaXMuYW1iaWVudENvbG9yPW5ldyBhLkNvbG9yMygwLDAsMCksdGhpcy5kaWZmdXNlQ29sb3I9bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLnNwZWN1bGFyQ29sb3I9bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLnNwZWN1bGFyUG93ZXI9NjQsdGhpcy5lbWlzc2l2ZUNvbG9yPW5ldyBhLkNvbG9yMygwLDAsMCksdGhpcy51c2VBbHBoYUZyb21EaWZmdXNlVGV4dHVyZT0hMSx0aGlzLl9jYWNoZWREZWZpbmVzPW51bGwsdGhpcy5fcmVuZGVyVGFyZ2V0cz1uZXcgYS5TbWFydEFycmF5KDE2KSx0aGlzLl93b3JsZFZpZXdQcm9qZWN0aW9uTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9nbG9iYWxBbWJpZW50Q29sb3I9bmV3IGEuQ29sb3IzKDAsMCwwKSx0aGlzLl9iYXNlQ29sb3I9bmV3IGEuQ29sb3IzLHRoaXMuX3NjYWxlZERpZmZ1c2U9bmV3IGEuQ29sb3IzLHRoaXMuX3NjYWxlZFNwZWN1bGFyPW5ldyBhLkNvbG9yMyx0aGlzLmdldFJlbmRlclRhcmdldFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIGUuX3JlbmRlclRhcmdldHMucmVzZXQoKSxlLnJlZmxlY3Rpb25UZXh0dXJlJiZlLnJlZmxlY3Rpb25UZXh0dXJlLmlzUmVuZGVyVGFyZ2V0JiZlLl9yZW5kZXJUYXJnZXRzLnB1c2goZS5yZWZsZWN0aW9uVGV4dHVyZSksZS5fcmVuZGVyVGFyZ2V0c319cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLm5lZWRBbHBoYUJsZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWxwaGE8MXx8bnVsbCE9dGhpcy5vcGFjaXR5VGV4dHVyZXx8dGhpcy5fc2hvdWxkVXNlQWxwaGFGcm9tRGlmZnVzZVRleHR1cmUoKX0sZC5wcm90b3R5cGUubmVlZEFscGhhVGVzdGluZz1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmRpZmZ1c2VUZXh0dXJlJiZ0aGlzLmRpZmZ1c2VUZXh0dXJlLmhhc0FscGhhJiYhdGhpcy5kaWZmdXNlVGV4dHVyZS5nZXRBbHBoYUZyb21SR0J9LGQucHJvdG90eXBlLl9zaG91bGRVc2VBbHBoYUZyb21EaWZmdXNlVGV4dHVyZT1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmRpZmZ1c2VUZXh0dXJlJiZ0aGlzLmRpZmZ1c2VUZXh0dXJlLmhhc0FscGhhJiZ0aGlzLnVzZUFscGhhRnJvbURpZmZ1c2VUZXh0dXJlfSxkLnByb3RvdHlwZS5nZXRBbHBoYVRlc3RUZXh0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlmZnVzZVRleHR1cmV9LGQucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oYyxkKXtpZih0aGlzLmNoZWNrUmVhZHlPbmx5T25jZSYmdGhpcy5fd2FzUHJldmlvdXNseVJlYWR5KXJldHVybiEwO3ZhciBlPXRoaXMuZ2V0U2NlbmUoKTtpZighdGhpcy5jaGVja1JlYWR5T25FdmVyeUNhbGwmJnRoaXMuX3JlbmRlcklkPT09ZS5nZXRSZW5kZXJJZCgpKXJldHVybiEwO3ZhciBmPWUuZ2V0RW5naW5lKCksZz1bXSxoPW5ldyBBcnJheTtpZihlLnRleHR1cmVzRW5hYmxlZCl7aWYodGhpcy5kaWZmdXNlVGV4dHVyZSYmYS5TdGFuZGFyZE1hdGVyaWFsLkRpZmZ1c2VUZXh0dXJlRW5hYmxlZCl7aWYoIXRoaXMuZGlmZnVzZVRleHR1cmUuaXNSZWFkeSgpKXJldHVybiExO2cucHVzaChcIiNkZWZpbmUgRElGRlVTRVwiKX1pZih0aGlzLmFtYmllbnRUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuQW1iaWVudFRleHR1cmVFbmFibGVkKXtpZighdGhpcy5hbWJpZW50VGV4dHVyZS5pc1JlYWR5KCkpcmV0dXJuITE7Zy5wdXNoKFwiI2RlZmluZSBBTUJJRU5UXCIpfWlmKHRoaXMub3BhY2l0eVRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5PcGFjaXR5VGV4dHVyZUVuYWJsZWQpe2lmKCF0aGlzLm9wYWNpdHlUZXh0dXJlLmlzUmVhZHkoKSlyZXR1cm4hMTtnLnB1c2goXCIjZGVmaW5lIE9QQUNJVFlcIiksdGhpcy5vcGFjaXR5VGV4dHVyZS5nZXRBbHBoYUZyb21SR0ImJmcucHVzaChcIiNkZWZpbmUgT1BBQ0lUWVJHQlwiKX1pZih0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuUmVmbGVjdGlvblRleHR1cmVFbmFibGVkKXtpZighdGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5pc1JlYWR5KCkpcmV0dXJuITE7Zy5wdXNoKFwiI2RlZmluZSBSRUZMRUNUSU9OXCIpfWlmKHRoaXMuZW1pc3NpdmVUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuRW1pc3NpdmVUZXh0dXJlRW5hYmxlZCl7aWYoIXRoaXMuZW1pc3NpdmVUZXh0dXJlLmlzUmVhZHkoKSlyZXR1cm4hMTtnLnB1c2goXCIjZGVmaW5lIEVNSVNTSVZFXCIpfWlmKHRoaXMuc3BlY3VsYXJUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuU3BlY3VsYXJUZXh0dXJlRW5hYmxlZCl7aWYoIXRoaXMuc3BlY3VsYXJUZXh0dXJlLmlzUmVhZHkoKSlyZXR1cm4hMTtnLnB1c2goXCIjZGVmaW5lIFNQRUNVTEFSXCIpLGgucHVzaChnW2cubGVuZ3RoLTFdKX19aWYoZS5nZXRFbmdpbmUoKS5nZXRDYXBzKCkuc3RhbmRhcmREZXJpdmF0aXZlcyYmdGhpcy5idW1wVGV4dHVyZSYmYS5TdGFuZGFyZE1hdGVyaWFsLkJ1bXBUZXh0dXJlRW5hYmxlZCl7aWYoIXRoaXMuYnVtcFRleHR1cmUuaXNSZWFkeSgpKXJldHVybiExO2cucHVzaChcIiNkZWZpbmUgQlVNUFwiKSxoLnB1c2goZ1tnLmxlbmd0aC0xXSl9ZS5jbGlwUGxhbmUmJmcucHVzaChcIiNkZWZpbmUgQ0xJUFBMQU5FXCIpLGYuZ2V0QWxwaGFUZXN0aW5nKCkmJmcucHVzaChcIiNkZWZpbmUgQUxQSEFURVNUXCIpLHRoaXMuX3Nob3VsZFVzZUFscGhhRnJvbURpZmZ1c2VUZXh0dXJlKCkmJmcucHVzaChcIiNkZWZpbmUgQUxQSEFGUk9NRElGRlVTRVwiKSxlLmZvZ01vZGUhPT1hLlNjZW5lLkZPR01PREVfTk9ORSYmKGcucHVzaChcIiNkZWZpbmUgRk9HXCIpLGgucHVzaChnW2cubGVuZ3RoLTFdKSk7dmFyIGk9ITEsaj0wO2lmKGUubGlnaHRzRW5hYmxlZClmb3IodmFyIGs9MDtrPGUubGlnaHRzLmxlbmd0aDtrKyspe3ZhciBsPWUubGlnaHRzW2tdO2lmKGwuaXNFbmFibGVkKCkpe2lmKGwuX2V4Y2x1ZGVkTWVzaGVzSWRzLmxlbmd0aD4wKXtmb3IodmFyIG09MDttPGwuX2V4Y2x1ZGVkTWVzaGVzSWRzLmxlbmd0aDttKyspe3ZhciBuPWUuZ2V0TWVzaEJ5SUQobC5fZXhjbHVkZWRNZXNoZXNJZHNbbV0pO24mJmwuZXhjbHVkZWRNZXNoZXMucHVzaChuKX1sLl9leGNsdWRlZE1lc2hlc0lkcz1bXX1pZighY3x8LTE9PT1sLmV4Y2x1ZGVkTWVzaGVzLmluZGV4T2YoYykpe2cucHVzaChcIiNkZWZpbmUgTElHSFRcIitqKSxqPjAmJmgucHVzaChnW2cubGVuZ3RoLTFdKTt2YXIgbztvPWwgaW5zdGFuY2VvZiBhLlNwb3RMaWdodD9cIiNkZWZpbmUgU1BPVExJR0hUXCIrajpsIGluc3RhbmNlb2YgYS5IZW1pc3BoZXJpY0xpZ2h0P1wiI2RlZmluZSBIRU1JTElHSFRcIitqOlwiI2RlZmluZSBQT0lOVERJUkxJR0hUXCIraixnLnB1c2gobyksaj4wJiZoLnB1c2goZ1tnLmxlbmd0aC0xXSk7dmFyIHA9bC5nZXRTaGFkb3dHZW5lcmF0b3IoKTtpZihjJiZjLnJlY2VpdmVTaGFkb3dzJiZwJiYoZy5wdXNoKFwiI2RlZmluZSBTSEFET1dcIitqKSxqPjAmJmgucHVzaChnW2cubGVuZ3RoLTFdKSxpfHwoZy5wdXNoKFwiI2RlZmluZSBTSEFET1dTXCIpLGk9ITApLHAudXNlVmFyaWFuY2VTaGFkb3dNYXAmJihnLnB1c2goXCIjZGVmaW5lIFNIQURPV1ZTTVwiK2opLGo+MCYmaC5wdXNoKGdbZy5sZW5ndGgtMV0pKSxwLnVzZVBvaXNzb25TYW1wbGluZyYmKGcucHVzaChcIiNkZWZpbmUgU0hBRE9XUENGXCIraiksaj4wJiZoLnB1c2goZ1tnLmxlbmd0aC0xXSkpKSxqKyssaj09YilicmVha319fXZhciBxPVthLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZF07YyYmKGMuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLlVWS2luZCkmJihxLnB1c2goYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSxnLnB1c2goXCIjZGVmaW5lIFVWMVwiKSksYy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkmJihxLnB1c2goYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCksZy5wdXNoKFwiI2RlZmluZSBVVjJcIikpLGMuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCkmJihxLnB1c2goYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSxnLnB1c2goXCIjZGVmaW5lIFZFUlRFWENPTE9SXCIpKSxjLnNrZWxldG9uJiZjLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSYmYy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCkmJihxLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCkscS5wdXNoKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpLGcucHVzaChcIiNkZWZpbmUgQk9ORVNcIiksZy5wdXNoKFwiI2RlZmluZSBCb25lc1Blck1lc2ggXCIrKGMuc2tlbGV0b24uYm9uZXMubGVuZ3RoKzEpKSxnLnB1c2goXCIjZGVmaW5lIEJPTkVTNFwiKSxoLnB1c2goZ1tnLmxlbmd0aC0xXSkpLGQmJihnLnB1c2goXCIjZGVmaW5lIElOU1RBTkNFU1wiKSxxLnB1c2goXCJ3b3JsZDBcIikscS5wdXNoKFwid29ybGQxXCIpLHEucHVzaChcIndvcmxkMlwiKSxxLnB1c2goXCJ3b3JsZDNcIikpKTt2YXIgcj1nLmpvaW4oXCJcXG5cIik7aWYodGhpcy5fY2FjaGVkRGVmaW5lcyE9cil7dGhpcy5fY2FjaGVkRGVmaW5lcz1yO3ZhciBzPVwiZGVmYXVsdFwiO2UuZ2V0RW5naW5lKCkuZ2V0Q2FwcygpLnN0YW5kYXJkRGVyaXZhdGl2ZXN8fChzPVwibGVnYWN5ZGVmYXVsdFwiKSx0aGlzLl9lZmZlY3Q9ZS5nZXRFbmdpbmUoKS5jcmVhdGVFZmZlY3QocyxxLFtcIndvcmxkXCIsXCJ2aWV3XCIsXCJ2aWV3UHJvamVjdGlvblwiLFwidkV5ZVBvc2l0aW9uXCIsXCJ2TGlnaHRzVHlwZVwiLFwidkFtYmllbnRDb2xvclwiLFwidkRpZmZ1c2VDb2xvclwiLFwidlNwZWN1bGFyQ29sb3JcIixcInZFbWlzc2l2ZUNvbG9yXCIsXCJ2TGlnaHREYXRhMFwiLFwidkxpZ2h0RGlmZnVzZTBcIixcInZMaWdodFNwZWN1bGFyMFwiLFwidkxpZ2h0RGlyZWN0aW9uMFwiLFwidkxpZ2h0R3JvdW5kMFwiLFwibGlnaHRNYXRyaXgwXCIsXCJ2TGlnaHREYXRhMVwiLFwidkxpZ2h0RGlmZnVzZTFcIixcInZMaWdodFNwZWN1bGFyMVwiLFwidkxpZ2h0RGlyZWN0aW9uMVwiLFwidkxpZ2h0R3JvdW5kMVwiLFwibGlnaHRNYXRyaXgxXCIsXCJ2TGlnaHREYXRhMlwiLFwidkxpZ2h0RGlmZnVzZTJcIixcInZMaWdodFNwZWN1bGFyMlwiLFwidkxpZ2h0RGlyZWN0aW9uMlwiLFwidkxpZ2h0R3JvdW5kMlwiLFwibGlnaHRNYXRyaXgyXCIsXCJ2TGlnaHREYXRhM1wiLFwidkxpZ2h0RGlmZnVzZTNcIixcInZMaWdodFNwZWN1bGFyM1wiLFwidkxpZ2h0RGlyZWN0aW9uM1wiLFwidkxpZ2h0R3JvdW5kM1wiLFwibGlnaHRNYXRyaXgzXCIsXCJ2Rm9nSW5mb3NcIixcInZGb2dDb2xvclwiLFwidkRpZmZ1c2VJbmZvc1wiLFwidkFtYmllbnRJbmZvc1wiLFwidk9wYWNpdHlJbmZvc1wiLFwidlJlZmxlY3Rpb25JbmZvc1wiLFwidkVtaXNzaXZlSW5mb3NcIixcInZTcGVjdWxhckluZm9zXCIsXCJ2QnVtcEluZm9zXCIsXCJtQm9uZXNcIixcInZDbGlwUGxhbmVcIixcImRpZmZ1c2VNYXRyaXhcIixcImFtYmllbnRNYXRyaXhcIixcIm9wYWNpdHlNYXRyaXhcIixcInJlZmxlY3Rpb25NYXRyaXhcIixcImVtaXNzaXZlTWF0cml4XCIsXCJzcGVjdWxhck1hdHJpeFwiLFwiYnVtcE1hdHJpeFwiLFwiZGFya25lc3MwXCIsXCJkYXJrbmVzczFcIixcImRhcmtuZXNzMlwiLFwiZGFya25lc3MzXCJdLFtcImRpZmZ1c2VTYW1wbGVyXCIsXCJhbWJpZW50U2FtcGxlclwiLFwib3BhY2l0eVNhbXBsZXJcIixcInJlZmxlY3Rpb25DdWJlU2FtcGxlclwiLFwicmVmbGVjdGlvbjJEU2FtcGxlclwiLFwiZW1pc3NpdmVTYW1wbGVyXCIsXCJzcGVjdWxhclNhbXBsZXJcIixcImJ1bXBTYW1wbGVyXCIsXCJzaGFkb3dTYW1wbGVyMFwiLFwic2hhZG93U2FtcGxlcjFcIixcInNoYWRvd1NhbXBsZXIyXCIsXCJzaGFkb3dTYW1wbGVyM1wiXSxyLGgsdGhpcy5vbkNvbXBpbGVkLHRoaXMub25FcnJvcil9cmV0dXJuIHRoaXMuX2VmZmVjdC5pc1JlYWR5KCk/KHRoaXMuX3JlbmRlcklkPWUuZ2V0UmVuZGVySWQoKSx0aGlzLl93YXNQcmV2aW91c2x5UmVhZHk9ITAsITApOiExfSxkLnByb3RvdHlwZS51bmJpbmQ9ZnVuY3Rpb24oKXt0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZ0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmlzUmVuZGVyVGFyZ2V0JiZ0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcInJlZmxlY3Rpb24yRFNhbXBsZXJcIixudWxsKX0sZC5wcm90b3R5cGUuYmluZE9ubHlXb3JsZE1hdHJpeD1mdW5jdGlvbihhKXt0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRcIixhKX0sZC5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihjLGQpe3ZhciBlPXRoaXMuZ2V0U2NlbmUoKTtpZih0aGlzLl9iYXNlQ29sb3IuY29weUZyb20odGhpcy5kaWZmdXNlQ29sb3IpLHRoaXMuYmluZE9ubHlXb3JsZE1hdHJpeChjKSx0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwidmlld1Byb2plY3Rpb25cIixlLmdldFRyYW5zZm9ybU1hdHJpeCgpKSxkLnNrZWxldG9uJiZkLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSYmZC5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCkmJnRoaXMuX2VmZmVjdC5zZXRNYXRyaWNlcyhcIm1Cb25lc1wiLGQuc2tlbGV0b24uZ2V0VHJhbnNmb3JtTWF0cmljZXMoKSksdGhpcy5kaWZmdXNlVGV4dHVyZSYmYS5TdGFuZGFyZE1hdGVyaWFsLkRpZmZ1c2VUZXh0dXJlRW5hYmxlZCYmKHRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwiZGlmZnVzZVNhbXBsZXJcIix0aGlzLmRpZmZ1c2VUZXh0dXJlKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQyKFwidkRpZmZ1c2VJbmZvc1wiLHRoaXMuZGlmZnVzZVRleHR1cmUuY29vcmRpbmF0ZXNJbmRleCx0aGlzLmRpZmZ1c2VUZXh0dXJlLmxldmVsKSx0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwiZGlmZnVzZU1hdHJpeFwiLHRoaXMuZGlmZnVzZVRleHR1cmUuZ2V0VGV4dHVyZU1hdHJpeCgpKSx0aGlzLl9iYXNlQ29sb3IuY29weUZyb21GbG9hdHMoMSwxLDEpKSx0aGlzLmFtYmllbnRUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuQW1iaWVudFRleHR1cmVFbmFibGVkJiYodGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJhbWJpZW50U2FtcGxlclwiLHRoaXMuYW1iaWVudFRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdDIoXCJ2QW1iaWVudEluZm9zXCIsdGhpcy5hbWJpZW50VGV4dHVyZS5jb29yZGluYXRlc0luZGV4LHRoaXMuYW1iaWVudFRleHR1cmUubGV2ZWwpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJhbWJpZW50TWF0cml4XCIsdGhpcy5hbWJpZW50VGV4dHVyZS5nZXRUZXh0dXJlTWF0cml4KCkpKSx0aGlzLm9wYWNpdHlUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuT3BhY2l0eVRleHR1cmVFbmFibGVkJiYodGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJvcGFjaXR5U2FtcGxlclwiLHRoaXMub3BhY2l0eVRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdDIoXCJ2T3BhY2l0eUluZm9zXCIsdGhpcy5vcGFjaXR5VGV4dHVyZS5jb29yZGluYXRlc0luZGV4LHRoaXMub3BhY2l0eVRleHR1cmUubGV2ZWwpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJvcGFjaXR5TWF0cml4XCIsdGhpcy5vcGFjaXR5VGV4dHVyZS5nZXRUZXh0dXJlTWF0cml4KCkpKSx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuUmVmbGVjdGlvblRleHR1cmVFbmFibGVkJiYodGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5pc0N1YmU/dGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJyZWZsZWN0aW9uQ3ViZVNhbXBsZXJcIix0aGlzLnJlZmxlY3Rpb25UZXh0dXJlKTp0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcInJlZmxlY3Rpb24yRFNhbXBsZXJcIix0aGlzLnJlZmxlY3Rpb25UZXh0dXJlKSx0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwicmVmbGVjdGlvbk1hdHJpeFwiLHRoaXMucmVmbGVjdGlvblRleHR1cmUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXgoKSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MyhcInZSZWZsZWN0aW9uSW5mb3NcIix0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmNvb3JkaW5hdGVzTW9kZSx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmxldmVsLHRoaXMucmVmbGVjdGlvblRleHR1cmUuaXNDdWJlPzE6MCkpLHRoaXMuZW1pc3NpdmVUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuRW1pc3NpdmVUZXh0dXJlRW5hYmxlZCYmKHRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwiZW1pc3NpdmVTYW1wbGVyXCIsdGhpcy5lbWlzc2l2ZVRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdDIoXCJ2RW1pc3NpdmVJbmZvc1wiLHRoaXMuZW1pc3NpdmVUZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXgsdGhpcy5lbWlzc2l2ZVRleHR1cmUubGV2ZWwpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJlbWlzc2l2ZU1hdHJpeFwiLHRoaXMuZW1pc3NpdmVUZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSkpLHRoaXMuc3BlY3VsYXJUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuU3BlY3VsYXJUZXh0dXJlRW5hYmxlZCYmKHRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwic3BlY3VsYXJTYW1wbGVyXCIsdGhpcy5zcGVjdWxhclRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdDIoXCJ2U3BlY3VsYXJJbmZvc1wiLHRoaXMuc3BlY3VsYXJUZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXgsdGhpcy5zcGVjdWxhclRleHR1cmUubGV2ZWwpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJzcGVjdWxhck1hdHJpeFwiLHRoaXMuc3BlY3VsYXJUZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSkpLHRoaXMuYnVtcFRleHR1cmUmJmUuZ2V0RW5naW5lKCkuZ2V0Q2FwcygpLnN0YW5kYXJkRGVyaXZhdGl2ZXMmJmEuU3RhbmRhcmRNYXRlcmlhbC5CdW1wVGV4dHVyZUVuYWJsZWQmJih0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcImJ1bXBTYW1wbGVyXCIsdGhpcy5idW1wVGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MihcInZCdW1wSW5mb3NcIix0aGlzLmJ1bXBUZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXgsdGhpcy5idW1wVGV4dHVyZS5sZXZlbCksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcImJ1bXBNYXRyaXhcIix0aGlzLmJ1bXBUZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSkpLGUuYW1iaWVudENvbG9yLm11bHRpcGx5VG9SZWYodGhpcy5hbWJpZW50Q29sb3IsdGhpcy5fZ2xvYmFsQW1iaWVudENvbG9yKSx0aGlzLl9lZmZlY3Quc2V0VmVjdG9yMyhcInZFeWVQb3NpdGlvblwiLGUuYWN0aXZlQ2FtZXJhLnBvc2l0aW9uKSx0aGlzLl9lZmZlY3Quc2V0Q29sb3IzKFwidkFtYmllbnRDb2xvclwiLHRoaXMuX2dsb2JhbEFtYmllbnRDb2xvciksdGhpcy5fZWZmZWN0LnNldENvbG9yNChcInZEaWZmdXNlQ29sb3JcIix0aGlzLl9iYXNlQ29sb3IsdGhpcy5hbHBoYSpkLnZpc2liaWxpdHkpLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjQoXCJ2U3BlY3VsYXJDb2xvclwiLHRoaXMuc3BlY3VsYXJDb2xvcix0aGlzLnNwZWN1bGFyUG93ZXIpLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjMoXCJ2RW1pc3NpdmVDb2xvclwiLHRoaXMuZW1pc3NpdmVDb2xvciksZS5saWdodHNFbmFibGVkKWZvcih2YXIgZj0wLGc9MDtnPGUubGlnaHRzLmxlbmd0aDtnKyspe3ZhciBoPWUubGlnaHRzW2ddO2lmKGguaXNFbmFibGVkKCkmJighZHx8LTE9PT1oLmV4Y2x1ZGVkTWVzaGVzLmluZGV4T2YoZCkpKXtoIGluc3RhbmNlb2YgYS5Qb2ludExpZ2h0P2gudHJhbnNmZXJUb0VmZmVjdCh0aGlzLl9lZmZlY3QsXCJ2TGlnaHREYXRhXCIrZik6aCBpbnN0YW5jZW9mIGEuRGlyZWN0aW9uYWxMaWdodD9oLnRyYW5zZmVyVG9FZmZlY3QodGhpcy5fZWZmZWN0LFwidkxpZ2h0RGF0YVwiK2YpOmggaW5zdGFuY2VvZiBhLlNwb3RMaWdodD9oLnRyYW5zZmVyVG9FZmZlY3QodGhpcy5fZWZmZWN0LFwidkxpZ2h0RGF0YVwiK2YsXCJ2TGlnaHREaXJlY3Rpb25cIitmKTpoIGluc3RhbmNlb2YgYS5IZW1pc3BoZXJpY0xpZ2h0JiZoLnRyYW5zZmVyVG9FZmZlY3QodGhpcy5fZWZmZWN0LFwidkxpZ2h0RGF0YVwiK2YsXCJ2TGlnaHRHcm91bmRcIitmKSxoLmRpZmZ1c2Uuc2NhbGVUb1JlZihoLmludGVuc2l0eSx0aGlzLl9zY2FsZWREaWZmdXNlKSxoLnNwZWN1bGFyLnNjYWxlVG9SZWYoaC5pbnRlbnNpdHksdGhpcy5fc2NhbGVkU3BlY3VsYXIpLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjQoXCJ2TGlnaHREaWZmdXNlXCIrZix0aGlzLl9zY2FsZWREaWZmdXNlLGgucmFuZ2UpLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjMoXCJ2TGlnaHRTcGVjdWxhclwiK2YsdGhpcy5fc2NhbGVkU3BlY3VsYXIpO3ZhciBpPWguZ2V0U2hhZG93R2VuZXJhdG9yKCk7aWYoZC5yZWNlaXZlU2hhZG93cyYmaSYmKHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJsaWdodE1hdHJpeFwiK2YsaS5nZXRUcmFuc2Zvcm1NYXRyaXgoKSksdGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJzaGFkb3dTYW1wbGVyXCIrZixpLmdldFNoYWRvd01hcCgpKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQoXCJkYXJrbmVzc1wiK2YsaS5nZXREYXJrbmVzcygpKSksZisrLGY9PWIpYnJlYWt9fWlmKGUuY2xpcFBsYW5lKXt2YXIgaj1lLmNsaXBQbGFuZTt0aGlzLl9lZmZlY3Quc2V0RmxvYXQ0KFwidkNsaXBQbGFuZVwiLGoubm9ybWFsLngsai5ub3JtYWwueSxqLm5vcm1hbC56LGouZCl9KGUuZm9nTW9kZSE9PWEuU2NlbmUuRk9HTU9ERV9OT05FfHx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlKSYmdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcInZpZXdcIixlLmdldFZpZXdNYXRyaXgoKSksZS5mb2dNb2RlIT09YS5TY2VuZS5GT0dNT0RFX05PTkUmJih0aGlzLl9lZmZlY3Quc2V0RmxvYXQ0KFwidkZvZ0luZm9zXCIsZS5mb2dNb2RlLGUuZm9nU3RhcnQsZS5mb2dFbmQsZS5mb2dEZW5zaXR5KSx0aGlzLl9lZmZlY3Quc2V0Q29sb3IzKFwidkZvZ0NvbG9yXCIsZS5mb2dDb2xvcikpfSxkLnByb3RvdHlwZS5nZXRBbmltYXRhYmxlcz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLmRpZmZ1c2VUZXh0dXJlJiZ0aGlzLmRpZmZ1c2VUZXh0dXJlLmFuaW1hdGlvbnMmJnRoaXMuZGlmZnVzZVRleHR1cmUuYW5pbWF0aW9ucy5sZW5ndGg+MCYmYS5wdXNoKHRoaXMuZGlmZnVzZVRleHR1cmUpLHRoaXMuYW1iaWVudFRleHR1cmUmJnRoaXMuYW1iaWVudFRleHR1cmUuYW5pbWF0aW9ucyYmdGhpcy5hbWJpZW50VGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5hbWJpZW50VGV4dHVyZSksdGhpcy5vcGFjaXR5VGV4dHVyZSYmdGhpcy5vcGFjaXR5VGV4dHVyZS5hbmltYXRpb25zJiZ0aGlzLm9wYWNpdHlUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoPjAmJmEucHVzaCh0aGlzLm9wYWNpdHlUZXh0dXJlKSx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZ0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmFuaW1hdGlvbnMmJnRoaXMucmVmbGVjdGlvblRleHR1cmUuYW5pbWF0aW9ucy5sZW5ndGg+MCYmYS5wdXNoKHRoaXMucmVmbGVjdGlvblRleHR1cmUpLHRoaXMuZW1pc3NpdmVUZXh0dXJlJiZ0aGlzLmVtaXNzaXZlVGV4dHVyZS5hbmltYXRpb25zJiZ0aGlzLmVtaXNzaXZlVGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5lbWlzc2l2ZVRleHR1cmUpLHRoaXMuc3BlY3VsYXJUZXh0dXJlJiZ0aGlzLnNwZWN1bGFyVGV4dHVyZS5hbmltYXRpb25zJiZ0aGlzLnNwZWN1bGFyVGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5zcGVjdWxhclRleHR1cmUpLHRoaXMuYnVtcFRleHR1cmUmJnRoaXMuYnVtcFRleHR1cmUuYW5pbWF0aW9ucyYmdGhpcy5idW1wVGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5idW1wVGV4dHVyZSksYX0sZC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbihhKXt0aGlzLmRpZmZ1c2VUZXh0dXJlJiZ0aGlzLmRpZmZ1c2VUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLmFtYmllbnRUZXh0dXJlJiZ0aGlzLmFtYmllbnRUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLm9wYWNpdHlUZXh0dXJlJiZ0aGlzLm9wYWNpdHlUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZ0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLmVtaXNzaXZlVGV4dHVyZSYmdGhpcy5lbWlzc2l2ZVRleHR1cmUuZGlzcG9zZSgpLHRoaXMuc3BlY3VsYXJUZXh0dXJlJiZ0aGlzLnNwZWN1bGFyVGV4dHVyZS5kaXNwb3NlKCksdGhpcy5idW1wVGV4dHVyZSYmdGhpcy5idW1wVGV4dHVyZS5kaXNwb3NlKCksYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsYSl9LGQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhLlN0YW5kYXJkTWF0ZXJpYWwoYix0aGlzLmdldFNjZW5lKCkpO3JldHVybiBjLmNoZWNrUmVhZHlPbkV2ZXJ5Q2FsbD10aGlzLmNoZWNrUmVhZHlPbkV2ZXJ5Q2FsbCxjLmFscGhhPXRoaXMuYWxwaGEsYy53aXJlZnJhbWU9dGhpcy53aXJlZnJhbWUsYy5iYWNrRmFjZUN1bGxpbmc9dGhpcy5iYWNrRmFjZUN1bGxpbmcsdGhpcy5kaWZmdXNlVGV4dHVyZSYmdGhpcy5kaWZmdXNlVGV4dHVyZS5jbG9uZSYmKGMuZGlmZnVzZVRleHR1cmU9dGhpcy5kaWZmdXNlVGV4dHVyZS5jbG9uZSgpKSx0aGlzLmFtYmllbnRUZXh0dXJlJiZ0aGlzLmFtYmllbnRUZXh0dXJlLmNsb25lJiYoYy5hbWJpZW50VGV4dHVyZT10aGlzLmFtYmllbnRUZXh0dXJlLmNsb25lKCkpLHRoaXMub3BhY2l0eVRleHR1cmUmJnRoaXMub3BhY2l0eVRleHR1cmUuY2xvbmUmJihjLm9wYWNpdHlUZXh0dXJlPXRoaXMub3BhY2l0eVRleHR1cmUuY2xvbmUoKSksdGhpcy5yZWZsZWN0aW9uVGV4dHVyZSYmdGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5jbG9uZSYmKGMucmVmbGVjdGlvblRleHR1cmU9dGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5jbG9uZSgpKSx0aGlzLmVtaXNzaXZlVGV4dHVyZSYmdGhpcy5lbWlzc2l2ZVRleHR1cmUuY2xvbmUmJihjLmVtaXNzaXZlVGV4dHVyZT10aGlzLmVtaXNzaXZlVGV4dHVyZS5jbG9uZSgpKSx0aGlzLnNwZWN1bGFyVGV4dHVyZSYmdGhpcy5zcGVjdWxhclRleHR1cmUuY2xvbmUmJihjLnNwZWN1bGFyVGV4dHVyZT10aGlzLnNwZWN1bGFyVGV4dHVyZS5jbG9uZSgpKSx0aGlzLmJ1bXBUZXh0dXJlJiZ0aGlzLmJ1bXBUZXh0dXJlLmNsb25lJiYoYy5idW1wVGV4dHVyZT10aGlzLmJ1bXBUZXh0dXJlLmNsb25lKCkpLGMuYW1iaWVudENvbG9yPXRoaXMuYW1iaWVudENvbG9yLmNsb25lKCksYy5kaWZmdXNlQ29sb3I9dGhpcy5kaWZmdXNlQ29sb3IuY2xvbmUoKSxjLnNwZWN1bGFyQ29sb3I9dGhpcy5zcGVjdWxhckNvbG9yLmNsb25lKCksYy5zcGVjdWxhclBvd2VyPXRoaXMuc3BlY3VsYXJQb3dlcixjLmVtaXNzaXZlQ29sb3I9dGhpcy5lbWlzc2l2ZUNvbG9yLmNsb25lKCksY30sZC5EaWZmdXNlVGV4dHVyZUVuYWJsZWQ9ITAsZC5BbWJpZW50VGV4dHVyZUVuYWJsZWQ9ITAsZC5PcGFjaXR5VGV4dHVyZUVuYWJsZWQ9ITAsZC5SZWZsZWN0aW9uVGV4dHVyZUVuYWJsZWQ9ITAsZC5FbWlzc2l2ZVRleHR1cmVFbmFibGVkPSEwLGQuU3BlY3VsYXJUZXh0dXJlRW5hYmxlZD0hMCxkLkJ1bXBUZXh0dXJlRW5hYmxlZD0hMCxkfShhLk1hdGVyaWFsKTthLlN0YW5kYXJkTWF0ZXJpYWw9Y30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjKXthLmNhbGwodGhpcyxiLGMsITApLHRoaXMuc3ViTWF0ZXJpYWxzPW5ldyBBcnJheSxjLm11bHRpTWF0ZXJpYWxzLnB1c2godGhpcyl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLmdldFN1Yk1hdGVyaWFsPWZ1bmN0aW9uKGEpe3JldHVybiAwPmF8fGE+PXRoaXMuc3ViTWF0ZXJpYWxzLmxlbmd0aD90aGlzLmdldFNjZW5lKCkuZGVmYXVsdE1hdGVyaWFsOnRoaXMuc3ViTWF0ZXJpYWxzW2FdfSxiLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5zdWJNYXRlcmlhbHMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5zdWJNYXRlcmlhbHNbYl07aWYoYyYmIXRoaXMuc3ViTWF0ZXJpYWxzW2JdLmlzUmVhZHkoYSkpcmV0dXJuITF9cmV0dXJuITB9LGJ9KGEuTWF0ZXJpYWwpO2EuTXVsdGlNYXRlcmlhbD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLmlkYkZhY3Rvcnk9d2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQnx8d2luZG93Lm1zSW5kZXhlZERCLHRoaXMuY2FsbGJhY2tNYW5pZmVzdENoZWNrZWQ9Yyx0aGlzLmN1cnJlbnRTY2VuZVVybD1hLkRhdGFiYXNlLlJldHVybkZ1bGxVcmxMb2NhdGlvbihiKSx0aGlzLmRiPW51bGwsdGhpcy5lbmFibGVTY2VuZU9mZmxpbmU9ITEsdGhpcy5lbmFibGVUZXh0dXJlc09mZmxpbmU9ITEsdGhpcy5tYW5pZmVzdFZlcnNpb25Gb3VuZD0wLHRoaXMubXVzdFVwZGF0ZVJlc3NvdXJjZXM9ITEsdGhpcy5oYXNSZWFjaGVkUXVvdGE9ITEsdGhpcy5jaGVja01hbmlmZXN0RmlsZSgpfXJldHVybiBiLnByb3RvdHlwZS5jaGVja01hbmlmZXN0RmlsZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXthLlRvb2xzLkxvZyhcIlZhbGlkIG1hbmlmZXN0IGZpbGUgbm90IGZvdW5kLiBTY2VuZSAmIHRleHR1cmVzIHdpbGwgYmUgbG9hZGVkIGRpcmVjdGx5IGZyb20gdGhlIHdlYiBzZXJ2ZXIuXCIpLGQuZW5hYmxlU2NlbmVPZmZsaW5lPSExLGQuZW5hYmxlVGV4dHVyZXNPZmZsaW5lPSExLGQuY2FsbGJhY2tNYW5pZmVzdENoZWNrZWQoITEpfXZhciBjPXRoaXMsZD10aGlzLGU9dGhpcy5jdXJyZW50U2NlbmVVcmwrXCIubWFuaWZlc3RcIixmPW5ldyBYTUxIdHRwUmVxdWVzdCxnPWUrKG51bGw9PWUubWF0Y2goL1xcPy8pP1wiP1wiOlwiJlwiKSsobmV3IERhdGUpLmdldFRpbWUoKTtmLm9wZW4oXCJHRVRcIixnLCEwKSxmLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oKXtpZigyMDA9PT1mLnN0YXR1c3x8YS5Ub29scy5WYWxpZGF0ZVhIUkRhdGEoZiwxKSl0cnl7dmFyIGQ9SlNPTi5wYXJzZShmLnJlc3BvbnNlKTtjLmVuYWJsZVNjZW5lT2ZmbGluZT1kLmVuYWJsZVNjZW5lT2ZmbGluZSxjLmVuYWJsZVRleHR1cmVzT2ZmbGluZT1kLmVuYWJsZVRleHR1cmVzT2ZmbGluZSxkLnZlcnNpb24mJiFpc05hTihwYXJzZUludChkLnZlcnNpb24pKSYmKGMubWFuaWZlc3RWZXJzaW9uRm91bmQ9ZC52ZXJzaW9uKSxjLmNhbGxiYWNrTWFuaWZlc3RDaGVja2VkJiZjLmNhbGxiYWNrTWFuaWZlc3RDaGVja2VkKCEwKX1jYXRjaChlKXtiKCl9ZWxzZSBiKCl9LCExKSxmLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKCl7YigpfSwhMSk7dHJ5e2Yuc2VuZCgpfWNhdGNoKGgpe2EuVG9vbHMuRXJyb3IoXCJFcnJvciBvbiBYSFIgc2VuZCByZXF1ZXN0LlwiKSxkLmNhbGxiYWNrTWFuaWZlc3RDaGVja2VkKCExKX19LGIucHJvdG90eXBlLm9wZW5Bc3luYz1mdW5jdGlvbihiLGMpe2Z1bmN0aW9uIGQoKXtmLmlzU3VwcG9ydGVkPSExLGMmJmMoKX12YXIgZT10aGlzLGY9dGhpcztpZih0aGlzLmlkYkZhY3RvcnkmJih0aGlzLmVuYWJsZVNjZW5lT2ZmbGluZXx8dGhpcy5lbmFibGVUZXh0dXJlc09mZmxpbmUpKWlmKHRoaXMuZGIpYiYmYigpO2Vsc2V7dGhpcy5oYXNSZWFjaGVkUXVvdGE9ITEsdGhpcy5pc1N1cHBvcnRlZD0hMDt2YXIgZz10aGlzLmlkYkZhY3Rvcnkub3BlbihcImJhYnlsb25qc1wiLDEpO2cub25lcnJvcj1mdW5jdGlvbigpe2QoKX0sZy5vbmJsb2NrZWQ9ZnVuY3Rpb24oKXthLlRvb2xzLkVycm9yKFwiSURCIHJlcXVlc3QgYmxvY2tlZC4gUGxlYXNlIHJlbG9hZCB0aGUgcGFnZS5cIiksZCgpfSxnLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2UuZGI9Zy5yZXN1bHQsYigpfSxnLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihiKXtlLmRiPWIudGFyZ2V0LnJlc3VsdDt0cnl7Yi5vbGRWZXJzaW9uPjAmJihlLmRiLmRlbGV0ZU9iamVjdFN0b3JlKFwic2NlbmVzXCIpLGUuZGIuZGVsZXRlT2JqZWN0U3RvcmUoXCJ2ZXJzaW9uc1wiKSxlLmRiLmRlbGV0ZU9iamVjdFN0b3JlKFwidGV4dHVyZXNcIikpO3tlLmRiLmNyZWF0ZU9iamVjdFN0b3JlKFwic2NlbmVzXCIse2tleVBhdGg6XCJzY2VuZVVybFwifSksZS5kYi5jcmVhdGVPYmplY3RTdG9yZShcInZlcnNpb25zXCIse2tleVBhdGg6XCJzY2VuZVVybFwifSksZS5kYi5jcmVhdGVPYmplY3RTdG9yZShcInRleHR1cmVzXCIse2tleVBhdGg6XCJ0ZXh0dXJlVXJsXCJ9KX19Y2F0Y2goYyl7YS5Ub29scy5FcnJvcihcIkVycm9yIHdoaWxlIGNyZWF0aW5nIG9iamVjdCBzdG9yZXMuIEV4Y2VwdGlvbjogXCIrYy5tZXNzYWdlKSxkKCl9fX1lbHNlIHRoaXMuaXNTdXBwb3J0ZWQ9ITEsYyYmYygpfSxiLnByb3RvdHlwZS5sb2FkSW1hZ2VGcm9tREI9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLGU9YS5EYXRhYmFzZS5SZXR1cm5GdWxsVXJsTG9jYXRpb24oYiksZj1mdW5jdGlvbigpe2QuaGFzUmVhY2hlZFF1b3RhfHxudWxsPT09ZC5kYj9jLnNyYz1iOmQuX3NhdmVJbWFnZUludG9EQkFzeW5jKGUsYyl9O3RoaXMubXVzdFVwZGF0ZVJlc3NvdXJjZXM/ZigpOnRoaXMuX2xvYWRJbWFnZUZyb21EQkFzeW5jKGUsYyxmKX0sYi5wcm90b3R5cGUuX2xvYWRJbWFnZUZyb21EQkFzeW5jPWZ1bmN0aW9uKGIsYyxkKXtpZih0aGlzLmlzU3VwcG9ydGVkJiZudWxsIT09dGhpcy5kYil7dmFyIGUsZj10aGlzLmRiLnRyYW5zYWN0aW9uKFtcInRleHR1cmVzXCJdKTtmLm9uYWJvcnQ9ZnVuY3Rpb24oKXtjLnNyYz1ifSxmLm9uY29tcGxldGU9ZnVuY3Rpb24oKXt2YXIgZjtpZihlKXt2YXIgZz13aW5kb3cuVVJMfHx3aW5kb3cud2Via2l0VVJMO2Y9Zy5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLHtvbmVUaW1lT25seTohMH0pLGMub25lcnJvcj1mdW5jdGlvbigpe2EuVG9vbHMuRXJyb3IoXCJFcnJvciBsb2FkaW5nIGltYWdlIGZyb20gYmxvYiBVUkw6IFwiK2YrXCIgc3dpdGNoaW5nIGJhY2sgdG8gd2ViIHVybDogXCIrYiksYy5zcmM9Yn0sYy5zcmM9Zn1lbHNlIGQoKX07dmFyIGc9Zi5vYmplY3RTdG9yZShcInRleHR1cmVzXCIpLmdldChiKTtnLm9uc3VjY2Vzcz1mdW5jdGlvbihhKXtlPWEudGFyZ2V0LnJlc3VsdH0sZy5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGxvYWRpbmcgdGV4dHVyZSBcIitiK1wiIGZyb20gREIuXCIpLGMuc3JjPWJ9fWVsc2UgYS5Ub29scy5FcnJvcihcIkVycm9yOiBJbmRleGVkREIgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIgb3IgQmFieWxvbkpTIERhdGFiYXNlIGlzIG5vdCBvcGVuLlwiKSxjLnNyYz1ifSxiLnByb3RvdHlwZS5fc2F2ZUltYWdlSW50b0RCQXN5bmM9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzO2lmKHRoaXMuaXNTdXBwb3J0ZWQpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIGE7aWYoZil7dmFyIGI9d2luZG93LlVSTHx8d2luZG93LndlYmtpdFVSTDt0cnl7YT1iLmNyZWF0ZU9iamVjdFVSTChmLHtvbmVUaW1lT25seTohMH0pfWNhdGNoKGQpe2E9Yi5jcmVhdGVPYmplY3RVUkwoZil9fWMuc3JjPWF9O2lmKGEuRGF0YWJhc2UuaXNVQVN1cHBvcnRpbmdCbG9iU3RvcmFnZSl7dmFyIGYsZz1uZXcgWE1MSHR0cFJlcXVlc3Q7Zy5vcGVuKFwiR0VUXCIsYiwhMCksZy5yZXNwb25zZVR5cGU9XCJibG9iXCIsZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7aWYoMjAwPT09Zy5zdGF0dXMpe2Y9Zy5yZXNwb25zZTt2YXIgaD1kLmRiLnRyYW5zYWN0aW9uKFtcInRleHR1cmVzXCJdLFwicmVhZHdyaXRlXCIpO2gub25hYm9ydD1mdW5jdGlvbihhKXt0cnl7XCJRdW90YUV4Y2VlZGVkRXJyb3JcIj09PWEuc3JjRWxlbWVudC5lcnJvci5uYW1lJiYodGhpcy5oYXNSZWFjaGVkUXVvdGE9ITApfWNhdGNoKGIpe31lKCl9LGgub25jb21wbGV0ZT1mdW5jdGlvbigpe2UoKX07dmFyIGk9e3RleHR1cmVVcmw6YixkYXRhOmZ9O3RyeXt2YXIgaj1oLm9iamVjdFN0b3JlKFwidGV4dHVyZXNcIikucHV0KGkpO2oub25zdWNjZXNzPWZ1bmN0aW9uKCl7fSxqLm9uZXJyb3I9ZnVuY3Rpb24oKXtlKCl9fWNhdGNoKGspezI1PT09ay5jb2RlJiYoYS5EYXRhYmFzZS5pc1VBU3VwcG9ydGluZ0Jsb2JTdG9yYWdlPSExKSxjLnNyYz1ifX1lbHNlIGMuc3JjPWJ9LCExKSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGluIFhIUiByZXF1ZXN0IGluIEJBQllMT04uRGF0YWJhc2UuXCIpLGMuc3JjPWJ9LCExKSxnLnNlbmQoKX1lbHNlIGMuc3JjPWJ9ZWxzZSBhLlRvb2xzLkVycm9yKFwiRXJyb3I6IEluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBCYWJ5bG9uSlMgRGF0YWJhc2UgaXMgbm90IG9wZW4uXCIpLGMuc3JjPWJ9LGIucHJvdG90eXBlLl9jaGVja1ZlcnNpb25Gcm9tREI9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9ZnVuY3Rpb24oKXtjLl9zYXZlVmVyc2lvbkludG9EQkFzeW5jKGEsYil9O3RoaXMuX2xvYWRWZXJzaW9uRnJvbURCQXN5bmMoYSxiLGQpfSxiLnByb3RvdHlwZS5fbG9hZFZlcnNpb25Gcm9tREJBc3luYz1mdW5jdGlvbihiLGMsZCl7dmFyIGU9dGhpcztpZih0aGlzLmlzU3VwcG9ydGVkKXt2YXIgZjt0cnl7dmFyIGc9dGhpcy5kYi50cmFuc2FjdGlvbihbXCJ2ZXJzaW9uc1wiXSk7Zy5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7Zj9lLm1hbmlmZXN0VmVyc2lvbkZvdW5kPmYuZGF0YT8oZS5tdXN0VXBkYXRlUmVzc291cmNlcz0hMCxkKCkpOmMoZi5kYXRhKTooZS5tdXN0VXBkYXRlUmVzc291cmNlcz0hMCxkKCkpfSxnLm9uYWJvcnQ9ZnVuY3Rpb24oKXtjKC0xKX07dmFyIGg9Zy5vYmplY3RTdG9yZShcInZlcnNpb25zXCIpLmdldChiKTtoLm9uc3VjY2Vzcz1mdW5jdGlvbihhKXtmPWEudGFyZ2V0LnJlc3VsdH0saC5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGxvYWRpbmcgdmVyc2lvbiBmb3Igc2NlbmUgXCIrYitcIiBmcm9tIERCLlwiKSxjKC0xKX19Y2F0Y2goaSl7YS5Ub29scy5FcnJvcihcIkVycm9yIHdoaWxlIGFjY2Vzc2luZyAndmVyc2lvbnMnIG9iamVjdCBzdG9yZSAoUkVBRCBPUCkuIEV4Y2VwdGlvbjogXCIraS5tZXNzYWdlKSxjKC0xKX19ZWxzZSBhLlRvb2xzLkVycm9yKFwiRXJyb3I6IEluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBCYWJ5bG9uSlMgRGF0YWJhc2UgaXMgbm90IG9wZW4uXCIpLGMoLTEpfSxiLnByb3RvdHlwZS5fc2F2ZVZlcnNpb25JbnRvREJBc3luYz1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXM7aWYodGhpcy5pc1N1cHBvcnRlZCYmIXRoaXMuaGFzUmVhY2hlZFF1b3RhKXRyeXt2YXIgZT10aGlzLmRiLnRyYW5zYWN0aW9uKFtcInZlcnNpb25zXCJdLFwicmVhZHdyaXRlXCIpO2Uub25hYm9ydD1mdW5jdGlvbihhKXt0cnl7XCJRdW90YUV4Y2VlZGVkRXJyb3JcIj09PWEuc3JjRWxlbWVudC5lcnJvci5uYW1lJiYoZC5oYXNSZWFjaGVkUXVvdGE9ITApfWNhdGNoKGIpe31jKC0xKX0sZS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7YyhkLm1hbmlmZXN0VmVyc2lvbkZvdW5kKX07dmFyIGY9e3NjZW5lVXJsOmIsZGF0YTp0aGlzLm1hbmlmZXN0VmVyc2lvbkZvdW5kfSxnPWUub2JqZWN0U3RvcmUoXCJ2ZXJzaW9uc1wiKS5wdXQoZik7Zy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt9LGcub25lcnJvcj1mdW5jdGlvbigpe2EuVG9vbHMuRXJyb3IoXCJFcnJvciBpbiBEQiBhZGQgdmVyc2lvbiByZXF1ZXN0IGluIEJBQllMT04uRGF0YWJhc2UuXCIpfX1jYXRjaChoKXthLlRvb2xzLkVycm9yKFwiRXJyb3Igd2hpbGUgYWNjZXNzaW5nICd2ZXJzaW9ucycgb2JqZWN0IHN0b3JlIChXUklURSBPUCkuIEV4Y2VwdGlvbjogXCIraC5tZXNzYWdlKSxjKC0xKX1lbHNlIGMoLTEpfSxiLnByb3RvdHlwZS5sb2FkRmlsZUZyb21EQj1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPXRoaXMsaD1hLkRhdGFiYXNlLlJldHVybkZ1bGxVcmxMb2NhdGlvbihiKSxpPWZ1bmN0aW9uKCl7Zy5fc2F2ZUZpbGVJbnRvREJBc3luYyhoLGMsZCl9O3RoaXMuX2NoZWNrVmVyc2lvbkZyb21EQihoLGZ1bmN0aW9uKGEpey0xIT09YT9nLm11c3RVcGRhdGVSZXNzb3VyY2VzP2cuX3NhdmVGaWxlSW50b0RCQXN5bmMoaCxjLGQsZik6Zy5fbG9hZEZpbGVGcm9tREJBc3luYyhoLGMsaSxmKTplKCl9KX0sYi5wcm90b3R5cGUuX2xvYWRGaWxlRnJvbURCQXN5bmM9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMuaXNTdXBwb3J0ZWQpe3ZhciBlO2U9LTEhPT1iLmluZGV4T2YoXCIuYmFieWxvblwiKT9cInNjZW5lc1wiOlwidGV4dHVyZXNcIjt2YXIgZixnPXRoaXMuZGIudHJhbnNhY3Rpb24oW2VdKTtnLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtmP2MoZi5kYXRhKTpkKCl9LGcub25hYm9ydD1mdW5jdGlvbigpe2QoKX07dmFyIGg9Zy5vYmplY3RTdG9yZShlKS5nZXQoYik7aC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYSl7Zj1hLnRhcmdldC5yZXN1bHR9LGgub25lcnJvcj1mdW5jdGlvbigpe2EuVG9vbHMuRXJyb3IoXCJFcnJvciBsb2FkaW5nIGZpbGUgXCIrYitcIiBmcm9tIERCLlwiKSxkKCl9fWVsc2UgYS5Ub29scy5FcnJvcihcIkVycm9yOiBJbmRleGVkREIgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIgb3IgQmFieWxvbkpTIERhdGFiYXNlIGlzIG5vdCBvcGVuLlwiKSxjKCl9LGIucHJvdG90eXBlLl9zYXZlRmlsZUludG9EQkFzeW5jPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPXRoaXM7aWYodGhpcy5pc1N1cHBvcnRlZCl7dmFyIGc7Zz0tMSE9PWIuaW5kZXhPZihcIi5iYWJ5bG9uXCIpP1wic2NlbmVzXCI6XCJ0ZXh0dXJlc1wiO3ZhciBoLGk9bmV3IFhNTEh0dHBSZXF1ZXN0O2kub3BlbihcIkdFVFwiLGIsITApLGUmJihpLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIpLGkub25wcm9ncmVzcz1kLGkuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe2lmKDIwMD09PWkuc3RhdHVzfHxhLlRvb2xzLlZhbGlkYXRlWEhSRGF0YShpLGU/NjoxKSlpZihoPWU/aS5yZXNwb25zZTppLnJlc3BvbnNlVGV4dCxmLmhhc1JlYWNoZWRRdW90YSljKGgpO2Vsc2V7dmFyIGQ9Zi5kYi50cmFuc2FjdGlvbihbZ10sXCJyZWFkd3JpdGVcIik7ZC5vbmFib3J0PWZ1bmN0aW9uKGEpe3RyeXtcIlF1b3RhRXhjZWVkZWRFcnJvclwiPT09YS5zcmNFbGVtZW50LmVycm9yLm5hbWUmJih0aGlzLmhhc1JlYWNoZWRRdW90YT0hMCl9Y2F0Y2goYil7fWMoaCl9LGQub25jb21wbGV0ZT1mdW5jdGlvbigpe2MoaCl9O3ZhciBqO2o9XCJzY2VuZXNcIj09PWc/e3NjZW5lVXJsOmIsZGF0YTpoLHZlcnNpb246Zi5tYW5pZmVzdFZlcnNpb25Gb3VuZH06e3RleHR1cmVVcmw6YixkYXRhOmh9O3RyeXt2YXIgaz1kLm9iamVjdFN0b3JlKGcpLnB1dChqKTtrLm9uc3VjY2Vzcz1mdW5jdGlvbigpe30say5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGluIERCIGFkZCBmaWxlIHJlcXVlc3QgaW4gQkFCWUxPTi5EYXRhYmFzZS5cIil9fWNhdGNoKGwpe2MoaCl9fWVsc2UgYygpfSwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbigpe2EuVG9vbHMuRXJyb3IoXCJlcnJvciBvbiBYSFIgcmVxdWVzdC5cIiksYygpfSwhMSksaS5zZW5kKCl9ZWxzZSBhLlRvb2xzLkVycm9yKFwiRXJyb3I6IEluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBCYWJ5bG9uSlMgRGF0YWJhc2UgaXMgbm90IG9wZW4uXCIpLGMoKX0sYi5pc1VBU3VwcG9ydGluZ0Jsb2JTdG9yYWdlPSEwLGIucGFyc2VVUkw9ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7Yi5ocmVmPWE7dmFyIGM9YS5zdWJzdHJpbmcoYS5sYXN0SW5kZXhPZihcIi9cIikrMSxhLmxlbmd0aCksZD1hLnN1YnN0cmluZygwLGEuaW5kZXhPZihjLDApKTtyZXR1cm4gZH0sYi5SZXR1cm5GdWxsVXJsTG9jYXRpb249ZnVuY3Rpb24oYil7cmV0dXJuLTE9PT1iLmluZGV4T2YoXCJodHRwOi9cIik/YS5EYXRhYmFzZS5wYXJzZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikrYjpifSxifSgpO2EuRGF0YWJhc2U9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnKXt0aGlzLm5hbWU9Yix0aGlzLmNlbGxTaXplPWUsdGhpcy5zcHJpdGVzPW5ldyBBcnJheSx0aGlzLnJlbmRlcmluZ0dyb3VwSWQ9MCx0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbj1bMyw0LDQsNF0sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZT02MCx0aGlzLl9jYXBhY2l0eT1kLHRoaXMuX3Nwcml0ZVRleHR1cmU9bmV3IGEuVGV4dHVyZShjLGYsITAsITEpLHRoaXMuX3Nwcml0ZVRleHR1cmUud3JhcFU9YS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFLHRoaXMuX3Nwcml0ZVRleHR1cmUud3JhcFY9YS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFLHRoaXMuX2Vwc2lsb249dm9pZCAwPT09Zz8uMDE6Zyx0aGlzLl9zY2VuZT1mLHRoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzLnB1c2godGhpcyksdGhpcy5fdmVydGV4RGVjbGFyYXRpb249WzMsNCw0LDRdLHRoaXMuX3ZlcnRleFN0cmlkZVNpemU9NjAsdGhpcy5fdmVydGV4QnVmZmVyPWYuZ2V0RW5naW5lKCkuY3JlYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcihkKnRoaXMuX3ZlcnRleFN0cmlkZVNpemUqNCk7Zm9yKHZhciBoPVtdLGk9MCxqPTA7ZD5qO2orKyloLnB1c2goaSksaC5wdXNoKGkrMSksaC5wdXNoKGkrMiksaC5wdXNoKGkpLGgucHVzaChpKzIpLGgucHVzaChpKzMpLGkrPTQ7dGhpcy5faW5kZXhCdWZmZXI9Zi5nZXRFbmdpbmUoKS5jcmVhdGVJbmRleEJ1ZmZlcihoKSx0aGlzLl92ZXJ0aWNlcz1uZXcgRmxvYXQzMkFycmF5KGQqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSksdGhpcy5fZWZmZWN0QmFzZT10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5jcmVhdGVFZmZlY3QoXCJzcHJpdGVzXCIsW1wicG9zaXRpb25cIixcIm9wdGlvbnNcIixcImNlbGxJbmZvXCIsXCJjb2xvclwiXSxbXCJ2aWV3XCIsXCJwcm9qZWN0aW9uXCIsXCJ0ZXh0dXJlSW5mb3NcIixcImFscGhhVGVzdFwiXSxbXCJkaWZmdXNlU2FtcGxlclwiXSxcIlwiKSx0aGlzLl9lZmZlY3RGb2c9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlRWZmZWN0KFwic3ByaXRlc1wiLFtcInBvc2l0aW9uXCIsXCJvcHRpb25zXCIsXCJjZWxsSW5mb1wiLFwiY29sb3JcIl0sW1widmlld1wiLFwicHJvamVjdGlvblwiLFwidGV4dHVyZUluZm9zXCIsXCJhbHBoYVRlc3RcIixcInZGb2dJbmZvc1wiLFwidkZvZ0NvbG9yXCJdLFtcImRpZmZ1c2VTYW1wbGVyXCJdLFwiI2RlZmluZSBGT0dcIil9cmV0dXJuIGIucHJvdG90eXBlLl9hcHBlbmRTcHJpdGVWZXJ0ZXg9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj0xNSphOzA9PWM/Yz10aGlzLl9lcHNpbG9uOjE9PWMmJihjPTEtdGhpcy5fZXBzaWxvbiksMD09ZD9kPXRoaXMuX2Vwc2lsb246MT09ZCYmKGQ9MS10aGlzLl9lcHNpbG9uKSx0aGlzLl92ZXJ0aWNlc1tmXT1iLnBvc2l0aW9uLngsdGhpcy5fdmVydGljZXNbZisxXT1iLnBvc2l0aW9uLnksdGhpcy5fdmVydGljZXNbZisyXT1iLnBvc2l0aW9uLnosdGhpcy5fdmVydGljZXNbZiszXT1iLmFuZ2xlLHRoaXMuX3ZlcnRpY2VzW2YrNF09Yi5zaXplLHRoaXMuX3ZlcnRpY2VzW2YrNV09Yyx0aGlzLl92ZXJ0aWNlc1tmKzZdPWQsdGhpcy5fdmVydGljZXNbZis3XT1iLmludmVydFU/MTowLHRoaXMuX3ZlcnRpY2VzW2YrOF09Yi5pbnZlcnRWPzE6MDt2YXIgZz1iLmNlbGxJbmRleC9lPj4wO3RoaXMuX3ZlcnRpY2VzW2YrOV09Yi5jZWxsSW5kZXgtZyplLHRoaXMuX3ZlcnRpY2VzW2YrMTBdPWcsdGhpcy5fdmVydGljZXNbZisxMV09Yi5jb2xvci5yLHRoaXMuX3ZlcnRpY2VzW2YrMTJdPWIuY29sb3IuZyx0aGlzLl92ZXJ0aWNlc1tmKzEzXT1iLmNvbG9yLmIsdGhpcy5fdmVydGljZXNbZisxNF09Yi5jb2xvci5hfSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtpZih0aGlzLl9lZmZlY3RCYXNlLmlzUmVhZHkoKSYmdGhpcy5fZWZmZWN0Rm9nLmlzUmVhZHkoKSYmdGhpcy5fc3ByaXRlVGV4dHVyZSYmdGhpcy5fc3ByaXRlVGV4dHVyZS5pc1JlYWR5KCkpe2Zvcih2YXIgYj10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKSxjPXRoaXMuX3Nwcml0ZVRleHR1cmUuZ2V0QmFzZVNpemUoKSxkPWEuVG9vbHMuR2V0RGVsdGFUaW1lKCksZT1NYXRoLm1pbih0aGlzLl9jYXBhY2l0eSx0aGlzLnNwcml0ZXMubGVuZ3RoKSxmPWMud2lkdGgvdGhpcy5jZWxsU2l6ZSxnPTAsaD0wO2U+aDtoKyspe3ZhciBpPXRoaXMuc3ByaXRlc1toXTtpJiYoaS5fYW5pbWF0ZShkKSx0aGlzLl9hcHBlbmRTcHJpdGVWZXJ0ZXgoZysrLGksMCwwLGYpLHRoaXMuX2FwcGVuZFNwcml0ZVZlcnRleChnKyssaSwxLDAsZiksdGhpcy5fYXBwZW5kU3ByaXRlVmVydGV4KGcrKyxpLDEsMSxmKSx0aGlzLl9hcHBlbmRTcHJpdGVWZXJ0ZXgoZysrLGksMCwxLGYpKX1iLnVwZGF0ZUR5bmFtaWNWZXJ0ZXhCdWZmZXIodGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX3ZlcnRpY2VzLGUqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSk7dmFyIGo9dGhpcy5fZWZmZWN0QmFzZTt0aGlzLl9zY2VuZS5mb2dNb2RlIT09YS5TY2VuZS5GT0dNT0RFX05PTkUmJihqPXRoaXMuX2VmZmVjdEZvZyksYi5lbmFibGVFZmZlY3Qoaik7dmFyIGs9dGhpcy5fc2NlbmUuZ2V0Vmlld01hdHJpeCgpO2ouc2V0VGV4dHVyZShcImRpZmZ1c2VTYW1wbGVyXCIsdGhpcy5fc3ByaXRlVGV4dHVyZSksai5zZXRNYXRyaXgoXCJ2aWV3XCIsayksai5zZXRNYXRyaXgoXCJwcm9qZWN0aW9uXCIsdGhpcy5fc2NlbmUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKSxqLnNldEZsb2F0MihcInRleHR1cmVJbmZvc1wiLHRoaXMuY2VsbFNpemUvYy53aWR0aCx0aGlzLmNlbGxTaXplL2MuaGVpZ2h0KSx0aGlzLl9zY2VuZS5mb2dNb2RlIT09YS5TY2VuZS5GT0dNT0RFX05PTkUmJihqLnNldEZsb2F0NChcInZGb2dJbmZvc1wiLHRoaXMuX3NjZW5lLmZvZ01vZGUsdGhpcy5fc2NlbmUuZm9nU3RhcnQsdGhpcy5fc2NlbmUuZm9nRW5kLHRoaXMuX3NjZW5lLmZvZ0RlbnNpdHkpLGouc2V0Q29sb3IzKFwidkZvZ0NvbG9yXCIsdGhpcy5fc2NlbmUuZm9nQ29sb3IpKSxiLmJpbmRCdWZmZXJzKHRoaXMuX3ZlcnRleEJ1ZmZlcix0aGlzLl9pbmRleEJ1ZmZlcix0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbix0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplLGopLGouc2V0Qm9vbChcImFscGhhVGVzdFwiLCEwKSxiLnNldENvbG9yV3JpdGUoITEpLGIuZHJhdyghMCwwLDYqZSksYi5zZXRDb2xvcldyaXRlKCEwKSxqLnNldEJvb2woXCJhbHBoYVRlc3RcIiwhMSksYi5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfQ09NQklORSksYi5kcmF3KCEwLDAsNiplKSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9ESVNBQkxFKX19LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1udWxsKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKSx0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKSx0aGlzLl9zcHJpdGVUZXh0dXJlJiYodGhpcy5fc3ByaXRlVGV4dHVyZS5kaXNwb3NlKCksdGhpcy5fc3ByaXRlVGV4dHVyZT1udWxsKTt2YXIgYT10aGlzLl9zY2VuZS5zcHJpdGVNYW5hZ2Vycy5pbmRleE9mKHRoaXMpO3RoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzLnNwbGljZShhLDEpLHRoaXMub25EaXNwb3NlJiZ0aGlzLm9uRGlzcG9zZSgpfSxifSgpO2EuU3ByaXRlTWFuYWdlcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLm5hbWU9Yix0aGlzLmNvbG9yPW5ldyBhLkNvbG9yNCgxLDEsMSwxKSx0aGlzLnNpemU9MSx0aGlzLmFuZ2xlPTAsdGhpcy5jZWxsSW5kZXg9MCx0aGlzLmludmVydFU9MCx0aGlzLmludmVydFY9MCx0aGlzLmFuaW1hdGlvbnM9bmV3IEFycmF5LHRoaXMuX2FuaW1hdGlvblN0YXJ0ZWQ9ITEsdGhpcy5fbG9vcEFuaW1hdGlvbj0hMSx0aGlzLl9mcm9tSW5kZXg9MCx0aGlzLl90b0luZGV4PTAsdGhpcy5fZGVsYXk9MCx0aGlzLl9kaXJlY3Rpb249MSx0aGlzLl9mcmFtZUNvdW50PTAsdGhpcy5fdGltZT0wLHRoaXMuX21hbmFnZXI9Yyx0aGlzLl9tYW5hZ2VyLnNwcml0ZXMucHVzaCh0aGlzKSx0aGlzLnBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCl9cmV0dXJuIGIucHJvdG90eXBlLnBsYXlBbmltYXRpb249ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5fZnJvbUluZGV4PWEsdGhpcy5fdG9JbmRleD1iLHRoaXMuX2xvb3BBbmltYXRpb249Yyx0aGlzLl9kZWxheT1kLHRoaXMuX2FuaW1hdGlvblN0YXJ0ZWQ9ITAsdGhpcy5fZGlyZWN0aW9uPWI+YT8xOi0xLHRoaXMuY2VsbEluZGV4PWEsdGhpcy5fdGltZT0wfSxiLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uPWZ1bmN0aW9uKCl7dGhpcy5fYW5pbWF0aW9uU3RhcnRlZD0hMX0sYi5wcm90b3R5cGUuX2FuaW1hdGU9ZnVuY3Rpb24oYSl7dGhpcy5fYW5pbWF0aW9uU3RhcnRlZCYmKHRoaXMuX3RpbWUrPWEsdGhpcy5fdGltZT50aGlzLl9kZWxheSYmKHRoaXMuX3RpbWU9dGhpcy5fdGltZSV0aGlzLl9kZWxheSx0aGlzLmNlbGxJbmRleCs9dGhpcy5fZGlyZWN0aW9uLHRoaXMuY2VsbEluZGV4PT10aGlzLl90b0luZGV4JiYodGhpcy5fbG9vcEFuaW1hdGlvbj90aGlzLmNlbGxJbmRleD10aGlzLl9mcm9tSW5kZXg6KHRoaXMuX2FuaW1hdGlvblN0YXJ0ZWQ9ITEsdGhpcy5kaXNwb3NlV2hlbkZpbmlzaGVkQW5pbWF0aW5nJiZ0aGlzLmRpc3Bvc2UoKSkpKSl9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuX21hbmFnZXIuc3ByaXRlcy5sZW5ndGg7YSsrKXRoaXMuX21hbmFnZXIuc3ByaXRlc1thXT09dGhpcyYmdGhpcy5fbWFuYWdlci5zcHJpdGVzLnNwbGljZShhLDEpfSxifSgpO2EuU3ByaXRlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlLGYpe3RoaXMubmFtZT1iLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uPVsyXSx0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplPTgsdGhpcy50ZXh0dXJlPWM/bmV3IGEuVGV4dHVyZShjLGQsITApOm51bGwsdGhpcy5pc0JhY2tncm91bmQ9dm9pZCAwPT09ZT8hMDplLHRoaXMuY29sb3I9dm9pZCAwPT09Zj9uZXcgYS5Db2xvcjQoMSwxLDEsMSk6Zix0aGlzLl9zY2VuZT1kLHRoaXMuX3NjZW5lLmxheWVycy5wdXNoKHRoaXMpO3ZhciBnPVtdO2cucHVzaCgxLDEpLGcucHVzaCgtMSwxKSxnLnB1c2goLTEsLTEpLGcucHVzaCgxLC0xKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9ZC5nZXRFbmdpbmUoKS5jcmVhdGVWZXJ0ZXhCdWZmZXIoZyk7dmFyIGg9W107aC5wdXNoKDApLGgucHVzaCgxKSxoLnB1c2goMiksaC5wdXNoKDApLGgucHVzaCgyKSxoLnB1c2goMyksdGhpcy5faW5kZXhCdWZmZXI9ZC5nZXRFbmdpbmUoKS5jcmVhdGVJbmRleEJ1ZmZlcihoKSx0aGlzLl9lZmZlY3Q9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlRWZmZWN0KFwibGF5ZXJcIixbXCJwb3NpdGlvblwiXSxbXCJ0ZXh0dXJlTWF0cml4XCIsXCJjb2xvclwiXSxbXCJ0ZXh0dXJlU2FtcGxlclwiXSxcIlwiKX1yZXR1cm4gYi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7aWYodGhpcy5fZWZmZWN0LmlzUmVhZHkoKSYmdGhpcy50ZXh0dXJlJiZ0aGlzLnRleHR1cmUuaXNSZWFkeSgpKXt2YXIgYj10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtiLmVuYWJsZUVmZmVjdCh0aGlzLl9lZmZlY3QpLGIuc2V0U3RhdGUoITEpLHRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwidGV4dHVyZVNhbXBsZXJcIix0aGlzLnRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJ0ZXh0dXJlTWF0cml4XCIsdGhpcy50ZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSksdGhpcy5fZWZmZWN0LnNldEZsb2F0NChcImNvbG9yXCIsdGhpcy5jb2xvci5yLHRoaXMuY29sb3IuZyx0aGlzLmNvbG9yLmIsdGhpcy5jb2xvci5hKSxiLmJpbmRCdWZmZXJzKHRoaXMuX3ZlcnRleEJ1ZmZlcix0aGlzLl9pbmRleEJ1ZmZlcix0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbix0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplLHRoaXMuX2VmZmVjdCksYi5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfQ09NQklORSksYi5kcmF3KCEwLDAsNiksYi5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfRElTQUJMRSl9fSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fdmVydGV4QnVmZmVyJiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5fdmVydGV4QnVmZmVyKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9bnVsbCksdGhpcy5faW5kZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5faW5kZXhCdWZmZXI9bnVsbCksdGhpcy50ZXh0dXJlJiYodGhpcy50ZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmU9bnVsbCk7dmFyIGE9dGhpcy5fc2NlbmUubGF5ZXJzLmluZGV4T2YodGhpcyk7dGhpcy5fc2NlbmUubGF5ZXJzLnNwbGljZShhLDEpLHRoaXMub25EaXNwb3NlJiZ0aGlzLm9uRGlzcG9zZSgpfSxifSgpO2EuTGF5ZXI9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7dGhpcy5wb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuZGlyZWN0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5jb2xvcj1uZXcgYS5Db2xvcjQoMCwwLDAsMCksdGhpcy5jb2xvclN0ZXA9bmV3IGEuQ29sb3I0KDAsMCwwLDApLHRoaXMubGlmZVRpbWU9MSx0aGlzLmFnZT0wLHRoaXMuc2l6ZT0wLHRoaXMuYW5nbGU9MCx0aGlzLmFuZ3VsYXJTcGVlZD0wfXJldHVybiBifSgpO2EuUGFydGljbGU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSxiKXtpZihhPT1iKXJldHVybiBhO3ZhciBjPU1hdGgucmFuZG9tKCk7cmV0dXJuIGMqKGItYSkrYX0sYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGMoYyxkLGUsZil7dmFyIGc9dGhpczt0aGlzLm5hbWU9Yyx0aGlzLmZyYWdtZW50RWxlbWVudD1mLHRoaXMucmVuZGVyaW5nR3JvdXBJZD0wLHRoaXMuZW1pdHRlcj1udWxsLHRoaXMuZW1pdFJhdGU9MTAsdGhpcy5tYW51YWxFbWl0Q291bnQ9LTEsdGhpcy51cGRhdGVTcGVlZD0uMDEsdGhpcy50YXJnZXRTdG9wRHVyYXRpb249MCx0aGlzLmRpc3Bvc2VPblN0b3A9ITEsdGhpcy5taW5FbWl0UG93ZXI9MSx0aGlzLm1heEVtaXRQb3dlcj0xLHRoaXMubWluTGlmZVRpbWU9MSx0aGlzLm1heExpZmVUaW1lPTEsdGhpcy5taW5TaXplPTEsdGhpcy5tYXhTaXplPTEsdGhpcy5taW5Bbmd1bGFyU3BlZWQ9MCx0aGlzLm1heEFuZ3VsYXJTcGVlZD0wLHRoaXMuYmxlbmRNb2RlPWEuUGFydGljbGVTeXN0ZW0uQkxFTkRNT0RFX09ORU9ORSx0aGlzLmZvcmNlRGVwdGhXcml0ZT0hMSx0aGlzLmdyYXZpdHk9YS5WZWN0b3IzLlplcm8oKSx0aGlzLmRpcmVjdGlvbjE9bmV3IGEuVmVjdG9yMygwLDEsMCksdGhpcy5kaXJlY3Rpb24yPW5ldyBhLlZlY3RvcjMoMCwxLDApLHRoaXMubWluRW1pdEJveD1uZXcgYS5WZWN0b3IzKC0uNSwtLjUsLS41KSx0aGlzLm1heEVtaXRCb3g9bmV3IGEuVmVjdG9yMyguNSwuNSwuNSksdGhpcy5jb2xvcjE9bmV3IGEuQ29sb3I0KDEsMSwxLDEpLHRoaXMuY29sb3IyPW5ldyBhLkNvbG9yNCgxLDEsMSwxKSx0aGlzLmNvbG9yRGVhZD1uZXcgYS5Db2xvcjQoMCwwLDAsMSksdGhpcy50ZXh0dXJlTWFzaz1uZXcgYS5Db2xvcjQoMSwxLDEsMSksdGhpcy5wYXJ0aWNsZXM9bmV3IEFycmF5LHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uPVszLDQsNF0sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZT00NCx0aGlzLl9zdG9ja1BhcnRpY2xlcz1uZXcgQXJyYXksdGhpcy5fbmV3UGFydHNFeGNlc3M9MCx0aGlzLl9zY2FsZWRDb2xvclN0ZXA9bmV3IGEuQ29sb3I0KDAsMCwwLDApLHRoaXMuX2NvbG9yRGlmZj1uZXcgYS5Db2xvcjQoMCwwLDAsMCksdGhpcy5fc2NhbGVkRGlyZWN0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fc2NhbGVkR3Jhdml0eT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2N1cnJlbnRSZW5kZXJJZD0tMSx0aGlzLl9zdGFydGVkPSExLHRoaXMuX3N0b3BwZWQ9ITEsdGhpcy5fYWN0dWFsRnJhbWU9MCx0aGlzLmlkPWMsdGhpcy5fY2FwYWNpdHk9ZCx0aGlzLl9zY2VuZT1lLGUucGFydGljbGVTeXN0ZW1zLnB1c2godGhpcyksdGhpcy5fdmVydGV4QnVmZmVyPWUuZ2V0RW5naW5lKCkuY3JlYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcihkKnRoaXMuX3ZlcnRleFN0cmlkZVNpemUqNCk7Zm9yKHZhciBoPVtdLGk9MCxqPTA7ZD5qO2orKyloLnB1c2goaSksaC5wdXNoKGkrMSksaC5wdXNoKGkrMiksaC5wdXNoKGkpLGgucHVzaChpKzIpLGgucHVzaChpKzMpLGkrPTQ7dGhpcy5faW5kZXhCdWZmZXI9ZS5nZXRFbmdpbmUoKS5jcmVhdGVJbmRleEJ1ZmZlcihoKSx0aGlzLl92ZXJ0aWNlcz1uZXcgRmxvYXQzMkFycmF5KGQqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSksdGhpcy5zdGFydERpcmVjdGlvbkZ1bmN0aW9uPWZ1bmN0aW9uKGMsZCxlKXt2YXIgZj1iKGcuZGlyZWN0aW9uMS54LGcuZGlyZWN0aW9uMi54KSxoPWIoZy5kaXJlY3Rpb24xLnksZy5kaXJlY3Rpb24yLnkpLGk9YihnLmRpcmVjdGlvbjEueixnLmRpcmVjdGlvbjIueik7XG5hLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsRnJvbUZsb2F0c1RvUmVmKGYqYyxoKmMsaSpjLGQsZSl9LHRoaXMuc3RhcnRQb3NpdGlvbkZ1bmN0aW9uPWZ1bmN0aW9uKGMsZCl7dmFyIGU9YihnLm1pbkVtaXRCb3gueCxnLm1heEVtaXRCb3gueCksZj1iKGcubWluRW1pdEJveC55LGcubWF4RW1pdEJveC55KSxoPWIoZy5taW5FbWl0Qm94LnosZy5tYXhFbWl0Qm94LnopO2EuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc0Zyb21GbG9hdHNUb1JlZihlLGYsaCxjLGQpfX1yZXR1cm4gYy5wcm90b3R5cGUuZ2V0Q2FwYWNpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2FwYWNpdHl9LGMucHJvdG90eXBlLmlzQWxpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxpdmV9LGMucHJvdG90eXBlLmlzU3RhcnRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGFydGVkfSxjLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3RoaXMuX3N0YXJ0ZWQ9ITAsdGhpcy5fc3RvcHBlZD0hMSx0aGlzLl9hY3R1YWxGcmFtZT0wfSxjLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5fc3RvcHBlZD0hMH0sYy5wcm90b3R5cGUuX2FwcGVuZFBhcnRpY2xlVmVydGV4PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPTExKmE7dGhpcy5fdmVydGljZXNbZV09Yi5wb3NpdGlvbi54LHRoaXMuX3ZlcnRpY2VzW2UrMV09Yi5wb3NpdGlvbi55LHRoaXMuX3ZlcnRpY2VzW2UrMl09Yi5wb3NpdGlvbi56LHRoaXMuX3ZlcnRpY2VzW2UrM109Yi5jb2xvci5yLHRoaXMuX3ZlcnRpY2VzW2UrNF09Yi5jb2xvci5nLHRoaXMuX3ZlcnRpY2VzW2UrNV09Yi5jb2xvci5iLHRoaXMuX3ZlcnRpY2VzW2UrNl09Yi5jb2xvci5hLHRoaXMuX3ZlcnRpY2VzW2UrN109Yi5hbmdsZSx0aGlzLl92ZXJ0aWNlc1tlKzhdPWIuc2l6ZSx0aGlzLl92ZXJ0aWNlc1tlKzldPWMsdGhpcy5fdmVydGljZXNbZSsxMF09ZH0sYy5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbihjKXt0aGlzLl9hbGl2ZT10aGlzLnBhcnRpY2xlcy5sZW5ndGg+MDtmb3IodmFyIGQ9MDtkPHRoaXMucGFydGljbGVzLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMucGFydGljbGVzW2RdO2UuYWdlKz10aGlzLl9zY2FsZWRVcGRhdGVTcGVlZCxlLmFnZT49ZS5saWZlVGltZT8odGhpcy5fc3RvY2tQYXJ0aWNsZXMucHVzaCh0aGlzLnBhcnRpY2xlcy5zcGxpY2UoZCwxKVswXSksZC0tKTooZS5jb2xvclN0ZXAuc2NhbGVUb1JlZih0aGlzLl9zY2FsZWRVcGRhdGVTcGVlZCx0aGlzLl9zY2FsZWRDb2xvclN0ZXApLGUuY29sb3IuYWRkSW5QbGFjZSh0aGlzLl9zY2FsZWRDb2xvclN0ZXApLGUuY29sb3IuYTwwJiYoZS5jb2xvci5hPTApLGUuYW5nbGUrPWUuYW5ndWxhclNwZWVkKnRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLGUuZGlyZWN0aW9uLnNjYWxlVG9SZWYodGhpcy5fc2NhbGVkVXBkYXRlU3BlZWQsdGhpcy5fc2NhbGVkRGlyZWN0aW9uKSxlLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5fc2NhbGVkRGlyZWN0aW9uKSx0aGlzLmdyYXZpdHkuc2NhbGVUb1JlZih0aGlzLl9zY2FsZWRVcGRhdGVTcGVlZCx0aGlzLl9zY2FsZWRHcmF2aXR5KSxlLmRpcmVjdGlvbi5hZGRJblBsYWNlKHRoaXMuX3NjYWxlZEdyYXZpdHkpKX12YXIgZjtmb3IoZj10aGlzLmVtaXR0ZXIucG9zaXRpb24/dGhpcy5lbWl0dGVyLmdldFdvcmxkTWF0cml4KCk6YS5NYXRyaXguVHJhbnNsYXRpb24odGhpcy5lbWl0dGVyLngsdGhpcy5lbWl0dGVyLnksdGhpcy5lbWl0dGVyLnopLGQ9MDtjPmQmJnRoaXMucGFydGljbGVzLmxlbmd0aCE9dGhpcy5fY2FwYWNpdHk7ZCsrKXswIT09dGhpcy5fc3RvY2tQYXJ0aWNsZXMubGVuZ3RoPyhlPXRoaXMuX3N0b2NrUGFydGljbGVzLnBvcCgpLGUuYWdlPTApOmU9bmV3IGEuUGFydGljbGUsdGhpcy5wYXJ0aWNsZXMucHVzaChlKTt2YXIgZz1iKHRoaXMubWluRW1pdFBvd2VyLHRoaXMubWF4RW1pdFBvd2VyKTt0aGlzLnN0YXJ0RGlyZWN0aW9uRnVuY3Rpb24oZyxmLGUuZGlyZWN0aW9uKSxlLmxpZmVUaW1lPWIodGhpcy5taW5MaWZlVGltZSx0aGlzLm1heExpZmVUaW1lKSxlLnNpemU9Yih0aGlzLm1pblNpemUsdGhpcy5tYXhTaXplKSxlLmFuZ3VsYXJTcGVlZD1iKHRoaXMubWluQW5ndWxhclNwZWVkLHRoaXMubWF4QW5ndWxhclNwZWVkKSx0aGlzLnN0YXJ0UG9zaXRpb25GdW5jdGlvbihmLGUucG9zaXRpb24pO3ZhciBoPWIoMCwxKTthLkNvbG9yNC5MZXJwVG9SZWYodGhpcy5jb2xvcjEsdGhpcy5jb2xvcjIsaCxlLmNvbG9yKSx0aGlzLmNvbG9yRGVhZC5zdWJ0cmFjdFRvUmVmKGUuY29sb3IsdGhpcy5fY29sb3JEaWZmKSx0aGlzLl9jb2xvckRpZmYuc2NhbGVUb1JlZigxL2UubGlmZVRpbWUsZS5jb2xvclN0ZXApfX0sYy5wcm90b3R5cGUuX2dldEVmZmVjdD1mdW5jdGlvbigpe3ZhciBhPVtdO3RoaXMuX3NjZW5lLmNsaXBQbGFuZSYmYS5wdXNoKFwiI2RlZmluZSBDTElQUExBTkVcIik7dmFyIGI9YS5qb2luKFwiXFxuXCIpO2lmKHRoaXMuX2NhY2hlZERlZmluZXMhPWIpe3RoaXMuX2NhY2hlZERlZmluZXM9Yjt2YXIgYztjPXRoaXMuZnJhZ21lbnRFbGVtZW50P3t2ZXJ0ZXg6XCJwYXJ0aWNsZXNcIixmcmFnbWVudEVsZW1lbnQ6dGhpcy5mcmFnbWVudEVsZW1lbnR9OlwicGFydGljbGVzXCIsdGhpcy5fZWZmZWN0PXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmNyZWF0ZUVmZmVjdChjLFtcInBvc2l0aW9uXCIsXCJjb2xvclwiLFwib3B0aW9uc1wiXSxbXCJpbnZWaWV3XCIsXCJ2aWV3XCIsXCJwcm9qZWN0aW9uXCIsXCJ2Q2xpcFBsYW5lXCIsXCJ0ZXh0dXJlTWFza1wiXSxbXCJkaWZmdXNlU2FtcGxlclwiXSxiKX1yZXR1cm4gdGhpcy5fZWZmZWN0fSxjLnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKCl7aWYodGhpcy5fc3RhcnRlZCl7dmFyIGE9dGhpcy5fZ2V0RWZmZWN0KCk7aWYodGhpcy5lbWl0dGVyJiZhLmlzUmVhZHkoKSYmdGhpcy5wYXJ0aWNsZVRleHR1cmUmJnRoaXMucGFydGljbGVUZXh0dXJlLmlzUmVhZHkoKSYmdGhpcy5fY3VycmVudFJlbmRlcklkIT09dGhpcy5fc2NlbmUuZ2V0UmVuZGVySWQoKSl7dGhpcy5fY3VycmVudFJlbmRlcklkPXRoaXMuX3NjZW5lLmdldFJlbmRlcklkKCksdGhpcy5fc2NhbGVkVXBkYXRlU3BlZWQ9dGhpcy51cGRhdGVTcGVlZCp0aGlzLl9zY2VuZS5nZXRBbmltYXRpb25SYXRpbygpO3ZhciBiO3RoaXMubWFudWFsRW1pdENvdW50Pi0xPyhiPXRoaXMubWFudWFsRW1pdENvdW50LHRoaXMubWFudWFsRW1pdENvdW50PTApOmI9dGhpcy5lbWl0UmF0ZTt2YXIgYz1iKnRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkPj4wO3RoaXMuX25ld1BhcnRzRXhjZXNzKz1iKnRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLWMsdGhpcy5fbmV3UGFydHNFeGNlc3M+MSYmKGMrPXRoaXMuX25ld1BhcnRzRXhjZXNzPj4wLHRoaXMuX25ld1BhcnRzRXhjZXNzLT10aGlzLl9uZXdQYXJ0c0V4Y2Vzcz4+MCksdGhpcy5fYWxpdmU9ITEsdGhpcy5fc3RvcHBlZD9jPTA6KHRoaXMuX2FjdHVhbEZyYW1lKz10aGlzLl9zY2FsZWRVcGRhdGVTcGVlZCx0aGlzLnRhcmdldFN0b3BEdXJhdGlvbiYmdGhpcy5fYWN0dWFsRnJhbWU+PXRoaXMudGFyZ2V0U3RvcER1cmF0aW9uJiZ0aGlzLnN0b3AoKSksdGhpcy5fdXBkYXRlKGMpLHRoaXMuX3N0b3BwZWQmJih0aGlzLl9hbGl2ZXx8KHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5kaXNwb3NlT25TdG9wJiZ0aGlzLl9zY2VuZS5fdG9CZURpc3Bvc2VkLnB1c2godGhpcykpKTtmb3IodmFyIGQ9MCxlPTA7ZTx0aGlzLnBhcnRpY2xlcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLnBhcnRpY2xlc1tlXTt0aGlzLl9hcHBlbmRQYXJ0aWNsZVZlcnRleChkKyssZiwwLDApLHRoaXMuX2FwcGVuZFBhcnRpY2xlVmVydGV4KGQrKyxmLDEsMCksdGhpcy5fYXBwZW5kUGFydGljbGVWZXJ0ZXgoZCsrLGYsMSwxKSx0aGlzLl9hcHBlbmRQYXJ0aWNsZVZlcnRleChkKyssZiwwLDEpfXZhciBnPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2cudXBkYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIsdGhpcy5fdmVydGljZXMsdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKnRoaXMuX3ZlcnRleFN0cmlkZVNpemUpfX19LGMucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe3ZhciBiPXRoaXMuX2dldEVmZmVjdCgpO2lmKCEodGhpcy5lbWl0dGVyJiZiLmlzUmVhZHkoKSYmdGhpcy5wYXJ0aWNsZVRleHR1cmUmJnRoaXMucGFydGljbGVUZXh0dXJlLmlzUmVhZHkoKSYmdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKSlyZXR1cm4gMDt2YXIgYz10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKTtjLmVuYWJsZUVmZmVjdChiKTt2YXIgZD10aGlzLl9zY2VuZS5nZXRWaWV3TWF0cml4KCk7aWYoYi5zZXRUZXh0dXJlKFwiZGlmZnVzZVNhbXBsZXJcIix0aGlzLnBhcnRpY2xlVGV4dHVyZSksYi5zZXRNYXRyaXgoXCJ2aWV3XCIsZCksYi5zZXRNYXRyaXgoXCJwcm9qZWN0aW9uXCIsdGhpcy5fc2NlbmUuZ2V0UHJvamVjdGlvbk1hdHJpeCgpKSxiLnNldEZsb2F0NChcInRleHR1cmVNYXNrXCIsdGhpcy50ZXh0dXJlTWFzay5yLHRoaXMudGV4dHVyZU1hc2suZyx0aGlzLnRleHR1cmVNYXNrLmIsdGhpcy50ZXh0dXJlTWFzay5hKSx0aGlzLl9zY2VuZS5jbGlwUGxhbmUpe3ZhciBlPXRoaXMuX3NjZW5lLmNsaXBQbGFuZSxmPWQuY2xvbmUoKTtmLmludmVydCgpLGIuc2V0TWF0cml4KFwiaW52Vmlld1wiLGYpLGIuc2V0RmxvYXQ0KFwidkNsaXBQbGFuZVwiLGUubm9ybWFsLngsZS5ub3JtYWwueSxlLm5vcm1hbC56LGUuZCl9cmV0dXJuIGMuYmluZEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX2luZGV4QnVmZmVyLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uLHRoaXMuX3ZlcnRleFN0cmlkZVNpemUsYiksYy5zZXRBbHBoYU1vZGUodGhpcy5ibGVuZE1vZGU9PT1hLlBhcnRpY2xlU3lzdGVtLkJMRU5ETU9ERV9PTkVPTkU/YS5FbmdpbmUuQUxQSEFfQUREOmEuRW5naW5lLkFMUEhBX0NPTUJJTkUpLHRoaXMuZm9yY2VEZXB0aFdyaXRlJiZjLnNldERlcHRoV3JpdGUoITApLGMuZHJhdyghMCwwLDYqdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKSxjLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9ESVNBQkxFKSx0aGlzLnBhcnRpY2xlcy5sZW5ndGh9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1udWxsKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKSx0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKSx0aGlzLnBhcnRpY2xlVGV4dHVyZSYmKHRoaXMucGFydGljbGVUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLnBhcnRpY2xlVGV4dHVyZT1udWxsKTt2YXIgYT10aGlzLl9zY2VuZS5wYXJ0aWNsZVN5c3RlbXMuaW5kZXhPZih0aGlzKTt0aGlzLl9zY2VuZS5wYXJ0aWNsZVN5c3RlbXMuc3BsaWNlKGEsMSksdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCl9LGMucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuUGFydGljbGVTeXN0ZW0oYix0aGlzLl9jYXBhY2l0eSx0aGlzLl9zY2VuZSk7cmV0dXJuIGEuVG9vbHMuRGVlcENvcHkodGhpcyxkLFtcInBhcnRpY2xlc1wiXSxbXCJfdmVydGV4RGVjbGFyYXRpb25cIixcIl92ZXJ0ZXhTdHJpZGVTaXplXCJdKSx2b2lkIDA9PT1jJiYoYz10aGlzLmVtaXR0ZXIpLGQuZW1pdHRlcj1jLHRoaXMucGFydGljbGVUZXh0dXJlJiYoZC5wYXJ0aWNsZVRleHR1cmU9bmV3IGEuVGV4dHVyZSh0aGlzLnBhcnRpY2xlVGV4dHVyZS51cmwsdGhpcy5fc2NlbmUpKSxkLnN0YXJ0KCksZH0sYy5CTEVORE1PREVfT05FT05FPTAsYy5CTEVORE1PREVfU1RBTkRBUkQ9MSxjfSgpO2EuUGFydGljbGVTeXN0ZW09Y30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYyxkLGUsZil7dGhpcy5uYW1lPWEsdGhpcy50YXJnZXRQcm9wZXJ0eT1jLHRoaXMuZnJhbWVQZXJTZWNvbmQ9ZCx0aGlzLmRhdGFUeXBlPWUsdGhpcy5sb29wTW9kZT1mLHRoaXMuX29mZnNldHNDYWNoZT17fSx0aGlzLl9oaWdoTGltaXRzQ2FjaGU9e30sdGhpcy5fc3RvcHBlZD0hMSx0aGlzLnRhcmdldFByb3BlcnR5UGF0aD1jLnNwbGl0KFwiLlwiKSx0aGlzLmRhdGFUeXBlPWUsdGhpcy5sb29wTW9kZT12b2lkIDA9PT1mP2IuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU6Zn1yZXR1cm4gYi5wcm90b3R5cGUuaXNTdG9wcGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0b3BwZWR9LGIucHJvdG90eXBlLmdldEtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa2V5c30sYi5wcm90b3R5cGUuZmxvYXRJbnRlcnBvbGF0ZUZ1bmN0aW9uPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYSsoYi1hKSpjfSxiLnByb3RvdHlwZS5xdWF0ZXJuaW9uSW50ZXJwb2xhdGVGdW5jdGlvbj1mdW5jdGlvbihiLGMsZCl7cmV0dXJuIGEuUXVhdGVybmlvbi5TbGVycChiLGMsZCl9LGIucHJvdG90eXBlLnZlY3RvcjNJbnRlcnBvbGF0ZUZ1bmN0aW9uPWZ1bmN0aW9uKGIsYyxkKXtyZXR1cm4gYS5WZWN0b3IzLkxlcnAoYixjLGQpfSxiLnByb3RvdHlwZS5jb2xvcjNJbnRlcnBvbGF0ZUZ1bmN0aW9uPWZ1bmN0aW9uKGIsYyxkKXtyZXR1cm4gYS5Db2xvcjMuTGVycChiLGMsZCl9LGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IGIodGhpcy5uYW1lLHRoaXMudGFyZ2V0UHJvcGVydHlQYXRoLmpvaW4oXCIuXCIpLHRoaXMuZnJhbWVQZXJTZWNvbmQsdGhpcy5kYXRhVHlwZSx0aGlzLmxvb3BNb2RlKTtyZXR1cm4gYS5zZXRLZXlzKHRoaXMuX2tleXMpLGF9LGIucHJvdG90eXBlLnNldEtleXM9ZnVuY3Rpb24oYSl7dGhpcy5fa2V5cz1hLnNsaWNlKDApLHRoaXMuX29mZnNldHNDYWNoZT17fSx0aGlzLl9oaWdoTGltaXRzQ2FjaGU9e319LGIucHJvdG90eXBlLl9pbnRlcnBvbGF0ZT1mdW5jdGlvbihhLGMsZCxlLGYpe2lmKGQ9PT1iLkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UJiZjPjApcmV0dXJuIGYuY2xvbmU/Zi5jbG9uZSgpOmY7dGhpcy5jdXJyZW50RnJhbWU9YTtmb3IodmFyIGc9MDtnPHRoaXMuX2tleXMubGVuZ3RoO2crKylpZih0aGlzLl9rZXlzW2crMV0uZnJhbWU+PWEpe3ZhciBoPXRoaXMuX2tleXNbZ10udmFsdWUsaT10aGlzLl9rZXlzW2crMV0udmFsdWUsaj0oYS10aGlzLl9rZXlzW2ddLmZyYW1lKS8odGhpcy5fa2V5c1tnKzFdLmZyYW1lLXRoaXMuX2tleXNbZ10uZnJhbWUpO3N3aXRjaCh0aGlzLmRhdGFUeXBlKXtjYXNlIGIuQU5JTUFUSU9OVFlQRV9GTE9BVDpzd2l0Y2goZCl7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFOmNhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVDpyZXR1cm4gdGhpcy5mbG9hdEludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopO2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRTpyZXR1cm4gZSpjK3RoaXMuZmxvYXRJbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKX1icmVhaztjYXNlIGIuQU5JTUFUSU9OVFlQRV9RVUFURVJOSU9OOnZhciBrPW51bGw7c3dpdGNoKGQpe2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DWUNMRTpjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQ6az10aGlzLnF1YXRlcm5pb25JbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKTticmVhaztjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfUkVMQVRJVkU6az10aGlzLnF1YXRlcm5pb25JbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKS5hZGQoZS5zY2FsZShjKSl9cmV0dXJuIGs7Y2FzZSBiLkFOSU1BVElPTlRZUEVfVkVDVE9SMzpzd2l0Y2goZCl7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFOmNhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVDpyZXR1cm4gdGhpcy52ZWN0b3IzSW50ZXJwb2xhdGVGdW5jdGlvbihoLGksaik7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFOnJldHVybiB0aGlzLnZlY3RvcjNJbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKS5hZGQoZS5zY2FsZShjKSl9Y2FzZSBiLkFOSU1BVElPTlRZUEVfQ09MT1IzOnN3aXRjaChkKXtjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU6Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UOnJldHVybiB0aGlzLmNvbG9yM0ludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopO2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRTpyZXR1cm4gdGhpcy5jb2xvcjNJbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKS5hZGQoZS5zY2FsZShjKSl9Y2FzZSBiLkFOSU1BVElPTlRZUEVfTUFUUklYOnN3aXRjaChkKXtjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU6Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UOmNhc2UgYi5BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRTpyZXR1cm4gaH19YnJlYWt9cmV0dXJuIHRoaXMuX2tleXNbdGhpcy5fa2V5cy5sZW5ndGgtMV0udmFsdWV9LGIucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYSxjLGQsZSxmKXtpZighdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGh8fHRoaXMudGFyZ2V0UHJvcGVydHlQYXRoLmxlbmd0aDwxKXJldHVybiB0aGlzLl9zdG9wcGVkPSEwLCExO3ZhciBnPSEwO2lmKDAhPXRoaXMuX2tleXNbMF0uZnJhbWUpe3ZhciBoPXtmcmFtZTowLHZhbHVlOnRoaXMuX2tleXNbMF0udmFsdWV9O3RoaXMuX2tleXMuc3BsaWNlKDAsMCxoKX0oYzx0aGlzLl9rZXlzWzBdLmZyYW1lfHxjPnRoaXMuX2tleXNbdGhpcy5fa2V5cy5sZW5ndGgtMV0uZnJhbWUpJiYoYz10aGlzLl9rZXlzWzBdLmZyYW1lKSwoZDx0aGlzLl9rZXlzWzBdLmZyYW1lfHxkPnRoaXMuX2tleXNbdGhpcy5fa2V5cy5sZW5ndGgtMV0uZnJhbWUpJiYoZD10aGlzLl9rZXlzW3RoaXMuX2tleXMubGVuZ3RoLTFdLmZyYW1lKTt2YXIgaT1kLWMsaj1hKnRoaXMuZnJhbWVQZXJTZWNvbmQqZi8xZTM7aWYoaj5pJiYhZSlrPTAsZz0hMSxsPXRoaXMuX2tleXNbdGhpcy5fa2V5cy5sZW5ndGgtMV0udmFsdWU7ZWxzZXt2YXIgaz0wLGw9MDtpZih0aGlzLmxvb3BNb2RlIT1iLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFKXt2YXIgbT1kLnRvU3RyaW5nKCkrYy50b1N0cmluZygpO2lmKCF0aGlzLl9vZmZzZXRzQ2FjaGVbbV0pe3ZhciBuPXRoaXMuX2ludGVycG9sYXRlKGMsMCxiLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFKSxvPXRoaXMuX2ludGVycG9sYXRlKGQsMCxiLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFKTtzd2l0Y2godGhpcy5kYXRhVHlwZSl7Y2FzZSBiLkFOSU1BVElPTlRZUEVfRkxPQVQ6dGhpcy5fb2Zmc2V0c0NhY2hlW21dPW8tbjticmVhaztjYXNlIGIuQU5JTUFUSU9OVFlQRV9RVUFURVJOSU9OOnRoaXMuX29mZnNldHNDYWNoZVttXT1vLnN1YnRyYWN0KG4pO2JyZWFrO2Nhc2UgYi5BTklNQVRJT05UWVBFX1ZFQ1RPUjM6dGhpcy5fb2Zmc2V0c0NhY2hlW21dPW8uc3VidHJhY3Qobik7Y2FzZSBiLkFOSU1BVElPTlRZUEVfQ09MT1IzOnRoaXMuX29mZnNldHNDYWNoZVttXT1vLnN1YnRyYWN0KG4pfXRoaXMuX2hpZ2hMaW1pdHNDYWNoZVttXT1vfWw9dGhpcy5faGlnaExpbWl0c0NhY2hlW21dLGs9dGhpcy5fb2Zmc2V0c0NhY2hlW21dfX12YXIgcD1qL2k+PjAscT1nP2MraiVpOmQscj10aGlzLl9pbnRlcnBvbGF0ZShxLHAsdGhpcy5sb29wTW9kZSxrLGwpO2lmKHRoaXMudGFyZ2V0UHJvcGVydHlQYXRoLmxlbmd0aD4xKXtmb3IodmFyIHM9dGhpcy5fdGFyZ2V0W3RoaXMudGFyZ2V0UHJvcGVydHlQYXRoWzBdXSx0PTE7dDx0aGlzLnRhcmdldFByb3BlcnR5UGF0aC5sZW5ndGgtMTt0Kyspcz1zW3RoaXMudGFyZ2V0UHJvcGVydHlQYXRoW3RdXTtzW3RoaXMudGFyZ2V0UHJvcGVydHlQYXRoW3RoaXMudGFyZ2V0UHJvcGVydHlQYXRoLmxlbmd0aC0xXV09cn1lbHNlIHRoaXMuX3RhcmdldFt0aGlzLnRhcmdldFByb3BlcnR5UGF0aFswXV09cjtyZXR1cm4gdGhpcy5fdGFyZ2V0Lm1hcmtBc0RpcnR5JiZ0aGlzLl90YXJnZXQubWFya0FzRGlydHkodGhpcy50YXJnZXRQcm9wZXJ0eSksZ3x8KHRoaXMuX3N0b3BwZWQ9ITApLGd9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiQU5JTUFUSU9OVFlQRV9GTE9BVFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OVFlQRV9GTE9BVH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTlRZUEVfVkVDVE9SM1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OVFlQRV9WRUNUT1IzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiQU5JTUFUSU9OVFlQRV9RVUFURVJOSU9OXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05UWVBFX1FVQVRFUk5JT059LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05UWVBFX01BVFJJWFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OVFlQRV9NQVRSSVh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05UWVBFX0NPTE9SM1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OVFlQRV9DT0xPUjN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05MT09QTU9ERV9SRUxBVElWRVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OTE9PUE1PREVfUkVMQVRJVkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05MT09QTU9ERV9DWUNMRVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05MT09QTU9ERV9DT05TVEFOVFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5fQU5JTUFUSU9OVFlQRV9GTE9BVD0wLGIuX0FOSU1BVElPTlRZUEVfVkVDVE9SMz0xLGIuX0FOSU1BVElPTlRZUEVfUVVBVEVSTklPTj0yLGIuX0FOSU1BVElPTlRZUEVfTUFUUklYPTMsYi5fQU5JTUFUSU9OVFlQRV9DT0xPUjM9NCxiLl9BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRT0wLGIuX0FOSU1BVElPTkxPT1BNT0RFX0NZQ0xFPTEsYi5fQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQ9MixifSgpO2EuQW5pbWF0aW9uPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkLGUsZixnLGgpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBjJiYoYz0wKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZCYmKGQ9MTAwKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZSYmKGU9ITEpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmJiYoZj0xKSx0aGlzLnRhcmdldD1iLHRoaXMuZnJvbUZyYW1lPWMsdGhpcy50b0ZyYW1lPWQsdGhpcy5sb29wQW5pbWF0aW9uPWUsdGhpcy5zcGVlZFJhdGlvPWYsdGhpcy5vbkFuaW1hdGlvbkVuZD1nLHRoaXMuX2FuaW1hdGlvbnM9bmV3IEFycmF5LHRoaXMuX3BhdXNlZD0hMSx0aGlzLmFuaW1hdGlvblN0YXJ0ZWQ9ITEsaCYmdGhpcy5hcHBlbmRBbmltYXRpb25zKGIsaCksdGhpcy5fc2NlbmU9YSxhLl9hY3RpdmVBbmltYXRhYmxlcy5wdXNoKHRoaXMpfXJldHVybiBhLnByb3RvdHlwZS5hcHBlbmRBbmltYXRpb25zPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107ZC5fdGFyZ2V0PWEsdGhpcy5fYW5pbWF0aW9ucy5wdXNoKGQpfX0sYS5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQnlUYXJnZXRQcm9wZXJ0eT1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5fYW5pbWF0aW9ucyxjPTA7YzxiLmxlbmd0aDtjKyspaWYoYltjXS50YXJnZXRQcm9wZXJ0eT09PWEpcmV0dXJuIGJbY107cmV0dXJuIG51bGx9LGEucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5fcGF1c2VkPSEwfSxhLnByb3RvdHlwZS5yZXN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5fcGF1c2VkPSExfSxhLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fc2NlbmUuX2FjdGl2ZUFuaW1hdGFibGVzLmluZGV4T2YodGhpcyk7YT4tMSYmdGhpcy5fc2NlbmUuX2FjdGl2ZUFuaW1hdGFibGVzLnNwbGljZShhLDEpLHRoaXMub25BbmltYXRpb25FbmQmJnRoaXMub25BbmltYXRpb25FbmQoKX0sYS5wcm90b3R5cGUuX2FuaW1hdGU9ZnVuY3Rpb24oYSl7aWYodGhpcy5fcGF1c2VkKXJldHVybiEwO3RoaXMuX2xvY2FsRGVsYXlPZmZzZXR8fCh0aGlzLl9sb2NhbERlbGF5T2Zmc2V0PWEpO2Zvcih2YXIgYj0hMSxjPXRoaXMuX2FuaW1hdGlvbnMsZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9ZS5hbmltYXRlKGEtdGhpcy5fbG9jYWxEZWxheU9mZnNldCx0aGlzLmZyb21GcmFtZSx0aGlzLnRvRnJhbWUsdGhpcy5sb29wQW5pbWF0aW9uLHRoaXMuc3BlZWRSYXRpbyk7Yj1ifHxmfXJldHVybiFiJiZ0aGlzLm9uQW5pbWF0aW9uRW5kJiZ0aGlzLm9uQW5pbWF0aW9uRW5kKCksYn0sYX0oKTthLkFuaW1hdGFibGU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZCYmKGQ9MiksdGhpcy5tYXhEZXB0aD1kLHRoaXMuZHluYW1pY0NvbnRlbnQ9bmV3IEFycmF5LHRoaXMuX21heEJsb2NrQ2FwYWNpdHk9Y3x8NjQsdGhpcy5fc2VsZWN0aW9uQ29udGVudD1uZXcgYS5TbWFydEFycmF5KDEwMjQpLHRoaXMuX2NyZWF0aW9uRnVuYz1ifXJldHVybiBiLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxjLGQpe2IuX0NyZWF0ZUJsb2NrcyhhLGMsZCx0aGlzLl9tYXhCbG9ja0NhcGFjaXR5LDAsdGhpcy5tYXhEZXB0aCx0aGlzLHRoaXMuX2NyZWF0aW9uRnVuYyl9LGIucHJvdG90eXBlLmFkZE1lc2g9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmJsb2Nrcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmJsb2Nrc1tiXTtjLmFkZEVudHJ5KGEpfX0sYi5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGEsYil7dGhpcy5fc2VsZWN0aW9uQ29udGVudC5yZXNldCgpO2Zvcih2YXIgYz0wO2M8dGhpcy5ibG9ja3MubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5ibG9ja3NbY107ZC5zZWxlY3QoYSx0aGlzLl9zZWxlY3Rpb25Db250ZW50LGIpfXJldHVybiBiP3RoaXMuX3NlbGVjdGlvbkNvbnRlbnQuY29uY2F0KHRoaXMuZHluYW1pY0NvbnRlbnQpOnRoaXMuX3NlbGVjdGlvbkNvbnRlbnQuY29uY2F0V2l0aE5vRHVwbGljYXRlKHRoaXMuZHluYW1pY0NvbnRlbnQpLHRoaXMuX3NlbGVjdGlvbkNvbnRlbnR9LGIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX3NlbGVjdGlvbkNvbnRlbnQucmVzZXQoKTtmb3IodmFyIGQ9MDtkPHRoaXMuYmxvY2tzLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMuYmxvY2tzW2RdO2UuaW50ZXJzZWN0cyhhLGIsdGhpcy5fc2VsZWN0aW9uQ29udGVudCxjKX1yZXR1cm4gYz90aGlzLl9zZWxlY3Rpb25Db250ZW50LmNvbmNhdCh0aGlzLmR5bmFtaWNDb250ZW50KTp0aGlzLl9zZWxlY3Rpb25Db250ZW50LmNvbmNhdFdpdGhOb0R1cGxpY2F0ZSh0aGlzLmR5bmFtaWNDb250ZW50KSx0aGlzLl9zZWxlY3Rpb25Db250ZW50fSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzUmF5PWZ1bmN0aW9uKGEpe3RoaXMuX3NlbGVjdGlvbkNvbnRlbnQucmVzZXQoKTtmb3IodmFyIGI9MDtiPHRoaXMuYmxvY2tzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYmxvY2tzW2JdO2MuaW50ZXJzZWN0c1JheShhLHRoaXMuX3NlbGVjdGlvbkNvbnRlbnQpfXJldHVybiB0aGlzLl9zZWxlY3Rpb25Db250ZW50LmNvbmNhdFdpdGhOb0R1cGxpY2F0ZSh0aGlzLmR5bmFtaWNDb250ZW50KSx0aGlzLl9zZWxlY3Rpb25Db250ZW50fSxiLl9DcmVhdGVCbG9ja3M9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpKXtoLmJsb2Nrcz1uZXcgQXJyYXk7Zm9yKHZhciBqPW5ldyBhLlZlY3RvcjMoKGMueC1iLngpLzIsKGMueS1iLnkpLzIsKGMuei1iLnopLzIpLGs9MDsyPms7aysrKWZvcih2YXIgbD0wOzI+bDtsKyspZm9yKHZhciBtPTA7Mj5tO20rKyl7dmFyIG49Yi5hZGQoai5tdWx0aXBseUJ5RmxvYXRzKGssbCxtKSksbz1iLmFkZChqLm11bHRpcGx5QnlGbG9hdHMoaysxLGwrMSxtKzEpKSxwPW5ldyBhLk9jdHJlZUJsb2NrKG4sbyxlLGYrMSxnLGkpO3AuYWRkRW50cmllcyhkKSxoLmJsb2Nrcy5wdXNoKHApfX0sYi5DcmVhdGlvbkZ1bmNGb3JNZXNoZXM9ZnVuY3Rpb24oYSxiKXthLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94LmludGVyc2VjdHNNaW5NYXgoYi5taW5Qb2ludCxiLm1heFBvaW50KSYmYi5lbnRyaWVzLnB1c2goYSl9LGIuQ3JlYXRpb25GdW5jRm9yU3ViTWVzaGVzPWZ1bmN0aW9uKGEsYil7YS5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveC5pbnRlcnNlY3RzTWluTWF4KGIubWluUG9pbnQsYi5tYXhQb2ludCkmJmIuZW50cmllcy5wdXNoKGEpfSxifSgpO2EuT2N0cmVlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyxkLGUsZil7dGhpcy5lbnRyaWVzPW5ldyBBcnJheSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnM9bmV3IEFycmF5LHRoaXMuX2NhcGFjaXR5PWMsdGhpcy5fZGVwdGg9ZCx0aGlzLl9tYXhEZXB0aD1lLHRoaXMuX2NyZWF0aW9uRnVuYz1mLHRoaXMuX21pblBvaW50PWEsdGhpcy5fbWF4UG9pbnQ9Yix0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChhLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9ycy5wdXNoKGIuY2xvbmUoKSksdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYS5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbMl0ueD1iLngsdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYS5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbM10ueT1iLnksdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYS5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbNF0uej1iLnosdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYi5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbNV0uej1hLnosdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYi5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbNl0ueD1hLngsdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYi5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnNbN10ueT1hLnl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImNhcGFjaXR5XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jYXBhY2l0eX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJtaW5Qb2ludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWluUG9pbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwibWF4UG9pbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21heFBvaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLmFkZEVudHJ5PWZ1bmN0aW9uKGEpe2lmKHRoaXMuYmxvY2tzKWZvcih2YXIgYj0wO2I8dGhpcy5ibG9ja3MubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5ibG9ja3NbYl07Yy5hZGRFbnRyeShhKX1lbHNlIHRoaXMuX2NyZWF0aW9uRnVuYyhhLHRoaXMpLHRoaXMuZW50cmllcy5sZW5ndGg+dGhpcy5jYXBhY2l0eSYmdGhpcy5fZGVwdGg8dGhpcy5fbWF4RGVwdGgmJnRoaXMuY3JlYXRlSW5uZXJCbG9ja3MoKX0sYi5wcm90b3R5cGUuYWRkRW50cmllcz1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTt0aGlzLmFkZEVudHJ5KGMpfX0sYi5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGIsYyxkKXtpZihhLkJvdW5kaW5nQm94LklzSW5GcnVzdHVtKHRoaXMuX2JvdW5kaW5nVmVjdG9ycyxiKSl7aWYodGhpcy5ibG9ja3Mpe2Zvcih2YXIgZT0wO2U8dGhpcy5ibG9ja3MubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy5ibG9ja3NbZV07Zi5zZWxlY3QoYixjLGQpfXJldHVybn1kP2MuY29uY2F0KHRoaXMuZW50cmllcyk6Yy5jb25jYXRXaXRoTm9EdXBsaWNhdGUodGhpcy5lbnRyaWVzKX19LGIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYixjLGQsZSl7aWYoYS5Cb3VuZGluZ0JveC5JbnRlcnNlY3RzU3BoZXJlKHRoaXMuX21pblBvaW50LHRoaXMuX21heFBvaW50LGIsYykpe2lmKHRoaXMuYmxvY2tzKXtmb3IodmFyIGY9MDtmPHRoaXMuYmxvY2tzLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMuYmxvY2tzW2ZdO2cuaW50ZXJzZWN0cyhiLGMsZCxlKX1yZXR1cm59ZT9kLmNvbmNhdCh0aGlzLmVudHJpZXMpOmQuY29uY2F0V2l0aE5vRHVwbGljYXRlKHRoaXMuZW50cmllcyl9fSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzUmF5PWZ1bmN0aW9uKGEsYil7aWYoYS5pbnRlcnNlY3RzQm94TWluTWF4KHRoaXMuX21pblBvaW50LHRoaXMuX21heFBvaW50KSl7aWYodGhpcy5ibG9ja3Mpe2Zvcih2YXIgYz0wO2M8dGhpcy5ibG9ja3MubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5ibG9ja3NbY107ZC5pbnRlcnNlY3RzUmF5KGEsYil9cmV0dXJufWIuY29uY2F0V2l0aE5vRHVwbGljYXRlKHRoaXMuZW50cmllcyl9fSxiLnByb3RvdHlwZS5jcmVhdGVJbm5lckJsb2Nrcz1mdW5jdGlvbigpe2EuT2N0cmVlLl9DcmVhdGVCbG9ja3ModGhpcy5fbWluUG9pbnQsdGhpcy5fbWF4UG9pbnQsdGhpcy5lbnRyaWVzLHRoaXMuX2NhcGFjaXR5LHRoaXMuX2RlcHRoLHRoaXMuX21heERlcHRoLHRoaXMsdGhpcy5fY3JlYXRpb25GdW5jKX0sYn0oKTthLk9jdHJlZUJsb2NrPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlKXt0aGlzLm5hbWU9Yix0aGlzLmNoaWxkcmVuPW5ldyBBcnJheSx0aGlzLmFuaW1hdGlvbnM9bmV3IEFycmF5LHRoaXMuX3dvcmxkVHJhbnNmb3JtPW5ldyBhLk1hdHJpeCx0aGlzLl9hYnNvbHV0ZVRyYW5zZm9ybT1uZXcgYS5NYXRyaXgsdGhpcy5faW52ZXJ0ZWRBYnNvbHV0ZVRyYW5zZm9ybT1uZXcgYS5NYXRyaXgsdGhpcy5fc2tlbGV0b249Yyx0aGlzLl9tYXRyaXg9ZSx0aGlzLl9iYXNlTWF0cml4PWUsYy5ib25lcy5wdXNoKHRoaXMpLGQ/KHRoaXMuX3BhcmVudD1kLGQuY2hpbGRyZW4ucHVzaCh0aGlzKSk6dGhpcy5fcGFyZW50PW51bGwsdGhpcy5fdXBkYXRlRGlmZmVyZW5jZU1hdHJpeCgpfXJldHVybiBiLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFyZW50fSxiLnByb3RvdHlwZS5nZXRMb2NhbE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXh9LGIucHJvdG90eXBlLmdldEJhc2VNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmFzZU1hdHJpeH0sYi5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRUcmFuc2Zvcm19LGIucHJvdG90eXBlLmdldEludmVydGVkQWJzb2x1dGVUcmFuc2Zvcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW52ZXJ0ZWRBYnNvbHV0ZVRyYW5zZm9ybX0sYi5wcm90b3R5cGUuZ2V0QWJzb2x1dGVNYXRyaXg9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5fbWF0cml4LmNsb25lKCksYj10aGlzLl9wYXJlbnQ7YjspYT1hLm11bHRpcGx5KGIuZ2V0TG9jYWxNYXRyaXgoKSksYj1iLmdldFBhcmVudCgpO3JldHVybiBhfSxiLnByb3RvdHlwZS51cGRhdGVNYXRyaXg9ZnVuY3Rpb24oYSl7dGhpcy5fbWF0cml4PWEsdGhpcy5fc2tlbGV0b24uX21hcmtBc0RpcnR5KCksdGhpcy5fdXBkYXRlRGlmZmVyZW5jZU1hdHJpeCgpfSxiLnByb3RvdHlwZS5fdXBkYXRlRGlmZmVyZW5jZU1hdHJpeD1mdW5jdGlvbigpe3RoaXMuX3BhcmVudD90aGlzLl9tYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9wYXJlbnQuX2Fic29sdXRlVHJhbnNmb3JtLHRoaXMuX2Fic29sdXRlVHJhbnNmb3JtKTp0aGlzLl9hYnNvbHV0ZVRyYW5zZm9ybS5jb3B5RnJvbSh0aGlzLl9tYXRyaXgpLHRoaXMuX2Fic29sdXRlVHJhbnNmb3JtLmludmVydFRvUmVmKHRoaXMuX2ludmVydGVkQWJzb2x1dGVUcmFuc2Zvcm0pO2Zvcih2YXIgYT0wO2E8dGhpcy5jaGlsZHJlbi5sZW5ndGg7YSsrKXRoaXMuY2hpbGRyZW5bYV0uX3VwZGF0ZURpZmZlcmVuY2VNYXRyaXgoKX0sYi5wcm90b3R5cGUubWFya0FzRGlydHk9ZnVuY3Rpb24oKXt0aGlzLl9za2VsZXRvbi5fbWFya0FzRGlydHkoKX0sYn0oKTthLkJvbmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkKXt0aGlzLm5hbWU9Yix0aGlzLmlkPWMsdGhpcy5ib25lcz1uZXcgQXJyYXksdGhpcy5faXNEaXJ0eT0hMCx0aGlzLl9pZGVudGl0eT1hLk1hdHJpeC5JZGVudGl0eSgpLHRoaXMuYm9uZXM9W10sdGhpcy5fc2NlbmU9ZCxkLnNrZWxldG9ucy5wdXNoKHRoaXMpfXJldHVybiBiLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1NYXRyaWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1NYXRyaWNlc30sYi5wcm90b3R5cGUuX21hcmtBc0RpcnR5PWZ1bmN0aW9uKCl7dGhpcy5faXNEaXJ0eT0hMH0sYi5wcm90b3R5cGUucHJlcGFyZT1mdW5jdGlvbigpe2lmKHRoaXMuX2lzRGlydHkpe3RoaXMuX3RyYW5zZm9ybU1hdHJpY2VzJiZ0aGlzLl90cmFuc2Zvcm1NYXRyaWNlcy5sZW5ndGg9PT0xNioodGhpcy5ib25lcy5sZW5ndGgrMSl8fCh0aGlzLl90cmFuc2Zvcm1NYXRyaWNlcz1uZXcgRmxvYXQzMkFycmF5KDE2Kih0aGlzLmJvbmVzLmxlbmd0aCsxKSkpO2Zvcih2YXIgYT0wO2E8dGhpcy5ib25lcy5sZW5ndGg7YSsrKXt2YXIgYj10aGlzLmJvbmVzW2FdLGM9Yi5nZXRQYXJlbnQoKTtjP2IuZ2V0TG9jYWxNYXRyaXgoKS5tdWx0aXBseVRvUmVmKGMuZ2V0V29ybGRNYXRyaXgoKSxiLmdldFdvcmxkTWF0cml4KCkpOmIuZ2V0V29ybGRNYXRyaXgoKS5jb3B5RnJvbShiLmdldExvY2FsTWF0cml4KCkpLGIuZ2V0SW52ZXJ0ZWRBYnNvbHV0ZVRyYW5zZm9ybSgpLm11bHRpcGx5VG9BcnJheShiLmdldFdvcmxkTWF0cml4KCksdGhpcy5fdHJhbnNmb3JtTWF0cmljZXMsMTYqYSl9dGhpcy5faWRlbnRpdHkuY29weVRvQXJyYXkodGhpcy5fdHJhbnNmb3JtTWF0cmljZXMsMTYqdGhpcy5ib25lcy5sZW5ndGgpLHRoaXMuX2lzRGlydHk9ITF9fSxiLnByb3RvdHlwZS5nZXRBbmltYXRhYmxlcz1mdW5jdGlvbigpe2lmKCF0aGlzLl9hbmltYXRhYmxlc3x8dGhpcy5fYW5pbWF0YWJsZXMubGVuZ3RoIT10aGlzLmJvbmVzLmxlbmd0aCl7dGhpcy5fYW5pbWF0YWJsZXM9W107Zm9yKHZhciBhPTA7YTx0aGlzLmJvbmVzLmxlbmd0aDthKyspdGhpcy5fYW5pbWF0YWJsZXMucHVzaCh0aGlzLmJvbmVzW2FdKX1yZXR1cm4gdGhpcy5fYW5pbWF0YWJsZXN9LGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPW5ldyBhLlNrZWxldG9uKGIsY3x8Yix0aGlzLl9zY2VuZSksZT0wO2U8dGhpcy5ib25lcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLmJvbmVzW2VdLGc9bnVsbDtpZihmLmdldFBhcmVudCgpKXt2YXIgaD10aGlzLmJvbmVzLmluZGV4T2YoZi5nZXRQYXJlbnQoKSk7Zz1kLmJvbmVzW2hdfXZhciBpPW5ldyBhLkJvbmUoZi5uYW1lLGQsZyxmLmdldEJhc2VNYXRyaXgoKSk7YS5Ub29scy5EZWVwQ29weShmLmFuaW1hdGlvbnMsaS5hbmltYXRpb25zKX1yZXR1cm4gZH0sYn0oKTthLlNrZWxldG9uPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyxoLGksail7dGhpcy5uYW1lPWIsdGhpcy53aWR0aD0tMSx0aGlzLmhlaWdodD0tMSx0aGlzLl9yZXVzYWJsZT0hMSx0aGlzLl90ZXh0dXJlcz1uZXcgYS5TbWFydEFycmF5KDIpLHRoaXMuX2N1cnJlbnRSZW5kZXJUZXh0dXJlSW5kPTAsbnVsbCE9Zz8odGhpcy5fY2FtZXJhPWcsdGhpcy5fc2NlbmU9Zy5nZXRTY2VuZSgpLGcuYXR0YWNoUG9zdFByb2Nlc3ModGhpcyksdGhpcy5fZW5naW5lPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpKTp0aGlzLl9lbmdpbmU9aSx0aGlzLl9yZW5kZXJSYXRpbz1mLHRoaXMucmVuZGVyVGFyZ2V0U2FtcGxpbmdNb2RlPWg/aDphLlRleHR1cmUuTkVBUkVTVF9TQU1QTElOR01PREUsdGhpcy5fcmV1c2FibGU9anx8ITEsZT1lfHxbXSxlLnB1c2goXCJ0ZXh0dXJlU2FtcGxlclwiKSx0aGlzLl9lZmZlY3Q9dGhpcy5fZW5naW5lLmNyZWF0ZUVmZmVjdCh7dmVydGV4OlwicG9zdHByb2Nlc3NcIixmcmFnbWVudDpjfSxbXCJwb3NpdGlvblwiXSxkfHxbXSxlLFwiXCIpfXJldHVybiBiLnByb3RvdHlwZS5pc1JldXNhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JldXNhYmxlfSxiLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbihhLGIpe2E9YXx8dGhpcy5fY2FtZXJhO3ZhciBjPWEuZ2V0U2NlbmUoKSxkPShiP2IuX3dpZHRoOnRoaXMuX2VuZ2luZS5nZXRSZW5kZXJpbmdDYW52YXMoKS53aWR0aCkqdGhpcy5fcmVuZGVyUmF0aW8sZT0oYj9iLl9oZWlnaHQ6dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpLmhlaWdodCkqdGhpcy5fcmVuZGVyUmF0aW87aWYodGhpcy53aWR0aCE9PWR8fHRoaXMuaGVpZ2h0IT09ZSl7aWYodGhpcy5fdGV4dHVyZXMubGVuZ3RoPjApe2Zvcih2YXIgZj0wO2Y8dGhpcy5fdGV4dHVyZXMubGVuZ3RoO2YrKyl0aGlzLl9lbmdpbmUuX3JlbGVhc2VUZXh0dXJlKHRoaXMuX3RleHR1cmVzLmRhdGFbZl0pO3RoaXMuX3RleHR1cmVzLnJlc2V0KCl9dGhpcy53aWR0aD1kLHRoaXMuaGVpZ2h0PWUsdGhpcy5fdGV4dHVyZXMucHVzaCh0aGlzLl9lbmdpbmUuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh7d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHR9LHtnZW5lcmF0ZU1pcE1hcHM6ITEsZ2VuZXJhdGVEZXB0aEJ1ZmZlcjphLl9wb3N0UHJvY2Vzc2VzLmluZGV4T2YodGhpcyk9PT1hLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzWzBdLHNhbXBsaW5nTW9kZTp0aGlzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZX0pKSx0aGlzLl9yZXVzYWJsZSYmdGhpcy5fdGV4dHVyZXMucHVzaCh0aGlzLl9lbmdpbmUuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZSh7d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHR9LHtnZW5lcmF0ZU1pcE1hcHM6ITEsZ2VuZXJhdGVEZXB0aEJ1ZmZlcjphLl9wb3N0UHJvY2Vzc2VzLmluZGV4T2YodGhpcyk9PT1hLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzWzBdLHNhbXBsaW5nTW9kZTp0aGlzLnJlbmRlclRhcmdldFNhbXBsaW5nTW9kZX0pKSx0aGlzLm9uU2l6ZUNoYW5nZWQmJnRoaXMub25TaXplQ2hhbmdlZCgpfXRoaXMuX2VuZ2luZS5iaW5kRnJhbWVidWZmZXIodGhpcy5fdGV4dHVyZXMuZGF0YVt0aGlzLl9jdXJyZW50UmVuZGVyVGV4dHVyZUluZF0pLHRoaXMub25BY3RpdmF0ZSYmdGhpcy5vbkFjdGl2YXRlKGEpLHRoaXMuX2VuZ2luZS5jbGVhcihjLmNsZWFyQ29sb3IsYy5hdXRvQ2xlYXJ8fGMuZm9yY2VXaXJlZnJhbWUsITApLHRoaXMuX3JldXNhYmxlJiYodGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQ9KHRoaXMuX2N1cnJlbnRSZW5kZXJUZXh0dXJlSW5kKzEpJTIpfSxiLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lZmZlY3QuaXNSZWFkeSgpPyh0aGlzLl9lbmdpbmUuZW5hYmxlRWZmZWN0KHRoaXMuX2VmZmVjdCksdGhpcy5fZW5naW5lLnNldFN0YXRlKCExKSx0aGlzLl9lbmdpbmUuc2V0QWxwaGFNb2RlKGEuRW5naW5lLkFMUEhBX0RJU0FCTEUpLHRoaXMuX2VuZ2luZS5zZXREZXB0aEJ1ZmZlcighMSksdGhpcy5fZW5naW5lLnNldERlcHRoV3JpdGUoITEpLHRoaXMuX2VmZmVjdC5fYmluZFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLHRoaXMuX3RleHR1cmVzLmRhdGFbdGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmRdKSx0aGlzLm9uQXBwbHkmJnRoaXMub25BcHBseSh0aGlzLl9lZmZlY3QpLHRoaXMuX2VmZmVjdCk6bnVsbH0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbihhKXtpZihhPWF8fHRoaXMuX2NhbWVyYSx0aGlzLl90ZXh0dXJlcy5sZW5ndGg+MCl7Zm9yKHZhciBiPTA7Yjx0aGlzLl90ZXh0dXJlcy5sZW5ndGg7YisrKXRoaXMuX2VuZ2luZS5fcmVsZWFzZVRleHR1cmUodGhpcy5fdGV4dHVyZXMuZGF0YVtiXSk7dGhpcy5fdGV4dHVyZXMucmVzZXQoKX1hLmRldGFjaFBvc3RQcm9jZXNzKHRoaXMpO3ZhciBjPWEuX3Bvc3RQcm9jZXNzZXMuaW5kZXhPZih0aGlzKTtjPT09YS5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlc1swXSYmYS5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5sZW5ndGg+MCYmKHRoaXMuX2NhbWVyYS5fcG9zdFByb2Nlc3Nlc1thLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzWzBdXS53aWR0aD0tMSl9LGJ9KCk7YS5Qb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7dGhpcy5fdmVydGV4RGVjbGFyYXRpb249WzJdLHRoaXMuX3ZlcnRleFN0cmlkZVNpemU9OCx0aGlzLl9zY2VuZT1hO3ZhciBiPVtdO2IucHVzaCgxLDEpLGIucHVzaCgtMSwxKSxiLnB1c2goLTEsLTEpLGIucHVzaCgxLC0xKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9YS5nZXRFbmdpbmUoKS5jcmVhdGVWZXJ0ZXhCdWZmZXIoYik7dmFyIGM9W107Yy5wdXNoKDApLGMucHVzaCgxKSxjLnB1c2goMiksYy5wdXNoKDApLGMucHVzaCgyKSxjLnB1c2goMyksdGhpcy5faW5kZXhCdWZmZXI9YS5nZXRFbmdpbmUoKS5jcmVhdGVJbmRleEJ1ZmZlcihjKX1yZXR1cm4gYS5wcm90b3R5cGUuX3ByZXBhcmVGcmFtZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEuX3Bvc3RQcm9jZXNzZXMsYz10aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXM7cmV0dXJuIDAhPT1jLmxlbmd0aCYmdGhpcy5fc2NlbmUucG9zdFByb2Nlc3Nlc0VuYWJsZWQ/KGJbdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzWzBdXS5hY3RpdmF0ZSh0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEsYSksITApOiExfSxhLnByb3RvdHlwZS5fZmluYWxpemVGcmFtZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5fcG9zdFByb2Nlc3NlcyxkPXRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcztpZigwIT09ZC5sZW5ndGgmJnRoaXMuX3NjZW5lLnBvc3RQcm9jZXNzZXNFbmFibGVkKXtmb3IodmFyIGU9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCksZj0wO2Y8ZC5sZW5ndGgmJihmPGQubGVuZ3RoLTE/Y1tkW2YrMV1dLmFjdGl2YXRlKHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYSk6Yj9lLmJpbmRGcmFtZWJ1ZmZlcihiKTplLnJlc3RvcmVEZWZhdWx0RnJhbWVidWZmZXIoKSwhYSk7ZisrKXt2YXIgZz1jW2RbZl1dLmFwcGx5KCk7ZyYmKGUuYmluZEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX2luZGV4QnVmZmVyLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uLHRoaXMuX3ZlcnRleFN0cmlkZVNpemUsZyksZS5kcmF3KCEwLDAsNikpfWUuc2V0RGVwdGhCdWZmZXIoITApLGUuc2V0RGVwdGhXcml0ZSghMCl9fSxhLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fdmVydGV4QnVmZmVyJiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5fdmVydGV4QnVmZmVyKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9bnVsbCksdGhpcy5faW5kZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5faW5kZXhCdWZmZXI9bnVsbCl9LGF9KCk7YS5Qb3N0UHJvY2Vzc01hbmFnZXI9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcpe2EuY2FsbCh0aGlzLGIsXCJwYXNzXCIsbnVsbCxudWxsLGMsZCxlLGYsZyl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGJ9KGEuUG9zdFByb2Nlc3MpO2EuUGFzc1Bvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYsZyxoLGksail7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGgmJihoPWEuVGV4dHVyZS5CSUxJTkVBUl9TQU1QTElOR01PREUpO3ZhciBrPXRoaXM7Yi5jYWxsKHRoaXMsYyxcImJsdXJcIixbXCJzY3JlZW5TaXplXCIsXCJkaXJlY3Rpb25cIixcImJsdXJXaWR0aFwiXSxudWxsLGYsZyxoLGksaiksdGhpcy5kaXJlY3Rpb249ZCx0aGlzLmJsdXJXaWR0aD1lLHRoaXMub25BcHBseT1mdW5jdGlvbihhKXthLnNldEZsb2F0MihcInNjcmVlblNpemVcIixrLndpZHRoLGsuaGVpZ2h0KSxhLnNldFZlY3RvcjIoXCJkaXJlY3Rpb25cIixrLmRpcmVjdGlvbiksYS5zZXRGbG9hdChcImJsdXJXaWR0aFwiLGsuYmx1cldpZHRoKX19cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGN9KGEuUG9zdFByb2Nlc3MpO2EuQmx1clBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnLGgpe3ZhciBpPXRoaXM7YS5jYWxsKHRoaXMsYixcImZpbHRlclwiLFtcImtlcm5lbE1hdHJpeFwiXSxudWxsLGQsZSxmLGcsaCksdGhpcy5rZXJuZWxNYXRyaXg9Yyx0aGlzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRNYXRyaXgoXCJrZXJuZWxNYXRyaXhcIixpLmtlcm5lbE1hdHJpeCl9fXJldHVybiBfX2V4dGVuZHMoYixhKSxifShhLlBvc3RQcm9jZXNzKTthLkZpbHRlclBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYsZyxoLGksaixrLGwpe3ZhciBtPXRoaXM7Yi5jYWxsKHRoaXMsYyxcInJlZnJhY3Rpb25cIixbXCJiYXNlQ29sb3JcIixcImRlcHRoXCIsXCJjb2xvckxldmVsXCJdLFtcInJlZnJhY3Rpb25TYW1wbGVyXCJdLGgsaSxqLGssbCksdGhpcy5jb2xvcj1lLHRoaXMuZGVwdGg9Zix0aGlzLmNvbG9yTGV2ZWw9Zyx0aGlzLm9uQWN0aXZhdGU9ZnVuY3Rpb24oYil7bS5fcmVmUmV4dHVyZT1tLl9yZWZSZXh0dXJlfHxuZXcgYS5UZXh0dXJlKGQsYi5nZXRTY2VuZSgpKX0sdGhpcy5vbkFwcGx5PWZ1bmN0aW9uKGEpe2Euc2V0Q29sb3IzKFwiYmFzZUNvbG9yXCIsbS5jb2xvciksYS5zZXRGbG9hdChcImRlcHRoXCIsbS5kZXB0aCksYS5zZXRGbG9hdChcImNvbG9yTGV2ZWxcIixtLmNvbG9yTGV2ZWwpLGEuc2V0VGV4dHVyZShcInJlZnJhY3Rpb25TYW1wbGVyXCIsbS5fcmVmUmV4dHVyZSl9fXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe3RoaXMuX3JlZlJleHR1cmUmJnRoaXMuX3JlZlJleHR1cmUuZGlzcG9zZSgpLGIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLGEpfSxjfShhLlBvc3RQcm9jZXNzKTthLlJlZnJhY3Rpb25Qb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7YS5jYWxsKHRoaXMsYixcImJsYWNrQW5kV2hpdGVcIixudWxsLG51bGwsYyxkLGUsZixnKX1yZXR1cm4gX19leHRlbmRzKGIsYSksYn0oYS5Qb3N0UHJvY2Vzcyk7YS5CbGFja0FuZFdoaXRlUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpczthLmNhbGwodGhpcyxiLFwiY29udm9sdXRpb25cIixbXCJrZXJuZWxcIixcInNjcmVlblNpemVcIl0sbnVsbCxkLGUsZixnLGgpLHRoaXMua2VybmVsPWMsdGhpcy5vbkFwcGx5PWZ1bmN0aW9uKGEpe2Euc2V0RmxvYXQyKFwic2NyZWVuU2l6ZVwiLGkud2lkdGgsaS5oZWlnaHQpLGEuc2V0QXJyYXkoXCJrZXJuZWxcIixpLmtlcm5lbCl9fXJldHVybiBfX2V4dGVuZHMoYixhKSxiLkVkZ2VEZXRlY3QwS2VybmVsPVsxLDAsLTEsMCwwLDAsLTEsMCwxXSxiLkVkZ2VEZXRlY3QxS2VybmVsPVswLDEsMCwxLC00LDEsMCwxLDBdLGIuRWRnZURldGVjdDJLZXJuZWw9Wy0xLC0xLC0xLC0xLDgsLTEsLTEsLTEsLTFdLGIuU2hhcnBlbktlcm5lbD1bMCwtMSwwLC0xLDUsLTEsMCwtMSwwXSxiLkVtYm9zc0tlcm5lbD1bLTIsLTEsMCwtMSwxLDEsMCwxLDJdLGIuR2F1c3NpYW5LZXJuZWw9WzAsMSwwLDEsMSwxLDAsMSwwXSxifShhLlBvc3RQcm9jZXNzKTthLkNvbnZvbHV0aW9uUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcpe3ZhciBoPXRoaXM7YS5jYWxsKHRoaXMsYixcImZ4YWFcIixbXCJ0ZXhlbFNpemVcIl0sbnVsbCxjLGQsZSxmLGcpLHRoaXMub25TaXplQ2hhbmdlZD1mdW5jdGlvbigpe2gudGV4ZWxXaWR0aD0xL2gud2lkdGgsaC50ZXhlbEhlaWdodD0xL2guaGVpZ2h0fSx0aGlzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRGbG9hdDIoXCJ0ZXhlbFNpemVcIixoLnRleGVsV2lkdGgsaC50ZXhlbEhlaWdodCl9fXJldHVybiBfX2V4dGVuZHMoYixhKSxifShhLlBvc3RQcm9jZXNzKTthLkZ4YWFQb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsZSxmKXt0aGlzLnNpemU9Yix0aGlzLnBvc2l0aW9uPWMsdGhpcy5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy50ZXh0dXJlJiZ0aGlzLnRleHR1cmUuZGlzcG9zZSgpO3ZhciBhPXRoaXMuX3N5c3RlbS5sZW5zRmxhcmVzLmluZGV4T2YodGhpcyk7dGhpcy5fc3lzdGVtLmxlbnNGbGFyZXMuc3BsaWNlKGEsMSl9LHRoaXMuY29sb3I9ZHx8bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLnRleHR1cmU9ZT9uZXcgYS5UZXh0dXJlKGUsZi5nZXRTY2VuZSgpLCEwKTpudWxsLHRoaXMuX3N5c3RlbT1mLGYubGVuc0ZsYXJlcy5wdXNoKHRoaXMpfXJldHVybiBifSgpO2EuTGVuc0ZsYXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIsYyl7dGhpcy5uYW1lPWEsdGhpcy5sZW5zRmxhcmVzPW5ldyBBcnJheSx0aGlzLmJvcmRlckxpbWl0PTMwMCx0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbj1bMl0sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZT04LHRoaXMuX2lzRW5hYmxlZD0hMCx0aGlzLl9zY2VuZT1jLHRoaXMuX2VtaXR0ZXI9YixjLmxlbnNGbGFyZVN5c3RlbXMucHVzaCh0aGlzKSx0aGlzLm1lc2hlc1NlbGVjdGlvblByZWRpY2F0ZT1mdW5jdGlvbihhKXtyZXR1cm4gYS5tYXRlcmlhbCYmYS5pc1Zpc2libGUmJmEuaXNFbmFibGVkKCkmJmEuY2hlY2tDb2xsaXNpb25zJiYwIT0oYS5sYXllck1hc2smYy5hY3RpdmVDYW1lcmEubGF5ZXJNYXNrKX07dmFyIGQ9W107ZC5wdXNoKDEsMSksZC5wdXNoKC0xLDEpLGQucHVzaCgtMSwtMSksZC5wdXNoKDEsLTEpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1jLmdldEVuZ2luZSgpLmNyZWF0ZVZlcnRleEJ1ZmZlcihkKTt2YXIgZT1bXTtlLnB1c2goMCksZS5wdXNoKDEpLGUucHVzaCgyKSxlLnB1c2goMCksZS5wdXNoKDIpLGUucHVzaCgzKSx0aGlzLl9pbmRleEJ1ZmZlcj1jLmdldEVuZ2luZSgpLmNyZWF0ZUluZGV4QnVmZmVyKGUpLHRoaXMuX2VmZmVjdD10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5jcmVhdGVFZmZlY3QoXCJsZW5zRmxhcmVcIixbXCJwb3NpdGlvblwiXSxbXCJjb2xvclwiLFwidmlld3BvcnRNYXRyaXhcIl0sW1widGV4dHVyZVNhbXBsZXJcIl0sXCJcIil9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImlzRW5hYmxlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNFbmFibGVkfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5faXNFbmFibGVkPWF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUuZ2V0U2NlbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NlbmV9LGIucHJvdG90eXBlLmdldEVtaXR0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW1pdHRlcn0sYi5wcm90b3R5cGUuZ2V0RW1pdHRlclBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VtaXR0ZXIuZ2V0QWJzb2x1dGVQb3NpdGlvbj90aGlzLl9lbWl0dGVyLmdldEFic29sdXRlUG9zaXRpb24oKTp0aGlzLl9lbWl0dGVyLnBvc2l0aW9ufSxiLnByb3RvdHlwZS5jb21wdXRlRWZmZWN0aXZlUG9zaXRpb249ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5nZXRFbWl0dGVyUG9zaXRpb24oKTtyZXR1cm4gYz1hLlZlY3RvcjMuUHJvamVjdChjLGEuTWF0cml4LklkZW50aXR5KCksdGhpcy5fc2NlbmUuZ2V0VHJhbnNmb3JtTWF0cml4KCksYiksdGhpcy5fcG9zaXRpb25YPWMueCx0aGlzLl9wb3NpdGlvblk9Yy55LGM9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMuZ2V0RW1pdHRlclBvc2l0aW9uKCksdGhpcy5fc2NlbmUuZ2V0Vmlld01hdHJpeCgpKSxjLno+MCYmdGhpcy5fcG9zaXRpb25YPmIueCYmdGhpcy5fcG9zaXRpb25YPGIueCtiLndpZHRoJiZ0aGlzLl9wb3NpdGlvblk+Yi55JiZ0aGlzLl9wb3NpdGlvblk8Yi55K2IuaGVpZ2h0PyEwOiExfSxiLnByb3RvdHlwZS5faXNWaXNpYmxlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2lzRW5hYmxlZClyZXR1cm4hMTt2YXIgYj10aGlzLmdldEVtaXR0ZXJQb3NpdGlvbigpLGM9Yi5zdWJ0cmFjdCh0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEucG9zaXRpb24pLGQ9Yy5sZW5ndGgoKTtjLm5vcm1hbGl6ZSgpO3ZhciBlPW5ldyBhLlJheSh0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEucG9zaXRpb24sYyksZj10aGlzLl9zY2VuZS5waWNrV2l0aFJheShlLHRoaXMubWVzaGVzU2VsZWN0aW9uUHJlZGljYXRlLCEwKTtyZXR1cm4hZi5oaXR8fGYuZGlzdGFuY2U+ZH0sYi5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VmZmVjdC5pc1JlYWR5KCkpcmV0dXJuITE7dmFyIGI9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCksYz10aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEudmlld3BvcnQsZD1jLnRvR2xvYmFsKGIpO2lmKCF0aGlzLmNvbXB1dGVFZmZlY3RpdmVQb3NpdGlvbihkKSlyZXR1cm4hMTtpZighdGhpcy5faXNWaXNpYmxlKCkpcmV0dXJuITE7dmFyIGUsZjtlPXRoaXMuX3Bvc2l0aW9uWDx0aGlzLmJvcmRlckxpbWl0K2QueD90aGlzLmJvcmRlckxpbWl0K2QueC10aGlzLl9wb3NpdGlvblg6dGhpcy5fcG9zaXRpb25YPmQueCtkLndpZHRoLXRoaXMuYm9yZGVyTGltaXQ/dGhpcy5fcG9zaXRpb25YLWQueC1kLndpZHRoK3RoaXMuYm9yZGVyTGltaXQ6MCxmPXRoaXMuX3Bvc2l0aW9uWTx0aGlzLmJvcmRlckxpbWl0K2QueT90aGlzLmJvcmRlckxpbWl0K2QueS10aGlzLl9wb3NpdGlvblk6dGhpcy5fcG9zaXRpb25ZPmQueStkLmhlaWdodC10aGlzLmJvcmRlckxpbWl0P3RoaXMuX3Bvc2l0aW9uWS1kLnktZC5oZWlnaHQrdGhpcy5ib3JkZXJMaW1pdDowO3ZhciBnPWU+Zj9lOmY7Zz50aGlzLmJvcmRlckxpbWl0JiYoZz10aGlzLmJvcmRlckxpbWl0KTt2YXIgaD0xLWcvdGhpcy5ib3JkZXJMaW1pdDtpZigwPmgpcmV0dXJuITE7aD4xJiYoaD0xKTt2YXIgaT1kLngrZC53aWR0aC8yLGo9ZC55K2QuaGVpZ2h0LzIsaz1pLXRoaXMuX3Bvc2l0aW9uWCxsPWotdGhpcy5fcG9zaXRpb25ZO2IuZW5hYmxlRWZmZWN0KHRoaXMuX2VmZmVjdCksYi5zZXRTdGF0ZSghMSksYi5zZXREZXB0aEJ1ZmZlcighMSksYi5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfQUREKSxiLmJpbmRCdWZmZXJzKHRoaXMuX3ZlcnRleEJ1ZmZlcix0aGlzLl9pbmRleEJ1ZmZlcix0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbix0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplLHRoaXMuX2VmZmVjdCk7Zm9yKHZhciBtPTA7bTx0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO20rKyl7dmFyIG49dGhpcy5sZW5zRmxhcmVzW21dLG89aS1rKm4ucG9zaXRpb24scD1qLWwqbi5wb3NpdGlvbixxPW4uc2l6ZSxyPW4uc2l6ZSpiLmdldEFzcGVjdFJhdGlvKHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYSkscz0yKihvL2Qud2lkdGgpLTEsdD0xLTIqKHAvZC5oZWlnaHQpLHU9YS5NYXRyaXguRnJvbVZhbHVlcyhxLzIsMCwwLDAsMCxyLzIsMCwwLDAsMCwxLDAscyx0LDAsMSk7dGhpcy5fZWZmZWN0LnNldE1hdHJpeChcInZpZXdwb3J0TWF0cml4XCIsdSksdGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLG4udGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0NChcImNvbG9yXCIsbi5jb2xvci5yKmgsbi5jb2xvci5nKmgsbi5jb2xvci5iKmgsMSksYi5kcmF3KCEwLDAsNilcbn1yZXR1cm4gYi5zZXREZXB0aEJ1ZmZlcighMCksYi5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfRElTQUJMRSksITB9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodGhpcy5fdmVydGV4QnVmZmVyJiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5fdmVydGV4QnVmZmVyKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9bnVsbCksdGhpcy5faW5kZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5faW5kZXhCdWZmZXI9bnVsbCk7dGhpcy5sZW5zRmxhcmVzLmxlbmd0aDspdGhpcy5sZW5zRmxhcmVzWzBdLmRpc3Bvc2UoKTt2YXIgYT10aGlzLl9zY2VuZS5sZW5zRmxhcmVTeXN0ZW1zLmluZGV4T2YodGhpcyk7dGhpcy5fc2NlbmUubGVuc0ZsYXJlU3lzdGVtcy5zcGxpY2UoYSwxKX0sYn0oKTthLkxlbnNGbGFyZVN5c3RlbT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMpe3RoaXMuYnU9YSx0aGlzLmJ2PWIsdGhpcy5kaXN0YW5jZT1jLHRoaXMuZmFjZUlkPTB9cmV0dXJuIGF9KCk7YS5JbnRlcnNlY3Rpb25JbmZvPWI7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7dGhpcy5oaXQ9ITEsdGhpcy5kaXN0YW5jZT0wLHRoaXMucGlja2VkUG9pbnQ9bnVsbCx0aGlzLnBpY2tlZE1lc2g9bnVsbCx0aGlzLmJ1PTAsdGhpcy5idj0wLHRoaXMuZmFjZUlkPS0xfXJldHVybiBiLnByb3RvdHlwZS5nZXROb3JtYWw9ZnVuY3Rpb24oKXtpZighdGhpcy5waWNrZWRNZXNofHwhdGhpcy5waWNrZWRNZXNoLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKSlyZXR1cm4gbnVsbDt2YXIgYj10aGlzLnBpY2tlZE1lc2guZ2V0SW5kaWNlcygpLGM9dGhpcy5waWNrZWRNZXNoLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKSxkPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYywzKmJbMyp0aGlzLmZhY2VJZF0pLGU9YS5WZWN0b3IzLkZyb21BcnJheShjLDMqYlszKnRoaXMuZmFjZUlkKzFdKSxmPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYywzKmJbMyp0aGlzLmZhY2VJZCsyXSk7cmV0dXJuIGQ9ZC5zY2FsZSh0aGlzLmJ1KSxlPWUuc2NhbGUodGhpcy5idiksZj1mLnNjYWxlKDEtdGhpcy5idS10aGlzLmJ2KSxuZXcgYS5WZWN0b3IzKGQueCtlLngrZi54LGQueStlLnkrZi55LGQueitlLnorZi56KX0sYi5wcm90b3R5cGUuZ2V0VGV4dHVyZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKCl7aWYoIXRoaXMucGlja2VkTWVzaHx8IXRoaXMucGlja2VkTWVzaC5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSlyZXR1cm4gbnVsbDt2YXIgYj10aGlzLnBpY2tlZE1lc2guZ2V0SW5kaWNlcygpLGM9dGhpcy5waWNrZWRNZXNoLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQpLGQ9YS5WZWN0b3IyLkZyb21BcnJheShjLDIqYlszKnRoaXMuZmFjZUlkXSksZT1hLlZlY3RvcjIuRnJvbUFycmF5KGMsMipiWzMqdGhpcy5mYWNlSWQrMV0pLGY9YS5WZWN0b3IyLkZyb21BcnJheShjLDIqYlszKnRoaXMuZmFjZUlkKzJdKTtyZXR1cm4gZD1kLnNjYWxlKHRoaXMuYnUpLGU9ZS5zY2FsZSh0aGlzLmJ2KSxmPWYuc2NhbGUoMS10aGlzLmJ1LXRoaXMuYnYpLG5ldyBhLlZlY3RvcjIoZC54K2UueCtmLngsZC55K2UueStmLnkpfSxifSgpO2EuUGlja2luZ0luZm89Y30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmLGcsaCl7dGhpcy5lbmdpbmU9YSx0aGlzLmNhbnZhcz1jLHRoaXMuY3VycmVudFNjZW5lPWIsdGhpcy5zY2VuZUxvYWRlZENhbGxiYWNrPWQsdGhpcy5wcm9ncmVzc0NhbGxiYWNrPWUsdGhpcy5hZGRpdGlvbm5hbFJlbmRlckxvb3BMb2dpY0NhbGxiYWNrPWYsdGhpcy50ZXh0dXJlTG9hZGluZ0NhbGxiYWNrPWcsdGhpcy5zdGFydGluZ1Byb2Nlc3NpbmdGaWxlc0NhbGxiYWNrPWh9cmV0dXJuIGIucHJvdG90eXBlLm1vbml0b3JFbGVtZW50Rm9yRHJhZ05Ecm9wPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7YSYmKHRoaXMuZWxlbWVudFRvTW9uaXRvcj1hLHRoaXMuZWxlbWVudFRvTW9uaXRvci5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsZnVuY3Rpb24oYSl7Yi5kcmFnKGEpfSwhMSksdGhpcy5lbGVtZW50VG9Nb25pdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLGZ1bmN0aW9uKGEpe2IuZHJhZyhhKX0sITEpLHRoaXMuZWxlbWVudFRvTW9uaXRvci5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLGZ1bmN0aW9uKGEpe2IuZHJvcChhKX0sITEpKX0sYi5wcm90b3R5cGUucmVuZGVyRnVuY3Rpb249ZnVuY3Rpb24oKXtpZih0aGlzLmFkZGl0aW9ubmFsUmVuZGVyTG9vcExvZ2ljQ2FsbGJhY2smJnRoaXMuYWRkaXRpb25uYWxSZW5kZXJMb29wTG9naWNDYWxsYmFjaygpLHRoaXMuY3VycmVudFNjZW5lKXtpZih0aGlzLnRleHR1cmVMb2FkaW5nQ2FsbGJhY2spe3ZhciBhPXRoaXMuY3VycmVudFNjZW5lLmdldFdhaXRpbmdJdGVtc0NvdW50KCk7YT4wJiZ0aGlzLnRleHR1cmVMb2FkaW5nQ2FsbGJhY2soYSl9dGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCl9fSxiLnByb3RvdHlwZS5kcmFnPWZ1bmN0aW9uKGEpe2Euc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpfSxiLnByb3RvdHlwZS5kcm9wPWZ1bmN0aW9uKGEpe2Euc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMubG9hZEZpbGVzKGEpfSxiLnByb3RvdHlwZS5sb2FkRmlsZXM9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPXRoaXM7dGhpcy5zdGFydGluZ1Byb2Nlc3NpbmdGaWxlc0NhbGxiYWNrJiZ0aGlzLnN0YXJ0aW5nUHJvY2Vzc2luZ0ZpbGVzQ2FsbGJhY2soKTt2YXIgZSxmO2lmKGImJmIuZGF0YVRyYW5zZmVyJiZiLmRhdGFUcmFuc2Zlci5maWxlcyYmKGY9Yi5kYXRhVHJhbnNmZXIuZmlsZXMpLGImJmIudGFyZ2V0JiZiLnRhcmdldC5maWxlcyYmKGY9Yi50YXJnZXQuZmlsZXMpLGYmJmYubGVuZ3RoPjApe2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXN3aXRjaChmW2ddLnR5cGUpe2Nhc2VcImltYWdlL2pwZWdcIjpjYXNlXCJpbWFnZS9wbmdcIjphLkZpbGVzSW5wdXQuRmlsZXNUZXh0dXJlc1tmW2ddLm5hbWVdPWZbZ107YnJlYWs7Y2FzZVwiaW1hZ2UvdGFyZ2FcIjpjYXNlXCJpbWFnZS92bmQubXMtZGRzXCI6YS5GaWxlc0lucHV0LkZpbGVzVG9Mb2FkW2ZbZ10ubmFtZV09ZltnXTticmVhaztkZWZhdWx0Oi0xIT09ZltnXS5uYW1lLmluZGV4T2YoXCIuYmFieWxvblwiKSYmLTE9PT1mW2ddLm5hbWUuaW5kZXhPZihcIi5tYW5pZmVzdFwiKSYmLTE9PT1mW2ddLm5hbWUuaW5kZXhPZihcIi5pbmNyZW1lbnRhbFwiKSYmLTE9PT1mW2ddLm5hbWUuaW5kZXhPZihcIi5iYWJ5bG9ubWVzaGRhdGFcIikmJi0xPT09ZltnXS5uYW1lLmluZGV4T2YoXCIuYmFieWxvbmdlb21ldHJ5ZGF0YVwiKSYmKGU9ZltnXSl9ZT8odGhpcy5jdXJyZW50U2NlbmUmJih0aGlzLmVuZ2luZS5zdG9wUmVuZGVyTG9vcCgpLHRoaXMuY3VycmVudFNjZW5lLmRpc3Bvc2UoKSksYS5TY2VuZUxvYWRlci5Mb2FkKFwiZmlsZTpcIixlLHRoaXMuZW5naW5lLGZ1bmN0aW9uKGEpe2QuY3VycmVudFNjZW5lPWEsZC5jdXJyZW50U2NlbmUuZXhlY3V0ZVdoZW5SZWFkeShmdW5jdGlvbigpe2QuY3VycmVudFNjZW5lLmFjdGl2ZUNhbWVyYSYmZC5jdXJyZW50U2NlbmUuYWN0aXZlQ2FtZXJhLmF0dGFjaENvbnRyb2woZC5jYW52YXMpLGQuc2NlbmVMb2FkZWRDYWxsYmFjayYmZC5zY2VuZUxvYWRlZENhbGxiYWNrKGUsZC5jdXJyZW50U2NlbmUpLGQuZW5naW5lLnJ1blJlbmRlckxvb3AoZnVuY3Rpb24oKXtkLnJlbmRlckZ1bmN0aW9uKCl9KX0pfSxmdW5jdGlvbihhKXtjLnByb2dyZXNzQ2FsbGJhY2smJmMucHJvZ3Jlc3NDYWxsYmFjayhhKX0pKTphLlRvb2xzLkVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCAuYmFieWxvbiBmaWxlLlwiKX19LGIuRmlsZXNUZXh0dXJlcz1uZXcgQXJyYXksYi5GaWxlc1RvTG9hZD1uZXcgQXJyYXksYn0oKTthLkZpbGVzSW5wdXQ9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcz1bXSx0aGlzLnVwZGF0ZUJvZHlQb3NpdGlvbj1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tiXTtpZihjLm1lc2g9PT1hfHxjLm1lc2g9PT1hLnBhcmVudCl7dmFyIGQ9Yy5ib2R5LmJvZHk7cmV0dXJuIGQuc2V0UG9zaXRpb24oYS5wb3NpdGlvbi54LGEucG9zaXRpb24ueSxhLnBvc2l0aW9uLnopLHZvaWQgZC5zZXRPcmllbnRhdGlvbihhLnJvdGF0aW9uLngsYS5yb3RhdGlvbi55LGEucm90YXRpb24ueil9aWYoYy5tZXNoLnBhcmVudD09PWEpe2EuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxjLm1lc2guY29tcHV0ZVdvcmxkTWF0cml4KCEwKTt2YXIgZT1jLm1lc2guZ2V0QWJzb2x1dGVQb3NpdGlvbigpLGY9YS5yb3RhdGlvbjtyZXR1cm4gZD1jLmJvZHkuYm9keSxkLnNldFBvc2l0aW9uKGUueCxlLnksZS56KSx2b2lkIGQuc2V0T3JpZW50YXRpb24oZi54LGYueSxmLnopfX19fXJldHVybiBiLnByb3RvdHlwZS5fY2hlY2tXaXRoRXBzaWxvbj1mdW5jdGlvbihiKXtyZXR1cm4gYjxhLlBoeXNpY3NFbmdpbmUuRXBzaWxvbj9hLlBoeXNpY3NFbmdpbmUuRXBzaWxvbjpifSxiLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKCl7dGhpcy5fd29ybGQ9bmV3IE9JTU8uV29ybGQsdGhpcy5fd29ybGQuY2xlYXIoKX0sYi5wcm90b3R5cGUuc2V0R3Jhdml0eT1mdW5jdGlvbihhKXt0aGlzLl93b3JsZC5ncmF2aXR5PWF9LGIucHJvdG90eXBlLnJlZ2lzdGVyTWVzaD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bnVsbDtzd2l0Y2godGhpcy51bnJlZ2lzdGVyTWVzaChiKSxiLmNvbXB1dGVXb3JsZE1hdHJpeCghMCksYyl7Y2FzZSBhLlBoeXNpY3NFbmdpbmUuU3BoZXJlSW1wb3N0b3I6dmFyIGY9Yi5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveCxnPWYubWF4aW11bVdvcmxkLngtZi5taW5pbXVtV29ybGQueCxoPWYubWF4aW11bVdvcmxkLnktZi5taW5pbXVtV29ybGQueSxpPWYubWF4aW11bVdvcmxkLnotZi5taW5pbXVtV29ybGQueixqPU1hdGgubWF4KHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oZyksdGhpcy5fY2hlY2tXaXRoRXBzaWxvbihoKSx0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGkpKS8yO2U9bmV3IE9JTU8uQm9keSh7dHlwZTpcInNwaGVyZVwiLHNpemU6W2pdLHBvczpbYi5wb3NpdGlvbi54LGIucG9zaXRpb24ueSxiLnBvc2l0aW9uLnpdLHJvdDpbYi5yb3RhdGlvbi54L09JTU8uVE9fUkFELGIucm90YXRpb24ueS9PSU1PLlRPX1JBRCxiLnJvdGF0aW9uLnovT0lNTy5UT19SQURdLG1vdmU6MCE9ZC5tYXNzLGNvbmZpZzpbZC5tYXNzLGQuZnJpY3Rpb24sZC5yZXN0aXR1dGlvbl0sd29ybGQ6dGhpcy5fd29ybGR9KSx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLnB1c2goe21lc2g6Yixib2R5OmV9KTticmVhaztjYXNlIGEuUGh5c2ljc0VuZ2luZS5QbGFuZUltcG9zdG9yOmNhc2UgYS5QaHlzaWNzRW5naW5lLkJveEltcG9zdG9yOmY9Yi5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveDt2YXIgaz1mLm1pbmltdW1Xb3JsZCxsPWYubWF4aW11bVdvcmxkLG09bC5zdWJ0cmFjdChrKSxuPXRoaXMuX2NoZWNrV2l0aEVwc2lsb24obS54KSxvPXRoaXMuX2NoZWNrV2l0aEVwc2lsb24obS55KSxwPXRoaXMuX2NoZWNrV2l0aEVwc2lsb24obS56KTtlPW5ldyBPSU1PLkJvZHkoe3R5cGU6XCJib3hcIixzaXplOltuLG8scF0scG9zOltiLnBvc2l0aW9uLngsYi5wb3NpdGlvbi55LGIucG9zaXRpb24uel0scm90OltiLnJvdGF0aW9uLngvT0lNTy5UT19SQUQsYi5yb3RhdGlvbi55L09JTU8uVE9fUkFELGIucm90YXRpb24uei9PSU1PLlRPX1JBRF0sbW92ZTowIT1kLm1hc3MsY29uZmlnOltkLm1hc3MsZC5mcmljdGlvbixkLnJlc3RpdHV0aW9uXSx3b3JsZDp0aGlzLl93b3JsZH0pLHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMucHVzaCh7bWVzaDpiLGJvZHk6ZX0pfXJldHVybiBlfSxiLnByb3RvdHlwZS5yZWdpc3Rlck1lc2hlc0FzQ29tcG91bmQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD1bXSxlPVtdLGY9W10sZz1hWzBdLm1lc2gsaD0wO2g8YS5sZW5ndGg7aCsrKXt2YXIgaT1hW2hdLGo9dGhpcy5fY3JlYXRlQm9keUFzQ29tcG91bmQoaSxiLGcpO2MucHVzaChqLnR5cGUpLGQucHVzaC5hcHBseShkLGouc2l6ZSksZS5wdXNoLmFwcGx5KGUsai5wb3MpLGYucHVzaC5hcHBseShmLGoucm90KX12YXIgaz1uZXcgT0lNTy5Cb2R5KHt0eXBlOmMsc2l6ZTpkLHBvczplLHJvdDpmLG1vdmU6MCE9Yi5tYXNzLGNvbmZpZzpbYi5tYXNzLGIuZnJpY3Rpb24sYi5yZXN0aXR1dGlvbl0sd29ybGQ6dGhpcy5fd29ybGR9KTtyZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5wdXNoKHttZXNoOmcsYm9keTprfSksa30sYi5wcm90b3R5cGUuX2NyZWF0ZUJvZHlBc0NvbXBvdW5kPWZ1bmN0aW9uKGIpe3ZhciBjPW51bGwsZD1iLm1lc2g7c3dpdGNoKGIuaW1wb3N0b3Ipe2Nhc2UgYS5QaHlzaWNzRW5naW5lLlNwaGVyZUltcG9zdG9yOnZhciBlPWQuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gsZj1lLm1heGltdW1Xb3JsZC54LWUubWluaW11bVdvcmxkLngsZz1lLm1heGltdW1Xb3JsZC55LWUubWluaW11bVdvcmxkLnksaD1lLm1heGltdW1Xb3JsZC56LWUubWluaW11bVdvcmxkLnosaT1NYXRoLm1heCh0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGYpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oZyksdGhpcy5fY2hlY2tXaXRoRXBzaWxvbihoKSkvMjtjPXt0eXBlOlwic3BoZXJlXCIsc2l6ZTpbaSwtMSwtMV0scG9zOltkLnBvc2l0aW9uLngsZC5wb3NpdGlvbi55LGQucG9zaXRpb24uel0scm90OltkLnJvdGF0aW9uLngvT0lNTy5UT19SQUQsZC5yb3RhdGlvbi55L09JTU8uVE9fUkFELGQucm90YXRpb24uei9PSU1PLlRPX1JBRF19O2JyZWFrO2Nhc2UgYS5QaHlzaWNzRW5naW5lLlBsYW5lSW1wb3N0b3I6Y2FzZSBhLlBoeXNpY3NFbmdpbmUuQm94SW1wb3N0b3I6ZT1kLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94O3ZhciBqPWUubWluaW11bVdvcmxkLGs9ZS5tYXhpbXVtV29ybGQsbD1rLnN1YnRyYWN0KGopLG09dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihsLngpLG49dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihsLnkpLG89dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihsLnopLHA9ZC5wb3NpdGlvbjtjPXt0eXBlOlwiYm94XCIsc2l6ZTpbbSxuLG9dLHBvczpbcC54LHAueSxwLnpdLHJvdDpbZC5yb3RhdGlvbi54L09JTU8uVE9fUkFELGQucm90YXRpb24ueS9PSU1PLlRPX1JBRCxkLnJvdGF0aW9uLnovT0lNTy5UT19SQURdfX1yZXR1cm4gY30sYi5wcm90b3R5cGUudW5yZWdpc3Rlck1lc2g9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbYl07aWYoYy5tZXNoPT09YXx8Yy5tZXNoPT09YS5wYXJlbnQpcmV0dXJuIGMuYm9keSYmKHRoaXMuX3dvcmxkLnJlbW92ZVJpZ2lkQm9keShjLmJvZHkuYm9keSksdGhpcy5fdW5iaW5kQm9keShjLmJvZHkpKSx2b2lkIHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMuc3BsaWNlKGIsMSl9fSxiLnByb3RvdHlwZS5fdW5iaW5kQm9keT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tiXTtjLmJvZHk9PT1hJiYoYy5ib2R5PW51bGwpfX0sYi5wcm90b3R5cGUuYXBwbHlJbXB1bHNlPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MDtkPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tkXTtpZihlLm1lc2g9PT1hfHxlLm1lc2g9PT1hLnBhcmVudClyZXR1cm4gdm9pZCBlLmJvZHkuYm9keS5hcHBseUltcHVsc2UoYy5zY2FsZShPSU1PLklOVl9TQ0FMRSksYi5zY2FsZShPSU1PLklOVl9TQ0FMRSkpfX0sYi5wcm90b3R5cGUuY3JlYXRlTGluaz1mdW5jdGlvbihhLGIsYyxkLGUpe2Zvcih2YXIgZj1udWxsLGc9bnVsbCxoPTA7aDx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDtoKyspe3ZhciBpPXRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbaF07aS5tZXNoPT09YT9mPWkuYm9keS5ib2R5OmkubWVzaD09PWImJihnPWkuYm9keS5ib2R5KX1yZXR1cm4gZiYmZz8oZXx8KGU9e30pLG5ldyBPSU1PLkxpbmsoe3R5cGU6ZS50eXBlLGJvZHkxOmYsYm9keTI6ZyxtaW46ZS5taW4sbWF4OmUubWF4LGF4ZTE6ZS5heGUxLGF4ZTI6ZS5heGUyLHBvczE6W2MueCxjLnksYy56XSxwb3MyOltkLngsZC55LGQuel0sY29sbGlzaW9uOmUuY29sbGlzaW9uLHNwcmluZzplLnNwcmluZyx3b3JsZDp0aGlzLl93b3JsZH0pLCEwKTohMX0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih0aGlzLl93b3JsZC5jbGVhcigpO3RoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoOyl0aGlzLnVucmVnaXN0ZXJNZXNoKHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbMF0ubWVzaCl9LGIucHJvdG90eXBlLmlzU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PU9JTU99LGIucHJvdG90eXBlLl9nZXRMYXN0U2hhcGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEuc2hhcGVzO2IubmV4dDspYj1iLm5leHQ7cmV0dXJuIGJ9LGIucHJvdG90eXBlLnJ1bk9uZVN0ZXA9ZnVuY3Rpb24oKXt0aGlzLl93b3JsZC5zdGVwKCk7Zm9yKHZhciBiLGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7Yy0tOyl7dmFyIGQ9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tjXS5ib2R5LmJvZHksZT10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2NdLm1lc2g7aWYoIWQuc2xlZXBpbmcpaWYoZC5zaGFwZXMubmV4dCl7dmFyIGY9dGhpcy5fZ2V0TGFzdFNoYXBlKGQpO2UucG9zaXRpb24ueD1mLnBvc2l0aW9uLngqT0lNTy5XT1JMRF9TQ0FMRSxlLnBvc2l0aW9uLnk9Zi5wb3NpdGlvbi55Kk9JTU8uV09STERfU0NBTEUsZS5wb3NpdGlvbi56PWYucG9zaXRpb24ueipPSU1PLldPUkxEX1NDQUxFO3ZhciBnPWEuTWF0cml4LkZyb21BcnJheShkLmdldE1hdHJpeCgpKTtlLnJvdGF0aW9uUXVhdGVybmlvbnx8KGUucm90YXRpb25RdWF0ZXJuaW9uPW5ldyBhLlF1YXRlcm5pb24oMCwwLDAsMSkpLGUucm90YXRpb25RdWF0ZXJuaW9uLmZyb21Sb3RhdGlvbk1hdHJpeChnKX1lbHNlIGI9ZC5nZXRNYXRyaXgoKSxnPWEuTWF0cml4LkZyb21BcnJheShiKSxlLnBvc2l0aW9uLng9Zy5tWzEyXSxlLnBvc2l0aW9uLnk9Zy5tWzEzXSxlLnBvc2l0aW9uLno9Zy5tWzE0XSxlLnJvdGF0aW9uUXVhdGVybmlvbnx8KGUucm90YXRpb25RdWF0ZXJuaW9uPW5ldyBhLlF1YXRlcm5pb24oMCwwLDAsMSkpLGUucm90YXRpb25RdWF0ZXJuaW9uLmZyb21Sb3RhdGlvbk1hdHJpeChnKX19LGJ9KCk7YS5PaW1vSlNQbHVnaW49Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3RoaXMuX2N1cnJlbnRQbHVnaW49Ynx8bmV3IGEuT2ltb0pTUGx1Z2lufXJldHVybiBiLnByb3RvdHlwZS5faW5pdGlhbGl6ZT1mdW5jdGlvbihhKXt0aGlzLl9jdXJyZW50UGx1Z2luLmluaXRpYWxpemUoKSx0aGlzLl9zZXRHcmF2aXR5KGEpfSxiLnByb3RvdHlwZS5fcnVuT25lU3RlcD1mdW5jdGlvbihhKXthPi4xP2E9LjE6MD49YSYmKGE9MS82MCksdGhpcy5fY3VycmVudFBsdWdpbi5ydW5PbmVTdGVwKGEpfSxiLnByb3RvdHlwZS5fc2V0R3Jhdml0eT1mdW5jdGlvbihiKXt0aGlzLmdyYXZpdHk9Ynx8bmV3IGEuVmVjdG9yMygwLC05LjgyLDApLHRoaXMuX2N1cnJlbnRQbHVnaW4uc2V0R3Jhdml0eSh0aGlzLmdyYXZpdHkpfSxiLnByb3RvdHlwZS5fcmVnaXN0ZXJNZXNoPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5fY3VycmVudFBsdWdpbi5yZWdpc3Rlck1lc2goYSxiLGMpfSxiLnByb3RvdHlwZS5fcmVnaXN0ZXJNZXNoZXNBc0NvbXBvdW5kPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2N1cnJlbnRQbHVnaW4ucmVnaXN0ZXJNZXNoZXNBc0NvbXBvdW5kKGEsYil9LGIucHJvdG90eXBlLl91bnJlZ2lzdGVyTWVzaD1mdW5jdGlvbihhKXt0aGlzLl9jdXJyZW50UGx1Z2luLnVucmVnaXN0ZXJNZXNoKGEpfSxiLnByb3RvdHlwZS5fYXBwbHlJbXB1bHNlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLl9jdXJyZW50UGx1Z2luLmFwcGx5SW1wdWxzZShhLGIsYyl9LGIucHJvdG90eXBlLl9jcmVhdGVMaW5rPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHRoaXMuX2N1cnJlbnRQbHVnaW4uY3JlYXRlTGluayhhLGIsYyxkLGUpfSxiLnByb3RvdHlwZS5fdXBkYXRlQm9keVBvc2l0aW9uPWZ1bmN0aW9uKGEpe3RoaXMuX2N1cnJlbnRQbHVnaW4udXBkYXRlQm9keVBvc2l0aW9uKGEpfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY3VycmVudFBsdWdpbi5kaXNwb3NlKCl9LGIucHJvdG90eXBlLmlzU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRQbHVnaW4uaXNTdXBwb3J0ZWQoKX0sYi5Ob0ltcG9zdG9yPTAsYi5TcGhlcmVJbXBvc3Rvcj0xLGIuQm94SW1wb3N0b3I9MixiLlBsYW5lSW1wb3N0b3I9MyxiLkNvbXBvdW5kSW1wb3N0b3I9NCxiLk1lc2hJbXBvc3Rvcj00LGIuQ2Fwc3VsZUltcG9zdG9yPTUsYi5Db25lSW1wb3N0b3I9NixiLkN5bGluZGVySW1wb3N0b3I9NyxiLkNvbnZleEh1bGxJbXBvc3Rvcj04LGIuRXBzaWxvbj0uMDAxLGJ9KCk7YS5QaHlzaWNzRW5naW5lPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe3ZhciBjPXt9O2lmKGMubmFtZT1iLm5hbWUsYy5pZD1iLmlkLGMudGFncz1hLlRhZ3MuR2V0VGFncyhiKSxiIGluc3RhbmNlb2YgYS5Qb2ludExpZ2h0KWMudHlwZT0wLGMucG9zaXRpb249Yi5wb3NpdGlvbi5hc0FycmF5KCk7ZWxzZSBpZihiIGluc3RhbmNlb2YgYS5EaXJlY3Rpb25hbExpZ2h0KXtjLnR5cGU9MTt2YXIgZD1iO2MucG9zaXRpb249ZC5wb3NpdGlvbi5hc0FycmF5KCksYy5kaXJlY3Rpb249ZC5kaXJlY3Rpb24uYXNBcnJheSgpfWVsc2UgaWYoYiBpbnN0YW5jZW9mIGEuU3BvdExpZ2h0KXtjLnR5cGU9Mjt2YXIgZT1iO2MucG9zaXRpb249ZS5wb3NpdGlvbi5hc0FycmF5KCksYy5kaXJlY3Rpb249ZS5wb3NpdGlvbi5hc0FycmF5KCksYy5hbmdsZT1lLmFuZ2xlLGMuZXhwb25lbnQ9ZS5leHBvbmVudH1lbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkhlbWlzcGhlcmljTGlnaHQpe2MudHlwZT0zO3ZhciBmPWI7Yy5kaXJlY3Rpb249Zi5kaXJlY3Rpb24uYXNBcnJheSgpLGMuZ3JvdW5kQ29sb3I9Zi5ncm91bmRDb2xvci5hc0FycmF5KCl9cmV0dXJuIGIuaW50ZW5zaXR5JiYoYy5pbnRlbnNpdHk9Yi5pbnRlbnNpdHkpLGMucmFuZ2U9Yi5yYW5nZSxjLmRpZmZ1c2U9Yi5kaWZmdXNlLmFzQXJyYXkoKSxjLnNwZWN1bGFyPWIuc3BlY3VsYXIuYXNBcnJheSgpLGN9LGM9ZnVuY3Rpb24oYil7dmFyIGM9e307cmV0dXJuIGMubmFtZT1iLm5hbWUsYy50YWdzPWEuVGFncy5HZXRUYWdzKGIpLGMuaWQ9Yi5pZCxjLnBvc2l0aW9uPWIucG9zaXRpb24uYXNBcnJheSgpLGIucGFyZW50JiYoYy5wYXJlbnRJZD1iLnBhcmVudC5pZCksYy5yb3RhdGlvbj1iLnJvdGF0aW9uLmFzQXJyYXkoKSxiLmxvY2tlZFRhcmdldCYmYi5sb2NrZWRUYXJnZXQuaWQmJihjLmxvY2tlZFRhcmdldElkPWIubG9ja2VkVGFyZ2V0LmlkKSxjLmZvdj1iLmZvdixjLm1pblo9Yi5taW5aLGMubWF4Wj1iLm1heFosYy5zcGVlZD1iLnNwZWVkLGMuaW5lcnRpYT1iLmluZXJ0aWEsYy5jaGVja0NvbGxpc2lvbnM9Yi5jaGVja0NvbGxpc2lvbnMsYy5hcHBseUdyYXZpdHk9Yi5hcHBseUdyYXZpdHksYi5lbGxpcHNvaWQmJihjLmVsbGlwc29pZD1iLmVsbGlwc29pZC5hc0FycmF5KCkpLGQoYixjKSxjLmxheWVyTWFzaz1iLmxheWVyTWFzayxjfSxkPWZ1bmN0aW9uKGEsYil7aWYoYS5hbmltYXRpb25zKXtiLmFuaW1hdGlvbnM9W107Zm9yKHZhciBjPTA7YzxhLmFuaW1hdGlvbnMubGVuZ3RoO2MrKyl7dmFyIGQ9YS5hbmltYXRpb25zW2NdO2IuYW5pbWF0aW9ucy5wdXNoKGUoZCkpfX19LGU9ZnVuY3Rpb24oYil7dmFyIGM9e307Yy5uYW1lPWIubmFtZSxjLnByb3BlcnR5PWIudGFyZ2V0UHJvcGVydHksYy5mcmFtZVBlclNlY29uZD1iLmZyYW1lUGVyU2Vjb25kLGMuZGF0YVR5cGU9Yi5kYXRhVHlwZSxjLmxvb3BCZWhhdmlvcj1iLmxvb3BNb2RlO3ZhciBkPWIuZGF0YVR5cGU7Yy5rZXlzPVtdO2Zvcih2YXIgZT1iLmdldEtleXMoKSxmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl0saD17fTtzd2l0Y2goaC5mcmFtZT1nLmZyYW1lLGQpe2Nhc2UgYS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVDpoLnZhbHVlcz1bZy52YWx1ZV07YnJlYWs7Y2FzZSBhLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX1FVQVRFUk5JT046Y2FzZSBhLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX01BVFJJWDpjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfVkVDVE9SMzpoLnZhbHVlcz1nLnZhbHVlLmFzQXJyYXkoKX1jLmtleXMucHVzaChoKX1yZXR1cm4gY30sZj1mdW5jdGlvbihiKXt2YXIgYz17fTtjLm5hbWU9Yi5uYW1lLGMuaWQ9Yi5pZCxjLnRhZ3M9YS5UYWdzLkdldFRhZ3MoYiksYy5tYXRlcmlhbHM9W107Zm9yKHZhciBkPTA7ZDxiLnN1Yk1hdGVyaWFscy5sZW5ndGg7ZCsrKXt2YXIgZT1iLnN1Yk1hdGVyaWFsc1tkXTtjLm1hdGVyaWFscy5wdXNoKGU/ZS5pZDpudWxsKX1yZXR1cm4gY30sZz1mdW5jdGlvbihiKXt2YXIgYz17fTtyZXR1cm4gYy5uYW1lPWIubmFtZSxjLmFtYmllbnQ9Yi5hbWJpZW50Q29sb3IuYXNBcnJheSgpLGMuZGlmZnVzZT1iLmRpZmZ1c2VDb2xvci5hc0FycmF5KCksYy5zcGVjdWxhcj1iLnNwZWN1bGFyQ29sb3IuYXNBcnJheSgpLGMuc3BlY3VsYXJQb3dlcj1iLnNwZWN1bGFyUG93ZXIsYy5lbWlzc2l2ZT1iLmVtaXNzaXZlQ29sb3IuYXNBcnJheSgpLGMuYWxwaGE9Yi5hbHBoYSxjLmlkPWIuaWQsYy50YWdzPWEuVGFncy5HZXRUYWdzKGIpLGMuYmFja0ZhY2VDdWxsaW5nPWIuYmFja0ZhY2VDdWxsaW5nLGIuZGlmZnVzZVRleHR1cmUmJihjLmRpZmZ1c2VUZXh0dXJlPWgoYi5kaWZmdXNlVGV4dHVyZSkpLGIuYW1iaWVudFRleHR1cmUmJihjLmFtYmllbnRUZXh0dXJlPWgoYi5hbWJpZW50VGV4dHVyZSkpLGIub3BhY2l0eVRleHR1cmUmJihjLm9wYWNpdHlUZXh0dXJlPWgoYi5vcGFjaXR5VGV4dHVyZSkpLGIucmVmbGVjdGlvblRleHR1cmUmJihjLnJlZmxlY3Rpb25UZXh0dXJlPWgoYi5yZWZsZWN0aW9uVGV4dHVyZSkpLGIuZW1pc3NpdmVUZXh0dXJlJiYoYy5lbWlzc2l2ZVRleHR1cmU9aChiLmVtaXNzaXZlVGV4dHVyZSkpLGIuc3BlY3VsYXJUZXh0dXJlJiYoYy5zcGVjdWxhclRleHR1cmU9aChiLnNwZWN1bGFyVGV4dHVyZSkpLGIuYnVtcFRleHR1cmUmJihjLmJ1bXBUZXh0dXJlPWgoYi5idW1wVGV4dHVyZSkpLGN9LGg9ZnVuY3Rpb24oYil7dmFyIGM9e307aWYoIWIubmFtZSlyZXR1cm4gbnVsbDtpZihiIGluc3RhbmNlb2YgYS5DdWJlVGV4dHVyZSlyZXR1cm4gYy5uYW1lPWIubmFtZSxjLmhhc0FscGhhPWIuaGFzQWxwaGEsYy5sZXZlbD1iLmxldmVsLGMuY29vcmRpbmF0ZXNNb2RlPWIuY29vcmRpbmF0ZXNNb2RlLGM7aWYoYiBpbnN0YW5jZW9mIGEuTWlycm9yVGV4dHVyZSl7dmFyIGU9YjtjLnJlbmRlclRhcmdldFNpemU9ZS5nZXRSZW5kZXJTaXplKCksYy5yZW5kZXJMaXN0PVtdO2Zvcih2YXIgZj0wO2Y8ZS5yZW5kZXJMaXN0Lmxlbmd0aDtmKyspYy5yZW5kZXJMaXN0LnB1c2goZS5yZW5kZXJMaXN0W2ZdLmlkKTtjLm1pcnJvclBsYW5lPWUubWlycm9yUGxhbmUuYXNBcnJheSgpfWVsc2UgaWYoYiBpbnN0YW5jZW9mIGEuUmVuZGVyVGFyZ2V0VGV4dHVyZSl7dmFyIGc9Yjtmb3IoYy5yZW5kZXJUYXJnZXRTaXplPWcuZ2V0UmVuZGVyU2l6ZSgpLGMucmVuZGVyTGlzdD1bXSxmPTA7ZjxnLnJlbmRlckxpc3QubGVuZ3RoO2YrKyljLnJlbmRlckxpc3QucHVzaChnLnJlbmRlckxpc3RbZl0uaWQpfXZhciBoPWI7cmV0dXJuIGMubmFtZT1iLm5hbWUsYy5oYXNBbHBoYT1iLmhhc0FscGhhLGMubGV2ZWw9Yi5sZXZlbCxjLmNvb3JkaW5hdGVzSW5kZXg9Yi5jb29yZGluYXRlc0luZGV4LGMuY29vcmRpbmF0ZXNNb2RlPWIuY29vcmRpbmF0ZXNNb2RlLGMudU9mZnNldD1oLnVPZmZzZXQsYy52T2Zmc2V0PWgudk9mZnNldCxjLnVTY2FsZT1oLnVTY2FsZSxjLnZTY2FsZT1oLnZTY2FsZSxjLnVBbmc9aC51QW5nLGMudkFuZz1oLnZBbmcsYy53QW5nPWgud0FuZyxjLndyYXBVPWIud3JhcFUsYy53cmFwVj1iLndyYXBWLGQoYixjKSxjfSxpPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O2IubmFtZT1hLm5hbWUsYi5pZD1hLmlkLGIuYm9uZXM9W107Zm9yKHZhciBjPTA7YzxhLmJvbmVzLmxlbmd0aDtjKyspe3ZhciBkPWEuYm9uZXNbY10sZj17cGFyZW50Qm9uZUluZGV4OmQuZ2V0UGFyZW50KCk/YS5ib25lcy5pbmRleE9mKGQuZ2V0UGFyZW50KCkpOi0xLG5hbWU6ZC5uYW1lLG1hdHJpeDpkLmdldExvY2FsTWF0cml4KCkudG9BcnJheSgpfTtiLmJvbmVzLnB1c2goZiksZC5hbmltYXRpb25zJiZkLmFuaW1hdGlvbnMubGVuZ3RoPjAmJihmLmFuaW1hdGlvbj1lKGQuYW5pbWF0aW9uc1swXSkpfXJldHVybiBifSxqPWZ1bmN0aW9uKGEpe3ZhciBiPXt9O3JldHVybiBiLmVtaXR0ZXJJZD1hLmVtaXR0ZXIuaWQsYi5jYXBhY2l0eT1hLmdldENhcGFjaXR5KCksYS5wYXJ0aWNsZVRleHR1cmUmJihiLnRleHR1cmVOYW1lPWEucGFydGljbGVUZXh0dXJlLm5hbWUpLGIubWluQW5ndWxhclNwZWVkPWEubWluQW5ndWxhclNwZWVkLGIubWF4QW5ndWxhclNwZWVkPWEubWF4QW5ndWxhclNwZWVkLGIubWluU2l6ZT1hLm1pblNpemUsYi5tYXhTaXplPWEubWF4U2l6ZSxiLm1pbkxpZmVUaW1lPWEubWluTGlmZVRpbWUsYi5tYXhMaWZlVGltZT1hLm1heExpZmVUaW1lLGIuZW1pdFJhdGU9YS5lbWl0UmF0ZSxiLm1pbkVtaXRCb3g9YS5taW5FbWl0Qm94LmFzQXJyYXkoKSxiLm1heEVtaXRCb3g9YS5tYXhFbWl0Qm94LmFzQXJyYXkoKSxiLmdyYXZpdHk9YS5ncmF2aXR5LmFzQXJyYXkoKSxiLmRpcmVjdGlvbjE9YS5kaXJlY3Rpb24xLmFzQXJyYXkoKSxiLmRpcmVjdGlvbjI9YS5kaXJlY3Rpb24yLmFzQXJyYXkoKSxiLmNvbG9yMT1hLmNvbG9yMS5hc0FycmF5KCksYi5jb2xvcjI9YS5jb2xvcjIuYXNBcnJheSgpLGIuY29sb3JEZWFkPWEuY29sb3JEZWFkLmFzQXJyYXkoKSxiLnVwZGF0ZVNwZWVkPWEudXBkYXRlU3BlZWQsYi50YXJnZXRTdG9wRHVyYXRpb249YS50YXJnZXRTdG9wRHVyYXRpb24sYi50ZXh0dXJlTWFzaz1hLnRleHR1cmVNYXNrLmFzQXJyYXkoKSxiLmJsZW5kTW9kZT1hLmJsZW5kTW9kZSxifSxrPWZ1bmN0aW9uKGIpe3ZhciBjPXt9O2MuZW1pdHRlcklkPWIuZ2V0RW1pdHRlcigpLmlkLGMuYm9yZGVyTGltaXQ9Yi5ib3JkZXJMaW1pdCxjLmZsYXJlcz1bXTtmb3IodmFyIGQ9MDtkPGIubGVuc0ZsYXJlcy5sZW5ndGg7ZCsrKXt2YXIgZT1iLmxlbnNGbGFyZXNbZF07Yy5mbGFyZXMucHVzaCh7c2l6ZTplLnNpemUscG9zaXRpb246ZS5wb3NpdGlvbixjb2xvcjplLmNvbG9yLmFzQXJyYXkoKSx0ZXh0dXJlTmFtZTphLlRvb2xzLkdldEZpbGVuYW1lKGUudGV4dHVyZS5uYW1lKX0pfXJldHVybiBjfSxsPWZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9YS5nZXRTaGFkb3dHZW5lcmF0b3IoKTtiLmxpZ2h0SWQ9YS5pZCxiLm1hcFNpemU9Yy5nZXRTaGFkb3dNYXAoKS5nZXRSZW5kZXJTaXplKCksYi51c2VWYXJpYW5jZVNoYWRvd01hcD1jLnVzZVZhcmlhbmNlU2hhZG93TWFwLGIudXNlUG9pc3NvblNhbXBsaW5nPWMudXNlUG9pc3NvblNhbXBsaW5nLGIucmVuZGVyTGlzdD1bXTtmb3IodmFyIGQ9MDtkPGMuZ2V0U2hhZG93TWFwKCkucmVuZGVyTGlzdC5sZW5ndGg7ZCsrKXt2YXIgZT1jLmdldFNoYWRvd01hcCgpLnJlbmRlckxpc3RbZF07Yi5yZW5kZXJMaXN0LnB1c2goZS5pZCl9cmV0dXJuIGJ9LG09W10sbj1mdW5jdGlvbihiLGMpe2lmKCFtW2IuaWRdKXtpZihiIGluc3RhbmNlb2YgYS5HZW9tZXRyeS5QcmltaXRpdmVzLkJveCljLmJveGVzLnB1c2gocihiKSk7ZWxzZSBpZihiIGluc3RhbmNlb2YgYS5HZW9tZXRyeS5QcmltaXRpdmVzLlNwaGVyZSljLnNwaGVyZXMucHVzaChzKGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuQ3lsaW5kZXIpYy5jeWxpbmRlcnMucHVzaCh0KGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuVG9ydXMpYy50b3J1c2VzLnB1c2godShiKSk7ZWxzZSBpZihiIGluc3RhbmNlb2YgYS5HZW9tZXRyeS5QcmltaXRpdmVzLkdyb3VuZCljLmdyb3VuZHMucHVzaCh2KGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuUGxhbmUpYy5wbGFuZXMucHVzaCh3KGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuVG9ydXNLbm90KWMudG9ydXNLbm90cy5wdXNoKHgoYikpO2Vsc2V7aWYoYiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5fUHJpbWl0aXZlKXRocm93IG5ldyBFcnJvcihcIlVua25vdyBwcmltaXRpdmUgdHlwZVwiKTtjLnZlcnRleERhdGEucHVzaChwKGIpKX1tW2IuaWRdPSEwfX0sbz1mdW5jdGlvbihiKXt2YXIgYz17fTtyZXR1cm4gYy5pZD1iLmlkLGEuVGFncy5IYXNUYWdzKGIpJiYoYy50YWdzPWEuVGFncy5HZXRUYWdzKGIpKSxjfSxwPWZ1bmN0aW9uKGIpe3ZhciBjPW8oYik7cmV0dXJuIGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkmJihjLnBvc2l0aW9ucz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKSYmKGMubm9ybWFscz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSYmKGMudXZzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLlVWMktpbmQpJiYoYy51dnMyPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWMktpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpJiYoYy5jb2xvcnM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCkmJihjLm1hdHJpY2VzSW5kaWNlcz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSxjLm1hdHJpY2VzSW5kaWNlcy5faXNFeHBhbmRlZD0hMCksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCkmJihjLm1hdHJpY2VzV2VpZ2h0cz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSksYy5pbmRpY2VzPWIuZ2V0SW5kaWNlcygpLGN9LHE9ZnVuY3Rpb24oYSl7dmFyIGI9byhhKTtyZXR1cm4gYi5jYW5CZVJlZ2VuZXJhdGVkPWEuY2FuQmVSZWdlbmVyYXRlZCgpLGJ9LHI9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi5zaXplPWEuc2l6ZSxifSxzPWZ1bmN0aW9uKGEpe3ZhciBiPXEoYSk7cmV0dXJuIGIuc2VnbWVudHM9YS5zZWdtZW50cyxiLmRpYW1ldGVyPWEuZGlhbWV0ZXIsYn0sdD1mdW5jdGlvbihhKXt2YXIgYj1xKGEpO3JldHVybiBiLmhlaWdodD1hLmhlaWdodCxiLmRpYW1ldGVyVG9wPWEuZGlhbWV0ZXJUb3AsYi5kaWFtZXRlckJvdHRvbT1hLmRpYW1ldGVyQm90dG9tLGIudGVzc2VsbGF0aW9uPWEudGVzc2VsbGF0aW9uLGJ9LHU9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi5kaWFtZXRlcj1hLmRpYW1ldGVyLGIudGhpY2tuZXNzPWEudGhpY2tuZXNzLGIudGVzc2VsbGF0aW9uPWEudGVzc2VsbGF0aW9uLGJ9LHY9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi53aWR0aD1hLndpZHRoLGIuaGVpZ2h0PWEuaGVpZ2h0LGIuc3ViZGl2aXNpb25zPWEuc3ViZGl2aXNpb25zLGJ9LHc9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi5zaXplPWEuc2l6ZSxifSx4PWZ1bmN0aW9uKGEpe3ZhciBiPXEoYSk7cmV0dXJuIGIucmFkaXVzPWEucmFkaXVzLGIudHViZT1hLnR1YmUsYi5yYWRpYWxTZWdtZW50cz1hLnJhZGlhbFNlZ21lbnRzLGIudHVidWxhclNlZ21lbnRzPWEudHVidWxhclNlZ21lbnRzLGIucD1hLnAsYi5xPWEucSxifSx5PWZ1bmN0aW9uKGIsYyl7dmFyIGU9e307ZS5uYW1lPWIubmFtZSxlLmlkPWIuaWQsYS5UYWdzLkhhc1RhZ3MoYikmJihlLnRhZ3M9YS5UYWdzLkdldFRhZ3MoYikpLGUucG9zaXRpb249Yi5wb3NpdGlvbi5hc0FycmF5KCksYi5yb3RhdGlvblF1YXRlcm5pb24/ZS5yb3RhdGlvblF1YXRlcm5pb249Yi5yb3RhdGlvblF1YXRlcm5pb24uYXNBcnJheSgpOmIucm90YXRpb24mJihlLnJvdGF0aW9uPWIucm90YXRpb24uYXNBcnJheSgpKSxlLnNjYWxpbmc9Yi5zY2FsaW5nLmFzQXJyYXkoKSxlLmxvY2FsTWF0cml4PWIuZ2V0UGl2b3RNYXRyaXgoKS5hc0FycmF5KCksZS5pc0VuYWJsZWQ9Yi5pc0VuYWJsZWQoKSxlLmlzVmlzaWJsZT1iLmlzVmlzaWJsZSxlLmluZmluaXRlRGlzdGFuY2U9Yi5pbmZpbml0ZURpc3RhbmNlLGUucGlja2FibGU9Yi5pc1BpY2thYmxlLGUucmVjZWl2ZVNoYWRvd3M9Yi5yZWNlaXZlU2hhZG93cyxlLmJpbGxib2FyZE1vZGU9Yi5iaWxsYm9hcmRNb2RlLGUudmlzaWJpbGl0eT1iLnZpc2liaWxpdHksZS5jaGVja0NvbGxpc2lvbnM9Yi5jaGVja0NvbGxpc2lvbnMsYi5wYXJlbnQmJihlLnBhcmVudElkPWIucGFyZW50LmlkKTt2YXIgZj1iLl9nZW9tZXRyeTtpZihmKXt2YXIgZz1mLmlkO2UuZ2VvbWV0cnlJZD1nLGIuZ2V0U2NlbmUoKS5nZXRHZW9tZXRyeUJ5SUQoZyl8fG4oZixjLmdlb21ldHJpZXMpLGUuc3ViTWVzaGVzPVtdO2Zvcih2YXIgaD0wO2g8Yi5zdWJNZXNoZXMubGVuZ3RoO2grKyl7dmFyIGk9Yi5zdWJNZXNoZXNbaF07ZS5zdWJNZXNoZXMucHVzaCh7bWF0ZXJpYWxJbmRleDppLm1hdGVyaWFsSW5kZXgsdmVydGljZXNTdGFydDppLnZlcnRpY2VzU3RhcnQsdmVydGljZXNDb3VudDppLnZlcnRpY2VzQ291bnQsaW5kZXhTdGFydDppLmluZGV4U3RhcnQsaW5kZXhDb3VudDppLmluZGV4Q291bnR9KX19aWYoYi5tYXRlcmlhbD9lLm1hdGVyaWFsSWQ9Yi5tYXRlcmlhbC5pZDpiLm1hdGVyaWFsPW51bGwsYi5za2VsZXRvbiYmKGUuc2tlbGV0b25JZD1iLnNrZWxldG9uLmlkKSxiLmdldFBoeXNpY3NJbXBvc3RvcigpIT09YS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3Ipc3dpdGNoKGUucGh5c2ljc01hc3M9Yi5nZXRQaHlzaWNzTWFzcygpLGUucGh5c2ljc0ZyaWN0aW9uPWIuZ2V0UGh5c2ljc0ZyaWN0aW9uKCksZS5waHlzaWNzUmVzdGl0dXRpb249Yi5nZXRQaHlzaWNzUmVzdGl0dXRpb24oKSxiLmdldFBoeXNpY3NJbXBvc3RvcigpKXtjYXNlIGEuUGh5c2ljc0VuZ2luZS5Cb3hJbXBvc3RvcjplLnBoeXNpY3NJbXBvc3Rvcj0xO2JyZWFrO2Nhc2UgYS5QaHlzaWNzRW5naW5lLlNwaGVyZUltcG9zdG9yOmUucGh5c2ljc0ltcG9zdG9yPTJ9cmV0dXJuIGQoYixlKSxlLmxheWVyTWFzaz1iLmxheWVyTWFzayxlfSx6PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZCgpe31yZXR1cm4gZC5TZXJpYWxpemU9ZnVuY3Rpb24oZCl7dmFyIGU9e307ZS51c2VEZWxheWVkVGV4dHVyZUxvYWRpbmc9ZC51c2VEZWxheWVkVGV4dHVyZUxvYWRpbmcsZS5hdXRvQ2xlYXI9ZC5hdXRvQ2xlYXIsZS5jbGVhckNvbG9yPWQuY2xlYXJDb2xvci5hc0FycmF5KCksZS5hbWJpZW50Q29sb3I9ZC5hbWJpZW50Q29sb3IuYXNBcnJheSgpLGUuZ3Jhdml0eT1kLmdyYXZpdHkuYXNBcnJheSgpLGQuZm9nTW9kZSYmMCE9PWQuZm9nTW9kZSYmKGUuZm9nTW9kZT1kLmZvZ01vZGUsZS5mb2dDb2xvcj1kLmZvZ0NvbG9yLmFzQXJyYXkoKSxlLmZvZ1N0YXJ0PWQuZm9nU3RhcnQsZS5mb2dFbmQ9ZC5mb2dFbmQsZS5mb2dEZW5zaXR5PWQuZm9nRGVuc2l0eSksZS5saWdodHM9W107Zm9yKHZhciBoPTA7aDxkLmxpZ2h0cy5sZW5ndGg7aCsrKXt2YXIgbz1kLmxpZ2h0c1toXTtlLmxpZ2h0cy5wdXNoKGIobykpfWZvcihlLmNhbWVyYXM9W10saD0wO2g8ZC5jYW1lcmFzLmxlbmd0aDtoKyspe3ZhciBwPWQuY2FtZXJhc1toXTtwIGluc3RhbmNlb2YgYS5GcmVlQ2FtZXJhJiZlLmNhbWVyYXMucHVzaChjKHApKX1mb3IoZC5hY3RpdmVDYW1lcmEmJihlLmFjdGl2ZUNhbWVyYUlEPWQuYWN0aXZlQ2FtZXJhLmlkKSxlLm1hdGVyaWFscz1bXSxlLm11bHRpTWF0ZXJpYWxzPVtdLGg9MDtoPGQubWF0ZXJpYWxzLmxlbmd0aDtoKyspe3ZhciBxPWQubWF0ZXJpYWxzW2hdO3EgaW5zdGFuY2VvZiBhLlN0YW5kYXJkTWF0ZXJpYWw/ZS5tYXRlcmlhbHMucHVzaChnKHEpKTpxIGluc3RhbmNlb2YgYS5NdWx0aU1hdGVyaWFsJiZlLm11bHRpTWF0ZXJpYWxzLnB1c2goZihxKSl9Zm9yKGUuc2tlbGV0b25zPVtdLGg9MDtoPGQuc2tlbGV0b25zLmxlbmd0aDtoKyspZS5za2VsZXRvbnMucHVzaChpKGQuc2tlbGV0b25zW2hdKSk7ZS5nZW9tZXRyaWVzPXt9LGUuZ2VvbWV0cmllcy5ib3hlcz1bXSxlLmdlb21ldHJpZXMuc3BoZXJlcz1bXSxlLmdlb21ldHJpZXMuY3lsaW5kZXJzPVtdLGUuZ2VvbWV0cmllcy50b3J1c2VzPVtdLGUuZ2VvbWV0cmllcy5ncm91bmRzPVtdLGUuZ2VvbWV0cmllcy5wbGFuZXM9W10sZS5nZW9tZXRyaWVzLnRvcnVzS25vdHM9W10sZS5nZW9tZXRyaWVzLnZlcnRleERhdGE9W10sbT1bXTtmb3IodmFyIHI9ZC5nZXRHZW9tZXRyaWVzKCksaD0wO2g8ci5sZW5ndGg7aCsrKXt2YXIgcz1yW2hdO3MuaXNSZWFkeSgpJiZuKHMsZS5nZW9tZXRyaWVzKX1mb3IoZS5tZXNoZXM9W10saD0wO2g8ZC5tZXNoZXMubGVuZ3RoO2grKyl7dmFyIHQ9ZC5tZXNoZXNbaF07aWYodCBpbnN0YW5jZW9mIGEuTWVzaCl7dmFyIHU9dDsodS5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURFRHx8dS5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PTkUpJiZlLm1lc2hlcy5wdXNoKHkodSxlKSl9fWZvcihlLnBhcnRpY2xlU3lzdGVtcz1bXSxoPTA7aDxkLnBhcnRpY2xlU3lzdGVtcy5sZW5ndGg7aCsrKWUucGFydGljbGVTeXN0ZW1zLnB1c2goaihkLnBhcnRpY2xlU3lzdGVtc1toXSkpO2ZvcihlLmxlbnNGbGFyZVN5c3RlbXM9W10saD0wO2g8ZC5sZW5zRmxhcmVTeXN0ZW1zLmxlbmd0aDtoKyspZS5sZW5zRmxhcmVTeXN0ZW1zLnB1c2goayhkLmxlbnNGbGFyZVN5c3RlbXNbaF0pKTtmb3IoZS5zaGFkb3dHZW5lcmF0b3JzPVtdLGg9MDtoPGQubGlnaHRzLmxlbmd0aDtoKyspbz1kLmxpZ2h0c1toXSxvLmdldFNoYWRvd0dlbmVyYXRvcigpJiZlLnNoYWRvd0dlbmVyYXRvcnMucHVzaChsKG8pKTtyZXR1cm4gZX0sZH0oKTthLlNjZW5lU2VyaWFsaXplcj16fShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiRm9yY2VGdWxsU2NlbmVMb2FkaW5nRm9ySW5jcmVtZW50YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0ZvcmNlRnVsbFNjZW5lTG9hZGluZ0ZvckluY3JlbWVudGFsfSxzZXQ6ZnVuY3Rpb24oYSl7Yi5fRm9yY2VGdWxsU2NlbmVMb2FkaW5nRm9ySW5jcmVtZW50YWw9YX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLl9nZXRQbHVnaW5Gb3JGaWxlbmFtZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5sYXN0SW5kZXhPZihcIi5cIiksYz1hLnN1YnN0cmluZyhiKS50b0xvd2VyQ2FzZSgpLGQ9MDtkPHRoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zW2RdO2lmKC0xIT09ZS5leHRlbnNpb25zLmluZGV4T2YoYykpcmV0dXJuIGV9cmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zW3RoaXMuX3JlZ2lzdGVyZWRQbHVnaW5zLmxlbmd0aC0xXX0sYi5SZWdpc3RlclBsdWdpbj1mdW5jdGlvbihhKXthLmV4dGVuc2lvbnM9YS5leHRlbnNpb25zLnRvTG93ZXJDYXNlKCksYi5fcmVnaXN0ZXJlZFBsdWdpbnMucHVzaChhKX0sYi5JbXBvcnRNZXNoPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgpe3ZhciBpPXRoaXMsaj1mdW5jdGlvbigpe2UuZGF0YWJhc2U9azt2YXIgaj1pLl9nZXRQbHVnaW5Gb3JGaWxlbmFtZShkKSxsPWZ1bmN0aW9uKGEpe3ZhciBnPVtdLGk9W10saz1bXTtyZXR1cm4gai5pbXBvcnRNZXNoKGIsZSxhLGMsZyxpLGspP3ZvaWQoZiYmKGUuaW1wb3J0ZWRNZXNoZXNGaWxlcy5wdXNoKGMrZCksZihnLGksaykpKTp2b2lkKGgmJmgoZSkpfTtyZXR1cm4gZC5zdWJzdHImJlwiZGF0YTpcIj09PWQuc3Vic3RyKDAsNSk/dm9pZCBsKGQuc3Vic3RyKDUpKTp2b2lkIGEuVG9vbHMuTG9hZEZpbGUoYytkLGZ1bmN0aW9uKGEpe2woYSl9LGcsayl9LGs9bmV3IGEuRGF0YWJhc2UoYytkLGopfSxiLkxvYWQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe3ZhciBoLGk9dGhpcy5fZ2V0UGx1Z2luRm9yRmlsZW5hbWUoYy5uYW1lfHxjKSxqPWZ1bmN0aW9uKGMpe3ZhciBmPW5ldyBhLlNjZW5lKGQpO3JldHVybiBmLmRhdGFiYXNlPWgsaS5sb2FkKGYsYyxiKT92b2lkKGUmJmUoZikpOnZvaWQoZyYmZyhmKSl9LGs9ZnVuY3Rpb24oKXthLlRvb2xzLkxvYWRGaWxlKGIrYyxqLGYsaCl9O3JldHVybiBjLnN1YnN0ciYmXCJkYXRhOlwiPT09Yy5zdWJzdHIoMCw1KT92b2lkIGooYy5zdWJzdHIoNSkpOnZvaWQoLTE9PT1iLmluZGV4T2YoXCJmaWxlOlwiKT9oPW5ldyBhLkRhdGFiYXNlKGIrYyxrKTphLlRvb2xzLlJlYWRGaWxlKGMsaixmKSl9LGIuX0ZvcmNlRnVsbFNjZW5lTG9hZGluZ0ZvckluY3JlbWVudGFsPSExLGIuX3JlZ2lzdGVyZWRQbHVnaW5zPW5ldyBBcnJheSxifSgpO2EuU2NlbmVMb2FkZXI9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7IWZ1bmN0aW9uKCl7dmFyIGI9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPW5ldyBhLkN1YmVUZXh0dXJlKGIrYy5uYW1lLGQpO3JldHVybiBlLm5hbWU9Yy5uYW1lLGUuaGFzQWxwaGE9Yy5oYXNBbHBoYSxlLmxldmVsPWMubGV2ZWwsZS5jb29yZGluYXRlc01vZGU9Yy5jb29yZGluYXRlc01vZGUsZX0sYz1mdW5jdGlvbihjLGQsZSl7aWYoIWQubmFtZSYmIWQuaXNSZW5kZXJUYXJnZXQpcmV0dXJuIG51bGw7aWYoZC5pc0N1YmUpcmV0dXJuIGIoYyxkLGUpO3ZhciBmO2lmKGQubWlycm9yUGxhbmU/KGY9bmV3IGEuTWlycm9yVGV4dHVyZShkLm5hbWUsZC5yZW5kZXJUYXJnZXRTaXplLGUpLGYuX3dhaXRpbmdSZW5kZXJMaXN0PWQucmVuZGVyTGlzdCxmLm1pcnJvclBsYW5lPWEuUGxhbmUuRnJvbUFycmF5KGQubWlycm9yUGxhbmUpKTpkLmlzUmVuZGVyVGFyZ2V0PyhmPW5ldyBhLlJlbmRlclRhcmdldFRleHR1cmUoZC5uYW1lLGQucmVuZGVyVGFyZ2V0U2l6ZSxlKSxmLl93YWl0aW5nUmVuZGVyTGlzdD1kLnJlbmRlckxpc3QpOmY9bmV3IGEuVGV4dHVyZShjK2QubmFtZSxlKSxmLm5hbWU9ZC5uYW1lLGYuaGFzQWxwaGE9ZC5oYXNBbHBoYSxmLmdldEFscGhhRnJvbVJHQj1kLmdldEFscGhhRnJvbVJHQixmLmxldmVsPWQubGV2ZWwsZi5jb29yZGluYXRlc0luZGV4PWQuY29vcmRpbmF0ZXNJbmRleCxmLmNvb3JkaW5hdGVzTW9kZT1kLmNvb3JkaW5hdGVzTW9kZSxmLnVPZmZzZXQ9ZC51T2Zmc2V0LGYudk9mZnNldD1kLnZPZmZzZXQsZi51U2NhbGU9ZC51U2NhbGUsZi52U2NhbGU9ZC52U2NhbGUsZi51QW5nPWQudUFuZyxmLnZBbmc9ZC52QW5nLGYud0FuZz1kLndBbmcsZi53cmFwVT1kLndyYXBVLGYud3JhcFY9ZC53cmFwVixkLmFuaW1hdGlvbnMpZm9yKHZhciBnPTA7ZzxkLmFuaW1hdGlvbnMubGVuZ3RoO2crKyl7dmFyIGg9ZC5hbmltYXRpb25zW2ddO2YuYW5pbWF0aW9ucy5wdXNoKGsoaCkpfXJldHVybiBmfSxkPWZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPW5ldyBhLlNrZWxldG9uKGIubmFtZSxiLmlkLGMpLGU9MDtlPGIuYm9uZXMubGVuZ3RoO2UrKyl7dmFyIGY9Yi5ib25lc1tlXSxnPW51bGw7Zi5wYXJlbnRCb25lSW5kZXg+LTEmJihnPWQuYm9uZXNbZi5wYXJlbnRCb25lSW5kZXhdKTt2YXIgaD1uZXcgYS5Cb25lKGYubmFtZSxkLGcsYS5NYXRyaXguRnJvbUFycmF5KGYubWF0cml4KSk7Zi5hbmltYXRpb24mJmguYW5pbWF0aW9ucy5wdXNoKGsoZi5hbmltYXRpb24pKX1yZXR1cm4gZH0sZT1mdW5jdGlvbihiLGQsZSl7dmFyIGY7cmV0dXJuIGY9bmV3IGEuU3RhbmRhcmRNYXRlcmlhbChiLm5hbWUsZCksZi5hbWJpZW50Q29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGIuYW1iaWVudCksZi5kaWZmdXNlQ29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGIuZGlmZnVzZSksZi5zcGVjdWxhckNvbG9yPWEuQ29sb3IzLkZyb21BcnJheShiLnNwZWN1bGFyKSxmLnNwZWN1bGFyUG93ZXI9Yi5zcGVjdWxhclBvd2VyLGYuZW1pc3NpdmVDb2xvcj1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5lbWlzc2l2ZSksZi5hbHBoYT1iLmFscGhhLGYuaWQ9Yi5pZCxhLlRhZ3MuQWRkVGFnc1RvKGYsYi50YWdzKSxmLmJhY2tGYWNlQ3VsbGluZz1iLmJhY2tGYWNlQ3VsbGluZyxmLndpcmVmcmFtZT1iLndpcmVmcmFtZSxiLmRpZmZ1c2VUZXh0dXJlJiYoZi5kaWZmdXNlVGV4dHVyZT1jKGUsYi5kaWZmdXNlVGV4dHVyZSxkKSksYi5hbWJpZW50VGV4dHVyZSYmKGYuYW1iaWVudFRleHR1cmU9YyhlLGIuYW1iaWVudFRleHR1cmUsZCkpLGIub3BhY2l0eVRleHR1cmUmJihmLm9wYWNpdHlUZXh0dXJlPWMoZSxiLm9wYWNpdHlUZXh0dXJlLGQpKSxiLnJlZmxlY3Rpb25UZXh0dXJlJiYoZi5yZWZsZWN0aW9uVGV4dHVyZT1jKGUsYi5yZWZsZWN0aW9uVGV4dHVyZSxkKSksYi5lbWlzc2l2ZVRleHR1cmUmJihmLmVtaXNzaXZlVGV4dHVyZT1jKGUsYi5lbWlzc2l2ZVRleHR1cmUsZCkpLGIuc3BlY3VsYXJUZXh0dXJlJiYoZi5zcGVjdWxhclRleHR1cmU9YyhlLGIuc3BlY3VsYXJUZXh0dXJlLGQpKSxiLmJ1bXBUZXh0dXJlJiYoZi5idW1wVGV4dHVyZT1jKGUsYi5idW1wVGV4dHVyZSxkKSksZn0sZj1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGY9MDtmPGIubWF0ZXJpYWxzLmxlbmd0aDtmKyspe3ZhciBnPWIubWF0ZXJpYWxzW2ZdO2lmKGcuaWQ9PT1hKXJldHVybiBlKGcsYyxkKX1yZXR1cm4gbnVsbH0sZz1mdW5jdGlvbihiLGMpe3ZhciBkPW5ldyBhLk11bHRpTWF0ZXJpYWwoYi5uYW1lLGMpO2QuaWQ9Yi5pZCxhLlRhZ3MuQWRkVGFnc1RvKGQsYi50YWdzKTtmb3IodmFyIGU9MDtlPGIubWF0ZXJpYWxzLmxlbmd0aDtlKyspe3ZhciBmPWIubWF0ZXJpYWxzW2VdO2Quc3ViTWF0ZXJpYWxzLnB1c2goZj9jLmdldE1hdGVyaWFsQnlJRChmKTpudWxsKX1yZXR1cm4gZH0saD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9Yy5nZXRMYXN0RW50cnlCeUlEKGIuZW1pdHRlcklkKSxmPW5ldyBhLkxlbnNGbGFyZVN5c3RlbShcImxlbnNGbGFyZVN5c3RlbSNcIitiLmVtaXR0ZXJJZCxlLGMpO2YuYm9yZGVyTGltaXQ9Yi5ib3JkZXJMaW1pdDtmb3IodmFyIGc9MDtnPGIuZmxhcmVzLmxlbmd0aDtnKyspe3ZhciBoPWIuZmxhcmVzW2ddO25ldyBhLkxlbnNGbGFyZShoLnNpemUsaC5wb3NpdGlvbixhLkNvbG9yMy5Gcm9tQXJyYXkoaC5jb2xvciksZCtoLnRleHR1cmVOYW1lLGYpfXJldHVybiBmfSxpPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1jLmdldExhc3RNZXNoQnlJRChiLmVtaXR0ZXJJZCksZj1uZXcgYS5QYXJ0aWNsZVN5c3RlbShcInBhcnRpY2xlcyNcIitlLm5hbWUsYi5jYXBhY2l0eSxjKTtyZXR1cm4gYi50ZXh0dXJlTmFtZSYmKGYucGFydGljbGVUZXh0dXJlPW5ldyBhLlRleHR1cmUoZCtiLnRleHR1cmVOYW1lLGMpLGYucGFydGljbGVUZXh0dXJlLm5hbWU9Yi50ZXh0dXJlTmFtZSksZi5taW5Bbmd1bGFyU3BlZWQ9Yi5taW5Bbmd1bGFyU3BlZWQsZi5tYXhBbmd1bGFyU3BlZWQ9Yi5tYXhBbmd1bGFyU3BlZWQsZi5taW5TaXplPWIubWluU2l6ZSxmLm1heFNpemU9Yi5tYXhTaXplLGYubWluTGlmZVRpbWU9Yi5taW5MaWZlVGltZSxmLm1heExpZmVUaW1lPWIubWF4TGlmZVRpbWUsZi5lbWl0dGVyPWUsZi5lbWl0UmF0ZT1iLmVtaXRSYXRlLGYubWluRW1pdEJveD1hLlZlY3RvcjMuRnJvbUFycmF5KGIubWluRW1pdEJveCksZi5tYXhFbWl0Qm94PWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5tYXhFbWl0Qm94KSxmLmdyYXZpdHk9YS5WZWN0b3IzLkZyb21BcnJheShiLmdyYXZpdHkpLGYuZGlyZWN0aW9uMT1hLlZlY3RvcjMuRnJvbUFycmF5KGIuZGlyZWN0aW9uMSksZi5kaXJlY3Rpb24yPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5kaXJlY3Rpb24yKSxmLmNvbG9yMT1hLkNvbG9yNC5Gcm9tQXJyYXkoYi5jb2xvcjEpLGYuY29sb3IyPWEuQ29sb3I0LkZyb21BcnJheShiLmNvbG9yMiksZi5jb2xvckRlYWQ9YS5Db2xvcjQuRnJvbUFycmF5KGIuY29sb3JEZWFkKSxmLnVwZGF0ZVNwZWVkPWIudXBkYXRlU3BlZWQsZi50YXJnZXRTdG9wRHVyYXRpb249Yi50YXJnZXRTdG9wRnJhbWUsZi50ZXh0dXJlTWFzaz1hLkNvbG9yNC5Gcm9tQXJyYXkoYi50ZXh0dXJlTWFzayksZi5ibGVuZE1vZGU9Yi5ibGVuZE1vZGUsZi5zdGFydCgpLGZ9LGo9ZnVuY3Rpb24oYixjKXtmb3IodmFyIGQ9Yy5nZXRMaWdodEJ5SUQoYi5saWdodElkKSxlPW5ldyBhLlNoYWRvd0dlbmVyYXRvcihiLm1hcFNpemUsZCksZj0wO2Y8Yi5yZW5kZXJMaXN0Lmxlbmd0aDtmKyspe3ZhciBnPWMuZ2V0TWVzaEJ5SUQoYi5yZW5kZXJMaXN0W2ZdKTtlLmdldFNoYWRvd01hcCgpLnJlbmRlckxpc3QucHVzaChnKX1yZXR1cm4gYi51c2VQb2lzc29uU2FtcGxpbmc/ZS51c2VQb2lzc29uU2FtcGxpbmc9ITA6ZS51c2VWYXJpYW5jZVNoYWRvd01hcD1iLnVzZVZhcmlhbmNlU2hhZG93TWFwLGV9LGs9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPW5ldyBhLkFuaW1hdGlvbihiLm5hbWUsYi5wcm9wZXJ0eSxiLmZyYW1lUGVyU2Vjb25kLGIuZGF0YVR5cGUsYi5sb29wQmVoYXZpb3IpLGQ9Yi5kYXRhVHlwZSxlPVtdLGY9MDtmPGIua2V5cy5sZW5ndGg7ZisrKXt2YXIgZyxoPWIua2V5c1tmXTtzd2l0Y2goZCl7Y2FzZSBhLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FUOmc9aC52YWx1ZXNbMF07YnJlYWs7Y2FzZSBhLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX1FVQVRFUk5JT046Zz1hLlF1YXRlcm5pb24uRnJvbUFycmF5KGgudmFsdWVzKTticmVhaztjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfTUFUUklYOmc9YS5NYXRyaXguRnJvbUFycmF5KGgudmFsdWVzKTticmVhaztjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfVkVDVE9SMzpkZWZhdWx0Omc9YS5WZWN0b3IzLkZyb21BcnJheShoLnZhbHVlcyl9ZS5wdXNoKHtmcmFtZTpoLmZyYW1lLHZhbHVlOmd9KX1yZXR1cm4gYy5zZXRLZXlzKGUpLGN9LGw9ZnVuY3Rpb24oYixjKXt2YXIgZDtzd2l0Y2goYi50eXBlKXtjYXNlIDA6ZD1uZXcgYS5Qb2ludExpZ2h0KGIubmFtZSxhLlZlY3RvcjMuRnJvbUFycmF5KGIucG9zaXRpb24pLGMpO2JyZWFrO2Nhc2UgMTpkPW5ldyBhLkRpcmVjdGlvbmFsTGlnaHQoYi5uYW1lLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5kaXJlY3Rpb24pLGMpLGQucG9zaXRpb249YS5WZWN0b3IzLkZyb21BcnJheShiLnBvc2l0aW9uKTticmVhaztjYXNlIDI6ZD1uZXcgYS5TcG90TGlnaHQoYi5uYW1lLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5wb3NpdGlvbiksYS5WZWN0b3IzLkZyb21BcnJheShiLmRpcmVjdGlvbiksYi5hbmdsZSxiLmV4cG9uZW50LGMpO2JyZWFrO2Nhc2UgMzpkPW5ldyBhLkhlbWlzcGhlcmljTGlnaHQoYi5uYW1lLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5kaXJlY3Rpb24pLGMpLGQuZ3JvdW5kQ29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGIuZ3JvdW5kQ29sb3IpfWlmKGQuaWQ9Yi5pZCxhLlRhZ3MuQWRkVGFnc1RvKGQsYi50YWdzKSx2b2lkIDAhPT1iLmludGVuc2l0eSYmKGQuaW50ZW5zaXR5PWIuaW50ZW5zaXR5KSxiLnJhbmdlJiYoZC5yYW5nZT1iLnJhbmdlKSxkLmRpZmZ1c2U9YS5Db2xvcjMuRnJvbUFycmF5KGIuZGlmZnVzZSksZC5zcGVjdWxhcj1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5zcGVjdWxhciksYi5leGNsdWRlZE1lc2hlc0lkcyYmKGQuX2V4Y2x1ZGVkTWVzaGVzSWRzPWIuZXhjbHVkZWRNZXNoZXNJZHMpLGIuYW5pbWF0aW9ucylmb3IodmFyIGU9MDtlPGIuYW5pbWF0aW9ucy5sZW5ndGg7ZSsrKXt2YXIgZj1iLmFuaW1hdGlvbnNbZV07ZC5hbmltYXRpb25zLnB1c2goayhmKSl9Yi5hdXRvQW5pbWF0ZSYmYy5iZWdpbkFuaW1hdGlvbihkLGIuYXV0b0FuaW1hdGVGcm9tLGIuYXV0b0FuaW1hdGVUbyxiLmF1dG9BbmltYXRlTG9vcCwxKX0sbT1mdW5jdGlvbihiLGMpe3ZhciBkPW5ldyBhLkZyZWVDYW1lcmEoYi5uYW1lLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5wb3NpdGlvbiksYyk7aWYoZC5pZD1iLmlkLGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLGIucGFyZW50SWQmJihkLl93YWl0aW5nUGFyZW50SWQ9Yi5wYXJlbnRJZCksYi50YXJnZXQ/ZC5zZXRUYXJnZXQoYS5WZWN0b3IzLkZyb21BcnJheShiLnRhcmdldCkpOmQucm90YXRpb249YS5WZWN0b3IzLkZyb21BcnJheShiLnJvdGF0aW9uKSxiLmxvY2tlZFRhcmdldElkJiYoZC5fd2FpdGluZ0xvY2tlZFRhcmdldElkPWIubG9ja2VkVGFyZ2V0SWQpLGQuZm92PWIuZm92LGQubWluWj1iLm1pblosZC5tYXhaPWIubWF4WixkLnNwZWVkPWIuc3BlZWQsZC5pbmVydGlhPWIuaW5lcnRpYSxkLmNoZWNrQ29sbGlzaW9ucz1iLmNoZWNrQ29sbGlzaW9ucyxkLmFwcGx5R3Jhdml0eT1iLmFwcGx5R3Jhdml0eSxiLmVsbGlwc29pZCYmKGQuZWxsaXBzb2lkPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5lbGxpcHNvaWQpKSxiLmFuaW1hdGlvbnMpZm9yKHZhciBlPTA7ZTxiLmFuaW1hdGlvbnMubGVuZ3RoO2UrKyl7dmFyIGY9Yi5hbmltYXRpb25zW2VdO2QuYW5pbWF0aW9ucy5wdXNoKGsoZikpfXJldHVybiBiLmF1dG9BbmltYXRlJiZjLmJlZ2luQW5pbWF0aW9uKGQsYi5hdXRvQW5pbWF0ZUZyb20sYi5hdXRvQW5pbWF0ZVRvLGIuYXV0b0FuaW1hdGVMb29wLDEpLGQubGF5ZXJNYXNrPWIubGF5ZXJNYXNrJiYhaXNOYU4oYi5sYXllck1hc2spP01hdGguYWJzKHBhcnNlSW50KGIubGF5ZXJNYXNrKSk6NDI5NDk2NzI5NSxkfSxuPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5pZDtyZXR1cm4gYi5nZXRHZW9tZXRyeUJ5SUQoYyl9LG89ZnVuY3Rpb24oYixjKXtpZihuKGIsYykpcmV0dXJuIG51bGw7dmFyIGQ9bmV3IGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5Cb3goYi5pZCxjLGIuc2l6ZSxiLmNhbkJlUmVnZW5lcmF0ZWQsbnVsbCk7cmV0dXJuIGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLGMucHVzaEdlb21ldHJ5KGQsITApLGR9LHA9ZnVuY3Rpb24oYixjKXtpZihuKGIsYykpcmV0dXJuIG51bGw7dmFyIGQ9bmV3IGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5TcGhlcmUoYi5pZCxjLGIuc2VnbWVudHMsYi5kaWFtZXRlcixiLmNhbkJlUmVnZW5lcmF0ZWQsbnVsbCk7cmV0dXJuIGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLGMucHVzaEdlb21ldHJ5KGQsITApLGR9LHE9ZnVuY3Rpb24oYixjKXtpZihuKGIsYykpcmV0dXJuIG51bGw7dmFyIGQ9bmV3IGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5DeWxpbmRlcihiLmlkLGMsYi5oZWlnaHQsYi5kaWFtZXRlclRvcCxiLmRpYW1ldGVyQm90dG9tLGIudGVzc2VsbGF0aW9uLGIuc3ViZGl2aXNpb25zLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0scj1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLlRvcnVzKGIuaWQsYyxiLmRpYW1ldGVyLGIudGhpY2tuZXNzLGIudGVzc2VsbGF0aW9uLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0scz1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLkdyb3VuZChiLmlkLGMsYi53aWR0aCxiLmhlaWdodCxiLnN1YmRpdmlzaW9ucyxiLmNhbkJlUmVnZW5lcmF0ZWQsbnVsbCk7cmV0dXJuIGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLGMucHVzaEdlb21ldHJ5KGQsITApLGR9LHQ9ZnVuY3Rpb24oYixjKXtpZihuKGIsYykpcmV0dXJuIG51bGw7dmFyIGQ9bmV3IGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5QbGFuZShiLmlkLGMsYi5zaXplLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0sdT1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLlRvcnVzS25vdChiLmlkLGMsYi5yYWRpdXMsYi50dWJlLGIucmFkaWFsU2VnbWVudHMsYi50dWJ1bGFyU2VnbWVudHMsYi5wLGIucSxiLmNhbkJlUmVnZW5lcmF0ZWQsbnVsbCk7cmV0dXJuIGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLGMucHVzaEdlb21ldHJ5KGQsITApLGR9LHY9ZnVuY3Rpb24oYixjLGQpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZT1uZXcgYS5HZW9tZXRyeShiLmlkLGMpO3JldHVybiBhLlRhZ3MuQWRkVGFnc1RvKGUsYi50YWdzKSxiLmRlbGF5TG9hZGluZ0ZpbGU/KGUuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVELGUuZGVsYXlMb2FkaW5nRmlsZT1kK2IuZGVsYXlMb2FkaW5nRmlsZSxlLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5ib3VuZGluZ0JveE1pbmltdW0pLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5ib3VuZGluZ0JveE1heGltdW0pKSxlLl9kZWxheUluZm89W10sYi5oYXNVVnMmJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLlVWS2luZCksYi5oYXNVVnMyJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSxiLmhhc0NvbG9ycyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSxiLmhhc01hdHJpY2VzSW5kaWNlcyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCksYi5oYXNNYXRyaWNlc1dlaWdodHMmJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpLGUuX2RlbGF5TG9hZGluZ0Z1bmN0aW9uPXkpOnkoYixlKSxjLnB1c2hHZW9tZXRyeShlLCEwKSxlfSx3PWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1uZXcgYS5NZXNoKGIubmFtZSxjKTtpZihlLmlkPWIuaWQsYS5UYWdzLkFkZFRhZ3NUbyhlLGIudGFncyksZS5wb3NpdGlvbj1hLlZlY3RvcjMuRnJvbUFycmF5KGIucG9zaXRpb24pLGIucm90YXRpb25RdWF0ZXJuaW9uP2Uucm90YXRpb25RdWF0ZXJuaW9uPWEuUXVhdGVybmlvbi5Gcm9tQXJyYXkoYi5yb3RhdGlvblF1YXRlcm5pb24pOmIucm90YXRpb24mJihlLnJvdGF0aW9uPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5yb3RhdGlvbikpLGUuc2NhbGluZz1hLlZlY3RvcjMuRnJvbUFycmF5KGIuc2NhbGluZyksYi5sb2NhbE1hdHJpeD9lLnNldFBpdm90TWF0cml4KGEuTWF0cml4LkZyb21BcnJheShiLmxvY2FsTWF0cml4KSk6Yi5waXZvdE1hdHJpeCYmZS5zZXRQaXZvdE1hdHJpeChhLk1hdHJpeC5Gcm9tQXJyYXkoYi5waXZvdE1hdHJpeCkpLGUuc2V0RW5hYmxlZChiLmlzRW5hYmxlZCksZS5pc1Zpc2libGU9Yi5pc1Zpc2libGUsZS5pbmZpbml0ZURpc3RhbmNlPWIuaW5maW5pdGVEaXN0YW5jZSxlLnNob3dCb3VuZGluZ0JveD1iLnNob3dCb3VuZGluZ0JveCxlLnNob3dTdWJNZXNoZXNCb3VuZGluZ0JveD1iLnNob3dTdWJNZXNoZXNCb3VuZGluZ0JveCx2b2lkIDAhPT1iLnBpY2thYmxlJiYoZS5pc1BpY2thYmxlPWIucGlja2FibGUpLGUucmVjZWl2ZVNoYWRvd3M9Yi5yZWNlaXZlU2hhZG93cyxlLmJpbGxib2FyZE1vZGU9Yi5iaWxsYm9hcmRNb2RlLHZvaWQgMCE9PWIudmlzaWJpbGl0eSYmKGUudmlzaWJpbGl0eT1iLnZpc2liaWxpdHkpLGUuY2hlY2tDb2xsaXNpb25zPWIuY2hlY2tDb2xsaXNpb25zLGUuX3Nob3VsZEdlbmVyYXRlRmxhdFNoYWRpbmc9Yi51c2VGbGF0U2hhZGluZyxiLnBhcmVudElkJiYoZS5wYXJlbnQ9Yy5nZXRMYXN0RW50cnlCeUlEKGIucGFyZW50SWQpKSxiLmRlbGF5TG9hZGluZ0ZpbGU/KGUuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVELGUuZGVsYXlMb2FkaW5nRmlsZT1kK2IuZGVsYXlMb2FkaW5nRmlsZSxlLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5ib3VuZGluZ0JveE1pbmltdW0pLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5ib3VuZGluZ0JveE1heGltdW0pKSxlLl9kZWxheUluZm89W10sYi5oYXNVVnMmJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLlVWS2luZCksYi5oYXNVVnMyJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSxiLmhhc0NvbG9ycyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSxiLmhhc01hdHJpY2VzSW5kaWNlcyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCksYi5oYXNNYXRyaWNlc1dlaWdodHMmJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpLGUuX2RlbGF5TG9hZGluZ0Z1bmN0aW9uPXosYS5TY2VuZUxvYWRlci5Gb3JjZUZ1bGxTY2VuZUxvYWRpbmdGb3JJbmNyZW1lbnRhbCYmZS5fY2hlY2tEZWxheVN0YXRlKCkpOnooYixlKSxiLm1hdGVyaWFsSWQ/ZS5zZXRNYXRlcmlhbEJ5SUQoYi5tYXRlcmlhbElkKTplLm1hdGVyaWFsPW51bGwsYi5za2VsZXRvbklkPi0xJiYoZS5za2VsZXRvbj1jLmdldExhc3RTa2VsZXRvbkJ5SUQoYi5za2VsZXRvbklkKSksYi5waHlzaWNzSW1wb3N0b3ImJihjLmlzUGh5c2ljc0VuYWJsZWQoKXx8Yy5lbmFibGVQaHlzaWNzKCksZS5zZXRQaHlzaWNzU3RhdGUoe2ltcG9zdG9yOmIucGh5c2ljc0ltcG9zdG9yLG1hc3M6Yi5waHlzaWNzTWFzcyxmcmljdGlvbjpiLnBoeXNpY3NGcmljdGlvbixyZXN0aXR1dGlvbjpiLnBoeXNpY3NSZXN0aXR1dGlvbn0pKSxiLmFuaW1hdGlvbnMpZm9yKHZhciBmPTA7ZjxiLmFuaW1hdGlvbnMubGVuZ3RoO2YrKyl7dmFyIGc9Yi5hbmltYXRpb25zW2ZdO1xuZS5hbmltYXRpb25zLnB1c2goayhnKSl9aWYoYi5hdXRvQW5pbWF0ZSYmYy5iZWdpbkFuaW1hdGlvbihlLGIuYXV0b0FuaW1hdGVGcm9tLGIuYXV0b0FuaW1hdGVUbyxiLmF1dG9BbmltYXRlTG9vcCwxKSxlLmxheWVyTWFzaz1iLmxheWVyTWFzayYmIWlzTmFOKGIubGF5ZXJNYXNrKT9NYXRoLmFicyhwYXJzZUludChiLmxheWVyTWFzaykpOjQyOTQ5NjcyOTUsYi5pbnN0YW5jZXMpZm9yKHZhciBoPTA7aDxiLmluc3RhbmNlcy5sZW5ndGg7aCsrKXt2YXIgaT1iLmluc3RhbmNlc1toXSxqPWUuY3JlYXRlSW5zdGFuY2UoaS5uYW1lKTtpZihhLlRhZ3MuQWRkVGFnc1RvKGosaS50YWdzKSxqLnBvc2l0aW9uPWEuVmVjdG9yMy5Gcm9tQXJyYXkoaS5wb3NpdGlvbiksaS5yb3RhdGlvblF1YXRlcm5pb24/ai5yb3RhdGlvblF1YXRlcm5pb249YS5RdWF0ZXJuaW9uLkZyb21BcnJheShpLnJvdGF0aW9uUXVhdGVybmlvbik6aS5yb3RhdGlvbiYmKGoucm90YXRpb249YS5WZWN0b3IzLkZyb21BcnJheShpLnJvdGF0aW9uKSksai5zY2FsaW5nPWEuVmVjdG9yMy5Gcm9tQXJyYXkoaS5zY2FsaW5nKSxqLmNoZWNrQ29sbGlzaW9ucz1lLmNoZWNrQ29sbGlzaW9ucyxiLmFuaW1hdGlvbnMpZm9yKGY9MDtmPGIuYW5pbWF0aW9ucy5sZW5ndGg7ZisrKWc9Yi5hbmltYXRpb25zW2ZdLGouYW5pbWF0aW9ucy5wdXNoKGsoZykpfXJldHVybiBlfSx4PWZ1bmN0aW9uKGEsYixjKXtiPWIgaW5zdGFuY2VvZiBBcnJheT9iOltiXTtmb3IodmFyIGQgaW4gYilpZihhLm5hbWU9PT1iW2RdKXJldHVybiBjLnB1c2goYS5pZCksITA7cmV0dXJuIGEucGFyZW50SWQmJi0xIT09Yy5pbmRleE9mKGEucGFyZW50SWQpPyhjLnB1c2goYS5pZCksITApOiExfSx5PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuVmVydGV4RGF0YSxlPWIucG9zaXRpb25zO2UmJmQuc2V0KGUsYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTt2YXIgZj1iLm5vcm1hbHM7ZiYmZC5zZXQoZixhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKTt2YXIgZz1iLnV2cztnJiZkLnNldChnLGEuVmVydGV4QnVmZmVyLlVWS2luZCk7dmFyIGg9Yi51djJzO2gmJmQuc2V0KGgsYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCk7dmFyIGk9Yi5jb2xvcnM7aSYmZC5zZXQoaSxhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpO3ZhciBqPWIubWF0cmljZXNJbmRpY2VzO2omJmQuc2V0KGosYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCk7dmFyIGs9Yi5tYXRyaWNlc1dlaWdodHM7ayYmZC5zZXQoayxhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKTt2YXIgbD1iLmluZGljZXM7bCYmKGQuaW5kaWNlcz1sKSxjLnNldEFsbFZlcnRpY2VzRGF0YShkLGIudXBkYXRhYmxlKX0sej1mdW5jdGlvbihiLGMpe3ZhciBkPWMuZ2V0U2NlbmUoKSxlPWIuZ2VvbWV0cnlJZDtpZihlKXt2YXIgZj1kLmdldEdlb21ldHJ5QnlJRChlKTtmJiZmLmFwcGx5VG9NZXNoKGMpfWVsc2UgaWYoYi5wb3NpdGlvbnMmJmIubm9ybWFscyYmYi5pbmRpY2VzKXtpZihjLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsYi5wb3NpdGlvbnMsITEpLGMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsYi5ub3JtYWxzLCExKSxiLnV2cyYmYy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kLGIudXZzLCExKSxiLnV2czImJmMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWMktpbmQsYi51dnMyLCExKSxiLmNvbG9ycyYmYy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kLGIuY29sb3JzLCExKSxiLm1hdHJpY2VzSW5kaWNlcylpZihiLm1hdHJpY2VzSW5kaWNlcy5faXNFeHBhbmRlZClkZWxldGUgYi5tYXRyaWNlc0luZGljZXMuX2lzRXhwYW5kZWQsYy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCxiLm1hdHJpY2VzSW5kaWNlcywhMSk7ZWxzZXtmb3IodmFyIGc9W10saD0wO2g8Yi5tYXRyaWNlc0luZGljZXMubGVuZ3RoO2grKyl7dmFyIGk9Yi5tYXRyaWNlc0luZGljZXNbaF07Zy5wdXNoKDI1NSZpKSxnLnB1c2goKDY1MjgwJmkpPj44KSxnLnB1c2goKDE2NzExNjgwJmkpPj4xNiksZy5wdXNoKGk+PjI0KX1jLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kLGcsITEpfWIubWF0cmljZXNXZWlnaHRzJiZjLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kLGIubWF0cmljZXNXZWlnaHRzLCExKSxjLnNldEluZGljZXMoYi5pbmRpY2VzKX1pZihiLnN1Yk1lc2hlcyl7Yy5zdWJNZXNoZXM9W107Zm9yKHZhciBqPTA7ajxiLnN1Yk1lc2hlcy5sZW5ndGg7aisrKXt2YXIgaz1iLnN1Yk1lc2hlc1tqXTtuZXcgYS5TdWJNZXNoKGsubWF0ZXJpYWxJbmRleCxrLnZlcnRpY2VzU3RhcnQsay52ZXJ0aWNlc0NvdW50LGsuaW5kZXhTdGFydCxrLmluZGV4Q291bnQsYyl9fWMuX3Nob3VsZEdlbmVyYXRlRmxhdFNoYWRpbmcmJihjLmNvbnZlcnRUb0ZsYXRTaGFkZWRNZXNoKCksZGVsZXRlIGMuX3Nob3VsZEdlbmVyYXRlRmxhdFNoYWRpbmcpLGMuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxkLl9zZWxlY3Rpb25PY3RyZWUmJmQuX3NlbGVjdGlvbk9jdHJlZS5hZGRNZXNoKGMpfTthLlNjZW5lTG9hZGVyLlJlZ2lzdGVyUGx1Z2luKHtleHRlbnNpb25zOlwiLmJhYnlsb25cIixpbXBvcnRNZXNoOmZ1bmN0aW9uKGEsYixjLGUsaCxqLGspe2Zvcih2YXIgbD1KU09OLnBhcnNlKGMpLG09W10sbj1bXSxvPVtdLHA9MDtwPGwubWVzaGVzLmxlbmd0aDtwKyspe3ZhciBxPWwubWVzaGVzW3BdO2lmKCFhfHx4KHEsYSxvKSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5JiZkZWxldGUgYVthLmluZGV4T2YocS5uYW1lKV0scS5tYXRlcmlhbElkKXt2YXIgcj0tMSE9PW4uaW5kZXhPZihxLm1hdGVyaWFsSWQpO2lmKCFyKWZvcih2YXIgcz0wO3M8bC5tdWx0aU1hdGVyaWFscy5sZW5ndGg7cysrKXt2YXIgdD1sLm11bHRpTWF0ZXJpYWxzW3NdO2lmKHQuaWQ9PXEubWF0ZXJpYWxJZCl7Zm9yKHZhciB1PTA7dTx0Lm1hdGVyaWFscy5sZW5ndGg7dSsrKXt2YXIgdj10Lm1hdGVyaWFsc1t1XTtuLnB1c2godiksZih2LGwsYixlKX1uLnB1c2godC5pZCksZyh0LGIpLHI9ITA7YnJlYWt9fXJ8fChuLnB1c2gocS5tYXRlcmlhbElkKSxmKHEubWF0ZXJpYWxJZCxsLGIsZSkpfWlmKHEuc2tlbGV0b25JZD4tMSYmYi5za2VsZXRvbnMpe3ZhciB5PW0uaW5kZXhPZihxLnNrZWxldG9uSWQpPi0xO2lmKCF5KWZvcih2YXIgej0wO3o8bC5za2VsZXRvbnMubGVuZ3RoO3orKyl7dmFyIEE9bC5za2VsZXRvbnNbel07QS5pZD09PXEuc2tlbGV0b25JZCYmKGsucHVzaChkKEEsYikpLG0ucHVzaChBLmlkKSl9fXZhciBCPXcocSxiLGUpO2gucHVzaChCKX19aWYobC5wYXJ0aWNsZVN5c3RlbXMpZm9yKHA9MDtwPGwucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtwKyspe3ZhciBDPWwucGFydGljbGVTeXN0ZW1zW3BdOy0xIT09by5pbmRleE9mKEMuZW1pdHRlcklkKSYmai5wdXNoKGkoQyxiLGUpKX1yZXR1cm4hMH0sbG9hZDpmdW5jdGlvbihiLGMsZil7dmFyIGs9SlNPTi5wYXJzZShjKTtiLnVzZURlbGF5ZWRUZXh0dXJlTG9hZGluZz1rLnVzZURlbGF5ZWRUZXh0dXJlTG9hZGluZyYmIWEuU2NlbmVMb2FkZXIuRm9yY2VGdWxsU2NlbmVMb2FkaW5nRm9ySW5jcmVtZW50YWwsYi5hdXRvQ2xlYXI9ay5hdXRvQ2xlYXIsYi5jbGVhckNvbG9yPWEuQ29sb3IzLkZyb21BcnJheShrLmNsZWFyQ29sb3IpLGIuYW1iaWVudENvbG9yPWEuQ29sb3IzLkZyb21BcnJheShrLmFtYmllbnRDb2xvciksYi5ncmF2aXR5PWEuVmVjdG9yMy5Gcm9tQXJyYXkoay5ncmF2aXR5KSxrLmZvZ01vZGUmJjAhPT1rLmZvZ01vZGUmJihiLmZvZ01vZGU9ay5mb2dNb2RlLGIuZm9nQ29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGsuZm9nQ29sb3IpLGIuZm9nU3RhcnQ9ay5mb2dTdGFydCxiLmZvZ0VuZD1rLmZvZ0VuZCxiLmZvZ0RlbnNpdHk9ay5mb2dEZW5zaXR5KTtmb3IodmFyIG49MDtuPGsubGlnaHRzLmxlbmd0aDtuKyspe3ZhciB4PWsubGlnaHRzW25dO2woeCxiKX1mb3Iobj0wO248ay5jYW1lcmFzLmxlbmd0aDtuKyspe3ZhciB5PWsuY2FtZXJhc1tuXTttKHksYil9aWYoay5hY3RpdmVDYW1lcmFJRCYmYi5zZXRBY3RpdmVDYW1lcmFCeUlEKGsuYWN0aXZlQ2FtZXJhSUQpLGsubWF0ZXJpYWxzKWZvcihuPTA7bjxrLm1hdGVyaWFscy5sZW5ndGg7bisrKXt2YXIgej1rLm1hdGVyaWFsc1tuXTtlKHosYixmKX1pZihrLm11bHRpTWF0ZXJpYWxzKWZvcihuPTA7bjxrLm11bHRpTWF0ZXJpYWxzLmxlbmd0aDtuKyspe3ZhciBBPWsubXVsdGlNYXRlcmlhbHNbbl07ZyhBLGIpfWlmKGsuc2tlbGV0b25zKWZvcihuPTA7bjxrLnNrZWxldG9ucy5sZW5ndGg7bisrKXt2YXIgQj1rLnNrZWxldG9uc1tuXTtkKEIsYil9dmFyIEM9ay5nZW9tZXRyaWVzO2lmKEMpe3ZhciBEPUMuYm94ZXM7aWYoRClmb3Iobj0wO248RC5sZW5ndGg7bisrKXt2YXIgRT1EW25dO28oRSxiKX12YXIgRj1DLnNwaGVyZXM7aWYoRilmb3Iobj0wO248Ri5sZW5ndGg7bisrKXt2YXIgRz1GW25dO3AoRyxiKX12YXIgSD1DLmN5bGluZGVycztpZihIKWZvcihuPTA7bjxILmxlbmd0aDtuKyspe3ZhciBJPUhbbl07cShJLGIpfXZhciBKPUMudG9ydXNlcztpZihKKWZvcihuPTA7bjxKLmxlbmd0aDtuKyspe3ZhciBLPUpbbl07cihLLGIpfXZhciBMPUMuZ3JvdW5kcztpZihMKWZvcihuPTA7bjxMLmxlbmd0aDtuKyspe3ZhciBNPUxbbl07cyhNLGIpfXZhciBOPUMucGxhbmVzO2lmKE4pZm9yKG49MDtuPE4ubGVuZ3RoO24rKyl7dmFyIE89TltuXTt0KE8sYil9dmFyIFA9Qy50b3J1c0tub3RzO2lmKFApZm9yKG49MDtuPFAubGVuZ3RoO24rKyl7dmFyIFE9UFtuXTt1KFEsYil9dmFyIFI9Qy52ZXJ0ZXhEYXRhO2lmKFIpZm9yKG49MDtuPFIubGVuZ3RoO24rKyl7dmFyIFM9UltuXTt2KFMsYixmKX19Zm9yKG49MDtuPGsubWVzaGVzLmxlbmd0aDtuKyspe3ZhciBUPWsubWVzaGVzW25dO3coVCxiLGYpfWZvcihuPTA7bjxiLmNhbWVyYXMubGVuZ3RoO24rKyl7dmFyIFU9Yi5jYW1lcmFzW25dO2lmKFUuX3dhaXRpbmdQYXJlbnRJZCYmKFUucGFyZW50PWIuZ2V0TGFzdEVudHJ5QnlJRChVLl93YWl0aW5nUGFyZW50SWQpLGRlbGV0ZSBVLl93YWl0aW5nUGFyZW50SWQpLFUgaW5zdGFuY2VvZiBhLkZyZWVDYW1lcmEpe3ZhciBWPVU7Vi5fd2FpdGluZ0xvY2tlZFRhcmdldElkJiYoVi5sb2NrZWRUYXJnZXQ9Yi5nZXRMYXN0RW50cnlCeUlEKFYuX3dhaXRpbmdMb2NrZWRUYXJnZXRJZCksZGVsZXRlIFYuX3dhaXRpbmdMb2NrZWRUYXJnZXRJZCl9fWlmKGsucGFydGljbGVTeXN0ZW1zKWZvcihuPTA7bjxrLnBhcnRpY2xlU3lzdGVtcy5sZW5ndGg7bisrKXt2YXIgVz1rLnBhcnRpY2xlU3lzdGVtc1tuXTtpKFcsYixmKX1pZihrLmxlbnNGbGFyZVN5c3RlbXMpZm9yKG49MDtuPGsubGVuc0ZsYXJlU3lzdGVtcy5sZW5ndGg7bisrKXt2YXIgWD1rLmxlbnNGbGFyZVN5c3RlbXNbbl07aChYLGIsZil9aWYoay5zaGFkb3dHZW5lcmF0b3JzKWZvcihuPTA7bjxrLnNoYWRvd0dlbmVyYXRvcnMubGVuZ3RoO24rKyl7dmFyIFk9ay5zaGFkb3dHZW5lcmF0b3JzW25dO2ooWSxiKX1yZXR1cm4hMH19KX0oYS5JbnRlcm5hbHN8fChhLkludGVybmFscz17fSkpO2EuSW50ZXJuYWxzfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj0wLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjKXt0aGlzLnBvcz1hLHRoaXMubm9ybWFsPWIsdGhpcy51dj1jfXJldHVybiBiLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYih0aGlzLnBvcy5jbG9uZSgpLHRoaXMubm9ybWFsLmNsb25lKCksdGhpcy51di5jbG9uZSgpKX0sYi5wcm90b3R5cGUuZmxpcD1mdW5jdGlvbigpe3RoaXMubm9ybWFsPXRoaXMubm9ybWFsLnNjYWxlKC0xKX0sYi5wcm90b3R5cGUuaW50ZXJwb2xhdGU9ZnVuY3Rpb24oYyxkKXtyZXR1cm4gbmV3IGIoYS5WZWN0b3IzLkxlcnAodGhpcy5wb3MsYy5wb3MsZCksYS5WZWN0b3IzLkxlcnAodGhpcy5ub3JtYWwsYy5ub3JtYWwsZCksYS5WZWN0b3IyLkxlcnAodGhpcy51dixjLnV2LGQpKX0sYn0oKSxkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIpe3RoaXMubm9ybWFsPWEsdGhpcy53PWJ9cmV0dXJuIGIuRnJvbVBvaW50cz1mdW5jdGlvbihjLGQsZSl7dmFyIGY9ZS5zdWJ0cmFjdChjKSxnPWQuc3VidHJhY3QoYyk7aWYoMD09PWYubGVuZ3RoU3F1YXJlZCgpfHwwPT09Zy5sZW5ndGhTcXVhcmVkKCkpcmV0dXJuIG51bGw7dmFyIGg9YS5WZWN0b3IzLk5vcm1hbGl6ZShhLlZlY3RvcjMuQ3Jvc3MoZixnKSk7cmV0dXJuIG5ldyBiKGgsYS5WZWN0b3IzLkRvdChoLGMpKX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIodGhpcy5ub3JtYWwuY2xvbmUoKSx0aGlzLncpfSxiLnByb3RvdHlwZS5mbGlwPWZ1bmN0aW9uKCl7dGhpcy5ub3JtYWwuc2NhbGVJblBsYWNlKC0xKSx0aGlzLnc9LXRoaXMud30sYi5wcm90b3R5cGUuc3BsaXRQb2x5Z29uPWZ1bmN0aW9uKGMsZCxmLGcsaCl7Zm9yKHZhciBpPTAsaj0xLGs9MixsPTMsbT0wLG49W10sbz0wO288Yy52ZXJ0aWNlcy5sZW5ndGg7bysrKXt2YXIgcD1hLlZlY3RvcjMuRG90KHRoaXMubm9ybWFsLGMudmVydGljZXNbb10ucG9zKS10aGlzLncscT1wPC1iLkVQU0lMT04/azpwPmIuRVBTSUxPTj9qOmk7bXw9cSxuLnB1c2gocSl9c3dpdGNoKG0pe2Nhc2UgaTooYS5WZWN0b3IzLkRvdCh0aGlzLm5vcm1hbCxjLnBsYW5lLm5vcm1hbCk+MD9kOmYpLnB1c2goYyk7YnJlYWs7Y2FzZSBqOmcucHVzaChjKTticmVhaztjYXNlIGs6aC5wdXNoKGMpO2JyZWFrO2Nhc2UgbDp2YXIgcj1bXSxzPVtdO2ZvcihvPTA7bzxjLnZlcnRpY2VzLmxlbmd0aDtvKyspe3ZhciB0PShvKzEpJWMudmVydGljZXMubGVuZ3RoLHU9bltvXSx2PW5bdF0sdz1jLnZlcnRpY2VzW29dLHg9Yy52ZXJ0aWNlc1t0XTtpZih1IT1rJiZyLnB1c2godyksdSE9aiYmcy5wdXNoKHUhPWs/dy5jbG9uZSgpOncpLCh1fHYpPT1sKXtwPSh0aGlzLnctYS5WZWN0b3IzLkRvdCh0aGlzLm5vcm1hbCx3LnBvcykpL2EuVmVjdG9yMy5Eb3QodGhpcy5ub3JtYWwseC5wb3Muc3VidHJhY3Qody5wb3MpKTt2YXIgeT13LmludGVycG9sYXRlKHgscCk7ci5wdXNoKHkpLHMucHVzaCh5LmNsb25lKCkpfX1pZihyLmxlbmd0aD49Myl7dmFyIHo9bmV3IGUocixjLnNoYXJlZCk7ei5wbGFuZSYmZy5wdXNoKHopfXMubGVuZ3RoPj0zJiYoej1uZXcgZShzLGMuc2hhcmVkKSx6LnBsYW5lJiZoLnB1c2goeikpfX0sYi5FUFNJTE9OPTFlLTUsYn0oKSxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3RoaXMudmVydGljZXM9YSx0aGlzLnNoYXJlZD1iLHRoaXMucGxhbmU9ZC5Gcm9tUG9pbnRzKGFbMF0ucG9zLGFbMV0ucG9zLGFbMl0ucG9zKX1yZXR1cm4gYS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLnZlcnRpY2VzLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS5jbG9uZSgpfSk7cmV0dXJuIG5ldyBhKGIsdGhpcy5zaGFyZWQpfSxhLnByb3RvdHlwZS5mbGlwPWZ1bmN0aW9uKCl7dGhpcy52ZXJ0aWNlcy5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGEpe2EuZmxpcCgpfSksdGhpcy5wbGFuZS5mbGlwKCl9LGF9KCksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7dGhpcy5wbGFuZT1udWxsLHRoaXMuZnJvbnQ9bnVsbCx0aGlzLmJhY2s9bnVsbCx0aGlzLnBvbHlnb25zPVtdLGEmJnRoaXMuYnVpbGQoYSl9cmV0dXJuIGEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGI9bmV3IGE7cmV0dXJuIGIucGxhbmU9dGhpcy5wbGFuZSYmdGhpcy5wbGFuZS5jbG9uZSgpLGIuZnJvbnQ9dGhpcy5mcm9udCYmdGhpcy5mcm9udC5jbG9uZSgpLGIuYmFjaz10aGlzLmJhY2smJnRoaXMuYmFjay5jbG9uZSgpLGIucG9seWdvbnM9dGhpcy5wb2x5Z29ucy5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xvbmUoKX0pLGJ9LGEucHJvdG90eXBlLmludmVydD1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5wb2x5Z29ucy5sZW5ndGg7YSsrKXRoaXMucG9seWdvbnNbYV0uZmxpcCgpO3RoaXMucGxhbmUmJnRoaXMucGxhbmUuZmxpcCgpLHRoaXMuZnJvbnQmJnRoaXMuZnJvbnQuaW52ZXJ0KCksdGhpcy5iYWNrJiZ0aGlzLmJhY2suaW52ZXJ0KCk7dmFyIGI9dGhpcy5mcm9udDt0aGlzLmZyb250PXRoaXMuYmFjayx0aGlzLmJhY2s9Yn0sYS5wcm90b3R5cGUuY2xpcFBvbHlnb25zPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLnBsYW5lKXJldHVybiBhLnNsaWNlKCk7Zm9yKHZhciBiPVtdLGM9W10sZD0wO2Q8YS5sZW5ndGg7ZCsrKXRoaXMucGxhbmUuc3BsaXRQb2x5Z29uKGFbZF0sYixjLGIsYyk7cmV0dXJuIHRoaXMuZnJvbnQmJihiPXRoaXMuZnJvbnQuY2xpcFBvbHlnb25zKGIpKSxjPXRoaXMuYmFjaz90aGlzLmJhY2suY2xpcFBvbHlnb25zKGMpOltdLGIuY29uY2F0KGMpfSxhLnByb3RvdHlwZS5jbGlwVG89ZnVuY3Rpb24oYSl7dGhpcy5wb2x5Z29ucz1hLmNsaXBQb2x5Z29ucyh0aGlzLnBvbHlnb25zKSx0aGlzLmZyb250JiZ0aGlzLmZyb250LmNsaXBUbyhhKSx0aGlzLmJhY2smJnRoaXMuYmFjay5jbGlwVG8oYSl9LGEucHJvdG90eXBlLmFsbFBvbHlnb25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wb2x5Z29ucy5zbGljZSgpO3JldHVybiB0aGlzLmZyb250JiYoYT1hLmNvbmNhdCh0aGlzLmZyb250LmFsbFBvbHlnb25zKCkpKSx0aGlzLmJhY2smJihhPWEuY29uY2F0KHRoaXMuYmFjay5hbGxQb2x5Z29ucygpKSksYX0sYS5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oYil7aWYoYi5sZW5ndGgpe3RoaXMucGxhbmV8fCh0aGlzLnBsYW5lPWJbMF0ucGxhbmUuY2xvbmUoKSk7Zm9yKHZhciBjPVtdLGQ9W10sZT0wO2U8Yi5sZW5ndGg7ZSsrKXRoaXMucGxhbmUuc3BsaXRQb2x5Z29uKGJbZV0sdGhpcy5wb2x5Z29ucyx0aGlzLnBvbHlnb25zLGMsZCk7Yy5sZW5ndGgmJih0aGlzLmZyb250fHwodGhpcy5mcm9udD1uZXcgYSksdGhpcy5mcm9udC5idWlsZChjKSksZC5sZW5ndGgmJih0aGlzLmJhY2t8fCh0aGlzLmJhY2s9bmV3IGEpLHRoaXMuYmFjay5idWlsZChkKSl9fSxhfSgpLGc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7dGhpcy5wb2x5Z29ucz1uZXcgQXJyYXl9cmV0dXJuIGQuRnJvbU1lc2g9ZnVuY3Rpb24oZil7dmFyIGcsaCxpLGosayxsLG09W107aWYoIShmIGluc3RhbmNlb2YgYS5NZXNoKSl0aHJvd1wiQkFCWUxPTi5DU0c6V3JvbmcgTWVzaCB0eXBlLG11c3QgYmUgQkFCWUxPTi5NZXNoXCI7Zi5jb21wdXRlV29ybGRNYXRyaXgoITApO2Zvcih2YXIgbj1mLmdldFdvcmxkTWF0cml4KCksbz1mLnBvc2l0aW9uLmNsb25lKCkscD1mLnJvdGF0aW9uLmNsb25lKCkscT1mLnNjYWxpbmcuY2xvbmUoKSxyPWYuZ2V0SW5kaWNlcygpLHM9Zi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSx0PWYuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpLHU9Zi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSx2PWYuc3ViTWVzaGVzLHc9MCx4PXYubGVuZ3RoO3g+dzt3KyspZm9yKHZhciB5PXZbd10uaW5kZXhTdGFydCx6PXZbd10uaW5kZXhDb3VudCt2W3ddLmluZGV4U3RhcnQ7ej55O3krPTMpe2w9W107Zm9yKHZhciBBPTA7Mz5BO0ErKyloPW5ldyBhLlZlY3RvcjModFszKnJbeStBXV0sdFszKnJbeStBXSsxXSx0WzMqclt5K0FdKzJdKSxpPW5ldyBhLlZlY3RvcjIodVsyKnJbeStBXV0sdVsyKnJbeStBXSsxXSksaj1uZXcgYS5WZWN0b3IzKHNbMypyW3krQV1dLHNbMypyW3krQV0rMV0sc1szKnJbeStBXSsyXSksYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYoaixuLGopLGEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxUb1JlZihoLG4saCksZz1uZXcgYyhqLGgsaSksbC5wdXNoKGcpO2s9bmV3IGUobCx7c3ViTWVzaElkOncsbWVzaElkOmIsbWF0ZXJpYWxJbmRleDp2W3ddLm1hdGVyaWFsSW5kZXh9KSxrLnBsYW5lJiZtLnB1c2goayl9dmFyIEI9ZC5Gcm9tUG9seWdvbnMobSk7cmV0dXJuIEIubWF0cml4PW4sQi5wb3NpdGlvbj1vLEIucm90YXRpb249cCxCLnNjYWxpbmc9cSxiKyssQn0sZC5Gcm9tUG9seWdvbnM9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGEuQ1NHO3JldHVybiBjLnBvbHlnb25zPWIsY30sZC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj1uZXcgYS5DU0c7cmV0dXJuIGIucG9seWdvbnM9dGhpcy5wb2x5Z29ucy5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xvbmUoKX0pLGIuY29weVRyYW5zZm9ybUF0dHJpYnV0ZXModGhpcyksYn0sZC5wcm90b3R5cGUudG9Qb2x5Z29ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25zfSxkLnByb3RvdHlwZS51bmlvbj1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZih0aGlzLmNsb25lKCkucG9seWdvbnMpLGM9bmV3IGYoYS5jbG9uZSgpLnBvbHlnb25zKTtyZXR1cm4gYi5jbGlwVG8oYyksYy5jbGlwVG8oYiksYy5pbnZlcnQoKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGIuYnVpbGQoYy5hbGxQb2x5Z29ucygpKSxkLkZyb21Qb2x5Z29ucyhiLmFsbFBvbHlnb25zKCkpLmNvcHlUcmFuc2Zvcm1BdHRyaWJ1dGVzKHRoaXMpfSxkLnByb3RvdHlwZS51bmlvbkluUGxhY2U9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGYodGhpcy5wb2x5Z29ucyksYz1uZXcgZihhLnBvbHlnb25zKTtiLmNsaXBUbyhjKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLHRoaXMucG9seWdvbnM9Yi5hbGxQb2x5Z29ucygpfSxkLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZih0aGlzLmNsb25lKCkucG9seWdvbnMpLGM9bmV3IGYoYS5jbG9uZSgpLnBvbHlnb25zKTtyZXR1cm4gYi5pbnZlcnQoKSxiLmNsaXBUbyhjKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLGIuaW52ZXJ0KCksZC5Gcm9tUG9seWdvbnMoYi5hbGxQb2x5Z29ucygpKS5jb3B5VHJhbnNmb3JtQXR0cmlidXRlcyh0aGlzKX0sZC5wcm90b3R5cGUuc3VidHJhY3RJblBsYWNlPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBmKHRoaXMucG9seWdvbnMpLGM9bmV3IGYoYS5wb2x5Z29ucyk7Yi5pbnZlcnQoKSxiLmNsaXBUbyhjKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLGIuaW52ZXJ0KCksdGhpcy5wb2x5Z29ucz1iLmFsbFBvbHlnb25zKCl9LGQucHJvdG90eXBlLmludGVyc2VjdD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZih0aGlzLmNsb25lKCkucG9seWdvbnMpLGM9bmV3IGYoYS5jbG9uZSgpLnBvbHlnb25zKTtyZXR1cm4gYi5pbnZlcnQoKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGIuY2xpcFRvKGMpLGMuY2xpcFRvKGIpLGIuYnVpbGQoYy5hbGxQb2x5Z29ucygpKSxiLmludmVydCgpLGQuRnJvbVBvbHlnb25zKGIuYWxsUG9seWdvbnMoKSkuY29weVRyYW5zZm9ybUF0dHJpYnV0ZXModGhpcyl9LGQucHJvdG90eXBlLmludGVyc2VjdEluUGxhY2U9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGYodGhpcy5wb2x5Z29ucyksYz1uZXcgZihhLnBvbHlnb25zKTtiLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5jbGlwVG8oYyksYy5jbGlwVG8oYiksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLGIuaW52ZXJ0KCksdGhpcy5wb2x5Z29ucz1iLmFsbFBvbHlnb25zKCl9LGQucHJvdG90eXBlLmludmVyc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNsb25lKCk7cmV0dXJuIGEuaW52ZXJzZUluUGxhY2UoKSxhfSxkLnByb3RvdHlwZS5pbnZlcnNlSW5QbGFjZT1mdW5jdGlvbigpe3RoaXMucG9seWdvbnMubWFwKGZ1bmN0aW9uKGEpe2EuZmxpcCgpfSl9LGQucHJvdG90eXBlLmNvcHlUcmFuc2Zvcm1BdHRyaWJ1dGVzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hdHJpeD1hLm1hdHJpeCx0aGlzLnBvc2l0aW9uPWEucG9zaXRpb24sdGhpcy5yb3RhdGlvbj1hLnJvdGF0aW9uLHRoaXMuc2NhbGluZz1hLnNjYWxpbmcsdGhpc30sZC5wcm90b3R5cGUuYnVpbGRNZXNoR2VvbWV0cnk9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXMubWF0cml4LmNsb25lKCk7ZS5pbnZlcnQoKTt2YXIgZixnLGgsaT1uZXcgYS5NZXNoKGIsYyksaj1bXSxrPVtdLGw9W10sbT1bXSxuPWEuVmVjdG9yMy5aZXJvKCksbz1hLlZlY3RvcjMuWmVybygpLHA9YS5WZWN0b3IyLlplcm8oKSxxPXRoaXMucG9seWdvbnMscj1bMCwwLDBdLHM9e30sdD0wLHU9e307ZCYmcS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc2hhcmVkLm1lc2hJZD09PWIuc2hhcmVkLm1lc2hJZD9hLnNoYXJlZC5zdWJNZXNoSWQtYi5zaGFyZWQuc3ViTWVzaElkOmEuc2hhcmVkLm1lc2hJZC1iLnNoYXJlZC5tZXNoSWR9KTtmb3IodmFyIHY9MCx3PXEubGVuZ3RoO3c+djt2Kyspe2Y9cVt2XSx1W2Yuc2hhcmVkLm1lc2hJZF18fCh1W2Yuc2hhcmVkLm1lc2hJZF09e30pLHVbZi5zaGFyZWQubWVzaElkXVtmLnNoYXJlZC5zdWJNZXNoSWRdfHwodVtmLnNoYXJlZC5tZXNoSWRdW2Yuc2hhcmVkLnN1Yk1lc2hJZF09e2luZGV4U3RhcnQ6KzEvMCxpbmRleEVuZDotMS8wLG1hdGVyaWFsSW5kZXg6Zi5zaGFyZWQubWF0ZXJpYWxJbmRleH0pLGg9dVtmLnNoYXJlZC5tZXNoSWRdW2Yuc2hhcmVkLnN1Yk1lc2hJZF07Zm9yKHZhciB4PTIseT1mLnZlcnRpY2VzLmxlbmd0aDt5Png7eCsrKXtyWzBdPTAsclsxXT14LTEsclsyXT14O2Zvcih2YXIgej0wOzM+ejt6Kyspbi5jb3B5RnJvbShmLnZlcnRpY2VzW3Jbel1dLnBvcyksby5jb3B5RnJvbShmLnZlcnRpY2VzW3Jbel1dLm5vcm1hbCkscC5jb3B5RnJvbShmLnZlcnRpY2VzW3Jbel1dLnV2KSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZihuLGUsbiksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKG8sZSxvKSxnPXNbbi54K1wiLFwiK24ueStcIixcIituLnpdLChcInVuZGVmaW5lZFwiPT10eXBlb2YgZ3x8bFszKmddIT09by54fHxsWzMqZysxXSE9PW8ueXx8bFszKmcrMl0hPT1vLnp8fG1bMipnXSE9PXAueHx8bVsyKmcrMV0hPT1wLnkpJiYoai5wdXNoKG4ueCxuLnksbi56KSxtLnB1c2gocC54LHAueSksbC5wdXNoKG8ueCxvLnksby56KSxnPXNbbi54K1wiLFwiK24ueStcIixcIituLnpdPWoubGVuZ3RoLzMtMSksay5wdXNoKGcpLGguaW5kZXhTdGFydD1NYXRoLm1pbih0LGguaW5kZXhTdGFydCksaC5pbmRleEVuZD1NYXRoLm1heCh0LGguaW5kZXhFbmQpLHQrK319aWYoaS5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLGopLGkuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsbCksaS5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kLG0pLGkuc2V0SW5kaWNlcyhrKSxkKXt2YXIgQSxCPTA7aS5zdWJNZXNoZXMubGVuZ3RoPTA7Zm9yKHZhciBDIGluIHUpe0E9LTE7Zm9yKHZhciBEIGluIHVbQ10paD11W0NdW0RdLGEuU3ViTWVzaC5DcmVhdGVGcm9tSW5kaWNlcyhoLm1hdGVyaWFsSW5kZXgrQixoLmluZGV4U3RhcnQsaC5pbmRleEVuZC1oLmluZGV4U3RhcnQrMSxpKSxBPU1hdGgubWF4KGgubWF0ZXJpYWxJbmRleCxBKTtCKz0rK0F9fXJldHVybiBpfSxkLnByb3RvdHlwZS50b01lc2g9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5idWlsZE1lc2hHZW9tZXRyeShhLGMsZCk7cmV0dXJuIGUubWF0ZXJpYWw9YixlLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMucG9zaXRpb24pLGUucm90YXRpb24uY29weUZyb20odGhpcy5yb3RhdGlvbiksZS5zY2FsaW5nLmNvcHlGcm9tKHRoaXMuc2NhbGluZyksZS5jb21wdXRlV29ybGRNYXRyaXgoITApLGV9LGR9KCk7YS5DU0c9Z30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUsZil7dmFyIGc9dGhpcztiLmNhbGwodGhpcyxjLFwib2N1bHVzRGlzdG9ydGlvbkNvcnJlY3Rpb25cIixbXCJMZW5zQ2VudGVyXCIsXCJTY2FsZVwiLFwiU2NhbGVJblwiLFwiSG1kV2FycFBhcmFtXCJdLG51bGwsZi5Qb3N0UHJvY2Vzc1NjYWxlRmFjdG9yLGQsYS5UZXh0dXJlLkJJTElORUFSX1NBTVBMSU5HTU9ERSxudWxsLG51bGwpLHRoaXMuX2lzUmlnaHRFeWU9ZSx0aGlzLl9kaXN0b3J0aW9uRmFjdG9ycz1mLkRpc3RvcnRpb25LLHRoaXMuX3Bvc3RQcm9jZXNzU2NhbGVGYWN0b3I9Zi5Qb3N0UHJvY2Vzc1NjYWxlRmFjdG9yLHRoaXMuX2xlbnNDZW50ZXJPZmZzZXQ9Zi5MZW5zQ2VudGVyT2Zmc2V0LHRoaXMub25TaXplQ2hhbmdlZD1mdW5jdGlvbigpe2cuYXNwZWN0UmF0aW89LjUqZy53aWR0aC9nLmhlaWdodCxnLl9zY2FsZUluPW5ldyBhLlZlY3RvcjIoMiwyL2cuYXNwZWN0UmF0aW8pLGcuX3NjYWxlRmFjdG9yPW5ldyBhLlZlY3RvcjIoLjUqKDEvZy5fcG9zdFByb2Nlc3NTY2FsZUZhY3RvciksLjUqKDEvZy5fcG9zdFByb2Nlc3NTY2FsZUZhY3RvcikqZy5hc3BlY3RSYXRpbyksZy5fbGVuc0NlbnRlcj1uZXcgYS5WZWN0b3IyKGcuX2lzUmlnaHRFeWU/LjUtLjUqZy5fbGVuc0NlbnRlck9mZnNldDouNSsuNSpnLl9sZW5zQ2VudGVyT2Zmc2V0LC41KX0sdGhpcy5vbkFwcGx5PWZ1bmN0aW9uKGEpe2Euc2V0RmxvYXQyKFwiTGVuc0NlbnRlclwiLGcuX2xlbnNDZW50ZXIueCxnLl9sZW5zQ2VudGVyLnkpLGEuc2V0RmxvYXQyKFwiU2NhbGVcIixnLl9zY2FsZUZhY3Rvci54LGcuX3NjYWxlRmFjdG9yLnkpLGEuc2V0RmxvYXQyKFwiU2NhbGVJblwiLGcuX3NjYWxlSW4ueCxnLl9zY2FsZUluLnkpLGEuc2V0RmxvYXQ0KFwiSG1kV2FycFBhcmFtXCIsZy5fZGlzdG9ydGlvbkZhY3RvcnNbMF0sZy5fZGlzdG9ydGlvbkZhY3RvcnNbMV0sZy5fZGlzdG9ydGlvbkZhY3RvcnNbMl0sZy5fZGlzdG9ydGlvbkZhY3RvcnNbM10pfX1yZXR1cm4gX19leHRlbmRzKGMsYiksY30oYS5Qb3N0UHJvY2Vzcyk7YS5PY3VsdXNEaXN0b3J0aW9uQ29ycmVjdGlvblBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpeyFmdW5jdGlvbihhKXthW2EuWD0wXT1cIlhcIixhW2EuWT0xXT1cIllcIixhW2EuWj0yXT1cIlpcIn0oYS5Kb3lzdGlja0F4aXN8fChhLkpveXN0aWNrQXhpcz17fSkpO3ZhciBiPShhLkpveXN0aWNrQXhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYyl7dmFyIGQ9dGhpczt0aGlzLl9sZWZ0Sm95c3RpY2s9Yz8hMDohMSx0aGlzLl9qb3lzdGlja0luZGV4PWIuX2dsb2JhbEpveXN0aWNrSW5kZXgsYi5fZ2xvYmFsSm95c3RpY2tJbmRleCsrLHRoaXMuX2F4aXNUYXJnZXRlZEJ5TGVmdEFuZFJpZ2h0PTAsdGhpcy5fYXhpc1RhcmdldGVkQnlVcEFuZERvd249MSx0aGlzLnJldmVyc2VMZWZ0UmlnaHQ9ITEsdGhpcy5yZXZlcnNlVXBEb3duPSExLHRoaXMuX3RvdWNoZXM9bmV3IGEuVmlydHVhbEpveXN0aWNrLkNvbGxlY3Rpb24sdGhpcy5kZWx0YVBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fam95c3RpY2tTZW5zaWJpbGl0eT0yNSx0aGlzLl9pbnZlcnNlZFNlbnNpYmlsaXR5PTEvKHRoaXMuX2pveXN0aWNrU2Vuc2liaWxpdHkvMWUzKSx0aGlzLl9yb3RhdGlvblNwZWVkPTI1LHRoaXMuX2ludmVyc2VSb3RhdGlvblNwZWVkPTEvKHRoaXMuX3JvdGF0aW9uU3BlZWQvMWUzKSx0aGlzLl9yb3RhdGVPbkF4aXNSZWxhdGl2ZVRvTWVzaD0hMSxiLnZqQ2FudmFzfHwod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixmdW5jdGlvbigpe2IudmpDYW52YXNXaWR0aD13aW5kb3cuaW5uZXJXaWR0aCxiLnZqQ2FudmFzSGVpZ2h0PXdpbmRvdy5pbm5lckhlaWdodCxiLnZqQ2FudmFzLndpZHRoPWIudmpDYW52YXNXaWR0aCxiLnZqQ2FudmFzLmhlaWdodD1iLnZqQ2FudmFzSGVpZ2h0LGIuaGFsZldpZHRoPWIudmpDYW52YXNXaWR0aC8yLGIuaGFsZkhlaWdodD1iLnZqQ2FudmFzSGVpZ2h0LzJ9LCExKSxiLnZqQ2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksYi52akNhbnZhc1dpZHRoPXdpbmRvdy5pbm5lcldpZHRoLGIudmpDYW52YXNIZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0LGIudmpDYW52YXMud2lkdGg9d2luZG93LmlubmVyV2lkdGgsYi52akNhbnZhcy5oZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0LGIudmpDYW52YXMuc3R5bGUud2lkdGg9XCIxMDAlXCIsYi52akNhbnZhcy5zdHlsZS5oZWlnaHQ9XCIxMDAlXCIsYi52akNhbnZhcy5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsYi52akNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJ0cmFuc3BhcmVudFwiLGIudmpDYW52YXMuc3R5bGUudG9wPVwiMHB4XCIsYi52akNhbnZhcy5zdHlsZS5sZWZ0PVwiMHB4XCIsYi52akNhbnZhcy5zdHlsZS56SW5kZXg9XCI1XCIsYi52akNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uPVwibm9uZVwiLGIudmpDYW52YXNDb250ZXh0PWIudmpDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlPVwiI2ZmZmZmZlwiLGIudmpDYW52YXNDb250ZXh0LmxpbmVXaWR0aD0yLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi52akNhbnZhcykpLGIuaGFsZldpZHRoPWIudmpDYW52YXMud2lkdGgvMixiLmhhbGZIZWlnaHQ9Yi52akNhbnZhcy5oZWlnaHQvMix0aGlzLnByZXNzZWQ9ITEsdGhpcy5fam95c3RpY2tDb2xvcj1cImN5YW5cIix0aGlzLl9qb3lzdGlja1BvaW50ZXJJRD0tMSx0aGlzLl9qb3lzdGlja1BvaW50ZXJQb3M9bmV3IGEuVmVjdG9yMigwLDApLHRoaXMuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zPW5ldyBhLlZlY3RvcjIoMCwwKSx0aGlzLl9kZWx0YUpveXN0aWNrVmVjdG9yPW5ldyBhLlZlY3RvcjIoMCwwKSxiLnZqQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLGZ1bmN0aW9uKGEpe2QuX29uUG9pbnRlckRvd24oYSl9LCExKSxiLnZqQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLGZ1bmN0aW9uKGEpe2QuX29uUG9pbnRlck1vdmUoYSl9LCExKSxiLnZqQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIixmdW5jdGlvbihhKXtkLl9vblBvaW50ZXJVcChhKX0sITEpLGIudmpDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdXRcIixmdW5jdGlvbihhKXtkLl9vblBvaW50ZXJVcChhKX0sITEpLGIudmpDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpfSwhMSkscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7ZC5fZHJhd1ZpcnR1YWxKb3lzdGljaygpfSl9cmV0dXJuIGIucHJvdG90eXBlLnNldEpveXN0aWNrU2Vuc2liaWxpdHk9ZnVuY3Rpb24oYSl7dGhpcy5fam95c3RpY2tTZW5zaWJpbGl0eT1hLHRoaXMuX2ludmVyc2VkU2Vuc2liaWxpdHk9MS8odGhpcy5fam95c3RpY2tTZW5zaWJpbGl0eS8xZTMpfSxiLnByb3RvdHlwZS5fb25Qb2ludGVyRG93bj1mdW5jdGlvbihhKXt2YXIgYzthLnByZXZlbnREZWZhdWx0KCksYz10aGlzLl9sZWZ0Sm95c3RpY2s9PT0hMD9hLmNsaWVudFg8Yi5oYWxmV2lkdGg6YS5jbGllbnRYPmIuaGFsZldpZHRoLGMmJnRoaXMuX2pveXN0aWNrUG9pbnRlcklEPDA/KHRoaXMuX2pveXN0aWNrUG9pbnRlcklEPWEucG9pbnRlcklkLHRoaXMuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zLng9YS5jbGllbnRYLHRoaXMuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zLnk9YS5jbGllbnRZLHRoaXMuX2pveXN0aWNrUG9pbnRlclBvcz10aGlzLl9qb3lzdGlja1BvaW50ZXJTdGFydFBvcy5jbG9uZSgpLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueD0wLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueT0wLHRoaXMucHJlc3NlZD0hMCx0aGlzLl90b3VjaGVzLmFkZChhLnBvaW50ZXJJZC50b1N0cmluZygpLGEpKTpiLl9nbG9iYWxKb3lzdGlja0luZGV4PDImJnRoaXMuX2FjdGlvbiYmKHRoaXMuX2FjdGlvbigpLHRoaXMuX3RvdWNoZXMuYWRkKGEucG9pbnRlcklkLnRvU3RyaW5nKCksYSkpfSxiLnByb3RvdHlwZS5fb25Qb2ludGVyTW92ZT1mdW5jdGlvbihhKXtpZih0aGlzLl9qb3lzdGlja1BvaW50ZXJJRD09YS5wb2ludGVySWQpe3RoaXMuX2pveXN0aWNrUG9pbnRlclBvcy54PWEuY2xpZW50WCx0aGlzLl9qb3lzdGlja1BvaW50ZXJQb3MueT1hLmNsaWVudFksdGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvcj10aGlzLl9qb3lzdGlja1BvaW50ZXJQb3MuY2xvbmUoKSx0aGlzLl9kZWx0YUpveXN0aWNrVmVjdG9yPXRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3Iuc3VidHJhY3QodGhpcy5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MpO3ZhciBiPXRoaXMucmV2ZXJzZUxlZnRSaWdodD8tMToxLGM9Yip0aGlzLl9kZWx0YUpveXN0aWNrVmVjdG9yLngvdGhpcy5faW52ZXJzZWRTZW5zaWJpbGl0eTtzd2l0Y2godGhpcy5fYXhpc1RhcmdldGVkQnlMZWZ0QW5kUmlnaHQpe2Nhc2UgMDp0aGlzLmRlbHRhUG9zaXRpb24ueD1NYXRoLm1pbigxLE1hdGgubWF4KC0xLGMpKTticmVhaztjYXNlIDE6dGhpcy5kZWx0YVBvc2l0aW9uLnk9TWF0aC5taW4oMSxNYXRoLm1heCgtMSxjKSk7YnJlYWs7Y2FzZSAyOnRoaXMuZGVsdGFQb3NpdGlvbi56PU1hdGgubWluKDEsTWF0aC5tYXgoLTEsYykpfXZhciBkPXRoaXMucmV2ZXJzZVVwRG93bj8xOi0xLGU9ZCp0aGlzLl9kZWx0YUpveXN0aWNrVmVjdG9yLnkvdGhpcy5faW52ZXJzZWRTZW5zaWJpbGl0eTtzd2l0Y2godGhpcy5fYXhpc1RhcmdldGVkQnlVcEFuZERvd24pe2Nhc2UgMDp0aGlzLmRlbHRhUG9zaXRpb24ueD1NYXRoLm1pbigxLE1hdGgubWF4KC0xLGUpKTticmVhaztjYXNlIDE6dGhpcy5kZWx0YVBvc2l0aW9uLnk9TWF0aC5taW4oMSxNYXRoLm1heCgtMSxlKSk7YnJlYWs7Y2FzZSAyOnRoaXMuZGVsdGFQb3NpdGlvbi56PU1hdGgubWluKDEsTWF0aC5tYXgoLTEsZSkpfX1lbHNlIHRoaXMuX3RvdWNoZXMuaXRlbShhLnBvaW50ZXJJZC50b1N0cmluZygpKSYmKHRoaXMuX3RvdWNoZXMuaXRlbShhLnBvaW50ZXJJZC50b1N0cmluZygpKS54PWEuY2xpZW50WCx0aGlzLl90b3VjaGVzLml0ZW0oYS5wb2ludGVySWQudG9TdHJpbmcoKSkueT1hLmNsaWVudFkpfSxiLnByb3RvdHlwZS5fb25Qb2ludGVyVXA9ZnVuY3Rpb24oYSl7dGhpcy5fY2xlYXJDYW52YXMoKSx0aGlzLl9qb3lzdGlja1BvaW50ZXJJRD09YS5wb2ludGVySWQmJih0aGlzLl9qb3lzdGlja1BvaW50ZXJJRD0tMSx0aGlzLnByZXNzZWQ9ITEpLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueD0wLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueT0wLHRoaXMuX3RvdWNoZXMucmVtb3ZlKGEucG9pbnRlcklkLnRvU3RyaW5nKCkpfSxiLnByb3RvdHlwZS5zZXRKb3lzdGlja0NvbG9yPWZ1bmN0aW9uKGEpe3RoaXMuX2pveXN0aWNrQ29sb3I9YX0sYi5wcm90b3R5cGUuc2V0QWN0aW9uT25Ub3VjaD1mdW5jdGlvbihhKXt0aGlzLl9hY3Rpb249YX0sYi5wcm90b3R5cGUuc2V0QXhpc0ZvckxlZnRSaWdodD1mdW5jdGlvbihhKXtzd2l0Y2goYSl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6dGhpcy5fYXhpc1RhcmdldGVkQnlMZWZ0QW5kUmlnaHQ9YTticmVhaztkZWZhdWx0OnRoaXMuX2F4aXNUYXJnZXRlZEJ5TGVmdEFuZFJpZ2h0PTB9fSxiLnByb3RvdHlwZS5zZXRBeGlzRm9yVXBEb3duPWZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjp0aGlzLl9heGlzVGFyZ2V0ZWRCeVVwQW5kRG93bj1hO2JyZWFrO2RlZmF1bHQ6dGhpcy5fYXhpc1RhcmdldGVkQnlVcEFuZERvd249MX19LGIucHJvdG90eXBlLl9jbGVhckNhbnZhcz1mdW5jdGlvbigpe3RoaXMuX2xlZnRKb3lzdGljaz9iLnZqQ2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwwLGIudmpDYW52YXNXaWR0aC8yLGIudmpDYW52YXNIZWlnaHQpOmIudmpDYW52YXNDb250ZXh0LmNsZWFyUmVjdChiLnZqQ2FudmFzV2lkdGgvMiwwLGIudmpDYW52YXNXaWR0aCxiLnZqQ2FudmFzSGVpZ2h0KX0sYi5wcm90b3R5cGUuX2RyYXdWaXJ0dWFsSm95c3RpY2s9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMucHJlc3NlZCYmKHRoaXMuX2NsZWFyQ2FudmFzKCksdGhpcy5fdG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe2MucG9pbnRlcklkPT09YS5fam95c3RpY2tQb2ludGVySUQ/KGIudmpDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlPWEuX2pveXN0aWNrQ29sb3IsYi52akNhbnZhc0NvbnRleHQubGluZVdpZHRoPTYsYi52akNhbnZhc0NvbnRleHQuYXJjKGEuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zLngsYS5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MueSw0MCwwLDIqTWF0aC5QSSwhMCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlKCksYi52akNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGU9YS5fam95c3RpY2tDb2xvcixiLnZqQ2FudmFzQ29udGV4dC5saW5lV2lkdGg9MixiLnZqQ2FudmFzQ29udGV4dC5hcmMoYS5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MueCxhLl9qb3lzdGlja1BvaW50ZXJTdGFydFBvcy55LDYwLDAsMipNYXRoLlBJLCEwKSxiLnZqQ2FudmFzQ29udGV4dC5zdHJva2UoKSxiLnZqQ2FudmFzQ29udGV4dC5iZWdpblBhdGgoKSxiLnZqQ2FudmFzQ29udGV4dC5zdHJva2VTdHlsZT1hLl9qb3lzdGlja0NvbG9yLGIudmpDYW52YXNDb250ZXh0LmFyYyhhLl9qb3lzdGlja1BvaW50ZXJQb3MueCxhLl9qb3lzdGlja1BvaW50ZXJQb3MueSw0MCwwLDIqTWF0aC5QSSwhMCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlKCkpOihiLnZqQ2FudmFzQ29udGV4dC5iZWdpblBhdGgoKSxiLnZqQ2FudmFzQ29udGV4dC5maWxsU3R5bGU9XCJ3aGl0ZVwiLGIudmpDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlPVwicmVkXCIsYi52akNhbnZhc0NvbnRleHQubGluZVdpZHRoPTYsYi52akNhbnZhc0NvbnRleHQuYXJjKGMueCxjLnksNDAsMCwyKk1hdGguUEksITApLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZSgpKX0pKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXthLl9kcmF3VmlydHVhbEpveXN0aWNrKCl9KX0sYi5wcm90b3R5cGUucmVsZWFzZUNhbnZhcz1mdW5jdGlvbigpe2IudmpDYW52YXMmJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIudmpDYW52YXMpLGIudmpDYW52YXM9bnVsbCl9LGIuX2dsb2JhbEpveXN0aWNrSW5kZXg9MCxifSgpKTthLlZpcnR1YWxKb3lzdGljaz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dGhpcy5fY291bnQ9MCx0aGlzLl9jb2xsZWN0aW9uPW5ldyBBcnJheX1yZXR1cm4gYS5wcm90b3R5cGUuQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY291bnR9LGEucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhLGIpe3JldHVybiB2b2lkIDAhPXRoaXMuX2NvbGxlY3Rpb25bYV0/dm9pZCAwOih0aGlzLl9jb2xsZWN0aW9uW2FdPWIsKyt0aGlzLl9jb3VudCl9LGEucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT10aGlzLl9jb2xsZWN0aW9uW2FdP3ZvaWQgMDooZGVsZXRlIHRoaXMuX2NvbGxlY3Rpb25bYV0sLS10aGlzLl9jb3VudCl9LGEucHJvdG90eXBlLml0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2NvbGxlY3Rpb25bYV19LGEucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oYSl7dmFyIGI7Zm9yKGIgaW4gdGhpcy5fY29sbGVjdGlvbil0aGlzLl9jb2xsZWN0aW9uLmhhc093blByb3BlcnR5KGIpJiZhKHRoaXMuX2NvbGxlY3Rpb25bYl0pfSxhfSgpO2EuQ29sbGVjdGlvbj1ifShhLlZpcnR1YWxKb3lzdGlja3x8KGEuVmlydHVhbEpveXN0aWNrPXt9KSk7YS5WaXJ0dWFsSm95c3RpY2t9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj17SFJlc29sdXRpb246MTI4MCxWUmVzb2x1dGlvbjo4MDAsSFNjcmVlblNpemU6LjE0OTc1OTk5MyxWU2NyZWVuU2l6ZTouMDkzNTk5OTk3NSxWU2NyZWVuQ2VudGVyOi4wNDY3OTk5OTg3LEV5ZVRvU2NyZWVuRGlzdGFuY2U6LjA0MTAwMDAwMTEsTGVuc1NlcGFyYXRpb25EaXN0YW5jZTouMDYzNTAwMDAyLEludGVycHVwaWxsYXJ5RGlzdGFuY2U6LjA2NDAwMDAwMyxEaXN0b3J0aW9uSzpbMSwuMjE5OTk5OTk5LC4yMzk5OTk5OTUsMF0sQ2hyb21hQWJDb3JyZWN0aW9uOlsuOTk1OTk5OTkyLC0uMDA0MDAwMDAwMTksMS4wMTQwMDAwNiwwXSxQb3N0UHJvY2Vzc1NjYWxlRmFjdG9yOjEuNzE0NjA1NTA3ODA4NDEyLExlbnNDZW50ZXJPZmZzZXQ6LjE1MTk3NjQyMX0sYz1mdW5jdGlvbihjKXtmdW5jdGlvbiBkKGQsZSxmLGcpe2MuY2FsbCh0aGlzLGQsZSxmKSx0aGlzLl93b3JrTWF0cml4PW5ldyBhLk1hdHJpeCx0aGlzLl9hY3R1YWxVcD1uZXcgYS5WZWN0b3IzKDAsMCwwKSx0aGlzLl9hc3BlY3RSYXRpb0FzcGVjdFJhdGlvPWIuSFJlc29sdXRpb24vKDIqYi5WUmVzb2x1dGlvbiksdGhpcy5fYXNwZWN0UmF0aW9Gb3Y9MipNYXRoLmF0YW4oYi5Qb3N0UHJvY2Vzc1NjYWxlRmFjdG9yKmIuVlNjcmVlblNpemUvKDIqYi5FeWVUb1NjcmVlbkRpc3RhbmNlKSk7dmFyIGg9Yi5IU2NyZWVuU2l6ZS80LWIuTGVuc1NlcGFyYXRpb25EaXN0YW5jZS8yLGk9NCpoL2IuSFNjcmVlblNpemU7dGhpcy5faE1hdHJpeD1hLk1hdHJpeC5UcmFuc2xhdGlvbihnP2k6LWksMCwwKSx0aGlzLnZpZXdwb3J0PW5ldyBhLlZpZXdwb3J0KGc/MDouNSwwLC41LDEpLHRoaXMuX3ByZVZpZXdNYXRyaXg9YS5NYXRyaXguVHJhbnNsYXRpb24oZz8uNSpiLkludGVycHVwaWxsYXJ5RGlzdGFuY2U6LS41KmIuSW50ZXJwdXBpbGxhcnlEaXN0YW5jZSwwLDApO25ldyBhLk9jdWx1c0Rpc3RvcnRpb25Db3JyZWN0aW9uUG9zdFByb2Nlc3MoXCJPY3VsdXMgRGlzdG9ydGlvblwiLHRoaXMsIWcsYil9cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLmdldFByb2plY3Rpb25NYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gYS5NYXRyaXguUGVyc3BlY3RpdmVGb3ZMSFRvUmVmKHRoaXMuX2FzcGVjdFJhdGlvRm92LHRoaXMuX2FzcGVjdFJhdGlvQXNwZWN0UmF0aW8sdGhpcy5taW5aLHRoaXMubWF4Wix0aGlzLl93b3JrTWF0cml4KSx0aGlzLl93b3JrTWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5faE1hdHJpeCx0aGlzLl9wcm9qZWN0aW9uTWF0cml4KSx0aGlzLl9wcm9qZWN0aW9uTWF0cml4fSxkLnByb3RvdHlwZS5fZ2V0Vmlld01hdHJpeD1mdW5jdGlvbigpe3JldHVybiBhLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi56LHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZih0aGlzLl9yZWZlcmVuY2VQb2ludCx0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCx0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50KSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYodGhpcy51cFZlY3Rvcix0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCx0aGlzLl9hY3R1YWxVcCksdGhpcy5wb3NpdGlvbi5hZGRUb1JlZih0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50LHRoaXMuX2N1cnJlbnRUYXJnZXQpLGEuTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbix0aGlzLl9jdXJyZW50VGFyZ2V0LHRoaXMuX2FjdHVhbFVwLHRoaXMuX3dvcmtNYXRyaXgpLHRoaXMuX3dvcmtNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9wcmVWaWV3TWF0cml4LHRoaXMuX3ZpZXdNYXRyaXgpLHRoaXMuX3ZpZXdNYXRyaXh9LGR9KGEuRnJlZUNhbWVyYSksZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsZCxlKXthLmNhbGwodGhpcyxiLGQsZSksdGhpcy5fbGVmdENhbWVyYT1uZXcgYyhiK1wiX2xlZnRcIixkLmNsb25lKCksZSwhMCksdGhpcy5fcmlnaHRDYW1lcmE9bmV3IGMoYitcIl9yaWdodFwiLGQuY2xvbmUoKSxlLCExKSx0aGlzLnN1YkNhbWVyYXMucHVzaCh0aGlzLl9sZWZ0Q2FtZXJhKSx0aGlzLnN1YkNhbWVyYXMucHVzaCh0aGlzLl9yaWdodENhbWVyYSksdGhpcy5fZGV2aWNlT3JpZW50YXRpb25IYW5kbGVyPXRoaXMuX29uT3JpZW50YXRpb25FdmVudC5iaW5kKHRoaXMpfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fbGVmdENhbWVyYS5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnBvc2l0aW9uKSx0aGlzLl9yaWdodENhbWVyYS5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnBvc2l0aW9uKSx0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fbGVmdENhbWVyYSksdGhpcy5fdXBkYXRlQ2FtZXJhKHRoaXMuX3JpZ2h0Q2FtZXJhKSxhLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyl9LGIucHJvdG90eXBlLl91cGRhdGVDYW1lcmE9ZnVuY3Rpb24oYSl7YS5taW5aPXRoaXMubWluWixhLm1heFo9dGhpcy5tYXhaLGEucm90YXRpb24ueD10aGlzLnJvdGF0aW9uLngsYS5yb3RhdGlvbi55PXRoaXMucm90YXRpb24ueSxhLnJvdGF0aW9uLno9dGhpcy5yb3RhdGlvbi56fSxiLnByb3RvdHlwZS5fb25PcmllbnRhdGlvbkV2ZW50PWZ1bmN0aW9uKGEpe3ZhciBiPWEuYWxwaGEvMTgwKk1hdGguUEksYz1hLmJldGEvMTgwKk1hdGguUEksZD1hLmdhbW1hLzE4MCpNYXRoLlBJO3JldHVybiB0aGlzLl9vZmZzZXRPcmllbnRhdGlvbj8odGhpcy5yb3RhdGlvbi55Kz1iLXRoaXMuX29mZnNldE9yaWVudGF0aW9uLnlhdyx0aGlzLnJvdGF0aW9uLngrPWMtdGhpcy5fb2Zmc2V0T3JpZW50YXRpb24ucGl0Y2gsdGhpcy5yb3RhdGlvbi56Kz10aGlzLl9vZmZzZXRPcmllbnRhdGlvbi5yb2xsLWQsdGhpcy5fb2Zmc2V0T3JpZW50YXRpb24ueWF3PWIsdGhpcy5fb2Zmc2V0T3JpZW50YXRpb24ucGl0Y2g9Yyx0aGlzLl9vZmZzZXRPcmllbnRhdGlvbi5yb2xsPWQsdm9pZCAwKTp2b2lkKHRoaXMuX29mZnNldE9yaWVudGF0aW9uPXt5YXc6YixwaXRjaDpjLHJvbGw6ZH0pfSxiLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKGIsYyl7YS5wcm90b3R5cGUuYXR0YWNoQ29udHJvbC5jYWxsKHRoaXMsYixjKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5fZGV2aWNlT3JpZW50YXRpb25IYW5kbGVyKX0sYi5wcm90b3R5cGUuZGV0YWNoQ29udHJvbD1mdW5jdGlvbihiKXthLnByb3RvdHlwZS5kZXRhY2hDb250cm9sLmNhbGwodGhpcyxiKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5fZGV2aWNlT3JpZW50YXRpb25IYW5kbGVyKX0sYn0oYS5GcmVlQ2FtZXJhKTthLk9jdWx1c0NhbWVyYT1kfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSl7Yi5jYWxsKHRoaXMsYyxkLGUpLHRoaXMuX2xlZnRqb3lzdGljaz1uZXcgYS5WaXJ0dWFsSm95c3RpY2soITApLHRoaXMuX2xlZnRqb3lzdGljay5zZXRBeGlzRm9yVXBEb3duKDIpLHRoaXMuX2xlZnRqb3lzdGljay5zZXRBeGlzRm9yTGVmdFJpZ2h0KDApLHRoaXMuX2xlZnRqb3lzdGljay5zZXRKb3lzdGlja1NlbnNpYmlsaXR5KC4xNSksdGhpcy5fcmlnaHRqb3lzdGljaz1uZXcgYS5WaXJ0dWFsSm95c3RpY2soITEpLHRoaXMuX3JpZ2h0am95c3RpY2suc2V0QXhpc0ZvclVwRG93bigwKSx0aGlzLl9yaWdodGpveXN0aWNrLnNldEF4aXNGb3JMZWZ0UmlnaHQoMSksdGhpcy5fcmlnaHRqb3lzdGljay5yZXZlcnNlVXBEb3duPSEwLHRoaXMuX3JpZ2h0am95c3RpY2suc2V0Sm95c3RpY2tTZW5zaWJpbGl0eSguMDUpLHRoaXMuX3JpZ2h0am95c3RpY2suc2V0Sm95c3RpY2tDb2xvcihcInllbGxvd1wiKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX2NoZWNrSW5wdXRzPWZ1bmN0aW9uKCl7dmFyIGI9YS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGwodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCwwKSxjPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0aGlzLl9sZWZ0am95c3RpY2suZGVsdGFQb3NpdGlvbixiKTt0aGlzLmNhbWVyYURpcmVjdGlvbj10aGlzLmNhbWVyYURpcmVjdGlvbi5hZGQoYyksdGhpcy5jYW1lcmFSb3RhdGlvbj10aGlzLmNhbWVyYVJvdGF0aW9uLmFkZCh0aGlzLl9yaWdodGpveXN0aWNrLmRlbHRhUG9zaXRpb24pLHRoaXMuX2xlZnRqb3lzdGljay5wcmVzc2VkfHwodGhpcy5fbGVmdGpveXN0aWNrLmRlbHRhUG9zaXRpb249dGhpcy5fbGVmdGpveXN0aWNrLmRlbHRhUG9zaXRpb24uc2NhbGUoLjkpKSx0aGlzLl9yaWdodGpveXN0aWNrLnByZXNzZWR8fCh0aGlzLl9yaWdodGpveXN0aWNrLmRlbHRhUG9zaXRpb249dGhpcy5fcmlnaHRqb3lzdGljay5kZWx0YVBvc2l0aW9uLnNjYWxlKC45KSl9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9sZWZ0am95c3RpY2sucmVsZWFzZUNhbnZhcygpfSxjfShhLkZyZWVDYW1lcmEpO2EuVmlydHVhbEpveXN0aWNrc0NhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmKXtiLmNhbGwodGhpcyxjLGQpLHRoaXMuX3RleHR1cmVzPW5ldyBBcnJheSx0aGlzLl9mbG9hdHM9bmV3IEFycmF5LHRoaXMuX2Zsb2F0c0FycmF5cz17fSx0aGlzLl9jb2xvcnMzPW5ldyBBcnJheSx0aGlzLl9jb2xvcnM0PW5ldyBBcnJheSx0aGlzLl92ZWN0b3JzMj1uZXcgQXJyYXksdGhpcy5fdmVjdG9yczM9bmV3IEFycmF5LHRoaXMuX21hdHJpY2VzPW5ldyBBcnJheSx0aGlzLl9jYWNoZWRXb3JsZFZpZXdNYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuX3NoYWRlclBhdGg9ZSxmLm5lZWRBbHBoYUJsZW5kaW5nPWYubmVlZEFscGhhQmxlbmRpbmd8fCExLGYubmVlZEFscGhhVGVzdGluZz1mLm5lZWRBbHBoYVRlc3Rpbmd8fCExLGYuYXR0cmlidXRlcz1mLmF0dHJpYnV0ZXN8fFtcInBvc2l0aW9uXCIsXCJub3JtYWxcIixcInV2XCJdLGYudW5pZm9ybXM9Zi51bmlmb3Jtc3x8W1wid29ybGRWaWV3UHJvamVjdGlvblwiXSxmLnNhbXBsZXJzPWYuc2FtcGxlcnN8fFtdLHRoaXMuX29wdGlvbnM9Zn1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUubmVlZEFscGhhQmxlbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3B0aW9ucy5uZWVkQWxwaGFCbGVuZGluZ30sYy5wcm90b3R5cGUubmVlZEFscGhhVGVzdGluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcHRpb25zLm5lZWRBbHBoYVRlc3Rpbmd9LGMucHJvdG90eXBlLl9jaGVja1VuaWZvcm09ZnVuY3Rpb24oYSl7LTE9PT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoYSkmJnRoaXMuX29wdGlvbnMudW5pZm9ybXMucHVzaChhKX0sYy5wcm90b3R5cGUuc2V0VGV4dHVyZT1mdW5jdGlvbihhLGIpe3JldHVybi0xPT09dGhpcy5fb3B0aW9ucy5zYW1wbGVycy5pbmRleE9mKGEpJiZ0aGlzLl9vcHRpb25zLnNhbXBsZXJzLnB1c2goYSksdGhpcy5fdGV4dHVyZXNbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRGbG9hdD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9jaGVja1VuaWZvcm0oYSksdGhpcy5fZmxvYXRzW2FdPWIsdGhpc30sYy5wcm90b3R5cGUuc2V0RmxvYXRzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2NoZWNrVW5pZm9ybShhKSx0aGlzLl9mbG9hdHNBcnJheXNbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRDb2xvcjM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX2NvbG9yczNbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRDb2xvcjQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX2NvbG9yczRbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRWZWN0b3IyPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2NoZWNrVW5pZm9ybShhKSx0aGlzLl92ZWN0b3JzMlthXT1iLHRoaXN9LGMucHJvdG90eXBlLnNldFZlY3RvcjM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX3ZlY3RvcnMzW2FdPWIsdGhpc30sYy5wcm90b3R5cGUuc2V0TWF0cml4PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2NoZWNrVW5pZm9ybShhKSx0aGlzLl9tYXRyaWNlc1thXT1iLHRoaXN9LGMucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCk7cmV0dXJuIHRoaXMuX2VmZmVjdD1hLmNyZWF0ZUVmZmVjdCh0aGlzLl9zaGFkZXJQYXRoLHRoaXMuX29wdGlvbnMuYXR0cmlidXRlcyx0aGlzLl9vcHRpb25zLnVuaWZvcm1zLHRoaXMuX29wdGlvbnMuc2FtcGxlcnMsXCJcIixudWxsLHRoaXMub25Db21waWxlZCx0aGlzLm9uRXJyb3IpLHRoaXMuX2VmZmVjdC5pc1JlYWR5KCk/ITA6ITF9LGMucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24oYSl7LTEhPT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoXCJ3b3JsZFwiKSYmdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcIndvcmxkXCIsYSksLTEhPT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoXCJ2aWV3XCIpJiZ0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwidmlld1wiLHRoaXMuZ2V0U2NlbmUoKS5nZXRWaWV3TWF0cml4KCkpLC0xIT09dGhpcy5fb3B0aW9ucy51bmlmb3Jtcy5pbmRleE9mKFwid29ybGRWaWV3XCIpJiYoYS5tdWx0aXBseVRvUmVmKHRoaXMuZ2V0U2NlbmUoKS5nZXRWaWV3TWF0cml4KCksdGhpcy5fY2FjaGVkV29ybGRWaWV3TWF0cml4KSx0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRWaWV3XCIsdGhpcy5fY2FjaGVkV29ybGRWaWV3TWF0cml4KSksLTEhPT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoXCJwcm9qZWN0aW9uXCIpJiZ0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwicHJvamVjdGlvblwiLHRoaXMuZ2V0U2NlbmUoKS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLC0xIT09dGhpcy5fb3B0aW9ucy51bmlmb3Jtcy5pbmRleE9mKFwid29ybGRWaWV3UHJvamVjdGlvblwiKSYmdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcIndvcmxkVmlld1Byb2plY3Rpb25cIixhLm11bHRpcGx5KHRoaXMuZ2V0U2NlbmUoKS5nZXRUcmFuc2Zvcm1NYXRyaXgoKSkpO2Zvcih2YXIgYiBpbiB0aGlzLl90ZXh0dXJlcyl0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShiLHRoaXMuX3RleHR1cmVzW2JdKTtmb3IoYiBpbiB0aGlzLl9mbG9hdHMpdGhpcy5fZWZmZWN0LnNldEZsb2F0KGIsdGhpcy5fZmxvYXRzW2JdKTtmb3IoYiBpbiB0aGlzLl9mbG9hdHNBcnJheXMpdGhpcy5fZWZmZWN0LnNldEFycmF5KGIsdGhpcy5fZmxvYXRzQXJyYXlzW2JdKTtmb3IoYiBpbiB0aGlzLl9jb2xvcnMzKXRoaXMuX2VmZmVjdC5zZXRDb2xvcjMoYix0aGlzLl9jb2xvcnMzW2JdKTtmb3IoYiBpbiB0aGlzLl9jb2xvcnM0KXt2YXIgYz10aGlzLl9jb2xvcnM0W2JdO3RoaXMuX2VmZmVjdC5zZXRGbG9hdDQoYixjLnIsYy5nLGMuYixjLmEpfWZvcihiIGluIHRoaXMuX3ZlY3RvcnMyKXRoaXMuX2VmZmVjdC5zZXRWZWN0b3IyKGIsdGhpcy5fdmVjdG9yczJbYl0pO2ZvcihiIGluIHRoaXMuX3ZlY3RvcnMzKXRoaXMuX2VmZmVjdC5zZXRWZWN0b3IzKGIsdGhpcy5fdmVjdG9yczNbYl0pO2ZvcihiIGluIHRoaXMuX21hdHJpY2VzKXRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoYix0aGlzLl9tYXRyaWNlc1tiXSl9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjIGluIHRoaXMuX3RleHR1cmVzKXRoaXMuX3RleHR1cmVzW2NdLmRpc3Bvc2UoKTt0aGlzLl90ZXh0dXJlcz1bXSxiLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyxhKX0sY30oYS5NYXRlcmlhbCk7YS5TaGFkZXJNYXRlcmlhbD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt9cmV0dXJuIGIucHJvdG90eXBlLnNldD1mdW5jdGlvbihiLGMpe3N3aXRjaChjKXtjYXNlIGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZDp0aGlzLnBvc2l0aW9ucz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZDp0aGlzLm5vcm1hbHM9YjticmVhaztjYXNlIGEuVmVydGV4QnVmZmVyLlVWS2luZDp0aGlzLnV2cz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZDp0aGlzLnV2MnM9YjticmVhaztjYXNlIGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZDp0aGlzLmNvbG9ycz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZDp0aGlzLm1hdHJpY2VzSW5kaWNlcz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZDp0aGlzLm1hdHJpY2VzV2VpZ2h0cz1ifX0sYi5wcm90b3R5cGUuYXBwbHlUb01lc2g9ZnVuY3Rpb24oYSxiKXt0aGlzLl9hcHBseVRvKGEsYil9LGIucHJvdG90eXBlLmFwcGx5VG9HZW9tZXRyeT1mdW5jdGlvbihhLGIpe3RoaXMuX2FwcGx5VG8oYSxiKX0sYi5wcm90b3R5cGUudXBkYXRlTWVzaD1mdW5jdGlvbihhKXt0aGlzLl91cGRhdGUoYSl9LGIucHJvdG90eXBlLnVwZGF0ZUdlb21ldHJ5PWZ1bmN0aW9uKGEpe3RoaXMuX3VwZGF0ZShhKX0sYi5wcm90b3R5cGUuX2FwcGx5VG89ZnVuY3Rpb24oYixjKXt0aGlzLnBvc2l0aW9ucyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLHRoaXMucG9zaXRpb25zLGMpLHRoaXMubm9ybWFscyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCx0aGlzLm5vcm1hbHMsYyksdGhpcy51dnMmJmIuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWS2luZCx0aGlzLnV2cyxjKSx0aGlzLnV2MnMmJmIuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWMktpbmQsdGhpcy51djJzLGMpLHRoaXMuY29sb3JzJiZiLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQsdGhpcy5jb2xvcnMsYyksdGhpcy5tYXRyaWNlc0luZGljZXMmJmIuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQsdGhpcy5tYXRyaWNlc0luZGljZXMsYyksdGhpcy5tYXRyaWNlc1dlaWdodHMmJmIuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQsdGhpcy5tYXRyaWNlc1dlaWdodHMsYyksdGhpcy5pbmRpY2VzJiZiLnNldEluZGljZXModGhpcy5pbmRpY2VzKVxufSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGIsYyxkKXt0aGlzLnBvc2l0aW9ucyYmYi51cGRhdGVWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLHRoaXMucG9zaXRpb25zLGMsZCksdGhpcy5ub3JtYWxzJiZiLnVwZGF0ZVZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLHRoaXMubm9ybWFscyxjLGQpLHRoaXMudXZzJiZiLnVwZGF0ZVZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQsdGhpcy51dnMsYyxkKSx0aGlzLnV2MnMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWMktpbmQsdGhpcy51djJzLGMsZCksdGhpcy5jb2xvcnMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCx0aGlzLmNvbG9ycyxjLGQpLHRoaXMubWF0cmljZXNJbmRpY2VzJiZiLnVwZGF0ZVZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kLHRoaXMubWF0cmljZXNJbmRpY2VzLGMsZCksdGhpcy5tYXRyaWNlc1dlaWdodHMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQsdGhpcy5tYXRyaWNlc1dlaWdodHMsYyxkKSx0aGlzLmluZGljZXMmJmIuc2V0SW5kaWNlcyh0aGlzLmluZGljZXMpfSxiLnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24oYil7dmFyIGM9YS5WZWN0b3IzLlplcm8oKTtpZih0aGlzLnBvc2l0aW9ucylmb3IodmFyIGQ9YS5WZWN0b3IzLlplcm8oKSxlPTA7ZTx0aGlzLnBvc2l0aW9ucy5sZW5ndGg7ZSs9MylhLlZlY3RvcjMuRnJvbUFycmF5VG9SZWYodGhpcy5wb3NpdGlvbnMsZSxkKSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZihkLGIsYyksdGhpcy5wb3NpdGlvbnNbZV09Yy54LHRoaXMucG9zaXRpb25zW2UrMV09Yy55LHRoaXMucG9zaXRpb25zW2UrMl09Yy56O2lmKHRoaXMubm9ybWFscyl7dmFyIGY9YS5WZWN0b3IzLlplcm8oKTtmb3IoZT0wO2U8dGhpcy5ub3JtYWxzLmxlbmd0aDtlKz0zKWEuVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZih0aGlzLm5vcm1hbHMsZSxmKSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYoZixiLGMpLHRoaXMubm9ybWFsc1tlXT1jLngsdGhpcy5ub3JtYWxzW2UrMV09Yy55LHRoaXMubm9ybWFsc1tlKzJdPWMuen19LGIucHJvdG90eXBlLm1lcmdlPWZ1bmN0aW9uKGEpe2lmKGEuaW5kaWNlcyl7dGhpcy5pbmRpY2VzfHwodGhpcy5pbmRpY2VzPVtdKTtmb3IodmFyIGI9dGhpcy5wb3NpdGlvbnM/dGhpcy5wb3NpdGlvbnMubGVuZ3RoLzM6MCxjPTA7YzxhLmluZGljZXMubGVuZ3RoO2MrKyl0aGlzLmluZGljZXMucHVzaChhLmluZGljZXNbY10rYil9aWYoYS5wb3NpdGlvbnMpZm9yKHRoaXMucG9zaXRpb25zfHwodGhpcy5wb3NpdGlvbnM9W10pLGM9MDtjPGEucG9zaXRpb25zLmxlbmd0aDtjKyspdGhpcy5wb3NpdGlvbnMucHVzaChhLnBvc2l0aW9uc1tjXSk7aWYoYS5ub3JtYWxzKWZvcih0aGlzLm5vcm1hbHN8fCh0aGlzLm5vcm1hbHM9W10pLGM9MDtjPGEubm9ybWFscy5sZW5ndGg7YysrKXRoaXMubm9ybWFscy5wdXNoKGEubm9ybWFsc1tjXSk7aWYoYS51dnMpZm9yKHRoaXMudXZzfHwodGhpcy51dnM9W10pLGM9MDtjPGEudXZzLmxlbmd0aDtjKyspdGhpcy51dnMucHVzaChhLnV2c1tjXSk7aWYoYS51djJzKWZvcih0aGlzLnV2MnN8fCh0aGlzLnV2MnM9W10pLGM9MDtjPGEudXYycy5sZW5ndGg7YysrKXRoaXMudXYycy5wdXNoKGEudXYyc1tjXSk7aWYoYS5tYXRyaWNlc0luZGljZXMpZm9yKHRoaXMubWF0cmljZXNJbmRpY2VzfHwodGhpcy5tYXRyaWNlc0luZGljZXM9W10pLGM9MDtjPGEubWF0cmljZXNJbmRpY2VzLmxlbmd0aDtjKyspdGhpcy5tYXRyaWNlc0luZGljZXMucHVzaChhLm1hdHJpY2VzSW5kaWNlc1tjXSk7aWYoYS5tYXRyaWNlc1dlaWdodHMpZm9yKHRoaXMubWF0cmljZXNXZWlnaHRzfHwodGhpcy5tYXRyaWNlc1dlaWdodHM9W10pLGM9MDtjPGEubWF0cmljZXNXZWlnaHRzLmxlbmd0aDtjKyspdGhpcy5tYXRyaWNlc1dlaWdodHMucHVzaChhLm1hdHJpY2VzV2VpZ2h0c1tjXSk7aWYoYS5jb2xvcnMpZm9yKHRoaXMuY29sb3JzfHwodGhpcy5jb2xvcnM9W10pLGM9MDtjPGEuY29sb3JzLmxlbmd0aDtjKyspdGhpcy5jb2xvcnMucHVzaChhLmNvbG9yc1tjXSl9LGIuRXh0cmFjdEZyb21NZXNoPWZ1bmN0aW9uKGEpe3JldHVybiBiLl9FeHRyYWN0RnJvbShhKX0sYi5FeHRyYWN0RnJvbUdlb21ldHJ5PWZ1bmN0aW9uKGEpe3JldHVybiBiLl9FeHRyYWN0RnJvbShhKX0sYi5fRXh0cmFjdEZyb209ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4gYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSYmKGMucG9zaXRpb25zPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpJiYoYy5ub3JtYWxzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVktpbmQpJiYoYy51dnM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkmJihjLnV2MnM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCkmJihjLmNvbG9ycz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSYmKGMubWF0cmljZXNJbmRpY2VzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSYmKGMubWF0cmljZXNXZWlnaHRzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpKSxjLmluZGljZXM9Yi5nZXRJbmRpY2VzKCksY30sYi5DcmVhdGVCb3g9ZnVuY3Rpb24oYil7dmFyIGM9W25ldyBhLlZlY3RvcjMoMCwwLDEpLG5ldyBhLlZlY3RvcjMoMCwwLC0xKSxuZXcgYS5WZWN0b3IzKDEsMCwwKSxuZXcgYS5WZWN0b3IzKC0xLDAsMCksbmV3IGEuVmVjdG9yMygwLDEsMCksbmV3IGEuVmVjdG9yMygwLC0xLDApXSxkPVtdLGU9W10sZj1bXSxnPVtdO2I9Ynx8MTtmb3IodmFyIGg9MDtoPGMubGVuZ3RoO2grKyl7dmFyIGk9Y1toXSxqPW5ldyBhLlZlY3RvcjMoaS55LGkueixpLngpLGs9YS5WZWN0b3IzLkNyb3NzKGksaiksbD1lLmxlbmd0aC8zO2QucHVzaChsKSxkLnB1c2gobCsxKSxkLnB1c2gobCsyKSxkLnB1c2gobCksZC5wdXNoKGwrMiksZC5wdXNoKGwrMyk7dmFyIG09aS5zdWJ0cmFjdChqKS5zdWJ0cmFjdChrKS5zY2FsZShiLzIpO2UucHVzaChtLngsbS55LG0ueiksZi5wdXNoKGkueCxpLnksaS56KSxnLnB1c2goMSwxKSxtPWkuc3VidHJhY3QoaikuYWRkKGspLnNjYWxlKGIvMiksZS5wdXNoKG0ueCxtLnksbS56KSxmLnB1c2goaS54LGkueSxpLnopLGcucHVzaCgwLDEpLG09aS5hZGQoaikuYWRkKGspLnNjYWxlKGIvMiksZS5wdXNoKG0ueCxtLnksbS56KSxmLnB1c2goaS54LGkueSxpLnopLGcucHVzaCgwLDApLG09aS5hZGQoaikuc3VidHJhY3Qoaykuc2NhbGUoYi8yKSxlLnB1c2gobS54LG0ueSxtLnopLGYucHVzaChpLngsaS55LGkueiksZy5wdXNoKDEsMCl9dmFyIG49bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4gbi5pbmRpY2VzPWQsbi5wb3NpdGlvbnM9ZSxuLm5vcm1hbHM9ZixuLnV2cz1nLG59LGIuQ3JlYXRlU3BoZXJlPWZ1bmN0aW9uKGIsYyl7Yj1ifHwzMixjPWN8fDE7Zm9yKHZhciBkPWMvMixlPTIrYixmPTIqZSxnPVtdLGg9W10saT1bXSxqPVtdLGs9MDtlPj1rO2srKyl7Zm9yKHZhciBsPWsvZSxtPWwqTWF0aC5QSSxuPTA7Zj49bjtuKyspe3ZhciBvPW4vZixwPW8qTWF0aC5QSSoyLHE9YS5NYXRyaXguUm90YXRpb25aKC1tKSxyPWEuTWF0cml4LlJvdGF0aW9uWShwKSxzPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhhLlZlY3RvcjMuVXAoKSxxKSx0PWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhzLHIpLHU9dC5zY2FsZShkKSx2PWEuVmVjdG9yMy5Ob3JtYWxpemUodSk7aC5wdXNoKHUueCx1LnksdS56KSxpLnB1c2godi54LHYueSx2LnopLGoucHVzaChsLG8pfWlmKGs+MClmb3IodmFyIHc9aC5sZW5ndGgvMyx4PXctMiooZisxKTt3PngrZisyO3grKylnLnB1c2goeCksZy5wdXNoKHgrMSksZy5wdXNoKHgrZisxKSxnLnB1c2goeCtmKzEpLGcucHVzaCh4KzEpLGcucHVzaCh4K2YrMil9dmFyIHk9bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4geS5pbmRpY2VzPWcseS5wb3NpdGlvbnM9aCx5Lm5vcm1hbHM9aSx5LnV2cz1qLHl9LGIuQ3JlYXRlQ3lsaW5kZXI9ZnVuY3Rpb24oYixjLGQsZSxmKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZiYmKGY9MSk7dmFyIGc9Yy8yLGg9ZC8yLGk9W10saj1bXSxrPVtdLGw9W107Yj1ifHwxLGM9Y3x8LjUsZD1kfHwxLGU9ZXx8MTYsZj1mfHwxLGY9MT5mPzE6Zjtmb3IodmFyIG09ZnVuY3Rpb24oYil7dmFyIGM9MipiKk1hdGguUEkvZSxkPU1hdGguY29zKGMpLGY9TWF0aC5zaW4oYyk7cmV0dXJuIG5ldyBhLlZlY3RvcjMoZCwwLGYpfSxuPWZ1bmN0aW9uKGMpe3ZhciBkPWM/ZzpoO2lmKDAhPWQpe3ZhciBmPWoubGVuZ3RoLzMsaz1uZXcgYS5WZWN0b3IzKDAsYi8yLDApLG49bmV3IGEuVmVjdG9yMiguNSwuNSk7Zm9yKGN8fChrLnNjYWxlSW5QbGFjZSgtMSksbi54PS1uLngpLHI9MDtlPnI7cisrKXt2YXIgbz1tKHIpLHA9by5zY2FsZShkKS5hZGQoaykscT1uZXcgYS5WZWN0b3IyKG8ueCpuLngrLjUsby56Km4ueSsuNSk7ai5wdXNoKHAueCxwLnkscC56KSxsLnB1c2gocS54LHEueSl9Zm9yKHZhciByPTA7ZS0yPnI7cisrKWM/KGkucHVzaChmKSxpLnB1c2goZisocisxKSVlKSxpLnB1c2goZisocisyKSVlKSk6KGkucHVzaChmKSxpLnB1c2goZisocisyKSVlKSxpLnB1c2goZisocisxKSVlKSl9fSxvPW5ldyBhLlZlY3RvcjMoMCwtMSwwKS5zY2FsZShiLzIpLHA9bmV3IGEuVmVjdG9yMygwLDEsMCkuc2NhbGUoYi9mKSxxPWUrMSxyPTA7ZT49cjtyKyspZm9yKHZhciBzLHQ9bShyKSx1PW5ldyBhLlZlY3RvcjIoci9lLDApLHY9aCx3PTA7Zj49dzt3Kyspcz10LnNjYWxlKHYpLHMuYWRkSW5QbGFjZShvLmFkZChwLnNjYWxlKHcpKSksdS55Kz0xL2Ysdis9KGctaCkvZixqLnB1c2gocy54LHMueSxzLnopLGwucHVzaCh1LngsdS55KTtmKz0xO2Zvcih2YXIgdz0wO2YtMT53O3crKylmb3IodmFyIHI9MDtlPj1yO3IrKylpLnB1c2gocipmK3cpLGkucHVzaCgocipmKyh3K2YpKSUocSpmKSksaS5wdXNoKHIqZisodysxKSksaS5wdXNoKHIqZisodysxKSksaS5wdXNoKChyKmYrKHcrZikpJShxKmYpKSxpLnB1c2goKHIqZisodytmKzEpKSUocSpmKSk7bighMCksbighMSksYS5WZXJ0ZXhEYXRhLkNvbXB1dGVOb3JtYWxzKGosaSxrKTt2YXIgeD1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiB4LmluZGljZXM9aSx4LnBvc2l0aW9ucz1qLHgubm9ybWFscz1rLHgudXZzPWwseH0sYi5DcmVhdGVUb3J1cz1mdW5jdGlvbihiLGMsZCl7dmFyIGU9W10sZj1bXSxnPVtdLGg9W107Yj1ifHwxLGM9Y3x8LjUsZD1kfHwxNjtmb3IodmFyIGk9ZCsxLGo9MDtkPj1qO2orKylmb3IodmFyIGs9ai9kLGw9aipNYXRoLlBJKjIvZC1NYXRoLlBJLzIsbT1hLk1hdHJpeC5UcmFuc2xhdGlvbihiLzIsMCwwKS5tdWx0aXBseShhLk1hdHJpeC5Sb3RhdGlvblkobCkpLG49MDtkPj1uO24rKyl7dmFyIG89MS1uL2QscD1uKk1hdGguUEkqMi9kK01hdGguUEkscT1NYXRoLmNvcyhwKSxyPU1hdGguc2luKHApLHM9bmV3IGEuVmVjdG9yMyhxLHIsMCksdD1zLnNjYWxlKGMvMiksdT1uZXcgYS5WZWN0b3IyKGssbyk7dD1hLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXModCxtKSxzPWEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwocyxtKSxmLnB1c2godC54LHQueSx0LnopLGcucHVzaChzLngscy55LHMueiksaC5wdXNoKHUueCx1LnkpO3ZhciB2PShqKzEpJWksdz0obisxKSVpO2UucHVzaChqKmkrbiksZS5wdXNoKGoqaSt3KSxlLnB1c2godippK24pLGUucHVzaChqKmkrdyksZS5wdXNoKHYqaSt3KSxlLnB1c2godippK24pfXZhciB4PW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIHguaW5kaWNlcz1lLHgucG9zaXRpb25zPWYseC5ub3JtYWxzPWcseC51dnM9aCx4fSxiLkNyZWF0ZUxpbmVzPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1bXSxkPVtdLGU9MDtlPGIubGVuZ3RoO2UrKylkLnB1c2goYltlXS54LGJbZV0ueSxiW2VdLnopLGU+MCYmKGMucHVzaChlLTEpLGMucHVzaChlKSk7dmFyIGY9bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4gZi5pbmRpY2VzPWMsZi5wb3NpdGlvbnM9ZCxmfSxiLkNyZWF0ZUdyb3VuZD1mdW5jdGlvbihiLGMsZCl7dmFyIGUsZixnPVtdLGg9W10saT1bXSxqPVtdO2ZvcihiPWJ8fDEsYz1jfHwxLGQ9ZHx8MSxlPTA7ZD49ZTtlKyspZm9yKGY9MDtkPj1mO2YrKyl7dmFyIGs9bmV3IGEuVmVjdG9yMyhmKmIvZC1iLzIsMCwoZC1lKSpjL2QtYy8yKSxsPW5ldyBhLlZlY3RvcjMoMCwxLDApO2gucHVzaChrLngsay55LGsueiksaS5wdXNoKGwueCxsLnksbC56KSxqLnB1c2goZi9kLDEtZS9kKX1mb3IoZT0wO2Q+ZTtlKyspZm9yKGY9MDtkPmY7ZisrKWcucHVzaChmKzErKGUrMSkqKGQrMSkpLGcucHVzaChmKzErZSooZCsxKSksZy5wdXNoKGYrZSooZCsxKSksZy5wdXNoKGYrKGUrMSkqKGQrMSkpLGcucHVzaChmKzErKGUrMSkqKGQrMSkpLGcucHVzaChmK2UqKGQrMSkpO3ZhciBtPW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIG0uaW5kaWNlcz1nLG0ucG9zaXRpb25zPWgsbS5ub3JtYWxzPWksbS51dnM9aixtfSxiLkNyZWF0ZVRpbGVkR3JvdW5kPWZ1bmN0aW9uKGIsYyxkLGUsZixnKXtmdW5jdGlvbiBoKGIsYyxkLGUpe3ZhciBmPW4ubGVuZ3RoLzMsaD1nLncrMTtmb3IoaT0wO2k8Zy5oO2krKylmb3Ioaj0wO2o8Zy53O2orKyl7dmFyIGs9W2YraitpKmgsZisoaisxKStpKmgsZisoaisxKSsoaSsxKSpoLGYraisoaSsxKSpoXTttLnB1c2goa1sxXSksbS5wdXNoKGtbMl0pLG0ucHVzaChrWzNdKSxtLnB1c2goa1swXSksbS5wdXNoKGtbMV0pLG0ucHVzaChrWzNdKX12YXIgbD1hLlZlY3RvcjMuWmVybygpLHE9bmV3IGEuVmVjdG9yMygwLDEsMCk7Zm9yKGk9MDtpPD1nLmg7aSsrKWZvcihsLno9aSooZS1jKS9nLmgrYyxqPTA7ajw9Zy53O2orKylsLng9aiooZC1iKS9nLncrYixsLnk9MCxuLnB1c2gobC54LGwueSxsLnopLG8ucHVzaChxLngscS55LHEueikscC5wdXNoKGovZy53LGkvZy5oKX1cInVuZGVmaW5lZFwiPT10eXBlb2YgZiYmKGY9e3c6MSxoOjF9KSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZyYmKGc9e3c6MSxoOjF9KTt2YXIgaSxqLGssbCxtPVtdLG49W10sbz1bXSxwPVtdO2YuaD1mLnc8MT8xOmYuaCxmLnc9Zi53PDE/MTpmLncsZy53PWcudzwxPzE6Zy53LGcuaD1nLmg8MT8xOmcuaDt2YXIgcT17dzooZC1iKS9mLncsaDooZS1jKS9mLmh9O2ZvcihrPTA7azxmLmg7aysrKWZvcihsPTA7bDxmLnc7bCsrKWgoYitsKnEudyxjK2sqcS5oLGIrKGwrMSkqcS53LGMrKGsrMSkqcS5oKTt2YXIgcj1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiByLmluZGljZXM9bSxyLnBvc2l0aW9ucz1uLHIubm9ybWFscz1vLHIudXZzPXAscn0sYi5DcmVhdGVHcm91bmRGcm9tSGVpZ2h0TWFwPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgsaSl7dmFyIGosayxsPVtdLG09W10sbj1bXSxvPVtdO2ZvcihqPTA7ZD49ajtqKyspZm9yKGs9MDtkPj1rO2srKyl7dmFyIHA9bmV3IGEuVmVjdG9yMyhrKmIvZC1iLzIsMCwoZC1qKSpjL2QtYy8yKSxxPShwLngrYi8yKS9iKihoLTEpfDAscj0oMS0ocC56K2MvMikvYykqKGktMSl8MCxzPTQqKHErcipoKSx0PWdbc10vMjU1LHU9Z1tzKzFdLzI1NSx2PWdbcysyXS8yNTUsdz0uMyp0Ky41OSp1Ky4xMSp2O3AueT1lKyhmLWUpKncsbS5wdXNoKHAueCxwLnkscC56KSxuLnB1c2goMCwwLDApLG8ucHVzaChrL2QsMS1qL2QpfWZvcihqPTA7ZD5qO2orKylmb3Ioaz0wO2Q+aztrKyspbC5wdXNoKGsrMSsoaisxKSooZCsxKSksbC5wdXNoKGsrMStqKihkKzEpKSxsLnB1c2goaytqKihkKzEpKSxsLnB1c2goaysoaisxKSooZCsxKSksbC5wdXNoKGsrMSsoaisxKSooZCsxKSksbC5wdXNoKGsraiooZCsxKSk7YS5WZXJ0ZXhEYXRhLkNvbXB1dGVOb3JtYWxzKG0sbCxuKTt2YXIgeD1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiB4LmluZGljZXM9bCx4LnBvc2l0aW9ucz1tLHgubm9ybWFscz1uLHgudXZzPW8seH0sYi5DcmVhdGVQbGFuZT1mdW5jdGlvbihiKXt2YXIgYz1bXSxkPVtdLGU9W10sZj1bXTtiPWJ8fDE7dmFyIGc9Yi8yO2QucHVzaCgtZywtZywwKSxlLnB1c2goMCwwLC0xKSxmLnB1c2goMCwwKSxkLnB1c2goZywtZywwKSxlLnB1c2goMCwwLC0xKSxmLnB1c2goMSwwKSxkLnB1c2goZyxnLDApLGUucHVzaCgwLDAsLTEpLGYucHVzaCgxLDEpLGQucHVzaCgtZyxnLDApLGUucHVzaCgwLDAsLTEpLGYucHVzaCgwLDEpLGMucHVzaCgwKSxjLnB1c2goMSksYy5wdXNoKDIpLGMucHVzaCgwKSxjLnB1c2goMiksYy5wdXNoKDMpO3ZhciBoPW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIGguaW5kaWNlcz1jLGgucG9zaXRpb25zPWQsaC5ub3JtYWxzPWUsaC51dnM9ZixofSxiLkNyZWF0ZVRvcnVzS25vdD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dmFyIGg9W10saT1bXSxqPVtdLGs9W107Yj1ifHwyLGM9Y3x8LjUsZD1kfHwzMixlPWV8fDMyLGY9Znx8MixnPWd8fDM7Zm9yKHZhciBsPWZ1bmN0aW9uKGMpe3ZhciBkPU1hdGguY29zKGMpLGU9TWF0aC5zaW4oYyksaD1nL2YqYyxpPU1hdGguY29zKGgpLGo9YiooMitpKSouNSpkLGs9YiooMitpKSplKi41LGw9YipNYXRoLnNpbihoKSouNTtyZXR1cm4gbmV3IGEuVmVjdG9yMyhqLGssbCl9LG09MDtkPj1tO20rKyl7dmFyIG49bSVkLG89bi9kKjIqZipNYXRoLlBJLHA9bChvKSxxPWwobysuMDEpLHI9cS5zdWJ0cmFjdChwKSxzPXEuYWRkKHApLHQ9YS5WZWN0b3IzLkNyb3NzKHIscyk7cz1hLlZlY3RvcjMuQ3Jvc3ModCxyKSx0Lm5vcm1hbGl6ZSgpLHMubm9ybWFsaXplKCk7Zm9yKHZhciB1PTA7ZT51O3UrKyl7dmFyIHY9dSVlLHc9di9lKjIqTWF0aC5QSSx4PS1jKk1hdGguY29zKHcpLHk9YypNYXRoLnNpbih3KTtpLnB1c2gocC54K3gqcy54K3kqdC54KSxpLnB1c2gocC55K3gqcy55K3kqdC55KSxpLnB1c2gocC56K3gqcy56K3kqdC56KSxrLnB1c2gobS9kKSxrLnB1c2godS9lKX19Zm9yKG09MDtkPm07bSsrKWZvcih1PTA7ZT51O3UrKyl7dmFyIHo9KHUrMSklZSxBPW0qZSt1LEI9KG0rMSkqZSt1LEM9KG0rMSkqZSt6LEQ9bSplK3o7aC5wdXNoKEQpLGgucHVzaChCKSxoLnB1c2goQSksaC5wdXNoKEQpLGgucHVzaChDKSxoLnB1c2goQil9YS5WZXJ0ZXhEYXRhLkNvbXB1dGVOb3JtYWxzKGksaCxqKTt2YXIgRT1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiBFLmluZGljZXM9aCxFLnBvc2l0aW9ucz1pLEUubm9ybWFscz1qLEUudXZzPWssRX0sYi5Db21wdXRlTm9ybWFscz1mdW5jdGlvbihiLGMsZCl7dmFyIGUsZj1bXSxnPVtdO2ZvcihlPTA7ZTxiLmxlbmd0aDtlKz0zKXt2YXIgaD1uZXcgYS5WZWN0b3IzKGJbZV0sYltlKzFdLGJbZSsyXSk7Zi5wdXNoKGgpLGcucHVzaChbXSl9dmFyIGk9W107Zm9yKGU9MDtlPGMubGVuZ3RoLzM7ZSsrKXt2YXIgaj1jWzMqZV0saz1jWzMqZSsxXSxsPWNbMyplKzJdLG09ZltqXSxuPWZba10sbz1mW2xdLHA9bS5zdWJ0cmFjdChuKSxxPW8uc3VidHJhY3Qobik7aVtlXT1hLlZlY3RvcjMuTm9ybWFsaXplKGEuVmVjdG9yMy5Dcm9zcyhwLHEpKSxnW2pdLnB1c2goZSksZ1trXS5wdXNoKGUpLGdbbF0ucHVzaChlKX1mb3IoZT0wO2U8Zi5sZW5ndGg7ZSsrKXtmb3IodmFyIHI9Z1tlXSxzPWEuVmVjdG9yMy5aZXJvKCksdD0wO3Q8ci5sZW5ndGg7dCsrKXMuYWRkSW5QbGFjZShpW3JbdF1dKTtzPWEuVmVjdG9yMy5Ob3JtYWxpemUocy5zY2FsZSgxL3IubGVuZ3RoKSksZFszKmVdPXMueCxkWzMqZSsxXT1zLnksZFszKmUrMl09cy56fX0sYn0oKTthLlZlcnRleERhdGE9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIsYyl7Yi5fbGVmdENhbWVyYS5pc0ludGVybWVkaWF0ZT0hMCxiLnN1YkNhbWVyYXMucHVzaChiLl9sZWZ0Q2FtZXJhKSxiLnN1YkNhbWVyYXMucHVzaChiLl9yaWdodENhbWVyYSksYi5fbGVmdFRleHR1cmU9bmV3IGEuUGFzc1Bvc3RQcm9jZXNzKGMrXCJfbGVmdFRleHR1cmVcIiwxLGIuX2xlZnRDYW1lcmEpLGIuX2FuYWdseXBoUG9zdFByb2Nlc3M9bmV3IGEuQW5hZ2x5cGhQb3N0UHJvY2VzcyhjK1wiX2FuYWdseXBoXCIsMSxiLl9yaWdodENhbWVyYSksYi5fYW5hZ2x5cGhQb3N0UHJvY2Vzcy5vbkFwcGx5PWZ1bmN0aW9uKGEpe2Euc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2VzcyhcImxlZnRTYW1wbGVyXCIsYi5fbGVmdFRleHR1cmUpfSxiLl91cGRhdGUoKX0sYz1mdW5jdGlvbihjKXtmdW5jdGlvbiBkKGQsZSxmLGcsaCxpLGope2MuY2FsbCh0aGlzLGQsZSxmLGcsaCxqKSx0aGlzLl9leWVTcGFjZT1hLlRvb2xzLlRvUmFkaWFucyhpKSx0aGlzLl9sZWZ0Q2FtZXJhPW5ldyBhLkFyY1JvdGF0ZUNhbWVyYShkK1wiX2xlZnRcIixlLXRoaXMuX2V5ZVNwYWNlLGYsZyxoLGopLHRoaXMuX3JpZ2h0Q2FtZXJhPW5ldyBhLkFyY1JvdGF0ZUNhbWVyYShkK1wiX3JpZ2h0XCIsZSt0aGlzLl9leWVTcGFjZSxmLGcsaCxqKSxiKHRoaXMsZCl9cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fbGVmdENhbWVyYSksdGhpcy5fdXBkYXRlQ2FtZXJhKHRoaXMuX3JpZ2h0Q2FtZXJhKSx0aGlzLl9sZWZ0Q2FtZXJhLmFscGhhPXRoaXMuYWxwaGEtdGhpcy5fZXllU3BhY2UsdGhpcy5fcmlnaHRDYW1lcmEuYWxwaGE9dGhpcy5hbHBoYSt0aGlzLl9leWVTcGFjZSxjLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyl9LGQucHJvdG90eXBlLl91cGRhdGVDYW1lcmE9ZnVuY3Rpb24oYSl7YS5iZXRhPXRoaXMuYmV0YSxhLnJhZGl1cz10aGlzLnJhZGl1cyxhLm1pblo9dGhpcy5taW5aLGEubWF4Wj10aGlzLm1heFosYS5mb3Y9dGhpcy5mb3YsYS50YXJnZXQ9dGhpcy50YXJnZXR9LGR9KGEuQXJjUm90YXRlQ2FtZXJhKTthLkFuYWdseXBoQXJjUm90YXRlQ2FtZXJhPWM7dmFyIGQ9ZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZChkLGUsZixnKXtjLmNhbGwodGhpcyxkLGUsZyksdGhpcy5fZXllU3BhY2U9YS5Ub29scy5Ub1JhZGlhbnMoZiksdGhpcy5fdHJhbnNmb3JtTWF0cml4PW5ldyBhLk1hdHJpeCx0aGlzLl9sZWZ0Q2FtZXJhPW5ldyBhLkZyZWVDYW1lcmEoZCtcIl9sZWZ0XCIsZS5jbG9uZSgpLGcpLHRoaXMuX3JpZ2h0Q2FtZXJhPW5ldyBhLkZyZWVDYW1lcmEoZCtcIl9yaWdodFwiLGUuY2xvbmUoKSxnKSxiKHRoaXMsZCl9cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLl9nZXRTdWJDYW1lcmFQb3NpdGlvbj1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMuZ2V0VGFyZ2V0KCk7YS5NYXRyaXguVHJhbnNsYXRpb24oLWQueCwtZC55LC1kLnopLm11bHRpcGx5VG9SZWYoYS5NYXRyaXguUm90YXRpb25ZKGIpLHRoaXMuX3RyYW5zZm9ybU1hdHJpeCksdGhpcy5fdHJhbnNmb3JtTWF0cml4PXRoaXMuX3RyYW5zZm9ybU1hdHJpeC5tdWx0aXBseShhLk1hdHJpeC5UcmFuc2xhdGlvbihkLngsZC55LGQueikpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMucG9zaXRpb24sdGhpcy5fdHJhbnNmb3JtTWF0cml4LGMpfSxkLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fZ2V0U3ViQ2FtZXJhUG9zaXRpb24oLXRoaXMuX2V5ZVNwYWNlLHRoaXMuX2xlZnRDYW1lcmEucG9zaXRpb24pLHRoaXMuX2dldFN1YkNhbWVyYVBvc2l0aW9uKHRoaXMuX2V5ZVNwYWNlLHRoaXMuX3JpZ2h0Q2FtZXJhLnBvc2l0aW9uKSx0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fbGVmdENhbWVyYSksdGhpcy5fdXBkYXRlQ2FtZXJhKHRoaXMuX3JpZ2h0Q2FtZXJhKSxjLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyl9LGQucHJvdG90eXBlLl91cGRhdGVDYW1lcmE9ZnVuY3Rpb24oYSl7YS5taW5aPXRoaXMubWluWixhLm1heFo9dGhpcy5tYXhaLGEuZm92PXRoaXMuZm92LGEudmlld3BvcnQ9dGhpcy52aWV3cG9ydCxhLnNldFRhcmdldCh0aGlzLmdldFRhcmdldCgpKX0sZH0oYS5GcmVlQ2FtZXJhKTthLkFuYWdseXBoRnJlZUNhbWVyYT1kfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7YS5jYWxsKHRoaXMsYixcImFuYWdseXBoXCIsbnVsbCxbXCJsZWZ0U2FtcGxlclwiXSxjLGQsZSxmLGcpfXJldHVybiBfX2V4dGVuZHMoYixhKSxifShhLlBvc3RQcm9jZXNzKTthLkFuYWdseXBoUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7fXJldHVybiBiLkVuYWJsZUZvcj1mdW5jdGlvbihhKXthLl90YWdzPWEuX3RhZ3N8fHt9LGEuaGFzVGFncz1mdW5jdGlvbigpe3JldHVybiBiLkhhc1RhZ3MoYSl9LGEuYWRkVGFncz1mdW5jdGlvbihjKXtyZXR1cm4gYi5BZGRUYWdzVG8oYSxjKX0sYS5yZW1vdmVUYWdzPWZ1bmN0aW9uKGMpe3JldHVybiBiLlJlbW92ZVRhZ3NGcm9tKGEsYyl9LGEubWF0Y2hlc1RhZ3NRdWVyeT1mdW5jdGlvbihjKXtyZXR1cm4gYi5NYXRjaGVzUXVlcnkoYSxjKX19LGIuRGlzYWJsZUZvcj1mdW5jdGlvbihhKXtkZWxldGUgYS5fdGFncyxkZWxldGUgYS5oYXNUYWdzLGRlbGV0ZSBhLmFkZFRhZ3MsZGVsZXRlIGEucmVtb3ZlVGFncyxkZWxldGUgYS5tYXRjaGVzVGFnc1F1ZXJ5fSxiLkhhc1RhZ3M9ZnVuY3Rpb24oYil7cmV0dXJuIGIuX3RhZ3M/IWEuVG9vbHMuSXNFbXB0eShiLl90YWdzKTohMX0sYi5HZXRUYWdzPWZ1bmN0aW9uKGEpe3JldHVybiBhLl90YWdzP2EuX3RhZ3M6bnVsbH0sYi5BZGRUYWdzVG89ZnVuY3Rpb24oYSxjKXtpZihjKXt2YXIgZD1jLnNwbGl0KFwiIFwiKTtmb3IodmFyIGUgaW4gZCliLl9BZGRUYWdUbyhhLGRbZV0pfX0sYi5fQWRkVGFnVG89ZnVuY3Rpb24oYSxjKXtjPWMudHJpbSgpLFwiXCIhPT1jJiZcInRydWVcIiE9PWMmJlwiZmFsc2VcIiE9PWMmJihjLm1hdGNoKC9bXFxzXS8pfHxjLm1hdGNoKC9eKFshXXwoW3xdfFsmXSl7Mn0pLyl8fChiLkVuYWJsZUZvcihhKSxhLl90YWdzW2NdPSEwKSl9LGIuUmVtb3ZlVGFnc0Zyb209ZnVuY3Rpb24oYSxjKXtpZihiLkhhc1RhZ3MoYSkpe3ZhciBkPWMuc3BsaXQoXCIgXCIpO2Zvcih2YXIgZSBpbiBkKWIuX1JlbW92ZVRhZ0Zyb20oYSxkW2VdKX19LGIuX1JlbW92ZVRhZ0Zyb209ZnVuY3Rpb24oYSxiKXtkZWxldGUgYS5fdGFnc1tiXX0sYi5NYXRjaGVzUXVlcnk9ZnVuY3Rpb24oYyxkKXtyZXR1cm4gdm9pZCAwPT09ZD8hMDpcIlwiPT09ZD9iLkhhc1RhZ3MoYyk6YS5JbnRlcm5hbHMuQW5kT3JOb3RFdmFsdWF0b3IuRXZhbChkLGZ1bmN0aW9uKGEpe3JldHVybiBiLkhhc1RhZ3MoYykmJmMuX3RhZ3NbYV19KX0sYn0oKTthLlRhZ3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe31yZXR1cm4gYS5FdmFsPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGI9Yi5tYXRjaCgvXFwoW15cXChcXCldKlxcKS9nKT9iLnJlcGxhY2UoL1xcKFteXFwoXFwpXSpcXCkvZyxmdW5jdGlvbihiKXtyZXR1cm4gYj1iLnNsaWNlKDEsYi5sZW5ndGgtMSksYS5fSGFuZGxlUGFyZW50aGVzaXNDb250ZW50KGIsYyl9KTphLl9IYW5kbGVQYXJlbnRoZXNpc0NvbnRlbnQoYixjKSxcInRydWVcIj09PWI/ITA6XCJmYWxzZVwiPT09Yj8hMTphLkV2YWwoYixjKX0sYS5fSGFuZGxlUGFyZW50aGVzaXNDb250ZW50PWZ1bmN0aW9uKGIsYyl7Yz1jfHxmdW5jdGlvbihhKXtyZXR1cm5cInRydWVcIj09PWE/ITA6ITF9O3ZhciBkLGU9Yi5zcGxpdChcInx8XCIpO2Zvcih2YXIgZiBpbiBlKXt2YXIgZz1hLl9TaW1wbGlmeU5lZ2F0aW9uKGVbZl0udHJpbSgpKSxoPWcuc3BsaXQoXCImJlwiKTtpZihoLmxlbmd0aD4xKWZvcih2YXIgaT0wO2k8aC5sZW5ndGg7KytpKXt2YXIgaj1hLl9TaW1wbGlmeU5lZ2F0aW9uKGhbaV0udHJpbSgpKTtpZihkPVwidHJ1ZVwiIT09aiYmXCJmYWxzZVwiIT09aj9cIiFcIj09PWpbMF0/IWMoai5zdWJzdHJpbmcoMSkpOmMoaik6XCJ0cnVlXCI9PT1qPyEwOiExLCFkKXtnPVwiZmFsc2VcIjticmVha319aWYoZHx8XCJ0cnVlXCI9PT1nKXtkPSEwO2JyZWFrfWQ9XCJ0cnVlXCIhPT1nJiZcImZhbHNlXCIhPT1nP1wiIVwiPT09Z1swXT8hYyhnLnN1YnN0cmluZygxKSk6YyhnKTpcInRydWVcIj09PWc/ITA6ITF9cmV0dXJuIGQ/XCJ0cnVlXCI6XCJmYWxzZVwifSxhLl9TaW1wbGlmeU5lZ2F0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZSgvXltcXHMhXSsvLGZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZSgvW1xcc10vZyxmdW5jdGlvbigpe3JldHVyblwiXCJ9KSxhLmxlbmd0aCUyP1wiIVwiOlwiXCJ9KSxhPWEudHJpbSgpLFwiIXRydWVcIj09PWE/YT1cImZhbHNlXCI6XCIhZmFsc2VcIj09PWEmJihhPVwidHJ1ZVwiKSxhfSxhfSgpO2EuQW5kT3JOb3RFdmFsdWF0b3I9Yn0oYS5JbnRlcm5hbHN8fChhLkludGVybmFscz17fSkpO2EuSW50ZXJuYWxzfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcpe3RoaXMuX2VuYWJsZWQ9ITAsdGhpcy5fcmVmQ291bnQ9MCx0aGlzLl9uYW1lPWMsdGhpcy5fcmVuZGVyVGV4dHVyZT1uZXcgYS5SZW5kZXJUYXJnZXRUZXh0dXJlKGMsZCxiKSx0aGlzLnNldFJlbmRlckxpc3QoZSksdGhpcy5fcmVuZGVyVGV4dHVyZS5vbkJlZm9yZVJlbmRlcj1mLHRoaXMuX3JlbmRlclRleHR1cmUub25BZnRlclJlbmRlcj1nLHRoaXMuX3NjZW5lPWJ9cmV0dXJuIGIucHJvdG90eXBlLl9pbmNSZWZDb3VudD1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5fcmVmQ291bnQmJnRoaXMuX3NjZW5lLmN1c3RvbVJlbmRlclRhcmdldHMucHVzaCh0aGlzLl9yZW5kZXJUZXh0dXJlKSwrK3RoaXMuX3JlZkNvdW50fSxiLnByb3RvdHlwZS5fZGVjUmVmQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVmQ291bnQtLSx0aGlzLl9yZWZDb3VudDw9MCYmdGhpcy5fc2NlbmUuY3VzdG9tUmVuZGVyVGFyZ2V0cy5zcGxpY2UodGhpcy5fc2NlbmUuY3VzdG9tUmVuZGVyVGFyZ2V0cy5pbmRleE9mKHRoaXMuX3JlbmRlclRleHR1cmUpLDEpLHRoaXMuX3JlZkNvdW50fSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5zZXRSZW5kZXJMaXN0KHRoaXMuX3JlbmRlckxpc3QpfSxiLnByb3RvdHlwZS5zZXRSZW5kZXJMaXN0PWZ1bmN0aW9uKGEpe3RoaXMuX3JlbmRlclRleHR1cmUucmVuZGVyTGlzdD1hfSxiLnByb3RvdHlwZS5nZXRSZW5kZXJUZXh0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmV9LGJ9KCk7YS5Qb3N0UHJvY2Vzc1JlbmRlclBhc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmKXt0aGlzLl9lbmdpbmU9YSx0aGlzLl9uYW1lPWIsdGhpcy5fcG9zdFByb2Nlc3NUeXBlPWMsdGhpcy5fcmF0aW89ZHx8MSx0aGlzLl9zYW1wbGluZ01vZGU9ZXx8bnVsbCx0aGlzLl9zaW5nbGVJbnN0YW5jZT1mfHwhMCx0aGlzLl9jYW1lcmFzPVtdLHRoaXMuX3Bvc3RQcm9jZXNzZXM9W10sdGhpcy5faW5kaWNlc0ZvckNhbWVyYT1bXSx0aGlzLl9yZW5kZXJQYXNzZXM9W10sdGhpcy5fcmVuZGVyRWZmZWN0QXNQYXNzZXM9W10sdGhpcy5wYXJhbWV0ZXJzPWZ1bmN0aW9uKCl7fX1yZXR1cm4gYi5fR2V0SW5zdGFuY2U9ZnVuY3Rpb24oYSxjLGQsZSl7Zm9yKHZhciBmLGcsaD1bXSxpPWIuX0dldFBhcmFtZXRlcnNOYW1lcyhjKSxqPTA7ajxpLmxlbmd0aDtqKyspc3dpdGNoKGlbal0pe2Nhc2VcIm5hbWVcIjpoW2pdPWMudG9TdHJpbmcoKTticmVhaztjYXNlXCJyYXRpb1wiOmhbal09ZDticmVhaztjYXNlXCJjYW1lcmFcIjpoW2pdPW51bGw7YnJlYWs7Y2FzZVwic2FtcGxpbmdNb2RlXCI6aFtqXT1lO2JyZWFrO2Nhc2VcImVuZ2luZVwiOmhbal09YTticmVhaztjYXNlXCJyZXVzYWJsZVwiOmhbal09ITA7YnJlYWs7ZGVmYXVsdDpoW2pdPW51bGx9cmV0dXJuIGY9ZnVuY3Rpb24oKXt9LGYucHJvdG90eXBlPWMucHJvdG90eXBlLGc9bmV3IGYsYy5hcHBseShnLGgpLGd9LGIuX0dldFBhcmFtZXRlcnNOYW1lcz1mdW5jdGlvbihhKXt2YXIgYj0vKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvZ20sYz1hLnRvU3RyaW5nKCkucmVwbGFjZShiLFwiXCIpLGQ9Yy5zbGljZShjLmluZGV4T2YoXCIoXCIpKzEsYy5pbmRleE9mKFwiKVwiKSkubWF0Y2goLyhbXlxccyxdKykvZyk7cmV0dXJuIG51bGw9PT1kJiYoZD1bXSksZH0sYi5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLl9yZW5kZXJQYXNzZXMpdGhpcy5fcmVuZGVyUGFzc2VzW2FdLl91cGRhdGUoKX0sYi5wcm90b3R5cGUuYWRkUGFzcz1mdW5jdGlvbihhKXt0aGlzLl9yZW5kZXJQYXNzZXNbYS5fbmFtZV09YSx0aGlzLl9saW5rUGFyYW1ldGVycygpfSxiLnByb3RvdHlwZS5yZW1vdmVQYXNzPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLl9yZW5kZXJQYXNzZXNbYS5fbmFtZV0sdGhpcy5fbGlua1BhcmFtZXRlcnMoKX0sYi5wcm90b3R5cGUuYWRkUmVuZGVyRWZmZWN0QXNQYXNzPWZ1bmN0aW9uKGEpe3RoaXMuX3JlbmRlckVmZmVjdEFzUGFzc2VzW2EuX25hbWVdPWEsdGhpcy5fbGlua1BhcmFtZXRlcnMoKX0sYi5wcm90b3R5cGUuZ2V0UGFzcz1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gdGhpcy5fcmVuZGVyUGFzc2VzKWlmKGI9PT1hKXJldHVybiB0aGlzLl9yZW5kZXJQYXNzZXNbYV19LGIucHJvdG90eXBlLmVtcHR5UGFzc2VzPWZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyUGFzc2VzLmxlbmd0aD0wLHRoaXMuX2xpbmtQYXJhbWV0ZXJzKCl9LGIucHJvdG90eXBlLl9hdHRhY2hDYW1lcmFzPWZ1bmN0aW9uKGMpe2Zvcih2YXIgZCxlPWEuVG9vbHMuTWFrZUFycmF5KGN8fHRoaXMuX2NhbWVyYXMpLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXSxoPWcubmFtZTtkPXRoaXMuX3NpbmdsZUluc3RhbmNlPzA6aCx0aGlzLl9wb3N0UHJvY2Vzc2VzW2RdPXRoaXMuX3Bvc3RQcm9jZXNzZXNbZF18fGIuX0dldEluc3RhbmNlKHRoaXMuX2VuZ2luZSx0aGlzLl9wb3N0UHJvY2Vzc1R5cGUsdGhpcy5fcmF0aW8sdGhpcy5fc2FtcGxpbmdNb2RlKTt2YXIgaT1nLmF0dGFjaFBvc3RQcm9jZXNzKHRoaXMuX3Bvc3RQcm9jZXNzZXNbZF0pO251bGw9PT10aGlzLl9pbmRpY2VzRm9yQ2FtZXJhW2hdJiYodGhpcy5faW5kaWNlc0ZvckNhbWVyYVtoXT1bXSksdGhpcy5faW5kaWNlc0ZvckNhbWVyYVtoXS5wdXNoKGkpLC0xPT09dGhpcy5fY2FtZXJhcy5pbmRleE9mKGcpJiYodGhpcy5fY2FtZXJhc1toXT1nKTtmb3IodmFyIGogaW4gdGhpcy5fcmVuZGVyUGFzc2VzKXRoaXMuX3JlbmRlclBhc3Nlc1tqXS5faW5jUmVmQ291bnQoKX10aGlzLl9saW5rUGFyYW1ldGVycygpfSxiLnByb3RvdHlwZS5fZGV0YWNoQ2FtZXJhcz1mdW5jdGlvbihiKXtmb3IodmFyIGM9YS5Ub29scy5NYWtlQXJyYXkoYnx8dGhpcy5fY2FtZXJhcyksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9ZS5uYW1lO2UuZGV0YWNoUG9zdFByb2Nlc3ModGhpcy5fcG9zdFByb2Nlc3Nlc1t0aGlzLl9zaW5nbGVJbnN0YW5jZT8wOmZdLHRoaXMuX2luZGljZXNGb3JDYW1lcmFbZl0pO3ZhciBnPXRoaXMuX2NhbWVyYXMuaW5kZXhPZihmKTt0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhLnNwbGljZShnLDEpLHRoaXMuX2NhbWVyYXMuc3BsaWNlKGcsMSk7Zm9yKHZhciBoIGluIHRoaXMuX3JlbmRlclBhc3Nlcyl0aGlzLl9yZW5kZXJQYXNzZXNbaF0uX2RlY1JlZkNvdW50KCl9fSxiLnByb3RvdHlwZS5fZW5hYmxlPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1hLlRvb2xzLk1ha2VBcnJheShifHx0aGlzLl9jYW1lcmFzKSxkPTA7ZDxjLmxlbmd0aDtkKyspe2Zvcih2YXIgZT1jW2RdLGY9ZS5uYW1lLGc9MDtnPHRoaXMuX2luZGljZXNGb3JDYW1lcmFbZl0ubGVuZ3RoO2crKyl2b2lkIDA9PT1lLl9wb3N0UHJvY2Vzc2VzW3RoaXMuX2luZGljZXNGb3JDYW1lcmFbZl1bZ11dJiZiW2RdLmF0dGFjaFBvc3RQcm9jZXNzKHRoaXMuX3Bvc3RQcm9jZXNzZXNbdGhpcy5fc2luZ2xlSW5zdGFuY2U/MDpmXSx0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhW2ZdW2ddKTtmb3IodmFyIGggaW4gdGhpcy5fcmVuZGVyUGFzc2VzKXRoaXMuX3JlbmRlclBhc3Nlc1toXS5faW5jUmVmQ291bnQoKX19LGIucHJvdG90eXBlLl9kaXNhYmxlPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1hLlRvb2xzLk1ha2VBcnJheShifHx0aGlzLl9jYW1lcmFzKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1lLk5hbWU7ZS5kZXRhY2hQb3N0UHJvY2Vzcyh0aGlzLl9wb3N0UHJvY2Vzc2VzW3RoaXMuX3NpbmdsZUluc3RhbmNlPzA6Zl0sdGhpcy5faW5kaWNlc0ZvckNhbWVyYVtmXSk7Zm9yKHZhciBnIGluIHRoaXMuX3JlbmRlclBhc3Nlcyl0aGlzLl9yZW5kZXJQYXNzZXNbZ10uX2RlY1JlZkNvdW50KCl9fSxiLnByb3RvdHlwZS5nZXRQb3N0UHJvY2Vzcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fc2luZ2xlSW5zdGFuY2U/dGhpcy5fcG9zdFByb2Nlc3Nlc1swXTp0aGlzLl9wb3N0UHJvY2Vzc2VzW2EubmFtZV19LGIucHJvdG90eXBlLl9saW5rUGFyYW1ldGVycz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7Zm9yKHZhciBiIGluIHRoaXMuX3Bvc3RQcm9jZXNzZXMpdGhpcy5fcG9zdFByb2Nlc3Nlc1tiXS5vbkFwcGx5PWZ1bmN0aW9uKGIpe2EucGFyYW1ldGVycyhiKSxhLl9saW5rVGV4dHVyZXMoYil9fSxiLnByb3RvdHlwZS5fbGlua1RleHR1cmVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiB0aGlzLl9yZW5kZXJQYXNzZXMpYS5zZXRUZXh0dXJlKGIsdGhpcy5fcmVuZGVyUGFzc2VzW2JdLmdldFJlbmRlclRleHR1cmUoKSk7Zm9yKHZhciBjIGluIHRoaXMuX3JlbmRlckVmZmVjdEFzUGFzc2VzKWEuc2V0VGV4dHVyZUZyb21Qb3N0UHJvY2VzcyhjK1wiU2FtcGxlclwiLHRoaXMuX3JlbmRlckVmZmVjdEFzUGFzc2VzW2NdLmdldFBvc3RQcm9jZXNzKCkpfSxifSgpO2EuUG9zdFByb2Nlc3NSZW5kZXJFZmZlY3Q9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYil7dGhpcy5fZW5naW5lPWEsdGhpcy5fbmFtZT1iLHRoaXMuX3JlbmRlckVmZmVjdHM9W10sdGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzcz1bXSx0aGlzLl9jYW1lcmFzPVtdfXJldHVybiBiLnByb3RvdHlwZS5hZGRFZmZlY3Q9ZnVuY3Rpb24oYSl7dGhpcy5fcmVuZGVyRWZmZWN0c1thLl9uYW1lXT1hfSxiLnByb3RvdHlwZS5fZW5hYmxlRWZmZWN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5fcmVuZGVyRWZmZWN0c1tiXTtkJiZkLmVuYWJsZShhLlRvb2xzLk1ha2VBcnJheShjfHx0aGlzLl9jYW1lcmFzKSl9LGIucHJvdG90eXBlLl9kaXNhYmxlRWZmZWN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5fcmVuZGVyRWZmZWN0c1tiXTtkJiZkLmRpc2FibGUoYS5Ub29scy5NYWtlQXJyYXkoY3x8dGhpcy5fY2FtZXJhcykpfSxiLnByb3RvdHlwZS5fYXR0YWNoQ2FtZXJhcz1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZD1hLlRvb2xzLk1ha2VBcnJheShifHx0aGlzLl9jYW1lcmFzKSxlPVtdLGY9MDtmPGQubGVuZ3RoO2YrKyl7dmFyIGc9ZFtmXSxoPWcubmFtZTstMT09PXRoaXMuX2NhbWVyYXMuaW5kZXhPZihnKT90aGlzLl9jYW1lcmFzW2hdPWc6YyYmZS5wdXNoKGYpfWZvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKWIuc3BsaWNlKGVbZl0sMSk7Zm9yKHZhciBpIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpdGhpcy5fcmVuZGVyRWZmZWN0c1tpXS5fYXR0YWNoQ2FtZXJhcyhkKX0sYi5wcm90b3R5cGUuX2RldGFjaENhbWVyYXM9ZnVuY3Rpb24oYil7dmFyIGM9YS5Ub29scy5NYWtlQXJyYXkoYnx8dGhpcy5fY2FtZXJhcyk7Zm9yKHZhciBkIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpdGhpcy5fcmVuZGVyRWZmZWN0c1tkXS5fZGV0YWNoQ2FtZXJhcyhjKTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyl0aGlzLl9jYW1lcmFzLnNwbGljZSh0aGlzLl9jYW1lcmFzLmluZGV4T2YoY1tlXSksMSl9LGIucHJvdG90eXBlLl9lbmFibGVEaXNwbGF5T25seVBhc3M9ZnVuY3Rpb24oYyxkKXt2YXIgZT1hLlRvb2xzLk1ha2VBcnJheShkfHx0aGlzLl9jYW1lcmFzKSxmPW51bGw7Zm9yKHZhciBnIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpaWYoZj10aGlzLl9yZW5kZXJFZmZlY3RzW2ddLmdldFBhc3MoYyksbnVsbCE9ZilicmVhaztpZihudWxsIT09Zil7Zm9yKHZhciBnIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpdGhpcy5fcmVuZGVyRWZmZWN0c1tnXS5fZGlzYWJsZShlKTtmLl9uYW1lPWIuUEFTU19TQU1QTEVSX05BTUU7Zm9yKHZhciBoPTA7aDxlLmxlbmd0aDtoKyspe3ZhciBpPWVbaF0saj1pLm5hbWU7dGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tqXT10aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2pdfHxuZXcgYS5Qb3N0UHJvY2Vzc1JlbmRlckVmZmVjdCh0aGlzLl9lbmdpbmUsYi5QQVNTX0VGRkVDVF9OQU1FLFwiQkFCWUxPTi5EaXNwbGF5UGFzc1Bvc3RQcm9jZXNzXCIsMSxudWxsLG51bGwpLHRoaXMuX3JlbmRlckVmZmVjdHNGb3JJc29sYXRlZFBhc3Nbal0uZW1wdHlQYXNzZXMoKSx0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2pdLmFkZFBhc3MoZiksdGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tqXS5fYXR0YWNoQ2FtZXJhcyhpKX19fSxiLnByb3RvdHlwZS5fZGlzYWJsZURpc3BsYXlPbmx5UGFzcz1mdW5jdGlvbihjKXtmb3IodmFyIGQ9YS5Ub29scy5NYWtlQXJyYXkoY3x8dGhpcy5fY2FtZXJhcyksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdLGc9Zi5uYW1lO3RoaXMuX3JlbmRlckVmZmVjdHNGb3JJc29sYXRlZFBhc3NbZ109dGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tnXXx8bmV3IGEuUG9zdFByb2Nlc3NSZW5kZXJFZmZlY3QodGhpcy5fZW5naW5lLGIuUEFTU19FRkZFQ1RfTkFNRSxcIkJBQllMT04uRGlzcGxheVBhc3NQb3N0UHJvY2Vzc1wiLDEsbnVsbCxudWxsKSx0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2ddLl9kaXNhYmxlKGYpfWZvcih2YXIgaCBpbiB0aGlzLl9yZW5kZXJFZmZlY3RzKXRoaXMuX3JlbmRlckVmZmVjdHNbaF0uX2VuYWJsZShkKX0sYi5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLl9yZW5kZXJFZmZlY3RzKXRoaXMuX3JlbmRlckVmZmVjdHNbYV0uX3VwZGF0ZSgpO2Zvcih2YXIgYj0wO2I8dGhpcy5fY2FtZXJhcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9jYW1lcmFzW2JdLm5hbWU7dGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tjXSYmdGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tjXS5fdXBkYXRlKCl9fSxiLlBBU1NfRUZGRUNUX05BTUU9XCJwYXNzRWZmZWN0XCIsYi5QQVNTX1NBTVBMRVJfTkFNRT1cInBhc3NTYW1wbGVyXCIsYn0oKTthLlBvc3RQcm9jZXNzUmVuZGVyUGlwZWxpbmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dGhpcy5fcmVuZGVyUGlwZWxpbmVzPVtdfXJldHVybiBhLnByb3RvdHlwZS5hZGRQaXBlbGluZT1mdW5jdGlvbihhKXt0aGlzLl9yZW5kZXJQaXBlbGluZXNbYS5fbmFtZV09YX0sYS5wcm90b3R5cGUuYXR0YWNoQ2FtZXJhc1RvUmVuZGVyUGlwZWxpbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXTtkJiZkLmF0dGFjaENhbWVyYXMoYixjKX0sYS5wcm90b3R5cGUuZGV0YWNoQ2FtZXJhc0Zyb21SZW5kZXJQaXBlbGluZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXTtjJiZjLmRldGFjaENhbWVyYXMoYil9LGEucHJvdG90eXBlLmVuYWJsZUVmZmVjdEluUGlwZWxpbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXTtkJiZkLmVuYWJsZUVmZmVjdChiLGMpfSxhLnByb3RvdHlwZS5kaXNhYmxlRWZmZWN0SW5QaXBlbGluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fcmVuZGVyUGlwZWxpbmVzW2FdO2QmJmQuZGlzYWJsZUVmZmVjdChiLGMpfSxhLnByb3RvdHlwZS5lbmFibGVEaXNwbGF5T25seVBhc3NJblBpcGVsaW5lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLl9yZW5kZXJQaXBlbGluZXNbYV07ZCYmZC5lbmFibGVEaXNwbGF5T25seVBhc3MoYixjKX0sYS5wcm90b3R5cGUuZGlzYWJsZURpc3BsYXlPbmx5UGFzc0luUGlwZWxpbmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLl9yZW5kZXJQaXBlbGluZXNbYV07YyYmYy5kaXNhYmxlRGlzcGxheU9ubHlQYXNzKGIpfSxhLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5fcmVuZGVyUGlwZWxpbmVzKXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXS5fdXBkYXRlKCl9LGF9KCk7YS5Qb3N0UHJvY2Vzc1JlbmRlclBpcGVsaW5lTWFuYWdlcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7YS5jYWxsKHRoaXMsYixcImRpc3BsYXlQYXNzXCIsW1wicGFzc1NhbXBsZXJcIl0sW1wicGFzc1NhbXBsZXJcIl0sYyxkLGUsZixnKX1yZXR1cm4gX19leHRlbmRzKGIsYSksYn0oYS5Qb3N0UHJvY2Vzcyk7YS5EaXNwbGF5UGFzc1Bvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiKXt0aGlzLmZyb250Q29sb3I9bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLmJhY2tDb2xvcj1uZXcgYS5Db2xvcjMoLjEsLjEsLjEpLHRoaXMuc2hvd0JhY2tMaW5lcz0hMCx0aGlzLnJlbmRlckxpc3Q9bmV3IGEuU21hcnRBcnJheSgzMiksdGhpcy5fc2NlbmU9Yix0aGlzLl9jb2xvclNoYWRlcj1uZXcgYS5TaGFkZXJNYXRlcmlhbChcImNvbG9yU2hhZGVyXCIsYixcImNvbG9yXCIse2F0dHJpYnV0ZXM6W1wicG9zaXRpb25cIl0sdW5pZm9ybXM6W1wid29ybGRWaWV3UHJvamVjdGlvblwiLFwiY29sb3JcIl19KTt2YXIgYz10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKSxkPWEuVmVydGV4RGF0YS5DcmVhdGVCb3goMSk7dGhpcy5fdmI9bmV3IGEuVmVydGV4QnVmZmVyKGMsZC5wb3NpdGlvbnMsYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCExKSx0aGlzLl9pYj1jLmNyZWF0ZUluZGV4QnVmZmVyKFswLDEsMSwyLDIsMywzLDAsNCw1LDUsNiw2LDcsNyw0LDAsNywxLDYsMiw1LDMsNF0pfXJldHVybiBiLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMucmVuZGVyTGlzdC5yZXNldCgpfSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtpZigwIT10aGlzLnJlbmRlckxpc3QubGVuZ3RoJiZ0aGlzLl9jb2xvclNoYWRlci5pc1JlYWR5KCkpe3ZhciBiPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2Iuc2V0RGVwdGhXcml0ZSghMSksdGhpcy5fY29sb3JTaGFkZXIuX3ByZUJpbmQoKTtmb3IodmFyIGM9MDtjPHRoaXMucmVuZGVyTGlzdC5sZW5ndGg7YysrKXt2YXIgZD10aGlzLnJlbmRlckxpc3QuZGF0YVtjXSxlPWQubWluaW11bSxmPWQubWF4aW11bSxnPWYuc3VidHJhY3QoZSksaD1lLmFkZChnLnNjYWxlKC41KSksaT1hLk1hdHJpeC5TY2FsaW5nKGcueCxnLnksZy56KS5tdWx0aXBseShhLk1hdHJpeC5UcmFuc2xhdGlvbihoLngsaC55LGgueikpLm11bHRpcGx5KGQuZ2V0V29ybGRNYXRyaXgoKSk7Yi5iaW5kQnVmZmVycyh0aGlzLl92Yi5nZXRCdWZmZXIoKSx0aGlzLl9pYixbM10sMTIsdGhpcy5fY29sb3JTaGFkZXIuZ2V0RWZmZWN0KCkpLHRoaXMuc2hvd0JhY2tMaW5lcyYmKGIuc2V0RGVwdGhGdW5jdGlvblRvR3JlYXRlck9yRXF1YWwoKSx0aGlzLl9jb2xvclNoYWRlci5zZXRDb2xvcjMoXCJjb2xvclwiLHRoaXMuYmFja0NvbG9yKSx0aGlzLl9jb2xvclNoYWRlci5iaW5kKGkpLGIuZHJhdyghMSwwLDI0KSksYi5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzKCksdGhpcy5fY29sb3JTaGFkZXIuc2V0Q29sb3IzKFwiY29sb3JcIix0aGlzLmZyb250Q29sb3IpLHRoaXMuX2NvbG9yU2hhZGVyLmJpbmQoaSksYi5kcmF3KCExLDAsMjQpfXRoaXMuX2NvbG9yU2hhZGVyLnVuYmluZCgpLGIuc2V0RGVwdGhGdW5jdGlvblRvTGVzc09yRXF1YWwoKSxiLnNldERlcHRoV3JpdGUoITApfX0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuX2NvbG9yU2hhZGVyLmRpc3Bvc2UoKSx0aGlzLl92Yi5kaXNwb3NlKCksdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5faWIpfSxifSgpO2EuQm91bmRpbmdCb3hSZW5kZXJlcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXshZnVuY3Rpb24oYil7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7fXJldHVybiBiLkdldFRHQUhlYWRlcj1mdW5jdGlvbihhKXt2YXIgYj0wLGM9e2lkX2xlbmd0aDphW2IrK10sY29sb3JtYXBfdHlwZTphW2IrK10saW1hZ2VfdHlwZTphW2IrK10sY29sb3JtYXBfaW5kZXg6YVtiKytdfGFbYisrXTw8OCxjb2xvcm1hcF9sZW5ndGg6YVtiKytdfGFbYisrXTw8OCxjb2xvcm1hcF9zaXplOmFbYisrXSxvcmlnaW46W2FbYisrXXxhW2IrK108PDgsYVtiKytdfGFbYisrXTw8OF0sd2lkdGg6YVtiKytdfGFbYisrXTw8OCxoZWlnaHQ6YVtiKytdfGFbYisrXTw8OCxwaXhlbF9zaXplOmFbYisrXSxmbGFnczphW2IrK119O3JldHVybiBjfSxiLlVwbG9hZENvbnRlbnQ9ZnVuY3Rpb24oYyxkKXtpZihkLmxlbmd0aDwxOSlyZXR1cm4gdm9pZCBhLlRvb2xzLkVycm9yKFwiVW5hYmxlIHRvIGxvYWQgVEdBIGZpbGUgLSBOb3QgZW5vdWdoIGRhdGEgdG8gY29udGFpbiBoZWFkZXJcIik7dmFyIGU9MTgsZj1iLkdldFRHQUhlYWRlcihkKTtpZihmLmlkX2xlbmd0aCtlPmQubGVuZ3RoKXJldHVybiB2b2lkIGEuVG9vbHMuRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBUR0EgZmlsZSAtIE5vdCBlbm91Z2ggZGF0YVwiKTtlKz1mLmlkX2xlbmd0aDt2YXIgZz0hMSxoPSExLGk9ITEsaj0hMTtzd2l0Y2goZi5pbWFnZV90eXBlKXtjYXNlIGIuX1RZUEVfUkxFX0lOREVYRUQ6Zz0hMDtjYXNlIGIuX1RZUEVfSU5ERVhFRDpoPSEwO2JyZWFrO2Nhc2UgYi5fVFlQRV9STEVfUkdCOmc9ITA7Y2FzZSBiLl9UWVBFX1JHQjppPSEwO2JyZWFrO2Nhc2UgYi5fVFlQRV9STEVfR1JFWTpnPSEwO2Nhc2UgYi5fVFlQRV9HUkVZOmo9ITB9dmFyIGssbCxtPSgxNSZmLmZsYWdzLGYucGl4ZWxfc2l6ZT4+Myksbj1mLndpZHRoKmYuaGVpZ2h0Km07aWYoaCYmKGw9ZC5zdWJhcnJheShlLGUrPWYuY29sb3JtYXBfbGVuZ3RoKihmLmNvbG9ybWFwX3NpemU+PjMpKSksZyl7az1uZXcgVWludDhBcnJheShuKTtmb3IodmFyIG8scCxxLHI9MCxzPW5ldyBVaW50OEFycmF5KG0pO24+ZTspaWYobz1kW2UrK10scD0oMTI3Jm8pKzEsMTI4Jm8pe2ZvcihxPTA7bT5xOysrcSlzW3FdPWRbZSsrXTtmb3IocT0wO3A+cTsrK3Epay5zZXQocyxyK3EqbSk7cis9bSpwfWVsc2V7Zm9yKHAqPW0scT0wO3A+cTsrK3Epa1tyK3FdPWRbZSsrXTtyKz1wfX1lbHNlIGs9ZC5zdWJhcnJheShlLGUrPWg/Zi53aWR0aCpmLmhlaWdodDpuKTt2YXIgdCx1LHYsdyx4LHk7c3dpdGNoKChmLmZsYWdzJmIuX09SSUdJTl9NQVNLKT4+Yi5fT1JJR0lOX1NISUZUKXtkZWZhdWx0OmNhc2UgYi5fT1JJR0lOX1VMOnQ9MCx2PTEseT1mLndpZHRoLHU9MCx3PTEseD1mLmhlaWdodDticmVhaztjYXNlIGIuX09SSUdJTl9CTDp0PTAsdj0xLHk9Zi53aWR0aCx1PWYuaGVpZ2h0LTEsdz0tMSx4PS0xO2JyZWFrO2Nhc2UgYi5fT1JJR0lOX1VSOnQ9Zi53aWR0aC0xLHY9LTEseT0tMSx1PTAsdz0xLHg9Zi5oZWlnaHQ7YnJlYWs7Y2FzZSBiLl9PUklHSU5fQlI6dD1mLndpZHRoLTEsdj0tMSx5PS0xLHU9Zi5oZWlnaHQtMSx3PS0xLHg9LTF9dmFyIHo9XCJfZ2V0SW1hZ2VEYXRhXCIrKGo/XCJHcmV5XCI6XCJcIikrZi5waXhlbF9zaXplK1wiYml0c1wiLEE9Ylt6XShmLGwsayx1LHcseCx0LHYseSk7Yy50ZXhJbWFnZTJEKGMuVEVYVFVSRV8yRCwwLGMuUkdCQSxmLndpZHRoLGYuaGVpZ2h0LDAsYy5SR0JBLGMuVU5TSUdORURfQllURSxBKX0sYi5fZ2V0SW1hZ2VEYXRhOGJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbCxtPWMsbj1iLG89YS53aWR0aCxwPWEuaGVpZ2h0LHE9MCxyPW5ldyBVaW50OEFycmF5KG8qcCo0KTtmb3IobD1kO2whPT1mO2wrPWUpZm9yKGs9ZztrIT09aTtrKz1oLHErKylqPW1bcV0scls0KihrK28qbCkrM109MjU1LHJbNCooaytvKmwpKzJdPW5bMypqKzBdLHJbNCooaytvKmwpKzFdPW5bMypqKzFdLHJbNCooaytvKmwpKzBdPW5bMypqKzJdO3JldHVybiByfSxiLl9nZXRJbWFnZURhdGExNmJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbCxtPWMsbj1hLndpZHRoLG89YS5oZWlnaHQscD0wLHE9bmV3IFVpbnQ4QXJyYXkobipvKjQpO2ZvcihsPWQ7bCE9PWY7bCs9ZSlmb3Ioaz1nO2shPT1pO2srPWgscCs9MilqPW1bcCswXSsobVtwKzFdPDw4KSxxWzQqKGsrbipsKSswXT0oMzE3NDQmaik+PjcscVs0KihrK24qbCkrMV09KDk5MiZqKT4+MixxWzQqKGsrbipsKSsyXT0oMzEmaik+PjMscVs0KihrK24qbCkrM109MzI3Njgmaj8wOjI1NTtyZXR1cm4gcX0sYi5fZ2V0SW1hZ2VEYXRhMjRiaXRzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXt2YXIgaixrLGw9YyxtPWEud2lkdGgsbj1hLmhlaWdodCxvPTAscD1uZXcgVWludDhBcnJheShtKm4qNCk7Zm9yKGs9ZDtrIT09ZjtrKz1lKWZvcihqPWc7aiE9PWk7ais9aCxvKz0zKXBbNCooaittKmspKzNdPTI1NSxwWzQqKGorbSprKSsyXT1sW28rMF0scFs0KihqK20qaykrMV09bFtvKzFdLHBbNCooaittKmspKzBdPWxbbysyXTtyZXR1cm4gcH0sYi5fZ2V0SW1hZ2VEYXRhMzJiaXRzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXt2YXIgaixrLGw9YyxtPWEud2lkdGgsbj1hLmhlaWdodCxvPTAscD1uZXcgVWludDhBcnJheShtKm4qNCk7Zm9yKGs9ZDtrIT09ZjtrKz1lKWZvcihqPWc7aiE9PWk7ais9aCxvKz00KXBbNCooaittKmspKzJdPWxbbyswXSxwWzQqKGorbSprKSsxXT1sW28rMV0scFs0KihqK20qaykrMF09bFtvKzJdLHBbNCooaittKmspKzNdPWxbbyszXTtyZXR1cm4gcH0sYi5fZ2V0SW1hZ2VEYXRhR3JleThiaXRzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXt2YXIgaixrLGwsbT1jLG49YS53aWR0aCxvPWEuaGVpZ2h0LHA9MCxxPW5ldyBVaW50OEFycmF5KG4qbyo0KTtmb3IobD1kO2whPT1mO2wrPWUpZm9yKGs9ZztrIT09aTtrKz1oLHArKylqPW1bcF0scVs0KihrK24qbCkrMF09aixxWzQqKGsrbipsKSsxXT1qLHFbNCooaytuKmwpKzJdPWoscVs0KihrK24qbCkrM109MjU1O3JldHVybiBxfSxiLl9nZXRJbWFnZURhdGFHcmV5MTZiaXRzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXt2YXIgaixrLGw9YyxtPWEud2lkdGgsbj1hLmhlaWdodCxvPTAscD1uZXcgVWludDhBcnJheShtKm4qNCk7Zm9yKGs9ZDtrIT09ZjtrKz1lKWZvcihqPWc7aiE9PWk7ais9aCxvKz0yKXBbNCooaittKmspKzBdPWxbbyswXSxwWzQqKGorbSprKSsxXT1sW28rMF0scFs0KihqK20qaykrMl09bFtvKzBdLHBbNCooaittKmspKzNdPWxbbysxXTtyZXR1cm4gcH0sYi5fVFlQRV9OT19EQVRBPTAsYi5fVFlQRV9JTkRFWEVEPTEsYi5fVFlQRV9SR0I9MixiLl9UWVBFX0dSRVk9MyxiLl9UWVBFX1JMRV9JTkRFWEVEPTksYi5fVFlQRV9STEVfUkdCPTEwLGIuX1RZUEVfUkxFX0dSRVk9MTEsYi5fT1JJR0lOX01BU0s9NDgsYi5fT1JJR0lOX1NISUZUPTQsYi5fT1JJR0lOX0JMPTAsYi5fT1JJR0lOX0JSPTEsYi5fT1JJR0lOX1VMPTIsYi5fT1JJR0lOX1VSPTMsYn0oKTtiLlRHQVRvb2xzPWN9KGEuSW50ZXJuYWxzfHwoYS5JbnRlcm5hbHM9e30pKTthLkludGVybmFsc30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7IWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEuY2hhckNvZGVBdCgwKSsoYS5jaGFyQ29kZUF0KDEpPDw4KSsoYS5jaGFyQ29kZUF0KDIpPDwxNikrKGEuY2hhckNvZGVBdCgzKTw8MjQpfWZ1bmN0aW9uIGQoYSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmEsYT4+OCYyNTUsYT4+MTYmMjU1LGE+PjI0JjI1NSl9dmFyIGU9NTQyMzI3ODc2LGY9MTMxMDcyLGc9NTEyLGg9NCxpPTY0LGo9MTMxMDcyLGs9YyhcIkRYVDFcIiksbD1jKFwiRFhUM1wiKSxtPWMoXCJEWFQ1XCIpLG49MzEsbz0wLHA9MSxxPTIscj0zLHM9NCx0PTcsdT0yMCx2PTIxLHc9MjIseD0yOCx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe31yZXR1cm4gYi5HZXRERFNJbmZvPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBJbnQzMkFycmF5KGEsMCxuKSxjPTE7cmV0dXJuIGJbcV0mZiYmKGM9TWF0aC5tYXgoMSxiW3RdKSkse3dpZHRoOmJbc10saGVpZ2h0OmJbcl0sbWlwbWFwQ291bnQ6Yyxpc0ZvdXJDQzooYlt1XSZoKT09PWgsaXNSR0I6KGJbdV0maSk9PT1pLGlzTHVtaW5hbmNlOihiW3VdJmopPT09aixpc0N1YmU6KGJbeF0mZyk9PT1nfX0sYi5HZXRSR0JBQXJyYXlCdWZmZXI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtmb3IodmFyIGY9bmV3IFVpbnQ4QXJyYXkoZCksZz1uZXcgVWludDhBcnJheShlKSxoPTAsaT1iLTE7aT49MDtpLS0pZm9yKHZhciBqPTA7YT5qO2orKyl7dmFyIGs9Yys0KihqK2kqYSk7ZltoKzJdPWdba10sZltoKzFdPWdbaysxXSxmW2hdPWdbaysyXSxmW2grM109Z1trKzNdLGgrPTR9cmV0dXJuIGZ9LGIuR2V0UkdCQXJyYXlCdWZmZXI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtmb3IodmFyIGY9bmV3IFVpbnQ4QXJyYXkoZCksZz1uZXcgVWludDhBcnJheShlKSxoPTAsaT1iLTE7aT49MDtpLS0pZm9yKHZhciBqPTA7YT5qO2orKyl7dmFyIGs9YyszKihqK2kqYSk7ZltoKzJdPWdba10sZltoKzFdPWdbaysxXSxmW2hdPWdbaysyXSxoKz0zfXJldHVybiBmfSxiLkdldEx1bWluYW5jZUFycmF5QnVmZmVyPWZ1bmN0aW9uKGEsYixjLGQsZSl7Zm9yKHZhciBmPW5ldyBVaW50OEFycmF5KGQpLGc9bmV3IFVpbnQ4QXJyYXkoZSksaD0wLGk9Yi0xO2k+PTA7aS0tKWZvcih2YXIgaj0wO2E+ajtqKyspe3ZhciBrPWMrKGoraSphKTtmW2hdPWdba10saCsrfXJldHVybiBmfSxiLlVwbG9hZEREU0xldmVscz1mdW5jdGlvbihjLGcsaCxpLGosdSl7dmFyIHgseSx6LEEsQixDLEQsRSxGLEcsSD1uZXcgSW50MzJBcnJheShoLDAsbik7aWYoSFtvXSE9ZSlyZXR1cm4gdm9pZCBhLlRvb2xzLkVycm9yKFwiSW52YWxpZCBtYWdpYyBudW1iZXIgaW4gRERTIGhlYWRlclwiKTtpZighaS5pc0ZvdXJDQyYmIWkuaXNSR0ImJiFpLmlzTHVtaW5hbmNlKXJldHVybiB2b2lkIGEuVG9vbHMuRXJyb3IoXCJVbnN1cHBvcnRlZCBmb3JtYXQsIG11c3QgY29udGFpbiBhIEZvdXJDQywgUkdCIG9yIExVTUlOQU5DRSBjb2RlXCIpO2lmKGkuaXNGb3VyQ0Mpc3dpdGNoKHg9SFt2XSl7Y2FzZSBrOnk9OCx6PWcuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7YnJlYWs7Y2FzZSBsOnk9MTYsej1nLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO2JyZWFrO2Nhc2UgbTp5PTE2LHo9Zy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDticmVhaztkZWZhdWx0OnJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTpcIixkKHgpKX1GPTEsSFtxXSZmJiZqIT09ITEmJihGPU1hdGgubWF4KDEsSFt0XSkpO2Zvcih2YXIgST1IW3ddLEo9MDt1Pko7SisrKXt2YXIgSz0xPT11P2MuVEVYVFVSRV8yRDpjLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtKO2ZvcihBPUhbc10sQj1IW3JdLEQ9SFtwXSs0LEc9MDtGPkc7KytHKXtpZihpLmlzUkdCKTI0PT1JPyhDPUEqQiozLEU9Yi5HZXRSR0JBcnJheUJ1ZmZlcihBLEIsRCxDLGgpLGMudGV4SW1hZ2UyRChLLEcsYy5SR0IsQSxCLDAsYy5SR0IsYy5VTlNJR05FRF9CWVRFLEUpKTooQz1BKkIqNCxFPWIuR2V0UkdCQUFycmF5QnVmZmVyKEEsQixELEMsaCksYy50ZXhJbWFnZTJEKEssRyxjLlJHQkEsQSxCLDAsYy5SR0JBLGMuVU5TSUdORURfQllURSxFKSk7ZWxzZSBpZihpLmlzTHVtaW5hbmNlKXt2YXIgTD1jLmdldFBhcmFtZXRlcihjLlVOUEFDS19BTElHTk1FTlQpLE09QSxOPU1hdGguZmxvb3IoKEErTC0xKS9MKSpMO0M9TiooQi0xKStNLEU9Yi5HZXRMdW1pbmFuY2VBcnJheUJ1ZmZlcihBLEIsRCxDLGgpLGMudGV4SW1hZ2UyRChLLEcsYy5MVU1JTkFOQ0UsQSxCLDAsYy5MVU1JTkFOQ0UsYy5VTlNJR05FRF9CWVRFLEUpfWVsc2UgQz1NYXRoLm1heCg0LEEpLzQqTWF0aC5tYXgoNCxCKS80KnksRT1uZXcgVWludDhBcnJheShoLEQsQyksYy5jb21wcmVzc2VkVGV4SW1hZ2UyRChLLEcseixBLEIsMCxFKTtEKz1DLEEqPS41LEIqPS41LEE9TWF0aC5tYXgoMSxBKSxCPU1hdGgubWF4KDEsQil9fX0sYn0oKTtiLkREU1Rvb2xzPXl9KGEuSW50ZXJuYWxzfHwoYS5JbnRlcm5hbHM9e30pKTthLkludGVybmFsc30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGIpe3RoaXMubGVuZ3RoPTAsdGhpcy5fZHVwbGljYXRlSWQ9MCx0aGlzLmRhdGE9bmV3IEFycmF5KGIpLHRoaXMuX2lkPWEuX0dsb2JhbElkKyt9cmV0dXJuIGEucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oYSl7dGhpcy5kYXRhW3RoaXMubGVuZ3RoKytdPWEsdGhpcy5sZW5ndGg+dGhpcy5kYXRhLmxlbmd0aCYmKHRoaXMuZGF0YS5sZW5ndGgqPTIpLGEuX19zbWFydEFycmF5RmxhZ3N8fChhLl9fc21hcnRBcnJheUZsYWdzPXt9KSxhLl9fc21hcnRBcnJheUZsYWdzW3RoaXMuX2lkXT10aGlzLl9kdXBsaWNhdGVJZH0sYS5wcm90b3R5cGUucHVzaE5vRHVwbGljYXRlPWZ1bmN0aW9uKGEpe2EuX19zbWFydEFycmF5RmxhZ3MmJmEuX19zbWFydEFycmF5RmxhZ3NbdGhpcy5faWRdPT09dGhpcy5fZHVwbGljYXRlSWR8fHRoaXMucHVzaChhKVxufSxhLnByb3RvdHlwZS5zb3J0PWZ1bmN0aW9uKGEpe3RoaXMuZGF0YS5zb3J0KGEpfSxhLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMubGVuZ3RoPTAsdGhpcy5fZHVwbGljYXRlSWQrK30sYS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGEpe2lmKDAhPT1hLmxlbmd0aCl7dGhpcy5sZW5ndGgrYS5sZW5ndGg+dGhpcy5kYXRhLmxlbmd0aCYmKHRoaXMuZGF0YS5sZW5ndGg9MioodGhpcy5sZW5ndGgrYS5sZW5ndGgpKTtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLmRhdGFbdGhpcy5sZW5ndGgrK109KGEuZGF0YXx8YSlbYl19fSxhLnByb3RvdHlwZS5jb25jYXRXaXRoTm9EdXBsaWNhdGU9ZnVuY3Rpb24oYSl7aWYoMCE9PWEubGVuZ3RoKXt0aGlzLmxlbmd0aCthLmxlbmd0aD50aGlzLmRhdGEubGVuZ3RoJiYodGhpcy5kYXRhLmxlbmd0aD0yKih0aGlzLmxlbmd0aCthLmxlbmd0aCkpO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz0oYS5kYXRhfHxhKVtiXTt0aGlzLnB1c2hOb0R1cGxpY2F0ZShjKX19fSxhLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZGF0YS5pbmRleE9mKGEpO3JldHVybiBiPj10aGlzLmxlbmd0aD8tMTpifSxhLl9HbG9iYWxJZD0wLGF9KCk7YS5TbWFydEFycmF5PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe3RoaXMuX3JlZ2lzdGVyZWRNZXNoZXM9W10sdGhpcy5fcGh5c2ljc01hdGVyaWFscz1bXSx0aGlzLnVwZGF0ZUJvZHlQb3NpdGlvbj1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tiXTtpZihjLm1lc2g9PT1hfHxjLm1lc2g9PT1hLnBhcmVudCl7dmFyIGQ9Yy5ib2R5LmJvZHk7cmV0dXJuIGQucG9zaXRpb24uc2V0KGEucG9zaXRpb24ueCxhLnBvc2l0aW9uLnosYS5wb3NpdGlvbi55KSxkLnF1YXRlcm5pb24ueD1hLnJvdGF0aW9uUXVhdGVybmlvbi54LGQucXVhdGVybmlvbi56PWEucm90YXRpb25RdWF0ZXJuaW9uLnksZC5xdWF0ZXJuaW9uLnk9YS5yb3RhdGlvblF1YXRlcm5pb24ueix2b2lkKGQucXVhdGVybmlvbi53PS1hLnJvdGF0aW9uUXVhdGVybmlvbi53KX19fX1yZXR1cm4gYi5wcm90b3R5cGUuaW5pdGlhbGl6ZT1mdW5jdGlvbihhKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYSYmKGE9MTApLHRoaXMuX3dvcmxkPW5ldyBDQU5OT04uV29ybGQsdGhpcy5fd29ybGQuYnJvYWRwaGFzZT1uZXcgQ0FOTk9OLk5haXZlQnJvYWRwaGFzZSx0aGlzLl93b3JsZC5zb2x2ZXIuaXRlcmF0aW9ucz1hfSxiLnByb3RvdHlwZS5fY2hlY2tXaXRoRXBzaWxvbj1mdW5jdGlvbihiKXtyZXR1cm4gYjxhLlBoeXNpY3NFbmdpbmUuRXBzaWxvbj9hLlBoeXNpY3NFbmdpbmUuRXBzaWxvbjpifSxiLnByb3RvdHlwZS5ydW5PbmVTdGVwPWZ1bmN0aW9uKGIpe3RoaXMuX3dvcmxkLnN0ZXAoYik7Zm9yKHZhciBjPTA7Yzx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbY107ZC5pc0NoaWxkfHwoZC5tZXNoLnBvc2l0aW9uLng9ZC5ib2R5LnBvc2l0aW9uLngsZC5tZXNoLnBvc2l0aW9uLnk9ZC5ib2R5LnBvc2l0aW9uLnosZC5tZXNoLnBvc2l0aW9uLno9ZC5ib2R5LnBvc2l0aW9uLnksZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbnx8KGQubWVzaC5yb3RhdGlvblF1YXRlcm5pb249bmV3IGEuUXVhdGVybmlvbigwLDAsMCwxKSksZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbi54PWQuYm9keS5xdWF0ZXJuaW9uLngsZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbi55PWQuYm9keS5xdWF0ZXJuaW9uLnosZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbi56PWQuYm9keS5xdWF0ZXJuaW9uLnksZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbi53PS1kLmJvZHkucXVhdGVybmlvbi53KX19LGIucHJvdG90eXBlLnNldEdyYXZpdHk9ZnVuY3Rpb24oYSl7dGhpcy5fd29ybGQuZ3Jhdml0eS5zZXQoYS54LGEueixhLnkpfSxiLnByb3RvdHlwZS5yZWdpc3Rlck1lc2g9ZnVuY3Rpb24oYixjLGQpe3N3aXRjaCh0aGlzLnVucmVnaXN0ZXJNZXNoKGIpLGIuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxjKXtjYXNlIGEuUGh5c2ljc0VuZ2luZS5TcGhlcmVJbXBvc3Rvcjp2YXIgZT1iLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94LGY9ZS5tYXhpbXVtV29ybGQueC1lLm1pbmltdW1Xb3JsZC54LGc9ZS5tYXhpbXVtV29ybGQueS1lLm1pbmltdW1Xb3JsZC55LGg9ZS5tYXhpbXVtV29ybGQuei1lLm1pbmltdW1Xb3JsZC56O3JldHVybiB0aGlzLl9jcmVhdGVTcGhlcmUoTWF0aC5tYXgodGhpcy5fY2hlY2tXaXRoRXBzaWxvbihmKSx0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGcpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oaCkpLzIsYixkKTtjYXNlIGEuUGh5c2ljc0VuZ2luZS5Cb3hJbXBvc3RvcjplPWIuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3g7dmFyIGk9ZS5taW5pbXVtV29ybGQsaj1lLm1heGltdW1Xb3JsZCxrPWouc3VidHJhY3QoaSkuc2NhbGUoLjUpO3JldHVybiB0aGlzLl9jcmVhdGVCb3godGhpcy5fY2hlY2tXaXRoRXBzaWxvbihrLngpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oay55KSx0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGsueiksYixkKTtjYXNlIGEuUGh5c2ljc0VuZ2luZS5QbGFuZUltcG9zdG9yOnJldHVybiB0aGlzLl9jcmVhdGVQbGFuZShiLGQpO2Nhc2UgYS5QaHlzaWNzRW5naW5lLk1lc2hJbXBvc3Rvcjp2YXIgbD1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpLG09Yi5nZXRJbmRpY2VzKCk7cmV0dXJuIHRoaXMuX2NyZWF0ZUNvbnZleFBvbHloZWRyb24obCxtLGIsZCl9cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLl9jcmVhdGVTcGhlcmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW5ldyBDQU5OT04uU3BoZXJlKGEpO3JldHVybiBjP3RoaXMuX2NyZWF0ZVJpZ2lkQm9keUZyb21TaGFwZShkLGIsYy5tYXNzLGMuZnJpY3Rpb24sYy5yZXN0aXR1dGlvbik6ZH0sYi5wcm90b3R5cGUuX2NyZWF0ZUJveD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPW5ldyBDQU5OT04uQm94KG5ldyBDQU5OT04uVmVjMyhhLGMsYikpO3JldHVybiBlP3RoaXMuX2NyZWF0ZVJpZ2lkQm9keUZyb21TaGFwZShmLGQsZS5tYXNzLGUuZnJpY3Rpb24sZS5yZXN0aXR1dGlvbik6Zn0sYi5wcm90b3R5cGUuX2NyZWF0ZVBsYW5lPWZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IENBTk5PTi5QbGFuZTtyZXR1cm4gYj90aGlzLl9jcmVhdGVSaWdpZEJvZHlGcm9tU2hhcGUoYyxhLGIubWFzcyxiLmZyaWN0aW9uLGIucmVzdGl0dXRpb24pOmN9LGIucHJvdG90eXBlLl9jcmVhdGVDb252ZXhQb2x5aGVkcm9uPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPVtdLGc9W107ZC5jb21wdXRlV29ybGRNYXRyaXgoITApO2Zvcih2YXIgaD0wO2g8Yi5sZW5ndGg7aCs9Myl7dmFyIGk9YS5WZWN0b3IzLlplcm8oKTthLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsRnJvbUZsb2F0c1RvUmVmKGJbaF0sYltoKzFdLGJbaCsyXSxkLmdldFdvcmxkTWF0cml4KCksaSksZi5wdXNoKG5ldyBDQU5OT04uVmVjMyhpLngsaS56LGkueSkpfWZvcih2YXIgaj0wO2o8Yy5sZW5ndGg7ais9MylnLnB1c2goW2Nbal0sY1tqKzJdLGNbaisxXV0pO3ZhciBrPW5ldyBDQU5OT04uQ29udmV4UG9seWhlZHJvbihmLGcpO3JldHVybiBlP3RoaXMuX2NyZWF0ZVJpZ2lkQm9keUZyb21TaGFwZShrLGQsZS5tYXNzLGUuZnJpY3Rpb24sZS5yZXN0aXR1dGlvbik6a30sYi5wcm90b3R5cGUuX2FkZE1hdGVyaWFsPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtmb3IoYz0wO2M8dGhpcy5fcGh5c2ljc01hdGVyaWFscy5sZW5ndGg7YysrKWlmKGQ9dGhpcy5fcGh5c2ljc01hdGVyaWFsc1tjXSxkLmZyaWN0aW9uPT09YSYmZC5yZXN0aXR1dGlvbj09PWIpcmV0dXJuIGQ7dmFyIGU9bmV3IENBTk5PTi5NYXRlcmlhbDtmb3IoZS5mcmljdGlvbj1hLGUucmVzdGl0dXRpb249Yix0aGlzLl9waHlzaWNzTWF0ZXJpYWxzLnB1c2goZSksYz0wO2M8dGhpcy5fcGh5c2ljc01hdGVyaWFscy5sZW5ndGg7YysrKXtkPXRoaXMuX3BoeXNpY3NNYXRlcmlhbHNbY107dmFyIGY9bmV3IENBTk5PTi5Db250YWN0TWF0ZXJpYWwoZCxlLGQuZnJpY3Rpb24qZS5mcmljdGlvbixkLnJlc3RpdHV0aW9uKmUucmVzdGl0dXRpb24pO2YuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlMTAsZi5jb250YWN0RXF1YXRpb25SZWd1bGFyaXphdGlvblRpbWU9MTAsdGhpcy5fd29ybGQuYWRkQ29udGFjdE1hdGVyaWFsKGYpfXJldHVybiBlfSxiLnByb3RvdHlwZS5fY3JlYXRlUmlnaWRCb2R5RnJvbVNoYXBlPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGc9bnVsbDtjLnJvdGF0aW9uUXVhdGVybmlvbiYmKGc9Yy5yb3RhdGlvblF1YXRlcm5pb24uY2xvbmUoKSxjLnJvdGF0aW9uUXVhdGVybmlvbj1uZXcgYS5RdWF0ZXJuaW9uKDAsMCwwLDEpKTt2YXIgaD10aGlzLl9hZGRNYXRlcmlhbChlLGYpLGk9bmV3IENBTk5PTi5SaWdpZEJvZHkoZCxiLGgpO3JldHVybiBnJiYoaS5xdWF0ZXJuaW9uLng9Zy54LGkucXVhdGVybmlvbi56PWcueSxpLnF1YXRlcm5pb24ueT1nLnosaS5xdWF0ZXJuaW9uLnc9LWcudyksaS5wb3NpdGlvbi5zZXQoYy5wb3NpdGlvbi54LGMucG9zaXRpb24ueixjLnBvc2l0aW9uLnkpLHRoaXMuX3dvcmxkLmFkZChpKSx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLnB1c2goe21lc2g6Yyxib2R5OmksbWF0ZXJpYWw6aH0pLGl9LGIucHJvdG90eXBlLnJlZ2lzdGVyTWVzaGVzQXNDb21wb3VuZD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1uZXcgQ0FOTk9OLkNvbXBvdW5kLGQ9MDtkPGEubGVuZ3RoO2QrKyl7dmFyIGU9YVtkXS5tZXNoLGY9dGhpcy5yZWdpc3Rlck1lc2goZSxhW2RdLmltcG9zdG9yKTswPT1kP2MuYWRkQ2hpbGQoZixuZXcgQ0FOTk9OLlZlYzMoMCwwLDApKTpjLmFkZENoaWxkKGYsbmV3IENBTk5PTi5WZWMzKGUucG9zaXRpb24ueCxlLnBvc2l0aW9uLnosZS5wb3NpdGlvbi55KSl9dmFyIGc9YVswXS5tZXNoLGg9dGhpcy5fY3JlYXRlUmlnaWRCb2R5RnJvbVNoYXBlKGMsZyxiLm1hc3MsYi5mcmljdGlvbixiLnJlc3RpdHV0aW9uKTtyZXR1cm4gaC5wYXJ0cz1hLGh9LGIucHJvdG90eXBlLl91bmJpbmRCb2R5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2JdO2MuYm9keT09PWEmJihjLmJvZHk9bnVsbCl9fSxiLnByb3RvdHlwZS51bnJlZ2lzdGVyTWVzaD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tiXTtpZihjLm1lc2g9PT1hKXJldHVybiBjLmJvZHkmJih0aGlzLl93b3JsZC5yZW1vdmUoYy5ib2R5KSx0aGlzLl91bmJpbmRCb2R5KGMuYm9keSkpLHZvaWQgdGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5zcGxpY2UoYiwxKX19LGIucHJvdG90eXBlLmFwcGx5SW1wdWxzZT1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPW5ldyBDQU5OT04uVmVjMyhjLngsYy56LGMueSksZT1uZXcgQ0FOTk9OLlZlYzMoYi54LGIueixiLnkpLGY9MDtmPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tmXTtpZihnLm1lc2g9PT1hKXJldHVybiB2b2lkIGcuYm9keS5hcHBseUltcHVsc2UoZSxkKX19LGIucHJvdG90eXBlLmNyZWF0ZUxpbms9ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlPW51bGwsZj1udWxsLGc9MDtnPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2crKyl7dmFyIGg9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tnXTtoLm1lc2g9PT1hP2U9aC5ib2R5OmgubWVzaD09PWImJihmPWguYm9keSl9aWYoIWV8fCFmKXJldHVybiExO3ZhciBpPW5ldyBDQU5OT04uUG9pbnRUb1BvaW50Q29uc3RyYWludChlLG5ldyBDQU5OT04uVmVjMyhjLngsYy56LGMueSksZixuZXcgQ0FOTk9OLlZlYzMoZC54LGQueixkLnkpKTtyZXR1cm4gdGhpcy5fd29ybGQuYWRkQ29uc3RyYWludChpKSwhMH0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcig7dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7KXRoaXMudW5yZWdpc3Rlck1lc2godGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1swXS5tZXNoKX0sYi5wcm90b3R5cGUuaXNTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09d2luZG93LkNBTk5PTn0sYn0oKTthLkNhbm5vbkpTUGx1Z2luPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7dGhpcy5fYWN0aW9uTWFuYWdlcj1hfXJldHVybiBhLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGEucHJvdG90eXBlLl9nZXRQcm9wZXJ0eT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fYWN0aW9uTWFuYWdlci5fZ2V0UHJvcGVydHkoYSl9LGEucHJvdG90eXBlLl9nZXRFZmZlY3RpdmVUYXJnZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fYWN0aW9uTWFuYWdlci5fZ2V0RWZmZWN0aXZlVGFyZ2V0KGEsYil9LGF9KCk7YS5Db25kaXRpb249Yjt2YXIgYz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGMsZCxlLGYsZyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGcmJihnPWIuSXNFcXVhbCksYS5jYWxsKHRoaXMsYyksdGhpcy5wcm9wZXJ0eVBhdGg9ZSx0aGlzLnZhbHVlPWYsdGhpcy5vcGVyYXRvcj1nLHRoaXMuX3RhcmdldD10aGlzLl9nZXRFZmZlY3RpdmVUYXJnZXQoZCx0aGlzLnByb3BlcnR5UGF0aCksdGhpcy5fcHJvcGVydHk9dGhpcy5fZ2V0UHJvcGVydHkodGhpcy5wcm9wZXJ0eVBhdGgpfXJldHVybiBfX2V4dGVuZHMoYixhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIklzRXF1YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0lzRXF1YWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJJc0RpZmZlcmVudFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fSXNEaWZmZXJlbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJJc0dyZWF0ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0lzR3JlYXRlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIklzTGVzc2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9Jc0xlc3Nlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMub3BlcmF0b3Ipe2Nhc2UgYi5Jc0dyZWF0ZXI6cmV0dXJuIHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV0+dGhpcy52YWx1ZTtjYXNlIGIuSXNMZXNzZXI6cmV0dXJuIHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV08dGhpcy52YWx1ZTtjYXNlIGIuSXNFcXVhbDpjYXNlIGIuSXNEaWZmZXJlbnQ6dmFyIGE7cmV0dXJuIGE9dGhpcy52YWx1ZS5lcXVhbHM/dGhpcy52YWx1ZS5lcXVhbHModGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XSk6dGhpcy52YWx1ZT09PXRoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV0sdGhpcy5vcGVyYXRvcj09PWIuSXNFcXVhbD9hOiFhfXJldHVybiExfSxiLl9Jc0VxdWFsPTAsYi5fSXNEaWZmZXJlbnQ9MSxiLl9Jc0dyZWF0ZXI9MixiLl9Jc0xlc3Nlcj0zLGJ9KGIpO2EuVmFsdWVDb25kaXRpb249Yzt2YXIgZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyl7YS5jYWxsKHRoaXMsYiksdGhpcy5wcmVkaWNhdGU9Y31yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByZWRpY2F0ZSgpfSxifShiKTthLlByZWRpY2F0ZUNvbmRpdGlvbj1kO3ZhciBlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQpe2EuY2FsbCh0aGlzLGIpLHRoaXMudmFsdWU9ZCx0aGlzLl90YXJnZXQ9Y31yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90YXJnZXQuc3RhdGU9PT10aGlzLnZhbHVlfSxifShiKTthLlN0YXRlQ29uZGl0aW9uPWV9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3RoaXMudHJpZ2dlck9wdGlvbnM9YSxhLnBhcmFtZXRlcj8odGhpcy50cmlnZ2VyPWEudHJpZ2dlcix0aGlzLl90cmlnZ2VyUGFyYW1ldGVyPWEucGFyYW1ldGVyKTp0aGlzLnRyaWdnZXI9YSx0aGlzLl9uZXh0QWN0aXZlQWN0aW9uPXRoaXMsdGhpcy5fY29uZGl0aW9uPWJ9cmV0dXJuIGEucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5nZXRUcmlnZ2VyUGFyYW1ldGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyaWdnZXJQYXJhbWV0ZXJ9LGEucHJvdG90eXBlLl9leGVjdXRlQ3VycmVudD1mdW5jdGlvbihhKXtpZih0aGlzLl9jb25kaXRpb24pe3ZhciBiPXRoaXMuX2FjdGlvbk1hbmFnZXIuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpO2lmKHRoaXMuX2NvbmRpdGlvbi5fZXZhbHVhdGlvbklkPT09Yil7aWYoIXRoaXMuX2NvbmRpdGlvbi5fY3VycmVudFJlc3VsdClyZXR1cm59ZWxzZXtpZih0aGlzLl9jb25kaXRpb24uX2V2YWx1YXRpb25JZD1iLCF0aGlzLl9jb25kaXRpb24uaXNWYWxpZCgpKXJldHVybiB2b2lkKHRoaXMuX2NvbmRpdGlvbi5fY3VycmVudFJlc3VsdD0hMSk7dGhpcy5fY29uZGl0aW9uLl9jdXJyZW50UmVzdWx0PSEwfX10aGlzLl9uZXh0QWN0aXZlQWN0aW9uLmV4ZWN1dGUoYSksdGhpcy5fbmV4dEFjdGl2ZUFjdGlvbj10aGlzLl9uZXh0QWN0aXZlQWN0aW9uLl9jaGlsZD90aGlzLl9uZXh0QWN0aXZlQWN0aW9uLl9jaGlsZDp0aGlzfSxhLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9jaGlsZD1hLGEuX2FjdGlvbk1hbmFnZXI9dGhpcy5fYWN0aW9uTWFuYWdlcixhLl9wcmVwYXJlKCksYX0sYS5wcm90b3R5cGUuX2dldFByb3BlcnR5PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9hY3Rpb25NYW5hZ2VyLl9nZXRQcm9wZXJ0eShhKX0sYS5wcm90b3R5cGUuX2dldEVmZmVjdGl2ZVRhcmdldD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9hY3Rpb25NYW5hZ2VyLl9nZXRFZmZlY3RpdmVUYXJnZXQoYSxiKX0sYX0oKTthLkFjdGlvbj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMsZCxlKXt0aGlzLnNvdXJjZT1hLHRoaXMucG9pbnRlclg9Yix0aGlzLnBvaW50ZXJZPWMsdGhpcy5tZXNoVW5kZXJQb2ludGVyPWQsdGhpcy5zb3VyY2VFdmVudD1lfXJldHVybiBhLkNyZWF0ZU5ldz1mdW5jdGlvbihiKXt2YXIgYz1iLmdldFNjZW5lKCk7cmV0dXJuIG5ldyBhKGIsYy5wb2ludGVyWCxjLnBvaW50ZXJZLGMubWVzaFVuZGVyUG9pbnRlcil9LGEuQ3JlYXRlTmV3RnJvbVNjZW5lPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIG5ldyBhKG51bGwsYi5wb2ludGVyWCxiLnBvaW50ZXJZLGIubWVzaFVuZGVyUG9pbnRlcixjKX0sYX0oKTthLkFjdGlvbkV2ZW50PWI7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3RoaXMuYWN0aW9ucz1uZXcgQXJyYXksdGhpcy5fc2NlbmU9YSxhLl9hY3Rpb25NYW5hZ2Vycy5wdXNoKHRoaXMpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk5vdGhpbmdUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9Ob3RoaW5nVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uUGlja1RyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uUGlja1RyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPbkxlZnRQaWNrVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25MZWZ0UGlja1RyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPblJpZ2h0UGlja1RyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uUmlnaHRQaWNrVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uQ2VudGVyUGlja1RyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uQ2VudGVyUGlja1RyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPblBvaW50ZXJPdmVyVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25Qb2ludGVyT3ZlclRyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPblBvaW50ZXJPdXRUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PblBvaW50ZXJPdXRUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25FdmVyeUZyYW1lVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25FdmVyeUZyYW1lVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PbkludGVyc2VjdGlvbkVudGVyVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uSW50ZXJzZWN0aW9uRXhpdFRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uSW50ZXJzZWN0aW9uRXhpdFRyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPbktleURvd25UcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PbktleURvd25UcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25LZXlVcFRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uS2V5VXBUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9zY2VuZS5fYWN0aW9uTWFuYWdlcnMuaW5kZXhPZih0aGlzKTthPi0xJiZ0aGlzLl9zY2VuZS5fYWN0aW9uTWFuYWdlcnMuc3BsaWNlKGEsMSl9LGIucHJvdG90eXBlLmdldFNjZW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjZW5lfSxiLnByb3RvdHlwZS5oYXNTcGVjaWZpY1RyaWdnZXJzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5hY3Rpb25zLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYWN0aW9uc1tiXTtpZihhLmluZGV4T2YoYy50cmlnZ2VyKT4tMSlyZXR1cm4hMH1yZXR1cm4hMX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiaGFzUG9pbnRlclRyaWdnZXJzXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5hY3Rpb25zLmxlbmd0aDthKyspe3ZhciBjPXRoaXMuYWN0aW9uc1thXTtpZihjLnRyaWdnZXI+PWIuX09uUGlja1RyaWdnZXImJmMudHJpZ2dlcjw9Yi5fT25Qb2ludGVyT3V0VHJpZ2dlcilyZXR1cm4hMH1yZXR1cm4hMX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJoYXNQaWNrVHJpZ2dlcnNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLmFjdGlvbnMubGVuZ3RoO2ErKyl7dmFyIGM9dGhpcy5hY3Rpb25zW2FdO2lmKGMudHJpZ2dlcj49Yi5fT25QaWNrVHJpZ2dlciYmYy50cmlnZ2VyPD1iLl9PbkNlbnRlclBpY2tUcmlnZ2VyKXJldHVybiEwfXJldHVybiExfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLnJlZ2lzdGVyQWN0aW9uPWZ1bmN0aW9uKGMpe3JldHVybiBjLnRyaWdnZXI9PT1iLk9uRXZlcnlGcmFtZVRyaWdnZXImJnRoaXMuZ2V0U2NlbmUoKS5hY3Rpb25NYW5hZ2VyIT09dGhpcz8oYS5Ub29scy5XYXJuKFwiT25FdmVyeUZyYW1lVHJpZ2dlciBjYW4gb25seSBiZSB1c2VkIHdpdGggc2NlbmUuYWN0aW9uTWFuYWdlclwiKSxudWxsKToodGhpcy5hY3Rpb25zLnB1c2goYyksYy5fYWN0aW9uTWFuYWdlcj10aGlzLGMuX3ByZXBhcmUoKSxjKX0sYi5wcm90b3R5cGUucHJvY2Vzc1RyaWdnZXI9ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGQ9MDtkPHRoaXMuYWN0aW9ucy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLmFjdGlvbnNbZF07aWYoZS50cmlnZ2VyPT09YSl7aWYoYT09Yi5PbktleVVwVHJpZ2dlcnx8YT09Yi5PbktleURvd25UcmlnZ2VyKXt2YXIgZj1lLmdldFRyaWdnZXJQYXJhbWV0ZXIoKTtpZihmJiZjLnNvdXJjZUV2ZW50LmtleSE9PWYpY29udGludWV9ZS5fZXhlY3V0ZUN1cnJlbnQoYyl9fX0sYi5wcm90b3R5cGUuX2dldEVmZmVjdGl2ZVRhcmdldD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLnNwbGl0KFwiLlwiKSxkPTA7ZDxjLmxlbmd0aC0xO2QrKylhPWFbY1tkXV07cmV0dXJuIGF9LGIucHJvdG90eXBlLl9nZXRQcm9wZXJ0eT1mdW5jdGlvbihhKXt2YXIgYj1hLnNwbGl0KFwiLlwiKTtyZXR1cm4gYltiLmxlbmd0aC0xXX0sYi5fTm90aGluZ1RyaWdnZXI9MCxiLl9PblBpY2tUcmlnZ2VyPTEsYi5fT25MZWZ0UGlja1RyaWdnZXI9MixiLl9PblJpZ2h0UGlja1RyaWdnZXI9MyxiLl9PbkNlbnRlclBpY2tUcmlnZ2VyPTQsYi5fT25Qb2ludGVyT3ZlclRyaWdnZXI9NSxiLl9PblBvaW50ZXJPdXRUcmlnZ2VyPTYsYi5fT25FdmVyeUZyYW1lVHJpZ2dlcj03LGIuX09uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyPTgsYi5fT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlcj05LGIuX09uS2V5RG93blRyaWdnZXI9MTAsYi5fT25LZXlVcFRyaWdnZXI9MTEsYn0oKTthLkFjdGlvbk1hbmFnZXI9Y30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcsaCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGYmJihmPTFlMyksYi5jYWxsKHRoaXMsYSxnKSx0aGlzLnByb3BlcnR5UGF0aD1kLHRoaXMudmFsdWU9ZSx0aGlzLmR1cmF0aW9uPWYsdGhpcy5zdG9wT3RoZXJBbmltYXRpb25zPWgsdGhpcy5fdGFyZ2V0PWN9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0PXRoaXMuX2dldEVmZmVjdGl2ZVRhcmdldCh0aGlzLl90YXJnZXQsdGhpcy5wcm9wZXJ0eVBhdGgpLHRoaXMuX3Byb3BlcnR5PXRoaXMuX2dldFByb3BlcnR5KHRoaXMucHJvcGVydHlQYXRoKX0sYy5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBiLGM9dGhpcy5fYWN0aW9uTWFuYWdlci5nZXRTY2VuZSgpLGQ9W3tmcmFtZTowLHZhbHVlOnRoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV19LHtmcmFtZToxMDAsdmFsdWU6dGhpcy52YWx1ZX1dO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLnZhbHVlKWI9YS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9GTE9BVDtlbHNlIGlmKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBhLkNvbG9yMyliPWEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfQ09MT1IzO2Vsc2UgaWYodGhpcy52YWx1ZSBpbnN0YW5jZW9mIGEuVmVjdG9yMyliPWEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfVkVDVE9SMztlbHNlIGlmKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBhLk1hdHJpeCliPWEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfTUFUUklYO2Vsc2V7aWYoISh0aGlzLnZhbHVlIGluc3RhbmNlb2YgYS5RdWF0ZXJuaW9uKSlyZXR1cm4gdm9pZCBhLlRvb2xzLldhcm4oXCJJbnRlcnBvbGF0ZVZhbHVlQWN0aW9uOiBVbnN1cHBvcnRlZCB0eXBlIChcIit0eXBlb2YgdGhpcy52YWx1ZStcIilcIik7Yj1hLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX1FVQVRFUk5JT059dmFyIGU9bmV3IGEuQW5pbWF0aW9uKFwiSW50ZXJwb2xhdGVWYWx1ZUFjdGlvblwiLHRoaXMuX3Byb3BlcnR5LDEwMCooMWUzL3RoaXMuZHVyYXRpb24pLGIsYS5BbmltYXRpb24uQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQpO2Uuc2V0S2V5cyhkKSx0aGlzLnN0b3BPdGhlckFuaW1hdGlvbnMmJmMuc3RvcEFuaW1hdGlvbih0aGlzLl90YXJnZXQpLGMuYmVnaW5EaXJlY3RBbmltYXRpb24odGhpcy5fdGFyZ2V0LFtlXSwwLDEwMCl9LGN9KGEuQWN0aW9uKTthLkludGVycG9sYXRlVmFsdWVBY3Rpb249Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSl7YS5jYWxsKHRoaXMsYixlKSx0aGlzLnByb3BlcnR5UGF0aD1kLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5fcHJlcGFyZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldD10aGlzLl9nZXRFZmZlY3RpdmVUYXJnZXQodGhpcy5fdGFyZ2V0LHRoaXMucHJvcGVydHlQYXRoKSx0aGlzLl9wcm9wZXJ0eT10aGlzLl9nZXRQcm9wZXJ0eSh0aGlzLnByb3BlcnR5UGF0aCl9LGIucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldPSF0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldfSxifShhLkFjdGlvbik7YS5Td2l0Y2hCb29sZWFuQWN0aW9uPWI7dmFyIGM9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlKXthLmNhbGwodGhpcyxiLGUpLHRoaXMudmFsdWU9ZCx0aGlzLl90YXJnZXQ9Y31yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldC5zdGF0ZT10aGlzLnZhbHVlfSxifShhLkFjdGlvbik7YS5TZXRTdGF0ZUFjdGlvbj1jO3ZhciBkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmKXthLmNhbGwodGhpcyxiLGYpLHRoaXMucHJvcGVydHlQYXRoPWQsdGhpcy52YWx1ZT1lLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5fcHJlcGFyZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldD10aGlzLl9nZXRFZmZlY3RpdmVUYXJnZXQodGhpcy5fdGFyZ2V0LHRoaXMucHJvcGVydHlQYXRoKSx0aGlzLl9wcm9wZXJ0eT10aGlzLl9nZXRQcm9wZXJ0eSh0aGlzLnByb3BlcnR5UGF0aCl9LGIucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldPXRoaXMudmFsdWV9LGJ9KGEuQWN0aW9uKTthLlNldFZhbHVlQWN0aW9uPWQ7dmFyIGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYpe2IuY2FsbCh0aGlzLGEsZiksdGhpcy5wcm9wZXJ0eVBhdGg9ZCx0aGlzLnZhbHVlPWUsdGhpcy5fdGFyZ2V0PWN9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0PXRoaXMuX2dldEVmZmVjdGl2ZVRhcmdldCh0aGlzLl90YXJnZXQsdGhpcy5wcm9wZXJ0eVBhdGgpLHRoaXMuX3Byb3BlcnR5PXRoaXMuX2dldFByb3BlcnR5KHRoaXMucHJvcGVydHlQYXRoKSxcIm51bWJlclwiIT10eXBlb2YgdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XSYmYS5Ub29scy5XYXJuKFwiV2FybmluZzogSW5jcmVtZW50VmFsdWVBY3Rpb24gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG51bWJlciB2YWx1ZXNcIil9LGMucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldKz10aGlzLnZhbHVlfSxjfShhLkFjdGlvbik7YS5JbmNyZW1lbnRWYWx1ZUFjdGlvbj1lO3ZhciBmPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcpe2EuY2FsbCh0aGlzLGIsZyksdGhpcy5mcm9tPWQsdGhpcy50bz1lLHRoaXMubG9vcD1mLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5fcHJlcGFyZT1mdW5jdGlvbigpe30sYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX2FjdGlvbk1hbmFnZXIuZ2V0U2NlbmUoKTthLmJlZ2luQW5pbWF0aW9uKHRoaXMuX3RhcmdldCx0aGlzLmZyb20sdGhpcy50byx0aGlzLmxvb3ApfSxifShhLkFjdGlvbik7YS5QbGF5QW5pbWF0aW9uQWN0aW9uPWY7dmFyIGc9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCl7YS5jYWxsKHRoaXMsYixkKSx0aGlzLl90YXJnZXQ9Y31yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt9LGIucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9hY3Rpb25NYW5hZ2VyLmdldFNjZW5lKCk7YS5zdG9wQW5pbWF0aW9uKHRoaXMuX3RhcmdldCl9LGJ9KGEuQWN0aW9uKTthLlN0b3BBbmltYXRpb25BY3Rpb249Zzt2YXIgaD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPWEuQWN0aW9uTWFuYWdlci5Ob3RoaW5nVHJpZ2dlciksYi5jYWxsKHRoaXMsYyxkKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe30sY30oYS5BY3Rpb24pO2EuRG9Ob3RoaW5nQWN0aW9uPWg7dmFyIGk9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCl7YS5jYWxsKHRoaXMsYixkKSx0aGlzLmNoaWxkcmVuPWN9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLmNoaWxkcmVuLmxlbmd0aDthKyspdGhpcy5jaGlsZHJlblthXS5fYWN0aW9uTWFuYWdlcj10aGlzLl9hY3Rpb25NYW5hZ2VyLHRoaXMuY2hpbGRyZW5bYV0uX3ByZXBhcmUoKX0sYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO2IrKyl0aGlzLmNoaWxkcmVuW2JdLmV4ZWN1dGUoYSl9LGJ9KGEuQWN0aW9uKTthLkNvbWJpbmVBY3Rpb249aTt2YXIgaj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkKXthLmNhbGwodGhpcyxiLGQpLHRoaXMuZnVuYz1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe3RoaXMuZnVuYyhhKX0sYn0oYS5BY3Rpb24pO2EuRXhlY3V0ZUNvZGVBY3Rpb249ajt2YXIgaz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUpe2IuY2FsbCh0aGlzLGEsZSksdGhpcy5fdGFyZ2V0PWMsdGhpcy5fcGFyZW50PWR9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7aWYodGhpcy5fdGFyZ2V0LnBhcmVudCE9PXRoaXMuX3BhcmVudCl7dmFyIGI9dGhpcy5fcGFyZW50LmdldFdvcmxkTWF0cml4KCkuY2xvbmUoKTtiLmludmVydCgpLHRoaXMuX3RhcmdldC5wb3NpdGlvbj1hLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXModGhpcy5fdGFyZ2V0LnBvc2l0aW9uLGIpLHRoaXMuX3RhcmdldC5wYXJlbnQ9dGhpcy5fcGFyZW50fX0sY30oYS5BY3Rpb24pO2EuU2V0UGFyZW50QWN0aW9uPWt9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsZSxmKXt0aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PTkUsdGhpcy5fdG90YWxWZXJ0aWNlcz0wLHRoaXMuX2luZGljZXM9W10sdGhpcy5pZD1iLHRoaXMuX2VuZ2luZT1jLmdldEVuZ2luZSgpLHRoaXMuX21lc2hlcz1bXSx0aGlzLl9zY2VuZT1jLGQ/dGhpcy5zZXRBbGxWZXJ0aWNlc0RhdGEoZCxlKToodGhpcy5fdG90YWxWZXJ0aWNlcz0wLHRoaXMuX2luZGljZXM9W10pLGYmJnRoaXMuYXBwbHlUb01lc2goZil9cmV0dXJuIGIucHJvdG90eXBlLmdldFNjZW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjZW5lfSxiLnByb3RvdHlwZS5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW5naW5lfSxiLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsYXlMb2FkU3RhdGU9PT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FERUR8fHRoaXMuZGVsYXlMb2FkU3RhdGU9PT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT05FfSxiLnByb3RvdHlwZS5zZXRBbGxWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYSxiKXthLmFwcGx5VG9HZW9tZXRyeSh0aGlzLGIpfSxiLnByb3RvdHlwZS5zZXRWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMuX3ZlcnRleEJ1ZmZlcnM9dGhpcy5fdmVydGV4QnVmZmVyc3x8e30sdGhpcy5fdmVydGV4QnVmZmVyc1tiXSYmdGhpcy5fdmVydGV4QnVmZmVyc1tiXS5kaXNwb3NlKCksdGhpcy5fdmVydGV4QnVmZmVyc1tiXT1uZXcgYS5WZXJ0ZXhCdWZmZXIodGhpcy5fZW5naW5lLGMsYixkLDA9PT10aGlzLl9tZXNoZXMubGVuZ3RoKSxiPT09YS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKXt2YXIgZT10aGlzLl92ZXJ0ZXhCdWZmZXJzW2JdLmdldFN0cmlkZVNpemUoKTt0aGlzLl90b3RhbFZlcnRpY2VzPWMubGVuZ3RoL2U7Zm9yKHZhciBmPWEuVG9vbHMuRXh0cmFjdE1pbkFuZE1heChjLDAsdGhpcy5fdG90YWxWZXJ0aWNlcyksZz10aGlzLl9tZXNoZXMsaD1nLmxlbmd0aCxpPTA7aD5pO2krKyl7dmFyIGo9Z1tpXTtqLl9yZXNldFBvaW50c0FycmF5Q2FjaGUoKSxqLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGYubWluaW11bSxmLm1heGltdW0pLGouX2NyZWF0ZUdsb2JhbFN1Yk1lc2goKSxqLmNvbXB1dGVXb3JsZE1hdHJpeCghMCl9fX0sYi5wcm90b3R5cGUudXBkYXRlVmVydGljZXNEYXRhPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzLmdldFZlcnRleEJ1ZmZlcihiKTtpZihlJiYoZS51cGRhdGUoYyksYj09PWEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkpe3ZhciBmO2lmKGQpe3ZhciBnPWUuZ2V0U3RyaWRlU2l6ZSgpO3RoaXMuX3RvdGFsVmVydGljZXM9Yy5sZW5ndGgvZyxmPWEuVG9vbHMuRXh0cmFjdE1pbkFuZE1heChjLDAsdGhpcy5fdG90YWxWZXJ0aWNlcyl9Zm9yKHZhciBoPXRoaXMuX21lc2hlcyxpPWgubGVuZ3RoLGo9MDtpPmo7aisrKXt2YXIgaz1oW2pdO2suX3Jlc2V0UG9pbnRzQXJyYXlDYWNoZSgpLGQmJihrLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGYubWluaW11bSxmLm1heGltdW0pKX19fSxiLnByb3RvdHlwZS5nZXRUb3RhbFZlcnRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeSgpP3RoaXMuX3RvdGFsVmVydGljZXM6MH0sYi5wcm90b3R5cGUuZ2V0VmVydGljZXNEYXRhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0VmVydGV4QnVmZmVyKGEpO3JldHVybiBiP2IuZ2V0RGF0YSgpOm51bGx9LGIucHJvdG90eXBlLmdldFZlcnRleEJ1ZmZlcj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5fdmVydGV4QnVmZmVyc1thXTpudWxsfSxiLnByb3RvdHlwZS5nZXRWZXJ0ZXhCdWZmZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeSgpP3RoaXMuX3ZlcnRleEJ1ZmZlcnM6bnVsbH0sYi5wcm90b3R5cGUuaXNWZXJ0aWNlc0RhdGFQcmVzZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl92ZXJ0ZXhCdWZmZXJzP3ZvaWQgMCE9PXRoaXMuX3ZlcnRleEJ1ZmZlcnNbYV06dGhpcy5fZGVsYXlJbmZvPy0xIT09dGhpcy5fZGVsYXlJbmZvLmluZGV4T2YoYSk6ITF9LGIucHJvdG90eXBlLmdldFZlcnRpY2VzRGF0YUtpbmRzPWZ1bmN0aW9uKCl7dmFyIGE9W107aWYoIXRoaXMuX3ZlcnRleEJ1ZmZlcnMmJnRoaXMuX2RlbGF5SW5mbylmb3IodmFyIGIgaW4gdGhpcy5fZGVsYXlJbmZvKWEucHVzaChiKTtlbHNlIGZvcihiIGluIHRoaXMuX3ZlcnRleEJ1ZmZlcnMpYS5wdXNoKGIpO3JldHVybiBhfSxiLnByb3RvdHlwZS5zZXRJbmRpY2VzPWZ1bmN0aW9uKGEpe3RoaXMuX2luZGV4QnVmZmVyJiZ0aGlzLl9lbmdpbmUuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpLHRoaXMuX2luZGljZXM9YSwwIT09dGhpcy5fbWVzaGVzLmxlbmd0aCYmdGhpcy5faW5kaWNlcyYmKHRoaXMuX2luZGV4QnVmZmVyPXRoaXMuX2VuZ2luZS5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLl9pbmRpY2VzKSk7Zm9yKHZhciBiPXRoaXMuX21lc2hlcyxjPWIubGVuZ3RoLGQ9MDtjPmQ7ZCsrKWJbZF0uX2NyZWF0ZUdsb2JhbFN1Yk1lc2goKX0sYi5wcm90b3R5cGUuZ2V0VG90YWxJbmRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeSgpP3RoaXMuX2luZGljZXMubGVuZ3RoOjB9LGIucHJvdG90eXBlLmdldEluZGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5faW5kaWNlczpudWxsfSxiLnByb3RvdHlwZS5nZXRJbmRleEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUmVhZHkoKT90aGlzLl9pbmRleEJ1ZmZlcjpudWxsfSxiLnByb3RvdHlwZS5yZWxlYXNlRm9yTWVzaD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX21lc2hlcyxkPWMuaW5kZXhPZihhKTtpZigtMSE9PWQpe2Zvcih2YXIgZSBpbiB0aGlzLl92ZXJ0ZXhCdWZmZXJzKXRoaXMuX3ZlcnRleEJ1ZmZlcnNbZV0uZGlzcG9zZSgpO3RoaXMuX2luZGV4QnVmZmVyJiZ0aGlzLl9lbmdpbmUuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpJiYodGhpcy5faW5kZXhCdWZmZXI9bnVsbCksYy5zcGxpY2UoZCwxKSxhLl9nZW9tZXRyeT1udWxsLDA9PWMubGVuZ3RoJiZiJiZ0aGlzLmRpc3Bvc2UoKX19LGIucHJvdG90eXBlLmFwcGx5VG9NZXNoPWZ1bmN0aW9uKGEpe2lmKGEuX2dlb21ldHJ5IT09dGhpcyl7dmFyIGI9YS5fZ2VvbWV0cnk7YiYmYi5yZWxlYXNlRm9yTWVzaChhKTt2YXIgYz10aGlzLl9tZXNoZXM7YS5fZ2VvbWV0cnk9dGhpcyx0aGlzLl9zY2VuZS5wdXNoR2VvbWV0cnkodGhpcyksYy5wdXNoKGEpLHRoaXMuaXNSZWFkeSgpP3RoaXMuX2FwcGx5VG9NZXNoKGEpOmEuX2JvdW5kaW5nSW5mbz10aGlzLl9ib3VuZGluZ0luZm99fSxiLnByb3RvdHlwZS5fYXBwbHlUb01lc2g9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5fbWVzaGVzLmxlbmd0aDtmb3IodmFyIGQgaW4gdGhpcy5fdmVydGV4QnVmZmVycylpZigxPT09YyYmdGhpcy5fdmVydGV4QnVmZmVyc1tkXS5jcmVhdGUoKSx0aGlzLl92ZXJ0ZXhCdWZmZXJzW2RdLl9idWZmZXIucmVmZXJlbmNlcz1jLGQ9PT1hLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpe2IuX3Jlc2V0UG9pbnRzQXJyYXlDYWNoZSgpO3ZhciBlPWEuVG9vbHMuRXh0cmFjdE1pbkFuZE1heCh0aGlzLl92ZXJ0ZXhCdWZmZXJzW2RdLmdldERhdGEoKSwwLHRoaXMuX3RvdGFsVmVydGljZXMpO2IuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oZS5taW5pbXVtLGUubWF4aW11bSksYi5fY3JlYXRlR2xvYmFsU3ViTWVzaCgpfTE9PT1jJiZ0aGlzLl9pbmRpY2VzJiYodGhpcy5faW5kZXhCdWZmZXI9dGhpcy5fZW5naW5lLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuX2luZGljZXMpKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX2luZGV4QnVmZmVyLnJlZmVyZW5jZXM9Yyl9LGIucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzO2lmKHRoaXMuZGVsYXlMb2FkU3RhdGUhPT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FESU5HKXtpZih0aGlzLmlzUmVhZHkoKSlyZXR1cm4gdm9pZChjJiZjKCkpO3RoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORyxiLl9hZGRQZW5kaW5nRGF0YSh0aGlzKSxhLlRvb2xzLkxvYWRGaWxlKHRoaXMuZGVsYXlMb2FkaW5nRmlsZSxmdW5jdGlvbihlKXtkLl9kZWxheUxvYWRpbmdGdW5jdGlvbihKU09OLnBhcnNlKGUpLGQpLGQuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BREVELGQuX2RlbGF5SW5mbz1bXSxiLl9yZW1vdmVQZW5kaW5nRGF0YShkKTtmb3IodmFyIGY9ZC5fbWVzaGVzLGc9Zi5sZW5ndGgsaD0wO2c+aDtoKyspZC5fYXBwbHlUb01lc2goZltoXSk7YyYmYygpfSxmdW5jdGlvbigpe30sYi5kYXRhYmFzZSl9fSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPXRoaXMuX21lc2hlcyxjPWIubGVuZ3RoLGQ9MDtjPmQ7ZCsrKXRoaXMucmVsZWFzZUZvck1lc2goYltkXSk7dGhpcy5fbWVzaGVzPVtdO2Zvcih2YXIgZSBpbiB0aGlzLl92ZXJ0ZXhCdWZmZXJzKXRoaXMuX3ZlcnRleEJ1ZmZlcnNbZV0uZGlzcG9zZSgpO3RoaXMuX3ZlcnRleEJ1ZmZlcnM9W10sdGhpcy5fdG90YWxWZXJ0aWNlcz0wLHRoaXMuX2luZGV4QnVmZmVyJiZ0aGlzLl9lbmdpbmUuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpLHRoaXMuX2luZGV4QnVmZmVyPW51bGwsdGhpcy5faW5kaWNlcz1bXSx0aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PTkUsdGhpcy5kZWxheUxvYWRpbmdGaWxlPW51bGwsdGhpcy5fZGVsYXlMb2FkaW5nRnVuY3Rpb249bnVsbCx0aGlzLl9kZWxheUluZm89W10sdGhpcy5fYm91bmRpbmdJbmZvPW51bGw7dmFyIGY9dGhpcy5fc2NlbmUuZ2V0R2VvbWV0cmllcygpO2Q9Zi5pbmRleE9mKHRoaXMpLGQ+LTEmJmYuc3BsaWNlKGQsMSl9LGIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGEuVmVydGV4RGF0YTtjLmluZGljZXM9W107Zm9yKHZhciBkPXRoaXMuZ2V0SW5kaWNlcygpLGU9MDtlPGQubGVuZ3RoO2UrKyljLmluZGljZXMucHVzaChkW2VdKTt2YXIgZj0hMSxnPSExO2Zvcih2YXIgaCBpbiB0aGlzLl92ZXJ0ZXhCdWZmZXJzKWMuc2V0KHRoaXMuZ2V0VmVydGljZXNEYXRhKGgpLGgpLGd8fChmPXRoaXMuZ2V0VmVydGV4QnVmZmVyKGgpLmlzVXBkYXRhYmxlKCksZz0hZik7dmFyIGk9bmV3IGEuR2VvbWV0cnkoYix0aGlzLl9zY2VuZSxjLGYsbnVsbCk7aS5kZWxheUxvYWRTdGF0ZT10aGlzLmRlbGF5TG9hZFN0YXRlLGkuZGVsYXlMb2FkaW5nRmlsZT10aGlzLmRlbGF5TG9hZGluZ0ZpbGUsaS5fZGVsYXlMb2FkaW5nRnVuY3Rpb249dGhpcy5fZGVsYXlMb2FkaW5nRnVuY3Rpb247Zm9yKGggaW4gdGhpcy5fZGVsYXlJbmZvKWkuX2RlbGF5SW5mbz1pLl9kZWxheUluZm98fFtdLGkuX2RlbGF5SW5mby5wdXNoKGgpO3ZhciBqPWEuVG9vbHMuRXh0cmFjdE1pbkFuZE1heCh0aGlzLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpLDAsdGhpcy5nZXRUb3RhbFZlcnRpY2VzKCkpO3JldHVybiBpLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGoubWluaW11bSxqLm1heGltdW0pLGl9LGIuRXh0cmFjdEZyb21NZXNoPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5fZ2VvbWV0cnk7cmV0dXJuIGM/Yy5jb3B5KGIpOm51bGx9LGIuUmFuZG9tSWQ9ZnVuY3Rpb24oKXtyZXR1cm5cInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZyxmdW5jdGlvbihhKXt2YXIgYj0xNipNYXRoLnJhbmRvbSgpfDAsYz1cInhcIj09YT9iOjMmYnw4O3JldHVybiBjLnRvU3RyaW5nKDE2KX0pfSxifSgpO2EuR2VvbWV0cnk9YixmdW5jdGlvbihiKXshZnVuY3Rpb24oYyl7dmFyIGQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYpe3RoaXMuX2JlaW5nUmVnZW5lcmF0ZWQ9ITAsdGhpcy5fY2FuQmVSZWdlbmVyYXRlZD1lLGEuY2FsbCh0aGlzLGIsYyxkLCExLGYpLHRoaXMuX2JlaW5nUmVnZW5lcmF0ZWQ9ITF9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLmNhbkJlUmVnZW5lcmF0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2FuQmVSZWdlbmVyYXRlZH0sYi5wcm90b3R5cGUucmVnZW5lcmF0ZT1mdW5jdGlvbigpe3RoaXMuX2NhbkJlUmVnZW5lcmF0ZWQmJih0aGlzLl9iZWluZ1JlZ2VuZXJhdGVkPSEwLHRoaXMuc2V0QWxsVmVydGljZXNEYXRhKHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksITEpLHRoaXMuX2JlaW5nUmVnZW5lcmF0ZWQ9ITEpfSxiLnByb3RvdHlwZS5hc05ld0dlb21ldHJ5PWZ1bmN0aW9uKGIpe3JldHVybiBhLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcyxiKX0sYi5wcm90b3R5cGUuc2V0QWxsVmVydGljZXNEYXRhPWZ1bmN0aW9uKGIpe3RoaXMuX2JlaW5nUmVnZW5lcmF0ZWQmJmEucHJvdG90eXBlLnNldEFsbFZlcnRpY2VzRGF0YS5jYWxsKHRoaXMsYiwhMSl9LGIucHJvdG90eXBlLnNldFZlcnRpY2VzRGF0YT1mdW5jdGlvbihiLGMpe3RoaXMuX2JlaW5nUmVnZW5lcmF0ZWQmJmEucHJvdG90eXBlLnNldFZlcnRpY2VzRGF0YS5jYWxsKHRoaXMsYixjLCExKX0sYi5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3QgbWV0aG9kXCIpfSxiLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTXVzdCBiZSBvdmVycmlkZW4gaW4gc3ViLWNsYXNzZXMuXCIpfSxifShiKTtjLl9QcmltaXRpdmU9ZDt2YXIgZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZil7dGhpcy5zaXplPWQsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksZSxmKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVCb3godGhpcy5zaXplKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy5zaXplLHRoaXMuY2FuQmVSZWdlbmVyYXRlZCgpLG51bGwpfSxjfShkKTtjLkJveD1lO3ZhciBmPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcpe3RoaXMuc2VnbWVudHM9ZCx0aGlzLmRpYW1ldGVyPWUsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksZixnKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVTcGhlcmUodGhpcy5zZWdtZW50cyx0aGlzLmRpYW1ldGVyKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy5zZWdtZW50cyx0aGlzLmRpYW1ldGVyLHRoaXMuY2FuQmVSZWdlbmVyYXRlZCgpLG51bGwpfSxjfShkKTtjLlNwaGVyZT1mO3ZhciBnPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcsaCxpLGope1widW5kZWZpbmVkXCI9PXR5cGVvZiBoJiYoaD0xKSx0aGlzLmhlaWdodD1kLHRoaXMuZGlhbWV0ZXJUb3A9ZSx0aGlzLmRpYW1ldGVyQm90dG9tPWYsdGhpcy50ZXNzZWxsYXRpb249Zyx0aGlzLnN1YmRpdmlzaW9ucz1oLGIuY2FsbCh0aGlzLGEsYyx0aGlzLl9yZWdlbmVyYXRlVmVydGV4RGF0YSgpLGksail9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9yZWdlbmVyYXRlVmVydGV4RGF0YT1mdW5jdGlvbigpe3JldHVybiBhLlZlcnRleERhdGEuQ3JlYXRlQ3lsaW5kZXIodGhpcy5oZWlnaHQsdGhpcy5kaWFtZXRlclRvcCx0aGlzLmRpYW1ldGVyQm90dG9tLHRoaXMudGVzc2VsbGF0aW9uLHRoaXMuc3ViZGl2aXNpb25zKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy5oZWlnaHQsdGhpcy5kaWFtZXRlclRvcCx0aGlzLmRpYW1ldGVyQm90dG9tLHRoaXMudGVzc2VsbGF0aW9uLHRoaXMuc3ViZGl2aXNpb25zLHRoaXMuY2FuQmVSZWdlbmVyYXRlZCgpLG51bGwpfSxjfShkKTtjLkN5bGluZGVyPWc7dmFyIGg9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYsZyxoKXt0aGlzLmRpYW1ldGVyPWQsdGhpcy50aGlja25lc3M9ZSx0aGlzLnRlc3NlbGxhdGlvbj1mLGIuY2FsbCh0aGlzLGEsYyx0aGlzLl9yZWdlbmVyYXRlVmVydGV4RGF0YSgpLGcsaCl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9yZWdlbmVyYXRlVmVydGV4RGF0YT1mdW5jdGlvbigpe3JldHVybiBhLlZlcnRleERhdGEuQ3JlYXRlVG9ydXModGhpcy5kaWFtZXRlcix0aGlzLnRoaWNrbmVzcyx0aGlzLnRlc3NlbGxhdGlvbil9LGMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEsdGhpcy5nZXRTY2VuZSgpLHRoaXMuZGlhbWV0ZXIsdGhpcy50aGlja25lc3MsdGhpcy50ZXNzZWxsYXRpb24sdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuVG9ydXM9aDt2YXIgaT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZixnLGgpe3RoaXMud2lkdGg9ZCx0aGlzLmhlaWdodD1lLHRoaXMuc3ViZGl2aXNpb25zPWYsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksZyxoKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVHcm91bmQodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLnN1YmRpdmlzaW9ucyl9LGMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEsdGhpcy5nZXRTY2VuZSgpLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5zdWJkaXZpc2lvbnMsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuR3JvdW5kPWk7dmFyIGo9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYsZyxoLGksaixrKXt0aGlzLnhtaW49ZCx0aGlzLnptaW49ZSx0aGlzLnhtYXg9Zix0aGlzLnptYXg9Zyx0aGlzLnN1YmRpdmlzaW9ucz1oLHRoaXMucHJlY2lzaW9uPWksYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksaixrKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVUaWxlZEdyb3VuZCh0aGlzLnhtaW4sdGhpcy56bWluLHRoaXMueG1heCx0aGlzLnptYXgsdGhpcy5zdWJkaXZpc2lvbnMsdGhpcy5wcmVjaXNpb24pfSxjLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLnhtaW4sdGhpcy56bWluLHRoaXMueG1heCx0aGlzLnptYXgsdGhpcy5zdWJkaXZpc2lvbnMsdGhpcy5wcmVjaXNpb24sdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuVGlsZWRHcm91bmQ9ajt2YXIgaz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZil7dGhpcy5zaXplPWQsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksZSxmKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVQbGFuZSh0aGlzLnNpemUpfSxjLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLnNpemUsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuUGxhbmU9azt2YXIgbD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZixnLGgsaSxqLGspe3RoaXMucmFkaXVzPWQsdGhpcy50dWJlPWUsdGhpcy5yYWRpYWxTZWdtZW50cz1mLHRoaXMudHVidWxhclNlZ21lbnRzPWcsdGhpcy5wPWgsdGhpcy5xPWksYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksaixrKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVUb3J1c0tub3QodGhpcy5yYWRpdXMsdGhpcy50dWJlLHRoaXMucmFkaWFsU2VnbWVudHMsdGhpcy50dWJ1bGFyU2VnbWVudHMsdGhpcy5wLHRoaXMucSl9LGMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEsdGhpcy5nZXRTY2VuZSgpLHRoaXMucmFkaXVzLHRoaXMudHViZSx0aGlzLnJhZGlhbFNlZ21lbnRzLHRoaXMudHVidWxhclNlZ21lbnRzLHRoaXMucCx0aGlzLnEsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuVG9ydXNLbm90PWx9KGIuUHJpbWl0aXZlc3x8KGIuUHJpbWl0aXZlcz17fSkpO2IuUHJpbWl0aXZlc30oYS5HZW9tZXRyeXx8KGEuR2VvbWV0cnk9e30pKTt2YXIgYj1hLkdlb21ldHJ5fShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3ZhciBiPXRoaXM7dGhpcy5iYWJ5bG9uR2FtZXBhZHM9W10sdGhpcy5vbmVHYW1lcGFkQ29ubmVjdGVkPSExLHRoaXMuaXNNb25pdG9yaW5nPSExLHRoaXMuZ2FtZXBhZEV2ZW50U3VwcG9ydGVkPVwiR2FtZXBhZEV2ZW50XCJpbiB3aW5kb3csdGhpcy5nYW1lcGFkU3VwcG9ydEF2YWlsYWJsZT1uYXZpZ2F0b3IuZ2V0R2FtZXBhZHN8fCEhbmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzfHwhIW5hdmlnYXRvci5tc0dldEdhbWVwYWRzfHwhIW5hdmlnYXRvci53ZWJraXRHYW1lcGFkcyx0aGlzLmJ1dHRvbkFEYXRhVVJMPVwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWEhlQUFBQUJHZEJUVUVBQUsvSU53V0s2UUFBQUJsMFJWaDBVMjltZEhkaGNtVUFRV1J2WW1VZ1NXMWhaMlZTWldGa2VYSEpaVHdBQUE5YVNVUkJWSGphN0Z0cGJCem5lWDdtM290Y2loU3BtOVo5VUphbHhQS2hWTFpscDZrdE56RWF4RTBDdEFuUUFnblNvUFdQQmkzc3l1aVB3b3JkRmk1UXQyaGFGeWdDb3lsU1Y0VmJ5Nm9zMUkza09MWXJTNjVrWFhRb3lwSkpTYUZFVVR5WHk5MjUrcnpmekM2SEZGbEwxa3BBSWU3aTVjek83SDd6UHM5N2Z0OE10VEFNY1N1L2ROemlyeGtDWmdpWUlXQ0dnQmtDWmdpNGhWL21EUjVmU3hBdCswWmlYMHVjRHhNU1RKTEsrZjgzQkZTQTZURmdLNzVPY2xzaG91S0JGYkEreGFWNGs3WitmRDZzTlJsbWpZRlhRTXU0TmlVVlMvb0hlNS9lY25IbzNNWXhkN1F0aE45VWNzZFc2RnFFUHdnRE9GYnFwQWFqTDJWbFRyVFVMemo0T3c4K3M0K25pcFN4V01veElVa3lybC9wR3N3RnRJUjdXekhnRENYNzdLN3ZmSE5rYk9BK0FyeWpZWmFkYjI3T0lKZHpDTlpCS21YdzRrYmszNXFQc1RFZkpiZUVrWkVTZW50SE1kQmZHdFkxNDJndTFiRHZxVi85MjVmNHRRSmxOQ2FqNGhYWDdSSFhTMEFGdUpFQVh2ZkhyL3ptazY3dlBqaXIwVjY4YUZFZTh4dHVRNk8xRkhsckVYTG1IQmlhRFV0ellCbHBOWWpyRitHRlpmaGhDY1BlQlF5NTNlaHpUK0g4UUJlNnV3ZlJmN2w4eGpLc3ZYL3k1WDk4amw4ZlRoRGhKNGk0NlFRa3JTNUk2djdvWDcvKys3N3ZQdExVbEZuWnRuSVJsdWJ2eFJ4bkhiSm1FNzlzeEQvU3FHMG9aazhNRmFyUnF1ZlVrUUFGcnhjWFNrZngwZUIrbk9nZ0tYMmpIWVpodmY3OXIvejRMMklpaXBPODRhWVJrQVNmZWZuQVg2OTVwM1AzYzltTS9VdWZ1YU1WZHpSdnhWeDdBMHhhV2RPTXFWVUxKNlozVFp2NkttSG8wenRLNkNrZnhwSGUzVGgwcEF1RjBmTGJuMXUrOWNtdjN2Vzc3YkUzZkdvU1BpMEJWZkF2dlBFSG05clB2Ly9pb29XejVtOVovd0NXWngrR285VXJONDhRVEQ5SUdNWjFjSkl6VFBpc1JRY2xQTXJoTUU0VzltRGZCMitpKzJ6LytUWHo3L3oyRTcvODUrOU9JdUdHRTZCVjNINzd6bS9kMzNueDZLdHIxOHpGZzJ0K0RRdWRlMm4xdExKOHRjSjkwdkRocEc1QW03cVRrSkFRRXJ5d2lMT2xkN0czL2Q5eHZMMEh5MXZXUGJidFMzLy8wMFE0aERlYUFGWGludHJ4MWZ1NytqcDJyMTNiZ29mWC9nYWF6YlZrSlFkTFQ5UDZWcVJGRFN1MmhJZ1hsQlVCTGd0Q3IzY2NlNDcvQ01lUFgwUnIwOHF0eno3KzhrOFRwZktHdGNLcTFqUFpyZTdvT2J5amRXa0dkNjI4bDdBWHd2TUNlTDdIak82cXJTOFMxRTVrVEU5dGZiaXVyNjY1Y2NVOUVCMUVGOUVwMFdYZXNFWklKYjlqNS9iL1hVdHpOcnQyOVJ3MG9nMmxjaG1CVnFMbzhMU0FIbENpeGJUcGRkR204WTdwamt0dENDVVArSlF5M0ZpYXROdXhkdlV4OUY0YXlvcE8vT0w5c1FlRU40b0EvZUhuNTc3b1dQYkdWZXMxMVBzclVCeGpEYWZ6ZTFUZTFWem91cW5LMlRnbUxRbGpRcW1ybkFzVCtpYVBWYjViMmNvN0VDK1FoQmdVZU0xUjFBY3JzR3A5Snk2KzRXOFUzZlo4citlM0VuT0kydWFBWDNsK3pnTkI0TzlyVzUvQjh0WTVXR285QnRPcko0dU1mVWwrdWowQjhIVG1QWGo4UGV4ODZ4VkVuVERCQlNFMnI3OGZYOWkwOVJQeVpmVDJBNWNlSU1TUHdET0g4Skg3S2s1K2ZBSHRSMFpoNk1aOWU3NTM0V2Mzd2dPMHNYTGhEOU9wRk9hMGVnakdNaGd1RDhCZ1RKb29NZlBiVjFoL3VtejI1b25kY0ZQOTBJelkyaVRncmZZOXVIMzFhcVNjOUNlU0VIa0JFeUlUdjI4TThYTUdjMi96MEhHQ3BXQ3M4QlMvOXNXckRZT3JKdUNCWit2dTVzVWZYYmljaWE1a1lHelV3NERXVHdKS2JBcFNqSHVUQkJqVDJINjh6ZzBNRDRLbEV3YWJaaTBZN3dkODV1LzNPOS9CNnNWclBsRVhlaUY5bk1tUnhQdDZRZjR5L0h5SWJoM0h3a2RGMXplZkd0NWZVd0s4d1AyV0FHd2gwMk1GRS81b2dZcjNRZy9TVEwwVzNkOGFCMXBwYStQdzB1STJUejYvMTM0TWcrVW9JR1psWjJITUxhSllIa1BJQ3I2Ly9SQmFtdlBqL1VBNGRZS3NlZ0dyWHFBWE1hcU5zRFQ2U3JlT1k1R3UvRnB0Q2VCRk4rY2FBcGhHaUtGaUdhT2pBM0FKSG9HdDZyN0dnTmJqcWpvNXlRa0JVVkhROFBhSkV4amlhWjJ5dWUxMm5PMjdnQ05kSFNwdHZmL3hHZHcxMUkyVVpTbXZDSUpnUWlKTWhvRWZlcXBORHZVU1J2VUI1aE1YOWZVZWNnMGFCaStIbTJ1YUF6NjMzYm1ibTFWTjgraDA3TGZLSmRrT2tRQjJmTDRCVGxzajhObzRZTEcycHV0TVNqd2pwM1FOdlpkSDhZc2lFeFY1MDFpc0ZqVTMwbHBGN0Q4ZFZmQ0E4c0ZIcDdCdVdZdGFJd2lDc0NyQ1NEVmhoOUlYOGswQ29Ic29NUTg0RnJmRkFFM3pRQUswVmFMek85dEs3OVhLQXhTaithWUFMdDNYTGZOaXBaRDF2NDkyWWV4ckUvc1AwekJnVUlRSW9ZYWZsQVhiejE2Q3p5WTZZS3FZbDh1aGVUYXJSaW9EN3hBeENRSFVwdjE4TDFZdWQrSWxvdWp0azR6UW85V1pjS1VScWpiSGNsekt2ajBHdmN3OFVBNm9ZMldxb25TdUdRR2I1SStUSmdFRkVzQjRkYVh6YzBlb3BhYmNYMTNXMEJYd2dBblJaTDRRNjJzOHBwblIvcEZ6L1FqRit0UnZ4ZUlzWS9jaXpHd1J0ODNQNGN6QUNMOEhkQTFKVWl2Q05HVm9ndmRrTmtnYUdETmU0Q3ZYRnlKOG4rQjVYR0xKMUZtSlhKNTNBempaS2dHYmF0a0tMNWMvbGlOV0lQTzh1TS80Vk8ydUtDUVpqTG1CcVFBR0o0RW1JOE5NYWJEVE91eVVvYllYbVBsQ0VwaXFBMUlrWWRXU0JwanBFRGw2d3NyRjlhQWpxSE5PUFhEeVhBR3ByQWtuWTVCMGJ0T0dHay9HbGZFMXRhcW9mQ051dVlOSUorb21PaVoxcnBVSHRFWVdqa3BXb1A1RVdWMnNiNWlzQTdhSVFUSEh4YUluaU5BRHVpOFBJczBFYjZTWS9aMFVRYytqK21YWXVvTTdWeS9BZ2U3emtCVXlDWkdMaFJMU09ZY1dwZlhGQTF3UGhxdXA4Sk5LcTVVa0tlb3FTSHhQTFNvcW5VUXR3NWlvYzYwSXlFL1ZrT2ppOG1ZRTJuWkVMTmdDWExhT2tHREZKQmc0T3pDTURFY3hDZkF6UzFwUVg1ZkhTTkRMQ2xMR3dtd3psczZ2UTA5aEdGSlllZ2RaMWhoYTJicUlCTmVsQjVRam9nMDJUenBGTlZFcXVZcE11VFNZci9sY1FQS1BKSG9SUThXMUdZTzNsRGdwTzlwUFdURVpFUUdudW9kZzVIeWs2Nkx5ZDhmS09RUTZncXlXaWN0N0dldVd6OEhReVdFRncrYkI3a3NGM05rMlYxbmZwWlRMUXFTTHNselhsRG1IcHNRMW9zVm95L1NvbHdmL0dwZEVycGFBUVVxald4TDJHV2NXYVNmQU1JaXM3UkJ3aXVDZHREMU9nbU5IQkpDZzdyNHVaQm5iZGphYXErM1lld0IrVVNZaWNZOGp1WVBuTXRsb3FkQ2pHM2YzOWVPKzNKS0lBRmFkU2lpWmlnQmRnZGNxSXRNeHNtWmJJYnZVSUtsenpRam9FZ0xHUmpVMktUcDhBalJDa3pFbkFHMG10UWg4S3Uwb0Fxb2s4SnpQK0x3ME1rQjNqcEtqS3BhcGFMNVdLWnhhZkRkQnFvQzZPOEx0eU1BUWhvWmR6RzdNd0xVOEZVWUtQSU5jbCtxaW1pc21SajI2djJJNzFJM2pEeGZkcE00MUk2Q1RzbUc0WDBkakt5YzhSWXU5dDBWbDJRSmJCSjV4RlBpSUNKSWcxaGRoUjNmczVIbldlbGRsZVpYQUJMQTk4YjdZNUh0amtnd05FdGJUTjRpRkM1b0kzSTFDVHNBYnNmVmpBaXpKQjNRYng5SHBoUnA2ZXFyM1REcHJTWUEwRkkvM250T3hicFVOTTJPanBFY0U2SFlFV2toSUt3K0lDZUJ4aStUMDlGMVdaVStpSnEybjhmUkRmNFltdTNYU3JjT0lnZzhIOXVPRm4zMWZOVVZDMG9kZFo3QjVZeHREd2xUZ282NlNFaWNpMmZva3dDSmpqdTBodzdKNTRXeXBRc0I3dFNSQXphK0grbmxkMzBZK20yYjdTUytRbjlQS0ZsMWVnUmNpSElmV3B4Qzh4Kzd0ZEE5NyszelVjTnlXWDRDaS9USE9vRDJ4L2htbFFUb3grM2dEaldZZWcvNGdtRjg1M3hqQnBVc2phR25KUjI0ZnUzNkZOelg1cG1mWTdFUFN0bFNMSWdiNmd3azYxNlFSWWs4dFM4OC9sLzJQVC9sb3lxYlFrRW1oUHBOR05wMUNtdnRpZVFIdk9OR3RMNHNkeTlIanA1a2twVFdtU3pNN0w1MjloRXJIczBjQ3B0MnFXMDBCeW1EVjNKWFNVOEhrQVhLSWp0Tm5lZHhTNDhtNE1yNWNSOVlsTXJ4K1hUcU5SbWJQMlprTU9qdkhLaXIvUE5hNXBvdWlpdEZqSDQ0aVo2WXdPNXRGQXkrZW82U2RwT1VKeWhCUVRKUitIVDlIWUxKYUZ2ZTBQcVFtVFFMYVZPQ2RtSVJJV0Urd3JtV1R6RzhpQXVnRjdxZ1dqU1drR2JZYTMyRWpKUVRrR0Z2NWRCWk5KS0NlSGRiNzdVUFhaUDFyV2hLTFo0UnFqdjJGejg2bExNTmxwdXNDWTlCbnFUTlVJeVRnclZoaHM3clZxMktvVzJUU3hXbFhMT0NxV1g0c3ZtcHpaZEVqV3ZnUWNkVldQbnUraTRDbFVTK0h5TElGbnNWZi85ZUJkdXc4ZUtZeTJEMVhNeE84SmcrSUI5d2wrM3MvdUFDM3FLTXBYWTg4bS9lY25VSGFTaXMzTmE4QWIxVXRhQ2gzajF5K3NtOG05bzBKKzlGdjlNUjRaaHc2RHVmVFdhc09lYnNPcyt4WktISk90dnRRdGVydHVscndWKzBCdEg1eVd2eVc3Q3h1YnNDVFg5K0tVUVo0Z2E3cW1kR1VGbXJ5YThRV0h3Y3hsUmVNRjhNdzRRRVRyUjhveTd0cTJpdkg1VHZ5YThuOGFYWk1HYzRBbi9uUkRweTUyRmZSOGI1S0NKQ0ltdDhZa1lGL0tEdG5lZ2Z3ejNzUG9kR2FqUWFqQ1RrOXovNG1RNmlwaE1XdjlBQTlJZU1XZHlZZG4rZ0JrVmM1YW13SFdWNmxIdlZhSTJZWnpmaW5OOTVOZ3YvaHRjVC9wMzFDUk5iZFY4bDhlKyt4RDVIUE5lSHhoeDVCZ2YxOGtUTjVUMWt2akJmRWpHakJKQ2FpNGduakhxQW5sdnFTOGU5TmV1akVqRXVsL05va0RiYWk0Vi8ydm9hZkhEMVMwZXZkV0xlYjhvak1OeWx5NWZTLy9mZmJjRDBMMzNqNEs0Ulg0cnRNaC9VVUdMWG1yNkJXWE45TUVGQWhZZnptWjZoY1hJK1RwSVNSSDgwNjFVaTY4Z1RXR1VKUDRhVTlQOFpyQjM5UytYa3gxdW1tUFNNa2JlYm5KY3hVMWptNEQ1ZUdodkI3ajMySEpjcFVKSGh4TElmeFRacHh3R2E4ZUtySEM1MWE5VG1wK041UDFSc1EwMWNKQXdFZmxIdzgvK3BmWW4vSGdhUStuNy9hMXZkNmsrQlVTMlh2VkQ0MDFUWGh1NDg4Z1EwcjcxUVV1TEpzcldUOG1TWXRma0JNbTBCQW1GaE5yZ0RYNG9ScXFlYUpNdzRjNlR5SXYvcVBQMFhmOEtVSjZzWHVQMVhsdXVFRXlHc0Q1VFhLZ3NxQk5Rdlc0UnRibmtEYjR0dEpRbEd0L0lRcUxNSkU3dFdxT1NCWkNTckw2ZEZTcXEzQW56aHpEQy90ZXdIdDV3NG5yM3N1dmdOMCtQOG8zVGVlZ0ZlM3ZZREh0ait4aEx0L1Eza2tlVzVkNjkzWXV1SFhzV0haUGNpeFc0dEN3byt0clZVOVFFczhHNkhGcVc1a2RCaUhUdTNINjRkZnhwR3VLOHI2NjVUdjd0ejJENmUvdFAyM2NUMEUxT0E1UVIyaWlJYnMxaTl1LzlxVFBQQzEyQ3R3bElvZmpaVnZXL0JaM0xWc0M1YlBXNHU1RFF1eGFQYXkyTnBSSXV5NjFJa0xBK2R3OGhkSGNlRFVQcHc0OXo5VFhVeXN2V1BYdGwzYlE0eVF0TUoxYTE4REFzYnZSTy9hdHZNNURYWFBQYnA5eXpQOCtHWEJYVGtuZ0tZQmRUV3ZFNVJYZG04NytIUUVmTGgyVDU3VUlBZE05NUpzOSswNExLU0RiTHpHMzErT214cHg5eGZ4S1I2QXVra2hNUDBhS3VVSHNhZzVWRXpFM2ZHU2Rkc1VWdTZLRnpJRStIL2lKcnkwbVgrYnU4VmZNd1RNRURCRHdBd0JNd1RNRUhBTHYvNVhnQUVBU3BSNU42ckIzMFVBQUFBQVNVVk9SSzVDWUlJPVwiLHRoaXMuX2NhbGxiYWNrR2FtZXBhZENvbm5lY3RlZD1hLHRoaXMuZ2FtZXBhZFN1cHBvcnRBdmFpbGFibGU/KHRoaXMuZ2FtZXBhZEV2ZW50U3VwcG9ydGVkPyh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIixmdW5jdGlvbihhKXtiLl9vbkdhbWVwYWRDb25uZWN0ZWQoYSlcbn0sITEpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLGZ1bmN0aW9uKGEpe2IuX29uR2FtZXBhZERpc2Nvbm5lY3RlZChhKX0sITEpKTp0aGlzLl9zdGFydE1vbml0b3JpbmdHYW1lcGFkcygpLHRoaXMub25lR2FtZXBhZENvbm5lY3RlZHx8dGhpcy5faW5zZXJ0R2FtZXBhZERPTUluc3RydWN0aW9ucygpKTp0aGlzLl9pbnNlcnRHYW1lcGFkRE9NTm90U3VwcG9ydGVkKCl9cmV0dXJuIGIucHJvdG90eXBlLl9pbnNlcnRHYW1lcGFkRE9NSW5zdHJ1Y3Rpb25zPWZ1bmN0aW9uKCl7Yi5nYW1lcGFkRE9NSW5mbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7YS5zcmM9dGhpcy5idXR0b25BRGF0YVVSTDt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtjLmlubmVySFRNTD1cIjxzdHJvbmc+dG8gYWN0aXZhdGUgZ2FtZXBhZDwvc3Ryb25nPlwiLGIuZ2FtZXBhZERPTUluZm8uYXBwZW5kQ2hpbGQoYSksYi5nYW1lcGFkRE9NSW5mby5hcHBlbmRDaGlsZChjKSxiLmdhbWVwYWRET01JbmZvLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLndpZHRoPVwiMTAwJVwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUuaGVpZ2h0PVwiNDhweFwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUuYm90dG9tPVwiMHB4XCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCJyZ2JhKDEsIDEsIDEsIDAuMTUpXCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS50ZXh0QWxpZ249XCJjZW50ZXJcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLnpJbmRleD1cIjEwXCIsYS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsYS5zdHlsZS5ib3R0b209XCI4cHhcIixjLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixjLnN0eWxlLmZvbnRTaXplPVwiMzJweFwiLGMuc3R5bGUuYm90dG9tPVwiMzJweFwiLGMuc3R5bGUuY29sb3I9XCJncmVlblwiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5nYW1lcGFkRE9NSW5mbyl9LGIucHJvdG90eXBlLl9pbnNlcnRHYW1lcGFkRE9NTm90U3VwcG9ydGVkPWZ1bmN0aW9uKCl7Yi5nYW1lcGFkRE9NSW5mbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2EuaW5uZXJIVE1MPVwiPHN0cm9uZz5nYW1lcGFkIG5vdCBzdXBwb3J0ZWQ8L3N0cm9uZz5cIixiLmdhbWVwYWRET01JbmZvLmFwcGVuZENoaWxkKGEpLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUud2lkdGg9XCIxMDAlXCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5oZWlnaHQ9XCI0MHB4XCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5ib3R0b209XCIwcHhcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoMSwgMSwgMSwgMC4xNSlcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLnRleHRBbGlnbj1cImNlbnRlclwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUuekluZGV4PVwiMTBcIixhLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixhLnN0eWxlLmZvbnRTaXplPVwiMzJweFwiLGEuc3R5bGUuY29sb3I9XCJyZWRcIixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIuZ2FtZXBhZERPTUluZm8pfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChiLmdhbWVwYWRET01JbmZvKX0sYi5wcm90b3R5cGUuX29uR2FtZXBhZENvbm5lY3RlZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9hZGROZXdHYW1lcGFkKGEuZ2FtZXBhZCk7dGhpcy5fY2FsbGJhY2tHYW1lcGFkQ29ubmVjdGVkJiZ0aGlzLl9jYWxsYmFja0dhbWVwYWRDb25uZWN0ZWQoYiksdGhpcy5fc3RhcnRNb25pdG9yaW5nR2FtZXBhZHMoKX0sYi5wcm90b3R5cGUuX2FkZE5ld0dhbWVwYWQ9ZnVuY3Rpb24oYyl7dGhpcy5vbmVHYW1lcGFkQ29ubmVjdGVkfHwodGhpcy5vbmVHYW1lcGFkQ29ubmVjdGVkPSEwLGIuZ2FtZXBhZERPTUluZm8mJihkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIuZ2FtZXBhZERPTUluZm8pLGIuZ2FtZXBhZERPTUluZm89bnVsbCkpO3ZhciBkO3JldHVybiBkPS0xIT09Yy5pZC5zZWFyY2goXCJYYm94IDM2MFwiKXx8LTEhPT1jLmlkLnNlYXJjaChcInhpbnB1dFwiKT9uZXcgYS5YYm94MzYwUGFkKGMuaWQsYy5pbmRleCxjKTpuZXcgYS5HZW5lcmljUGFkKGMuaWQsYy5pbmRleCxjKSx0aGlzLmJhYnlsb25HYW1lcGFkcy5wdXNoKGQpLGR9LGIucHJvdG90eXBlLl9vbkdhbWVwYWREaXNjb25uZWN0ZWQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIHRoaXMuYmFieWxvbkdhbWVwYWRzKWlmKHRoaXMuYmFieWxvbkdhbWVwYWRzW2JdLmluZGV4PT1hLmdhbWVwYWQuaW5kZXgpe3RoaXMuYmFieWxvbkdhbWVwYWRzLnNwbGljZShiLDEpO2JyZWFrfTA9PXRoaXMuYmFieWxvbkdhbWVwYWRzLmxlbmd0aCYmdGhpcy5fc3RvcE1vbml0b3JpbmdHYW1lcGFkcygpfSxiLnByb3RvdHlwZS5fc3RhcnRNb25pdG9yaW5nR2FtZXBhZHM9ZnVuY3Rpb24oKXt0aGlzLmlzTW9uaXRvcmluZ3x8KHRoaXMuaXNNb25pdG9yaW5nPSEwLHRoaXMuX2NoZWNrR2FtZXBhZHNTdGF0dXMoKSl9LGIucHJvdG90eXBlLl9zdG9wTW9uaXRvcmluZ0dhbWVwYWRzPWZ1bmN0aW9uKCl7dGhpcy5pc01vbml0b3Jpbmc9ITF9LGIucHJvdG90eXBlLl9jaGVja0dhbWVwYWRzU3RhdHVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLl91cGRhdGVHYW1lcGFkT2JqZWN0cygpO2Zvcih2YXIgYiBpbiB0aGlzLmJhYnlsb25HYW1lcGFkcyl0aGlzLmJhYnlsb25HYW1lcGFkc1tiXS51cGRhdGUoKTt0aGlzLmlzTW9uaXRvcmluZyYmKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuX2NoZWNrR2FtZXBhZHNTdGF0dXMoKX0pOndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuX2NoZWNrR2FtZXBhZHNTdGF0dXMoKX0pOndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXthLl9jaGVja0dhbWVwYWRzU3RhdHVzKCl9KSl9LGIucHJvdG90eXBlLl91cGRhdGVHYW1lcGFkT2JqZWN0cz1mdW5jdGlvbigpe2Zvcih2YXIgYT1uYXZpZ2F0b3IuZ2V0R2FtZXBhZHM/bmF2aWdhdG9yLmdldEdhbWVwYWRzKCk6bmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzP25hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpOltdLGI9MDtiPGEubGVuZ3RoO2IrKylpZihhW2JdKWlmKGFbYl0uaW5kZXggaW4gdGhpcy5iYWJ5bG9uR2FtZXBhZHMpdGhpcy5iYWJ5bG9uR2FtZXBhZHNbYl0uYnJvd3NlckdhbWVwYWQ9YVtiXTtlbHNle3ZhciBjPXRoaXMuX2FkZE5ld0dhbWVwYWQoYVtiXSk7dGhpcy5fY2FsbGJhY2tHYW1lcGFkQ29ubmVjdGVkJiZ0aGlzLl9jYWxsYmFja0dhbWVwYWRDb25uZWN0ZWQoYyl9fSxifSgpO2EuR2FtZXBhZHM9Yjt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXt0aGlzLng9YSx0aGlzLnk9Yn1yZXR1cm4gYX0oKTthLlN0aWNrVmFsdWVzPWM7dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYixjKXt0aGlzLmlkPWEsdGhpcy5pbmRleD1iLHRoaXMuYnJvd3NlckdhbWVwYWQ9Yyx0aGlzLmJyb3dzZXJHYW1lcGFkLmF4ZXMubGVuZ3RoPj0yJiYodGhpcy5fbGVmdFN0aWNrPXt4OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1swXSx5OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1sxXX0pLHRoaXMuYnJvd3NlckdhbWVwYWQuYXhlcy5sZW5ndGg+PTQmJih0aGlzLl9yaWdodFN0aWNrPXt4OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1syXSx5OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1szXX0pfXJldHVybiBhLnByb3RvdHlwZS5vbmxlZnRzdGlja2NoYW5nZWQ9ZnVuY3Rpb24oYSl7dGhpcy5fb25sZWZ0c3RpY2tjaGFuZ2VkPWF9LGEucHJvdG90eXBlLm9ucmlnaHRzdGlja2NoYW5nZWQ9ZnVuY3Rpb24oYSl7dGhpcy5fb25yaWdodHN0aWNrY2hhbmdlZD1hfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJsZWZ0U3RpY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlZnRTdGlja30sc2V0OmZ1bmN0aW9uKGEpeyF0aGlzLl9vbmxlZnRzdGlja2NoYW5nZWR8fHRoaXMuX2xlZnRTdGljay54PT09YS54JiZ0aGlzLl9sZWZ0U3RpY2sueT09PWEueXx8dGhpcy5fb25sZWZ0c3RpY2tjaGFuZ2VkKGEpLHRoaXMuX2xlZnRTdGljaz1hfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLnByb3RvdHlwZSxcInJpZ2h0U3RpY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JpZ2h0U3RpY2t9LHNldDpmdW5jdGlvbihhKXshdGhpcy5fb25yaWdodHN0aWNrY2hhbmdlZHx8dGhpcy5fcmlnaHRTdGljay54PT09YS54JiZ0aGlzLl9yaWdodFN0aWNrLnk9PT1hLnl8fHRoaXMuX29ucmlnaHRzdGlja2NoYW5nZWQoYSksdGhpcy5fcmlnaHRTdGljaz1hfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX2xlZnRTdGljayYmKHRoaXMubGVmdFN0aWNrPXt4OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1swXSx5OnRoaXMuYnJvd3NlckdhbWVwYWQuYXhlc1sxXX0pLHRoaXMuX3JpZ2h0U3RpY2smJih0aGlzLnJpZ2h0U3RpY2s9e3g6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzJdLHk6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzNdfSl9LGF9KCk7YS5HYW1lcGFkPWQ7dmFyIGU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCl7YS5jYWxsKHRoaXMsYixjLGQpLHRoaXMuaWQ9Yix0aGlzLmluZGV4PWMsdGhpcy5nYW1lcGFkPWQsdGhpcy5fYnV0dG9ucz1uZXcgQXJyYXkoZC5idXR0b25zLmxlbmd0aCl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLm9uYnV0dG9uZG93bj1mdW5jdGlvbihhKXt0aGlzLl9vbmJ1dHRvbmRvd249YX0sYi5wcm90b3R5cGUub25idXR0b251cD1mdW5jdGlvbihhKXt0aGlzLl9vbmJ1dHRvbnVwPWF9LGIucHJvdG90eXBlLl9zZXRCdXR0b25WYWx1ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEhPT1iJiYodGhpcy5fb25idXR0b25kb3duJiYxPT09YSYmdGhpcy5fb25idXR0b25kb3duKGMpLHRoaXMuX29uYnV0dG9udXAmJjA9PT1hJiZ0aGlzLl9vbmJ1dHRvbnVwKGMpKSxhfSxiLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXthLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtmb3IodmFyIGI9MDtiPHRoaXMuX2J1dHRvbnMubGVuZ3RoO2IrKyl0aGlzLl9idXR0b25zW2JdPXRoaXMuX3NldEJ1dHRvblZhbHVlKHRoaXMuZ2FtZXBhZC5idXR0b25zW2JdLnZhbHVlLHRoaXMuX2J1dHRvbnNbYl0sYil9LGJ9KGQpO2EuR2VuZXJpY1BhZD1lLGZ1bmN0aW9uKGEpe2FbYS5BPTBdPVwiQVwiLGFbYS5CPTFdPVwiQlwiLGFbYS5YPTJdPVwiWFwiLGFbYS5ZPTNdPVwiWVwiLGFbYS5TdGFydD00XT1cIlN0YXJ0XCIsYVthLkJhY2s9NV09XCJCYWNrXCIsYVthLkxCPTZdPVwiTEJcIixhW2EuUkI9N109XCJSQlwiLGFbYS5MZWZ0U3RpY2s9OF09XCJMZWZ0U3RpY2tcIixhW2EuUmlnaHRTdGljaz05XT1cIlJpZ2h0U3RpY2tcIn0oYS5YYm94MzYwQnV0dG9ufHwoYS5YYm94MzYwQnV0dG9uPXt9KSk7YS5YYm94MzYwQnV0dG9uOyFmdW5jdGlvbihhKXthW2EuVXA9MF09XCJVcFwiLGFbYS5Eb3duPTFdPVwiRG93blwiLGFbYS5MZWZ0PTJdPVwiTGVmdFwiLGFbYS5SaWdodD0zXT1cIlJpZ2h0XCJ9KGEuWGJveDM2MERwYWR8fChhLlhib3gzNjBEcGFkPXt9KSk7dmFyIGY9KGEuWGJveDM2MERwYWQsZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2EuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXMuX2xlZnRUcmlnZ2VyPTAsdGhpcy5fcmlnaHRUcmlnZ2VyPTAsdGhpcy5fYnV0dG9uQT0wLHRoaXMuX2J1dHRvbkI9MCx0aGlzLl9idXR0b25YPTAsdGhpcy5fYnV0dG9uWT0wLHRoaXMuX2J1dHRvbkJhY2s9MCx0aGlzLl9idXR0b25TdGFydD0wLHRoaXMuX2J1dHRvbkxCPTAsdGhpcy5fYnV0dG9uUkI9MCx0aGlzLl9idXR0b25MZWZ0U3RpY2s9MCx0aGlzLl9idXR0b25SaWdodFN0aWNrPTAsdGhpcy5fZFBhZFVwPTAsdGhpcy5fZFBhZERvd249MCx0aGlzLl9kUGFkTGVmdD0wLHRoaXMuX2RQYWRSaWdodD0wfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5vbmxlZnR0cmlnZ2VyY2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLl9vbmxlZnR0cmlnZ2VyY2hhbmdlZD1hfSxiLnByb3RvdHlwZS5vbnJpZ2h0dHJpZ2dlcmNoYW5nZWQ9ZnVuY3Rpb24oYSl7dGhpcy5fb25yaWdodHRyaWdnZXJjaGFuZ2VkPWF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImxlZnRUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sZWZ0VHJpZ2dlcn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX29ubGVmdHRyaWdnZXJjaGFuZ2VkJiZ0aGlzLl9sZWZ0VHJpZ2dlciE9PWEmJnRoaXMuX29ubGVmdHRyaWdnZXJjaGFuZ2VkKGEpLHRoaXMuX2xlZnRUcmlnZ2VyPWF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwicmlnaHRUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yaWdodFRyaWdnZXJ9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9vbnJpZ2h0dHJpZ2dlcmNoYW5nZWQmJnRoaXMuX3JpZ2h0VHJpZ2dlciE9PWEmJnRoaXMuX29ucmlnaHR0cmlnZ2VyY2hhbmdlZChhKSx0aGlzLl9yaWdodFRyaWdnZXI9YX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLnByb3RvdHlwZS5vbmJ1dHRvbmRvd249ZnVuY3Rpb24oYSl7dGhpcy5fb25idXR0b25kb3duPWF9LGIucHJvdG90eXBlLm9uYnV0dG9udXA9ZnVuY3Rpb24oYSl7dGhpcy5fb25idXR0b251cD1hfSxiLnByb3RvdHlwZS5vbmRwYWRkb3duPWZ1bmN0aW9uKGEpe3RoaXMuX29uZHBhZGRvd249YX0sYi5wcm90b3R5cGUub25kcGFkdXA9ZnVuY3Rpb24oYSl7dGhpcy5fb25kcGFkdXA9YX0sYi5wcm90b3R5cGUuX3NldEJ1dHRvblZhbHVlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYSE9PWImJih0aGlzLl9vbmJ1dHRvbmRvd24mJjE9PT1hJiZ0aGlzLl9vbmJ1dHRvbmRvd24oYyksdGhpcy5fb25idXR0b251cCYmMD09PWEmJnRoaXMuX29uYnV0dG9udXAoYykpLGF9LGIucHJvdG90eXBlLl9zZXREUGFkVmFsdWU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhIT09YiYmKHRoaXMuX29uZHBhZGRvd24mJjE9PT1hJiZ0aGlzLl9vbmRwYWRkb3duKGMpLHRoaXMuX29uZHBhZHVwJiYwPT09YSYmdGhpcy5fb25kcGFkdXAoYykpLGF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvbkFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbkF9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25BPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uQSwwKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25CXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25CfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fYnV0dG9uQj10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvbkIsMSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uWFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uWH0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvblg9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25YLDIpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvbllcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbll9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25ZPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uWSwzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25TdGFydFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uU3RhcnR9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25TdGFydD10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvblN0YXJ0LDQpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvbkJhY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbkJhY2t9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25CYWNrPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uQmFjayw1KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25MQlwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uTEJ9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25MQj10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvbkxCLDYpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvblJCXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25SQn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvblJCPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uUkIsNyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uTGVmdFN0aWNrXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25MZWZ0U3RpY2t9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25MZWZ0U3RpY2s9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25MZWZ0U3RpY2ssOCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uUmlnaHRTdGlja1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uUmlnaHRTdGlja30sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvblJpZ2h0U3RpY2s9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25SaWdodFN0aWNrLDkpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImRQYWRVcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZFBhZFVwfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fZFBhZFVwPXRoaXMuX3NldERQYWRWYWx1ZShhLHRoaXMuX2RQYWRVcCwwKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJkUGFkRG93blwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZFBhZERvd259LHNldDpmdW5jdGlvbihhKXt0aGlzLl9kUGFkRG93bj10aGlzLl9zZXREUGFkVmFsdWUoYSx0aGlzLl9kUGFkRG93biwxKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJkUGFkTGVmdFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZFBhZExlZnR9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9kUGFkTGVmdD10aGlzLl9zZXREUGFkVmFsdWUoYSx0aGlzLl9kUGFkTGVmdCwyKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJkUGFkUmlnaHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RQYWRSaWdodH0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2RQYWRSaWdodD10aGlzLl9zZXREUGFkVmFsdWUoYSx0aGlzLl9kUGFkUmlnaHQsMyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7YS5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyksdGhpcy5idXR0b25BPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1swXS52YWx1ZSx0aGlzLmJ1dHRvbkI9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzFdLnZhbHVlLHRoaXMuYnV0dG9uWD10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMl0udmFsdWUsdGhpcy5idXR0b25ZPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1szXS52YWx1ZSx0aGlzLmJ1dHRvbkxCPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s0XS52YWx1ZSx0aGlzLmJ1dHRvblJCPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s1XS52YWx1ZSx0aGlzLmxlZnRUcmlnZ2VyPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s2XS52YWx1ZSx0aGlzLnJpZ2h0VHJpZ2dlcj10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbN10udmFsdWUsdGhpcy5idXR0b25CYWNrPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s4XS52YWx1ZSx0aGlzLmJ1dHRvblN0YXJ0PXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s5XS52YWx1ZSx0aGlzLmJ1dHRvbkxlZnRTdGljaz10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMTBdLnZhbHVlLHRoaXMuYnV0dG9uUmlnaHRTdGljaz10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMTFdLnZhbHVlLHRoaXMuZFBhZFVwPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1sxMl0udmFsdWUsdGhpcy5kUGFkRG93bj10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMTNdLnZhbHVlLHRoaXMuZFBhZExlZnQ9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzE0XS52YWx1ZSx0aGlzLmRQYWRSaWdodD10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMTVdLnZhbHVlfSxifShkKSk7YS5YYm94MzYwUGFkPWZ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlKXt2YXIgZj10aGlzO2IuY2FsbCh0aGlzLGMsZCxlKSx0aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eT0yMDAsdGhpcy5tb3ZlU2Vuc2liaWxpdHk9NzUsdGhpcy5fZ2FtZXBhZHM9bmV3IGEuR2FtZXBhZHMoZnVuY3Rpb24oYSl7Zi5fb25OZXdHYW1lQ29ubmVjdGVkKGEpfSl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9vbk5ld0dhbWVDb25uZWN0ZWQ9ZnVuY3Rpb24oYSl7MD09PWEuaW5kZXgmJih0aGlzLl9nYW1lcGFkPWEpfSxjLnByb3RvdHlwZS5fY2hlY2tJbnB1dHM9ZnVuY3Rpb24oKXtpZih0aGlzLl9nYW1lcGFkKXt2YXIgYj10aGlzLl9nYW1lcGFkLmxlZnRTdGljayxjPWIueC90aGlzLm1vdmVTZW5zaWJpbGl0eSxkPWIueS90aGlzLm1vdmVTZW5zaWJpbGl0eTtiLng9TWF0aC5hYnMoYyk+LjAwNT8wK2M6MCxiLnk9TWF0aC5hYnMoZCk+LjAwNT8wK2Q6MDt2YXIgZT10aGlzLl9nYW1lcGFkLnJpZ2h0U3RpY2ssZj1lLngvdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHksZz1lLnkvdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHk7ZS54PU1hdGguYWJzKGYpPi4wMDE/MCtmOjAsZS55PU1hdGguYWJzKGcpPi4wMDE/MCtnOjA7dmFyIGg9YS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGwodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCwwKSxpPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhuZXcgYS5WZWN0b3IzKGIueCwwLC1iLnkpLGgpO3RoaXMuY2FtZXJhRGlyZWN0aW9uPXRoaXMuY2FtZXJhRGlyZWN0aW9uLmFkZChpKSx0aGlzLmNhbWVyYVJvdGF0aW9uPXRoaXMuY2FtZXJhUm90YXRpb24uYWRkKG5ldyBhLlZlY3RvcjMoZS55LGUueCwwKSl9fSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fZ2FtZXBhZHMuZGlzcG9zZSgpfSxjfShhLkZyZWVDYW1lcmEpO2EuR2FtZXBhZENhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGUmJihlPSExKSxiLmNhbGwodGhpcyxjLGQpLHRoaXMuY29sb3I9bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLl9pbmRpY2VzPW5ldyBBcnJheSx0aGlzLl9jb2xvclNoYWRlcj1uZXcgYS5TaGFkZXJNYXRlcmlhbChcImNvbG9yU2hhZGVyXCIsZCxcImNvbG9yXCIse2F0dHJpYnV0ZXM6W1wicG9zaXRpb25cIl0sdW5pZm9ybXM6W1wid29ybGRWaWV3UHJvamVjdGlvblwiLFwiY29sb3JcIl19KX1yZXR1cm4gX19leHRlbmRzKGMsYiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwibWF0ZXJpYWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbG9yU2hhZGVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcImlzUGlja2FibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwiY2hlY2tDb2xsaXNpb25zXCIse2dldDpmdW5jdGlvbigpe3JldHVybiExfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLl9iaW5kPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLGM9dGhpcy5fZ2VvbWV0cnkuZ2V0SW5kZXhCdWZmZXIoKTtiLmJpbmRCdWZmZXJzKHRoaXMuX2dlb21ldHJ5LmdldFZlcnRleEJ1ZmZlcihhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpLmdldEJ1ZmZlcigpLGMsWzNdLDEyLHRoaXMuX2NvbG9yU2hhZGVyLmdldEVmZmVjdCgpKSx0aGlzLl9jb2xvclNoYWRlci5zZXRDb2xvcjMoXCJjb2xvclwiLHRoaXMuY29sb3IpfSxjLnByb3RvdHlwZS5fZHJhdz1mdW5jdGlvbihhKXtpZih0aGlzLl9nZW9tZXRyeSYmdGhpcy5fZ2VvbWV0cnkuZ2V0VmVydGV4QnVmZmVycygpJiZ0aGlzLl9nZW9tZXRyeS5nZXRJbmRleEJ1ZmZlcigpKXt2YXIgYj10aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCk7Yi5kcmF3KCExLGEuaW5kZXhTdGFydCxhLmluZGV4Q291bnQpfX0sYy5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbigpe3JldHVybiBudWxsfSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe3RoaXMuX2NvbG9yU2hhZGVyLmRpc3Bvc2UoKSxiLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyxhKX0sY30oYS5NZXNoKTthLkxpbmVzTWVzaD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO21vZHVsZS5leHBvcnRzPUJBQllMT047IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjExLjJcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTEyLTE3VDE1OjI3WlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciB3aW5kb3cgaXMgcHJlc2VudCxcblx0XHQvLyBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5XG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBpbmhlcmVudGx5IHBvc3NlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgalF1ZXJ5LW1ha2luZyBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCB3aW5kb3dcblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mb1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIENhbid0IGRvIHRoaXMgYmVjYXVzZSBzZXZlcmFsIGFwcHMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vXG5cbnZhciBkZWxldGVkSWRzID0gW107XG5cbnZhciBzbGljZSA9IGRlbGV0ZWRJZHMuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBkZWxldGVkSWRzLmNvbmNhdDtcblxudmFyIHB1c2ggPSBkZWxldGVkSWRzLnB1c2g7XG5cbnZhciBpbmRleE9mID0gZGVsZXRlZElkcy5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIxLjExLjJcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuXHQvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBkZWxldGVkSWRzLnNvcnQsXG5cdHNwbGljZTogZGVsZXRlZElkcy5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImFycmF5XCI7XG5cdH0sXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0LyoganNoaW50IGVxZXFlcTogZmFsc2UgKi9cblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICsgMSkgPj0gMDtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBNdXN0IGJlIGFuIE9iamVjdC5cblx0XHQvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuXHRcdGlmICggIW9iaiB8fCBqUXVlcnkudHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwob2JqLCBcImNvbnN0cnVjdG9yXCIpICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdC8vIElFOCw5IFdpbGwgdGhyb3cgZXhjZXB0aW9ucyBvbiBjZXJ0YWluIGhvc3Qgb2JqZWN0cyAjOTg5N1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBIYW5kbGUgaXRlcmF0aW9uIG92ZXIgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLlxuXHRcdGlmICggc3VwcG9ydC5vd25MYXN0ICkge1xuXHRcdFx0Zm9yICgga2V5IGluIG9iaiApIHtcblx0XHRcdFx0cmV0dXJuIGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHRcdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdC8vIFdvcmthcm91bmRzIGJhc2VkIG9uIGZpbmRpbmdzIGJ5IEppbSBEcmlzY29sbFxuXHQvLyBodHRwOi8vd2VibG9ncy5qYXZhLm5ldC9ibG9nL2RyaXNjb2xsL2FyY2hpdmUvMjAwOS8wOS8wOC9ldmFsLWphdmFzY3JpcHQtZ2xvYmFsLWNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCBkYXRhICYmIGpRdWVyeS50cmltKCBkYXRhICkgKSB7XG5cdFx0XHQvLyBXZSB1c2UgZXhlY1NjcmlwdCBvbiBJbnRlcm5ldCBFeHBsb3JlclxuXHRcdFx0Ly8gV2UgdXNlIGFuIGFub255bW91cyBmdW5jdGlvbiBzbyB0aGF0IGNvbnRleHQgaXMgd2luZG93XG5cdFx0XHQvLyByYXRoZXIgdGhhbiBqUXVlcnkgaW4gRmlyZWZveFxuXHRcdFx0KCB3aW5kb3cuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0d2luZG93WyBcImV2YWxcIiBdLmNhbGwoIHdpbmRvdywgZGF0YSApO1xuXHRcdFx0fSApKCBkYXRhICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBJRTw5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHZhciBsZW47XG5cblx0XHRpZiAoIGFyciApIHtcblx0XHRcdGlmICggaW5kZXhPZiApIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Ly8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuXHRcdFx0XHRpZiAoIGkgaW4gYXJyICYmIGFyclsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHR3aGlsZSAoIGogPCBsZW4gKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGorKyBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBXb3JrYXJvdW5kIGNhc3Rpbmcgb2YgLmxlbmd0aCB0byBOYU4gb24gb3RoZXJ3aXNlIGFycmF5bGlrZSBvYmplY3RzIChlLmcuLCBOb2RlTGlzdHMpXG5cdFx0aWYgKCBsZW4gIT09IGxlbiApIHtcblx0XHRcdHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgYXJncywgcHJveHksIHRtcDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICsoIG5ldyBEYXRlKCkgKTtcblx0fSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cdHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4wLXByZVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE0LTEyLTE2XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xuXHRjaGFyYWN0ZXJFbmNvZGluZyA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcblx0Ly8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidypcIiApICsgXCIpXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXG5cdFx0Ly8gUVNBIHZhcnNcblx0XHRpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcblxuXHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZTtcblxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGlmICggIXNlZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIHdoZW4gcG9zc2libGUgKGUuZy4sIG5vdCB1bmRlciBEb2N1bWVudEZyYWdtZW50KVxuXHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuXHRcdFx0XHRcdGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIi5DTEFTU1wiKVxuXHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBRU0EgcGF0aFxuXHRcdGlmICggc3VwcG9ydC5xc2EgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XG5cdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdG5ld1NlbGVjdG9yID0gbm9kZVR5cGUgIT09IDEgJiYgc2VsZWN0b3I7XG5cblx0XHRcdC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuXHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXG5cdFx0XHQvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcblx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSApIHtcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIG5pZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5pZCA9IFwiW2lkPSdcIiArIG5pZCArIFwiJ10gXCI7XG5cblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0O1xuXHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggIW9sZCApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGF0dHJzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFNldCBvdXIgZG9jdW1lbnRcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XG5cblx0Ly8gU3VwcG9ydDogSUU+OFxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXG5cdC8vIElFIHdpbGwgdGhyb3cgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcblx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XG5cdFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTdXBwb3J0IHRlc3RzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvYyApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcZl0nIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjIrLCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuNytcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8IChwYXJlbnRbIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXRlckNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucyApIHtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xuXG5cdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApICYmICsrZGlmZiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGRpciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gb3V0ZXJDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHF1YWxpZmllciApID49IDAgKSAhPT0gbm90O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkpO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRsZW4gPSBzZWxmLmxlbmd0aDtcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXG5cdGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gXCI8XCIgJiYgc2VsZWN0b3IuY2hhckF0KCBzZWxlY3Rvci5sZW5ndGggLSAxICkgPT09IFwiPlwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbMV0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbMV0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuXHRcdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgIT09IG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcm9vdGpRdWVyeS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlIGluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHRjdXIgPSBlbGVtWyBkaXIgXTtcblxuXHRcdHdoaWxlICggY3VyICYmIGN1ci5ub2RlVHlwZSAhPT0gOSAmJiAodW50aWwgPT09IHVuZGVmaW5lZCB8fCBjdXIubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeSggY3VyICkuaXMoIHVudGlsICkpICkge1xuXHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHR9XG5cdFx0XHRjdXIgPSBjdXJbZGlyXTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH0sXG5cblx0c2libGluZzogZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdFx0dmFyIHIgPSBbXTtcblxuXHRcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdFx0ci5wdXNoKCBuICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0dGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsZW4gPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxuXHQvLyB0aGUgbWF0Y2hlZCBzZXQgb2YgZWxlbWVudHNcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gaW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KCB0aGlzWzBdLCBqUXVlcnkoIGVsZW0gKSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBqUXVlcnkuaW5BcnJheShcblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbSwgdGhpcyApO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdGRvIHtcblx0XHRjdXIgPSBjdXJbIGRpciBdO1xuXHR9IHdoaWxlICggY3VyICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApO1xuXG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApID9cblx0XHRcdGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG5cdFx0XHRqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHJldCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0cmV0ID0galF1ZXJ5LnVuaXF1ZSggcmV0ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldCA9IHJldC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxuXHRcdG1lbW9yeSxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoLS1yZW1haW5pbmcpICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cblx0XHRpZiAoICFkb2N1bWVudC5ib2R5ICkge1xuXHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogQ2xlYW4tdXAgbWV0aG9kIGZvciBkb20gcmVhZHkgZXZlbnRzXG4gKi9cbmZ1bmN0aW9uIGRldGFjaCgpIHtcblx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0fSBlbHNlIHtcblx0XHRkb2N1bWVudC5kZXRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG5cdFx0d2luZG93LmRldGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0Ly8gcmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIGlzIGdvb2QgZW5vdWdoIGZvciB1cyB0byBjYWxsIHRoZSBkb20gcmVhZHkgaW4gb2xkSUVcblx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyIHx8IGV2ZW50LnR5cGUgPT09IFwibG9hZFwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRkZXRhY2goKTtcblx0XHRqUXVlcnkucmVhZHkoKTtcblx0fVxufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gd2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHRzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdC8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWRcblx0XHR9IGVsc2UgaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXG5cdFx0Ly8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFbnN1cmUgZmlyaW5nIGJlZm9yZSBvbmxvYWQsIG1heWJlIGxhdGUgYnV0IHNhZmUgYWxzbyBmb3IgaWZyYW1lc1xuXHRcdFx0ZG9jdW1lbnQuYXR0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9ubG9hZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gSWYgSUUgYW5kIG5vdCBhIGZyYW1lXG5cdFx0XHQvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG5cdFx0XHR2YXIgdG9wID0gZmFsc2U7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRvcCA9IHdpbmRvdy5mcmFtZUVsZW1lbnQgPT0gbnVsbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHRcdGlmICggdG9wICYmIHRvcC5kb1Njcm9sbCApIHtcblx0XHRcdFx0KGZ1bmN0aW9uIGRvU2Nyb2xsQ2hlY2soKSB7XG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LmlzUmVhZHkgKSB7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgdHJpY2sgYnkgRGllZ28gUGVyaW5pXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvXG5cdFx0XHRcdFx0XHRcdHRvcC5kb1Njcm9sbChcImxlZnRcIik7XG5cdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoIGRvU2Nyb2xsQ2hlY2ssIDUwICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGRldGFjaCBhbGwgZG9tIHJlYWR5IGV2ZW50c1xuXHRcdFx0XHRcdFx0ZGV0YWNoKCk7XG5cblx0XHRcdFx0XHRcdC8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9uc1xuXHRcdFx0XHRcdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuXG52YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDtcblxuXG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIEl0ZXJhdGlvbiBvdmVyIG9iamVjdCdzIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBpdHMgb3duXG52YXIgaTtcbmZvciAoIGkgaW4galF1ZXJ5KCBzdXBwb3J0ICkgKSB7XG5cdGJyZWFrO1xufVxuc3VwcG9ydC5vd25MYXN0ID0gaSAhPT0gXCIwXCI7XG5cbi8vIE5vdGU6IG1vc3Qgc3VwcG9ydCB0ZXN0cyBhcmUgZGVmaW5lZCBpbiB0aGVpciByZXNwZWN0aXZlIG1vZHVsZXMuXG4vLyBmYWxzZSB1bnRpbCB0aGUgdGVzdCBpcyBydW5cbnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9IGZhbHNlO1xuXG4vLyBFeGVjdXRlIEFTQVAgaW4gY2FzZSB3ZSBuZWVkIHRvIHNldCBib2R5LnN0eWxlLnpvb21cbmpRdWVyeShmdW5jdGlvbigpIHtcblx0Ly8gTWluaWZpZWQ6IHZhciBhLGIsYyxkXG5cdHZhciB2YWwsIGRpdiwgYm9keSwgY29udGFpbmVyO1xuXG5cdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdO1xuXHRpZiAoICFib2R5IHx8ICFib2R5LnN0eWxlICkge1xuXHRcdC8vIFJldHVybiBmb3IgZnJhbWVzZXQgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBib2R5XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU2V0dXBcblx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweFwiO1xuXHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0Ly8gQ2hlY2sgaWYgbmF0aXZlbHkgYmxvY2stbGV2ZWwgZWxlbWVudHMgYWN0IGxpa2UgaW5saW5lLWJsb2NrXG5cdFx0Ly8gZWxlbWVudHMgd2hlbiBzZXR0aW5nIHRoZWlyIGRpc3BsYXkgdG8gJ2lubGluZScgYW5kIGdpdmluZ1xuXHRcdC8vIHRoZW0gbGF5b3V0XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcImRpc3BsYXk6aW5saW5lO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjFcIjtcblxuXHRcdHN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCA9IHZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMztcblx0XHRpZiAoIHZhbCApIHtcblx0XHRcdC8vIFByZXZlbnQgSUUgNiBmcm9tIGFmZmVjdGluZyBsYXlvdXQgZm9yIHBvc2l0aW9uZWQgZWxlbWVudHMgIzExMDQ4XG5cdFx0XHQvLyBQcmV2ZW50IElFIGZyb20gc2hyaW5raW5nIHRoZSBib2R5IGluIElFIDcgbW9kZSAjMTI4Njlcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdGJvZHkuc3R5bGUuem9vbSA9IDE7XG5cdFx0fVxuXHR9XG5cblx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG59KTtcblxuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEV4ZWN1dGUgdGhlIHRlc3Qgb25seSBpZiBub3QgYWxyZWFkeSBleGVjdXRlZCBpbiBhbm90aGVyIG1vZHVsZS5cblx0aWYgKHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9PSBudWxsKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGRlbGV0ZSBkaXYudGVzdDtcblx0XHR9IGNhdGNoKCBlICkge1xuXHRcdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGNhbiBoYXZlIGRhdGFcbiAqL1xualF1ZXJ5LmFjY2VwdERhdGEgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vRGF0YSA9IGpRdWVyeS5ub0RhdGFbIChlbGVtLm5vZGVOYW1lICsgXCIgXCIpLnRvTG93ZXJDYXNlKCkgXSxcblx0XHRub2RlVHlwZSA9ICtlbGVtLm5vZGVUeXBlIHx8IDE7XG5cblx0Ly8gRG8gbm90IHNldCBkYXRhIG9uIG5vbi1lbGVtZW50IERPTSBub2RlcyBiZWNhdXNlIGl0IHdpbGwgbm90IGJlIGNsZWFyZWQgKCM4MzM1KS5cblx0cmV0dXJuIG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ID9cblx0XHRmYWxzZSA6XG5cblx0XHQvLyBOb2RlcyBhY2NlcHQgZGF0YSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZDsgcmVqZWN0aW9uIGNhbiBiZSBjb25kaXRpb25hbFxuXHRcdCFub0RhdGEgfHwgbm9EYXRhICE9PSB0cnVlICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NpZFwiKSA9PT0gbm9EYXRhO1xufTtcblxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdHZhciBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtLCBrZXksIGRhdGEgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG4vLyBjaGVja3MgYSBjYWNoZSBvYmplY3QgZm9yIGVtcHRpbmVzc1xuZnVuY3Rpb24gaXNFbXB0eURhdGFPYmplY3QoIG9iaiApIHtcblx0dmFyIG5hbWU7XG5cdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXG5cdFx0Ly8gaWYgdGhlIHB1YmxpYyBkYXRhIG9iamVjdCBpcyBlbXB0eSwgdGhlIHByaXZhdGUgaXMgc3RpbGwgZW1wdHlcblx0XHRpZiAoIG5hbWUgPT09IFwiZGF0YVwiICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvYmpbbmFtZV0gKSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoIG5hbWUgIT09IFwidG9KU09OXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgcHZ0IC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByZXQsIHRoaXNDYWNoZSxcblx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXG5cdFx0Ly8gV2UgaGF2ZSB0byBoYW5kbGUgRE9NIG5vZGVzIGFuZCBKUyBvYmplY3RzIGRpZmZlcmVudGx5IGJlY2F1c2UgSUU2LTdcblx0XHQvLyBjYW4ndCBHQyBvYmplY3QgcmVmZXJlbmNlcyBwcm9wZXJseSBhY3Jvc3MgdGhlIERPTS1KUyBib3VuZGFyeVxuXHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIHRoZSBnbG9iYWwgalF1ZXJ5IGNhY2hlOyBKUyBvYmplY3QgZGF0YSBpc1xuXHRcdC8vIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBvYmplY3Qgc28gR0MgY2FuIG9jY3VyIGF1dG9tYXRpY2FsbHlcblx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHQvLyBPbmx5IGRlZmluaW5nIGFuIElEIGZvciBKUyBvYmplY3RzIGlmIGl0cyBjYWNoZSBhbHJlYWR5IGV4aXN0cyBhbGxvd3Ncblx0XHQvLyB0aGUgY29kZSB0byBzaG9ydGN1dCBvbiB0aGUgc2FtZSBwYXRoIGFzIGEgRE9NIG5vZGUgd2l0aCBubyBjYWNoZVxuXHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXk7XG5cblx0Ly8gQXZvaWQgZG9pbmcgYW55IG1vcmUgd29yayB0aGFuIHdlIG5lZWQgdG8gd2hlbiB0cnlpbmcgdG8gZ2V0IGRhdGEgb24gYW5cblx0Ly8gb2JqZWN0IHRoYXQgaGFzIG5vIGRhdGEgYXQgYWxsXG5cdGlmICggKCFpZCB8fCAhY2FjaGVbaWRdIHx8ICghcHZ0ICYmICFjYWNoZVtpZF0uZGF0YSkpICYmIGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoICFpZCApIHtcblx0XHQvLyBPbmx5IERPTSBub2RlcyBuZWVkIGEgbmV3IHVuaXF1ZSBJRCBmb3IgZWFjaCBlbGVtZW50IHNpbmNlIHRoZWlyIGRhdGFcblx0XHQvLyBlbmRzIHVwIGluIHRoZSBnbG9iYWwgY2FjaGVcblx0XHRpZiAoIGlzTm9kZSApIHtcblx0XHRcdGlkID0gZWxlbVsgaW50ZXJuYWxLZXkgXSA9IGRlbGV0ZWRJZHMucG9wKCkgfHwgalF1ZXJ5Lmd1aWQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWQgPSBpbnRlcm5hbEtleTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblx0XHQvLyBBdm9pZCBleHBvc2luZyBqUXVlcnkgbWV0YWRhdGEgb24gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIHRoZSBvYmplY3Rcblx0XHQvLyBpcyBzZXJpYWxpemVkIHVzaW5nIEpTT04uc3RyaW5naWZ5XG5cdFx0Y2FjaGVbIGlkIF0gPSBpc05vZGUgPyB7fSA6IHsgdG9KU09OOiBqUXVlcnkubm9vcCB9O1xuXHR9XG5cblx0Ly8gQW4gb2JqZWN0IGNhbiBiZSBwYXNzZWQgdG8galF1ZXJ5LmRhdGEgaW5zdGVhZCBvZiBhIGtleS92YWx1ZSBwYWlyOyB0aGlzIGdldHNcblx0Ly8gc2hhbGxvdyBjb3BpZWQgb3ZlciBvbnRvIHRoZSBleGlzdGluZyBjYWNoZVxuXHRpZiAoIHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0aWYgKCBwdnQgKSB7XG5cdFx0XHRjYWNoZVsgaWQgXSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhY2hlWyBpZCBdLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXS5kYXRhLCBuYW1lICk7XG5cdFx0fVxuXHR9XG5cblx0dGhpc0NhY2hlID0gY2FjaGVbIGlkIF07XG5cblx0Ly8galF1ZXJ5IGRhdGEoKSBpcyBzdG9yZWQgaW4gYSBzZXBhcmF0ZSBvYmplY3QgaW5zaWRlIHRoZSBvYmplY3QncyBpbnRlcm5hbCBkYXRhXG5cdC8vIGNhY2hlIGluIG9yZGVyIHRvIGF2b2lkIGtleSBjb2xsaXNpb25zIGJldHdlZW4gaW50ZXJuYWwgZGF0YSBhbmQgdXNlci1kZWZpbmVkXG5cdC8vIGRhdGEuXG5cdGlmICggIXB2dCApIHtcblx0XHRpZiAoICF0aGlzQ2FjaGUuZGF0YSApIHtcblx0XHRcdHRoaXNDYWNoZS5kYXRhID0ge307XG5cdFx0fVxuXG5cdFx0dGhpc0NhY2hlID0gdGhpc0NhY2hlLmRhdGE7XG5cdH1cblxuXHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzQ2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSBdID0gZGF0YTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBib3RoIGNvbnZlcnRlZC10by1jYW1lbCBhbmQgbm9uLWNvbnZlcnRlZCBkYXRhIHByb3BlcnR5IG5hbWVzXG5cdC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXG5cdGlmICggdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHQvLyBGaXJzdCBUcnkgdG8gZmluZCBhcy1pcyBwcm9wZXJ0eSBkYXRhXG5cdFx0cmV0ID0gdGhpc0NhY2hlWyBuYW1lIF07XG5cblx0XHQvLyBUZXN0IGZvciBudWxsfHVuZGVmaW5lZCBwcm9wZXJ0eSBkYXRhXG5cdFx0aWYgKCByZXQgPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gVHJ5IHRvIGZpbmQgdGhlIGNhbWVsQ2FzZWQgcHJvcGVydHlcblx0XHRcdHJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IHRoaXNDYWNoZTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSwgcHZ0ICkge1xuXHRpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciB0aGlzQ2FjaGUsIGksXG5cdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblx0XHRpZCA9IGlzTm9kZSA/IGVsZW1bIGpRdWVyeS5leHBhbmRvIF0gOiBqUXVlcnkuZXhwYW5kbztcblxuXHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IG5vIGNhY2hlIGVudHJ5IGZvciB0aGlzIG9iamVjdCwgdGhlcmUgaXMgbm9cblx0Ly8gcHVycG9zZSBpbiBjb250aW51aW5nXG5cdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggbmFtZSApIHtcblxuXHRcdHRoaXNDYWNoZSA9IHB2dCA/IGNhY2hlWyBpZCBdIDogY2FjaGVbIGlkIF0uZGF0YTtcblxuXHRcdGlmICggdGhpc0NhY2hlICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgbmFtZXMgZm9yIGRhdGEga2V5c1xuXHRcdFx0aWYgKCAhalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblxuXHRcdFx0XHQvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIG5hbWUgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHNwbGl0IHRoZSBjYW1lbCBjYXNlZCB2ZXJzaW9uIGJ5IHNwYWNlcyB1bmxlc3MgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0c1xuXHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBbIG5hbWUgXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IG5hbWUuY29uY2F0KCBqUXVlcnkubWFwKCBuYW1lLCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IG5hbWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzQ2FjaGVbIG5hbWVbaV0gXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gZGF0YSBsZWZ0IGluIHRoZSBjYWNoZSwgd2Ugd2FudCB0byBjb250aW51ZVxuXHRcdFx0Ly8gYW5kIGxldCB0aGUgY2FjaGUgb2JqZWN0IGl0c2VsZiBnZXQgZGVzdHJveWVkXG5cdFx0XHRpZiAoIHB2dCA/ICFpc0VtcHR5RGF0YU9iamVjdCh0aGlzQ2FjaGUpIDogIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHRoaXNDYWNoZSkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0aWYgKCAhcHZ0ICkge1xuXHRcdGRlbGV0ZSBjYWNoZVsgaWQgXS5kYXRhO1xuXG5cdFx0Ly8gRG9uJ3QgZGVzdHJveSB0aGUgcGFyZW50IGNhY2hlIHVubGVzcyB0aGUgaW50ZXJuYWwgZGF0YSBvYmplY3Rcblx0XHQvLyBoYWQgYmVlbiB0aGUgb25seSB0aGluZyBsZWZ0IGluIGl0XG5cdFx0aWYgKCAhaXNFbXB0eURhdGFPYmplY3QoIGNhY2hlWyBpZCBdICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0Ly8gRGVzdHJveSB0aGUgY2FjaGVcblx0aWYgKCBpc05vZGUgKSB7XG5cdFx0alF1ZXJ5LmNsZWFuRGF0YSggWyBlbGVtIF0sIHRydWUgKTtcblxuXHQvLyBVc2UgZGVsZXRlIHdoZW4gc3VwcG9ydGVkIGZvciBleHBhbmRvcyBvciBgY2FjaGVgIGlzIG5vdCBhIHdpbmRvdyBwZXIgaXNXaW5kb3cgKCMxMDA4MClcblx0LyoganNoaW50IGVxZXFlcTogZmFsc2UgKi9cblx0fSBlbHNlIGlmICggc3VwcG9ydC5kZWxldGVFeHBhbmRvIHx8IGNhY2hlICE9IGNhY2hlLndpbmRvdyApIHtcblx0XHQvKiBqc2hpbnQgZXFlcWVxOiB0cnVlICovXG5cdFx0ZGVsZXRlIGNhY2hlWyBpZCBdO1xuXG5cdC8vIFdoZW4gYWxsIGVsc2UgZmFpbHMsIG51bGxcblx0fSBlbHNlIHtcblx0XHRjYWNoZVsgaWQgXSA9IG51bGw7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNhY2hlOiB7fSxcblxuXHQvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIChzcGFjZS1zdWZmaXhlZCB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlIGNvbGxpc2lvbnMpXG5cdC8vIHRocm93IHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMgaWYgeW91IGF0dGVtcHQgdG8gc2V0IGV4cGFuZG8gcHJvcGVydGllc1xuXHRub0RhdGE6IHtcblx0XHRcImFwcGxldCBcIjogdHJ1ZSxcblx0XHRcImVtYmVkIFwiOiB0cnVlLFxuXHRcdC8vIC4uLmJ1dCBGbGFzaCBvYmplY3RzICh3aGljaCBoYXZlIHRoaXMgY2xhc3NpZCkgKmNhbiogaGFuZGxlIGV4cGFuZG9zXG5cdFx0XCJvYmplY3QgXCI6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJcblx0fSxcblxuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRlbGVtID0gZWxlbS5ub2RlVHlwZSA/IGpRdWVyeS5jYWNoZVsgZWxlbVtqUXVlcnkuZXhwYW5kb10gXSA6IGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XG5cdFx0cmV0dXJuICEhZWxlbSAmJiAhaXNFbXB0eURhdGFPYmplY3QoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEsIHRydWUgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsUmVtb3ZlRGF0YSggZWxlbSwgbmFtZSwgdHJ1ZSApO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gU3BlY2lhbCBleHBlY3Rpb25zIG9mIC5kYXRhIGJhc2ljYWxseSB0aHdhcnQgalF1ZXJ5LmFjY2Vzcyxcblx0XHQvLyBzbyBpbXBsZW1lbnQgdGhlIHJlbGV2YW50IGJlaGF2aW9yIG91cnNlbHZlc1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YSggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID9cblxuXHRcdFx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0pIDpcblxuXHRcdFx0Ly8gR2V0cyBvbmUgdmFsdWVcblx0XHRcdC8vIFRyeSB0byBmZXRjaCBhbnkgaW50ZXJuYWxseSBzdG9yZWQgZGF0YSBmaXJzdFxuXHRcdFx0ZWxlbSA/IGRhdGFBdHRyKCBlbGVtLCBrZXksIGpRdWVyeS5kYXRhKCBlbGVtLCBrZXkgKSApIDogdW5kZWZpbmVkO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBqUXVlcnkuX2RhdGEoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheShkYXRhKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIG5vdCBpbnRlbmRlZCBmb3IgcHVibGljIGNvbnN1bXB0aW9uIC0gZ2VuZXJhdGVzIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybnMgdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSApIHx8IGpRdWVyeS5fZGF0YSggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCB0eXBlICsgXCJxdWV1ZVwiICk7XG5cdFx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwga2V5ICk7XG5cdFx0XHR9KVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9KTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGpRdWVyeS5fZGF0YSggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSk7XG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0galF1ZXJ5LmFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0alF1ZXJ5LmFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGZuKCBlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoIGVsZW1zW2ldLCBpLCBmbiggZWxlbXNbaV0sIGtleSApICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbmd0aCA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHQvLyBNaW5pZmllZDogdmFyIGEsYixjXG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHQvLyBTZXR1cFxuXHRkaXYuaW5uZXJIVE1MID0gXCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIjtcblxuXHQvLyBJRSBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gLmlubmVySFRNTCBpcyB1c2VkXG5cdHN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgPSBkaXYuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMztcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuXHQvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXG5cdHN1cHBvcnQudGJvZHkgPSAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRib2R5XCIgKS5sZW5ndGg7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG5cdC8vIFRoaXMgcmVxdWlyZXMgYSB3cmFwcGVyIGVsZW1lbnQgaW4gSUVcblx0c3VwcG9ydC5odG1sU2VyaWFsaXplID0gISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwibGlua1wiICkubGVuZ3RoO1xuXG5cdC8vIE1ha2VzIHN1cmUgY2xvbmluZyBhbiBodG1sNSBlbGVtZW50IGRvZXMgbm90IGNhdXNlIHByb2JsZW1zXG5cdC8vIFdoZXJlIG91dGVySFRNTCBpcyB1bmRlZmluZWQsIHRoaXMgc3RpbGwgd29ya3Ncblx0c3VwcG9ydC5odG1sNUNsb25lID1cblx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm5hdlwiICkuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSBcIjw6bmF2PjwvOm5hdj5cIjtcblxuXHQvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuXHQvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXHRpbnB1dC5jaGVja2VkID0gdHJ1ZTtcblx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdHN1cHBvcnQuYXBwZW5kQ2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0Ly8gU3VwcG9ydDogSUU2LUlFMTErXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gIzExMjE3IC0gV2ViS2l0IGxvc2VzIGNoZWNrIHdoZW4gdGhlIG5hbWUgaXMgYWZ0ZXIgdGhlIGNoZWNrZWQgYXR0cmlidXRlXG5cdGZyYWdtZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0IHR5cGU9J3JhZGlvJyBjaGVja2VkPSdjaGVja2VkJyBuYW1lPSd0Jy8+XCI7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDUuMSwgaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXG5cdC8vIG9sZCBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gT3BlcmEgZG9lcyBub3QgY2xvbmUgZXZlbnRzIChhbmQgdHlwZW9mIGRpdi5hdHRhY2hFdmVudCA9PT0gdW5kZWZpbmVkKS5cblx0Ly8gSUU5LTEwIGNsb25lcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50LCBidXQgdGhleSBkb24ndCB0cmlnZ2VyIHdpdGggLmNsaWNrKClcblx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSB0cnVlO1xuXHRpZiAoIGRpdi5hdHRhY2hFdmVudCApIHtcblx0XHRkaXYuYXR0YWNoRXZlbnQoIFwib25jbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHN1cHBvcnQubm9DbG9uZUV2ZW50ID0gZmFsc2U7XG5cdFx0fSk7XG5cblx0XHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xpY2soKTtcblx0fVxuXG5cdC8vIEV4ZWN1dGUgdGhlIHRlc3Qgb25seSBpZiBub3QgYWxyZWFkeSBleGVjdXRlZCBpbiBhbm90aGVyIG1vZHVsZS5cblx0aWYgKHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9PSBudWxsKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGRlbGV0ZSBkaXYudGVzdDtcblx0XHR9IGNhdGNoKCBlICkge1xuXHRcdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGksIGV2ZW50TmFtZSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OSAobGFjayBzdWJtaXQvY2hhbmdlIGJ1YmJsZSksIEZpcmVmb3ggMjMrIChsYWNrIGZvY3VzaW4gZXZlbnQpXG5cdGZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIGNoYW5nZTogdHJ1ZSwgZm9jdXNpbjogdHJ1ZSB9KSB7XG5cdFx0ZXZlbnROYW1lID0gXCJvblwiICsgaTtcblxuXHRcdGlmICggIShzdXBwb3J0WyBpICsgXCJCdWJibGVzXCIgXSA9IGV2ZW50TmFtZSBpbiB3aW5kb3cpICkge1xuXHRcdFx0Ly8gQmV3YXJlIG9mIENTUCByZXN0cmljdGlvbnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUClcblx0XHRcdGRpdi5zZXRBdHRyaWJ1dGUoIGV2ZW50TmFtZSwgXCJ0XCIgKTtcblx0XHRcdHN1cHBvcnRbIGkgKyBcIkJ1YmJsZXNcIiBdID0gZGl2LmF0dHJpYnV0ZXNbIGV2ZW50TmFtZSBdLmV4cGFuZG8gPT09IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdGRpdiA9IG51bGw7XG59KSgpO1xuXG5cbnZhciByZm9ybUVsZW1zID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLFxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51KXxjbGljay8sXG5cdHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblx0XHR2YXIgdG1wLCBldmVudHMsIHQsIGhhbmRsZU9iakluLFxuXHRcdFx0c3BlY2lhbCwgZXZlbnRIYW5kbGUsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBzdHJ1bmRlZmluZWQgJiYgKCFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSkgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZXZlbnRIYW5kbGUuZWxlbSwgYXJndW1lbnRzICkgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0XHQvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZm4gdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggSUUgbm9uLW5hdGl2ZSBldmVudHNcblx0XHRcdGV2ZW50SGFuZGxlLmVsZW0gPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcblx0XHRlbGVtID0gbnVsbDtcblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblx0XHR2YXIgaiwgaGFuZGxlT2JqLCB0bXAsXG5cdFx0XHRvcmlnQ291bnQsIHQsIGV2ZW50cyxcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLFxuXHRcdFx0bmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cblx0XHRcdC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XG5cdFx0XHQvLyBzbyB1c2UgaXQgaW5zdGVhZCBvZiBkZWxldGVcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblx0XHR2YXIgaGFuZGxlLCBvbnR5cGUsIGN1cixcblx0XHRcdGJ1YmJsZVR5cGUsIHNwZWNpYWwsIHRtcCwgaSxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBDYW4ndCB1c2UgYW4gLmlzRnVuY3Rpb24oKSBjaGVjayBoZXJlIGJlY2F1c2UgSUU2LzcgZmFpbHMgdGhhdCB0ZXN0LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGVsZW1bIHR5cGUgXSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwjMTI1MTgpXG5cdFx0XHRcdFx0XHQvLyBvbmx5IHJlcHJvZHVjaWJsZSBvbiB3aW5YUCBJRTggbmF0aXZlLCBub3QgSUU5IGluIElFOCBtb2RlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCByZXQsIGhhbmRsZU9iaiwgbWF0Y2hlZCwgaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGpRdWVyeS5fZGF0YSggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvclxuXHRcdFx0XHQvLyAyKSBoYXZlIG5hbWVzcGFjZShzKSBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgc2VsLCBoYW5kbGVPYmosIG1hdGNoZXMsIGksXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHRcdFx0Zm9yICggOyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblx0XHRcdFx0LyoganNoaW50IGVxZXFlcTogdHJ1ZSAqL1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEZpeCB0YXJnZXQgcHJvcGVydHkgKCMxOTI1KVxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgMjMrLCBTYWZhcmk/XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBGb3IgbW91c2Uva2V5IGV2ZW50cywgbWV0YUtleT09ZmFsc2UgaWYgaXQncyB1bmRlZmluZWQgKCMzMzY4LCAjMTEzMjgpXG5cdFx0ZXZlbnQubWV0YUtleSA9ICEhZXZlbnQubWV0YUtleTtcblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGJvZHksIGV2ZW50RG9jLCBkb2MsXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcblx0XHRcdFx0ZnJvbUVsZW1lbnQgPSBvcmlnaW5hbC5mcm9tRWxlbWVudDtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcblx0XHRcdFx0ZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBvcmlnaW5hbC50b0VsZW1lbnQgOiBmcm9tRWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdFx0XHRcdC8vIElmIHdlIGVycm9yIG9uIGZvY3VzIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwgIzEyNTE4KSxcblx0XHRcdFx0XHRcdC8vIGxldCAudHJpZ2dlcigpIHJ1biB0aGUgaGFuZGxlcnNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICYmIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdFx0fVxuXHR9IDpcblx0ZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0XHR2YXIgbmFtZSA9IFwib25cIiArIHR5cGU7XG5cblx0XHRpZiAoIGVsZW0uZGV0YWNoRXZlbnQgKSB7XG5cblx0XHRcdC8vICM4NTQ1LCAjNzA1NCwgcHJldmVudGluZyBtZW1vcnkgbGVha3MgZm9yIGN1c3RvbSBldmVudHMgaW4gSUU2LThcblx0XHRcdC8vIGRldGFjaEV2ZW50IG5lZWRlZCBwcm9wZXJ0eSBvbiBlbGVtZW50LCBieSBuYW1lIG9mIHRoYXQgZXZlbnQsIHRvIHByb3Blcmx5IGV4cG9zZSBpdCB0byBHQ1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbVsgbmFtZSBdID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGVsZW1bIG5hbWUgXSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uZGV0YWNoRXZlbnQoIG5hbWUsIGhhbmRsZSApO1xuXHRcdH1cblx0fTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8IDksIEFuZHJvaWQgPCA0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHByZXZlbnREZWZhdWx0IGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gT3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBJZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBTZXQgdGhlIGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gdHJ1ZVxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcbmpRdWVyeS5lYWNoKHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gSUUgc3VibWl0IGRlbGVnYXRpb25cbmlmICggIXN1cHBvcnQuc3VibWl0QnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExhenktYWRkIGEgc3VibWl0IGhhbmRsZXIgd2hlbiBhIGRlc2NlbmRhbnQgZm9ybSBtYXkgcG90ZW50aWFsbHkgYmUgc3VibWl0dGVkXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCxcblx0XHRcdFx0XHRmb3JtID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSA/IGVsZW0uZm9ybSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCBmb3JtICYmICFqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0QnViYmxlc1wiICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZm9ybSwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5fc3VibWl0X2J1YmJsZSA9IHRydWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBmb3JtLCBcInN1Ym1pdEJ1YmJsZXNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdC8vIHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UgZG9uJ3QgbmVlZCBhbiBldmVudCBsaXN0ZW5lclxuXHRcdH0sXG5cblx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdC8vIElmIGZvcm0gd2FzIHN1Ym1pdHRlZCBieSB0aGUgdXNlciwgYnViYmxlIHRoZSBldmVudCB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCBldmVudC5fc3VibWl0X2J1YmJsZSApIHtcblx0XHRcdFx0ZGVsZXRlIGV2ZW50Ll9zdWJtaXRfYnViYmxlO1xuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE9ubHkgbmVlZCB0aGlzIGZvciBkZWxlZ2F0ZWQgZm9ybSBzdWJtaXQgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJmb3JtXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZGVsZWdhdGVkIGhhbmRsZXJzOyBjbGVhbkRhdGEgZXZlbnR1YWxseSByZWFwcyBzdWJtaXQgaGFuZGxlcnMgYXR0YWNoZWQgYWJvdmVcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIFwiLl9zdWJtaXRcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gSUUgY2hhbmdlIGRlbGVnYXRpb24gYW5kIGNoZWNrYm94L3JhZGlvIGZpeFxuaWYgKCAhc3VwcG9ydC5jaGFuZ2VCdWJibGVzICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLmNoYW5nZSA9IHtcblxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0aWYgKCByZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKSApIHtcblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBmaXJlIGNoYW5nZSBvbiBhIGNoZWNrL3JhZGlvIHVudGlsIGJsdXI7IHRyaWdnZXIgaXQgb24gY2xpY2tcblx0XHRcdFx0Ly8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuXG5cdFx0XHRcdC8vIFRoaXMgc3RpbGwgZmlyZXMgb25jaGFuZ2UgYSBzZWNvbmQgdGltZSBmb3IgY2hlY2svcmFkaW8gYWZ0ZXIgYmx1ci5cblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZSA9PT0gXCJjaGVja2VkXCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RfY2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5fanVzdF9jaGFuZ2VkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RfY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQWxsb3cgdHJpZ2dlcmVkLCBzaW11bGF0ZWQgY2hhbmdlIGV2ZW50cyAoIzExNTAwKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcImNoYW5nZVwiLCB0aGlzLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIERlbGVnYXRlZCBldmVudDsgbGF6eS1hZGQgYSBjaGFuZ2UgaGFuZGxlciBvbiBkZXNjZW5kYW50IGlucHV0c1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmICggcmZvcm1FbGVtcy50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgIWpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbGVtLCBcImNoYW5nZS5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1NpbXVsYXRlZCAmJiAhZXZlbnQuaXNUcmlnZ2VyICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMucGFyZW50Tm9kZSwgZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwiY2hhbmdlQnViYmxlc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBlbGVtID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHQvLyBTd2FsbG93IG5hdGl2ZSBjaGFuZ2UgZXZlbnRzIGZyb20gY2hlY2tib3gvcmFkaW8sIHdlIGFscmVhZHkgdHJpZ2dlcmVkIHRoZW0gYWJvdmVcblx0XHRcdGlmICggdGhpcyAhPT0gZWxlbSB8fCBldmVudC5pc1NpbXVsYXRlZCB8fCBldmVudC5pc1RyaWdnZXIgfHwgKGVsZW0udHlwZSAhPT0gXCJyYWRpb1wiICYmIGVsZW0udHlwZSAhPT0gXCJjaGVja2JveFwiKSApIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX2NoYW5nZVwiICk7XG5cblx0XHRcdHJldHVybiAhcmZvcm1FbGVtcy50ZXN0KCB0aGlzLm5vZGVOYW1lICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHtcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuXHRcdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0galF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBqUXVlcnkuX2RhdGEoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBkb2MsIGZpeCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi8gb25lICkge1xuXHRcdHZhciB0eXBlLCBvcmlnRm47XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSB7XG5cdHZhciBsaXN0ID0gbm9kZU5hbWVzLnNwbGl0KCBcInxcIiApLFxuXHRcdHNhZmVGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdGlmICggc2FmZUZyYWcuY3JlYXRlRWxlbWVudCApIHtcblx0XHR3aGlsZSAoIGxpc3QubGVuZ3RoICkge1xuXHRcdFx0c2FmZUZyYWcuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0bGlzdC5wb3AoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHNhZmVGcmFnO1xufVxuXG52YXIgbm9kZU5hbWVzID0gXCJhYmJyfGFydGljbGV8YXNpZGV8YXVkaW98YmRpfGNhbnZhc3xkYXRhfGRhdGFsaXN0fGRldGFpbHN8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfFwiICtcblx0XHRcImhlYWRlcnxoZ3JvdXB8bWFya3xtZXRlcnxuYXZ8b3V0cHV0fHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0aW1lfHZpZGVvXCIsXG5cdHJpbmxpbmVqUXVlcnkgPSAvIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxcblx0cm5vc2hpbWNhY2hlID0gbmV3IFJlZ0V4cChcIjwoPzpcIiArIG5vZGVOYW1lcyArIFwiKVtcXFxccy8+XVwiLCBcImlcIiksXG5cdHJsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy8sXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcblx0cnRhZ05hbWUgPSAvPChbXFx3Ol0rKS8sXG5cdHJ0Ym9keSA9IC88dGJvZHkvaSxcblx0cmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLFxuXG5cdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG5cdHdyYXBNYXAgPSB7XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cdFx0bGVnZW5kOiBbIDEsIFwiPGZpZWxkc2V0PlwiLCBcIjwvZmllbGRzZXQ+XCIgXSxcblx0XHRhcmVhOiBbIDEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIiBdLFxuXHRcdHBhcmFtOiBbIDEsIFwiPG9iamVjdD5cIiwgXCI8L29iamVjdD5cIiBdLFxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHQvLyBJRTYtOCBjYW4ndCBzZXJpYWxpemUgbGluaywgc2NyaXB0LCBzdHlsZSwgb3IgYW55IGh0bWw1IChOb1Njb3BlKSB0YWdzLFxuXHRcdC8vIHVubGVzcyB3cmFwcGVkIGluIGEgZGl2IHdpdGggbm9uLWJyZWFraW5nIGNoYXJhY3RlcnMgaW4gZnJvbnQgb2YgaXQuXG5cdFx0X2RlZmF1bHQ6IHN1cHBvcnQuaHRtbFNlcmlhbGl6ZSA/IFsgMCwgXCJcIiwgXCJcIiBdIDogWyAxLCBcIlg8ZGl2PlwiLCBcIjwvZGl2PlwiICBdXG5cdH0sXG5cdHNhZmVGcmFnbWVudCA9IGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKSxcblx0ZnJhZ21lbnREaXYgPSBzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcblxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIGVsZW1zLCBlbGVtLFxuXHRcdGkgPSAwLFxuXHRcdGZvdW5kID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCA/IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IHN0cnVuZGVmaW5lZCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdGlmICggIWZvdW5kICkge1xuXHRcdGZvciAoIGZvdW5kID0gW10sIGVsZW1zID0gY29udGV4dC5jaGlsZE5vZGVzIHx8IGNvbnRleHQ7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggIXRhZyB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIHRhZyApICkge1xuXHRcdFx0XHRmb3VuZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIGZvdW5kLCBnZXRBbGwoIGVsZW0sIHRhZyApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCBmb3VuZCApIDpcblx0XHRmb3VuZDtcbn1cblxuLy8gVXNlZCBpbiBidWlsZEZyYWdtZW50LCBmaXhlcyB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICkge1xuXHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsZW0udHlwZSApICkge1xuXHRcdGVsZW0uZGVmYXVsdENoZWNrZWQgPSBlbGVtLmNoZWNrZWQ7XG5cdH1cbn1cblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKSApIDpcblx0XHRlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoalF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0eXBlXCIgKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblx0aWYgKCBtYXRjaCApIHtcblx0XHRlbGVtLnR5cGUgPSBtYXRjaFsxXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XG5cdH1cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRpID0gMDtcblx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGpRdWVyeS5fZGF0YSggcmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiICkgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciB0eXBlLCBpLCBsLFxuXHRcdG9sZERhdGEgPSBqUXVlcnkuX2RhdGEoIHNyYyApLFxuXHRcdGN1ckRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QsIG9sZERhdGEgKSxcblx0XHRldmVudHMgPSBvbGREYXRhLmV2ZW50cztcblxuXHRpZiAoIGV2ZW50cyApIHtcblx0XHRkZWxldGUgY3VyRGF0YS5oYW5kbGU7XG5cdFx0Y3VyRGF0YS5ldmVudHMgPSB7fTtcblxuXHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBtYWtlIHRoZSBjbG9uZWQgcHVibGljIGRhdGEgb2JqZWN0IGEgY29weSBmcm9tIHRoZSBvcmlnaW5hbFxuXHRpZiAoIGN1ckRhdGEuZGF0YSApIHtcblx0XHRjdXJEYXRhLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyRGF0YS5kYXRhICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZml4Q2xvbmVOb2RlSXNzdWVzKCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSwgZSwgZGF0YTtcblxuXHQvLyBXZSBkbyBub3QgbmVlZCB0byBkbyBhbnl0aGluZyBmb3Igbm9uLUVsZW1lbnRzXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBJRTYtOCBjb3BpZXMgZXZlbnRzIGJvdW5kIHZpYSBhdHRhY2hFdmVudCB3aGVuIHVzaW5nIGNsb25lTm9kZS5cblx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lRXZlbnQgJiYgZGVzdFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCBkZXN0ICk7XG5cblx0XHRmb3IgKCBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBkZXN0LCBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdH1cblxuXHRcdC8vIEV2ZW50IGRhdGEgZ2V0cyByZWZlcmVuY2VkIGluc3RlYWQgb2YgY29waWVkIGlmIHRoZSBleHBhbmRvIGdldHMgY29waWVkIHRvb1xuXHRcdGRlc3QucmVtb3ZlQXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xuXHR9XG5cblx0Ly8gSUUgYmxhbmtzIGNvbnRlbnRzIHdoZW4gY2xvbmluZyBzY3JpcHRzLCBhbmQgdHJpZXMgdG8gZXZhbHVhdGUgbmV3bHktc2V0IHRleHRcblx0aWYgKCBub2RlTmFtZSA9PT0gXCJzY3JpcHRcIiAmJiBkZXN0LnRleHQgIT09IHNyYy50ZXh0ICkge1xuXHRcdGRpc2FibGVTY3JpcHQoIGRlc3QgKS50ZXh0ID0gc3JjLnRleHQ7XG5cdFx0cmVzdG9yZVNjcmlwdCggZGVzdCApO1xuXG5cdC8vIElFNi0xMCBpbXByb3Blcmx5IGNsb25lcyBjaGlsZHJlbiBvZiBvYmplY3QgZWxlbWVudHMgdXNpbmcgY2xhc3NpZC5cblx0Ly8gSUUxMCB0aHJvd3MgTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3IgaWYgcGFyZW50IGlzIG51bGwsICMxMjEzMi5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0aWYgKCBkZXN0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkZXN0Lm91dGVySFRNTCA9IHNyYy5vdXRlckhUTUw7XG5cdFx0fVxuXG5cdFx0Ly8gVGhpcyBwYXRoIGFwcGVhcnMgdW5hdm9pZGFibGUgZm9yIElFOS4gV2hlbiBjbG9uaW5nIGFuIG9iamVjdFxuXHRcdC8vIGVsZW1lbnQgaW4gSUU5LCB0aGUgb3V0ZXJIVE1MIHN0cmF0ZWd5IGFib3ZlIGlzIG5vdCBzdWZmaWNpZW50LlxuXHRcdC8vIElmIHRoZSBzcmMgaGFzIGlubmVySFRNTCBhbmQgdGhlIGRlc3RpbmF0aW9uIGRvZXMgbm90LFxuXHRcdC8vIGNvcHkgdGhlIHNyYy5pbm5lckhUTUwgaW50byB0aGUgZGVzdC5pbm5lckhUTUwuICMxMDMyNFxuXHRcdGlmICggc3VwcG9ydC5odG1sNUNsb25lICYmICggc3JjLmlubmVySFRNTCAmJiAhalF1ZXJ5LnRyaW0oZGVzdC5pbm5lckhUTUwpICkgKSB7XG5cdFx0XHRkZXN0LmlubmVySFRNTCA9IHNyYy5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHQvLyBJRTYtOCBmYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94XG5cdFx0Ly8gb3IgcmFkaW8gYnV0dG9uLiBXb3JzZSwgSUU2LTcgZmFpbCB0byBnaXZlIHRoZSBjbG9uZWQgZWxlbWVudFxuXHRcdC8vIGEgY2hlY2tlZCBhcHBlYXJhbmNlIGlmIHRoZSBkZWZhdWx0Q2hlY2tlZCB2YWx1ZSBpc24ndCBhbHNvIHNldFxuXG5cdFx0ZGVzdC5kZWZhdWx0Q2hlY2tlZCA9IGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdFx0Ly8gSUU2LTcgZ2V0IGNvbmZ1c2VkIGFuZCBlbmQgdXAgc2V0dGluZyB0aGUgdmFsdWUgb2YgYSBjbG9uZWRcblx0XHQvLyBjaGVja2JveC9yYWRpbyBidXR0b24gdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgXCJvblwiXG5cdFx0aWYgKCBkZXN0LnZhbHVlICE9PSBzcmMudmFsdWUgKSB7XG5cdFx0XHRkZXN0LnZhbHVlID0gc3JjLnZhbHVlO1xuXHRcdH1cblxuXHQvLyBJRTYtOCBmYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZFxuXHQvLyBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiApIHtcblx0XHRkZXN0LmRlZmF1bHRTZWxlY3RlZCA9IGRlc3Quc2VsZWN0ZWQgPSBzcmMuZGVmYXVsdFNlbGVjdGVkO1xuXG5cdC8vIElFNi04IGZhaWxzIHRvIHNldCB0aGUgZGVmYXVsdFZhbHVlIHRvIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW5cblx0Ly8gY2xvbmluZyBvdGhlciB0eXBlcyBvZiBpbnB1dCBmaWVsZHNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgZGVzdEVsZW1lbnRzLCBub2RlLCBjbG9uZSwgaSwgc3JjRWxlbWVudHMsXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0aWYgKCBzdXBwb3J0Lmh0bWw1Q2xvbmUgfHwgalF1ZXJ5LmlzWE1MRG9jKGVsZW0pIHx8ICFybm9zaGltY2FjaGUudGVzdCggXCI8XCIgKyBlbGVtLm5vZGVOYW1lICsgXCI+XCIgKSApIHtcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKTtcblxuXHRcdC8vIElFPD04IGRvZXMgbm90IHByb3Blcmx5IGNsb25lIGRldGFjaGVkLCB1bmtub3duIGVsZW1lbnQgbm9kZXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhZ21lbnREaXYuaW5uZXJIVE1MID0gZWxlbS5vdXRlckhUTUw7XG5cdFx0XHRmcmFnbWVudERpdi5yZW1vdmVDaGlsZCggY2xvbmUgPSBmcmFnbWVudERpdi5maXJzdENoaWxkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAoIXN1cHBvcnQubm9DbG9uZUV2ZW50IHx8ICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkKSAmJlxuXHRcdFx0XHQoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdC8vIEZpeCBhbGwgSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRcdGZvciAoIGkgPSAwOyAobm9kZSA9IHNyY0VsZW1lbnRzW2ldKSAhPSBudWxsOyArK2kgKSB7XG5cdFx0XHRcdC8vIEVuc3VyZSB0aGF0IHRoZSBkZXN0aW5hdGlvbiBub2RlIGlzIG5vdCBudWxsOyBGaXhlcyAjOTU4N1xuXHRcdFx0XHRpZiAoIGRlc3RFbGVtZW50c1tpXSApIHtcblx0XHRcdFx0XHRmaXhDbG9uZU5vZGVJc3N1ZXMoIG5vZGUsIGRlc3RFbGVtZW50c1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggbm9kZSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdGRlc3RFbGVtZW50cyA9IHNyY0VsZW1lbnRzID0gbm9kZSA9IG51bGw7XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0YnVpbGRGcmFnbWVudDogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24gKSB7XG5cdFx0dmFyIGosIGVsZW0sIGNvbnRhaW5zLFxuXHRcdFx0dG1wLCB0YWcsIHRib2R5LCB3cmFwLFxuXHRcdFx0bCA9IGVsZW1zLmxlbmd0aCxcblxuXHRcdFx0Ly8gRW5zdXJlIGEgc2FmZSBmcmFnbWVudFxuXHRcdFx0c2FmZSA9IGNyZWF0ZVNhZmVGcmFnbWVudCggY29udGV4dCApLFxuXG5cdFx0XHRub2RlcyA9IFtdLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IHNhZmUuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9IChydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0pWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblxuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKSArIHdyYXBbMl07XG5cblx0XHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0XHRqID0gd3JhcFswXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTWFudWFsbHkgYWRkIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGJ5IElFXG5cdFx0XHRcdFx0aWYgKCAhc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSAmJiBybGVhZGluZ1doaXRlc3BhY2UudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggcmxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGVsZW0gKVswXSApICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIElFJ3MgYXV0b2luc2VydGVkIDx0Ym9keT4gZnJvbSB0YWJsZSBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoICFzdXBwb3J0LnRib2R5ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgPHRhYmxlPiwgKm1heSogaGF2ZSBzcHVyaW91cyA8dGJvZHk+XG5cdFx0XHRcdFx0XHRlbGVtID0gdGFnID09PSBcInRhYmxlXCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuXHRcdFx0XHRcdFx0XHR0bXAuZmlyc3RDaGlsZCA6XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XG5cdFx0XHRcdFx0XHRcdHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFydGJvZHkudGVzdCggZWxlbSApID9cblx0XHRcdFx0XHRcdFx0XHR0bXAgOlxuXHRcdFx0XHRcdFx0XHRcdDA7XG5cblx0XHRcdFx0XHRcdGogPSBlbGVtICYmIGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoICh0Ym9keSA9IGVsZW0uY2hpbGROb2Rlc1tqXSksIFwidGJvZHlcIiApICYmICF0Ym9keS5jaGlsZE5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtLnJlbW92ZUNoaWxkKCB0Ym9keSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHRcdC8vIEZpeCAjMTIzOTIgZm9yIFdlYktpdCBhbmQgSUUgPiA5XG5cdFx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRcdFx0XHRcdC8vIEZpeCAjMTIzOTIgZm9yIG9sZElFXG5cdFx0XHRcdFx0d2hpbGUgKCB0bXAuZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0XHRcdHRtcC5yZW1vdmVDaGlsZCggdG1wLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgcHJvcGVyIGNsZWFudXBcblx0XHRcdFx0XHR0bXAgPSBzYWZlLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpeCAjMTEzNTY6IENsZWFyIGVsZW1lbnRzIGZyb20gZnJhZ21lbnRcblx0XHRpZiAoIHRtcCApIHtcblx0XHRcdHNhZmUucmVtb3ZlQ2hpbGQoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IGRlZmF1bHRDaGVja2VkIGZvciBhbnkgcmFkaW9zIGFuZCBjaGVja2JveGVzXG5cdFx0Ly8gYWJvdXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSBpbiBJRSA2LzcgKCM4MDYwKVxuXHRcdGlmICggIXN1cHBvcnQuYXBwZW5kQ2hlY2tlZCApIHtcblx0XHRcdGpRdWVyeS5ncmVwKCBnZXRBbGwoIG5vZGVzLCBcImlucHV0XCIgKSwgZml4RGVmYXVsdENoZWNrZWQgKTtcblx0XHR9XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChlbGVtID0gbm9kZXNbIGkrKyBdKSApIHtcblxuXHRcdFx0Ly8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcblx0XHRcdC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXG5cdFx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgIT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHRcdHRtcCA9IGdldEFsbCggc2FmZS5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG1wID0gbnVsbDtcblxuXHRcdHJldHVybiBzYWZlO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zLCAvKiBpbnRlcm5hbCAqLyBhY2NlcHREYXRhICkge1xuXHRcdHZhciBlbGVtLCB0eXBlLCBpZCwgZGF0YSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblx0XHRcdGNhY2hlID0galF1ZXJ5LmNhY2hlLFxuXHRcdFx0ZGVsZXRlRXhwYW5kbyA9IHN1cHBvcnQuZGVsZXRlRXhwYW5kbyxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhIHx8IGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuXHRcdFx0XHRkYXRhID0gaWQgJiYgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBjYWNoZSBvbmx5IGlmIGl0IHdhcyBub3QgYWxyZWFkeSByZW1vdmVkIGJ5IGpRdWVyeS5ldmVudC5yZW1vdmVcblx0XHRcdFx0XHRpZiAoIGNhY2hlWyBpZCBdICkge1xuXG5cdFx0XHRcdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0XHRcdFx0XHRcdC8vIElFIGRvZXMgbm90IGFsbG93IHVzIHRvIGRlbGV0ZSBleHBhbmRvIHByb3BlcnRpZXMgZnJvbSBub2Rlcyxcblx0XHRcdFx0XHRcdC8vIG5vciBkb2VzIGl0IGhhdmUgYSByZW1vdmVBdHRyaWJ1dGUgZnVuY3Rpb24gb24gRG9jdW1lbnQgbm9kZXM7XG5cdFx0XHRcdFx0XHQvLyB3ZSBtdXN0IGhhbmRsZSBhbGwgb2YgdGhlc2UgY2FzZXNcblx0XHRcdFx0XHRcdGlmICggZGVsZXRlRXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGVsZW1bIGludGVybmFsS2V5IF07XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggaW50ZXJuYWxLZXkgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZWxlbVsgaW50ZXJuYWxLZXkgXSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGRlbGV0ZWRJZHMucHVzaCggaWQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoICggdGhpc1swXSAmJiB0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKS5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgdGhpcyApIDogdGhpcyxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cblx0XHRcdGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSApICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVDaGlsZCggZWxlbS5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBzZWxlY3QsIGVuc3VyZSB0aGF0IGl0IGRpc3BsYXlzIGVtcHR5ICgjMTIzMzYpXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRpZiAoIGVsZW0ub3B0aW9ucyAmJiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwic2VsZWN0XCIgKSApIHtcblx0XHRcdFx0ZWxlbS5vcHRpb25zLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRcdFx0XHRlbGVtLmlubmVySFRNTC5yZXBsYWNlKCByaW5saW5lalF1ZXJ5LCBcIlwiICkgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCggc3VwcG9ydC5odG1sU2VyaWFsaXplIHx8ICFybm9zaGltY2FjaGUudGVzdCggdmFsdWUgKSAgKSAmJlxuXHRcdFx0XHQoIHN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgfHwgIXJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCB2YWx1ZSApICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbIChydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1sgMCBdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0dGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGFyZyA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblxuXHRcdFx0aWYgKCBhcmcgKSB7XG5cdFx0XHRcdGFyZy5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEZvcmNlIHJlbW92YWwgaWYgdGhlcmUgd2FzIG5vIG5ldyBjb250ZW50IChlLmcuLCBmcm9tIGVtcHR5IGFyZ3VtZW50cylcblx0XHRyZXR1cm4gYXJnICYmIChhcmcubGVuZ3RoIHx8IGFyZy5ub2RlVHlwZSkgPyB0aGlzIDogdGhpcy5yZW1vdmUoKTtcblx0fSxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0ZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdFx0dmFyIGZpcnN0LCBub2RlLCBoYXNTY3JpcHRzLFxuXHRcdFx0c2NyaXB0cywgZG9jLCBmcmFnbWVudCxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2V0ID0gdGhpcyxcblx0XHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbMF0sXG5cdFx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIGlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHNldC5lcSggaW5kZXggKTtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLmRvbU1hbmlwKCBhcmdzLCBjYWxsYmFjayApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBsICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggYXJncywgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCB0aGlzICk7XG5cdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW0gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCB0aGlzW2ldLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFqUXVlcnkuX2RhdGEoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiYgalF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCAoIG5vZGUudGV4dCB8fCBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJIVE1MIHx8IFwiXCIgKS5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRml4ICMxMTgwOTogQXZvaWQgbGVha2luZyBtZW1vcnlcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCh7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbaV0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gTW9kZXJuIGJyb3dzZXJzIGNhbiBhcHBseSBqUXVlcnkgY29sbGVjdGlvbnMgYXMgYXJyYXlzLCBidXQgb2xkSUUgbmVlZHMgYSAuZ2V0KClcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIHN0eWxlLFxuXHRcdGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdC8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50XG5cdFx0ZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoIHN0eWxlID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKSApID9cblxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdG1pemF0aW9uKSB1bnRpbCBzb21ldGhpbmcgYmV0dGVyIGNvbWVzIGFsb25nLFxuXHRcdFx0Ly8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRlxuXHRcdFx0c3R5bGUuZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9IChpZnJhbWUgfHwgalF1ZXJ5KCBcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIiApKS5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9ICggaWZyYW1lWyAwIF0uY29udGVudFdpbmRvdyB8fCBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQgKS5kb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgc2hyaW5rV3JhcEJsb2Nrc1ZhbDtcblxuXHRzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHNocmlua1dyYXBCbG9ja3NWYWwgIT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXHRcdH1cblxuXHRcdC8vIFdpbGwgYmUgY2hhbmdlZCBsYXRlciBpZiBuZWVkZWQuXG5cdFx0c2hyaW5rV3JhcEJsb2Nrc1ZhbCA9IGZhbHNlO1xuXG5cdFx0Ly8gTWluaWZpZWQ6IHZhciBiLGMsZFxuXHRcdHZhciBkaXYsIGJvZHksIGNvbnRhaW5lcjtcblxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdO1xuXHRcdGlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7XG5cdFx0XHQvLyBUZXN0IGZpcmVkIHRvbyBlYXJseSBvciBpbiBhbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudCwgZXhpdC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTZXR1cFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4XCI7XG5cdFx0Ym9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU2XG5cdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudHMgd2l0aCBsYXlvdXQgc2hyaW5rLXdyYXAgdGhlaXIgY2hpbGRyZW5cblx0XHRpZiAoIHR5cGVvZiBkaXYuc3R5bGUuem9vbSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlclxuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7XCIgK1xuXHRcdFx0XHRcInBhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjFcIjtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICkuc3R5bGUud2lkdGggPSBcIjVweFwiO1xuXHRcdFx0c2hyaW5rV3JhcEJsb2Nrc1ZhbCA9IGRpdi5vZmZzZXRXaWR0aCAhPT0gMztcblx0XHR9XG5cblx0XHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHJldHVybiBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXHR9O1xuXG59KSgpO1xudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG5cblxudmFyIGdldFN0eWxlcywgY3VyQ1NTLFxuXHRycG9zaXRpb24gPSAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87XG5cbmlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0aWYgKCBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XG5cdH07XG5cblx0Y3VyQ1NTID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHRcdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdFx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgaW4gSUU5LCBzZWUgIzEyNTM3XG5cdFx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDtcblxuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdFx0Ly8gQ2hyb21lIDwgMTcgYW5kIFNhZmFyaSA1LjAgdXNlcyBcImNvbXB1dGVkIHZhbHVlXCIgaW5zdGVhZCBvZiBcInVzZWQgdmFsdWVcIiBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBTYWZhcmkgNS4xLjcgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcblx0XHRcdC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldHVybiByZXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXQgOlxuXHRcdFx0cmV0ICsgXCJcIjtcblx0fTtcbn0gZWxzZSBpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUgKSB7XG5cdGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmN1cnJlbnRTdHlsZTtcblx0fTtcblxuXHRjdXJDU1MgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdFx0dmFyIGxlZnQsIHJzLCByc0xlZnQsIHJldCxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0Ly8gQXZvaWQgc2V0dGluZyByZXQgdG8gZW1wdHkgc3RyaW5nIGhlcmVcblx0XHQvLyBzbyB3ZSBkb24ndCBkZWZhdWx0IHRvIGF1dG9cblx0XHRpZiAoIHJldCA9PSBudWxsICYmIHN0eWxlICYmIHN0eWxlWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXQgPSBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcblx0XHQvLyBodHRwOi8vZXJpay5lYWUubmV0L2FyY2hpdmVzLzIwMDcvMDcvMjcvMTguNTQuMTUvI2NvbW1lbnQtMTAyMjkxXG5cblx0XHQvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcblx0XHQvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcblx0XHQvLyBidXQgbm90IHBvc2l0aW9uIGNzcyBhdHRyaWJ1dGVzLCBhcyB0aG9zZSBhcmUgcHJvcG9ydGlvbmFsIHRvIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0ZWFkXG5cdFx0Ly8gYW5kIHdlIGNhbid0IG1lYXN1cmUgdGhlIHBhcmVudCBpbnN0ZWFkIGJlY2F1c2UgaXQgbWlnaHQgdHJpZ2dlciBhIFwic3RhY2tpbmcgZG9sbHNcIiBwcm9ibGVtXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgIXJwb3NpdGlvbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGxlZnQgPSBzdHlsZS5sZWZ0O1xuXHRcdFx0cnMgPSBlbGVtLnJ1bnRpbWVTdHlsZTtcblx0XHRcdHJzTGVmdCA9IHJzICYmIHJzLmxlZnQ7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdGlmICggcnNMZWZ0ICkge1xuXHRcdFx0XHRycy5sZWZ0ID0gZWxlbS5jdXJyZW50U3R5bGUubGVmdDtcblx0XHRcdH1cblx0XHRcdHN0eWxlLmxlZnQgPSBuYW1lID09PSBcImZvbnRTaXplXCIgPyBcIjFlbVwiIDogcmV0O1xuXHRcdFx0cmV0ID0gc3R5bGUucGl4ZWxMZWZ0ICsgXCJweFwiO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS5sZWZ0ID0gbGVmdDtcblx0XHRcdGlmICggcnNMZWZ0ICkge1xuXHRcdFx0XHRycy5sZWZ0ID0gcnNMZWZ0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXR1cm4gcmV0ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0cmV0IDpcblx0XHRcdHJldCArIFwiXCIgfHwgXCJhdXRvXCI7XG5cdH07XG59XG5cblxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbkZuKCk7XG5cblx0XHRcdGlmICggY29uZGl0aW9uID09IG51bGwgKSB7XG5cdFx0XHRcdC8vIFRoZSB0ZXN0IHdhcyBub3QgcmVhZHkgYXQgdGhpcyBwb2ludDsgc2NyZXcgdGhlIGhvb2sgdGhpcyB0aW1lXG5cdFx0XHRcdC8vIGJ1dCBjaGVjayBhZ2FpbiB3aGVuIG5lZWRlZCBuZXh0IHRpbWUuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb25kaXRpb24gKSB7XG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZSB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLFxuXHRcdFx0XHQvLyByZW1vdmUgaXQuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBob29rcyBmb3IgbWFyZ2luUmlnaHQsIHJlbW92ZSB0aGUgd2hvbGUgb2JqZWN0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cblx0XHRcdHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXHQvLyBNaW5pZmllZDogdmFyIGIsYyxkLGUsZixnLCBoLGlcblx0dmFyIGRpdiwgc3R5bGUsIGEsIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCwgcmVsaWFibGVNYXJnaW5SaWdodFZhbDtcblxuXHQvLyBTZXR1cFxuXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXHRhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImFcIiApWyAwIF07XG5cdHN0eWxlID0gYSAmJiBhLnN0eWxlO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIXN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHN0eWxlLmNzc1RleHQgPSBcImZsb2F0OmxlZnQ7b3BhY2l0eTouNVwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gTWFrZSBzdXJlIHRoYXQgZWxlbWVudCBvcGFjaXR5IGV4aXN0cyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXIpXG5cdHN1cHBvcnQub3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgPT09IFwiMC41XCI7XG5cblx0Ly8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuXHQvLyAoSUUgdXNlcyBzdHlsZUZsb2F0IGluc3RlYWQgb2YgY3NzRmxvYXQpXG5cdHN1cHBvcnQuY3NzRmxvYXQgPSAhIXN0eWxlLmNzc0Zsb2F0O1xuXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0c3VwcG9ydC5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgPT09IFwiXCIgfHwgc3R5bGUuTW96Qm94U2l6aW5nID09PSBcIlwiIHx8XG5cdFx0c3R5bGUuV2Via2l0Qm94U2l6aW5nID09PSBcIlwiO1xuXG5cdGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbDtcblx0XHR9LFxuXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcGl4ZWxQb3NpdGlvblZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpblJpZ2h0VmFsO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cdFx0Ly8gTWluaWZpZWQ6IHZhciBiLGMsZCxqXG5cdFx0dmFyIGRpdiwgYm9keSwgY29udGFpbmVyLCBjb250ZW50cztcblxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdO1xuXHRcdGlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7XG5cdFx0XHQvLyBUZXN0IGZpcmVkIHRvbyBlYXJseSBvciBpbiBhbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudCwgZXhpdC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTZXR1cFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4XCI7XG5cdFx0Ym9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO1wiICtcblx0XHRcdFwiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBBc3N1bWUgcmVhc29uYWJsZSB2YWx1ZXMgaW4gdGhlIGFic2VuY2Ugb2YgZ2V0Q29tcHV0ZWRTdHlsZVxuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBib3hTaXppbmdSZWxpYWJsZVZhbCA9IGZhbHNlO1xuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPSB0cnVlO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGdldENvbXB1dGVkU3R5bGUgc28gdGhhdCB0aGlzIGNvZGUgaXMgbm90IHJ1biBpbiBJRTw5LlxuXHRcdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0XHRwaXhlbFBvc2l0aW9uVmFsID0gKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICkgfHwge30gKS50b3AgIT09IFwiMSVcIjtcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID1cblx0XHRcdFx0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICkgfHwgeyB3aWR0aDogXCI0cHhcIiB9ICkud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBEaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIgKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHRjb250ZW50cyA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcblx0XHRcdGNvbnRlbnRzLnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7XCIgK1xuXHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdGNvbnRlbnRzLnN0eWxlLm1hcmdpblJpZ2h0ID0gY29udGVudHMuc3R5bGUud2lkdGggPSBcIjBcIjtcblx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cblx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPVxuXHRcdFx0XHQhcGFyc2VGbG9hdCggKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggY29udGVudHMsIG51bGwgKSB8fCB7fSApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggY29udGVudHMgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHQvLyBDaGVjayBpZiB0YWJsZSBjZWxscyBzdGlsbCBoYXZlIG9mZnNldFdpZHRoL0hlaWdodCB3aGVuIHRoZXkgYXJlIHNldFxuXHRcdC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxuXHRcdC8vIHRhYmxlIHJvdzsgaWYgc28sIG9mZnNldFdpZHRoL0hlaWdodCBhcmUgbm90IHJlbGlhYmxlIGZvciB1c2Ugd2hlblxuXHRcdC8vIGRldGVybWluaW5nIGlmIGFuIGVsZW1lbnQgaGFzIGJlZW4gaGlkZGVuIGRpcmVjdGx5IHVzaW5nXG5cdFx0Ly8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcblx0XHQvLyBoaWRkZW47IGRvbiBzYWZldHkgZ29nZ2xlcyBhbmQgc2VlIGJ1ZyAjNDUxMiBmb3IgbW9yZSBpbmZvcm1hdGlvbikuXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiO1xuXHRcdGNvbnRlbnRzID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInRkXCIgKTtcblx0XHRjb250ZW50c1sgMCBdLnN0eWxlLmNzc1RleHQgPSBcIm1hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MDtkaXNwbGF5Om5vbmVcIjtcblx0XHRyZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgPSBjb250ZW50c1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMDtcblx0XHRpZiAoIHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCApIHtcblx0XHRcdGNvbnRlbnRzWyAwIF0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRjb250ZW50c1sgMSBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9IGNvbnRlbnRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwO1xuXHRcdH1cblxuXHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cbn0pKCk7XG5cblxuLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9ucy5cbmpRdWVyeS5zd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyXG5cdFx0cmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaSxcblx0cm9wYWNpdHkgPSAvb3BhY2l0eVxccyo9XFxzKihbXildKikvLFxuXG5cdC8vIHN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGUgZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoLiopJFwiLCBcImlcIiApLFxuXHRycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIHBudW0gKyBcIilcIiwgXCJpXCIgKSxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdO1xuXG5cbi8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG5cdFx0b3JpZ05hbWUgPSBuYW1lLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvcmlnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAmJiBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSA9IGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgP1xuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXHRcdC8vIGJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBzdXBwb3J0LmJveFNpemluZyAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIHNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiAoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcblx0XHRcImZsb2F0XCI6IHN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBvcmlnTmFtZSApICk7XG5cblx0XHQvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gY29udmVydCByZWxhdGl2ZSBudW1iZXIgc3RyaW5ncyAoKz0gb3IgLT0pIHRvIHJlbGF0aXZlIG51bWJlcnMuICM3MzQ1XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRml4ZXMgIzg5MDgsIGl0IGNhbiBiZSBkb25lIG1vcmUgY29ycmVjdGx5IGJ5IHNwZWNpZmluZyBzZXR0ZXJzIGluIGNzc0hvb2tzLFxuXHRcdFx0Ly8gYnV0IGl0IHdvdWxkIG1lYW4gdG8gZGVmaW5lIGVpZ2h0IChmb3IgZXZlcnkgcHJvYmxlbWF0aWMgcHJvcGVydHkpIGlkZW50aWNhbCBmdW5jdGlvbnNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8ICh2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdFx0Ly8gU3dhbGxvdyBlcnJvcnMgZnJvbSAnaW52YWxpZCcgQ1NTIHZhbHVlcyAoIzU1MDkpXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgbnVtLCB2YWwsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4sIGNvbnZlcnRpbmcgdG8gbnVtYmVyIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Ly8gY2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGhvd2V2ZXIsIGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzXG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XG5cdFx0XHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRzdXBwb3J0LmJveFNpemluZyAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpIDogMFxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59KTtcblxuaWYgKCAhc3VwcG9ydC5vcGFjaXR5ICkge1xuXHRqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdC8vIElFIHVzZXMgZmlsdGVycyBmb3Igb3BhY2l0eVxuXHRcdFx0cmV0dXJuIHJvcGFjaXR5LnRlc3QoIChjb21wdXRlZCAmJiBlbGVtLmN1cnJlbnRTdHlsZSA/IGVsZW0uY3VycmVudFN0eWxlLmZpbHRlciA6IGVsZW0uc3R5bGUuZmlsdGVyKSB8fCBcIlwiICkgP1xuXHRcdFx0XHQoIDAuMDEgKiBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKSApICsgXCJcIiA6XG5cdFx0XHRcdGNvbXB1dGVkID8gXCIxXCIgOiBcIlwiO1xuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0XHRcdGN1cnJlbnRTdHlsZSA9IGVsZW0uY3VycmVudFN0eWxlLFxuXHRcdFx0XHRvcGFjaXR5ID0galF1ZXJ5LmlzTnVtZXJpYyggdmFsdWUgKSA/IFwiYWxwaGEob3BhY2l0eT1cIiArIHZhbHVlICogMTAwICsgXCIpXCIgOiBcIlwiLFxuXHRcdFx0XHRmaWx0ZXIgPSBjdXJyZW50U3R5bGUgJiYgY3VycmVudFN0eWxlLmZpbHRlciB8fCBzdHlsZS5maWx0ZXIgfHwgXCJcIjtcblxuXHRcdFx0Ly8gSUUgaGFzIHRyb3VibGUgd2l0aCBvcGFjaXR5IGlmIGl0IGRvZXMgbm90IGhhdmUgbGF5b3V0XG5cdFx0XHQvLyBGb3JjZSBpdCBieSBzZXR0aW5nIHRoZSB6b29tIGxldmVsXG5cdFx0XHRzdHlsZS56b29tID0gMTtcblxuXHRcdFx0Ly8gaWYgc2V0dGluZyBvcGFjaXR5IHRvIDEsIGFuZCBubyBvdGhlciBmaWx0ZXJzIGV4aXN0IC0gYXR0ZW1wdCB0byByZW1vdmUgZmlsdGVyIGF0dHJpYnV0ZSAjNjY1MlxuXHRcdFx0Ly8gaWYgdmFsdWUgPT09IFwiXCIsIHRoZW4gcmVtb3ZlIGlubGluZSBvcGFjaXR5ICMxMjY4NVxuXHRcdFx0aWYgKCAoIHZhbHVlID49IDEgfHwgdmFsdWUgPT09IFwiXCIgKSAmJlxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBcIlwiICkgKSA9PT0gXCJcIiAmJlxuXHRcdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHQvLyBTZXR0aW5nIHN0eWxlLmZpbHRlciB0byBudWxsLCBcIlwiICYgXCIgXCIgc3RpbGwgbGVhdmUgXCJmaWx0ZXI6XCIgaW4gdGhlIGNzc1RleHRcblx0XHRcdFx0Ly8gaWYgXCJmaWx0ZXI6XCIgaXMgcHJlc2VudCBhdCBhbGwsIGNsZWFyVHlwZSBpcyBkaXNhYmxlZCwgd2Ugd2FudCB0byBhdm9pZCB0aGlzXG5cdFx0XHRcdC8vIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSBpcyBJRSBPbmx5LCBidXQgc28gYXBwYXJlbnRseSBpcyB0aGlzIGNvZGUgcGF0aC4uLlxuXHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoIFwiZmlsdGVyXCIgKTtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBubyBmaWx0ZXIgc3R5bGUgYXBwbGllZCBpbiBhIGNzcyBydWxlIG9yIHVuc2V0IGlubGluZSBvcGFjaXR5LCB3ZSBhcmUgZG9uZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcIlwiIHx8IGN1cnJlbnRTdHlsZSAmJiAhY3VycmVudFN0eWxlLmZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCBzZXQgbmV3IGZpbHRlciB2YWx1ZXNcblx0XHRcdHN0eWxlLmZpbHRlciA9IHJhbHBoYS50ZXN0KCBmaWx0ZXIgKSA/XG5cdFx0XHRcdGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIG9wYWNpdHkgKSA6XG5cdFx0XHRcdGZpbHRlciArIFwiIFwiICsgb3BhY2l0eTtcblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0Ly8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXG5cdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHNcblx0XHRcdC8vIHNvLCBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHQvLyB1c2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdCAtIHVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZSAtIHVzZSAuc3R5bGUgaWYgaXRzXG5cdFx0XHQvLyBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5zdHlsZSAmJiAoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9XG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxuXHRhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cdHR3ZWVuZXJzID0ge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICksXG5cdFx0XHRcdHRhcmdldCA9IHR3ZWVuLmN1cigpLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR1bml0ID0gcGFydHMgJiYgcGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdFx0XHRzdGFydCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0ICkgJiZcblx0XHRcdFx0XHRyZnhudW0uZXhlYyggalF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCApICksXG5cdFx0XHRcdHNjYWxlID0gMSxcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDIwO1xuXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XG5cdFx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbIDMgXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHRcdHBhcnRzID0gcGFydHMgfHwgW107XG5cblx0XHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDE7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqXG5cdFx0XHRcdFx0Ly8gVXNlIGEgc3RyaW5nIGZvciBkb3VibGluZyBmYWN0b3Igc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0IC8gc2NhbGU7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCBwcm9wLCBzdGFydCArIHVuaXQgKTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdFx0XHQvLyBBbmQgYnJlYWtpbmcgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaFxuXHRcdFx0XHR9IHdoaWxlICggc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHR3ZWVuIHByb3BlcnRpZXNcblx0XHRcdGlmICggcGFydHMgKSB7XG5cdFx0XHRcdHN0YXJ0ID0gdHdlZW4uc3RhcnQgPSArc3RhcnQgfHwgK3RhcmdldCB8fCAwO1xuXHRcdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdFx0Ly8gSWYgYSArPS8tPSB0b2tlbiB3YXMgcHJvdmlkZWQsIHdlJ3JlIGRvaW5nIGEgcmVsYXRpdmUgYW5pbWF0aW9uXG5cdFx0XHRcdHR3ZWVuLmVuZCA9IHBhcnRzWyAxIF0gP1xuXHRcdFx0XHRcdHN0YXJ0ICsgKCBwYXJ0c1sgMSBdICsgMSApICogcGFydHNbIDIgXSA6XG5cdFx0XHRcdFx0K3BhcnRzWyAyIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fTtcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0pO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfSxcblx0XHRpID0gMDtcblxuXHQvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIGlmIHdlIGRvbid0IGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAodHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSkgKSB7XG5cblx0XHRcdC8vIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIGhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9pbmcgdGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlIGNvbXBsZXRlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcblx0XHRcdC8vIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0Ly8gaW5saW5lLWxldmVsIGVsZW1lbnRzIGFjY2VwdCBpbmxpbmUtYmxvY2s7XG5cdFx0XHQvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuXHRcdFx0aWYgKCAhc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0IHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRpZiAoICFzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MoKSApIHtcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3cgYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBzdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoIChkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5KSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxuXHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0pLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHQvLyBhcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgMSAtICggMC41IHx8IDAgKSAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWVcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gc2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGpRdWVyeS5fZGF0YSggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG5cdFx0XHQvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gZW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBlbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0aSA9IDA7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdC8vIE1pbmlmaWVkOiB2YXIgYSxiLGMsZCxlXG5cdHZhciBpbnB1dCwgZGl2LCBzZWxlY3QsIGEsIG9wdDtcblxuXHQvLyBTZXR1cFxuXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGRpdi5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIsIFwidFwiICk7XG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXHRhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKVsgMCBdO1xuXG5cdC8vIEZpcnN0IGJhdGNoIG9mIHRlc3RzLlxuXHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuXHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikgKTtcblx0aW5wdXQgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVsgMCBdO1xuXG5cdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweFwiO1xuXG5cdC8vIFRlc3Qgc2V0QXR0cmlidXRlIG9uIGNhbWVsQ2FzZSBjbGFzcy4gSWYgaXQgd29ya3MsIHdlIG5lZWQgYXR0ckZpeGVzIHdoZW4gZG9pbmcgZ2V0L3NldEF0dHJpYnV0ZSAoaWU2LzcpXG5cdHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlID0gZGl2LmNsYXNzTmFtZSAhPT0gXCJ0XCI7XG5cblx0Ly8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuXHQvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWFkKVxuXHRzdXBwb3J0LnN0eWxlID0gL3RvcC8udGVzdCggYS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSApO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXG5cdC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXG5cdHN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgPSBhLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiL2FcIjtcblxuXHQvLyBDaGVjayB0aGUgZGVmYXVsdCBjaGVja2JveC9yYWRpbyB2YWx1ZSAoXCJcIiBvbiBXZWJLaXQ7IFwib25cIiBlbHNld2hlcmUpXG5cdHN1cHBvcnQuY2hlY2tPbiA9ICEhaW5wdXQudmFsdWU7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxuXHQvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKVxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFRlc3RzIGZvciBlbmN0eXBlIHN1cHBvcnQgb24gYSBmb3JtICgjNjc0Mylcblx0c3VwcG9ydC5lbmN0eXBlID0gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKS5lbmN0eXBlO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcblx0Ly8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTggb25seVxuXHQvLyBDaGVjayBpZiB3ZSBjYW4gdHJ1c3QgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0c3VwcG9ydC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG5cblx0Ly8gQ2hlY2sgaWYgYW4gaW5wdXQgbWFpbnRhaW5zIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59KSgpO1xuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBoYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IGluZGV4IDwgMCA/XG5cdFx0XHRcdFx0XHRtYXggOlxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gb2xkSUUgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID49IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFNlxuXHRcdFx0XHRcdFx0Ly8gV2hlbiBuZXcgb3B0aW9uIGVsZW1lbnQgaXMgYWRkZWQgdG8gc2VsZWN0IGJveCB3ZSBuZWVkIHRvXG5cdFx0XHRcdFx0XHQvLyBmb3JjZSByZWZsb3cgb2YgbmV3bHkgYWRkZWQgbm9kZSBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGRlbGF5XG5cdFx0XHRcdFx0XHQvLyBvZiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb25TZXQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9IGNhdGNoICggXyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBXaWxsIGJlIGV4ZWN1dGVkIG9ubHkgaW4gSUU2XG5cdFx0XHRcdFx0XHRcdG9wdGlvbi5zY3JvbGxIZWlnaHQ7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUgKSA+PSAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXZWJraXRcblx0XHRcdC8vIFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG5vZGVIb29rLCBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGUsXG5cdHJ1c2VEZWZhdWx0ID0gL14oPzpjaGVja2VkfHNlbGVjdGVkKSQvaSxcblx0Z2V0U2V0QXR0cmlidXRlID0gc3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGUsXG5cdGdldFNldElucHV0ID0gc3VwcG9ydC5pbnB1dDtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XG5cdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdHJldDtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGlmICggZ2V0U2V0SW5wdXQgJiYgZ2V0U2V0QXR0cmlidXRlIHx8ICFydXNlRGVmYXVsdC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0XHRcdC8vIEFsc28gY2xlYXIgZGVmYXVsdENoZWNrZWQvZGVmYXVsdFNlbGVjdGVkIChpZiBhcHByb3ByaWF0ZSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPVxuXHRcdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGpRdWVyeS5hdHRyKCBlbGVtLCBuYW1lLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggZ2V0U2V0QXR0cmlidXRlID8gbmFtZSA6IHByb3BOYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSApIHtcblx0XHRcdFx0XHQvLyBTZXR0aW5nIHRoZSB0eXBlIG9uIGEgcmFkaW8gYnV0dG9uIGFmdGVyIHRoZSB2YWx1ZSByZXNldHMgdGhlIHZhbHVlIGluIElFNi05XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdmFsdWUgdG8gZGVmYXVsdCBpbiBjYXNlIHR5cGUgaXMgc2V0IGFmdGVyIHZhbHVlIGR1cmluZyBjcmVhdGlvblxuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhvb2sgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdC8vIElFPDggbmVlZHMgdGhlICpwcm9wZXJ0eSogbmFtZVxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoICFnZXRTZXRBdHRyaWJ1dGUgJiYgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lLCBuYW1lICk7XG5cblx0XHQvLyBVc2UgZGVmYXVsdENoZWNrZWQgYW5kIGRlZmF1bHRTZWxlY3RlZCBmb3Igb2xkSUVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gPSBlbGVtWyBuYW1lIF0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG4vLyBSZXRyaWV2ZSBib29sZWFucyBzcGVjaWFsbHlcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZ2V0U2V0SW5wdXQgJiYgZ2V0U2V0QXR0cmlidXRlIHx8ICFydXNlRGVmYXVsdC50ZXN0KCBuYW1lICkgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdHZhciByZXQsIGhhbmRsZTtcblx0XHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbVsgalF1ZXJ5LmNhbWVsQ2FzZSggXCJkZWZhdWx0LVwiICsgbmFtZSApIF0gP1xuXHRcdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHR9O1xufSk7XG5cbi8vIGZpeCBvbGRJRSBhdHRyb3BlcnRpZXNcbmlmICggIWdldFNldElucHV0IHx8ICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG5cdGpRdWVyeS5hdHRySG9va3MudmFsdWUgPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdC8vIERvZXMgbm90IHJldHVybiBzbyB0aGF0IHNldEF0dHJpYnV0ZSBpcyBhbHNvIHVzZWRcblx0XHRcdFx0ZWxlbS5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFVzZSBub2RlSG9vayBpZiBkZWZpbmVkICgjMTk1NCk7IG90aGVyd2lzZSBzZXRBdHRyaWJ1dGUgaXMgZmluZVxuXHRcdFx0XHRyZXR1cm4gbm9kZUhvb2sgJiYgbm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gSUU2LzcgZG8gbm90IHN1cHBvcnQgZ2V0dGluZy9zZXR0aW5nIHNvbWUgYXR0cmlidXRlcyB3aXRoIGdldC9zZXRBdHRyaWJ1dGVcbmlmICggIWdldFNldEF0dHJpYnV0ZSApIHtcblxuXHQvLyBVc2UgdGhpcyBmb3IgYW55IGF0dHJpYnV0ZSBpbiBJRTYvN1xuXHQvLyBUaGlzIGZpeGVzIGFsbW9zdCBldmVyeSBJRTYvNyBpc3N1ZVxuXHRub2RlSG9vayA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdC8vIFNldCB0aGUgZXhpc3Rpbmcgb3IgY3JlYXRlIGEgbmV3IGF0dHJpYnV0ZSBub2RlXG5cdFx0XHR2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlTm9kZShcblx0XHRcdFx0XHQocmV0ID0gZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXQudmFsdWUgPSB2YWx1ZSArPSBcIlwiO1xuXG5cdFx0XHQvLyBCcmVhayBhc3NvY2lhdGlvbiB3aXRoIGNsb25lZCBlbGVtZW50cyBieSBhbHNvIHVzaW5nIHNldEF0dHJpYnV0ZSAoIzk2NDYpXG5cdFx0XHRpZiAoIG5hbWUgPT09IFwidmFsdWVcIiB8fCB2YWx1ZSA9PT0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBTb21lIGF0dHJpYnV0ZXMgYXJlIGNvbnN0cnVjdGVkIHdpdGggZW1wdHktc3RyaW5nIHZhbHVlcyB3aGVuIG5vdCBkZWZpbmVkXG5cdGF0dHJIYW5kbGUuaWQgPSBhdHRySGFuZGxlLm5hbWUgPSBhdHRySGFuZGxlLmNvb3JkcyA9XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0dmFyIHJldDtcblx0XHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0XHRyZXR1cm4gKHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiByZXQudmFsdWUgIT09IFwiXCIgP1xuXHRcdFx0XHRcdHJldC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdC8vIEZpeGluZyB2YWx1ZSByZXRyaWV2YWwgb24gYSBidXR0b24gcmVxdWlyZXMgdGhpcyBtb2R1bGVcblx0alF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0dmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuXHRcdFx0aWYgKCByZXQgJiYgcmV0LnNwZWNpZmllZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldC52YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldDogbm9kZUhvb2suc2V0XG5cdH07XG5cblx0Ly8gU2V0IGNvbnRlbnRlZGl0YWJsZSB0byBmYWxzZSBvbiByZW1vdmFscygjMTA0MjkpXG5cdC8vIFNldHRpbmcgdG8gZW1wdHkgc3RyaW5nIHRocm93cyBhbiBlcnJvciBhcyBhbiBpbnZhbGlkIHZhbHVlXG5cdGpRdWVyeS5hdHRySG9va3MuY29udGVudGVkaXRhYmxlID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0bm9kZUhvb2suc2V0KCBlbGVtLCB2YWx1ZSA9PT0gXCJcIiA/IGZhbHNlIDogdmFsdWUsIG5hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gU2V0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXV0byBpbnN0ZWFkIG9mIDAgb24gZW1wdHkgc3RyaW5nKCBCdWcgIzgxNTAgKVxuXHQvLyBUaGlzIGlzIGZvciByZW1vdmFsc1xuXHRqUXVlcnkuZWFjaChbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gPSB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgXCJhdXRvXCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxuaWYgKCAhc3VwcG9ydC5zdHlsZSApIHtcblx0alF1ZXJ5LmF0dHJIb29rcy5zdHlsZSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gUmV0dXJuIHVuZGVmaW5lZCBpbiB0aGUgY2FzZSBvZiBlbXB0eSBzdHJpbmdcblx0XHRcdC8vIE5vdGU6IElFIHVwcGVyY2FzZXMgY3NzIHByb3BlcnR5IG5hbWVzLCBidXQgaWYgd2Ugd2VyZSB0byAudG9Mb3dlckNhc2UoKVxuXHRcdFx0Ly8gLmNzc1RleHQsIHRoYXQgd291bGQgZGVzdHJveSBjYXNlIHNlbnN0aXRpdml0eSBpbiBVUkwncywgbGlrZSBpbiBcImJhY2tncm91bmRcIlxuXHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dCB8fCB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0uc3R5bGUuY3NzVGV4dCA9IHZhbHVlICsgXCJcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdHJ5L2NhdGNoIGhhbmRsZXMgY2FzZXMgd2hlcmUgSUUgYmFsa3MgKHN1Y2ggYXMgcmVtb3ZpbmcgYSBwcm9wZXJ0eSBvbiB3aW5kb3cpXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzWyBuYW1lIF07XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLCBub3R4bWwsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XG5cblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0KCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSkgIT09IG51bGwgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHRlbGVtWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdHJldHVybiB0YWJpbmRleCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fCByY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhc3VwcG9ydC5ocmVmTm9ybWFsaXplZCApIHtcblx0Ly8gaHJlZi9zcmMgcHJvcGVydHkgc2hvdWxkIGdldCB0aGUgZnVsbCBub3JtYWxpemVkIFVSTCAoIzEwMjk5LyMxMjkxNSlcblx0alF1ZXJ5LmVhY2goWyBcImhyZWZcIiwgXCJzcmNcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIDQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogU2FmYXJpLCBJRTkrXG4vLyBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbi8vIEFjY2Vzc2luZyB0aGUgcGFyZW50J3Mgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBmaXhlcyBpdFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGl0IGFsc28gd29ya3Mgd2l0aCBvcHRncm91cHMsIHNlZSAjNTcwMVxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0pO1xuXG4vLyBJRTYvNyBjYWxsIGVuY3R5cGUgZW5jb2RpbmdcbmlmICggIXN1cHBvcnQuZW5jdHlwZSApIHtcblx0alF1ZXJ5LnByb3BGaXguZW5jdHlwZSA9IFwiZW5jb2RpbmdcIjtcbn1cblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRwcm9jZWVkID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHQvLyBUaGUgZGlzanVuY3Rpb24gaGVyZSBpcyBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIHJlbW92ZUNsYXNzKVxuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiIFwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHByb2NlZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPj0gMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKCBjdXIgKSA6IFwiXCI7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBjaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgXCJmYWxzZVwiLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5qUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSk7XG5cblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKC9cXD8vKTtcblxuXG5cbnZhciBydmFsaWR0b2tlbnMgPSAvKCwpfChcXFt8eyl8KH18XSl8XCIoPzpbXlwiXFxcXFxcclxcbl18XFxcXFtcIlxcXFxcXC9iZm5ydF18XFxcXHVbXFxkYS1mQS1GXXs0fSkqXCJcXHMqOj98dHJ1ZXxmYWxzZXxudWxsfC0/KD8hMFxcZClcXGQrKD86XFwuXFxkK3wpKD86W2VFXVsrLV0/XFxkK3wpL2c7XG5cbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0Ly8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG5cdGlmICggd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgKSB7XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHQvLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxuXHRcdHJldHVybiB3aW5kb3cuSlNPTi5wYXJzZSggZGF0YSArIFwiXCIgKTtcblx0fVxuXG5cdHZhciByZXF1aXJlTm9uQ29tbWEsXG5cdFx0ZGVwdGggPSBudWxsLFxuXHRcdHN0ciA9IGpRdWVyeS50cmltKCBkYXRhICsgXCJcIiApO1xuXG5cdC8vIEd1YXJkIGFnYWluc3QgaW52YWxpZCAoYW5kIHBvc3NpYmx5IGRhbmdlcm91cykgaW5wdXQgYnkgZW5zdXJpbmcgdGhhdCBub3RoaW5nIHJlbWFpbnNcblx0Ly8gYWZ0ZXIgcmVtb3ZpbmcgdmFsaWQgdG9rZW5zXG5cdHJldHVybiBzdHIgJiYgIWpRdWVyeS50cmltKCBzdHIucmVwbGFjZSggcnZhbGlkdG9rZW5zLCBmdW5jdGlvbiggdG9rZW4sIGNvbW1hLCBvcGVuLCBjbG9zZSApIHtcblxuXHRcdC8vIEZvcmNlIHRlcm1pbmF0aW9uIGlmIHdlIHNlZSBhIG1pc3BsYWNlZCBjb21tYVxuXHRcdGlmICggcmVxdWlyZU5vbkNvbW1hICYmIGNvbW1hICkge1xuXHRcdFx0ZGVwdGggPSAwO1xuXHRcdH1cblxuXHRcdC8vIFBlcmZvcm0gbm8gbW9yZSByZXBsYWNlbWVudHMgYWZ0ZXIgcmV0dXJuaW5nIHRvIG91dGVybW9zdCBkZXB0aFxuXHRcdGlmICggZGVwdGggPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0fVxuXG5cdFx0Ly8gQ29tbWFzIG11c3Qgbm90IGZvbGxvdyBcIltcIiwgXCJ7XCIsIG9yIFwiLFwiXG5cdFx0cmVxdWlyZU5vbkNvbW1hID0gb3BlbiB8fCBjb21tYTtcblxuXHRcdC8vIERldGVybWluZSBuZXcgZGVwdGhcblx0XHQvLyBhcnJheS9vYmplY3Qgb3BlbiAoXCJbXCIgb3IgXCJ7XCIpOiBkZXB0aCArPSB0cnVlIC0gZmFsc2UgKGluY3JlbWVudClcblx0XHQvLyBhcnJheS9vYmplY3QgY2xvc2UgKFwiXVwiIG9yIFwifVwiKTogZGVwdGggKz0gZmFsc2UgLSB0cnVlIChkZWNyZW1lbnQpXG5cdFx0Ly8gb3RoZXIgY2FzZXMgKFwiLFwiIG9yIHByaW1pdGl2ZSk6IGRlcHRoICs9IHRydWUgLSB0cnVlIChudW1lcmljIGNhc3QpXG5cdFx0ZGVwdGggKz0gIWNsb3NlIC0gIW9wZW47XG5cblx0XHQvLyBSZW1vdmUgdGhpcyB0b2tlblxuXHRcdHJldHVybiBcIlwiO1xuXHR9KSApID9cblx0XHQoIEZ1bmN0aW9uKCBcInJldHVybiBcIiArIHN0ciApICkoKSA6XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgSlNPTjogXCIgKyBkYXRhICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRpZiAoIHdpbmRvdy5ET01QYXJzZXIgKSB7IC8vIFN0YW5kYXJkXG5cdFx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0XHR9IGVsc2UgeyAvLyBJRVxuXHRcdFx0eG1sID0gbmV3IEFjdGl2ZVhPYmplY3QoIFwiTWljcm9zb2Z0LlhNTERPTVwiICk7XG5cdFx0XHR4bWwuYXN5bmMgPSBcImZhbHNlXCI7XG5cdFx0XHR4bWwubG9hZFhNTCggZGF0YSApO1xuXHRcdH1cblx0fSBjYXRjaCggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKCAheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50IHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uXG5cdGFqYXhMb2NQYXJ0cyxcblx0YWpheExvY2F0aW9uLFxuXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsIC8vIElFIGxlYXZlcyBhbiBcXHIgY2hhcmFjdGVyIGF0IEVPTFxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpO1xuXG4vLyAjODEzOCwgSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XG50cnkge1xuXHRhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xufSBjYXRjaCggZSApIHtcblx0Ly8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcblx0Ly8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cblx0YWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0YWpheExvY2F0aW9uLmhyZWYgPSBcIlwiO1xuXHRhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbn1cblxuLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXG5hamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoIChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSApIHtcblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZS5jaGFyQXQoIDAgKSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGRlZXAsIGtleSxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8IChkZWVwID0ge30pICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cdHZhciBmaXJzdERhdGFUeXBlLCBjdCwgZmluYWxEYXRhVHlwZSwgdHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzWyBcInRocm93c1wiIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4geyBzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnQgfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGFqYXhMb2NhdGlvbixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGFqYXhMb2NQYXJ0c1sgMSBdICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAveG1sLyxcblx0XHRcdGh0bWw6IC9odG1sLyxcblx0XHRcdGpzb246IC9qc29uL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciAvLyBDcm9zcy1kb21haW4gZGV0ZWN0aW9uIHZhcnNcblx0XHRcdHBhcnRzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVycyBhcyBzdHJpbmdcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdHRyYW5zcG9ydCxcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblx0XHRcdC8vIFRoZSBqcVhIUiBzdGF0ZVxuXHRcdFx0c3RhdGUgPSAwLFxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xuXHRcdGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKCM1ODY2OiBJRTcgaXNzdWUgd2l0aCBwcm90b2NvbC1sZXNzIHVybHMpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKS5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0oIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB3ZSBoYXZlIGEgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0cy5jcm9zc0RvbWFpbiA9ICEhKCBwYXJ0cyAmJlxuXHRcdFx0XHQoIHBhcnRzWyAxIF0gIT09IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT09IGFqYXhMb2NQYXJ0c1sgMiBdIHx8XG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XG5cdFx0XHRcdFx0XHQoIGFqYXhMb2NQYXJ0c1sgMyBdIHx8ICggYWpheExvY1BhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybDtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSAoIHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGEgKTtcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBhYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0Ly8gU2ltcGx5IHJldGhyb3cgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIENhbGxlZCBvbmNlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xuXHRcdFx0c3RhdGUgPSAyO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XG5cdFx0XHRcdC8vIHRoZW4gbm9ybWFsaXplIHN0YXR1c1RleHQgYW5kIHN0YXR1cyBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSk7XG5cdH07XG59KTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogdXJsLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9KTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbMF0gKSB7XG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0dmFyIHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCApLmVxKDApLmNsb25lKHRydWUpO1xuXG5cdFx0XHRpZiAoIHRoaXNbMF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0pLmVuZCgpO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxuXHQvLyBPcGVyYSByZXBvcnRzIG9mZnNldFdpZHRocyBhbmQgb2Zmc2V0SGVpZ2h0cyBsZXNzIHRoYW4gemVybyBvbiBzb21lIGVsZW1lbnRzXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMCB8fFxuXHRcdCghc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMoKSAmJlxuXHRcdFx0KChlbGVtLnN0eWxlICYmIGVsZW0uc3R5bGUuZGlzcGxheSkgfHwgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSkgPT09IFwibm9uZVwiKTtcbn07XG5cbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdFx0XHQvLyBVc2UgLmlzKFwiOmRpc2FibGVkXCIpIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0pXG5cdFx0Lm1hcChmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0cmV0dXJuIHZhbCA9PSBudWxsID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0pLmdldCgpO1xuXHR9XG59KTtcblxuXG4vLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XG4vLyAoVGhpcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBhamF4U2V0dGluZ3MgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0ICE9PSB1bmRlZmluZWQgP1xuXHQvLyBTdXBwb3J0OiBJRTYrXG5cdGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gWEhSIGNhbm5vdCBhY2Nlc3MgbG9jYWwgZmlsZXMsIGFsd2F5cyB1c2UgQWN0aXZlWCBmb3IgdGhhdCBjYXNlXG5cdFx0cmV0dXJuICF0aGlzLmlzTG9jYWwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU3LThcblx0XHRcdC8vIG9sZElFIFhIUiBkb2VzIG5vdCBzdXBwb3J0IG5vbi1SRkMyNjE2IG1ldGhvZHMgKCMxMzI0MClcblx0XHRcdC8vIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvbXM1MzY2NDgodj12cy44NSkuYXNweFxuXHRcdFx0Ly8gYW5kIGh0dHA6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjOS5odG1sI3NlYzlcblx0XHRcdC8vIEFsdGhvdWdoIHRoaXMgY2hlY2sgZm9yIHNpeCBtZXRob2RzIGluc3RlYWQgb2YgZWlnaHRcblx0XHRcdC8vIHNpbmNlIElFIGFsc28gZG9lcyBub3Qgc3VwcG9ydCBcInRyYWNlXCIgYW5kIFwiY29ubmVjdFwiXG5cdFx0XHQvXihnZXR8cG9zdHxoZWFkfHB1dHxkZWxldGV8b3B0aW9ucykkL2kudGVzdCggdGhpcy50eXBlICkgJiZcblxuXHRcdFx0Y3JlYXRlU3RhbmRhcmRYSFIoKSB8fCBjcmVhdGVBY3RpdmVYSFIoKTtcblx0fSA6XG5cdC8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XG5cdGNyZWF0ZVN0YW5kYXJkWEhSO1xuXG52YXIgeGhySWQgPSAwLFxuXHR4aHJDYWxsYmFja3MgPSB7fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuLy8gU3VwcG9ydDogSUU8MTBcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXG4vLyBTZWUgaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NiBmb3IgbW9yZSBpbmZvXG5pZiAoIHdpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0d2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSggdW5kZWZpbmVkLCB0cnVlICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gRGV0ZXJtaW5lIHN1cHBvcnQgcHJvcGVydGllc1xuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xueGhyU3VwcG9ydGVkID0gc3VwcG9ydC5hamF4ID0gISF4aHJTdXBwb3J0ZWQ7XG5cbi8vIENyZWF0ZSB0cmFuc3BvcnQgaWYgdGhlIGJyb3dzZXIgY2FuIHByb3ZpZGUgYW4geGhyXG5pZiAoIHhoclN1cHBvcnRlZCApIHtcblxuXHRqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiB8fCBzdXBwb3J0LmNvcnMgKSB7XG5cblx0XHRcdHZhciBjYWxsYmFjaztcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRcdGlkID0gKyt4aHJJZDtcblxuXHRcdFx0XHRcdC8vIE9wZW4gdGhlIHNvY2tldFxuXHRcdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJRSdzIEFjdGl2ZVhPYmplY3QgdGhyb3dzIGEgJ1R5cGUgTWlzbWF0Y2gnIGV4Y2VwdGlvbiB3aGVuIHNldHRpbmdcblx0XHRcdFx0XHRcdC8vIHJlcXVlc3QgaGVhZGVyIHRvIGEgbnVsbC12YWx1ZS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBrZWVwIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBYSFIgaW1wbGVtZW50YXRpb25zLCBjYXN0IHRoZSB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gdG8gc3RyaW5nIGFuZCBpZ25vcmUgYHVuZGVmaW5lZGAuXG5cdFx0XHRcdFx0XHRpZiAoIGhlYWRlcnNbIGkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICsgXCJcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcblx0XHRcdFx0XHQvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSlcblx0XHRcdFx0XHR4aHIuc2VuZCggKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhICkgfHwgbnVsbCApO1xuXG5cdFx0XHRcdFx0Ly8gTGlzdGVuZXJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzO1xuXG5cdFx0XHRcdFx0XHQvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDbGVhbiB1cFxuXHRcdFx0XHRcdFx0XHRkZWxldGUgeGhyQ2FsbGJhY2tzWyBpZCBdO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFib3J0IG1hbnVhbGx5IGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8MTBcblx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyAoIzExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMudGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3RhdHVzVGV4dCBmb3IgZmF1bHR5IGNyb3NzLWRvbWFpbiByZXF1ZXN0c1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFdlIG5vcm1hbGl6ZSB3aXRoIFdlYmtpdCBnaXZpbmcgYW4gZW1wdHkgc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmlsdGVyIHN0YXR1cyBmb3Igbm9uIHN0YW5kYXJkIGJlaGF2aW9yc1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHJlcXVlc3QgaXMgbG9jYWwgYW5kIHdlIGhhdmUgZGF0YTogYXNzdW1lIGEgc3VjY2Vzc1xuXHRcdFx0XHRcdFx0XHRcdC8vIChzdWNjZXNzIHdpdGggbm8gZGF0YSB3b24ndCBnZXQgbm90aWZpZWQsIHRoYXQncyB0aGUgYmVzdCB3ZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGNhbiBkbyBnaXZlbiBjdXJyZW50IGltcGxlbWVudGF0aW9ucylcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFzdGF0dXMgJiYgb3B0aW9ucy5pc0xvY2FsICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSUUgLSAjMTQ1MDogc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENhbGwgY29tcGxldGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5hc3luYyApIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGluIHN5bmMgbW9kZSB3ZSBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdC8vIChJRTYgJiBJRTcpIGlmIGl0J3MgaW4gY2FjaGUgYW5kIGhhcyBiZWVuXG5cdFx0XHRcdFx0XHQvLyByZXRyaWV2ZWQgZGlyZWN0bHkgd2UgbmVlZCB0byBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggY2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQWRkIHRvIHRoZSBsaXN0IG9mIGFjdGl2ZSB4aHIgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soIHVuZGVmaW5lZCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBGdW5jdGlvbnMgdG8gY3JlYXRlIHhocnNcbmZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkWEhSKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgZ2xvYmFsXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0XHRzLmdsb2JhbCA9IGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGpRdWVyeShcImhlYWRcIilbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cblx0XHRcdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIHMuc2NyaXB0Q2hhcnNldCApIHtcblx0XHRcdFx0XHRzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjcmlwdC5zcmMgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBBdHRhY2ggaGFuZGxlcnMgZm9yIGFsbCBicm93c2Vyc1xuXHRcdFx0XHRzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgbWVtb3J5IGxlYWsgaW4gSUVcblx0XHRcdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBzY3JpcHRcblx0XHRcdFx0XHRcdGlmICggc2NyaXB0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgaWYgbm90IGFib3J0XG5cdFx0XHRcdFx0XHRpZiAoICFpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBDaXJjdW12ZW50IElFNiBidWdzIHdpdGggYmFzZSBlbGVtZW50cyAoIzI3MDkgYW5kICM0Mzc4KSBieSBwcmVwZW5kaW5nXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRoZWFkLmluc2VydEJlZm9yZSggc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBzY3JpcHQgKSB7XG5cdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCggdW5kZWZpbmVkLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgcmVzcG9uc2UsIHR5cGUsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSBqUXVlcnkudHJpbSggdXJsLnNsaWNlKCBvZmYsIHVybC5sZW5ndGggKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSkubGVuZ3RoO1xufTtcblxuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgP1xuXHRcdGVsZW0gOlxuXHRcdGVsZW0ubm9kZVR5cGUgPT09IDkgP1xuXHRcdFx0ZWxlbS5kZWZhdWx0VmlldyB8fCBlbGVtLnBhcmVudFdpbmRvdyA6XG5cdFx0XHRmYWxzZTtcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHRqUXVlcnkuaW5BcnJheShcImF1dG9cIiwgWyBjdXJDU1NUb3AsIGN1ckNTU0xlZnQgXSApID4gLTE7XG5cblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGdCQ1IsIGp1c3QgdXNlIDAsMCByYXRoZXIgdGhhbiBlcnJvclxuXHRcdC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICArICggd2luLnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wICkgIC0gKCBkb2NFbGVtLmNsaWVudFRvcCAgfHwgMCApLFxuXHRcdFx0bGVmdDogYm94LmxlZnQgKyAoIHdpbi5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgKSAtICggZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDAgKVxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdC8vIGZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdC8vIHdlIGFzc3VtZSB0aGF0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBhdmFpbGFibGUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudFsgMCBdLCBcImh0bWxcIiApICkge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuXHRcdFx0cGFyZW50T2Zmc2V0LnRvcCAgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0Ly8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcblx0XHQvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUpXG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiAoICFqUXVlcnkubm9kZU5hbWUoIG9mZnNldFBhcmVudCwgXCJodG1sXCIgKSAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IC9ZLy50ZXN0KCBwcm9wICk7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gKHByb3AgaW4gd2luKSA/IHdpblsgcHJvcCBdIDpcblx0XHRcdFx0XHR3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBtZXRob2QgXSA6XG5cdFx0XHRcdFx0ZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsVG9wKClcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwgd2UganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblx0XHRcdFx0Ly8gaWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59KTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblx0XHQvLyBtYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSwgd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0Ly8gdW5mb3J0dW5hdGVseSwgdGhpcyBjYXVzZXMgYnVnICMzODM4IGluIElFNi84IG9ubHksIGJ1dCB0aGVyZSBpcyBjdXJyZW50bHkgbm8gZ29vZCwgc21hbGwgd2F5IHRvIGZpeCBpdC5cblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSk7XG59KTtcblxuXG4vLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxualF1ZXJ5LmZuLnNpemUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9KTtcbn1cblxuXG5cblxudmFyXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxuLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcblxufSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogbG9kYXNoIDMuNi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1kIC1vIC4vaW5kZXguanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICczLjYuMCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3Igd3JhcHBlciBtZXRhZGF0YS4gKi9cbiAgdmFyIEJJTkRfRkxBRyA9IDEsXG4gICAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIENVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgQ1VSUllfRkxBRyA9IDgsXG4gICAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBQQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBSRUFSR19GTEFHID0gMjU2O1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgd2hlbiBhIGZ1bmN0aW9uIGJlY29tZXMgaG90LiAqL1xuICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRFJPUF9XSElMRV9GTEFHID0gMCxcbiAgICAgIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5fCM5Nik7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ2BdL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmtzID0gL1tcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMjNdL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUhleFByZWZpeCA9IC9eMFt4WF0vO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG4gIHZhciByZUhvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbjEgPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZGVcXHhkZi1cXHhmNlxceGY4LVxceGZmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBbc3BlY2lhbCBjaGFyYWN0ZXJzXShodHRwOi8vd3d3LnJlZ3VsYXItZXhwcmVzc2lvbnMuaW5mby9jaGFyYWN0ZXJzLmh0bWwjc3BlY2lhbCkuXG4gICAqIEluIGFkZGl0aW9uIHRvIHNwZWNpYWwgY2hhcmFjdGVycyB0aGUgZm9yd2FyZCBzbGFzaCBpcyBlc2NhcGVkIHRvIGFsbG93IGZvclxuICAgKiBlYXNpZXIgYGV2YWxgIHVzZSBhbmQgYEZ1bmN0aW9uYCBjb21waWxhdGlvbi5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFycyA9IFJlZ0V4cChyZVJlZ0V4cENoYXJzLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgdG8gY3JlYXRlIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVXb3JkcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdXBwZXIgPSAnW0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZV0nLFxuICAgICAgICBsb3dlciA9ICdbYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXSsnO1xuXG4gICAgcmV0dXJuIFJlZ0V4cCh1cHBlciArICcrKD89JyArIHVwcGVyICsgbG93ZXIgKyAnKXwnICsgdXBwZXIgKyAnPycgKyBsb3dlciArICd8JyArIHVwcGVyICsgJyt8WzAtOV0rJywgJ2cnKTtcbiAgfSgpKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3QgZm9yIHdoaXRlc3BhY2UuICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIEJhc2ljIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAnIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmJyArXG5cbiAgICAvLyBMaW5lIHRlcm1pbmF0b3JzLlxuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gVW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9ycy5cbiAgICAnXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCdcbiAgKTtcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0FycmF5QnVmZmVyJywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWF0aCcsICdOdW1iZXInLFxuICAgICdPYmplY3QnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnXycsICdjbGVhclRpbWVvdXQnLCAnZG9jdW1lbnQnLFxuICAgICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0JywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ3dpbmRvdydcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPSB0eXBlZEFycmF5VGFnc1ttYXBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPSB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW21hcFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgYXMgYW4gaW50ZXJuYWwgYF8uZGVib3VuY2VgIG9wdGlvbnMgb2JqZWN0IGJ5IGBfLnRocm90dGxlYC4gKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjQyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVDJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnYCc6ICcmIzk2OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCIsXG4gICAgJyYjOTY7JzogJ2AnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gb2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgJiYgc2VsZjtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHdpbmRvd2AuICovXG4gIHZhciBmcmVlV2luZG93ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93ICYmIHdpbmRvdy5PYmplY3QgJiYgd2luZG93O1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qKlxuICAgKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYHRoaXNgIHZhbHVlIGlzIHVzZWQgaWYgaXQgaXMgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3NcbiAgICogcmVzdHJpY3RlZCBgd2luZG93YCBvYmplY3QsIG90aGVyd2lzZSB0aGUgYHdpbmRvd2Agb2JqZWN0IGlzIHVzZWQuXG4gICAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXM7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjb21wYXJlQXNjZW5kaW5nYCB3aGljaCBjb21wYXJlcyB2YWx1ZXMgYW5kXG4gICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgdmFsdWUgdG8gY29tcGFyZSB0byBgdmFsdWVgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgIHZhciB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcjtcblxuICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgIXZhbElzUmVmbGV4aXZlIHx8ICh0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcgJiYgb3RoSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgIW90aElzUmVmbGV4aXZlIHx8ICh0eXBlb2Ygb3RoZXIgPT0gJ3VuZGVmaW5lZCcgJiYgdmFsSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0Z1bmN0aW9uYCB3aXRob3V0IHN1cHBvcnQgZm9yIGVudmlyb25tZW50c1xuICAgKiB3aXRoIGluY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gQXZvaWQgYSBDaGFrcmEgSklUIGJ1ZyBpbiBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDExLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvaXNzdWVzLzE2MjEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2soc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICogb2YgYHN0cmluZ2AgdGhhdCBpcyBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyBUaGUgY2hhcmFjdGVycyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGNoYXJzLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpbmRleCkpID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlXG4gICAqIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG9iamVjdGAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBlYWNoIGVsZW1lbnRcbiAgICogaW4gYSBjb2xsZWN0aW9uIGFuZCBzdGFibGUgc29ydCB0aGVtIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gICAqXG4gICAqIElmIG9yZGVycyBpcyB1bnNwZWNpZmllZCwgc29ydCBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGFsbCBwcm9wZXJ0aWVzLlxuICAgKiBPdGhlcndpc2UsIGZvciBlYWNoIHByb3BlcnR5LCBzb3J0IGluIGFzY2VuZGluZyBvcmRlciBpZiBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZSBpblxuICAgKiBvcmRlcnMgaXMgdHJ1ZSwgYW5kIGRlc2NlbmRpbmcgb3JkZXIgaWYgZmFsc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG9iamVjdGAuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyc1tpbmRleF0gPyAxIDogLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVidXJyTGV0dGVyKGxldHRlcikge1xuICAgIHJldHVybiBkZWJ1cnJlZExldHRlcnNbbGV0dGVyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gaHRtbEVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgTmFOYCBpcyBmb3VuZCBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIGBOYU5gLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mTmFOKGFycmF5LCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKG90aGVyICE9PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdHJpbW1lZExlZnRJbmRleGAgYW5kIGB0cmltbWVkUmlnaHRJbmRleGAgdG8gZGV0ZXJtaW5lIGlmIGFcbiAgICogY2hhcmFjdGVyIGNvZGUgaXMgd2hpdGVzcGFjZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJDb2RlIFRoZSBjaGFyYWN0ZXIgY29kZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGNoYXJDb2RlYCBpcyB3aGl0ZXNwYWNlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuICgoY2hhckNvZGUgPD0gMTYwICYmIChjaGFyQ29kZSA+PSA5ICYmIGNoYXJDb2RlIDw9IDEzKSB8fCBjaGFyQ29kZSA9PSAzMiB8fCBjaGFyQ29kZSA9PSAxNjApIHx8IGNoYXJDb2RlID09IDU3NjAgfHwgY2hhckNvZGUgPT0gNjE1OCB8fFxuICAgICAgKGNoYXJDb2RlID49IDgxOTIgJiYgKGNoYXJDb2RlIDw9IDgyMDIgfHwgY2hhckNvZGUgPT0gODIzMiB8fCBjaGFyQ29kZSA9PSA4MjMzIHx8IGNoYXJDb2RlID09IDgyMzkgfHwgY2hhckNvZGUgPT0gODI4NyB8fCBjaGFyQ29kZSA9PSAxMjI4OCB8fCBjaGFyQ29kZSA9PSA2NTI3OSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBzZWVuLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKCFpbmRleCB8fCBzZWVuICE9PSBjb21wdXRlZCkge1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZExlZnRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIHVzaW5nIGBjb250ZXh0YCB0byBtb2NrIGBEYXRlI2dldFRpbWVgIHVzZSBpbiBgXy5ub3dgXG4gICAqIHZhciBtb2NrID0gXy5ydW5JbkNvbnRleHQoe1xuICAgKiAgICdEYXRlJzogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4geyAnZ2V0VGltZSc6IGdldFRpbWVNb2NrIH07XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gb3IgY3JlYXRpbmcgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanNcbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBzdHJpbmdQcm90byA9IFN0cmluZy5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgRE9NIHN1cHBvcnQuICovXG4gICAgdmFyIGRvY3VtZW50ID0gKGRvY3VtZW50ID0gY29udGV4dC53aW5kb3cpICYmIGRvY3VtZW50LmRvY3VtZW50O1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gdGhlIGxlbmd0aCBvZiBuLXR1cGxlcyBmb3IgYF8udW56aXBgLiAqL1xuICAgIHZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IGNvbnRleHQuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBlc2NhcGVSZWdFeHAob2JqVG9TdHJpbmcpXG4gICAgICAucmVwbGFjZSgvdG9TdHJpbmd8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXlCdWZmZXIgPSBpc05hdGl2ZShBcnJheUJ1ZmZlciA9IGNvbnRleHQuQXJyYXlCdWZmZXIpICYmIEFycmF5QnVmZmVyLFxuICAgICAgICBidWZmZXJTbGljZSA9IGlzTmF0aXZlKGJ1ZmZlclNsaWNlID0gQXJyYXlCdWZmZXIgJiYgbmV3IEFycmF5QnVmZmVyKDApLnNsaWNlKSAmJiBidWZmZXJTbGljZSxcbiAgICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIHB1c2ggPSBhcnJheVByb3RvLnB1c2gsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIFNldCA9IGlzTmF0aXZlKFNldCA9IGNvbnRleHQuU2V0KSAmJiBTZXQsXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBVaW50OEFycmF5ID0gaXNOYXRpdmUoVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSkgJiYgVWludDhBcnJheSxcbiAgICAgICAgV2Vha01hcCA9IGlzTmF0aXZlKFdlYWtNYXAgPSBjb250ZXh0LldlYWtNYXApICYmIFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBjbG9uZSBhcnJheSBidWZmZXJzLiAqL1xuICAgIHZhciBGbG9hdDY0QXJyYXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBTYWZhcmkgNSBlcnJvcnMgd2hlbiB1c2luZyBhbiBhcnJheSBidWZmZXIgdG8gaW5pdGlhbGl6ZSBhIHR5cGVkIGFycmF5XG4gICAgICAvLyB3aGVyZSB0aGUgYXJyYXkgYnVmZmVyJ3MgYGJ5dGVMZW5ndGhgIGlzIG5vdCBhIG11bHRpcGxlIG9mIHRoZSB0eXBlZFxuICAgICAgLy8gYXJyYXkncyBgQllURVNfUEVSX0VMRU1FTlRgLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gY29udGV4dC5GbG9hdDY0QXJyYXkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgZnVuYyhuZXcgQXJyYXlCdWZmZXIoMTApLCAwLCAxKSAmJiBmdW5jO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBpc05hdGl2ZShuYXRpdmVOb3cgPSBEYXRlLm5vdykgJiYgbmF0aXZlTm93LFxuICAgICAgICBuYXRpdmVOdW1Jc0Zpbml0ZSA9IGlzTmF0aXZlKG5hdGl2ZU51bUlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKSAmJiBuYXRpdmVOdW1Jc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIGAtSW5maW5pdHlgIGFuZCBgSW5maW5pdHlgLiAqL1xuICAgIHZhciBORUdBVElWRV9JTkZJTklUWSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgUE9TSVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gTWF0aC5wb3coMiwgMzIpIC0gMSxcbiAgICAgICAgTUFYX0FSUkFZX0lOREVYID0gIE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gICAgLyoqIFVzZWQgYXMgdGhlIHNpemUsIGluIGJ5dGVzLCBvZiBlYWNoIGBGbG9hdDY0QXJyYXlgIGVsZW1lbnQuICovXG4gICAgdmFyIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQgPSBGbG9hdDY0QXJyYXkgPyBGbG9hdDY0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gICAgICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IGNoYWluaW5nLlxuICAgICAqIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucywgYW5kIGZ1bmN0aW9ucyBjYW5cbiAgICAgKiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0dXJuIGEgYm9vbGVhbiBvciBzaW5nbGUgdmFsdWUgd2lsbFxuICAgICAqIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiByZXR1cm5pbmcgdGhlIHVud3JhcHBlZCB2YWx1ZS4gRXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBtYXkgYmUgZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksXG4gICAgICogdGhhdCBpcywgZXhlY3V0aW9uIGlzIGRlZmVycmVkIHVudGlsIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHlcbiAgICAgKiBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi4gU2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRoYXQgbWVyZ2VzIGl0ZXJhdGVlcyB0byBhdm9pZCBjcmVhdGluZyBpbnRlcm1lZGlhdGVcbiAgICAgKiBhcnJheXMgYW5kIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLFxuICAgICAqIGBmaXJzdGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHBsdWNrYCwgYHJlamVjdGAsIGByZXN0YCwgYHJldmVyc2VgLFxuICAgICAqIGBzbGljZWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdG9BcnJheWAsXG4gICAgICogYW5kIGB3aGVyZWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhdGAsIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLFxuICAgICAqIGBjYWxsYmFja2AsIGBjaGFpbmAsIGBjaHVua2AsIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uc3RhbnRgLFxuICAgICAqIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbGxgLFxuICAgICAqIGBmaWx0ZXJgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmb3JFYWNoYCxcbiAgICAgKiBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLCBgaW52b2tlYCwgYGtleXNgLFxuICAgICAqIGBrZXlzSW5gLCBgbWFwYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsIGBtZW1vaXplYCwgYG1lcmdlYCxcbiAgICAgKiBgbWl4aW5gLCBgbmVnYXRlYCwgYG5vb3BgLCBgb21pdGAsIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCxcbiAgICAgKiBgcGFydGl0aW9uYCwgYHBpY2tgLCBgcGxhbnRgLCBgcGx1Y2tgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCxcbiAgICAgKiBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmVhcmdgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLFxuICAgICAqIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNvcnRCeUFsbGAsIGBzb3J0QnlPcmRlcmAsIGBzcGxpY2VgLFxuICAgICAqIGBzcHJlYWRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsXG4gICAgICogYHRocm90dGxlYCwgYHRocnVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgdmFsdWVzSW5gLCBgd2hlcmVgLFxuICAgICAqIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHppcGAsIGFuZCBgemlwT2JqZWN0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGRlYnVycmAsXG4gICAgICogYGVuZHNXaXRoYCwgYGVzY2FwZWAsIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsXG4gICAgICogYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmluZFdoZXJlYCwgYGZpcnN0YCwgYGhhc2AsXG4gICAgICogYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLFxuICAgICAqIGBpc0Zpbml0ZWAsYGlzRnVuY3Rpb25gLCBgaXNNYXRjaGAsIGBpc05hdGl2ZWAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCxcbiAgICAgKiBgaXNUeXBlZEFycmF5YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLCBgbWF4YCwgYG1pbmAsXG4gICAgICogYG5vQ29uZmxpY3RgLCBgbm93YCwgYHBhZGAsIGBwYWRMZWZ0YCwgYHBhZFJpZ2h0YCwgYHBhcnNlSW50YCwgYHBvcGAsXG4gICAgICogYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLCBgcmVwZWF0YCwgYHJlc3VsdGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGBzaGlmdGAsIGBzaXplYCwgYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN1bWAsIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1MZWZ0YCxcbiAgICAgKiBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZCBgc2FtcGxlYCB3aWxsIHJldHVybiBhIHdyYXBwZWQgdmFsdWUgd2hlbiBgbmAgaXMgcHJvdmlkZWQsXG4gICAgICogb3RoZXJ3aXNlIGFuIHVud3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX2NoYWluX18nKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgYWxsIGNoYWluaW5nIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGNoYWluaW5nIGZvciBhbGwgd3JhcHBlciBtZXRob2RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthY3Rpb25zPVtdXSBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwsIGFjdGlvbnMpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBhY3Rpb25zIHx8IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgKGZ1bmN0aW9uKHgpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgICAqIChhbGwgYnV0IEZpcmVmb3ggT1MgY2VydGlmaWVkIGFwcHMsIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycywgYW5kXG4gICAgICAgKiB0aGUgUGxheVN0YXRpb24gMzsgZm9yY2VkIGBmYWxzZWAgZm9yIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHN1cHBvcnQuZnVuY0RlY29tcCA9IC9cXGJ0aGlzXFxiLy50ZXN0KGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydC5mdW5jTmFtZXMgPSB0eXBlb2YgRnVuY3Rpb24ubmFtZSA9PSAnc3RyaW5nJztcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgdGhlIERPTSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICB0cnkge1xuICAgICAgICBzdXBwb3J0LmRvbSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5ub2RlVHlwZSA9PT0gMTE7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc3VwcG9ydC5kb20gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgICAgICpcbiAgICAgICAqIEluIEZpcmVmb3ggPCA0LCBJRSA8IDksIFBoYW50b21KUywgYW5kIFNhZmFyaSA8IDUuMSBgYXJndW1lbnRzYCBvYmplY3RcbiAgICAgICAqIGluZGV4ZXMgYXJlIG5vbi1lbnVtZXJhYmxlLiBDaHJvbWUgPCAyNSBhbmQgTm9kZS5qcyA8IDAuMTEuMCB0cmVhdFxuICAgICAgICogYGFyZ3VtZW50c2Agb2JqZWN0IGluZGV4ZXMgYXMgbm9uLWVudW1lcmFibGUgYW5kIGZhaWwgYGhhc093blByb3BlcnR5YFxuICAgICAgICogY2hlY2tzIGZvciBpbmRleGVzIHRoYXQgZXhjZWVkIHRoZWlyIGZ1bmN0aW9uJ3MgZm9ybWFsIHBhcmFtZXRlcnMgd2l0aFxuICAgICAgICogYXNzb2NpYXRlZCB2YWx1ZXMgb2YgYDBgLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwcG9ydC5ub25FbnVtQXJncyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc3VwcG9ydC5ub25FbnVtQXJncyA9IHRydWU7XG4gICAgICB9XG4gICAgfSgwLCAwKSk7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZVxuICAgICAqIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2Ryb3BDb3VudF9fID0gMDtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBudWxsO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuX19hY3Rpb25zX18sXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIHZpZXdzID0gdGhpcy5fX3ZpZXdzX18sXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuXG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBhY3Rpb25zID8gYXJyYXlDb3B5KGFjdGlvbnMpIDogbnVsbDtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBpdGVyYXRlZXMgPyBhcnJheUNvcHkoaXRlcmF0ZWVzKSA6IG51bGw7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSB2aWV3cyA/IGFycmF5Q29weSh2aWV3cykgOiBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCk7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyYXkubGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMgPyBpdGVyYXRlZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9EUk9QX1dISUxFX0ZMQUcpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRvbmUgJiYgKGlzUmlnaHQgPyAoaW5kZXggPiBkYXRhLmluZGV4KSA6IChpbmRleCA8IGRhdGEuaW5kZXgpKSkge1xuICAgICAgICAgICAgICBkYXRhLmNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZGF0YS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoIWRhdGEuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgbGltaXQgPSBkYXRhLmxpbWl0O1xuICAgICAgICAgICAgICBpZiAoIShkYXRhLmRvbmUgPSBsaW1pdCA+IC0xID8gKGRhdGEuY291bnQrKyA+PSBsaW1pdCkgOiAhaXRlcmF0ZWUodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbmFtZSBDYWNoZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZSgpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gYGtleWAgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gICAgICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHB1c2hcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWF4YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWF4KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1pbmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1pbihhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc3VtYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVN1bShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9ICthcnJheVtsZW5ndGhdIHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0VmFsdWUgPT0gJ3VuZGVmaW5lZCcgPyBzb3VyY2VWYWx1ZSA6IG9iamVjdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbGlrZSBgYXNzaWduRGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IGlnbm9yZXNcbiAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWVzIHdoZW4gY2hlY2tpbmcgaWYgYSBwcm9wZXJ0eSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0IGFuZCBzb3VyY2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduT3duRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0VmFsdWUgPT0gJ3VuZGVmaW5lZCcgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKVxuICAgICAgICA/IHNvdXJjZVZhbHVlXG4gICAgICAgIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICAgICAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICBpZiAoIWN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb3B5KHNvdXJjZSwgb2JqZWN0LCBwcm9wcyk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcih2YWx1ZSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuXG4gICAgICAgIGlmICgocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmdzIGFuZCBpbmRpdmlkdWFsXG4gICAgICoga2V5IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IFtwcm9wc10gVGhlIHByb3BlcnR5IG5hbWVzIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KGNvbGxlY3Rpb24sIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICBpc0FyciA9IGlzTGVuZ3RoKGxlbmd0aCksXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocHJvcHNMZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAga2V5ID0gcGFyc2VGbG9hdChrZXkpO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc0luZGV4KGtleSwgbGVuZ3RoKSA/IGNvbGxlY3Rpb25ba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gY29weS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgb2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNhbGxiYWNrYCB3aGljaCBzdXBwb3J0cyBzcGVjaWZ5aW5nIHRoZVxuICAgICAqIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICA/IGZ1bmNcbiAgICAgICAgICA6IGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGJhc2VQcm9wZXJ0eShmdW5jICsgJycpXG4gICAgICAgIDogYmFzZU1hdGNoZXNQcm9wZXJ0eShmdW5jICsgJycsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCBgdmFsdWVgIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QpIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnO1xuXG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwgcmVzdWx0LCBrZXlzKHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbG9uZWFibGVUYWdzW3RhZ11cbiAgICAgICAgICAgID8gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKVxuICAgICAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgY29udGV4dC5PYmplY3QoKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYW4gaW5kZXhcbiAgICAgKiBvZiB3aGVyZSB0byBzbGljZSB0aGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBhcmd1bWVudHMgcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHdoaWNoIGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGNhY2hlID0gKGlzQ29tbW9uICYmIHZhbHVlcy5sZW5ndGggPj0gMjAwKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9ICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoZW5kID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgd2hpbGUgKHN0YXJ0IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kYCwgYF8uZmluZExhc3RgLCBgXy5maW5kS2V5YCwgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEtleV0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudFxuICAgICAqICBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMsIHJldEtleSkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJldEtleSA/IGtleSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggYWRkZWQgc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmdcbiAgICAgKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0RlZXAgU3BlY2lmeSBhIGRlZXAgZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RyaWN0IFJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYXJyYXlzIGFuZCBgYXJndW1lbnRzYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwLCBpc1N0cmljdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzRGVlcCwgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gICAgICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0b3IgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gICAgICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckluYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gdGhvc2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXMuXG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIC8vIFRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsLlxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IDAgfHwgKDEgLyB2YWx1ZSA9PSAxIC8gb3RoZXIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbFR5cGUgPSB0eXBlb2YgdmFsdWUsXG4gICAgICAgICAgb3RoVHlwZSA9IHR5cGVvZiBvdGhlcjtcblxuICAgICAgLy8gRXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXMuXG4gICAgICBpZiAoKHZhbFR5cGUgIT0gJ2Z1bmN0aW9uJyAmJiB2YWxUeXBlICE9ICdvYmplY3QnICYmIG90aFR5cGUgIT0gJ2Z1bmN0aW9uJyAmJiBvdGhUeXBlICE9ICdvYmplY3QnKSB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAvLyBSZXR1cm4gYGZhbHNlYCB1bmxlc3MgYm90aCB2YWx1ZXMgYXJlIGBOYU5gLlxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gICAgICBpZiAoIW9iaklzQXJyKSB7XG4gICAgICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbiAgICAgICAgaWYgKG9ialRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICAgICAgb2JqVGFnID0gb2JqZWN0VGFnO1xuICAgICAgICB9IGVsc2UgaWYgKG9ialRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgICBvYmpJc0FyciA9IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW90aElzQXJyKSB7XG4gICAgICAgIG90aFRhZyA9IG9ialRvU3RyaW5nLmNhbGwob3RoZXIpO1xuICAgICAgICBpZiAob3RoVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvdGhUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG90aElzQXJyID0gaXNUeXBlZEFycmF5KG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9iaklzT2JqID0gKG9ialRhZyA9PSBvYmplY3RUYWcgfHwgKGlzTG9vc2UgJiYgb2JqVGFnID09IGZ1bmNUYWcpKSxcbiAgICAgICAgICBvdGhJc09iaiA9IChvdGhUYWcgPT0gb2JqZWN0VGFnIHx8IChpc0xvb3NlICYmIG90aFRhZyA9PSBmdW5jVGFnKSksXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhKG9iaklzQXJyIHx8IG9iaklzT2JqKSkge1xuICAgICAgICByZXR1cm4gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTG9vc2UpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVUYWcgJiYgIShvYmpJc09iaiAmJiBvdGhJc09iaikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWxXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmICh2YWxXcmFwcGVkIHx8IG90aFdyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKHZhbFdyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZXRlY3RpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyBzZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNKTy5cbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF0gPT0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCBgb2JqZWN0YCBhbmQgYG90aGVyYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICBzdGFja0EucHVzaChvYmplY3QpO1xuICAgICAgc3RhY2tCLnB1c2gob3RoZXIpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXG4gICAgICBzdGFja0EucG9wKCk7XG4gICAgICBzdGFja0IucG9wKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgc291cmNlIHByb3BlcnR5IG5hbWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgc291cmNlIHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHJpY3RDb21wYXJlRmxhZ3MgU3RyaWN0IGNvbXBhcmlzb24gZmxhZ3MgZm9yIHNvdXJjZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHByb3BzLCB2YWx1ZXMsIHN0cmljdENvbXBhcmVGbGFncywgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBzdHJpY3RDb21wYXJlRmxhZ3NbaW5kZXhdKVxuICAgICAgICAgICAgICA/IHZhbHVlc1tpbmRleF0gIT09IG9iamVjdFtwcm9wc1tpbmRleF1dXG4gICAgICAgICAgICAgIDogIShwcm9wc1tpbmRleF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IHZhbHVlc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBzdHJpY3RDb21wYXJlRmxhZ3NbaW5kZXhdKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBvYmpWYWx1ZSAhPSAndW5kZWZpbmVkJyB8fCAoa2V5IGluIG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQucHVzaChpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQodHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBvYmplY3Rba2V5XSA9PT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJyB8fCAoa2V5IGluIHRvT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBzdHJpY3RDb21wYXJlRmxhZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFsdWUgPSBzb3VyY2VbcHJvcHNbbGVuZ3RoXV07XG4gICAgICAgIHZhbHVlc1tsZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIHN0cmljdENvbXBhcmVGbGFnc1tsZW5ndGhdID0gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGJhc2VJc01hdGNoKHRvT2JqZWN0KG9iamVjdCksIHByb3BzLCB2YWx1ZXMsIHN0cmljdENvbXBhcmVGbGFncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lcyBub3QgY29lcmNlIGBrZXlgXG4gICAgICogdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIG9iamVjdFtrZXldID09PSB2YWx1ZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJyB8fCAoa2V5IGluIHRvT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGJhc2VJc0VxdWFsKHZhbHVlLCBvYmplY3Rba2V5XSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICAgICAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIGlzU3JjQXJyID0gaXNMZW5ndGgoc291cmNlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSk7XG4gICAgICAoaXNTcmNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXksIHNvdXJjZSkge1xuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuICAgICAgICAgIHJldHVybiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzQ29tbW9uID0gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlzU3JjQXJyIHx8IHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzTGVuZ3RoKHNyY1ZhbHVlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogKCh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpID8gYXJyYXlDb3B5KHZhbHVlKSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0FyZ3VtZW50cyh2YWx1ZSlcbiAgICAgICAgICAgID8gdG9QbGFpbk9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGVcbiAgICAgIC8vIGl0IHdpdGggaXRzIG1lcmdlZCB2YWx1ZS5cbiAgICAgIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjb2VyY2UgYGtleWAgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgICAqIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRGcm9tQ29sbGVjdGlvbiBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnRcbiAgICAgKiAgb2YgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21Db2xsZWN0aW9uLCBlYWNoRnVuYykge1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEZyb21Db2xsZWN0aW9uXG4gICAgICAgICAgPyAoaW5pdEZyb21Db2xsZWN0aW9uID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmVcbiAgICAgKiB0aGUgc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlPcmRlcmAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYHByb3BzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIHByb3BzLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGlzTGVuZ3RoKGxlbmd0aCkgPyBBcnJheShsZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICBjcml0ZXJpYSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgY3JpdGVyaWFbbGVuZ3RoXSA9IHZhbHVlID09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbKytpbmRleF0gPSB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiBpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9ICtpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHx8IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSAyMDAsXG4gICAgICAgICAgc2VlbiA9IGlzTGFyZ2UgPyBjcmVhdGVDYWNoZSgpIDogbnVsbCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgMCkgPCAwKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZHJvcFJpZ2h0V2hpbGVgLCBgXy5kcm9wV2hpbGVgLCBgXy50YWtlUmlnaHRXaGlsZWAsXG4gICAgICogYW5kIGBfLnRha2VXaGlsZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiYgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3Jlc3VsdF0sXG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25zW2luZGV4XTtcblxuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFjdGlvbi5hcmdzKTtcbiAgICAgICAgcmVzdWx0ID0gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiaW5hcnlJbmRleGAgZXhjZXB0IHRoYXQgaXQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvclxuICAgICAqIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNVbmRlZiA9IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IGZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIGlzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSBpc1JlZmxleGl2ZSB8fCByZXRIaWdoZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWYpIHtcbiAgICAgICAgICBzZXRMb3cgPSBpc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCB0eXBlb2YgY29tcHV0ZWQgIT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICAgICAqIGFuZCBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXJTbGljZS5jYWxsKGJ1ZmZlciwgMCk7XG4gICAgfVxuICAgIGlmICghYnVmZmVyU2xpY2UpIHtcbiAgICAgIC8vIFBoYW50b21KUyBoYXMgYEFycmF5QnVmZmVyYCBhbmQgYFVpbnQ4QXJyYXlgIGJ1dCBub3QgYEZsb2F0NjRBcnJheWAuXG4gICAgICBidWZmZXJDbG9uZSA9ICEoQXJyYXlCdWZmZXIgJiYgVWludDhBcnJheSkgPyBjb25zdGFudChudWxsKSA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgZmxvYXRMZW5ndGggPSBGbG9hdDY0QXJyYXkgPyBmbG9vcihieXRlTGVuZ3RoIC8gRkxPQVQ2NF9CWVRFU19QRVJfRUxFTUVOVCkgOiAwLFxuICAgICAgICAgICAgb2Zmc2V0ID0gZmxvYXRMZW5ndGggKiBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGlmIChmbG9hdExlbmd0aCkge1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IEZsb2F0NjRBcnJheShyZXN1bHQsIDAsIGZsb2F0TGVuZ3RoKTtcbiAgICAgICAgICB2aWV3LnNldChuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlciwgMCwgZmxvYXRMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGFyZ3NMZW5ndGggKyBsZWZ0TGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgcmlnaHRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIHBhZCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbcGFkICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3BhZCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIGFjY3VtdWxhdG9yXG4gICAgICogb2JqZWN0IGNvbXBvc2VkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGFuIGl0ZXJhdGVlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgYF8uY291bnRCeWAsIGBfLmdyb3VwQnlgLCBgXy5pbmRleEJ5YCxcbiAgICAgKiBhbmQgYF8ucGFydGl0aW9uYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhc3NpZ25zIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byBhIGdpdmVuXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBhbmQgYF8ubWVyZ2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgb2JqZWN0ID0gYXJnc1swXTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbWl6ZXIgPSBhcmdzW2xlbmd0aCAtIDJdLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGFyZ3NbbGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBndWFyZCA9IGFyZ3NbM107XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IChsZW5ndGggPiAyICYmIHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicpID8gdGhpc0FyZyA6IG51bGw7XG4gICAgICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChhcmdzWzFdLCBhcmdzWzJdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID09IDMgPyBudWxsIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgYF8uZm9ySW5gIG9yIGBfLmZvckluUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kV3JhcHBlcihmdW5jLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIG5ldyBjYWNoZSBvYmplY3QgaWYgYFNldGAgaXMgc3VwcG9ydGVkLCBlbHNlIGBudWxsYC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlQ2FjaGUgPSAhKG5hdGl2ZUNyZWF0ZSAmJiBTZXQpID8gY29uc3RhbnQobnVsbCkgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgY29tcG91bmQgd29yZHMgb3V0IG9mIHRoZSB3b3JkcyBpbiBhXG4gICAgICogZ2l2ZW4gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJyYXkgPSB3b3JkcyhkZWJ1cnIoc3RyaW5nKSksXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHJlc3VsdCwgYXJyYXlbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcldyYXBwZXIoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBjdXJyeSBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmbGFnKSB7XG4gICAgICBmdW5jdGlvbiBjdXJyeUZ1bmMoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCBhcml0eSwgZ3VhcmQpKSB7XG4gICAgICAgICAgYXJpdHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlGdW5jLnBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJ5RnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ubWF4YCBvciBgXy5taW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgZXh0cmVtdW0gdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01pbl0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIG1pbmltdW0sIGluc3RlYWQgb2YgdGhlIG1heGltdW0sXG4gICAgICogIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGV4dHJlbXVtIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dHJlbXVtKGFycmF5RnVuYywgaXNNaW4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBnZXRDYWxsYmFjaygpLFxuICAgICAgICAgICAgbm9JdGVyYXRlZSA9IGl0ZXJhdGVlID09IG51bGw7XG5cbiAgICAgICAgaWYgKCEoZnVuYyA9PT0gYmFzZUNhbGxiYWNrICYmIG5vSXRlcmF0ZWUpKSB7XG4gICAgICAgICAgbm9JdGVyYXRlZSA9IGZhbHNlO1xuICAgICAgICAgIGl0ZXJhdGVlID0gZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vSXRlcmF0ZWUpIHtcbiAgICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmICghaXNBcnIgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gY2hhckF0Q2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXNBcnIgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyZW11bUJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBpc01pbik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBjb2xsZWN0aW9uW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRJbmRleGAgb3IgYF8uZmluZExhc3RJbmRleGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEluZGV4KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEtleWAgb3IgYF8uZmluZExhc3RLZXlgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEtleShvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kKG9iamVjdCwgcHJlZGljYXRlLCBvYmplY3RGdW5jLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzWzBdOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwcGVyLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IDAsXG4gICAgICAgICAgICBmdW5jcyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gd3JhcHBlciA/ICcnIDogZ2V0RnVuY05hbWUoZnVuYyk7XG4gICAgICAgICAgd3JhcHBlciA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IG5ldyBMb2Rhc2hXcmFwcGVyKFtdKSA6IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gLTEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpO1xuXG4gICAgICAgICAgdmFyIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogbnVsbDtcbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KGFyZ3NbMF0pLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKVxuICAgICAgICAgIDogZWFjaEZ1bmMoY29sbGVjdGlvbiwgYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9ySW5gIG9yIGBfLmZvckluUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9ySW4ob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzQXJnICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yT3duYCBvciBgXy5mb3JPd25SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JPd24ob2JqZWN0RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzQXJnICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnBhZExlZnRgIG9yIGBfLnBhZFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IHBhZGRpbmcgZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZERpcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBzdHJpbmcgJiYgKChmcm9tUmlnaHQgPyBzdHJpbmcgOiAnJykgKyBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykgKyAoZnJvbVJpZ2h0ID8gJycgOiBzdHJpbmcpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnBhcnRpYWxgIG9yIGBfLnBhcnRpYWxSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgcGFydGlhbCBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZmxhZykge1xuICAgICAgdmFyIHBhcnRpYWxGdW5jID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgbnVsbCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFydGlhbEZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5yZWR1Y2VgIG9yIGBfLnJlZHVjZVJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgICB2YXIgaW5pdEZyb21BcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KVxuICAgICAgICAgIDogYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCksIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5LCBlYWNoRnVuYyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBBUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgQ1VSUllfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgQ1VSUllfQk9VTkRfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5UmlnaHQgPSBiaXRtYXNrICYgQ1VSUllfUklHSFRfRkxBRztcblxuICAgICAgdmFyIEN0b3IgPSAhaXNCaW5kS2V5ICYmIGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyeSB8fCBpc0N1cnJ5UmlnaHQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB3cmFwcGVyLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICBhcmdzSG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGxlbmd0aCAtPSBhcmdzSG9sZGVycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJnUG9zID0gYXJnUG9zID8gYXJyYXlDb3B5KGFyZ1BvcykgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5ld0FyaXR5ID0gbmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSxcbiAgICAgICAgICAgICAgICBuZXdzSG9sZGVycyA9IGlzQ3VycnkgPyBhcmdzSG9sZGVycyA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IG51bGwgOiBhcmdzSG9sZGVycyxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBhcmdzIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IG51bGwgOiBhcmdzO1xuXG4gICAgICAgICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gUEFSVElBTF9GTEFHIDogUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gUEFSVElBTF9SSUdIVF9GTEFHIDogUEFSVElBTF9GTEFHKTtcblxuICAgICAgICAgICAgaWYgKCFpc0N1cnJ5Qm91bmQpIHtcbiAgICAgICAgICAgICAgYml0bWFzayAmPSB+KEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld3NIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LCBuZXdIb2xkZXJzUmlnaHQsIG5ld0FyZ1BvcywgYXJ5LCBuZXdBcml0eV0sXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuXG4gICAgICAgICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzO1xuICAgICAgICBpZiAoaXNCaW5kS2V5KSB7XG4gICAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyAoQ3RvciB8fCBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKSkgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyByZXF1aXJlZCBmb3IgYHN0cmluZ2AgYmFzZWQgb24gdGhlIGdpdmVuIGBsZW5ndGhgLlxuICAgICAqIFRoZSBgY2hhcnNgIHN0cmluZyBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjcmVhdGUgcGFkZGluZyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWQgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBzdHJMZW5ndGg7XG4gICAgICBjaGFycyA9IGNoYXJzID09IG51bGwgPyAnICcgOiAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gcmVwZWF0KGNoYXJzLCBjZWlsKHBhZExlbmd0aCAvIGNoYXJzLmxlbmd0aCkpLnNsaWNlKDAsIHBhZExlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiB0aGUgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWxXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCBgZnVuY2AuXG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGFyZ3NMZW5ndGggKyBsZWZ0TGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uc29ydGVkSW5kZXhgIG9yIGBfLnNvcnRlZExhc3RJbmRleGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbmRleCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTb3J0ZWRJbmRleChyZXRIaWdoZXN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIChmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgaXRlcmF0ZWUgPT0gbnVsbClcbiAgICAgICAgICA/IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdClcbiAgICAgICAgICA6IGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBmdW5jKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSwgcmV0SGlnaGVzdCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgIDI1NiAtIGBfLmFyeWBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihQQVJUSUFMX0ZMQUcgfCBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcbiAgICAgIGlmIChiaXRtYXNrICYgUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IG51bGwgOiBnZXREYXRhKGZ1bmMpLFxuICAgICAgICAgIG5ld0RhdGEgPSBbZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVs5XSA9IGFyaXR5ID09IG51bGxcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IChuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApIHx8IDApO1xuXG4gICAgICBpZiAoYml0bWFzayA9PSBCSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmRXcmFwcGVyKG5ld0RhdGFbMF0sIG5ld0RhdGFbMl0pO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBQQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoQklORF9GTEFHIHwgUEFSVElBTF9GTEFHKSkgJiYgIW5ld0RhdGFbNF0ubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWxXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWRXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIGFycmF5cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzTG9vc2UgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKHJlc3VsdCAmJiArK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0xvb3NlXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleClcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgaWYgKGlzTG9vc2UpIHtcbiAgICAgICAgICAgIHZhciBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbb3RoSW5kZXhdO1xuICAgICAgICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoYXJyVmFsdWUgJiYgYXJyVmFsdWUgPT09IG90aFZhbHVlKSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gK29iamVjdCA9PSArb3RoZXI7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgICAgICByZXR1cm4gKG9iamVjdCAhPSArb2JqZWN0KVxuICAgICAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcbiAgICAgICAgICAgIC8vIEJ1dCwgdHJlYXQgYC0wYCB2cy4gYCswYCBhcyBub3QgZXF1YWwuXG4gICAgICAgICAgICA6IChvYmplY3QgPT0gMCA/ICgoMSAvIG9iamVjdCkgPT0gKDEgLyBvdGhlcikpIDogb2JqZWN0ID09ICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MgcHJpbWl0aXZlcyBhbmQgc3RyaW5nXG4gICAgICAgICAgLy8gb2JqZWN0cyBhcyBlcXVhbC4gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc0xvb3NlLFxuICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF0sXG4gICAgICAgICAgICByZXN1bHQgPSBpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXNMb29zZVxuICAgICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXkpXG4gICAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIHJlc3VsdCA9IChvYmpWYWx1ZSAmJiBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGV4dHJlbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIHZhbHVlXG4gICAgICogaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWluXSBTcGVjaWZ5IHJldHVybmluZyB0aGUgbWluaW11bSwgaW5zdGVhZCBvZiB0aGVcbiAgICAgKiAgbWF4aW11bSwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dHJlbXVtQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGlzTWluKSB7XG4gICAgICB2YXIgZXhWYWx1ZSA9IGlzTWluID8gUE9TSVRJVkVfSU5GSU5JVFkgOiBORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgICBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIGlmICgoaXNNaW4gPyAoY3VycmVudCA8IGNvbXB1dGVkKSA6IChjdXJyZW50ID4gY29tcHV0ZWQpKSB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiY2FsbGJhY2tcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmNhbGxiYWNrYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VDYWxsYmFja2AgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmNhbGxiYWNrIHx8IGNhbGxiYWNrO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBjYWxsYmFjayA/IGJhc2VDYWxsYmFjayA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmdDb3VudCA/IHJlc3VsdChmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgdmFyIGdldEZ1bmNOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQoJycpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0YW50Lm5hbWUgPT0gJ2NvbnN0YW50Jykge1xuICAgICAgICByZXR1cm4gYmFzZVByb3BlcnR5KCduYW1lJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5uYW1lLFxuICAgICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcblxuICAgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258bnVtYmVyfSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmluZGV4T2YgfHwgaW5kZXhPZjtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyByZXN1bHQoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZm9ybXNdIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3JtcyA/IHRyYW5zZm9ybXMubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKCEodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IE9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gICAgICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlcmVxID0gdHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAocHJlcmVxKSB7XG4gICAgICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKTtcbiAgICAgIHJldHVybiAhIWZ1bmNOYW1lICYmIGZ1bmMgPT09IGxvZGFzaFtmdW5jTmFtZV0gJiYgZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAodmFsdWUgPT09IDAgPyAoKDEgLyB2YWx1ZSkgPiAwKSA6ICFpc09iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyByZXF1aXJlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmQgYF8ucmVhcmdgXG4gICAgICogYXVnbWVudCBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmUgZXhlY3V0ZWQgaW1wb3J0YW50LFxuICAgICAqIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2UgYW4gZXhjZXB0aW9uIGZvciBhIHNhZmVcbiAgICAgKiBjb21tb24gY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWAgYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCBBUllfRkxBRztcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpIHx8XG4gICAgICAgIChzcmNCaXRtYXNrID09IEFSWV9GTEFHICYmIGJpdG1hc2sgPT0gUkVBUkdfRkxBRyAmJiBkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pIHx8XG4gICAgICAgIChzcmNCaXRtYXNrID09IChBUllfRkxBRyB8IFJFQVJHX0ZMQUcpICYmIGJpdG1hc2sgPT0gQ1VSUllfRkxBRyk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEJJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IChiaXRtYXNrICYgQklORF9GTEFHKSA/IDAgOiBDVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzRdKTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs2XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEFSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2AgdGhhdCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIHNwZWNpZmllZFxuICAgICAqIGJ5IHRoZSBgcHJvcHNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5QXJyYXkob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHRoYXQgcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYFxuICAgICAqIHJldHVybnMgdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBiYXNlRm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBhcnJheUNvcHkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgICogdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbXAgPSBub3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlU2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3Igb3IgaGFzIGEgYFtbUHJvdG90eXBlXV1gXG4gICAgICogb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvcixcbiAgICAgICAgICBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQ7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIG5vbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcpIHx8XG4gICAgICAgICAgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY29uc3RydWN0b3InKSAmJlxuICAgICAgICAgICAgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0O1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS1saWtlIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZW5ndGgodmFsdWUubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQgaXMgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXJcbiAgICAgICAgPyB3cmFwcGVyLmNsb25lKClcbiAgICAgICAgOiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXywgYXJyYXlDb3B5KHdyYXBwZXIuX19hY3Rpb25zX18pKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBjb2xsZWN0aW9uYCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgY29udGFpbmluZyBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCgrc2l6ZSB8fCAxLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoY2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgM10sIFs0LCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgZmFsc2UsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4XSwgJyonLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCA4XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAnYmFybmV5JztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBjcmVhdGVGaW5kSW5kZXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAncGViYmxlcyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0SW5kZXggPSBjcmVhdGVGaW5kSW5kZXgodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgdGhlIGFycmF5IGlzIHJlY3Vyc2l2ZWx5XG4gICAgICogZmxhdHRlbmVkLCBvdGhlcndpc2UgaXQgaXMgb25seSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBpc0RlZXBgXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzRGVlcCwgZ3VhcmQpKSB7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXApIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVjdXJzaXZlbHkgZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsXG4gICAgICogaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHBlcmZvcm1zIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDJdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IGZyb21JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSksXG4gICAgICAgICAgICBvdGhlciA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wUmlnaHQoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIGBTYW1lVmFsdWVaZXJvYFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBbXSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZjtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2goKGlzQ29tbW9uICYmIHZhbHVlLmxlbmd0aCA+PSAxMjApID8gY3JlYXRlQ2FjaGUoYXJnc0luZGV4ICYmIHZhbHVlKSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICgoc2VlbiA/IGNhY2hlSW5kZXhPZihzZWVuLCB2YWx1ZSkgOiBpbmRleE9mKHJlc3VsdCwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICBhcmdzSW5kZXggPSBhcmdzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW2FyZ3NJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFyZ3NbYXJnc0luZGV4XSwgdmFsdWUsIDApKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb21cbiAgICAgKiAgb3IgYHRydWVgIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgZnJvbUluZGV4YFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDEsIDIsIDJdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4IHx8IDAsIGxlbmd0aCAtIDEpKSArIDE7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGluZGV4LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5XG4gICAgICogY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGVzOioqXG4gICAgICogIC0gVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWBcbiAgICAgKiAgLSBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiAgICBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdFxuICAgICAqICAgIHRoYXQgYE5hTmAgbWF0Y2hlcyBgTmFOYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJyYXkgPSBhcmdzWzBdO1xuXG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkpID4gLTEpIHtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZGV4ZXMgYW5kIHJldHVybnNcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mXG4gICAgICogaW5kZXhlcyBvciBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzUsIDEwLCAxNSwgMjBdO1xuICAgICAqIHZhciBldmVucyA9IF8ucHVsbEF0KGFycmF5LCAxLCAzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbNSwgMTVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzEwLCAyMF1cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBbXSk7XG4gICAgICBpbmRleGVzID0gYmFzZUZsYXR0ZW4oaW5kZXhlcyk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBpbmRleGVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlRmxvYXQoaW5kZXhlc1tsZW5ndGhdKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IHByZXZpb3VzICYmIGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3AoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlXG4gICAgICogbGlzdHMgaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkXG4gICAgICogYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLiBJZiBhbiBpdGVyYXRlZVxuICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5kYXRhW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRMYXN0SW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDRdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgZmFsc2UsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIGBTYW1lVmFsdWVaZXJvYFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gUHJvdmlkaW5nIGB0cnVlYCBmb3IgYGlzU29ydGVkYCBwZXJmb3JtcyBhIGZhc3RlclxuICAgICAqIHNlYXJjaCBhbGdvcml0aG0gZm9yIHNvcnRlZCBhcnJheXMuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0XG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW5pcXVlXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdIFNwZWNpZnkgdGhlIGFycmF5IGlzIHNvcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gICAgICogXy51bmlxKFsxLCAxLCAyXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPSBudWxsICYmIHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKCk7XG4gICAgICBpZiAoIShmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgaXRlcmF0ZWUgPT0gbnVsbCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSBmdW5jKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaXNTb3J0ZWQgJiYgZ2V0SW5kZXhPZigpID09IGJhc2VJbmRleE9mKVxuICAgICAgICA/IHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKVxuICAgICAgICA6IGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS1gXy56aXBgXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIGFycmF5TWF4KGFycmF5TWFwKGFycmF5LCBnZXRMZW5ndGgpKSkgPj4+IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yXG4gICAgICogZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDJdLCBbNCwgMl0pO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgPyBiYXNlVW5pcShyZXN1bHQpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kIGVsZW1lbnRzXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gcmVzdFBhcmFtKHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnBhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXNcbiAgICAgKiBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzLiBQcm92aWRlIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksXG4gICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gIG9yIHR3byBhcnJheXMsIG9uZSBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoW1snZnJlZCcsIDMwXSwgWydiYXJuZXknLCA0MF1dKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzID8gcHJvcHMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKGxlbmd0aCAmJiAhdmFsdWVzICYmICFpc0FycmF5KHByb3BzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgICByZXR1cm4gY2hyLnVzZXIgKyAnIGlzICcgKyBjaHIuYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnNcbiAgICAgKiBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmZpcnN0KCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZXIgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlciA9IHdyYXBwZXIuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlci5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbmVkIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlciA9IF8oYXJyYXkpLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIE1hdGgucG93KHZhbHVlLCAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IFszLCA0XTtcbiAgICAgKiB2YXIgb3RoZXJXcmFwcGVyID0gd3JhcHBlci5wbGFudChvdGhlcik7XG4gICAgICpcbiAgICAgKiBvdGhlcldyYXBwZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIHdyYXBwZWQgYXJyYXkgc28gdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLnJldmVyc2UoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIHJlc3VsdCBvZiBjb2VyY2luZyB0aGUgdW53cmFwcGVkIHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvZXJjZWQgc3RyaW5nIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKCkgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgdG8gZXh0cmFjdCB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBydW4sIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4ga2V5cywgb3IgaW5kZXhlcyxcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAuIEtleXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBrZXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbcHJvcHNdIFRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqICBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2ssIHNwZWNpZmllZCBpbmRpdmlkdWFsbHkgb3IgaW4gYXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJ10sIFswLCAyXSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAncGViYmxlcyddXG4gICAgICovXG4gICAgdmFyIGF0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGlmIChpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VBdChjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyArK3Jlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzQsIDUsIDZdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChiYXNlRWFjaFJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRXaGVyZShjb2xsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmaW5kKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlLWtleSBwYWlyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obikge1xuICAgICAqICAgY29uc29sZS5sb2cobik7XG4gICAgICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoUmlnaHQgPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaFJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcbiAgICAgKiB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5XG4gICAgICogY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXQgZnJvbVxuICAgICAqIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbnRhaW5zLCBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkpKSB7XG4gICAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiAoZnJvbUluZGV4IHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0eXBlb2YgY29sbGVjdGlvbiA9PSAnc3RyaW5nJyB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgPyAoZnJvbUluZGV4IDwgbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleURhdGEgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCxcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWxcbiAgICAgKiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uXG4gICAgICogaXQgaXMgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gaXNMZW5ndGgobGVuZ3RoKSA/IEFycmF5KGxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2ROYW1lIDogKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbbWV0aG9kTmFtZV0pO1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaFxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaW50ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNhbGxiYWNrYCwgYGNodW5rYCwgYGNsb25lYCwgYGNyZWF0ZWAsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLFxuICAgICAqIGBkcm9wUmlnaHRgLCBgZXZlcnlgLCBgZmlsbGAsIGBmbGF0dGVuYCwgYGludmVydGAsIGBtYXhgLCBgbWluYCwgYHBhcnNlSW50YCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydEJ5YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUxlZnRgLFxuICAgICAqIGB0cmltUmlnaHRgLCBgdHJ1bmNgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHNhbXBsZWAsIGBzb21lYCwgYHVuaXFgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiAgY3JlYXRlIGEgYF8ucHJvcGVydHlgIG9yIGBfLm1hdGNoZXNgIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHRpbWVzVGhyZWUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyXSwgdGltZXNUaHJlZSk7XG4gICAgICogLy8gPT4gWzMsIDZdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogMSwgJ2InOiAyIH0sIHRpbWVzVGhyZWUpO1xuICAgICAqIC8vID0+IFszLCA2XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHdoaWxlIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFtbMSwgM10sIFsyXV1cbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKFsxLjIsIDIuMywgMy40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3IobikgJSAyO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFtbMS4yLCAzLjRdLCBbMi4zXV1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZXIgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgcmV0dXJuIF8ucGx1Y2soYXJyYXksICd1c2VyJyk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCBtYXBwZXIpO1xuICAgICAqIC8vID0+IFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnLCBmYWxzZSksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYGtleWAgZnJvbSBhbGwgZWxlbWVudHMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2sodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiB2YXIgdXNlckluZGV4ID0gXy5pbmRleEJ5KHVzZXJzLCAndXNlcicpO1xuICAgICAqIF8ucGx1Y2sodXNlckluZGV4LCAnYWdlJyk7XG4gICAgICogLy8gPT4gWzM2LCA0MF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBrZXkpIHtcbiAgICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgYmFzZVByb3BlcnR5KGtleSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpbnRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBzb3J0QnlBbGxgLCBhbmQgYHNvcnRCeU9yZGVyYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlID0gY3JlYXRlUmVkdWNlKGFycmF5UmVkdWNlLCBiYXNlRWFjaCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICB2YXIgcmVkdWNlUmlnaHQgPSAgY3JlYXRlUmVkdWNlKGFycmF5UmVkdWNlUmlnaHQsIGJhc2VFYWNoUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlamVjdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPiAwID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuIDwgMCA/IDAgOiAoK24gfHwgMCksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uID0gdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKDAsIGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4ICE9IHJhbmQpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0xlbmd0aChsZW5ndGgpID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYSBwYXNzaW5nIHZhbHVlIGFuZCBkb2VzIG5vdCBpdGVyYXRlXG4gICAgICogb3ZlciB0aGUgZW50aXJlIGNvbGxlY3Rpb24uIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykpIHtcbiAgICAgICAgcHJlZGljYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXNBcmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoaXMgbWV0aG9kIHBlcmZvcm1zXG4gICAgICogYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uXG4gICAgICogIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpc1xuICAgICAqICB1c2VkIHRvIGNyZWF0ZSBhIGBfLnByb3BlcnR5YCBvciBgXy5tYXRjaGVzYCBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnNpbihuKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuc2luKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGlzTGVuZ3RoKGxlbmd0aCkgPyBBcnJheShsZW5ndGgpIDogW107XG5cbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0geyAnY3JpdGVyaWEnOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgJ2luZGV4JzogaW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgY29tcGFyZUFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IHNvcnRzIGJ5IHByb3BlcnR5IG5hbWVzXG4gICAgICogaW5zdGVhZCBvZiBhbiBpdGVyYXRlZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gc29ydCBieSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHkgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgWyd1c2VyJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeUFsbCgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGNvbGxlY3Rpb24gPSBhcmdzWzBdLFxuICAgICAgICAgIGd1YXJkID0gYXJnc1szXSxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcHJvcHNbaW5kZXhdID0gYXJnc1srK2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChhcmdzWzFdLCBhcmdzWzJdLCBndWFyZCkpIHtcbiAgICAgICAgcHJvcHMgPSBhcmdzWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihwcm9wcyksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeUFsbGAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogc29ydCBvcmRlcnMgb2YgdGhlIHByb3BlcnR5IG5hbWVzIHRvIHNvcnQgYnkuIEEgdHJ1dGh5IHZhbHVlIGluIGBvcmRlcnNgXG4gICAgICogd2lsbCBzb3J0IHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWUgaW4gYXNjZW5kaW5nIG9yZGVyIHdoaWxlIGFcbiAgICAgKiBmYWxzZXkgdmFsdWUgd2lsbCBzb3J0IGl0IGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYHByb3BzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDI2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gc29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICogXy5tYXAoXy5zb3J0QnlPcmRlcih1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbdHJ1ZSwgZmFsc2VdKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAyNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgMzBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIHByb3BzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChwcm9wcywgb3JkZXJzLCBndWFyZCkpIHtcbiAgICAgICAgb3JkZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcyA9PSBudWxsID8gW10gOiBbcHJvcHNdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBwcm9wcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuYXRpdmVJc0Zpbml0ZShuID0gK24pID8gbiA6IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGBuYCBhcmd1bWVudHMgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuICAgICAgICBuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuYXRpdmVNYXgoK24gfHwgMCwgMCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBBUllfRkxBRywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQgaXMgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeSgnI2FkZCcpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBhbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBuO1xuICAgICAgICAgIG4gPSBmdW5jO1xuICAgICAgICAgIGZ1bmMgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYF8uYmluZGAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgIHRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGBcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZC5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCBlbnVtZXJhYmxlIGZ1bmN0aW9uXG4gICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW21ldGhvZE5hbWVzXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGxvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiB0aGUgZWxlbWVudCBpcyBjbGlja2VkXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgbWV0aG9kTmFtZXMgPSBtZXRob2ROYW1lcy5sZW5ndGggPyBiYXNlRmxhdHRlbihtZXRob2ROYW1lcykgOiBmdW5jdGlvbnMob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kTmFtZXNbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIEJJTkRfRkxBRywgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCBhbmQgcHJlcGVuZHNcbiAgICAgKiBhbnkgYWRkaXRpb25hbCBgXy5iaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL21pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kS2V5LnBsYWNlaG9sZGVyKTtcbiAgICAgICAgYml0bWFzayB8PSBQQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGNhbGxlZCBlaXRoZXIgaW52b2tlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIGN1cnJ5ID0gY3JlYXRlQ3VycnkoQ1VSUllfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeVJpZ2h0ID0gY3JlYXRlQ3VycnkoQ1VSUllfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHNcbiAgICAgKiBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC4gVGhlIGNyZWF0ZWQgZnVuY3Rpb24gY29tZXNcbiAgICAgKiB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnNcbiAgICAgKiBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yXG4gICAgICogdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIGRlYm91bmNlZFxuICAgICAqIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZVxuICAgICAqICBkZWxheWVkIGJlZm9yZSBpdCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcbiAgICAgKiB2YXIgdG9kb0NoYW5nZXMgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAxMDAwKTtcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMudG9kbywgdG9kb0NoYW5nZXMpO1xuICAgICAqXG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLCBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICogICBpZiAoXy5maW5kKGNoYW5nZXMsIHsgJ3VzZXInOiAndG9kbycsICd0eXBlJzogJ2RlbGV0ZSd9KSkge1xuICAgICAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9LCBbJ2RlbGV0ZSddKTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmF0IHNvbWUgcG9pbnQgYG1vZGVscy50b2RvYCBpcyBjaGFuZ2VkXG4gICAgICogbW9kZWxzLnRvZG8uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmJlZm9yZSAxIHNlY29uZCBoYXMgcGFzc2VkIGBtb2RlbHMudG9kb2AgaXMgZGVsZXRlZFxuICAgICAqIC8vIHdoaWNoIGNhbmNlbHMgdGhlIGRlYm91bmNlZCBgdG9kb0NoYW5nZXNgIGNhbGxcbiAgICAgKiBkZWxldGUgbW9kZWxzLnRvZG87XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHdhaXQgPCAwID8gMCA6ICgrd2FpdCB8fCAwKTtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiBtYXhXYWl0O1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KF8uYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBiYWNrZmxvdywgY29tcG9zZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcgYW5kIHVzZWQgYXMgdGhlXG4gICAgICogY2FjaGUga2V5LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGUgW2BNYXBgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXBwZXJDYXNlID0gXy5tZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHVwcGVyQ2FzZS5jYWNoZS5zZXQoJ2ZyZWQnLCAnQkFSTkVZJyk7XG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0JBUk5FWSdcbiAgICAgKlxuICAgICAqIC8vIHJlcGxhY2luZyBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdiYXJuZXknIH07XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcbiAgICAgKlxuICAgICAqIGlkZW50aXR5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogaWRlbnRpdHkob3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IG1lbW9pemUuQ2FjaGU7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgaW52b2tlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoZnVuYywgMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0XG4gICAgICogaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9SSUdIVF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIDIsIDAsIDEpO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogdmFyIG1hcCA9IF8ucmVhcmcoXy5tYXAsIFsxLCAwXSk7XG4gICAgICogbWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9LCBbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBSRUFSR19GTEFHLCBudWxsLCBudWxsLCBudWxsLCBiYXNlRmxhdHRlbihpbmRleGVzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heCh0eXBlb2Ygc3RhcnQgPT0gJ3VuZGVmaW5lZCcgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHJlc3Q7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2UgW2BGdW5jdGlvbiNhcHBseWBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC4zKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL1NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgUHJvbWlzZVxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJyYXkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzLiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0XG4gICAgICogYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSB0cmFpbGluZyB0aHJvdHRsZWQgY2FsbFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gK3dhaXQ7XG4gICAgICBkZWJvdW5jZU9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlXG4gICAgICogYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHdyYXBwZXIgPSB3cmFwcGVyID09IG51bGwgPyBpZGVudGl0eSA6IHdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCBQQVJUSUFMX0ZMQUcsIG51bGwsIFt2YWx1ZV0sIFtdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIGFyZSBjbG9uZWQsXG4gICAgICogb3RoZXJ3aXNlIHRoZXkgYXJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gICAgICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKHVzZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUodXNlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoaXNEZWVwICYmIHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIpKSB7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGlzRGVlcCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjdXN0b21pemVyO1xuICAgICAgICBjdXN0b21pemVyID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nICYmIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAxKTtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nXG4gICAgICogaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gICAgICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKHVzZXJzKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXAoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBlbC5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBpc09iamVjdExpa2UodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGlzTGVuZ3RoKGxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gISF2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIChvYmpUb1N0cmluZy5jYWxsKHZhbHVlKS5pbmRleE9mKCdFbGVtZW50JykgPiAtMSk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGZvciBlbnZpcm9ubWVudHMgd2l0aG91dCBET00gc3VwcG9ydC5cbiAgICBpZiAoIXN1cHBvcnQuZG9tKSB7XG4gICAgICBpc0VsZW1lbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eSB1bmxlc3MgaXQgaXMgYW5cbiAgICAgKiBgYXJndW1lbnRzYCBvYmplY3QsIGFycmF5LCBzdHJpbmcsIG9yIGpRdWVyeS1saWtlIGNvbGxlY3Rpb24gd2l0aCBhIGxlbmd0aFxuICAgICAqIGdyZWF0ZXIgdGhhbiBgMGAgb3IgYW4gb2JqZWN0IHdpdGggb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKGlzTGVuZ3RoKGxlbmd0aCkgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAha2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kXG4gICAgICogaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciBbLCBpbmRleHxrZXldKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICogYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmQgc3VwcG9ydFxuICAgICAqIGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwoYXJyYXksIG90aGVyLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIGlmIChfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMyk7XG4gICAgICBpZiAoIWN1c3RvbWl6ZXIgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSAmJiBpc1N0cmljdENvbXBhcmFibGUob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGVycm9yVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLmlzZmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMTApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRmluaXRlID0gbmF0aXZlTnVtSXNGaW5pdGUgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRnVuY3Rpb24gPSAhKGJhc2VJc0Z1bmN0aW9uKC94LykgfHwgKFVpbnQ4QXJyYXkgJiYgIWJhc2VJc0Z1bmN0aW9uKFVpbnQ4QXJyYXkpKSkgPyBiYXNlSXNGdW5jdGlvbiA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gICAgICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHR5cGUgPT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkXG4gICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgb3RoZXIsIGluZGV4fGtleSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIHByb3BlcnRpZXMgb2YgYXJyYXlzLCBib29sZWFucyxcbiAgICAgKiBgRGF0ZWAgb2JqZWN0cywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcbiAgICAgKiBzdXBwb3J0IGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pIHx8IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKCFjdXN0b21pemVyICYmIGxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgICAgIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG9iamVjdFtrZXldICYmICh0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCcgfHwgKGtleSBpbiB0b09iamVjdChvYmplY3QpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHN0cmljdENvbXBhcmVGbGFncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlc1tsZW5ndGhdID0gc291cmNlW3Byb3BzW2xlbmd0aF1dO1xuICAgICAgICBzdHJpY3RDb21wYXJlRmxhZ3NbbGVuZ3RoXSA9IGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2godG9PYmplY3Qob2JqZWN0KSwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub3QgdGhlIHNhbWUgYXMgW2Bpc05hTmBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40KVxuICAgICAqIHdoaWNoIHJldHVybnMgYHRydWVgIGZvciBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWcpIHtcbiAgICAgICAgcmV0dXJuIHJlTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUhvc3RDdG9yLnRlc3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZSBjbGFzc2lmaWVkXG4gICAgICogYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzguNCcpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFzc3VtZXMgb2JqZWN0cyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvclxuICAgICAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCEodmFsdWUgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwVGFnKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgICAgKiB9KDEsIDIsIDMpKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWUgPyB2YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogNDAgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyA/IG90aGVyIDogdmFsdWU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VBc3NpZ24pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICAgICAqIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSkge1xuICAgICAgICBwcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYmFzZUNvcHkocHJvcGVydGllcywgcmVzdWx0LCBrZXlzKHByb3BlcnRpZXMpKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goYXNzaWduRGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIGFzc2lnbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kS2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmdcbiAgICAgKiBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJywgJ2InLCBhbmQgJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duUmlnaHQgPSBjcmVhdGVGb3JPd24oYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FmdGVyJywgJ2FyeScsICdhc3NpZ24nLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBrZXlgIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCBpbnN0ZWFkIG9mIGFuXG4gICAgICogaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgaXMgYSBkaXJlY3QgcHJvcGVydHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlIHByb3BlcnR5XG4gICAgICogYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzIHVubGVzcyBgbXVsdGlWYWx1ZWAgaXMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlWYWx1ZV0gQWxsb3cgbXVsdGlwbGUgdmFsdWVzIHBlciBrZXkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGBtdWx0aVZhbHVlYFxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCwgdHJ1ZSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpKSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICAgICAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90J10gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGVcbiAgICAgKiBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBvbWl0LCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BzWzBdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMpLCBTdHJpbmcpO1xuICAgICAgICByZXR1cm4gcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRGlmZmVyZW5jZShrZXlzSW4ob2JqZWN0KSwgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKTtcbiAgICAgIHJldHVybiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIHRoZSBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgLFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFpcnMoeyAnYmFybmV5JzogMzYsICdmcmVkJzogNDAgfSk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLiBQcm9wZXJ0eVxuICAgICAqIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mIHByb3BlcnR5XG4gICAgICogbmFtZXMuIElmIGBwcmVkaWNhdGVgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGVhY2ggcHJvcGVydHkgb2YgYG9iamVjdGBcbiAgICAgKiBwaWNraW5nIHRoZSBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIF8uaXNTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHByb3BzWzBdID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGJpbmRDYWxsYmFjayhwcm9wc1swXSwgcHJvcHNbMV0sIDMpKVxuICAgICAgICA6IHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgdGhlIHZhbHVlIG9mIGBrZXlgIGlzXG4gICAgICogYSBmdW5jdGlvbiBpdCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBvYmplY3RgIGFuZCBpdHMgcmVzdWx0XG4gICAgICogaXMgcmV0dXJuZWQsIGVsc2UgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJldHVybmVkLiBJZiB0aGUgcHJvcGVydHkgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiAgcmVzb2x2ZXMgdG8gYHVuZGVmaW5lZGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IF8uY29uc3RhbnQoNDApIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiA0MFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3RhdHVzJywgJ2J1c3knKTtcbiAgICAgKiAvLyA9PiAnYnVzeSdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3N0YXR1cycsIF8uY29uc3RhbnQoJ2J1c3knKSk7XG4gICAgICogLy8gPT4gJ2J1c3knXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRvciBmdW5jdGlvbnNcbiAgICAgKiBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKGlzRnVuY3Rpb24oQ3RvcikgJiYgQ3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG5gIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICtlbmQgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA+PSBzdGFydCAmJiB2YWx1ZSA8IGVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG4gICAgICogbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgaXNJdGVyYXRlZUNhbGwobWluLCBtYXgsIGZsb2F0aW5nKSkge1xuICAgICAgICBtYXggPSBmbG9hdGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9NYXggJiYgdHlwZW9mIG1pbiA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgbm9NYXggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gKHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2FwaXRhbGl6ZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiAoc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmcgW2xhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZyBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbjEsIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFya3MsICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gKHRhcmdldCArICcnKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHR5cGVvZiBwb3NpdGlvbiA9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgbGVuZ3RoKTtcblxuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5pbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIFwiJ1wiLCBhbmQgXCJcXGBcIiwgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWwgY2hhcmFjdGVyc1xuICAgICAqIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIFNlZSBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBCYWNrdGlja3MgYXJlIGVzY2FwZWQgYmVjYXVzZSBpbiBJbnRlcm5ldCBFeHBsb3JlciA8IDksIHRoZXkgY2FuIGJyZWFrIG91dFxuICAgICAqIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy4gU2VlIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSxcbiAgICAgKiBbIzEwOF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwOCksIGFuZCBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2ZcbiAgICAgKiB0aGUgW0hUTUw1IFNlY3VyaXR5IENoZWF0c2hlZXRdKGh0dHBzOi8vaHRtbDVzZWMub3JnLykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXMgW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKVxuICAgICAqIHRvIHJlZHVjZSBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgLy8gUmVzZXQgYGxhc3RJbmRleGAgYmVjYXVzZSBpbiBJRSA8IDkgYFN0cmluZyNyZXBsYWNlYCBkb2VzIG5vdC5cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJcXFwiLCBcIi9cIiwgXCJeXCIsIFwiJFwiLCBcIi5cIiwgXCJ8XCIsIFwiP1wiLFxuICAgICAqIFwiKlwiLCBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczpcXC9cXC9sb2Rhc2hcXC5jb21cXC9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXJzLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0IGlzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBmbG9vcihtaWQpLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gY2VpbChtaWQpO1xuXG4gICAgICBjaGFycyA9IGNyZWF0ZVBhZGRpbmcoJycsIHJpZ2h0TGVuZ3RoLCBjaGFycyk7XG4gICAgICByZXR1cm4gY2hhcnMuc2xpY2UoMCwgbGVmdExlbmd0aCkgKyBzdHJpbmcgKyBjaGFycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQgaXMgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICB2YXIgcGFkTGVmdCA9IGNyZWF0ZVBhZERpcigpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCBpcyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGUgW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNFKVxuICAgICAqIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHJhZGl4LCBndWFyZCkpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0cmluZywgcmFkaXgpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGggcHJlLUVTNSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSAhPSA4KSB7XG4gICAgICBwYXJzZUludCA9IGZ1bmN0aW9uKHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gdHJpbSBsZWFkaW5nIDxCT00+IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTA5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSB0cmltKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG4gPSArbjtcbiAgICAgIGlmIChuIDwgMSB8fCAhc3RyaW5nIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGZsb29yKG4gLyAyKTtcbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMXSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW290aGVyT3B0aW9uc10gRW5hYmxlcyB0aGUgbGVnYWN5IGBvcHRpb25zYCBwYXJhbSBzaWduYXR1cmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVyc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTIGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWBcbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgb3RoZXJPcHRpb25zKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChvdGhlck9wdGlvbnMgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvdGhlck9wdGlvbnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYmFzZUFzc2lnbihiYXNlQXNzaWduKHt9LCBvdGhlck9wdGlvbnMgfHwgb3B0aW9ucyksIHNldHRpbmdzLCBhc3NpZ25Pd25EZWZhdWx0cyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYmFzZUFzc2lnbihiYXNlQXNzaWduKHt9LCBvcHRpb25zLmltcG9ydHMpLCBzZXR0aW5ncy5pbXBvcnRzLCBhc3NpZ25Pd25EZWZhdWx0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoJ3NvdXJjZVVSTCcgaW4gb3B0aW9uc1xuICAgICAgICAgID8gb3B0aW9ucy5zb3VyY2VVUkxcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpLCB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICBjaGFycyA9IChjaGFycyArICcnKTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycyksIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUxlZnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SaWdodChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0IGlzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIDI0KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmMoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyAoK29wdGlvbnMubGVuZ3RoIHx8IDApIDogbGVuZ3RoO1xuICAgICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gK29wdGlvbnMgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAobGVuZ3RoID49IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBvbWlzc2lvbi5sZW5ndGg7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBuZXdFbmQsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpIHx8ICcnKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT0gbnVsbCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbCBIVE1MXG4gICAgICogZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkpIHtcbiAgICAgICAgcGF0dGVybiA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybiB8fCByZVdvcmRzKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9yc1xuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUgdGhlXG4gICAgICogY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2BcbiAgICAgKiBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpblxuICAgICAqIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGl0ZXJhdGVlXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY2FsbGJhY2sgPSBfLndyYXAoXy5jYWxsYmFjaywgZnVuY3Rpb24oY2FsbGJhY2ssIGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhmdW5jKTtcbiAgICAgKiAgIGlmICghbWF0Y2gpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgICAqICAgfVxuICAgICAqICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0J1xuICAgICAqICAgICAgID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdXG4gICAgICogICAgICAgOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhZ2VfX2d0MzYnKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZnVuYywgdGhpc0FyZywgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCB0aGlzQXJnLCBndWFyZCkpIHtcbiAgICAgICAgdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKGZ1bmMpXG4gICAgICAgID8gbWF0Y2hlcyhmdW5jKVxuICAgICAgICA6IGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGdldHRlcigpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggcGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuIG9iamVjdFxuICAgICAqIGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ubWF0Y2hlcyh7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBrZXlgIG9uIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgXy5tYXRjaGVzUHJvcGVydHkoJ3VzZXInLCAnZnJlZCcpKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkoa2V5ICsgJycsIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiB0aGVuIG1ldGhvZHMgYXJlIGFkZGVkIHRvXG4gICAgICogaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uXG4gICAgICogZm9yIG1peGlucyB0byBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PXRoaXNdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWRcbiAgICAgKiAgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2UgYF8ucnVuSW5Db250ZXh0YCB0byBhdm9pZCBjb25mbGljdHMgKGVzcC4gaW4gTm9kZS5qcylcbiAgICAgKiB2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLnJ1bkluQ29udGV4dCgpO1xuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgdmFyIGlzT2JqID0gaXNPYmplY3Qoc291cmNlKSxcbiAgICAgICAgICAgIHByb3BzID0gaXNPYmogJiYga2V5cyhzb3VyY2UpLFxuICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSBwcm9wcyAmJiBwcm9wcy5sZW5ndGggJiYgYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgICBpZiAoIShtZXRob2ROYW1lcyA/IG1ldGhvZE5hbWVzLmxlbmd0aCA6IGlzT2JqKSkge1xuICAgICAgICAgIG1ldGhvZE5hbWVzID0gZmFsc2U7XG4gICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBtZXRob2ROYW1lc1tpbmRleF0sXG4gICAgICAgICAgICBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuXG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBhcnJheUNvcHkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFt0aGlzLnZhbHVlKCldO1xuICAgICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0oZnVuYykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYHVuZGVmaW5lZGAgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBrZXlgIG9uIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCd1c2VyJyk7XG4gICAgICpcbiAgICAgKiBfLm1hcCh1c2VycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCBnZXROYW1lKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBiYXNlUHJvcGVydHkoa2V5ICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gICAgICogdGhlIHByb3BlcnR5IHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAzLCAnYic6IDEsICdjJzogMiB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhJywgJ2MnXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFszLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWydhJywgJ2InLCAnYyddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWydiJywgJ2MnLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzXG4gICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYGVuZGBcbiAgICAgKiBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgZW5kID0gc3RlcCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiAoK3N0ZXAgfHwgMCk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgLy8gVXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1cyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggaW52b2NhdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYsIGZhbHNlKSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIG1hZ2UuY2FzdFNwZWxsKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcyB3aXRoIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYCByZXNwZWN0aXZlbHlcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgdGhpcy5jYXN0KG4pO1xuICAgICAqIH0sIG1hZ2UpO1xuICAgICAqIC8vID0+IGFsc28gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIG4gPSArbjtcblxuICAgICAgLy8gRXhpdCBlYXJseSB0byBhdm9pZCBhIEpTQyBKSVQgYnVnIGluIFNhZmFyaSA4XG4gICAgICAvLyB3aGVyZSBgQXJyYXkoMClgIGlzIHRyZWF0ZWQgYXMgYEFycmF5KDEpYC5cbiAgICAgIGlmIChuIDwgMSB8fCAhbmF0aXZlSXNGaW5pdGUobikpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpKTtcblxuICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGlmIChpbmRleCA8IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gYmFzZVRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgdG8gYWRkLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGQoYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oYXJyYXlNYXgpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbih1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBtaW4gPSBjcmVhdGVFeHRyZW11bShhcnJheU1pbiwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgNl0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiBfLnN1bSh7ICdhJzogNCwgJ2InOiA2IH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ24nOiA0IH0sXG4gICAgICogICB7ICduJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc3VtKG9iamVjdHMsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIG9iamVjdC5uO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc3VtKG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKCksXG4gICAgICAgICAgbm9JdGVyYXRlZSA9IGl0ZXJhdGVlID09IG51bGw7XG5cbiAgICAgIGlmICghKGZ1bmMgPT09IGJhc2VDYWxsYmFjayAmJiBub0l0ZXJhdGVlKSkge1xuICAgICAgICBub0l0ZXJhdGVlID0gZmFsc2U7XG4gICAgICAgIGl0ZXJhdGVlID0gZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9JdGVyYXRlZVxuICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSlcbiAgICAgICAgOiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBNYXBgIGNhY2hlLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcEdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBTZXQ7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU2V0YCBjYWNoZS5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIC8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmVzdFBhcmFtID0gcmVzdFBhcmFtO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0QnlBbGwgPSBzb3J0QnlBbGw7XG4gICAgbG9kYXNoLnNvcnRCeU9yZGVyID0gc29ydEJ5T3JkZXI7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmJhY2tmbG93ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5jb21wb3NlID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmluZFdoZXJlID0gZmluZFdoZXJlO1xuICAgIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkTGVmdCA9IHBhZExlZnQ7XG4gICAgbG9kYXNoLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuICAgIGxvZGFzaC50cmltUmlnaHQgPSB0cmltUmlnaHQ7XG4gICAgbG9kYXNoLnRydW5jID0gdHJ1bmM7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLl9fY2hhaW5fXyAmJiBuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHZhbHVlLCBuKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2Ryb3BXaGlsZScsICdmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCB0eXBlKSB7XG4gICAgICB2YXIgaXNGaWx0ZXIgPSB0eXBlICE9IExBWllfTUFQX0ZMQUcsXG4gICAgICAgICAgaXNEcm9wV2hpbGUgPSB0eXBlID09IExBWllfRFJPUF9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IChmaWx0ZXJlZCAmJiBpc0Ryb3BXaGlsZSkgPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzLmNsb25lKCksXG4gICAgICAgICAgICBpdGVyYXRlZXMgPSByZXN1bHQuX19pdGVyYXRlZXNfXyB8fCAocmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBbXSk7XG5cbiAgICAgICAgaXRlcmF0ZWVzLnB1c2goe1xuICAgICAgICAgICdkb25lJzogZmFsc2UsXG4gICAgICAgICAgJ2NvdW50JzogMCxcbiAgICAgICAgICAnaW5kZXgnOiAwLFxuICAgICAgICAgICdpdGVyYXRlZSc6IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSxcbiAgICAgICAgICAnbGltaXQnOiAtMSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IGZpbHRlcmVkIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB3aGlsZU5hbWUgPSBtZXRob2ROYW1lICsgJ1doaWxlJztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IChmaWx0ZXJlZCAmJiAhaW5kZXgpID8gdGhpcy5kcm9wV2hpbGUoKSA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBuID0gbiA9PSBudWxsID8gMSA6IG5hdGl2ZU1heChmbG9vcihuKSB8fCAwLCAwKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihyZXN1bHQuX190YWtlQ291bnRfXywgbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QocmVzdWx0Ll9faXRlcmF0ZWVzX18pLmxpbWl0ID0gbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZpZXdzID0gcmVzdWx0Ll9fdmlld3NfXyB8fCAocmVzdWx0Ll9fdmlld3NfXyA9IFtdKTtcbiAgICAgICAgICB2aWV3cy5wdXNoKHsgJ3NpemUnOiBuLCAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0V2hpbGUnXSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbd2hpbGVOYW1lXShwcmVkaWNhdGUsIHRoaXNBcmcpLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5maXJzdGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2ZpcnN0JywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8ucmVzdGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICdyZXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLnBsdWNrYCBhbmQgYF8ud2hlcmVgLlxuICAgIGFycmF5RWFjaChbJ3BsdWNrJywgJ3doZXJlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IGluZGV4ID8gJ2ZpbHRlcicgOiAnbWFwJyxcbiAgICAgICAgICBjcmVhdGVDYWxsYmFjayA9IGluZGV4ID8gYmFzZU1hdGNoZXMgOiBiYXNlUHJvcGVydHk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzW29wZXJhdGlvbk5hbWVdKGNyZWF0ZUNhbGxiYWNrKHZhbHVlKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMSk7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgdmFyIHJlc3VsdCA9IHN0YXJ0IDwgMCA/IHRoaXMudGFrZVJpZ2h0KC1zdGFydCkgOiB0aGlzLmRyb3Aoc3RhcnQpO1xuXG4gICAgICBpZiAodHlwZW9mIGVuZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmQgPSAoK2VuZCB8fCAwKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJvcCgwKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86Zmlyc3R8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIGF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBgbGVuZ3RoYCBvdGhlciB0aGFuIGAxYFxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCkge1xuICAgICAgICAgIHJldHVybiBvbmx5TGF6eVxuICAgICAgICAgICAgPyBmdW5jLmNhbGwodmFsdWUpXG4gICAgICAgICAgICA6IGxvZGFzaEZ1bmMuY2FsbChsb2Rhc2gsIHRoaXMudmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3RoZXJBcmdzID0gW3ZhbHVlXTtcbiAgICAgICAgICBwdXNoLmFwcGx5KG90aGVyQXJncywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBvdGhlckFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodXNlTGF6eSkge1xuICAgICAgICAgIHZhciB3cmFwcGVyID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh3cmFwcGVyLCBhcmdzKTtcblxuICAgICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIChpc0h5YnJpZCB8fCByZXN1bHQuX19hY3Rpb25zX18pKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyB8fCAocmVzdWx0Ll9fYWN0aW9uc19fID0gW10pO1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogbG9kYXNoIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3BvcCcsICdwdXNoJywgJ3JlcGxhY2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAnc3BsaXQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9ICgvXig/OnJlcGxhY2V8c3BsaXQpJC8udGVzdChtZXRob2ROYW1lKSA/IHN0cmluZ1Byb3RvIDogYXJyYXlQcm90bylbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpqb2lufHBvcHxyZXBsYWNlfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcy52YWx1ZSgpLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgZnVuY3Rpb24gbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lLFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XG5cbiAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZFdyYXBwZXIobnVsbCwgQklORF9LRVlfRkxBRykubmFtZV0gPSBbeyAnbmFtZSc6ICd3cmFwcGVyJywgJ2Z1bmMnOiBudWxsIH1dO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgbGF6eSB3cmFwcGVyLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbmluZyBmdW5jdGlvbnMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUucnVuID0gbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9uIGFsaWFzZXMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb2xsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5tYXA7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5oZWFkID0gbG9kYXNoLnByb3RvdHlwZS5maXJzdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnNlbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUuZmlsdGVyO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudGFpbCA9IGxvZGFzaC5wcm90b3R5cGUucmVzdDtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgbG9kYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IHRvIGF2b2lkXG4gICAgLy8gZXJyb3JzIGluIGNhc2VzIHdoZXJlIGxvZGFzaCBpcyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGFuZCBub3QgaW50ZW5kZWRcbiAgICAvLyBhcyBhbiBBTUQgbW9kdWxlLiBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3JcbiAgICAvLyBtb3JlIGRldGFpbHMuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3QuXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMgb3IgUmluZ29KUy5cbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIH1cbiAgICAvLyBFeHBvcnQgZm9yIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmUuXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciBhIGJyb3dzZXIgb3IgUmhpbm8uXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiJdfQ==
