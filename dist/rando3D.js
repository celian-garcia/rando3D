require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function () {
    'use strict';

    function Rando3D() {

        var RANDO = RANDO || {};

        require('./modules/settings')(RANDO, BABYLON);
        require('./modules/dem')(RANDO, BABYLON);
        require('./modules/events')(RANDO);
        require('./modules/poi')(RANDO, BABYLON);
        require('./modules/scene')(RANDO, BABYLON);
        require('./modules/tile-container')(RANDO);
        require('./modules/trek')(RANDO, BABYLON);
        require('./modules/utils')(RANDO, BABYLON);
        require('./modules/cameras/camera-computer')(RANDO, BABYLON);
        require('./modules/cameras/camera-container')(RANDO, BABYLON);
        require('./modules/cameras/bird-camera')(RANDO, BABYLON);
        require('./modules/cameras/examine-camera')(RANDO, BABYLON);
        require('./modules/cameras/hiker-camera')(RANDO, BABYLON);

        function init(customSettings, canvas, cameraID) {

            $.each(customSettings, function (settingName, settingValue) {
                RANDO.SETTINGS[settingName] = settingValue;
            });

            RANDO.START_TIME = Date.now();

            var scene = new RANDO.Scene(canvas, cameraID);

            return scene;
        }

        return {
            init: init
        };

    }

    if (window) {
        window.Rando3D = Rando3D;
    }
})();
},{"./modules/cameras/bird-camera":2,"./modules/cameras/camera-computer":3,"./modules/cameras/camera-container":4,"./modules/cameras/examine-camera":5,"./modules/cameras/hiker-camera":6,"./modules/dem":7,"./modules/events":8,"./modules/poi":9,"./modules/scene":10,"./modules/settings":11,"./modules/tile-container":12,"./modules/trek":13,"./modules/utils":14}],2:[function(require,module,exports){
/*******************************************************************************
 * Rando.BirdCamera.js
 *
 * BirdCamera class :
 *  It is a camera which look like the FreeCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  The differences are :
 *      - permites to translate it of world's X and Z axis instead of
 *  locale's one.
 *      - there is a wheel zoom.
 *
 *  It gives the impression of flying. That's why it is called BirdCamera
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.BirdCamera = function (name, position, scene) {
        BABYLON.Camera.call(this, name, position, scene);

        this.moveDirection = new BABYLON.Vector3(0, 0, 0);
        this.rotationDirection = new BABYLON.Vector2(0, 0);
        this.zoomDirection = new BABYLON.Vector3(0, 0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);
        this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

        this._keys = [];
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];

        // Collisions
        this._collider = new BABYLON.Collider();
        this._needMoveForGravity = true;

        // Internals
        this._currentTarget = BABYLON.Vector3.Zero();
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._camMatrix = BABYLON.Matrix.Zero();
        this._cameraTransformMatrix = BABYLON.Matrix.Zero();
        this._cameraRotationMatrix = BABYLON.Matrix.Zero();
        this._referencePoint = BABYLON.Vector3.Zero();
        this._transformedReferencePoint = BABYLON.Vector3.Zero();
        this._oldPosition = BABYLON.Vector3.Zero();
        this._diffPosition = BABYLON.Vector3.Zero();
        this._newPosition = BABYLON.Vector3.Zero();
        this._lookAtTemp = BABYLON.Matrix.Zero();
        this._tempMatrix = BABYLON.Matrix.Zero();
        this._positionAfterZoom = BABYLON.Vector3.Zero();
    };

    RANDO.BirdCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.BirdCamera.prototype.speed = 2.0;
    RANDO.BirdCamera.prototype.checkCollisions = false;
    RANDO.BirdCamera.prototype.applyGravity = false;
    RANDO.BirdCamera.prototype.noRotationConstraint = false;
    RANDO.BirdCamera.prototype.angularSensibility = 2000.0;
    RANDO.BirdCamera.prototype.lockedTarget = null;
    RANDO.BirdCamera.prototype.onCollide = null;
    RANDO.BirdCamera.prototype.wheelPrecision = 0.3;
    RANDO.BirdCamera.prototype.inertialRadiusOffset = 0;
    RANDO.BirdCamera.prototype.lowerRadiusLimit = null;
    RANDO.BirdCamera.prototype.upperRadiusLimit = null;

    RANDO.BirdCamera.prototype._getLockedTargetPosition = function () {
        if (!this.lockedTarget) {
            return null;
        }

        return this.lockedTarget.position || this.lockedTarget;
    };

    // Cache
    RANDO.BirdCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.lockedTarget = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };

    RANDO.BirdCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass)
            BABYLON.Camera.prototype._updateCache.call(this);

        var lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
            this._cache.lockedTarget = null;
        }
        else {
            if (!this._cache.lockedTarget) {
                this._cache.lockedTarget = lockedTargetPosition.clone();
            }
            else {
                this._cache.lockedTarget.copyFrom(lockedTargetPosition);
            }
        }

        this._cache.rotation.copyFrom(this.rotation);
    };

    // Synchronized
    RANDO.BirdCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this)) {
            return false;
        }

        var lockedTargetPosition = this._getLockedTargetPosition();

        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)
            && this._cache.rotation.equals(this.rotation);
    };

    // Methods
    RANDO.BirdCamera.prototype._computeLocalCameraSpeed = function () {
        return this.speed * ((BABYLON.Tools.GetDeltaTime() / (BABYLON.Tools.GetFps() * 10.0)));
    };

    // Target
    RANDO.BirdCamera.prototype.setTarget = function (target) {
        this.upVector.normalize();

        BABYLON.Matrix.LookAtLHToRef(this.position, target, this.upVector, this._camMatrix);
        this._camMatrix.invert();

        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);

        var vDir = target.subtract(this.position);

        if (vDir.x >= 0.0) {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);
        } else {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);
        }

        this.rotation.z = -Math.acos(BABYLON.Vector3.Dot(new BABYLON.Vector3(0, 1.0, 0), this.upVector));

        if (isNaN(this.rotation.x)) {
            this.rotation.x = 0;
        }

        if (isNaN(this.rotation.y)) {
            this.rotation.y = 0;
        }

        if (isNaN(this.rotation.z)) {
            this.rotation.z = 0;
        }
    };

    RANDO.BirdCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    // Controls
    RANDO.BirdCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var engine = this._scene.getEngine();

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        if (this._onMouseDown === undefined) {
            this._onMouseDown = function (evt) {
                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseUp = function (evt) {
                previousPosition = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseOut = function (evt) {
                previousPosition = null;
                that._keys = [];
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!previousPosition && !engine.isPointerLock) {
                    return;
                }

                var offsetX;
                var offsetY;

                if (!engine.isPointerLock) {
                    offsetX = evt.clientX - previousPosition.x;
                    offsetY = evt.clientY - previousPosition.y;
                } else {
                    offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                    offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
                }

                that.rotationDirection.y += offsetX / that.angularSensibility;
                that.rotationDirection.x += offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onWheel = function (event) {
                var delta = 0;
                if (event.wheelDelta) {
                    delta = event.wheelDelta / (that.wheelPrecision * 40);
                } else if (event.detail) {
                    delta = -event.detail / that.wheelPrecision;
                }

                if (delta)
                    that.inertialRadiusOffset += delta;

                if (event.preventDefault) {
                    if (!noPreventDefault) {
                        event.preventDefault();
                    }
                }
            };

            this._onKeyDown = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index === -1) {
                        that._keys.push(evt.keyCode);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            };

            this._onKeyUp = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index >= 0) {
                        that._keys.splice(index, 1);
                    }
                    if (!noPreventDefault) {
                        evt.preventDefault();
                    }
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
            };

            this._reset = function () {
                that._keys = [];
                previousPosition = null;
                that.moveDirection = new BABYLON.Vector3(0, 0, 0);
                that.rotationDirection = new BABYLON.Vector2(0, 0);
                that.zoomDirection = new BABYLON.Vector3(0, 0, 0);
            };
        }

        element.addEventListener("mousedown", this._onMouseDown, false);
        element.addEventListener("mouseup", this._onMouseUp, false);
        element.addEventListener("mouseout", this._onMouseOut, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener('mousewheel', this._onWheel, false);
        element.addEventListener('DOMMouseScroll', this._onWheel, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.BirdCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener("mousedown", this._onMouseDown);
        element.removeEventListener("mouseup", this._onMouseUp);
        element.removeEventListener("mouseout", this._onMouseOut);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener('mousewheel', this._onWheel);
        element.removeEventListener('DOMMouseScroll', this._onWheel);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._attachedElement = null;
        if (this._reset) {
            this._reset();
        }
    };

    RANDO.BirdCamera.prototype._collideWithWorld = function (velocity) {
        var globalPosition;

        if (this.parent) {
            globalPosition = BABYLON.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
            globalPosition = this.position;
        }

        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._collider.radius = this.ellipsoid;

        this.getScene()._getNewPosition(this._oldPosition, velocity, this._collider, 3, this._newPosition);
        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);

        if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
            this.position.addInPlace(this._diffPosition);
            if (this.onCollide) {
                this.onCollide(this._collider.collidedMesh);
            }
        }
    };

    RANDO.BirdCamera.prototype._checkInputs = function () {
        if (!this._localDirection) {
            this._localDirection = BABYLON.Vector3.Zero();
            this._transformedDirection = BABYLON.Vector3.Zero();
        }

        // Moves with the keyboard
        for (var index = 0; index < this._keys.length; index++) {
            var keyCode = this._keys[index];
            var speed = this._computeLocalCameraSpeed();

            if (this.keysLeft.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(0, 0, -speed);
            }

            this._cameraTransformMatrix = BABYLON.Matrix.RotationY(this.rotation.y);
            BABYLON.Vector3.TransformNormalToRef(
                this._localDirection,
                this._cameraTransformMatrix,
                this._transformedDirection
            );
            this.moveDirection.addInPlace(this._transformedDirection);
        }

        // Mouse wheel zoom
        if (this.inertialRadiusOffset) {
            BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

            this.getViewMatrix().invertToRef(this._cameraTransformMatrix);
            BABYLON.Vector3.TransformNormalToRef(
                this._referencePoint,
                this._cameraTransformMatrix,
                this.zoomDirection
            );

            this.zoomDirection.scaleInPlace(this.inertialRadiusOffset);
        }
    };

    RANDO.BirdCamera.prototype._update = function () {
        this._checkInputs();

        var needToMove = (
            this._needMoveForGravity ||
            Math.abs(this.moveDirection.x) > 0 ||
            Math.abs(this.moveDirection.y) > 0 ||
            Math.abs(this.moveDirection.z) > 0
        );
        var needToRotate = (
            Math.abs(this.rotationDirection.x) > 0 ||
            Math.abs(this.rotationDirection.y) > 0
        );
        var needToZoom = (
            Math.abs(this.zoomDirection.x) > 0 ||
            Math.abs(this.zoomDirection.y) > 0 ||
            Math.abs(this.zoomDirection.z) > 0
        );
        var needCollisions = this.checkCollisions && this._scene.collisionsEnabled;

        // Rotate
        if (needToRotate) {
            this.rotation.x += this.rotationDirection.x;
            this.rotation.y += this.rotationDirection.y;

            if (!this.noRotationConstraint) {
                var limit = (Math.PI / 2) * 0.95;

                if (this.rotation.x > limit)
                    this.rotation.x = limit;
                if (this.rotation.x < -limit)
                    this.rotation.x = -limit;
            }
        }

        // Moves and collisions
        if (needToZoom && needToMove) {
            if (needCollisions) {
                this._collideWithWorld(this.zoomDirection.add(this.moveDirection));
            } else {
                this.position.addInPlace(this.zoomDirection.add(this.moveDirection));
            }
        } else if (needToZoom) {
            if (needCollisions) {
                this._collideWithWorld(this.zoomDirection);
            } else {
                this.position.addInPlace(this.zoomDirection);
            }
        } else if (needToMove) {
            if (needCollisions) {
                this._collideWithWorld(this.moveDirection);
            } else {
                this.position.addInPlace(this.moveDirection);
            }
        }

        // Inertia
        if (needToMove) {
            if (Math.abs(this.moveDirection.x) < BABYLON.Engine.epsilon)
                this.moveDirection.x = 0;

            if (Math.abs(this.moveDirection.y) < BABYLON.Engine.epsilon)
                this.moveDirection.y = 0;

            if (Math.abs(this.moveDirection.z) < BABYLON.Engine.epsilon)
                this.moveDirection.z = 0;

            this.moveDirection.scaleInPlace(this.inertia);
        }
        if (needToRotate) {
            if (Math.abs(this.rotationDirection.x) < BABYLON.Engine.epsilon)
                this.rotationDirection.x = 0;

            if (Math.abs(this.rotationDirection.y) < BABYLON.Engine.epsilon)
                this.rotationDirection.y = 0;

            this.rotationDirection.scaleInPlace(this.inertia);
        }
        if (needToZoom) {
            if (Math.abs(this.inertialRadiusOffset) < BABYLON.Engine.epsilon)
                this.inertialRadiusOffset = 0;

            this.inertialRadiusOffset *= this.inertia;
        }
    };


    RANDO.BirdCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    RANDO.BirdCamera.prototype._getViewMatrix = function () {
        BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

        if (!this.lockedTarget) {
            // Compute
            if (this.upVector.x != 0 || this.upVector.y != 1.0 || this.upVector.z != 0) {
                BABYLON.Matrix.LookAtLHToRef(BABYLON.Vector3.Zero(), this._referencePoint, this.upVector, this._lookAtTemp);
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);

                this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix, this._tempMatrix);
                this._lookAtTemp.invert();
                this._tempMatrix.multiplyToRef(this._lookAtTemp, this._cameraRotationMatrix);
            } else {
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
            }

            BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);

            // Computing target and final matrix
            this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        } else {
            this._currentTarget.copyFrom(this._getLockedTargetPosition());
        }

        BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);
        return this._viewMatrix;
    };
};
},{}],3:[function(require,module,exports){
/*******************************************************************************
 * Rando.CameraComputer.js
 *
 * CameraComputer class :
 *  Used to separate calculations from the CameraContainer
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.CameraComputer = function (center, extent, altitudes, offsets, scene, number) {
        this._center        = {
            'x' : center.x + offsets.x,
            'y' : center.y,
            'z' : center.z + offsets.z
        };
        this._totalExtent   = {
            'x' : {
                'min' : extent.x.min + offsets.x,
                'max' : extent.x.max + offsets.x
            },
            'y' : {
                'min' : extent.y.min,
                'max' : extent.y.max
            },
            'z' : {
                'min' : extent.z.min + offsets.z,
                'max' : extent.z.max + offsets.z
            }
        };
        this._scene = scene;
        this._altitudes = altitudes;
        this._squares   = [];
        this._alphaSquare = null;
        this._number = number || 5;
    };

    /* Methods */
    RANDO.CameraComputer.prototype.computeInitialPositionToRef = function (initialPosition) {
        this._generateSquares ();
        this._findAlphaSquare ();
        this._setPositionToRef (initialPosition);
        //~ this._buildSquareViewer();
    };

    RANDO.CameraComputer.prototype.computeInitialTargetToRef = function (initialTarget) {
        initialTarget.x = this._center.x;
        initialTarget.y = 0;
        initialTarget.z = this._center.z;
    };

    RANDO.CameraComputer.prototype.computeLimitsToRef = function (limits) {
        limits.lowerX = this._totalExtent.x.min;
        limits.upperX = this._totalExtent.x.max;
        limits.lowerZ = this._totalExtent.z.min;
        limits.upperZ = this._totalExtent.z.max;

        limits.lowerRadius = RANDO.SETTINGS.MIN_THICKNESS + this._center.y;
        limits.upperRadius = 8000;
    };


    RANDO.CameraComputer.prototype._generateSquares = function () {
        // Fill square's extents (needed to determine indices)
        var squareGrid = RANDO.Utils.createFlatGrid(
            {
                'x' : this._totalExtent.x.min,
                'y' : this._totalExtent.z.min
            },
            {
                'x' : this._totalExtent.x.max,
                'y' : this._totalExtent.z.min
            },
            {
                'x' : this._totalExtent.x.max,
                'y' : this._totalExtent.z.max
            },
            {
                'x' : this._totalExtent.x.min,
                'y' : this._totalExtent.z.max
            },
            this._number+1,
            this._number+1
        );
        this._fillExtents (squareGrid);

        // Fill square's types
        this._fillTypes ();

        // Fill square's indices
        var elevatedPoints = RANDO.Utils.createElevationGrid (
            this._totalExtent.x.min,
            this._totalExtent.x.max,
            this._totalExtent.z.min,
            this._totalExtent.z.max,
            this._altitudes
        );
        this._fillIndices (elevatedPoints);

        // Fill square's neighborhood
        this._fillNeighborhood ();
    };

    /**
     * RANDO.CameraComputer._fillExtents() : Fill the extent property of all squares
     *  - grid : a flat grid containing points of squares
     */
    RANDO.CameraComputer.prototype._fillExtents = function (grid) {
        for (var row = 0 ; row < grid.length-1 ; row++) {
            for (var col = 0 ; col < grid[row].length-1 ; col++) {
                this._squares.push ({
                    'extent' : {
                        'x' : {
                            'min' : grid[row][col].x,
                            'max' : grid[row+1][col+1].x
                        },
                        'z' : {
                            'min' : grid[row][col].y,
                            'max' : grid[row+1][col+1].y
                        }
                    }
                });
            }
        }
    };

    /**
     * RANDO.CameraComputer._fillTypes() : Fill the type property of all squares
     */
    RANDO.CameraComputer.prototype._fillTypes = function () {
        // CORNER types
        this._squares[0].type = "CORNER"; // left-down corner
        this._squares[this._number - 1].type = "CORNER"; // right-down corner
        this._squares[(this._number - 1) * this._number].type = "CORNER"; // left-up corner
        this._squares[(this._number * this._number) - 1].type = "CORNER"; // right-up corner

        // Extern BORDER types
        for (var i = 1; i < this._number - 1; i++) {
            this._squares[i].type = "EXTBORDER"; // down border
            this._squares[(this._number - 1) * this._number + i].type = "EXTBORDER"; // top border
            this._squares[this._number * i].type = "EXTBORDER"; // left border
            this._squares[this._number * i + this._number -1].type = "EXTBORDER";// right border
        }

        // Intern BORDER types
        for (var i = 1; i < this._number - 1; i++) {
            this._squares[i + this._number].type = "INTBORDER";// down internal border
            this._squares[i + this._number + (this._number-3) * this._number].type = "INTBORDER";
            this._squares[i * this._number + 1].type = "INTBORDER";
            this._squares[i * this._number + 1 + (this._number-3)].type = "INTBORDER";
        };

        // BLACK types
        for (var it in this._squares) {
            if (!this._squares[it].type) this._squares[it].type = "BLACK";
        }
    };

    /**
     * RANDO.CameraComputer._fillIndices() : Fill the index property of all squares
     *  - elevatedPoints : a two-array of all 3D points of the DEM
     *
     * NB : It needs to have already computed the extent and the type of each square
     */
    RANDO.CameraComputer.prototype._fillIndices = function (elevatedPoints) {
        // Increment indices of squares with elevated points which are inside
        for (var row = 0; row < elevatedPoints.length; row++) {
            for (var col = 0; col < elevatedPoints[row].length; col++) {
                var position = elevatedPoints[row][col];
                for (var it in this._squares) {
                    var square = this._squares[it];
                    if (square.type != "BLACK" && RANDO.Utils.isInExtent(position, square.extent)) {
                        if (square.index) {
                            square.index += position.y;
                            square.nb_alt++;
                        } else {
                            square.index = position.y;
                            square.nb_alt = 1;
                        }
                    }
                }
            }
        }

        // Create an index between 0 and 10 which represents the elevation's average of a square
        for (var it in this._squares) {
            var square = this._squares[it];
            square.index = square.index / square.nb_alt;
            square.index = square.index * 10 / (this._totalExtent.y.max  - this._totalExtent.y.min);
            if (square.type == "BLACK") {
                square.index = -1;
            }
        }
    };

    /**
     * RANDO.CameraComputer._fillNeighborhood() : Fill the neighborhood property of squares
     * which are of CORNER or EXTBORDER types
     *
     * ****************************************
     * The neighborhood contains all neighbours of a square following this schedule :
     *
     *          CORNER :
     *      |
     *      n
     *      n n
     *      s n n _
     *
     *          EXTBORDER :
     *      n n n
     *    _ n s n _
     *
     * With
     *  s = square we want to get its neighbours
     *  n = neighbours of the square
     *
     * ****************************************
     * NB : - The square will be counted in its neighborhood
     *      - It needs to have already computed the index of each square
     */
    RANDO.CameraComputer.prototype._fillNeighborhood = function () {
        var dx, dy, t_dx, t_dy = [-this._number, this._number];

        for (var curr = 0; curr < this._squares.length; curr++) {
            var square = this._squares[curr];

            if (square.type == "CORNER") {
                square.neighborhood = [];
                if (curr%this._number == 0) {
                    dx = 1;
                }
                else {
                    dx = -1;
                }
                if (this._squares[curr + this._number]) {
                    dy = this._number;
                }
                else {
                    dy = -this._number;
                }
                square.neighborhood.push(curr);
                square.neighborhood.push(curr + dx);
                square.neighborhood.push(curr + 2 * dx);
                square.neighborhood.push(curr + dy);
                square.neighborhood.push(curr + 2 * dy);
                square.neighborhood.push(curr + dx + dy);
            }
            else if (square.type == "EXTBORDER") {
                square.neighborhood = [];
                if (curr%this._number == 0) {
                    t_dx = [0, 1];
                }
                else if (curr%this._number == this._number -1) {
                    t_dx = [-1, 0];
                }
                else {
                    t_dx = [-1, 0, 1];
                }
                for (var i in t_dx) {
                    square.neighborhood.push (curr + t_dx[i]);
                    for (var j in t_dy) {
                        if (this._squares[curr + t_dy[j]]) {
                            square.neighborhood.push (curr + t_dx[i] + t_dy[j]);
                        }
                    }
                }
            }
            else {
                square.neighborhood = [];
            }
        }
    };

    /**
     * RANDO.CameraComputer._findAlphaSquare() : Find the Alpha Square
     *  The alpha square is the square which have the neighborhood with the lowest indices values
     */
    RANDO.CameraComputer.prototype._findAlphaSquare = function () {
        var that = this;
        this._alphaSquare = _.min(this._squares, function (square) {
            var result = 0;
            if (!square.neighborhood.length) {
                return Infinity;
            }
            for (var it in square.neighborhood) {
                result += that._squares[square.neighborhood[it]].index;
            }
            return result;
        });
    };

    /**
     * RANDO.CameraComputer._setPositionToRef() : set the position given in parameter
     *  according to the alpha square position
     *
     *  - result : reference to the position to change
     */
    RANDO.CameraComputer.prototype._setPositionToRef = function (result) {
        // Alpha position : elevation do not matter
        var A = new BABYLON.Vector3(
            (this._alphaSquare.extent.x.max + this._alphaSquare.extent.x.min) /2,
            0,
            (this._alphaSquare.extent.z.max + this._alphaSquare.extent.z.min) /2
        );

        // Center position
        var O = new BABYLON.Vector3(
            this._center.x,
            this._center.y,
            this._center.z
        );

        var scale = 2.5;
        var OC = A.subtract(O).scale(scale);

        // Camera position
        var C = OC.add(O);
        result.x = C.x;
        result.y = this._center.y + (this._totalExtent.y.max - this._totalExtent.y.min);
        result.z = C.z;
    };

    /**
     * RANDO.CameraComputer._buildSquareViewer() : build a viewer which materialize
     *  differents squares in spheres of color
     *
     *  CORNER squares are green
     *  Extern BORDER squares are blue
     *  Intern BORDER squares are orange
     *  Intern squares are black
     *  Alpha Square is red
     */
    RANDO.CameraComputer.prototype._buildSquareViewer = function () {
        for (var it in this._squares) {
            var sphere = BABYLON.Mesh.CreateSphere(
                "Square " + it,
                10, 100,
                this._scene
            );

            sphere.position.x = (this._squares[it].extent.x.min + this._squares[it].extent.x.max) /2;
            sphere.position.y = this._totalExtent.y.max;
            sphere.position.z = (this._squares[it].extent.z.min + this._squares[it].extent.z.max) /2;
            sphere.material = new BABYLON.StandardMaterial("Square " + it + " - Material", this._scene);
            if (this._alphaSquare == this._squares[it]) {
                sphere.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            }
            else if (this._squares[it].type == "CORNER") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
            }
            else if (this._squares[it].type == "EXTBORDER") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 1, 1);
            }
            else if (this._squares[it].type == "INTBORDER") {
                sphere.material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
            }
            else if (this._squares[it].type == "BLACK") {
                sphere.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
            }
        }

        var sphere = BABYLON.Mesh.CreateSphere("Center", 10, 100, this._scene);
        sphere.position.x = this._center.x;
        sphere.position.y = this._totalExtent.y.max;
        sphere.position.z = this._center.z;
    };
};
},{}],4:[function(require,module,exports){
/*******************************************************************************
 * Rando.CameraContainer.js
 *
 * CameraContainer class :
 *  A container which will contains all cameras of the scene
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.CameraContainer = function (canvas, scene, params) {
        this._canvas = canvas;
        this._scene = scene;
        this._switchEnabled = params.switchEnabled || false;

        this._computer = new RANDO.CameraComputer (
            params.demCenter,
            params.demExtent,
            params.demAltitudes,
            params.offsets || BABYLON.Vector3.Zero(),
            scene,
            6
        );

        this.cameras = {};

        this._animationPath = null;
        this._controlsAttached  = false;
        this._positionBeforeSwitch = null;
        this._targetBeforeSwitch = null;

        this.initialPosition = BABYLON.Vector3.Zero();
        this.initialTarget = BABYLON.Vector3.Zero();
        this.limits = {
            'lowerX'        : null,
            'upperX'        : null,
            'lowerZ'        : null,
            'upperZ'        : null,
            'lowerRadius'   : null,
            'upperRadius'   : null
        };

        this.init();
    };

    // Static Array defining possibles cameras IDs
    RANDO.CameraIDs = ["examine", "bird", "hiker"];

    /* Methods */
    RANDO.CameraContainer.prototype.init = function () {
        this._computeInitialParameters ();
        this._buildBirdCamera ();
        this._buildExamineCamera ();
        this._buildHikerCamera ();
        this._initInterface();
        this._cameraSwitcher ();
    };

    /**
     * RANDO.CameraContainer._buildExamineCamera() : build of the Examine camera
     */
    RANDO.CameraContainer.prototype._buildExamineCamera = function () {
        var examine_camera = new RANDO.ExamineCamera(
            "Examine Camera",0, 0, 0,
            this.initialTarget,
            this._scene
        );
        examine_camera.id = "examine";
        examine_camera.keysUp     = [90, 38]; // Touche Z and up
        examine_camera.keysDown   = [83, 40]; // Touche S and down
        examine_camera.keysLeft   = [81, 37]; // Touche Q and left
        examine_camera.keysRight  = [68, 39]; // Touche D and right

        examine_camera.wheelPrecision = 0.2;
        examine_camera.checkCollisions = true;
        examine_camera.ellipsoid.y = RANDO.SETTINGS.COLLISIONS_OFFSET;
        examine_camera.maxZ = 50000;
        examine_camera.speed = RANDO.SETTINGS.CAM_SPEED_F ;

        examine_camera.lowerXLimit = this.limits.lowerX;
        examine_camera.lowerZLimit = this.limits.lowerZ;
        examine_camera.upperXLimit = this.limits.upperX;
        examine_camera.upperZLimit = this.limits.upperZ;
        examine_camera.upperBetaLimit = Math.PI/2;

        this.cameras.examine = examine_camera;
    };

    /**
     * RANDO.CameraContainer._buildBirdCamera() : build of the Bird camera
     */
    RANDO.CameraContainer.prototype._buildBirdCamera = function () {
        var bird_camera = new RANDO.BirdCamera(
            "Bird Camera",
            BABYLON.Vector3.Zero(),
            this._scene
        );
        bird_camera.id = "bird";
        bird_camera.keysUp     = [90, 38]; // Touche Z and up
        bird_camera.keysDown   = [83, 40]; // Touche S and down
        bird_camera.keysLeft   = [81, 37]; // Touche Q and left
        bird_camera.keysRight  = [68, 39]; // Touche D and right

        bird_camera.checkCollisions = true;
        bird_camera.ellipsoid.y = RANDO.SETTINGS.COLLISIONS_OFFSET;
        bird_camera.maxZ = 50000;
        bird_camera.speed = RANDO.SETTINGS.CAM_SPEED_F ;

        this.cameras.bird = bird_camera;
    };

    /**
     * RANDO.CameraContainer._buildHikerCamera() : build of the Hiker camera
     */
    RANDO.CameraContainer.prototype._buildHikerCamera = function () {
        var hiker_camera = new RANDO.HikerCamera(
            "Hiker Camera",
            BABYLON.Vector3.Zero(),
            this._scene
        );
        hiker_camera.id = "hiker";

        hiker_camera.checkCollisions = true;
        hiker_camera.maxZ = 50000;

        hiker_camera.returnSpeed = RANDO.SETTINGS.HCAM_RETURN_SPEED;
        hiker_camera.followSpeed = RANDO.SETTINGS.HCAM_FOLLOW_SPEED;


        this.cameras.hiker = hiker_camera;
    };

    /**
     * RANDO.CameraContainer.setActiveCamera() : set the active camera of the scene
     *      - newID: ID of the camera we want to set as active
     *
     * NB : newID should be in the static array RANDO.cameraIDs
     */
    RANDO.CameraContainer.prototype.setActiveCamera = function (newID) {
        if (RANDO.CameraIDs.indexOf(newID) == -1) {
            console.error("RANDO.CameraContainer.setActiveCamera () : " + newID +
                            " is not an available camera's ID");
            return;
        }

        var oldID = this._scene.activeCamera.id;

        // Record informations of the old camera
        this._recordInfoBeforeSwitch(oldID);

        // Attach & detach controls of cameras
        if (this._controlsAttached) {
            this.cameras[oldID].detachControl();
        }
        this.cameras[newID].attachControl(this._canvas);
        this._controlsAttached = true;

        // Update camera
        this._scene.setActiveCameraByID (newID);
        this._resetByDefault();

        // Interface changes
        $(".controls--" + oldID).css("display", "none");
        $(".camera--"   + oldID).removeClass("camera--selected");
        $(".controls--" + newID).css("display", "block");
        $(".camera--"   + newID).addClass("camera--selected");
    };

    RANDO.CameraContainer.prototype._recordInfoBeforeSwitch = function (oldID) {
        if (oldID == "examine") {
            this._positionBeforeSwitch  = this._scene.activeCamera.position.clone();
            this._targetBeforeSwitch    = this._scene.activeCamera.target.clone();
            this._rotationBeforeSwitch  = null;
        } 
        else if (oldID == "bird" || oldID == "hiker") {
            this._positionBeforeSwitch  = this._scene.activeCamera.position.clone();
            this._rotationBeforeSwitch  = this._scene.activeCamera.rotation.clone();
            this._targetBeforeSwitch    = null;
        }
    };

    RANDO.CameraContainer.prototype.setAnimationPath = function (vertices) {
        this._animationPath = vertices;
        this.cameras.hiker.setPath(vertices);
        this.enableCamera ("hiker");
    };

    RANDO.CameraContainer.prototype._cameraSwitcher = function () {
        var idArray = RANDO.CameraIDs;
        var that = this;

        if (!this._switchEnabled) {
            return;
        }
        else {
             $(".camera_switcher").css("display", "block");
        }

        for (var it in idArray) {
            // The hiker camera must not be active until his path has not been set
            if (idArray[it] != "hiker") {
                this.enableCamera(idArray[it]);
            }

            // Click event
            $(".camera--" + idArray[it]).click({id : idArray[it]}, function (e) {

                if($(this).hasClass('camera--disabled')) {
                    return;
                }
                else {
                    that.setActiveCamera (e.data.id);
                }
            });
        }
    };

    RANDO.CameraContainer.prototype.enableCamera = function (id) {
        $(".camera--" + id ).removeClass("camera--disabled");
        $(".camera--" + id ).addClass("camera--enabled");
        $(".camera--" + id + " img").attr("src", RANDO.SETTINGS.IMAGES_FOLDER + id + "_camera.png");
    };

    RANDO.CameraContainer.prototype._resetByDefault = function () {
        var activeCam = this._scene.activeCamera;

        // Examine Camera
        if (activeCam.id == "examine") {
            activeCam.setPosition(this.initialPosition.clone());
            activeCam.target = this.initialTarget.clone();
        }

        // Bird Camera
        else if (activeCam.id == "bird") {
            activeCam.position = this.initialPosition.clone();
            activeCam.setTarget(this.initialTarget.clone());
        }

        // Hiker Camera
        else if (activeCam.id == "hiker" ) {
            if (this._positionBeforeSwitch) {
                activeCam.position = this._positionBeforeSwitch;
            }
            if (this._rotationBeforeSwitch) {
                activeCam.rotation = this._rotationBeforeSwitch;
            }
            if (this._targetBeforeSwitch) {
                activeCam.setTarget(this._targetBeforeSwitch);
            }
        }

        activeCam._reset ();
    };

    RANDO.CameraContainer.prototype._computeInitialParameters = function () {
        this._computer.computeInitialPositionToRef (this.initialPosition);

        this._computer.computeInitialTargetToRef (this.initialTarget);

        this._computer.computeLimitsToRef (this.limits);
    };

    RANDO.CameraContainer.prototype._initInterface = function () {
        for (var it in this.cameras) {
            var id = this.cameras[it].id;
            $(".controls--" + id + " .controls-description")
                .text(RANDO.SETTINGS.CAMERA_MESSAGES[id]);
            $(".camera--"   + id + " .camera-description")
                .text(RANDO.SETTINGS.CAMERA_MESSAGES[id]);
        }
    };
};
},{}],5:[function(require,module,exports){
/*******************************************************************************
 * Rando.ExamineCamera.js
 *
 * ExamineCamera class :
 *  It is a camera which look like the ArcRotateCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  But we can also translate it over world axis X and Z.
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    var eventPrefix = BABYLON.Tools.GetPointerPrefix();

    RANDO.ExamineCamera = function (name, alpha, beta, radius, target, scene) {
        BABYLON.Camera.call(
            this, name, RANDO.ExamineCamera.sphericToCartesian(
                alpha,
                beta,
                radius,
                target
            ), scene
        );

        this.alpha = alpha;
        this.beta = beta;
        this.radius = radius;
        this.target = target;

        this._keys = [];
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];

        // Collisions
        this._collider = new BABYLON.Collider();
        this._needMoveForGravity = true;

        this.cameraDirection = new BABYLON.Vector3(0, 0, 0);
        this.cameraRotation = new BABYLON.Vector2(0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);
        this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

        // Internals
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._cameraTransformMatrix = BABYLON.Matrix.Zero();
        this._oldPosition = BABYLON.Vector3.Zero();
        this._diffPosition = BABYLON.Vector3.Zero();
        this._newPosition = BABYLON.Vector3.Zero();
    };

    RANDO.ExamineCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.ExamineCamera.prototype.inertialAlphaOffset = 0;
    RANDO.ExamineCamera.prototype.inertialBetaOffset = 0;
    RANDO.ExamineCamera.prototype.inertialRadiusOffset = 0;
    RANDO.ExamineCamera.prototype.lowerAlphaLimit = null;
    RANDO.ExamineCamera.prototype.upperAlphaLimit = null;
    RANDO.ExamineCamera.prototype.lowerBetaLimit = 0.01;
    RANDO.ExamineCamera.prototype.upperBetaLimit = Math.PI;
    RANDO.ExamineCamera.prototype.lowerRadiusLimit = null;
    RANDO.ExamineCamera.prototype.upperRadiusLimit = null;
    RANDO.ExamineCamera.prototype.lowerXLimit = null;
    RANDO.ExamineCamera.prototype.upperXLimit = null;
    RANDO.ExamineCamera.prototype.lowerZLimit = null;
    RANDO.ExamineCamera.prototype.upperZLimit = null;
    RANDO.ExamineCamera.prototype.angularSensibility = 1000.0;
    RANDO.ExamineCamera.prototype.wheelPrecision = 3.0;

    RANDO.ExamineCamera.prototype._getTargetPosition = function () {
        return this.target.position || this.target;
    };

    // Cache
    RANDO.ExamineCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.target = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.alpha = undefined;
        this._cache.beta = undefined;
        this._cache.radius = undefined;
    };

    RANDO.ExamineCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass)
            BABYLON.Camera.prototype._updateCache.call(this);

        this._cache.target.copyFrom(this._getTargetPosition());
        this._cache.alpha = this.alpha;
        this._cache.beta = this.beta;
        this._cache.radius = this.radius;
    };

    // Synchronized
    RANDO.ExamineCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this))
            return false;

        return this._cache.target.equals(this._getTargetPosition())
            && this._cache.alpha === this.alpha
            && this._cache.beta === this.beta
            && this._cache.radius === this.radius;
    };

    RANDO.ExamineCamera.prototype._computeLocalCameraSpeed = function () {
        return this.speed * ((BABYLON.Tools.GetDeltaTime() / (BABYLON.Tools.GetFps() * 10.0)));
    };

    RANDO.ExamineCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var pointerId;

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        var engine = this._scene.getEngine();

        if (this._onPointerDown === undefined) {
            this._onPointerDown = function (evt) {

                if (pointerId) {
                    return;
                }

                pointerId = evt.pointerId;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onPointerUp = function (evt) {
                previousPosition = null;
                pointerId = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };


            this._onPointerMove = function (evt) {
                if (!previousPosition) {
                    return;
                }

                if (pointerId !== evt.pointerId) {
                    return;
                }

                var offsetX = evt.clientX - previousPosition.x;
                var offsetY = evt.clientY - previousPosition.y;

                that.inertialAlphaOffset -= offsetX / that.angularSensibility;
                that.inertialBetaOffset -= offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!engine.isPointerLock) {
                    return;
                }

                var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;

                that.inertialAlphaOffset -= offsetX / that.angularSensibility;
                that.inertialBetaOffset -= offsetY / that.angularSensibility;

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._wheel = function (event) {
                var delta = 0;
                if (event.wheelDelta) {
                    delta = event.wheelDelta / (that.wheelPrecision * 40);
                } else if (event.detail) {
                    delta = -event.detail / that.wheelPrecision;
                }

                if (delta)
                    that.inertialRadiusOffset += delta;

                if (event.preventDefault) {
                    if (!noPreventDefault) {
                        event.preventDefault();
                    }
                }
            };

            this._onKeyDown = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index === -1) {
                        that._keys.push(evt.keyCode);
                    }

                    if (evt.preventDefault) {
                        if (!noPreventDefault) {
                            evt.preventDefault();
                        }
                    }
                }
            };

            this._onKeyUp = function (evt) {
                if (that.keysUp.indexOf(evt.keyCode) !== -1 ||
                    that.keysDown.indexOf(evt.keyCode) !== -1 ||
                    that.keysLeft.indexOf(evt.keyCode) !== -1 ||
                    that.keysRight.indexOf(evt.keyCode) !== -1) {
                    var index = that._keys.indexOf(evt.keyCode);

                    if (index >= 0) {
                        that._keys.splice(index, 1);
                    }

                    if (evt.preventDefault) {
                        if (!noPreventDefault) {
                            evt.preventDefault();
                        }
                    }
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
                pointerId = null;
            };

            this._onGestureStart = function (e) {
                if (window.MSGesture === undefined) {
                    return;
                }

                if (!that._MSGestureHandler) {
                    that._MSGestureHandler = new MSGesture();
                    that._MSGestureHandler.target = canvas;
                }

                that._MSGestureHandler.addPointer(e.pointerId);
            };

            this._onGesture = function (e) {
                that.radius *= e.scale;


                if (e.preventDefault) {
                    if (!noPreventDefault) {
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
            };

            this._reset = function () {
                that._keys = [];
                that.inertialAlphaOffset = 0;
                that.inertialBetaOffset = 0;
                that.inertialRadiusOffset = 0;
                that.cameraDirection = new BABYLON.Vector3(0, 0, 0);
                previousPosition = null;
                pointerId = null;
            };
        }

        element.addEventListener(eventPrefix + "down", this._onPointerDown, false);
        element.addEventListener(eventPrefix + "up", this._onPointerUp, false);
        element.addEventListener(eventPrefix + "out", this._onPointerUp, false);
        element.addEventListener(eventPrefix + "move", this._onPointerMove, false);
        element.addEventListener("mousemove", this._onMouseMove, false);
        element.addEventListener("MSPointerDown", this._onGestureStart, false);
        element.addEventListener("MSGestureChange", this._onGesture, false);
        element.addEventListener('mousewheel', this._wheel, false);
        element.addEventListener('DOMMouseScroll', this._wheel, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.ExamineCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener(eventPrefix + "down", this._onPointerDown);
        element.removeEventListener(eventPrefix + "up", this._onPointerUp);
        element.removeEventListener(eventPrefix + "out", this._onPointerUp);
        element.removeEventListener(eventPrefix + "move", this._onPointerMove);
        element.removeEventListener("mousemove", this._onMouseMove);
        element.removeEventListener("MSPointerDown", this._onGestureStart);
        element.removeEventListener("MSGestureChange", this._onGesture);
        element.removeEventListener('mousewheel', this._wheel);
        element.removeEventListener('DOMMouseScroll', this._wheel);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._MSGestureHandler = null;
        this._attachedElement = null;

        if (this._reset) {
            this._reset();
        }
    };

    RANDO.ExamineCamera.prototype._collideWithWorld = function (velocity) {
        var globalPosition;

        if (this.parent) {
            globalPosition = BABYLON.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
            globalPosition = this.position;
        }

        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._collider.radius = this.ellipsoid;

        this.getScene()._getNewPosition(this._oldPosition, velocity, this._collider, 3, this._newPosition);
        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);

        if (this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {
            this.position.addInPlace(this._diffPosition);
            this.setPosition(this.position);
            if (this.onCollide) {
                this.onCollide(this._collider.collidedMesh);
            }
        }
    };

    RANDO.ExamineCamera.prototype._checkInputs = function () {
        if (!this._localDirection) {
            this._localDirection = BABYLON.Vector3.Zero();
            this._transformedDirection = BABYLON.Vector3.Zero();
        }

        // Moves with the Keyboard
        for (var index = 0; index < this._keys.length; index++) {
            var keyCode = this._keys[index];
            var speed = this._computeLocalCameraSpeed();

            if (this.keysLeft.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
                this._localDirection.copyFromFloats(-speed, 0, 0);
            }

            this.getViewMatrix().invertToRef(this._cameraTransformMatrix);

            BABYLON.Vector3.TransformNormalToRef(
                this._localDirection,
                this._cameraTransformMatrix,
                this._transformedDirection
            );

            if (this.keysUp.indexOf(keyCode)   !== -1 ||
                this.keysDown.indexOf(keyCode)  !== -1 ) {
                this.cameraDirection.addInPlace(
                    BABYLON.Vector3.TransformNormal(
                        this._transformedDirection,
                        BABYLON.Matrix.RotationY(-Math.PI/2)
                    )
                );
            } else {
                this.cameraDirection.addInPlace(this._transformedDirection);
            }
        }
    };

    RANDO.ExamineCamera.prototype._update = function () {
        this._checkInputs();

        var needToMoveTarget = (
            Math.abs(this.cameraDirection.x) > 0 ||
            Math.abs(this.cameraDirection.y) > 0 ||
            Math.abs(this.cameraDirection.z) > 0
        );

        var needToRotateOrZoom = (
            this.inertialAlphaOffset  != 0 ||
            this.inertialBetaOffset   != 0 ||
            this.inertialRadiusOffset != 0
        );

        var needCollisions = this.checkCollisions && this._scene.collisionsEnabled;

        // Update target
        if (needToMoveTarget) {
            this.target.addInPlace(this.cameraDirection);
        }

        // Update Alpha Beta Radius
        if (needToRotateOrZoom) {
            this.alpha  += this.inertialAlphaOffset;
            this.beta   += this.inertialBetaOffset;
            this.radius -= this.inertialRadiusOffset;
        }

        // Limits
        if (this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit) {
            this.alpha = this.lowerAlphaLimit;
            this.inertialAlphaOffset = 0;
        }
        if (this.upperAlphaLimit && this.alpha > this.upperAlphaLimit) {
            this.alpha = this.upperAlphaLimit;
            this.inertialAlphaOffset = 0;
        }
        if (this.lowerBetaLimit && this.beta < this.lowerBetaLimit) {
            this.beta = this.lowerBetaLimit;
            this.inertialBetaOffset = 0;
        }
        if (this.upperBetaLimit && this.beta > this.upperBetaLimit) {
            this.beta = this.upperBetaLimit;
            this.inertialBetaOffset = 0;
        }
        if (this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit) {
            this.radius = this.lowerRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
        if (this.upperRadiusLimit && this.radius > this.upperRadiusLimit) {
            this.radius = this.upperRadiusLimit;
            this.inertialRadiusOffset = 0;
        }
        if (this.lowerXLimit && this.target.x < this.lowerXLimit) {
            this.target.x = this.lowerXLimit;
            this.cameraDirection.x = 0;
        }
        if (this.upperXLimit && this.target.x > this.upperXLimit) {
            this.target.x = this.upperXLimit;
            this.cameraDirection.x = 0;
        }
        if (this.lowerZLimit && this.target.z < this.lowerZLimit) {
            this.target.z = this.lowerZLimit;
            this.cameraDirection.z = 0;
        }
        if (this.upperZLimit && this.target.z > this.upperZLimit) {
            this.target.z = this.upperZLimit;
            this.cameraDirection.z = 0;
        }

        // Moves and Collisions
        if (needToRotateOrZoom && needToMoveTarget) {
            if (needCollisions) {
                this._collideWithWorld(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                    .add(this.cameraDirection)
                );
            }
            else {
                this.position.addInPlace(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                    .add(this.cameraDirection)
                );
                this.setPosition (this.position);
            }
        }
        else if (needToRotateOrZoom) {
            if (needCollisions) {
                this._collideWithWorld(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                );
            } else {
                this.position.addInPlace(
                    RANDO.ExamineCamera.sphericToCartesian(
                        this.alpha,
                        this.beta,
                        this.radius,
                        this.target
                    )
                    .subtract(this.position)
                );
                this.setPosition (this.position);
            }
        }
        else if (needToMoveTarget) {
            if (needCollisions) {
                this._collideWithWorld(this.cameraDirection);
            } else {
                this.position.addInPlace(this.cameraDirection);
                this.setPosition (this.position);
            }
        }

        // Inertia
        if (needToMoveTarget) {
            if (Math.abs(this.cameraDirection.x) < BABYLON.Engine.Epsilon)
                this.cameraDirection.x = 0;

            if (Math.abs(this.cameraDirection.y) < BABYLON.Engine.Epsilon)
                this.cameraDirection.y = 0;

            if (Math.abs(this.cameraDirection.z) < BABYLON.Engine.Epsilon)
                this.cameraDirection.z = 0;

            this.cameraDirection.scaleInPlace(this.inertia);
        }

        if (needToRotateOrZoom) {
            if (Math.abs(this.inertialAlphaOffset) < BABYLON.Engine.Epsilon)
                this.inertialAlphaOffset = 0;

            if (Math.abs(this.inertialBetaOffset) < BABYLON.Engine.Epsilon)
                this.inertialBetaOffset = 0;

            if (Math.abs(this.inertialRadiusOffset) < BABYLON.Engine.Epsilon)
                this.inertialRadiusOffset = 0;

            this.inertialAlphaOffset    *= this.inertia;
            this.inertialBetaOffset     *= this.inertia;
            this.inertialRadiusOffset   *= this.inertia;
        }
    };

    RANDO.ExamineCamera.prototype.setPosition = function (position) {
        this.position = position;
        var radiusv3 = position.subtract(this._getTargetPosition());
        this.radius = radiusv3.length();

        this.alpha = Math.acos(radiusv3.x / Math.sqrt(
            Math.pow(radiusv3.x, 2) +
            Math.pow(radiusv3.z, 2)
        ));
        if (radiusv3.z < 0) {
            this.alpha = 2 * Math.PI - this.alpha;
        }
        this.beta = Math.acos(radiusv3.y / this.radius);
    };

    RANDO.ExamineCamera.prototype._getViewMatrix = function () {
        BABYLON.Matrix.LookAtLHToRef(
            this.position,
            this.target,
            this.upVector,
            this._viewMatrix
        );

        return this._viewMatrix;
    };

    RANDO.ExamineCamera.ZOOM_ON_FACTOR = 1;
    RANDO.ExamineCamera.prototype.zoomOn = function (meshes) {
        meshes = meshes || this._scene.meshes;

        var minMaxVector = BABYLON.Mesh.MinMax(meshes);
        var distance = BABYLON.Vector3.Distance(minMaxVector.min, minMaxVector.max);

        this.radius = distance * RANDO.ExamineCamera.ZOOM_ON_FACTOR;

        this.focusOn({min: minMaxVector.min, max: minMaxVector.max, distance: distance});
    };

    RANDO.ExamineCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance) {
        var meshesOrMinMaxVector;
        var distance;

        if (meshesOrMinMaxVectorAndDistance.min === undefined) { // meshes
            meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance || this._scene.meshes;
            meshesOrMinMaxVector = BABYLON.Mesh.MinMax(meshesOrMinMaxVector);
            distance = BABYLON.Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
        }
        else { //minMaxVector and distance
            meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance;
            distance = meshesOrMinMaxVectorAndDistance.distance;
        }

        this.target = BABYLON.Mesh.Center(meshesOrMinMaxVector);

        this.maxZ = distance * 2;
    };

    // Static
    RANDO.ExamineCamera.sphericToCartesian = function (alpha, beta, radius, center) {
        var cosa = Math.cos(alpha);
        var sina = Math.sin(alpha);
        var cosb = Math.cos(beta);
        var sinb = Math.sin(beta);

        center = center || BABYLON.Vector3.Zero();
        return center.add(new BABYLON.Vector3(
            radius * cosa * sinb,
            radius * cosb,
            radius * sina * sinb
        ));
    };

    RANDO.ExamineCamera.cartesianToSpheric = function (position, center) {
        var radiusv3 = position.subtract(center);
        var radius = radiusv3.length();

        var alpha = Math.acos(radiusv3.x / Math.sqrt(
            Math.pow(radiusv3.x, 2) +
            Math.pow(radiusv3.z, 2)
        ));
        if (radiusv3.z < 0) {
            var alpha = 2*Math.PI - this.alpha;
        }
        var beta = Math.acos(radiusv3.y / this.radius);
        return {
            'alpha': alpha,
            'beta': beta,
            'radius': radius
        };
    };
};
},{}],6:[function(require,module,exports){
/*******************************************************************************
 * Rando.HikerCamera.js
 *
 * HikerCamera class :
 *  It is a camera which look like the FreeCamera of BabylonJS.
 *      https://github.com/BabylonJS/Babylon.js/wiki/05-Cameras.
 *
 *  The major differences is than all moves have been replaced by some
 *  animation controls. In effect this camera was done to follow a path.
 *
 *  After instantiate the camera, set the commands and set the path with
 *  setPath() function, we can play, pause, stop, rewind and move forward the
 *  camera along this path as we want.
 *
 *
 *  Beware ! this camera will need to have imported these libraries :

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/easing/EasePack.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TimelineLite.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/BezierPlugin.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/plugins/DirectionalRotationPlugin.min.js"></script>

 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.HikerCamera = function (name, position, scene) {
        BABYLON.Camera.call(this, name, position, scene);

        this.cameraRotation = new BABYLON.Vector2(0, 0);
        this.rotation = new BABYLON.Vector3(0, 0, 0);

        this.keysPlayPause = [32];
        this.keysStop  = [13];
        this.keysRewind = [40];
        this.keysForward = [38];

        // Internals
        this._currentTarget = BABYLON.Vector3.Zero();
        this._viewMatrix = BABYLON.Matrix.Zero();
        this._camMatrix = BABYLON.Matrix.Zero();
        this._cameraRotationMatrix = BABYLON.Matrix.Zero();
        this._referencePoint = BABYLON.Vector3.Zero();
        this._transformedReferencePoint = BABYLON.Vector3.Zero();
        this._lookAtTemp = BABYLON.Matrix.Zero();
        this._tempMatrix = BABYLON.Matrix.Zero();

        // Animation
        this._timeline = null
        this._path = [];
        this._state = null;
        this._oldState = null;
        this._isMoving = false;
        this._lenghtOfBezier = 0;
        this._positionTween = null;
        this._rotationTween = null;
    };

    RANDO.HikerCamera.prototype = Object.create(BABYLON.Camera.prototype);

    // Members
    RANDO.HikerCamera.prototype.returnSpeed = 2000;
    RANDO.HikerCamera.prototype.followSpeed = 20;
    RANDO.HikerCamera.prototype.checkCollisions = false;
    RANDO.HikerCamera.prototype.applyGravity = false;
    RANDO.HikerCamera.prototype.noRotationConstraint = false;
    RANDO.HikerCamera.prototype.angularSensibility = 2000.0;
    RANDO.HikerCamera.prototype.lockedTarget = null;
    RANDO.HikerCamera.prototype.onCollide = null;
    RANDO.HikerCamera.prototype.wheelPrecision = 0.3;
    RANDO.HikerCamera.prototype.inertialRadiusOffset = 0;
    RANDO.HikerCamera.prototype.lowerRadiusLimit = null;
    RANDO.HikerCamera.prototype.upperRadiusLimit = null;

    RANDO.HikerCamera.prototype._getLockedTargetPosition = function () {
        if (!this.lockedTarget) {
            return null;
        }

        return this.lockedTarget.position || this.lockedTarget;
    };

    // Cache
    RANDO.HikerCamera.prototype._initCache = function () {
        BABYLON.Camera.prototype._initCache.call(this);

        this._cache.lockedTarget = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    };

    RANDO.HikerCamera.prototype._updateCache = function (ignoreParentClass) {
        if (!ignoreParentClass) {
            BABYLON.Camera.prototype._updateCache.call(this);
        }

        var lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
            this._cache.lockedTarget = null;
        }
        else {
            if (!this._cache.lockedTarget) {
                this._cache.lockedTarget = lockedTargetPosition.clone();
            }
            else {
                this._cache.lockedTarget.copyFrom(lockedTargetPosition);
            }
        }

        this._cache.rotation.copyFrom(this.rotation);
    };

    // Synchronized
    RANDO.HikerCamera.prototype._isSynchronizedViewMatrix = function () {
        if (!BABYLON.Camera.prototype._isSynchronizedViewMatrix.call(this)) {
            return false;
        }

        var lockedTargetPosition = this._getLockedTargetPosition();

        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)
            && this._cache.rotation.equals(this.rotation);
    };

    // Target
    RANDO.HikerCamera.prototype.setTarget = function (target) {
        this.upVector.normalize();

        BABYLON.Matrix.LookAtLHToRef(this.position, target, this.upVector, this._camMatrix);
        this._camMatrix.invert();

        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);

        var vDir = target.subtract(this.position);

        if (vDir.x >= 0.0) {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);
        } else {
            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);
        }

        this.rotation.z = -Math.acos(BABYLON.Vector3.Dot(new BABYLON.Vector3(0, 1.0, 0), this.upVector));

        if (isNaN(this.rotation.x)) {
            this.rotation.x = 0;
        }

        if (isNaN(this.rotation.y)) {
            this.rotation.y = 0;
        }

        if (isNaN(this.rotation.z)) {
            this.rotation.z = 0;
        }
    };
    // Controls
    RANDO.HikerCamera.prototype.attachControl = function (element, noPreventDefault) {
        var previousPosition;
        var that = this;
        var engine = this._scene.getEngine();

        if (this._attachedElement) {
            return;
        }
        this._attachedElement = element;

        if (this._onMouseDown === undefined) {
            this._onMouseDown = function (evt) {
                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };

                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseUp = function (evt) {
                previousPosition = null;
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseOut = function (evt) {
                previousPosition = null;
                that._keys = [];
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onMouseMove = function (evt) {
                if (!previousPosition && !engine.isPointerLock) {
                    return;
                }

                var offsetX;
                var offsetY;

                if (!engine.isPointerLock) {
                    offsetX = evt.clientX - previousPosition.x;
                    offsetY = evt.clientY - previousPosition.y;
                } else {
                    offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;
                    offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;
                }

                that.cameraRotation.y += offsetX / that.angularSensibility;
                that.cameraRotation.x += offsetY / that.angularSensibility;

                previousPosition = {
                    x: evt.clientX,
                    y: evt.clientY
                };
                if (!noPreventDefault) {
                    evt.preventDefault();
                }
            };

            this._onKeyDown = function (evt) {
                var state = that._state;
                var oldState = state;
                if (that._path.length && !that._isMoving) {
                    var keyCode = evt.keyCode;

                    if (that.keysRewind.indexOf(keyCode) !== -1) {
                        if (state == "pause") {
                            state = "rewind";
                        }
                    }
                    else if (that.keysForward.indexOf(keyCode) !== -1) {
                        if (state == "pause" || state == "stop") {
                            state = "forward";
                        }
                    }
                    that._oldState  = oldState;
                    that._state     = state;
                }
            };

            this._onKeyUp = function (evt) {
                var state = that._state;
                var oldState = state;
                if (that._path.length && !that._isMoving) {
                    var keyCode = evt.keyCode;

                    if (that.keysPlayPause.indexOf(keyCode) !== -1) {
                        if (state == "stop" || state == "pause") {
                            state = "play";
                        } else if (state == "play") {
                            state = "pause";
                        }
                    }
                    else if (that.keysStop.indexOf(keyCode) !== -1) {
                        if (state == "play" || state == "pause" || !state) {
                            state = "stop";
                        }
                    }
                    else if (that.keysRewind.indexOf(keyCode) !== -1) {
                        if (state == "rewind" && that._timeline._time == 0) {
                            state = "stop";
                        }
                        else if (state == "rewind" && that._timeline._time != 0) {
                            state = "pause";
                        }
                    }
                    else if (that.keysForward.indexOf(keyCode) !== -1) {
                        if (state == "forward") {
                            state = "pause";
                        }
                    }
                    that._oldState  = oldState;
                    that._state     = state;
                }
            };

            this._onLostFocus = function () {
                that._keys = [];
            };

            this._reset = function () {
                that._keys = [];
                previousPosition = null;
                that.cameraRotation = new BABYLON.Vector2(0, 0);

                if (that._path.length) {
                    that.loadPathOnTimeline();
                }
                that._oldState = null;
                that._state = "stop";

                if (that._position_transition) {
                    that._position_transition.kill();
                }
                if (that._rotation_transition) {
                    that._rotation_transition.kill();
                }
            };
        }

        element.addEventListener("mousedown", this._onMouseDown, false);
        element.addEventListener("mouseup", this._onMouseUp, false);
        element.addEventListener("mouseout", this._onMouseOut, false);
        element.addEventListener("mousemove", this._onMouseMove, false);

        BABYLON.Tools.RegisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);
    };

    RANDO.HikerCamera.prototype.detachControl = function (element) {
        if (this._attachedElement != element) {
            return;
        }

        element.removeEventListener("mousedown", this._onMouseDown);
        element.removeEventListener("mouseup", this._onMouseUp);
        element.removeEventListener("mouseout", this._onMouseOut);
        element.removeEventListener("mousemove", this._onMouseMove);

        BABYLON.Tools.UnregisterTopRootEvents([
            { name: "keydown", handler: this._onKeyDown },
            { name: "keyup", handler: this._onKeyUp },
            { name: "blur", handler: this._onLostFocus }
        ]);

        this._attachedElement = null;
        if (this._reset) {
            this._reset();
        }
    };

    RANDO.HikerCamera.prototype._update = function () {

        var needToRotate = (
            Math.abs(this.cameraRotation.x) > 0 ||
            Math.abs(this.cameraRotation.y) > 0
        );
        var stateHaveChanged = (this._oldState != this._state);

        // Rotate
        if (needToRotate) {
            this.rotation.x += this.cameraRotation.x;
            this.rotation.y += this.cameraRotation.y;

            if (!this.noRotationConstraint) {
                var limit = (Math.PI / 2) * 0.95;

                if (this.rotation.x > limit)
                    this.rotation.x = limit;
                if (this.rotation.x < -limit)
                    this.rotation.x = -limit;
            }

            // Inertia
            if (Math.abs(this.cameraRotation.x) < BABYLON.Engine.epsilon)
                this.cameraRotation.x = 0;

            if (Math.abs(this.cameraRotation.y) < BABYLON.Engine.epsilon)
                this.cameraRotation.y = 0;

            this.cameraRotation.scaleInPlace(this.inertia);
        }

        // State
        if (stateHaveChanged) {
            console.log(this._oldState + " to " + this._state);
            var newState = this._state;

            switch (newState) {
                case "stop" :
                    this._isMoving = true;
                    this._timeline.pause();
                    var that = this;
                    this.moveTo(this._path[0], this._path[1], this.returnSpeed, function(){
                        that._timeline.pause(0);
                        that._isMoving = false;
                    });
                break;
                case "play" :
                    this._timeline.play();
                break;
                case "pause" :
                    this._timeline.pause();
                break;
                case "rewind" :
                    this._timeline.reverse();
                break;
                case "forward" :
                    this._timeline.play();
            }

            this._oldState = this._state;
        }
    };

    RANDO.HikerCamera.prototype._getViewMatrix = function () {
        BABYLON.Vector3.FromFloatsToRef(0, 0, 1, this._referencePoint);

        if (!this.lockedTarget) {
            // Compute
            if (this.upVector.x != 0 || this.upVector.y != 1.0 || this.upVector.z != 0) {
                BABYLON.Matrix.LookAtLHToRef(BABYLON.Vector3.Zero(), this._referencePoint, this.upVector, this._lookAtTemp);
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);

                this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix, this._tempMatrix);
                this._lookAtTemp.invert();
                this._tempMatrix.multiplyToRef(this._lookAtTemp, this._cameraRotationMatrix);
            } else {
                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
            }

            BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);

            // Computing target and final matrix
            this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        } else {
            this._currentTarget.copyFrom(this._getLockedTargetPosition());
        }

        BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);
        return this._viewMatrix;
    };

    RANDO.HikerCamera.prototype.setPath = function (vertices) {
        // Reinitialize the path
        var path = this._path;
        if (path.length) {
            path = [];
        }

        // Fill path array
        for (var i = 0; i < vertices.length; i+=20) {
            path.push(vertices[i]);
        }
        if (vertices[vertices.length] != path[path.length]) {
            path.push(vertices[vertices.length]);
        }

        // Load this path on the timeline
        this._lengthOfBezier = vertices.length;
        this.loadPathOnTimeline ();
    };

    RANDO.HikerCamera.prototype.loadPathOnTimeline = function () {
        // Verify if path and lengthOfBezier exist
        if (!this._path) {
            return;
        }
        if (!this._lengthOfBezier) {
            this._lengthOfBezier = this._path.length * 2;
        }

        // Reinitialize timeline
        if (this._timeline) {
            this._timeline.clear();
            this._timeline.kill();
            this._timeline = null;
        }
        var that = this;
        this._timeline = new TimelineLite({onComplete: function () {
            that._onCompleteTimeline();
        }});

        // Initials parameters of animation
        var quantity = this._lengthOfBezier;
        var duration = this._lengthOfBezier / this.followSpeed;
        var position = {
            x: this._path[0].x,
            y: this._path[0].y,
            z: this._path[0].z
        };

        // Creates the Bezier curve
        var tween = TweenLite.to(position, quantity, {bezier: this._path, ease:Linear.easeNone});
        var i, d = 20;

        // Load the Bezier curve on timeline
        for (i = 0; i < quantity-d; i++) {
            tween.time(i); // Jumps to the appropriate time in the tween, causing
                            // position variable to be updated accordingly.
            var currentPosition = _.clone(position);
            tween.time(i+d);
            var currentTarget = _.clone(position);
            var rotation_y = RANDO.Utils.angleFromAxis(currentPosition, currentTarget, BABYLON.Axis.Y);

            this._timeline.add([
                TweenLite.to(this.position, (duration / quantity), {
                    x: currentPosition.x,
                    y: currentPosition.y + RANDO.SETTINGS.CAM_OFFSET,
                    z: currentPosition.z,
                    ease: "Linear.easeNone"
                }),
                TweenLite.to(this.rotation, (duration / quantity), {
                    directionalRotation :{ y: (rotation_y +"_short"), useRadians:true} ,
                    ease: "Linear.easeNone"
                })
            ]);
        }
        while (i < quantity) {
            tween.time(i++);
            this._timeline.add(
                TweenLite.to(this.position, (duration / quantity), {
                    x: position.x,
                    y: position.y + RANDO.SETTINGS.CAM_OFFSET,
                    z: position.z,
                    ease: "Linear.easeNone"
                })
            );
        }

        // Animation paused by default
        this._timeline.pause(0);
    };

    RANDO.HikerCamera.prototype.getTarget = function () {
        return this._currentTarget;
    };

    RANDO.HikerCamera.prototype._onCompleteTimeline = function () {
        this._state = "stop";
    };

    RANDO.HikerCamera.prototype.moveTo = function (futurePosition, futureTarget, speed, onComplete) {
        var y_rotation = RANDO.Utils.angleFromAxis(futurePosition, futureTarget, BABYLON.Axis.Y);

        var distance = BABYLON.Vector3.Distance(this.position, futurePosition);
        var duration = distance / speed;

        // Translation
        this._positionTween = TweenLite.to(this.position, duration, {
            x: futurePosition.x,
            y: futurePosition.y + RANDO.SETTINGS.CAM_OFFSET,
            z: futurePosition.z,
            ease: 'ease-in',
            onComplete : function (){
                if (typeof(onComplete) === "function") onComplete();
            }
        });

        // Rotation
        this._rotationTween = TweenLite.to(this.rotation, duration, {
            directionalRotation : {
                x: "0_short",
                y: (y_rotation + "_short"),
                z: "0_short",
                useRadians : true
            },
            ease: 'ease-in'
        });
    };
};
},{}],7:[function(require,module,exports){
/*******************************************************************************
 * Rando.Dem.js
 *
 * Dem class :
 *  Permites the creation of a Digital Elevation Model in 3D
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Dem = function (extent, altitudes, offsets, scene) {
        /* Attributes declaration */
        this._extent = this._prepareExtent(extent, offsets);
        this._altitudes = altitudes
        this._offsets = offsets;
        this._scene = scene;
        this._tiles = null;
        this._frame = null;
        this._textures = [];
        this._min_thickness = RANDO.SETTINGS.MIN_THICKNESS;

        this.ground = new BABYLON.Mesh("Digital Elevation Model", scene);
        this.sides  = new BABYLON.Mesh("Sides", scene);
        this.scaleViewer = null;

        /* Initialization */
        this.init();
    };

    /* Methods */
    RANDO.Dem.prototype.init = function () {
        this._adjustZoom ();

        var tileContainer = new RANDO.TileContainer(
            this.getRealExtent(),
            this._altitudes,
            this._offsets
        );
        this._tiles = tileContainer._tiles;
        this._frame = tileContainer.getFrame();

        this.buildGround();
        this.buildSides();
        this.buildBasement();
    };

    /*
     * RANDO.Dem._prepareExtent() : translate extent of the offsets in parameters
     *  - extent : extent to translate
     *  - offsets : values of the translation
     */
    RANDO.Dem.prototype._prepareExtent = function (extent, offsets) {
        extent.x.min += offsets.x;
        extent.x.max += offsets.x;
        extent.z.min += offsets.z;
        extent.z.max += offsets.z;
        return extent;
    };

    /*
     * RANDO.Dem._adjustZoom() : adjust the tile's zoom according the extent of the DEM
     *  More the DEM is large, more the zoom decreased and so tiles are bigger.
     *
     * NB : It take in count the RANDO.SETTINGS.TILE_NUMBER_LIMIT which correspond to the
     * limit number of tiles. This number can be changed in convenience before launch the scene.
     */
    RANDO.Dem.prototype._adjustZoom = function () {
        while (RANDO.Utils.getNumberOfTiles(RANDO.SETTINGS.TILE_ZOOM, this.getRealExtent()) > RANDO.SETTINGS.TILE_NUMBER_LIMIT) {
            RANDO.SETTINGS.TILE_ZOOM -= 1;
        }
    };

    /**
     * RANDO.Dem.buildGround() : build the ground of the DEM
     */
    RANDO.Dem.prototype.buildGround = function () {
        // Ground building...
        console.log("Ground building... " + (Date.now() - RANDO.START_TIME) );

        // Creates all tiles
        for (var it in this._tiles) {
            var meshTile = this._buildTile(this._tiles[it]);
            meshTile.parent = this.ground;

            // Prepare the future tile's texture
            this._prepareTexture(this._tiles[it].coordinates);
        }

        // Ground built !
        console.log("Ground built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem.buildSides() : build four sides of the DEM
     */
    RANDO.Dem.prototype.buildSides = function () {
        // Sides building...
        console.log("Sides building... " + (Date.now() - RANDO.START_TIME) );

        var alt_min = - this._min_thickness;

        // Creates differents sides
        var e_side = this._buildSide("East Side",  this._frame.east,  alt_min, false);
        var w_side = this._buildSide("West Side",  this._frame.west,  alt_min, true );
        var n_side = this._buildSide("North Side", this._frame.north, alt_min, false);
        var s_side = this._buildSide("South Side", this._frame.south, alt_min, true );

        // Set sides container as parent of sides
        e_side.parent = this.sides;
        w_side.parent = this.sides;
        n_side.parent = this.sides;
        s_side.parent = this.sides;

        // Sides built !
        console.log("Sides built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem.buildBasement() : build the basement of the DEM
     */
    RANDO.Dem.prototype.buildBasement = function () {
        // Basement building...
        console.log("Basement building... " + (Date.now() - RANDO.START_TIME) );

        var A = {
            'x' : this._extent.x.min,
            'y' : this._extent.z.min
        };
        var B = {
            'x' : this._extent.x.max,
            'y' : this._extent.z.min
        };
        var C = {
            'x' : this._extent.x.max,
            'y' : this._extent.z.max
        };
        var D = {
            'x' : this._extent.x.min,
            'y' : this._extent.z.max
        };
        var basement = RANDO.Utils.createGroundFromExtent (
            "DEM Basement", A, B, C, D, 1, 1, this._scene
        );
        basement.material = new BABYLON.StandardMaterial("Basement Material", this._scene);
        basement.material.diffuseTexture = new BABYLON.Texture(
            RANDO.SETTINGS.SIDE_TEX_URL,
            this._scene
        );
        basement.position.y -= this._min_thickness;

        // Basement built !
        console.log("Basement built ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Dem._buildTile() : build a tile of the DEM
     *      - data : data of a tile
     *
     *  return the tile mesh
     */
    RANDO.Dem.prototype._buildTile = function (data) {
        var scene   = this._scene;
        var engine  = scene.getEngine();
        var that    = this;

        // Creates Tile
        var tile = RANDO.Utils.createGroundFromGrid(
            "Tile",
            data.grid,
            scene
        );

        // Recomputes normals for lights and shadows
        RANDO.Utils.computeMeshNormals(tile)

        // Set Uvs data of the tile
        RANDO.Utils.setMeshUvs(tile, data.uv);

        // Enables collisions
        tile.checkCollisions = true;

        // Material
        var material = new BABYLON.StandardMaterial("DEM - Material", scene);
        material.wireframe = true;
        material.backFaceCulling = false;
        tile.material = material;
        return tile;
    };

    /**
     * RANDO.Dem._buildSide() : build a side of the DEM
     *      - name: name of the side
     *      - line: Array of point corresponding to a border of the DEM
     *      - alt_min: altitude minimale of the DEM
     *      - reverse: Boolean, if true reverse the line
     *
     *  return the side mesh
     */
    RANDO.Dem.prototype._buildSide = function (name, line, alt_min, reverse) {
        var scene = this._scene;

        if (reverse) {
            line.reverse();
        }

        // Creates side
        var side = RANDO.Utils.createSideFromLine(name, line, alt_min, scene);

        this._computeSideUvs(side, line, alt_min);

        // Side material
        side.material = new BABYLON.StandardMaterial(name + "Material", scene);
        side.material.diffuseTexture = new BABYLON.Texture(RANDO.SETTINGS.SIDE_TEX_URL, scene);

        // Recomputes normals for lights and shadows
        RANDO.Utils.computeMeshNormals(side);

        // Enables collisions
        side.checkCollisions = true;

        return side;
    };

    /**
     * RANDO.Dem.applyTextures() : Load tile's textures over the DEM
     */
    RANDO.Dem.prototype.applyTextures = function () {
        console.log("Textures application ... " + (Date.now() - RANDO.START_TIME) );

        //~ // Prepare all textures
        //~ for (var it in this._tiles) {
            //~ this._prepareTexture(this._tiles[it].coordinates);
        //~ }

        var scene = this._scene;
        var meshes = this.ground.getChildren ();
        var finalTextures = this._textures;
        var checked = [];
        var count = finalTextures.length;
        for (var it in finalTextures){
            checked.push(false);
        }

        function loop (){
            var it = 0;
            var chunk = 50;
            function apply () {
                var cnt = chunk;
                while (cnt-- && it < finalTextures.length) {
                    if (!checked[it] && finalTextures[it]._texture.isReady) {
                        checked[it] = true;

                        // Set the texture when it's loaded
                        var material = meshes[it].material;
                        material.diffuseTexture = finalTextures[it];
                        material.diffuseTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
                        material.diffuseTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
                        material.wireframe = false;
                        count--;
                    }
                    it++;
                }
                if (it < finalTextures.length) {
                    setTimeout (apply, 1);
                } else if (count > 0) {
                    setTimeout (loop, 1);
                } else {
                    console.log("Textures applied ! " + (Date.now() - RANDO.START_TIME) );
                }
            };
            apply();
        }
        loop();
    };

    /**
     * RANDO.Dem._prepareTexture() : Prepare a tile of textures for the DEM and add
     *  it to the textures Array.
     *      - coordinates : coordinates of a tile
     *
     */
    RANDO.Dem.prototype._prepareTexture = function (coordinates) {
        var scene = this._scene;
        var engine = scene.getEngine();
        var url = RANDO.Utils.replaceUrlCoordinates(
            RANDO.SETTINGS.TILE_TEX_URL,
            coordinates.z,
            coordinates.x,
            coordinates.y
        );
        this._textures.push(new BABYLON.Texture(url, scene));
    };

    /**
     * RANDO.Dem._computeSideUvs() : Computes uvs values of a side
     *      - side : side mesh
     *      - line : line of altitudes
     *      - alt_min : it is the minimum altitude of the DEM
     */
    RANDO.Dem.prototype._computeSideUvs = function (side, line, alt_min) {
        var cType = 'z';
        if (line[line.length-1].z - line[0].z == 0) {
            cType = 'x';
        }

        var u = [];
        for (var it in line) {
            u.push(
                Math.abs(line[it][cType] - line[0][cType]) *
                1 / (Math.abs(line[line.length-1][cType] - line[0][cType]))
            );
        }

        var uv = [];
        for (var it in u) {
            uv.push(u[it]); // u value
            uv.push((line[it].y - alt_min)/(this._extent.y.max - alt_min)); // v value
        }
        for (var it in u) {
            uv.push(u[it]); // u value
            uv.push(0); // v value
        }

        side.setVerticesData(BABYLON.VertexBuffer.UVKind, uv);
    };

    /**
     * RANDO.Dem.getRealExtent() : Give the real extent of the DEM, it means the
     *  extent in meters in the original projection.
     */
    RANDO.Dem.prototype.getRealExtent = function () {
        var extent = {};
        extent.x = {};
        extent.y = {};
        extent.z = {};
        extent.x.min = this._extent.x.min - this._offsets.x;
        extent.x.max = this._extent.x.max - this._offsets.x;
        extent.y.min = this._extent.y.min;
        extent.y.max = this._extent.y.max;
        extent.z.min = this._extent.z.min - this._offsets.z;
        extent.z.max = this._extent.z.max - this._offsets.z;
        return extent;
    };
};
},{}],8:[function(require,module,exports){
module.exports = function(RANDO) {

    var RANDO = RANDO || {};

    RANDO.Events = {};
    /*
     * Bind and Unbind events
     *
     ***************************/
    // DOM Level 2 Event model
    if (document.addEventListener) {
        RANDO.Events.addEvent = function (elem, type, fn) {
            elem.addEventListener(type, fn, false);
            return fn;
        };
        RANDO.Events.removeEvent = function (elem, type, fn) {
            elem.removeEventListener(type, fn, false);
        };
    }
    // Proprietary legacy IE Model
    else if (document.attachEvent) {
        RANDO.Events.addEvent = function (elem, type, fn) {
            var bound = function () {
                return fn.apply(elem, arguments);
            };
            elem.attachEvent("on" + type, bound);
            return bound;
        };
        RANDO.Events.removeEvent = function (elem, type, fn) {
            elem.removeEventListener("on" + type, fn);
        };
    }
};
},{}],9:[function(require,module,exports){
/*******************************************************************************
 * Rando.Poi.js
 *
 * Poi class :
 *  Permites the build of a Point of Interest in 3D
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Poi = function (id, data, offsets, scene) {
        this._id            = id
        this._position      = {
            'x' : data.coordinates.x + offsets.x,
            'y' : 0,
            'z' : data.coordinates.z + offsets.z
        };
        this._name          = data.properties.name;
        this._type          = data.properties.type;
        this._elevation     = data.properties.elevation;
        this._description   = data.properties.description || RANDO.SETTINGS.NO_DESCRIPTION_MESSAGE;
        this._scene         = scene;

        this.panel          = null;
        this.picto          = null;
        this.sphere         = null;
        this._attachedLight = null;
        this.init();
    };

    RANDO.Poi.prototype.init = function () {
        this._buildPanel ();
        this._buildSphere ();

        var that = this;
        this._scene.registerBeforeRender( function () {
            that._registerBeforeRender();
        });
    };

    /**
     * RANDO.Poi._buildPanel() : build a Panel with a picto which defines the type of POI
     */
    RANDO.Poi.prototype._buildPanel = function () {
        var scene       = this._scene;
        var position    = this._position;
        var text        = this._name;
        var src         = RANDO.SETTINGS.PICTO_PREFIX + this._type.pictogram;
        var id          = this._id;
        var elevation   = this._elevation;

        // Size of panel (in pixel and in meters)
        var pan_size = {
            px: {
                width : 512,
                height : 512
            },
            m: {
                width : RANDO.SETTINGS.PICTO_SIZE,
                height : RANDO.SETTINGS.PICTO_SIZE + 30
            }
        };
        // Size of the pictogram (in pixels)
        var picto_size = {
            width : pan_size.px.width,
            height : pan_size.px.height * RANDO.SETTINGS.PICTO_SIZE / pan_size.m.height
        };

        // Building panel Mesh
        var panel = BABYLON.Mesh.CreateGround(
            "POI - Panel",
            pan_size.m.width,
            pan_size.m.height,
            2, scene
        );
        panel.id = id;
        panel.rotate (BABYLON.Axis.X, -Math.PI/2, BABYLON.Space.LOCAL);
        panel.position.x = position.x;
        panel.position.y = -1000;
        panel.position.z = position.z;
        panel.material = new BABYLON.StandardMaterial("POI - Panel - Material", scene);
        this.panel = panel;

        // Panel Texture
        var panel_tex = new BABYLON.DynamicTexture("POI - Panel - Texture", pan_size.px.width, scene, true);
        panel_tex.hasAlpha = true;
        fillPanelTexture();

        // Building pictogram Container
        var picto = BABYLON.Mesh.CreateGround(
            "POI - Panel",
            pan_size.m.width,
            pan_size.m.height,
            2, scene
        );
        picto.id = id;
        picto.material = new BABYLON.StandardMaterial("POI - Picto - Material", scene);
        picto.renderingGroupId = 1;
        this.picto = picto;
        picto.parent = panel;

        // Pictogram Texture
        var picto_tex = new BABYLON.DynamicTexture("POI - Picto - Texture", pan_size.px.width, scene, true);
        picto_tex.hasAlpha = true;
        fillPictoTexture();

        function fillPictoTexture () {
            var pictoContext = picto_tex.getContext();

            // Load the pictogram on the pictogram container
            var img = new Image();
            img.onload = function () {
                pictoContext.drawImage(img, 0, 0, picto_size.width, picto_size.height);

                // Update
                pictoContext.restore();
                picto_tex.update();
                picto.material.diffuseTexture = picto_tex;
                picto.material.emissiveTexture = picto_tex;
            };
            img.src = src;
        };

        function fillPanelTexture () {
            var panelContext = panel_tex.getContext();

            // Draws background of the pictogram on the panel
            panelContext.fillStyle = "rgba(255, 255, 255, 0.5)";
            RANDO.Utils.roundRect(panelContext, 0, 0, picto_size.width, picto_size.height, pan_size.px.width/10);

            // Set & draw the text on the panel
            var text = elevation + "m";
            var fontSize = (pan_size.px.height - picto_size.height) * RANDO.SETTINGS.POI_LABEL_SCALE ;
            panelContext.font = "bolder " + fontSize + "pt Arial";
            panelContext.fillStyle = "#fff";
            panelContext.textAlign = "center";
            panelContext.fillText(text, pan_size.px.width/2, pan_size.px.height);

            // Update
            panelContext.restore();
            panel_tex.update();
            panel.material.opacityTexture   = panel_tex;
            panel.material.emissiveTexture  = panel_tex;
        };
    };

    /**
     * RANDO.Poi._buildSphere() : build a Sphere which will be on the real position
     *  of the POI on the DEM.
     */
    RANDO.Poi.prototype._buildSphere = function () {
        var scene       = this._scene;
        var position    = this._position;

        var sphere = BABYLON.Mesh.CreateSphere(
            "POI - Sphere", 10, RANDO.SETTINGS.POI_SIZE, scene
        );
        sphere.material = new BABYLON.StandardMaterial(
            "POI - Sphere - Material", scene
        );
        sphere.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        sphere.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        this.sphere = sphere;
    };

    /**
     * RANDO.Poi._registerBeforeRender() : function to call before each scene render
     */
    RANDO.Poi.prototype._registerBeforeRender = function () {
        var scene       = this._scene;
        var panel       = this.panel;
        var picto       = this.picto;

        // Controls visibility according the Distance from camera
        if (BABYLON.Vector3.Distance(panel.position, scene.activeCamera.position) < 300) {
            panel.isVisible = false;
            picto.isVisible = false;
        }
        else {
            panel.isVisible = true;
            picto.isVisible = true;
        }

        // Controls panel orientation
        panel.lookAt(scene.activeCamera.position, 0, -Math.PI/2, 0);
    };

    /**
     * RANDO.Poi.drape() : drape the POI over the DEM
     *      - ground : ground of the DEM
     */
    RANDO.Poi.prototype.drape = function (ground) {
        RANDO.Utils.drapePoint(this.panel.position, ground, RANDO.SETTINGS.POI_OFFSET);
        this.sphere.position = this.panel.position.clone();
        this.sphere.position.y -= RANDO.SETTINGS.POI_OFFSET;
    };

    /**
     * RANDO.Poi.onMouseDownHandler() : callback to run if the mouse is down over a picto
     *      - evt: event informations
     */
    RANDO.Poi.prototype.onMouseDownHandler = function (evt) {
        $('.poi--clicked').text(this._name + ' (' + this._elevation + 'm )');
        $('.poi--clicked').css('left', evt.clientX - 20 + 'px');
        $('.poi--clicked').css('top',  evt.clientY - 40 + 'px');
        $('.poi--clicked').css('display', 'block');

        $('.poi_side h2').html(this._name );
        $('.poi_side .description').html(this._description);
        $('.poi_side').css('display', 'block');

        $('.interface').css('width', '80%');
    };

    /**
     * RANDO.Poi.onMouseOverHandler() : callback to run if the mouse is over a picto
     *      - evt: event informations
     */
    RANDO.Poi.prototype.onMouseOverHandler = function (evt) {
        $('.poi--hover').text(this._name + ' (' + this._elevation + 'm )');
        $('.poi--hover').css('left', evt.clientX - 20 + 'px');
        $('.poi--hover').css('top',  evt.clientY - 40 + 'px');
        $('.poi--hover').css('display', 'block');

        $('#canvas_renderer')[0].style.cursor = 'pointer';
    };

    /** Static
     * RANDO.Poi.runMouseListener() : Static function which run all mouse
     *  listeners linked to POIs, we give it a POI's array and it adds
     *  mouse events over all its elements.
     *
     *      - canvas : canvas where the scene is
     *      - pois : array of POIs
     *      - scene : scene
     */
    RANDO.Poi.runMouseListener = function (canvas, pois, scene) {
        var clickedID;

        // MouseDown Event : check if the mouse is over a Picto when Mouse left click is down
        RANDO.Events.addEvent(window, "mousedown", function (evt) {
            var pickResult = scene.pick (evt.clientX, evt.clientY);
            var pickedMesh = pickResult.pickedMesh;

            $('.poi--hover').css('display', 'none');
            $('.poi--clicked').css('display', 'none');
            clickedID = -1;

            // if the click hits a pictogram, we display informations of POI
            if (pickResult.hit && pickedMesh.name == "POI - Panel") {
                pois[pickedMesh.id].onMouseDownHandler(evt);
                clickedID = pickedMesh.id;
            }
        });

        // MouseMove Event : always check if mouse is over a Picto
        RANDO.Events.addEvent(window, "mousemove", function (evt) {
            var pickResult = scene.pick (evt.clientX, evt.clientY);
            var pickedMesh = pickResult.pickedMesh;

            $('.poi--hover').css('display', 'none');
            $('#canvas_renderer')[0].style.cursor = 'default';

            // if mouse is over a pictogram, we display informations of POI
            if (pickResult.hit && pickedMesh.name == "POI - Panel"
                && clickedID != pickedMesh.id) {
                pois[pickedMesh.id].onMouseOverHandler(evt);
            }
        });

        // Close button events of the POI side
        $(".close_btn").on('click', function () {
            $(".poi_side").css('display', 'none');
            $('.interface').css('width', '100%');
        });
        $(".close_btn").mouseover( function () {
           this.style.cursor = 'pointer';
        });
        $(".close_btn").mouseout( function () {
            this.style.cursor = 'default';
        });
    };

};
},{}],10:[function(require,module,exports){
/*******************************************************************************
 * Rando.Scene.js
 *
 * Scene class :
 *  Permites the creation and manipulation of a scene 3D containing (or not) :
 *      - a Digital Elevation Model
 *      - a Trek which is draped over the DEM
 *      - a set of Points Of Interest draped over the DEM too
 *      - a set of Cameras
 *      - a set of lights
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/


module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Scene = function (canvas, cameraID) {
        // Attributes declaration
        this._canvas    = canvas;
        this._cameraID  = cameraID;

        this._engine    = null;
        this._scene     = null;
        this.camContainer    = null;
        this.lights     = {};
        this.dem        = null;
        this.trek       = null;
        this.pois       = [];

        this._dem_data  = {};
        this._trek_data = [];
        this._pois_data = [];
        this._offsets   = {};
    };


    /* Methods */
    RANDO.Scene.prototype.init = function () {
        RANDO.START_TIME = Date.now();
        this._engine = new BABYLON.Engine(this._canvas, true);
        this._scene  = new BABYLON.Scene(this._engine);
        var that = this;
        RANDO.Events.addEvent(window, "resize", function(){
            that._engine.resize();
        });

        this._scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        this._scene.collisionsEnabled = true;
        this._buildLights();
        this.process();
    };

    /**
     * RANDO.Scene.process() : launch the building process of the scene
     *  It displays :
     *          - Terrain
     *          - Trek
     *          - POIs
     */
    RANDO.Scene.prototype.process = function () {
        var that = this;

        $.getJSON(RANDO.SETTINGS.DEM_URL)
         .done(function (data) {
            that._parseDemJson(data);
            that._buildCameras();
         })
         .then(function () {
            return $.getJSON(RANDO.SETTINGS.PROFILE_URL);
         })
         .done(function (data) {
            that._parseTrekJson(data);
         })
         .then(function () {
            return $.getJSON(RANDO.SETTINGS.POI_URL);
         })
         .done(function (data) {
            that._parsePoiJson(data);

         })
         .then(function () {
            // Run renderloop
            that._engine.runRenderLoop(function() {
                that._scene.render();
            });

            // Tiled DEM mesh building
            that.dem = new RANDO.Dem(
                that._dem_data.extent,
                that._dem_data.altitudes,
                that._offsets,
                that._scene
            );

            // Trek building
            that.trek = new RANDO.Trek  (
                that._trek_data,
                that._offsets,
                that._scene
            );

            // POIs building
            var id = 0;
            for (var it in that._pois_data) {
                if (RANDO.Utils.isInExtent(that._pois_data[it].coordinates, that.dem.getRealExtent())) {
                    that.pois.push(new RANDO.Poi(
                        id++,
                        that._pois_data[it],
                        that._offsets,
                        that._scene
                    ));
                }
            }
            RANDO.Poi.runMouseListener(that._canvas, that.pois, that._scene);

            // To execute when scene is ready
            that._scene.executeWhenReady(function () {
                that._executeWhenReady ();
            });
         })
    };

    /**
     * RANDO.Scene._buildCameras() : builds cameras of the scene
     *
     *  If the camera ID is not available, it is changed to "demo_camera"
     */
    RANDO.Scene.prototype._buildCameras = function () {
        // Parameters for the Camera Container
        var params = {
            'demCenter' : this._dem_data.center,
            'offsets'   : this._offsets,
            'demExtent' : this._dem_data.extent,
            'demAltitudes': this._dem_data.altitudes,
            'switchEnabled' : true
        };

        // Instantiate the container
        this.camContainer = new RANDO.CameraContainer(this._canvas, this._scene, params);

        // Control camera ID entered (examine_camera by default)...
        if (!$.inArray(this._cameraID, RANDO.CameraIDs))
            this._cameraID = "examine";

        // ...and set it as active
        this.camContainer.setActiveCamera (this._cameraID);
    };

    /**
     * RANDO.Scene._buildLights() : builds the differents lights of the scene
     */
    RANDO.Scene.prototype._buildLights = function () {
        var scene = this._scene;

        // Sun
        this.lights.sun = light (
            "Sun", new BABYLON.Vector3(-500, -10000, 0), 1.2
        );

        // Side Light 1
        this.lights.sideLight1 = light (
            "Side Light 1", new BABYLON.Vector3(1, 0, 0.8), 1.2
        );

        // Side Light 2
        this.lights.sideLight2 = light (
            "Side Light 2", new BABYLON.Vector3(-1, 0, -0.8), 1.2
        );

        // light() : return a directional light
        function light (name, direction, intensity) {
            var light = new BABYLON.DirectionalLight(
                name,
                direction,
                scene
            );
            light.intensity = intensity;
            light.specular = new BABYLON.Color4(0, 0, 0, 0);
            return light;
        }
    };

    /**
     * RANDO.Scene._executeWhenReady() : function which is executed when the scene
     *  is ready, in other words, when the scene have built all its elements.
     */
    RANDO.Scene.prototype._executeWhenReady = function () {
        console.log("Scene is ready ! " + (Date.now() - RANDO.START_TIME) );

        var trek            = this.trek;
        var camContainer    = this.camContainer;
        var lights          = this.lights;

        // Init sidelights excluded meshes arrays with the tiles
        lights.sideLight1.excludedMeshes = this.dem.ground.getChildren();
        lights.sideLight2.excludedMeshes = this.dem.ground.getChildren();

        // Apply DEM textures
        this.dem.applyTextures();

        // Drape the trek with an onComplete callback
        trek.drape(this.dem.ground, onDrapeComplete);

        // Drape POIS
        for (var it in this.pois) {
            this.pois[it].drape(this.dem.ground);
        }

        function onDrapeComplete () {
            // Updates trek vertices ...
            trek.updateVertices();

            // ... to give them to the camera container (for hiker camera)
            camContainer.setAnimationPath(trek._vertices);

            // Merges the trek to increase performances
            trek.merge();

            // Update excluded meshes of lights
            $.merge(lights.sideLight1.excludedMeshes, trek.mergedTreks);
            $.merge(lights.sideLight2.excludedMeshes, trek.mergedTreks);
        }
    };

    /**
     * RANDO.Scene._parseDemJson() : parse data from the DEM json
     *      - data : data from DEM json
     */
    RANDO.Scene.prototype._parseDemJson = function (data) {
        // Conversions
        var m_center = RANDO.Utils.toMeters(data.center);
        var m_extent = RANDO.Utils.getMetersExtent (data.extent);

        // Record DEM extent
        this._dem_data.extent = m_extent;
        this._dem_data.extent.y.min *= RANDO.SETTINGS.ALTITUDES_Z_SCALE;
        this._dem_data.extent.y.max *= RANDO.SETTINGS.ALTITUDES_Z_SCALE;

        // Record DEM altitudes scaled
        this._dem_data.altitudes = RANDO.Utils.scaleArray2(
            data.altitudes,
            RANDO.SETTINGS.ALTITUDES_Z_SCALE
        );

        // Record DEM center
        this._dem_data.center = {
            'x' : m_center.x,
            'y' : (this._dem_data.extent.y.min + this._dem_data.extent.y.max) / 2,
            'z' : m_center.y
        };

        // Records scene offsets
        this._offsets.x = -m_center.x;
        this._offsets.z = -m_center.y;
    };

    /**
     * RANDO.Scene._parseTrekJson() : parse data from the Trek profile json
     *      - data : data from Trek profile json
     */
    RANDO.Scene.prototype._parseTrekJson = function (data) {

        for (var it in data.profile){
            var tmp = {
                'lng' : data.profile[it][2][0],
                'lat' : data.profile[it][2][1]
            };

            // We take only x and z values (not the altitudes)
            tmp = RANDO.Utils.toMeters(tmp);

            // toMeters() give x-y-coordinates and babylon take x-z-coordinates
            tmp.z = tmp.y;
            delete tmp["y"];

            // Record
            this._trek_data.push(tmp);
        }
    };

    /**
     * RANDO.Scene._parsePoiJson() : parse data from the POI json
     *      - data : data from POI json
     */
    RANDO.Scene.prototype._parsePoiJson = function (data) {
        for (var it in data.features) {
            var feature = data.features[it];

            // Conversion
            var coordinates = RANDO.Utils.toMeters({
                'lng' : feature.geometry.coordinates[0],
                'lat' : feature.geometry.coordinates[1]
            });

            // Record
            this._pois_data.push ({
                'coordinates' : {
                    'x': coordinates.x,
                    'z': coordinates.y
                },
                'properties' : feature.properties
            });
        }
    };
};
},{}],11:[function(require,module,exports){
// Rando.Settings.js
// General settings

module.exports = function(RANDO, BABYLON) {
    var RANDO = RANDO || {};
    RANDO.SETTINGS = {};

    // Links
    RANDO.SETTINGS.IMAGES_FOLDER = '';
    RANDO.SETTINGS.DEM_URL = ''; // Url of the DEM json
    RANDO.SETTINGS.PROFILE_URL = ''; // Url of the trek's profile json
    RANDO.SETTINGS.TILE_TEX_URL = ''; // Url of a tile texture
    RANDO.SETTINGS.SIDE_TEX_URL = ''; // Url of the side texture
    RANDO.SETTINGS.TILE_TEX_URL_SUBDOMAINS = ['a', 'b', 'c'];
    ////////////////////////////////////////////////////////////////////////////////


    // Camera
    RANDO.SETTINGS.CAM_OFFSET = 200; // Camera's altitude offset (in meters)

    RANDO.SETTINGS.HCAM_FOLLOW_SPEED = 15; // HikerCamera speed when it follows trek
    RANDO.SETTINGS.HCAM_RETURN_SPEED = 1500; // HikerCamera speed when it comes back to default
    RANDO.SETTINGS.CAM_SPEED_F = 50;  // Camera speed in Flying mode(from 0 to infinity !)
    RANDO.SETTINGS.COLLISIONS_OFFSET = 150;
    ////////////////////////////////////////////////////////////////////////////////


    // Geometry
    RANDO.SETTINGS.ALTITUDES_Z_SCALE = 1.4;
    RANDO.SETTINGS.LIMIT_VERT_BY_MESH = 65536;
    RANDO.SETTINGS.TREK_SPH_TESSEL = 5;
    RANDO.SETTINGS.TREK_CYL_TESSEL = 20;
    RANDO.SETTINGS.MIN_THICKNESS = 200; // Minimum thickness of the DEM
    RANDO.SETTINGS.TREK_OFFSET = 2; // Trek's altitude offset (in meters)

    RANDO.SETTINGS.TREK_COLOR = new BABYLON.Color3(0.1, 0.6, 0.2); // Trek color (green)
                     // new BABYLON.Color3(0.1,0.6,0.2); // green
                     // new BABYLON.Color3(0.8,0,0.2); // fuschia
                     // new BABYLON.Color3(0.9,0.5,0); // orange

    RANDO.SETTINGS.TREK_WIDTH = 10; // Trek width (in meters)

    RANDO.SETTINGS.TILE_ZOOM = 17;
    RANDO.SETTINGS.TILE_NUMBER_LIMIT = 200;

    RANDO.SETTINGS.POI_OFFSET = 100;
    RANDO.SETTINGS.POI_FORM1 = {
        objectName : '' ,
        folder: 'blender/',
        fileName: 'poi.babylon'
    };
    RANDO.SETTINGS.POI_SIZE = 20;
    RANDO.SETTINGS.POI_LABEL_SCALE = 1;
    RANDO.SETTINGS.PICTO_SIZE = 100;
    RANDO.SETTINGS.PICTO_PREFIX = '';

    RANDO.SETTINGS.NO_DESCRIPTION_MESSAGE = '<p>Pas de description liÃ©e Ã  ce point d\'intÃ©rÃªt.</p>';
    RANDO.SETTINGS.CAMERA_MESSAGES = {
        'bird' : 'On peut survoler le terrain tel un oiseau, tourner la tÃªte, monter, descendre et se dÃ©placer !',
        'examine' : 'On peut examiner le terrain en le tournant dans tous les sens.',
        'hiker' : 'Ici on est dans la peau d\'un randonneur, on suit sans effort l\'avancement de l\'itinÃ©raire, en profitant de la vue.'
    };

    return RANDO;
};

////////////////////////////////////////////////////////////////////////////////

},{}],12:[function(require,module,exports){
/*******************************************************************************
 * Rando.TileContainer.js
 *
 * TileContainer class :
 *  Contains all data for the build of a tiled Digital Elevation Model
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function (RANDO) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.TileContainer = function (extent, altitudes, offsets) {
        /* Attributes declaration */
        this._extent = _.clone(extent);
        this._altitudes = _.clone(altitudes);
        this._offsets = _.clone(offsets);
        this._grid = null;
        this._tiles = {};

        this._init();
    };

    /* Methods */
    RANDO.TileContainer.prototype._init = function () {
        this._generateTiles();
        this._joinTiles();
        this._computeSize();
        this._computeUvs();
        this.translate();
    };

    /**
     * RANDO.TileContainer._generateTiles() : generates an array of tiles which are js objects
     */
    RANDO.TileContainer.prototype._generateTiles = function () {
        var zoom = RANDO.SETTINGS.TILE_ZOOM;
        var tiles = this._tiles;
        var col, row;

        this._grid = RANDO.Utils.createElevationGrid(
            this._extent.x.min,
            this._extent.x.max,
            this._extent.z.min,
            this._extent.z.max,
            this._altitudes
        );

        var grid = this._grid;

        var curr_index,  prev_index  = null,
            curr_point,  prev_point  = null,
            curr_tile_n, prev_tile_n = null,
            line_tmp = [],
            new_line = true;

        // Subdivide grid in tiles
        for (row in grid) {
            for (col in grid[row]) {
                curr_point = grid[row][col];

                // Get current tile number corresponding to the current point
                curr_tile_n = RANDO.Utils.meters2num(curr_point.x, curr_point.z, zoom);
                curr_index = "" + zoom + "/" + curr_tile_n.xtile + "/" + curr_tile_n.ytile;

                // tiles["z/x/y"] exists or not
                tiles[curr_index] = tiles[curr_index] || {};
                if (Object.keys(tiles[curr_index]).length == 0){
                    tiles[curr_index].grid = [];
                    tiles[curr_index].coordinates = {
                        z: zoom,
                        x: curr_tile_n.xtile,
                        y: curr_tile_n.ytile
                    };
                }
                // if the previous index exists and is different from the current index
                if ( prev_index != null && prev_index != curr_index ) {
                    tiles[prev_index].grid.push(line_tmp); // push the line into previous tile
                    line_tmp = []; // reset the line
                }

                line_tmp.push(_.clone(curr_point));

                prev_index = curr_index;
                prev_point = curr_point;
                new_line = false;
                prev_tile_n = curr_tile_n;
            }
            new_line = true;
        }

        // Push the last line of the last tile
        tiles[curr_index].grid.push(line_tmp);
    };

    /**
     * RANDO.TileContainer._joinTiles() : joins tiles data
     */
    RANDO.TileContainer.prototype._joinTiles = function () {
        var tiles = this._tiles;
        var col, row, it;

        // Joins East and West sides of tiles
        for (it in tiles) {
            var current_tile = tiles[it];
            var next_coord = {
                z: current_tile.coordinates.z,
                x: current_tile.coordinates.x + 1,
                y: current_tile.coordinates.y
            };
            var next_index = ""  + next_coord.z + "/" + next_coord.x + "/" + next_coord.y + "";

            // if next tile exist
            if (tiles[next_index]) {
                var current_grid = current_tile.grid;
                var next_grid = tiles[next_index].grid;

                // for each row in the current tile grid
                for (row in current_grid) {
                    var prev_point = current_grid[row][current_grid[row].length-1];
                    var next_point = next_grid[row][0];
                    var mid = RANDO.Utils.middle(prev_point, next_point);
                    current_grid[row].push(mid);
                    next_grid[row].splice(0, 0, _.clone(mid));
                }
            }
        }

        // Joins North and South sides of tiles
        for (it in tiles) {
            var current_tile = _.clone(tiles[it]);
            var next_coord = {
                z: current_tile.coordinates.z,
                x: current_tile.coordinates.x,
                y: current_tile.coordinates.y + 1
            };
            var next_index = ""  + next_coord.z + "/" + next_coord.x + "/" + next_coord.y + "";

            if (tiles[next_index]) {
                var next_tile = tiles[next_index];

                // First line of current tile
                var prev_line = _.clone(current_tile.grid[0]);

                // Last line of next tile
                var next_line = _.clone(next_tile.grid[next_tile.grid.length-1]);

                // we create a new line placed on the middle of the both previous
                // We need two variables to store this line
                var med_line1 = [];
                var med_line2 = [];

                for (var i in prev_line) {
                    var mid = RANDO.Utils.middle(prev_line[i], next_line[i]);
                    med_line1.push(_.clone(mid));
                    med_line2.push(_.clone(mid));
                }

                // The "median line" go to the south of current tile
                current_tile.grid.splice(0, 0, med_line1);
                // ... and to the north of next tile
                next_tile.grid.push(med_line2);
            }
        }
    };

    /**
     * RANDO.TileContainer._computeSize() : computes height and width of each tile and add it to the tiles data container
     */
    RANDO.TileContainer.prototype._computeSize = function () {
        var tiles = this._tiles;
        for (var it in tiles) {
            var tile = tiles[it];
            var grid = tile.grid;
            var n = grid.length-1;
            var m = grid[0].length-1;
            tile.size = {
                'width' : grid[0][m].x - grid[0][0].x,
                'height': grid[n][0].z - grid[0][0].z
            };
        }
    };

    /**
     * RANDO.TileContainer._computeUvs() :  computes uv values of each tile and add it to the tiles data container
     */
    RANDO.TileContainer.prototype._computeUvs = function () {
        var tiles = this._tiles;

        var max_width = _.max(tiles, function(tile) {
                return tile.size.width;
        }).size.width;

        var max_height = _.max(tiles, function(tile) {
                return tile.size.height;
        }).size.height;

        var extent = this.getExtentInTilesCoordinates();

        // Fill the uv data of tiles
        for (var it in tiles) {
            var tile = tiles[it];
            tile.uv = {};

            // Fill u array
            if (tile.coordinates.x == extent.x.min) { // East tiles
                tile.uv.u = uValues(tile, max_width, "east");
            }
            else if (tile.coordinates.x == extent.x.max) { // West tiles
                tile.uv.u = uValues(tile, max_width, "west");
            }
            else { // Interior tiles
                tile.uv.u = uValues(tile, tile.size.width, "normal");
            }

            // Fill v array
            if (tile.coordinates.y == extent.y.min) { // North tiles
                tile.uv.v = vValues(tile, max_height, "north");
            }
            else if (tile.coordinates.y == extent.y.max) { // South tiles
                tile.uv.v = vValues(tile, max_height, "south");
            }
            else { // Interior tiles
                tile.uv.v = vValues(tile, tile.size.height, "normal");
            }
        }

        function uValues(tile, width, string) {
            if (typeof (string) === 'undefined') string = "normal";
            console.assert(
                string == "east" || string == "normal" || string == "west",
                "uValues() function uncorrectly used"
            );

            if (string == "west") {
                string = "normal";
            }

            var n = tile.grid[0].length-1;
            switch (string) {
                case "east":
                    var u = [];
                    u[n] = 1;
                    for (var col = n-1; col >= 0; col--) {
                        var crt_x = tile.grid[0][col].x;
                        var nxt_x = tile.grid[0][col+1].x;
                        u[col] = u[col+1] - (Math.abs(nxt_x - crt_x)/width);
                    }
                    return u;
                break;
                case "normal":
                    var u = [];
                    u[0] = 0;
                    for (var col = 1; col <= n; col++) {
                        var crt_x = tile.grid[0][col].x;
                        var prv_x = tile.grid[0][col-1].x;
                        u[col] = u[col-1] + (Math.abs(prv_x - crt_x)/width);
                    }
                    return u;
                break;
                default:
                    return null;
            }
        };


        function vValues(tile, height, string) {
            if (typeof (string) === 'undefined') string = "normal";
            console.assert(
                string == "south" || string == "normal" || string == "north",
                "uValues() function uncorrectly used"
            );

            if (string == "north") {
                string = "normal";
            }

            var m = tile.grid.length-1;
            switch (string) {
                case "south":
                    var v = [];
                    v[m] = 1;
                    for (var row = m-1; row >= 0; row--) {
                        var crt_z = tile.grid[row][0].z;
                        var nxt_z = tile.grid[row+1][0].z;
                        v[row] = v[row+1] - (Math.abs(nxt_z - crt_z)/height);
                    }
                    v.reverse();
                    return v;
                break;
                case "normal":
                    var v = [];
                    v[0] = 0;
                    for (var row = 1; row <= m; row++) {
                        var crt_z = tile.grid[row][0].z;
                        var prv_z = tile.grid[row-1][0].z;
                        v[row] = v[row-1] + (Math.abs(prv_z - crt_z)/height);
                    }
                    v.reverse();
                    return v;
                break;
                default: return null;
            }
        };
    };

    /**
     * RANDO.TileContainer.translate() : translate the Tiles data of the offsets attribute or of
     * the offsets given in parameters
     */
    RANDO.TileContainer.prototype.translate = function (dx, dy, dz) {
        var tiles = this._tiles;
        var offsets = {};
        var col, row;

        if (typeof(dx) === "undefined"){
            offsets.x = this._offsets.x;
        }else {
            offsets.x = dx;
        }

        if (typeof(dy) === "undefined"){
            offsets.y = this._offsets.y;
        }else {
            offsets.y = dy;
        }

        if (typeof(dz) === "undefined"){
            offsets.z = this._offsets.z;
        }else {
            offsets.z = dz;
        }

        // Translates the tiles positions of the offsets
        for (var it in tiles) {
            var grid = tiles[it].grid;
            for (row in grid) {
                for (col in grid[row]) {
                    grid[row][col].x += offsets.x;
                    grid[row][col].z += offsets.z;
                }
            }
        }
    };

    /**
     * RANDO.TileContainer.getFrame() : get the frame of the DEM composed by 4 lines
     *  east, west, north, and south.
     */
    RANDO.TileContainer.prototype.getFrame = function () {
        var frame = {};
        frame.east  = [];
        frame.west  = [];
        frame.north = [];
        frame.south = [];
        var tiles = this._tiles;
        var col, row;

        var extent = this.getExtentInTilesCoordinates();

        for (var it in tiles) {
            var tile = tiles[it];
            if ( tile.coordinates.x == extent.x.max ) {
                var last_col = tile.grid[0].length -1;
                for (row in tile.grid) {
                    frame.east.push(tile.grid[row][last_col]);
                }
            }
            if ( tile.coordinates.x == extent.x.min ) {
                var first_col = 0;
                for (row in tile.grid) {
                    frame.west.push(tile.grid[row][first_col]);
                }
            }
            if ( tile.coordinates.y == extent.y.min ) {
                var last_row = tile.grid.length-1;
                for (col in tile.grid[last_row]){
                    frame.south.push(tile.grid[last_row][col]);
                }
            }
            if ( tile.coordinates.y == extent.y.max ) {
                var first_row = 0;
                for (col in tile.grid[first_row]){
                    frame.north.push(tile.grid[first_row][col]);
                }
            }
        }

        return frame;
    };

    /**
     * RANDO.TileContainer.getExtentInTilesCoordinates() : get the x and y extent in tile's
     * coordinates
     */
    RANDO.TileContainer.prototype.getExtentInTilesCoordinates = function () {
        var tileExtent = {};
        tileExtent.x = {};
        tileExtent.y = {};
        var tiles = this._tiles;

        // X extent
        tileExtent.x.min = _.min(tiles, function (tile) {
            return tile.coordinates.x;
        }).coordinates.x;

        tileExtent.x.max = _.max(tiles, function (tile) {
            return tile.coordinates.x;
        }).coordinates.x;

        // Y extent
        tileExtent.y.min = _.min(tiles, function (tile) {
            return tile.coordinates.y;
        }).coordinates.y;
        tileExtent.y.max = _.max(tiles, function (tile) {
            return tile.coordinates.y;
        }).coordinates.y;

        return tileExtent;
    };
};
},{}],13:[function(require,module,exports){
/*******************************************************************************
 * Rando.Trek.js
 *
 * Trek class :
 *  Permites the build of a Trek in 3D
 *
 * @author: CÃ©lian GARCIA
 ******************************************************************************/

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    /* Constructor */
    RANDO.Trek = function (data, offsets, scene) {
        this._vertices = this._prepareVertices(data, offsets);
        this._scene = scene;

        this.spheres     = null;
        this.cylinders   = null;
        this.material    = null;
        this.mergedTreks = [];

        this.init();
    };

    /* Methods */
    RANDO.Trek.prototype.init = function () {
        this.material = new BABYLON.StandardMaterial("Trek Material", this._scene)
        this.material.diffuseColor = RANDO.SETTINGS.TREK_COLOR;
        this.material.emissiveColor = RANDO.SETTINGS.TREK_COLOR;

        this.buildTrek ();
    };

    /**
     * RANDO.Trek._prepareVertices() : translate the Trek data of the offsets attribute
     *
     * return the array of vertices
     */
    RANDO.Trek.prototype._prepareVertices = function (data, offsets) {
        var vertices = _.map(data, _.clone);

        for (var it in vertices){
            vertices[it].x += offsets.x;
            vertices[it].y = 0;
            vertices[it].z += offsets.z;
        }
        return vertices;
    };

    /**
     * RANDO.Trek.buildTrek() : builds the trek with spheres and cylinders
     */
    RANDO.Trek.prototype.buildTrek = function () {
        // Trek building ...
        console.log("Trek building... " + (Date.now() - RANDO.START_TIME) );
        var vertices    = this._vertices;
        var scene       = this._scene;
        var material    = this.material;
        var spheres     = new BABYLON.Mesh("TREK - Spheres", scene);
        var cylinders   = new BABYLON.Mesh("TREK - Cylinders", scene);
        var n_sph = 0, n_cyl = 0;

        function createSphere(vertex) {
            n_sph++;
            var sphere = BABYLON.Mesh.CreateSphere(
                "Sphere " + n_sph,
                RANDO.SETTINGS.TREK_SPH_TESSEL,
                RANDO.SETTINGS.TREK_WIDTH,
                scene
            );

            sphere.position  = vertex;
            sphere.material  = material;
            sphere.parent    = spheres;
            sphere.isVisible = false;
        };

        function createCylinder(vertexA, vertexB) {
            n_cyl++;
            var cyl_height = BABYLON.Vector3.Distance(vertexA, vertexB);
            var cylinder = BABYLON.Mesh.CreateCylinder(
                "Cylinder " + n_cyl,
                1,
                RANDO.SETTINGS.TREK_WIDTH,
                RANDO.SETTINGS.TREK_WIDTH,
                RANDO.SETTINGS.TREK_CYL_TESSEL,
                scene
            );

            cylinder.material   = material;
            cylinder.parent     = cylinders;
            cylinder.isVisible  = false;
        };

        var prev, curr = null;
        for (var it in vertices){
            prev = curr;
            var curr = new BABYLON.Vector3(
                vertices[it].x,
                vertices[it].y,
                vertices[it].z
            );

            createSphere(curr);
            if (prev) {
                createCylinder(prev, curr);
            }
        }

        // Trek built !
        console.log("Trek built ! " + (Date.now() - RANDO.START_TIME) );

        this.spheres = spheres;
        this.cylinders = cylinders;
    };

    /**
     * RANDO.Trek.drape() : drape the trek over the ground
     *      - ground : Mesh in which we drape spheres
     *      - onComplete : callback called at the end of the RANDO.Trek.prototype.
     */
    RANDO.Trek.prototype.drape = function (ground, onComplete) {
        var spheres     = this.spheres.getChildren();
        var cylinders   = this.cylinders.getChildren();
        var trek_length = spheres.length;
        var index       = 0;
        var chunk       = 100; // By chunks of 100 points
        var that        = this;

        console.log("Trek adjustments ... " + (Date.now() - RANDO.START_TIME) );
        drapeChunk();

        // Step 1 : drape the spheres over the ground
        function drapeChunk () {
            var cnt = chunk;
            while (cnt-- && index < trek_length) {
                RANDO.Utils.drapePoint(spheres[index].position, ground, RANDO.SETTINGS.TREK_OFFSET);
                ++index;
            }
            if (index < trek_length){
                setTimeout(drapeChunk, 1);
            }else {
                // At the end of draping we place cylinders
                setTimeout(placeCylinders, 1);
            }
        };

        // Step 2 : Place all cylinders between each pairs of spheres
        function placeCylinders () {
            for (var i = 0; i < trek_length-1; i++) {
                RANDO.Utils.placeCylinder(
                    cylinders[i],
                    spheres[i].position,
                    spheres[i+1].position
                );
            }

            onComplete();
            console.log("Trek adjusted ! " + (Date.now() - RANDO.START_TIME) );
        };
    };

    /**
     * RANDO.Trek.merge() : merge all elements (spheres and cylinders) of the Trek
     */
    RANDO.Trek.prototype.merge = function () {
        console.log("Trek merging ... " + (Date.now() - RANDO.START_TIME) );
        var scene       = this._scene;
        var spheres     = this.spheres.getChildren();
        var cylinders   = this.cylinders.getChildren();
        var meshes      = spheres.concat(cylinders);
        var limit       = RANDO.SETTINGS.LIMIT_VERT_BY_MESH;

        var count = 0;
        var nMergedTrek = 0;
        var buffer = [];
        for (var i = 0; i < meshes.length; i++) {
            count += meshes[i].getTotalVertices();
            // The number of vertices in the buffer is acceptable
            if (count < limit) {
                meshes[i].isVisible = false;
                buffer.push(meshes[i]);
            }
            // The number of vertices in the buffer will not be acceptable
            else {
                //... so we merge all meshes of buffer
                var mergedTrek = new BABYLON.Mesh(
                    "Merged Trek " + nMergedTrek++, scene
                );
                RANDO.Utils.mergeMeshes(mergedTrek, buffer);
                mergedTrek.material = this.material;
                this.mergedTreks.push(mergedTrek);
                // ... and we push the current mesh in a new empty buffer
                buffer = [];
                buffer.push(meshes[i]);
                count = meshes[i].getTotalVertices();
            }
        }

        // If the count never reached the limit
        if (buffer.length != 0) {
            var mergedTrek = new BABYLON.Mesh(
                "Merged Trek " + nMergedTrek++, scene
            );
            RANDO.Utils.mergeMeshes(mergedTrek, buffer);
            mergedTrek.material = this.material;

            this.mergedTreks.push(mergedTrek);
        }
        console.log("Trek merged ! " + (Date.now() - RANDO.START_TIME) );
    };

    /**
     * RANDO.Trek.updateVertices() : update this._vertices attribute
     */
    RANDO.Trek.prototype.updateVertices = function () {
        var vertices    = this._vertices;
        var spheres     = this.spheres.getChildren();
        console.assert(vertices.length == spheres.length);
        for (var it in spheres) {
            vertices[it].x = spheres[it].position.x;
            vertices[it].y = spheres[it].position.y;
            vertices[it].z = spheres[it].position.z;
        }
    };

    /**
     * RANDO.Trek.getTotalVertices() : get the total number of vertices in the trek.
     */
    RANDO.Trek.prototype.getTotalVertices = function () {
        var spheresArray    = this.spheres.getChildren();
        var cylindersArray  = this.cylinders.getChildren();
        var meshes          = spheresArray.concat(cylindersArray);

        var totalVertices = 0;
        for (var it in meshes) {
            totalVertices += meshes[it].getTotalVertices();
        }

        return totalVertices;
    };
};
},{}],14:[function(require,module,exports){
// Rando.Utils.js
// Rando utilities

module.exports = function(RANDO, BABYLON) {
    'use strict';

    var RANDO = RANDO || {};

    RANDO.Utils = {};

    /****    BABYLON extents     ************************/
    /**
     *  createGroundFromExtent(): Create a ground from an extent of 4 points
     *      - name : Name of the new Ground
     *      - A : northwest vertex
     *      - B : northeast vertex
     *      - C : southeast vertex
     *      - D : southwest vertex
     *      - w_subdivisions : Number of Width's subdivisions in the new Ground
     *      - h_subdivisions : Number of Height's subdivisions in the new Ground
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromExtent = function (name, A, B, C, D, w_subdivisions, h_subdivisions, scene, updatable) {
        var ground = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var grid = RANDO.Utils.createFlatGrid(A, B, C, D, w_subdivisions+ 1, h_subdivisions+ 1);
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var position = grid[row][col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(position.x, 0, position.y);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createGroundFromGrid(): Create a ground from a grid of 2D points
     *      - name : Name of the new Ground
     *      - grid : grid of 2d points (each point contains a x and a y)
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromGrid = function (name, grid, scene, updatable) {
        var ground = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var h_subdivisions = grid.length-1;
        var w_subdivisions = grid[0].length-1;

        for (row = 0; row <= h_subdivisions; row++) {
            w_subdivisions = grid[row].length-1;
            for (col = 0; col <= w_subdivisions; col++) {
                var position = grid[h_subdivisions - row][col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(position.x, position.y, position.z);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            w_subdivisions = grid[row].length-1;
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createGroundFromVertices(): Create a ground from an array of vertices
     *      - name : Name of the new Ground
     *      - vertices : Array of vertices in BABYLON.VertexBuffer.PositionKind format
     *      - w_subdivisions : Number of Width's subdivisions in the new Ground
     *      - h_subdivisions : Number of Height's subdivisions in the new Ground
     *      - scene : Scene which contains the new Ground
     *      - updatable :
     *
     ****************************************************************/
    RANDO.Utils.createGroundFromVertices = function( name, vertices, w_subdivisions, h_subdivisions, scene, updatable) {
        console.assert(vertices.length%3 == 0);
        console.assert((vertices.length/3) == w_subdivisions*h_subdivisions,
        (vertices.length/3) + "!=" + w_subdivisions + "*" + h_subdivisions);

        var ground = BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var i = 0;
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                positions.push(vertices[i], vertices[i+1], vertices[i+2]);
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row / h_subdivisions);
                i+=3;
            }
        }

        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        ground.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        ground.setIndices(indices);

        return ground;
    };

    /**
     *  createSideFromLine(): Create a side of the DEM from a line of points (top line)
     *      - name : Name of the new Ground
     *      - line : Array of points [{x: ,y: ,z: }, ...]
     *      - base : Altitude of the base line
     *      - scene : Scene which contains the new side
     *      - updatable :
     *
     */
    RANDO.Utils.createSideFromLine = function (name, line, base, scene, updatable) {
        var side = new BABYLON.GroundMesh(name, scene);

        var indices = [];
        var positions = [];
        var normals = [];
        var uvs = [];
        var row, col;

        var h_subdivisions = 1
        var w_subdivisions = line.length-1;

        // Positions, normals, and uvs
        for (row = 0; row <= h_subdivisions; row++) {
            for (col = 0; col <= w_subdivisions; col++) {
                var position = line[col];
                var normal = new BABYLON.Vector3(0, 1.0, 0);

                if (row == 0) {
                    positions.push(position.x, position.y, position.z);
                } else {
                    positions.push(position.x, base, position.z);
                }

                normals.push(normal.x, normal.y, normal.z);
                uvs.push(col / w_subdivisions, 1.0 - row/1);
            }
        }

        // Indices
        for (row = 0; row < h_subdivisions; row++) {
            for (col = 0; col < w_subdivisions; col++) {
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + row * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));

                indices.push(col + (row + 1) * (w_subdivisions + 1));
                indices.push(col + 1 + (row + 1) * (w_subdivisions + 1));
                indices.push(col + row * (w_subdivisions + 1));
            }
        }

        side.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);
        side.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);
        side.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);
        side.setIndices(indices);

        return side;
    }

    /**
     *  placeCylinder()
     *      - cylinder (BABYLON.Mesh): BABYLON Cylinder object
     *      - A (BABYLON.Vector3):     First Point
     *      - B (BABYLON.Vector3):     Second Point
     *
     * Place the cylinder between both points
     ****************************************************************/
    RANDO.Utils.placeCylinder = function (cylinder, A, B) {
        // Initial position at the center of the AB vector
        cylinder.position = new BABYLON.Vector3(
            (A.x+B.x)/2,
            (A.y+B.y)/2,
            (A.z+B.z)/2
        );

        // Adjust scale of cylinder
        var new_height = BABYLON.Vector3.Distance(A, B);
        cylinder.scaling.y = new_height;

        // First rotation
        var angle1 = RANDO.Utils.angleFromAxis(A, B, BABYLON.Axis.X);
        cylinder.rotate(
            BABYLON.Axis.X,
            angle1,
            BABYLON.Space.LOCAL
        );

        // Second rotation
        var H = new BABYLON.Vector3(A.x,B.y,B.z);
        var angle2 = RANDO.Utils.angleFromPoints(A, B, H);
        cylinder.rotate(
            BABYLON.Axis.Z,
            angle2,
            BABYLON.Space.LOCAL
        );

        return cylinder;
    };

    /**
     * ComputeMeshNormals() : recompute normals of a mesh (for the shadows after)
     *      - mesh: mesh to recompute
     */
    RANDO.Utils.computeMeshNormals = function (mesh) {
        var vertices = BABYLON.VertexData.ExtractFromMesh (mesh);
        BABYLON.VertexData.ComputeNormals(vertices.positions, vertices.indices, vertices.normals);
        vertices.applyToMesh(mesh);
    };

    /**
     * setMeshUvs() : set the mesh uvs taking from the object uv taken in parameter
     *      mesh: babylon mesh
     *      uvs: object js containing uvs values
     *
     * NB: format of uv object parameter :
     *      uv = {
     *          u: [],
     *          v: []
     *      }
     */
    RANDO.Utils.setMeshUvs = function (mesh, uv) {
        var uv_array = [];
        var col, row;
        for (row in uv.v) {
            for (col in uv.u) {
                uv_array.push(uv.u[col]);
                uv_array.push(uv.v[row]);
            }
        }

        console.assert(
            mesh.getVerticesData(BABYLON.VertexBuffer.UVKind).length == uv_array.length,
            "setMeshUvs() : uvs in parameter are not well sized"
        );

        mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uv_array);
    };

    /**
     * RANDO.Utils.mergeMeshes() : Merge a mesh array in only one mesh. It permites
     * to increase performance.
     *      - newMesh : future merged Mesh
     *      - arrayObj : array of Meshes to merge
     *
     * Function directly inspired from David Catuhe's one in the github wiki of BabylonJS
     * https://github.com/BabylonJS/Babylon.js/wiki/How-to-merge-meshes
     */
    RANDO.Utils.mergeMeshes = function (newMesh, arrayObj) {
        var arrayPos = [];
        var arrayNormal = [];
        var arrayUv = [];
        var arrayUv2 = [];
        var arrayColor = [];
        var arrayMatricesIndices = [];
        var arrayMatricesWeights = [];
        var arrayIndice = [];
        var savedPosition = [];
        var savedNormal = [];
        var UVKind = true;
        var UV2Kind = true;
        var ColorKind = true;
        var MatricesIndicesKind = true;
        var MatricesWeightsKind = true;
        var i = 0, it;

        for (i = 0; i != arrayObj.length ; i++) {
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.UVKind]))
                UVKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.UV2Kind]))
                UV2Kind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.ColorKind]))
                ColorKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.MatricesIndicesKind]))
                MatricesIndicesKind = false;
            if (!arrayObj[i].isVerticesDataPresent([BABYLON.VertexBuffer.MatricesWeightsKind]))
                MatricesWeightsKind = false;
        }

        for (i = 0; i != arrayObj.length ; i++) {
            var ite = 0;
            var iter = 0;
            arrayPos[i] = arrayObj[i].getVerticesData(BABYLON.VertexBuffer.PositionKind);
            arrayNormal[i] = arrayObj[i].getVerticesData(BABYLON.VertexBuffer.NormalKind);
            if (UVKind)
                arrayUv = arrayUv.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.UVKind));
            if (UV2Kind)
                arrayUv2 = arrayUv2.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.UV2Kind));
            if (ColorKind)
                arrayColor = arrayColor.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.ColorKind));
            if (MatricesIndicesKind)
                arrayMatricesIndices = arrayMatricesIndices.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind));
            if (MatricesWeightsKind)
                arrayMatricesWeights = arrayMatricesWeights.concat(arrayObj[i].getVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind));

            var maxValue = savedPosition.length / 3;

            arrayObj[i].computeWorldMatrix(true);
            var worldMatrix = arrayObj[i].getWorldMatrix();

            while (ite < arrayPos[i].length) {
                var vertex = new BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(arrayPos[i][ite], arrayPos[i][ite + 1], arrayPos[i][ite + 2]), worldMatrix);
                savedPosition.push(vertex.x);
                savedPosition.push(vertex.y);
                savedPosition.push(vertex.z);
                ite = ite + 3;
            }
            while (iter < arrayNormal[i].length) {
                var vertex = new BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(arrayNormal[i][iter], arrayNormal[i][iter + 1], arrayNormal[i][iter + 2]), worldMatrix);
                savedNormal.push(vertex.x);
                savedNormal.push(vertex.y);
                savedNormal.push(vertex.z);
                iter = iter + 3;
            }
            if (i > 0) {
                var tmp = arrayObj[i].getIndices();
                for (it = 0 ; it != tmp.length; it++) {
                    tmp[it] = tmp[it] + maxValue;
                }
                arrayIndice = arrayIndice.concat(tmp);
            }
            else {
                arrayIndice = arrayObj[i].getIndices();
            }

            arrayObj[i].dispose(false);
        }

        newMesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, savedPosition, false);
        newMesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, savedNormal, false);
        if (arrayUv.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, arrayUv, false);
        if (arrayUv2.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.UV2Kind, arrayUv2, false);
        if (arrayColor.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.ColorKind, arrayColor, false);
        if (arrayMatricesIndices.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, arrayMatricesIndices, false);
        if (arrayMatricesWeights.length > 0)
            newMesh.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, arrayMatricesWeights, false);

        newMesh.setIndices(arrayIndice);
    };

    /**
     * RANDO.Utils.getSize () : get the size of a mesh
     *      - mesh : mesh
     *
     * return an object containing the width, height and deep of the mesh
     */
    RANDO.Utils.getSize = function (mesh) {
        var minmax = BABYLON.Mesh.MinMax([mesh]);

        return {
            'width'  : (minmax.max.x - minmax.min.x) ,
            'height' : (minmax.max.y - minmax.min.y) ,
            'deep'   : (minmax.max.z - minmax.min.z)
        };
    }

    /**
     * RANDO.Utils.isInExtent() :
     *  return true if the given coordinates are in the given extent
     */
    RANDO.Utils.isInExtent = function (coordinates, extent) {
        return (
            coordinates.x >= extent.x.min &&
            coordinates.x <= extent.x.max &&
            coordinates.z >= extent.z.min &&
            coordinates.z <= extent.z.max
         )? true: false;
    };

    /**
     * RANDO.Utils.getNumberOfTiles() : return the number of tiles according a zoom level and
     * a meters extent.
     */
    RANDO.Utils.getNumberOfTiles = function (zoom, extent) {
        var xTileMin = RANDO.Utils.meters2num (extent.x.min, extent.z.min, zoom).xtile;
        var xTileMax = RANDO.Utils.meters2num (extent.x.max, extent.z.max, zoom).xtile;
        var yTileMin = RANDO.Utils.meters2num (extent.x.min, extent.z.min, zoom).ytile;
        var yTileMax = RANDO.Utils.meters2num (extent.x.max, extent.z.max, zoom).ytile;
        return (xTileMax - xTileMin + 1) * (yTileMin - yTileMax + 1);
    };

    /****    GEOMETRY     ************************/
    /**tested
     * middle():
     *      A: first point
     *      B: second point
     *
     * return the middle of the segment form by A and B
     */
    RANDO.Utils.middle = function (A, B) {
        return {
            x: (A.x+B.x)/2,
            y: (A.y+B.y)/2,
            z: (A.z+B.z)/2
        };
    };

    /**tested
     * subdivide() :  interpolate a segment between 2 points A and B
     *      - n : number of points expected in result
     *      - A : first point
     *      - B : second point
     *
     * return an array of point
     *
     * NB : points are in the format : { x : .. , y : .. }
     *
     *
     * example :
     *
     *         * B                   * B
     *        /                     /
     *       /      n = 4          * M2
     *      /      ---->          /
     *     /                     * M1
     *    /                     /
     * A *                    A*
     *
     *          result : [A, M1, M2, B]
     *
     */
    RANDO.Utils.subdivide = function (n, A, B) {

        if (n<=0) return null;

        if (n==1) return A;

        if (n==2) return [A,B];

        if (n>=3) {
            var dx = (B.x-A.x)/(n-1);
            var dy = (B.y-A.y)/(n-1);

            var x = A.x;
            var y = A.y;

            var res = [];
            res.push(A);
            for (var i=0; i<n-2; i++){
                x += dx;
                y += dy;
                res.push({
                    'x' : x,
                    'y' : y
                });
            }
            res.push(B);
            return res;
        }
    }

    /**tested
     * createGrid() : create a grid of points for all type of quadrilateres, in particular
     *  these which are not square or rectangle.
     *      - A, B, C, D :  vertices of quadrilatere to subdivide
     *      - n_verti :     number of points in vertical size
     *      - n_horiz :     number of points in horizontal size
     *
     *
     * NB : * n_verti and n_horiz cannot be invert
     *      * the order of input points is also important, it determines
     * the order of output points :
     *  [A, ...., B,    -> first line
     *   ..........,
     *   D, ...., C]    -> last line
     *
     *
     * Example of quadrilatere :
     * D *------------------* C
     *   |                   \
     *   |                    \
     *   |                     \
     *   |                      \
     *   |                       \
     *   |                        \
     * A *-------------------------* B
     *
     */
    RANDO.Utils.createFlatGrid = function (A, B, C, D, n_horiz, n_verti) {
        if(n_verti<=0) return null;
        if(n_horiz<=0) return null;

        // subdivide both sides of the quad
        var west_side = RANDO.Utils.subdivide(n_verti, A, D);
        var east_side = RANDO.Utils.subdivide(n_verti, B, C);
        var grid = [];
        console.assert(west_side.length == east_side.length,
            "createGrid : west_side.length != east_side.length \n" +
            west_side.length +
            " != " +
            east_side.length
        );


        for (var j=0; j < n_verti; j++){
            // subidivide lines
            var line = RANDO.Utils.subdivide(n_horiz, west_side[j], east_side[j]);
            grid.push(line);
        }
        return grid;
    }

    /**
     *
     *
     */
    RANDO.Utils.createElevationGrid = function (xmin, xmax, ymin, ymax, altitudes) {
        var A = {
            'x' : xmin,
            'y' : ymin
        };
        var B = {
            'x' : xmax,
            'y' : ymin
        };
        var C = {
            'x' : xmax,
            'y' : ymax
        };
        var D = {
            'x' : xmin,
            'y' : ymax
        };
        var row, col;

        // Creates grid from extent datas
        var grid = RANDO.Utils.createFlatGrid(
            A, B, C, D,
            altitudes[0].length,
            altitudes.length
        );

        // Gives altitudes to the grid
        for (row in altitudes){
            for (col in altitudes[row]){
                grid[row][col].z = grid[row][col].y;
                grid[row][col].y = altitudes[row][col];
            }
        }
        return grid;
    };

    /**tested
     * angleFromAxis(): get an angle for a rotation
     *      - A     (BABYLON.Vector3) : First point
     *      - B     (BABYLON.Vector3) : Second point
     *      - axis  (BABYLON.Vector3) : Axis of rotation
     *
     *
     * Example with a rotation around y axis
     *
     *                     _ z
     *       .->           |
     *      /              |     * B
     *                     |    /
     *                     |   /
     *                     |  /
     *                     | /
     *                     |/               x
     *       --------------*--------------->
     *                     |A
     *                     |
     *
     * NB : It uses global axis only
     *  (1, 0, 0), (0, 1, 0), or (0, 0, 1)
     *
     */
    RANDO.Utils.angleFromAxis = function (A, B, axis) {
        var angle, AH, AB;
        switch (axis){
            case BABYLON.Axis.X :
                if(A.y == B.y && A.z == B.z) // It don't need rotation around X
                    return 0;
                AH = B.y-A.y;
                AB = Math.sqrt(
                    Math.pow(B.y-A.y, 2)+
                    Math.pow(B.z-A.z, 2)
                );
                angle = Math.acos(AH/AB);
                if (B.z < A.z)
                    return -angle;
                return angle;
            break;
            case BABYLON.Axis.Y :
                if(A.x == B.x && A.z == B.z) // It don't need rotation around Y
                    return 0;
                AH = B.z-A.z;
                AB = Math.sqrt(
                    Math.pow(B.z-A.z, 2)+
                    Math.pow(B.x-A.x, 2)
                );

                angle = Math.acos(AH/AB);
                //if (angle > Math.PI/2)
                    //angle = -((Math.PI/2)-angle)
                if (B.x < A.x)
                    return -angle;
                return angle;
            break;
            case BABYLON.Axis.Z :
                if(A.x == B.x && A.y == B.y) // It don't need rotation around Z
                        return 0;
                AH = B.x-A.x;
                AB = Math.sqrt(
                    Math.pow(B.x-A.x, 2)+
                    Math.pow(B.y-A.y, 2)
                );
                angle = Math.acos(AH/AB);
                if (B.y < A.y)
                    return -angle;
                return angle;
        }
        return null;
    }

    /**
     * angleFromPoints() : get an angle from 3 points for a rotation around an axis
     *  orthogonal of the plan formed by the 3 points
     *      - A (BABYLON.Vector3) : First point
     *      - B (BABYLON.Vector3) : Second point
     *      - H (BABYLON.Vector3) : Orthogonal projection of B over the axis
     *
     *
     * Example with a rotation around z axis
     *
     *                     _ x
     *       .->           |
     *      /            H *     * B
     *                     |    /
     *                     |   /
     *                     |  /
     *                     | /
     *                     |/               y
     *       --------------*--------------->
     *                     |A
     *                     |
     *
     * NB : It is used when we don't have especially classical global axis. For example
     * after a first rotation.
     *
     */
    RANDO.Utils.angleFromPoints = function (A, B, H) {
        var AH = BABYLON.Vector3.Distance(A, H);
        var AB = BABYLON.Vector3.Distance(A, B);
        var angle = Math.acos(AH/AB);

        // Check the sign
        if (H.x < B.x)
            return -angle;
        return angle;
    };

    RANDO.Utils.roundRect = function (context, x, y, w, h, radius) {
        var r = x + w;
        var b = y + h;
        context.beginPath();
        context.lineWidth="4";
        context.moveTo(x+radius, y);
        context.lineTo(r-radius, y);
        context.quadraticCurveTo(r, y, r, y+radius);
        context.lineTo(r, y+h-radius);
        context.quadraticCurveTo(r, b, r-radius, b);
        context.lineTo(x+radius, b);
        context.quadraticCurveTo(x, b, x, b-radius);
        context.lineTo(x, y+radius);
        context.quadraticCurveTo(x, y, x+radius, y);
        context.stroke();
        context.fill()
    };

    /**tested
     *  scaleArray2() : multiply all values of 2-dimensions array by a scale value
     *      - array2 : original array
     *      - scale : scale value
     *
     * return a new array which contains all values of array2 multiplied
     */
    RANDO.Utils.scaleArray2 = function (array2, scale) {
        var result = [];
        for (var row in array2) {
            var line = [];
            for (var col in array2[row]) {
                line.push(array2[row][col] * scale);
            }
            result.push(line);
        }
        return result;
    };


    /****    GETTERS     ************************/
    /**tested
     * getUrlFromCoordinates(): get the url of a tile texture
     *      z : level of zoom
     *      x : x coordinates of tile
     *      y : y coordinates of tile
     *
     */
    RANDO.Utils.replaceUrlCoordinates = function (url, z, x, y) {
        var subdomains = RANDO.SETTINGS.TILE_TEX_URL_SUBDOMAINS,
            index = Math.abs(x + y) % subdomains.length,
            subdomain = subdomains[index];

        url = url.replace("{s}", subdomain);
        url = url.replace("{z}", z);
        url = url.replace("{x}", x);
        url = url.replace("{y}", y);

        return url;
    }


    /****    CONVERSIONS     ************************/
    /**tested
     * toMeters() : convert a point in latitude/longitude to x/y meters coordinates
     *      - latlng : point in lat/lng
     *
     * return a point in meters
     *
     * { lat : .. , lng : .. }  ---> { x : .. , y : .. }
     */
    RANDO.Utils.toMeters = function (latlng) {

        var R = 6378137;

        var d = Math.PI / 180;
        var max = 1 - 1*Math.pow(10, -15);
        var sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);

        return {
            x : R * latlng.lng * d,
            y : R * Math.log((1 + sin) / (1 - sin)) / 2
        };
    };

    /**tested
     * toLatlng() : convert a point in x/y meters coordinates to latitude/longitude
     *      - point : point in x/y meters coordinates
     *
     * return a point in lat/long
     *
     * { x : .. , y : .. }  --->  { lat : .. , lng : .. }
     */
    RANDO.Utils.toLatlng = function (point) {

        var R = 6378137;

        var d = 180 / Math.PI;

        return {
            lat: (2 * Math.atan(Math.exp(point.y / R)) - (Math.PI / 2)) * d,
            lng: point.x * d / R
        };
    }

    /**
     * getMetersExtent() : get the extent of the DEM in meters
     *      - extent : extent of the DEM in latitudes/longitudes
     */
    RANDO.Utils.getMetersExtent = function (extent) {
        var nw = RANDO.Utils.toMeters(extent.northwest);
        var ne = RANDO.Utils.toMeters(extent.northeast);
        var sw = RANDO.Utils.toMeters(extent.southwest);
        var se = RANDO.Utils.toMeters(extent.southeast);

        return {
            'x' : {
                'min' : Math.min(nw.x, sw.x),
                'max' : Math.min(ne.x, se.x)
            },
            'y' : extent.altitudes,
            'z' : {
                'min' : Math.min(sw.y, se.y),
                'max' : Math.min(nw.y, ne.y)
            },
        }
    };

    /**
     * meters2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - x: x coordinate of point (in meters)
     *      - y: y coordinate of point (in meters)
     *      - zoom: zoom level
     */
    RANDO.Utils.meters2num = function (x, y, zoom) {
        var tmp_ll = RANDO.Utils.toLatlng({
            'x': x,
            'y': y
        });
        return RANDO.Utils.deg2num(tmp_ll.lat, tmp_ll.lng, zoom);
    };

    /**
     * deg2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - lat_deg: latitude  coordinate of point (in degrees)
     *      - lng_deg: longitude coordinate of point (in degrees)
     *      - zoom: zoom level
     */
    RANDO.Utils.deg2num = function (lat_deg, lng_deg, zoom) {
        var lat_rad = lat_deg*Math.PI/180;
        var n = Math.pow(2.0, zoom);
        var xtile = Math.floor((lng_deg + 180.0) / 360.0 * n);
        var ytile = Math.floor((1.0 - Math.log(Math.tan(lat_rad) + (1 / Math.cos(lat_rad))) / Math.PI) / 2.0 * n);
        return {
            "xtile": xtile,
            "ytile": ytile
        };
    };

    /**
     * rad2num(): get the tile number of the tile containing a point
     *  in a certain level of zoom
     *      - lat_rad: latitude  coordinate of point (in radians)
     *      - lng_rad: longitude coordinate of point (in radians)
     *      - zoom: zoom level
     */
    RANDO.Utils.rad2num = function (lat_rad, lng_rad, zoom) {
        var lat_deg = lat_rad*180/Math.PI;
        var lng_deg = lng_rad*180/Math.PI;
        var n = Math.pow(2.0, zoom);
        var xtile = Math.floor((lng_deg + 180.0) / 360.0 * n);
        var ytile = Math.floor((1.0 - Math.log(Math.tan(lat_rad) + (1 / Math.cos(lat_rad))) / Math.PI) / 2.0 * n);
        return {
            "xtile": xtile,
            "ytile": ytile
        };
    };


    /****    TRANSLATIONS     ************************/
    /**
     * drapePoint() : drape a point over the ground
     *      - point: point to drape
     *      - dem: ground
     */
    RANDO.Utils.drapePoint = function (point, dem, offset) {
        var it;
        if (typeof(offset) === "undefined") {
            var offset = 0;
        }
        var children = dem.getChildren();
        var ray =  new BABYLON.Ray(point, BABYLON.Axis.Y);
        for (it in children) {
            var pick = children[it].intersects(ray, true);
            if (pick.pickedPoint) {
                point.y = pick.pickedPoint.y + offset;
            }
        }
    }

};

},{}],"BezierPlugin":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 1.3.4
 * DATE: 2014-11-15
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = a[j+1].da / _r2[j] + a[j].da / _r1[j];
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.4",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._round = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._round[p]) {
								val = Math.round(val);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._roundProps = function(lookup, value) {
			var op = this._overwriteProps,
				i = op.length;
			while (--i > -1) {
				if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
					this._round[op[i]] = value;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("../TweenLite.js");
		module.exports = getGlobal();
	}
}("BezierPlugin"));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../TweenLite.js":"TweenLite"}],"DirectionalRotationPlugin":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 0.2.1
 * DATE: 2014-07-17
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.2.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					split = (value[p] + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"EasePack":[function(require,module,exports){
(function (global){
/*!
 * VERSION: beta 1.15.2
 * DATE: 2015-01-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true), 
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;
			
		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);
		
		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();	
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");
		
		return Back;
		
	}, true);

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"TimelineLite":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.1
 * DATE: 2015-03-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_blankArray = [],
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_pauseCallback = _internals.pauseCallback = function(tween, callback, params, scope) {
				var tl = tween._timeline,
					time = tl._totalTime,
					startTime = tween._startTime,
					reversed = (tween._rawPrevTime < 0 || (tween._rawPrevTime === 0 && tl._reversed)),//don't use tween.ratio because if the playhead lands exactly on top of the addPause(), ratio will be 1 even if the master timeline was reversed (which is correct). The key here is to sense the direction of the playhead.
					next = reversed ? 0 : _tinyNum,
					prev = reversed ? _tinyNum : 0,
					sibling;
				if (callback || !this._forcingPlayhead) { //if the user calls a method that moves the playhead (like progress() or time()), it should honor that and skip any pauses (although if there's a callback positioned at that pause, it must jump there and make the call to ensure the time is EXACTLY what it is supposed to be, and then proceed to where the playhead is being forced). Otherwise, imagine placing a pause in the middle of a timeline and then doing timeline.progress(0.9) - it would get stuck where the pause is.
					tl.pause(startTime);
					//now find sibling tweens that are EXACTLY at the same spot on the timeline and adjust the _rawPrevTime so that they fire (or don't fire) correctly on the next render. This is primarily to accommodate zero-duration tweens/callbacks that are positioned right on top of a pause. For example, tl.to(...).call(...).addPause(...).call(...) - notice that there's a call() on each side of the pause, so when it's running forward it should call the first one and then pause, and then when resumed, call the other. Zero-duration tweens use _rawPrevTime to sense momentum figure out if events were suppressed when arriving directly on top of that time.
					sibling = tween._prev;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = prev;
						sibling = sibling._prev;
					}
					sibling = tween._next;
					while (sibling && sibling._startTime === startTime) {
						sibling._rawPrevTime = next;
						sibling = sibling._next;
					}
					if (callback) {
						callback.apply(scope || tl, params || _blankArray);
					}
					if (this._forcingPlayhead || !tl._paused) { //the callback could have called resume().
						tl.seek(time);
					}
				}
			},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.16.1";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, onCompleteScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				if (vars.startAt) {
					vars.startAt = _copy(vars.startAt);
				}
				tl.to(targets[i], duration, _copy(vars), i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				return this._remove(value, false);
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
				this._time = this.duration();
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this);
			t.data = "isPause"; // we use this flag in TweenLite's render() method to identify it as a special case that shouldn't be triggered when the virtual playhead is LEAVING the exact position where the pause is, otherwise timeline.addPause(1).play(1) would end up paused on the very next tick.
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce;
			if (time >= totalDur) {
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
				this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
			}

			if (this._time >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (this._paused && !prevPaused) { //in case a tween pauses the timeline when rendering
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			if (this.totalDuration() !== 0) if (value !== 0) {
				this.timeScale(this._totalDuration / value);
			}
			return this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function() {
			return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);


}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("./TweenLite.js"); //dependency
		module.exports = getGlobal();
	}
}("TimelineLite"));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./TweenLite.js":"TweenLite"}],"TweenLite":[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.16.1
 * DATE: 2015-03-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
(function(window, moduleName) {

		"use strict";
		var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (ns === moduleName && typeof(module) !== "undefined" && module.exports){ //node
								module.exports = cl;
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame),
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function() {
				if (_id !== null) {
					_self.sleep();
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF && _self.frame < 5) {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					this.render((tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(-this._delay);
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.16.1";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},

			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},

			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				i = this._targets.length;
				while (--i > -1) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null)) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:true, n:p, pg:true, pr:plugin._priority};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}

				} else {
					this._firstPT = propLookup[p] = pt = {_next:this._firstPT, t:target, p:p, f:(typeof(target[p]) === "function"), n:p, pg:false, pr:0};
					pt.s = (!pt.f) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
					pt.c = (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : (Number(v) - pt.s) || 0;
				}
				if (pt) if (pt._next) {
					pt._next._prev = pt;
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration) {
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (time === 0 || prevRawPrevTime < 0 || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete) {
					this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i])) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if (!_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(-this._delay);
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onCompleteScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, onReverseCompleteScope:scope, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.10.1";
		TweenPlugin.API = 2;
		p._firstPT = null;

		p._addTween = function(target, prop, start, end, overwriteProp, round) {
			var c, pt;
			if (end != null && (c = (typeof(end) === "number" || end.charAt(1) !== "=") ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
				this._firstPT = pt = {_next:this._firstPT, t:target, p:prop, s:start, c:c, f:(typeof(target[prop]) === "function"), n:overwriteProp || prop, r:round};
				if (pt._next) {
					pt._next._prev = pt;
				}
				return pt;
			}
		};

		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val;
			while (pt) {
				val = pt.c * v + pt.s;
				if (pt.r) {
					val = Math.round(val);
				} else if (val < min) if (val > -min) { //prevents issues with converting very small numbers to strings in the browser
					val = 0;
				}
				if (pt.f) {
					pt.t[pt.p](val);
				} else {
					pt.t[pt.p] = val;
				}
				pt = pt._next;
			}
		};

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._roundProps = function(lookup, value) {
			var pt = this._firstPT;
			while (pt) {
				if (lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ])) { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					pt.r = value;
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_roundProps", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: com.greensock." + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenLite");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"babylonjs":[function(require,module,exports){
/*! Babylon 2014-08-08 */
var BABYLON;!function(a){var b=function(){function a(a,b,c){"undefined"==typeof a&&(a=0),"undefined"==typeof b&&(b=0),"undefined"==typeof c&&(c=0),this.r=a,this.g=b,this.b=c}return a.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"},a.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.r,a[b+1]=this.g,a[b+2]=this.b},a.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},a.prototype.multiply=function(b){return new a(this.r*b.r,this.g*b.g,this.b*b.b)},a.prototype.multiplyToRef=function(a,b){b.r=this.r*a.r,b.g=this.g*a.g,b.b=this.b*a.b},a.prototype.equals=function(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b},a.prototype.scale=function(b){return new a(this.r*b,this.g*b,this.b*b)},a.prototype.scaleToRef=function(a,b){b.r=this.r*a,b.g=this.g*a,b.b=this.b*a},a.prototype.add=function(b){return new a(this.r+b.r,this.g+b.g,this.b+b.b)},a.prototype.addToRef=function(a,b){b.r=this.r+a.r,b.g=this.g+a.g,b.b=this.b+a.b},a.prototype.subtract=function(b){return new a(this.r-b.r,this.g-b.g,this.b-b.b)},a.prototype.subtractToRef=function(a,b){b.r=this.r-a.r,b.g=this.g-a.g,b.b=this.b-a.b},a.prototype.clone=function(){return new a(this.r,this.g,this.b)},a.prototype.copyFrom=function(a){this.r=a.r,this.g=a.g,this.b=a.b},a.prototype.copyFromFloats=function(a,b,c){this.r=a,this.g=b,this.b=c},a.FromArray=function(b){return new a(b[0],b[1],b[2])},a.FromInts=function(b,c,d){return new a(b/255,c/255,d/255)},a.Lerp=function(b,c,d){var e=b.r+(c.r-b.r)*d,f=b.g+(c.g-b.g)*d,g=b.b+(c.b-b.b)*d;return new a(e,f,g)},a.Red=function(){return new a(1,0,0)},a.Green=function(){return new a(0,1,0)},a.Blue=function(){return new a(0,0,1)},a.Black=function(){return new a(0,0,0)},a.White=function(){return new a(1,1,1)},a.Purple=function(){return new a(.5,0,.5)},a.Magenta=function(){return new a(1,0,1)},a.Yellow=function(){return new a(1,1,0)},a.Gray=function(){return new a(.5,.5,.5)},a}();a.Color3=b;var c=function(){function b(a,b,c,d){this.r=a,this.g=b,this.b=c,this.a=d}return b.prototype.addInPlace=function(a){this.r+=a.r,this.g+=a.g,this.b+=a.b,this.a+=a.a},b.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},b.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.r,a[b+1]=this.g,a[b+2]=this.b,a[b+3]=this.a},b.prototype.add=function(a){return new b(this.r+a.r,this.g+a.g,this.b+a.b,this.a+a.a)},b.prototype.subtract=function(a){return new b(this.r-a.r,this.g-a.g,this.b-a.b,this.a-a.a)},b.prototype.subtractToRef=function(a,b){b.r=this.r-a.r,b.g=this.g-a.g,b.b=this.b-a.b,b.a=this.a-a.a},b.prototype.scale=function(a){return new b(this.r*a,this.g*a,this.b*a,this.a*a)},b.prototype.scaleToRef=function(a,b){b.r=this.r*a,b.g=this.g*a,b.b=this.b*a,b.a=this.a*a},b.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"},b.prototype.clone=function(){return new b(this.r,this.g,this.b,this.a)},b.Lerp=function(c,d,e){var f=new b(0,0,0,0);return a.Color4.LerpToRef(c,d,e,f),f},b.LerpToRef=function(a,b,c,d){d.r=a.r+(b.r-a.r)*c,d.g=a.g+(b.g-a.g)*c,d.b=a.b+(b.b-a.b)*c,d.a=a.a+(b.a-a.a)*c},b.FromArray=function(a,c){return"undefined"==typeof c&&(c=0),new b(a[c],a[c+1],a[c+2],a[c+3])},b.FromInts=function(a,c,d,e){return new b(a/255,c/255,d/255,e/255)},b}();a.Color4=c;var d=function(){function a(a,b){this.x=a,this.y=b}return a.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+"}"},a.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.x,a[b+1]=this.y},a.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},a.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y},a.prototype.add=function(b){return new a(this.x+b.x,this.y+b.y)},a.prototype.subtract=function(b){return new a(this.x-b.x,this.y-b.y)},a.prototype.negate=function(){return new a(-this.x,-this.y)},a.prototype.scaleInPlace=function(a){this.x*=a,this.y*=a},a.prototype.scale=function(b){return new a(this.x*b,this.y*b)},a.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y},a.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},a.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y},a.prototype.normalize=function(){var a=this.length();if(0!==a){var b=1/a;this.x*=b,this.y*=b}},a.prototype.clone=function(){return new a(this.x,this.y)},a.Zero=function(){return new a(0,0)},a.FromArray=function(b,c){return c||(c=0),new a(b[c],b[c+1])},a.CatmullRom=function(b,c,d,e,f){var g=f*f,h=f*g,i=.5*(2*c.x+(-b.x+d.x)*f+(2*b.x-5*c.x+4*d.x-e.x)*g+(-b.x+3*c.x-3*d.x+e.x)*h),j=.5*(2*c.y+(-b.y+d.y)*f+(2*b.y-5*c.y+4*d.y-e.y)*g+(-b.y+3*c.y-3*d.y+e.y)*h);return new a(i,j)},a.Clamp=function(b,c,d){var e=b.x;e=e>d.x?d.x:e,e=e<c.x?c.x:e;var f=b.y;return f=f>d.y?d.y:f,f=f<c.y?c.y:f,new a(e,f)},a.Hermite=function(b,c,d,e,f){var g=f*f,h=f*g,i=2*h-3*g+1,j=-2*h+3*g,k=h-2*g+f,l=h-g,m=b.x*i+d.x*j+c.x*k+e.x*l,n=b.y*i+d.y*j+c.y*k+e.y*l;return new a(m,n)},a.Lerp=function(b,c,d){var e=b.x+(c.x-b.x)*d,f=b.y+(c.y-b.y)*d;return new a(e,f)},a.Dot=function(a,b){return a.x*b.x+a.y*b.y},a.Normalize=function(a){var b=a.clone();return b.normalize(),b},a.Minimize=function(b,c){var d=b.x<c.x?b.x:c.x,e=b.y<c.y?b.y:c.y;return new a(d,e)},a.Maximize=function(b,c){var d=b.x>c.x?b.x:c.x,e=b.y>c.y?b.y:c.y;return new a(d,e)},a.Transform=function(b,c){var d=b.x*c.m[0]+b.y*c.m[4],e=b.x*c.m[1]+b.y*c.m[5];return new a(d,e)},a.Distance=function(b,c){return Math.sqrt(a.DistanceSquared(b,c))},a.DistanceSquared=function(a,b){var c=a.x-b.x,d=a.y-b.y;return c*c+d*d},a}();a.Vector2=d;var e=function(){function b(a,b,c){this.x=a,this.y=b,this.z=c}return b.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+"}"},b.prototype.asArray=function(){var a=[];return this.toArray(a,0),a},b.prototype.toArray=function(a,b){void 0===b&&(b=0),a[b]=this.x,a[b+1]=this.y,a[b+2]=this.z},b.prototype.addInPlace=function(a){this.x+=a.x,this.y+=a.y,this.z+=a.z},b.prototype.add=function(a){return new b(this.x+a.x,this.y+a.y,this.z+a.z)},b.prototype.addToRef=function(a,b){b.x=this.x+a.x,b.y=this.y+a.y,b.z=this.z+a.z},b.prototype.subtractInPlace=function(a){this.x-=a.x,this.y-=a.y,this.z-=a.z},b.prototype.subtract=function(a){return new b(this.x-a.x,this.y-a.y,this.z-a.z)},b.prototype.subtractToRef=function(a,b){b.x=this.x-a.x,b.y=this.y-a.y,b.z=this.z-a.z},b.prototype.subtractFromFloats=function(a,c,d){return new b(this.x-a,this.y-c,this.z-d)},b.prototype.subtractFromFloatsToRef=function(a,b,c,d){d.x=this.x-a,d.y=this.y-b,d.z=this.z-c},b.prototype.negate=function(){return new b(-this.x,-this.y,-this.z)},b.prototype.scaleInPlace=function(a){this.x*=a,this.y*=a,this.z*=a},b.prototype.scale=function(a){return new b(this.x*a,this.y*a,this.z*a)},b.prototype.scaleToRef=function(a,b){b.x=this.x*a,b.y=this.y*a,b.z=this.z*a},b.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y&&this.z===a.z},b.prototype.equalsWithEpsilon=function(b){return Math.abs(this.x-b.x)<a.Engine.Epsilon&&Math.abs(this.y-b.y)<a.Engine.Epsilon&&Math.abs(this.z-b.z)<a.Engine.Epsilon},b.prototype.equalsToFloats=function(a,b,c){return this.x===a&&this.y===b&&this.z===c},b.prototype.multiplyInPlace=function(a){this.x*=a.x,this.y*=a.y,this.z*=a.z},b.prototype.multiply=function(a){return new b(this.x*a.x,this.y*a.y,this.z*a.z)},b.prototype.multiplyToRef=function(a,b){b.x=this.x*a.x,b.y=this.y*a.y,b.z=this.z*a.z},b.prototype.multiplyByFloats=function(a,c,d){return new b(this.x*a,this.y*c,this.z*d)},b.prototype.divide=function(a){return new b(this.x/a.x,this.y/a.y,this.z/a.z)},b.prototype.divideToRef=function(a,b){b.x=this.x/a.x,b.y=this.y/a.y,b.z=this.z/a.z},b.prototype.MinimizeInPlace=function(a){a.x<this.x&&(this.x=a.x),a.y<this.y&&(this.y=a.y),a.z<this.z&&(this.z=a.z)},b.prototype.MaximizeInPlace=function(a){a.x>this.x&&(this.x=a.x),a.y>this.y&&(this.y=a.y),a.z>this.z&&(this.z=a.z)},b.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},b.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z},b.prototype.normalize=function(){var a=this.length();if(0!==a){var b=1/a;this.x*=b,this.y*=b,this.z*=b}},b.prototype.clone=function(){return new b(this.x,this.y,this.z)},b.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y,this.z=a.z},b.prototype.copyFromFloats=function(a,b,c){this.x=a,this.y=b,this.z=c},b.FromArray=function(a,c){return c||(c=0),new b(a[c],a[c+1],a[c+2])},b.FromArrayToRef=function(a,b,c){c.x=a[b],c.y=a[b+1],c.z=a[b+2]},b.FromFloatArrayToRef=function(a,b,c){c.x=a[b],c.y=a[b+1],c.z=a[b+2]},b.FromFloatsToRef=function(a,b,c,d){d.x=a,d.y=b,d.z=c},b.Zero=function(){return new b(0,0,0)},b.Up=function(){return new b(0,1,0)},b.TransformCoordinates=function(a,c){var d=b.Zero();return b.TransformCoordinatesToRef(a,c,d),d},b.TransformCoordinatesToRef=function(a,b,c){var d=a.x*b.m[0]+a.y*b.m[4]+a.z*b.m[8]+b.m[12],e=a.x*b.m[1]+a.y*b.m[5]+a.z*b.m[9]+b.m[13],f=a.x*b.m[2]+a.y*b.m[6]+a.z*b.m[10]+b.m[14],g=a.x*b.m[3]+a.y*b.m[7]+a.z*b.m[11]+b.m[15];c.x=d/g,c.y=e/g,c.z=f/g},b.TransformCoordinatesFromFloatsToRef=function(a,b,c,d,e){var f=a*d.m[0]+b*d.m[4]+c*d.m[8]+d.m[12],g=a*d.m[1]+b*d.m[5]+c*d.m[9]+d.m[13],h=a*d.m[2]+b*d.m[6]+c*d.m[10]+d.m[14],i=a*d.m[3]+b*d.m[7]+c*d.m[11]+d.m[15];e.x=f/i,e.y=g/i,e.z=h/i},b.TransformNormal=function(a,c){var d=b.Zero();return b.TransformNormalToRef(a,c,d),d},b.TransformNormalToRef=function(a,b,c){c.x=a.x*b.m[0]+a.y*b.m[4]+a.z*b.m[8],c.y=a.x*b.m[1]+a.y*b.m[5]+a.z*b.m[9],c.z=a.x*b.m[2]+a.y*b.m[6]+a.z*b.m[10]},b.TransformNormalFromFloatsToRef=function(a,b,c,d,e){e.x=a*d.m[0]+b*d.m[4]+c*d.m[8],e.y=a*d.m[1]+b*d.m[5]+c*d.m[9],e.z=a*d.m[2]+b*d.m[6]+c*d.m[10]},b.CatmullRom=function(a,c,d,e,f){var g=f*f,h=f*g,i=.5*(2*c.x+(-a.x+d.x)*f+(2*a.x-5*c.x+4*d.x-e.x)*g+(-a.x+3*c.x-3*d.x+e.x)*h),j=.5*(2*c.y+(-a.y+d.y)*f+(2*a.y-5*c.y+4*d.y-e.y)*g+(-a.y+3*c.y-3*d.y+e.y)*h),k=.5*(2*c.z+(-a.z+d.z)*f+(2*a.z-5*c.z+4*d.z-e.z)*g+(-a.z+3*c.z-3*d.z+e.z)*h);return new b(i,j,k)},b.Clamp=function(a,c,d){var e=a.x;e=e>d.x?d.x:e,e=e<c.x?c.x:e;var f=a.y;f=f>d.y?d.y:f,f=f<c.y?c.y:f;var g=a.z;return g=g>d.z?d.z:g,g=g<c.z?c.z:g,new b(e,f,g)},b.Hermite=function(a,c,d,e,f){var g=f*f,h=f*g,i=2*h-3*g+1,j=-2*h+3*g,k=h-2*g+f,l=h-g,m=a.x*i+d.x*j+c.x*k+e.x*l,n=a.y*i+d.y*j+c.y*k+e.y*l,o=a.z*i+d.z*j+c.z*k+e.z*l;return new b(m,n,o)},b.Lerp=function(a,c,d){var e=a.x+(c.x-a.x)*d,f=a.y+(c.y-a.y)*d,g=a.z+(c.z-a.z)*d;return new b(e,f,g)},b.Dot=function(a,b){return a.x*b.x+a.y*b.y+a.z*b.z},b.Cross=function(a,c){var d=b.Zero();return b.CrossToRef(a,c,d),d},b.CrossToRef=function(a,b,c){c.x=a.y*b.z-a.z*b.y,c.y=a.z*b.x-a.x*b.z,c.z=a.x*b.y-a.y*b.x},b.Normalize=function(a){var c=b.Zero();return b.NormalizeToRef(a,c),c},b.NormalizeToRef=function(a,b){b.copyFrom(a),b.normalize()},b.Project=function(c,d,e,f){var g=f.width,h=f.height,i=f.x,j=f.y,k=a.Matrix.FromValues(g/2,0,0,0,0,-h/2,0,0,0,0,1,0,i+g/2,h/2+j,0,1),l=d.multiply(e).multiply(k);return b.TransformCoordinates(c,l)},b.Unproject=function(b,c,d,e,f,g){var h=e.multiply(f).multiply(g);h.invert(),b.x=b.x/c*2-1,b.y=-(b.y/d*2-1);var i=a.Vector3.TransformCoordinates(b,h),j=b.x*h.m[3]+b.y*h.m[7]+b.z*h.m[11]+h.m[15];return a.Tools.WithinEpsilon(j,1)&&(i=i.scale(1/j)),i},b.Minimize=function(a,b){var c=a.clone();return c.MinimizeInPlace(b),c},b.Maximize=function(a,b){var c=a.clone();return c.MaximizeInPlace(b),c},b.Distance=function(a,c){return Math.sqrt(b.DistanceSquared(a,c))},b.DistanceSquared=function(a,b){var c=a.x-b.x,d=a.y-b.y,e=a.z-b.z;return c*c+d*d+e*e},b.Center=function(a,b){var c=a.add(b);return c.scaleInPlace(.5),c},b}();a.Vector3=e;var f=function(){function a(a,b,c,d){"undefined"==typeof a&&(a=0),"undefined"==typeof b&&(b=0),"undefined"==typeof c&&(c=0),"undefined"==typeof d&&(d=0),this.x=a,this.y=b,this.z=c,this.w=d}return a.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+" W:"+this.w+"}"},a.prototype.asArray=function(){return[this.x,this.y,this.z,this.w]},a.prototype.equals=function(a){return a&&this.x===a.x&&this.y===a.y&&this.z===a.z&&this.w===a.w},a.prototype.clone=function(){return new a(this.x,this.y,this.z,this.w)},a.prototype.copyFrom=function(a){this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w},a.prototype.add=function(b){return new a(this.x+b.x,this.y+b.y,this.z+b.z,this.w+b.w)},a.prototype.subtract=function(b){return new a(this.x-b.x,this.y-b.y,this.z-b.z,this.w-b.w)},a.prototype.scale=function(b){return new a(this.x*b,this.y*b,this.z*b,this.w*b)},a.prototype.multiply=function(b){var c=new a(0,0,0,1);return this.multiplyToRef(b,c),c},a.prototype.multiplyToRef=function(a,b){b.x=this.x*a.w+this.y*a.z-this.z*a.y+this.w*a.x,b.y=-this.x*a.z+this.y*a.w+this.z*a.x+this.w*a.y,b.z=this.x*a.y-this.y*a.x+this.z*a.w+this.w*a.z,b.w=-this.x*a.x-this.y*a.y-this.z*a.z+this.w*a.w},a.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},a.prototype.normalize=function(){var a=1/this.length();this.x*=a,this.y*=a,this.z*=a,this.w*=a},a.prototype.toEulerAngles=function(){var a=this.x,b=this.y,c=this.z,d=this.w,f=a*a,g=b*b,h=c*c,i=Math.atan2(2*(b*d-a*c),1-2*(g+h)),j=Math.asin(2*(a*b+c*d)),k=Math.atan2(2*(a*d-b*c),1-2*(f+h)),l=a*b+c*d;return l>.499?(i=2*Math.atan2(a,d),k=0):-.499>l&&(i=-2*Math.atan2(a,d),k=0),new e(j,i,k)},a.prototype.toRotationMatrix=function(a){var b=this.x*this.x,c=this.y*this.y,d=this.z*this.z,e=this.x*this.y,f=this.z*this.w,g=this.z*this.x,h=this.y*this.w,i=this.y*this.z,j=this.x*this.w;a.m[0]=1-2*(c+d),a.m[1]=2*(e+f),a.m[2]=2*(g-h),a.m[3]=0,a.m[4]=2*(e-f),a.m[5]=1-2*(d+b),a.m[6]=2*(i+j),a.m[7]=0,a.m[8]=2*(g+h),a.m[9]=2*(i-j),a.m[10]=1-2*(c+b),a.m[11]=0,a.m[12]=0,a.m[13]=0,a.m[14]=0,a.m[15]=1},a.prototype.fromRotationMatrix=function(a){var b,c=a.m,d=c[0],e=c[4],f=c[8],g=c[1],h=c[5],i=c[9],j=c[2],k=c[6],l=c[10],m=d+h+l;return m>0?(b=.5/Math.sqrt(m+1),this.w=.25/b,this.x=(k-i)*b,this.y=(f-j)*b,void(this.z=(g-e)*b)):d>h&&d>l?(b=2*Math.sqrt(1+d-h-l),this.w=(k-i)/b,this.x=.25*b,this.y=(e+g)/b,void(this.z=(f+j)/b)):h>l?(b=2*Math.sqrt(1+h-d-l),this.w=(f-j)/b,this.x=(e+g)/b,this.y=.25*b,void(this.z=(i+k)/b)):(b=2*Math.sqrt(1+l-d-h),this.w=(g-e)/b,this.x=(f+j)/b,this.y=(i+k)/b,void(this.z=.25*b))},a.RotationAxis=function(b,c){var d=new a,e=Math.sin(c/2);return d.w=Math.cos(c/2),d.x=b.x*e,d.y=b.y*e,d.z=b.z*e,d},a.FromArray=function(b,c){return c||(c=0),new a(b[c],b[c+1],b[c+2],b[c+3])},a.RotationYawPitchRoll=function(b,c,d){var e=new a;return a.RotationYawPitchRollToRef(b,c,d,e),e},a.RotationYawPitchRollToRef=function(a,b,c,d){var e=.5*c,f=.5*b,g=.5*a,h=Math.sin(e),i=Math.cos(e),j=Math.sin(f),k=Math.cos(f),l=Math.sin(g),m=Math.cos(g);d.x=m*j*i+l*k*h,d.y=l*k*i-m*j*h,d.z=m*k*h-l*j*i,d.w=m*k*i+l*j*h},a.Slerp=function(b,c,d){var e,f,g=d,h=b.x*c.x+b.y*c.y+b.z*c.z+b.w*c.w,i=!1;if(0>h&&(i=!0,h=-h),h>.999999)f=1-g,e=i?-g:g;else{var j=Math.acos(h),k=1/Math.sin(j);f=Math.sin((1-g)*j)*k,e=i?-Math.sin(g*j)*k:Math.sin(g*j)*k}return new a(f*b.x+e*c.x,f*b.y+e*c.y,f*b.z+e*c.z,f*b.w+e*c.w)},a}();a.Quaternion=f;var g=function(){function a(){this.m=new Float32Array(16)}return a.prototype.isIdentity=function(){return 1!=this.m[0]||1!=this.m[5]||1!=this.m[10]||1!=this.m[15]?!1:0!=this.m[1]||0!=this.m[2]||0!=this.m[3]||0!=this.m[4]||0!=this.m[6]||0!=this.m[7]||0!=this.m[8]||0!=this.m[9]||0!=this.m[11]||0!=this.m[12]||0!=this.m[13]||0!=this.m[14]?!1:!0},a.prototype.determinant=function(){var a=this.m[10]*this.m[15]-this.m[11]*this.m[14],b=this.m[9]*this.m[15]-this.m[11]*this.m[13],c=this.m[9]*this.m[14]-this.m[10]*this.m[13],d=this.m[8]*this.m[15]-this.m[11]*this.m[12],e=this.m[8]*this.m[14]-this.m[10]*this.m[12],f=this.m[8]*this.m[13]-this.m[9]*this.m[12];return this.m[0]*(this.m[5]*a-this.m[6]*b+this.m[7]*c)-this.m[1]*(this.m[4]*a-this.m[6]*d+this.m[7]*e)+this.m[2]*(this.m[4]*b-this.m[5]*d+this.m[7]*f)-this.m[3]*(this.m[4]*c-this.m[5]*e+this.m[6]*f)},a.prototype.toArray=function(){return this.m},a.prototype.asArray=function(){return this.toArray()},a.prototype.invert=function(){this.invertToRef(this)},a.prototype.invertToRef=function(a){var b=this.m[0],c=this.m[1],d=this.m[2],e=this.m[3],f=this.m[4],g=this.m[5],h=this.m[6],i=this.m[7],j=this.m[8],k=this.m[9],l=this.m[10],m=this.m[11],n=this.m[12],o=this.m[13],p=this.m[14],q=this.m[15],r=l*q-m*p,s=k*q-m*o,t=k*p-l*o,u=j*q-m*n,v=j*p-l*n,w=j*o-k*n,x=g*r-h*s+i*t,y=-(f*r-h*u+i*v),z=f*s-g*u+i*w,A=-(f*t-g*v+h*w),B=1/(b*x+c*y+d*z+e*A),C=h*q-i*p,D=g*q-i*o,E=g*p-h*o,F=f*q-i*n,G=f*p-h*n,H=f*o-g*n,I=h*m-i*l,J=g*m-i*k,K=g*l-h*k,L=f*m-i*j,M=f*l-h*j,N=f*k-g*j;a.m[0]=x*B,a.m[4]=y*B,a.m[8]=z*B,a.m[12]=A*B,a.m[1]=-(c*r-d*s+e*t)*B,a.m[5]=(b*r-d*u+e*v)*B,a.m[9]=-(b*s-c*u+e*w)*B,a.m[13]=(b*t-c*v+d*w)*B,a.m[2]=(c*C-d*D+e*E)*B,a.m[6]=-(b*C-d*F+e*G)*B,a.m[10]=(b*D-c*F+e*H)*B,a.m[14]=-(b*E-c*G+d*H)*B,a.m[3]=-(c*I-d*J+e*K)*B,a.m[7]=(b*I-d*L+e*M)*B,a.m[11]=-(b*J-c*L+e*N)*B,a.m[15]=(b*K-c*M+d*N)*B},a.prototype.setTranslation=function(a){this.m[12]=a.x,this.m[13]=a.y,this.m[14]=a.z},a.prototype.multiply=function(b){var c=new a;return this.multiplyToRef(b,c),c},a.prototype.copyFrom=function(a){for(var b=0;16>b;b++)this.m[b]=a.m[b]},a.prototype.copyToArray=function(a,b){"undefined"==typeof b&&(b=0);for(var c=0;16>c;c++)a[b+c]=this.m[c]},a.prototype.multiplyToRef=function(a,b){this.multiplyToArray(a,b.m,0)},a.prototype.multiplyToArray=function(a,b,c){var d=this.m[0],e=this.m[1],f=this.m[2],g=this.m[3],h=this.m[4],i=this.m[5],j=this.m[6],k=this.m[7],l=this.m[8],m=this.m[9],n=this.m[10],o=this.m[11],p=this.m[12],q=this.m[13],r=this.m[14],s=this.m[15],t=a.m[0],u=a.m[1],v=a.m[2],w=a.m[3],x=a.m[4],y=a.m[5],z=a.m[6],A=a.m[7],B=a.m[8],C=a.m[9],D=a.m[10],E=a.m[11],F=a.m[12],G=a.m[13],H=a.m[14],I=a.m[15];b[c]=d*t+e*x+f*B+g*F,b[c+1]=d*u+e*y+f*C+g*G,b[c+2]=d*v+e*z+f*D+g*H,b[c+3]=d*w+e*A+f*E+g*I,b[c+4]=h*t+i*x+j*B+k*F,b[c+5]=h*u+i*y+j*C+k*G,b[c+6]=h*v+i*z+j*D+k*H,b[c+7]=h*w+i*A+j*E+k*I,b[c+8]=l*t+m*x+n*B+o*F,b[c+9]=l*u+m*y+n*C+o*G,b[c+10]=l*v+m*z+n*D+o*H,b[c+11]=l*w+m*A+n*E+o*I,b[c+12]=p*t+q*x+r*B+s*F,b[c+13]=p*u+q*y+r*C+s*G,b[c+14]=p*v+q*z+r*D+s*H,b[c+15]=p*w+q*A+r*E+s*I},a.prototype.equals=function(a){return a&&this.m[0]===a.m[0]&&this.m[1]===a.m[1]&&this.m[2]===a.m[2]&&this.m[3]===a.m[3]&&this.m[4]===a.m[4]&&this.m[5]===a.m[5]&&this.m[6]===a.m[6]&&this.m[7]===a.m[7]&&this.m[8]===a.m[8]&&this.m[9]===a.m[9]&&this.m[10]===a.m[10]&&this.m[11]===a.m[11]&&this.m[12]===a.m[12]&&this.m[13]===a.m[13]&&this.m[14]===a.m[14]&&this.m[15]===a.m[15]},a.prototype.clone=function(){return a.FromValues(this.m[0],this.m[1],this.m[2],this.m[3],this.m[4],this.m[5],this.m[6],this.m[7],this.m[8],this.m[9],this.m[10],this.m[11],this.m[12],this.m[13],this.m[14],this.m[15])},a.FromArray=function(b,c){var d=new a;return c||(c=0),a.FromArrayToRef(b,c,d),d},a.FromArrayToRef=function(a,b,c){for(var d=0;16>d;d++)c.m[d]=a[d+b]},a.FromValuesToRef=function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){q.m[0]=a,q.m[1]=b,q.m[2]=c,q.m[3]=d,q.m[4]=e,q.m[5]=f,q.m[6]=g,q.m[7]=h,q.m[8]=i,q.m[9]=j,q.m[10]=k,q.m[11]=l,q.m[12]=m,q.m[13]=n,q.m[14]=o,q.m[15]=p},a.FromValues=function(b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){var r=new a;return r.m[0]=b,r.m[1]=c,r.m[2]=d,r.m[3]=e,r.m[4]=f,r.m[5]=g,r.m[6]=h,r.m[7]=i,r.m[8]=j,r.m[9]=k,r.m[10]=l,r.m[11]=m,r.m[12]=n,r.m[13]=o,r.m[14]=p,r.m[15]=q,r},a.Identity=function(){return a.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},a.IdentityToRef=function(b){a.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,b)},a.Zero=function(){return a.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)},a.RotationX=function(b){var c=new a;return a.RotationXToRef(b,c),c},a.RotationXToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[0]=1,b.m[15]=1,b.m[5]=d,b.m[10]=d,b.m[9]=-c,b.m[6]=c,b.m[1]=0,b.m[2]=0,b.m[3]=0,b.m[4]=0,b.m[7]=0,b.m[8]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationY=function(b){var c=new a;return a.RotationYToRef(b,c),c},a.RotationYToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[5]=1,b.m[15]=1,b.m[0]=d,b.m[2]=-c,b.m[8]=c,b.m[10]=d,b.m[1]=0,b.m[3]=0,b.m[4]=0,b.m[6]=0,b.m[7]=0,b.m[9]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationZ=function(b){var c=new a;return a.RotationZToRef(b,c),c},a.RotationZToRef=function(a,b){var c=Math.sin(a),d=Math.cos(a);b.m[10]=1,b.m[15]=1,b.m[0]=d,b.m[1]=c,b.m[4]=-c,b.m[5]=d,b.m[2]=0,b.m[3]=0,b.m[6]=0,b.m[7]=0,b.m[8]=0,b.m[9]=0,b.m[11]=0,b.m[12]=0,b.m[13]=0,b.m[14]=0},a.RotationAxis=function(b,c){var d=Math.sin(-c),e=Math.cos(-c),f=1-e;b.normalize();var g=a.Zero();return g.m[0]=b.x*b.x*f+e,g.m[1]=b.x*b.y*f-b.z*d,g.m[2]=b.x*b.z*f+b.y*d,g.m[3]=0,g.m[4]=b.y*b.x*f+b.z*d,g.m[5]=b.y*b.y*f+e,g.m[6]=b.y*b.z*f-b.x*d,g.m[7]=0,g.m[8]=b.z*b.x*f-b.y*d,g.m[9]=b.z*b.y*f+b.x*d,g.m[10]=b.z*b.z*f+e,g.m[11]=0,g.m[15]=1,g},a.RotationYawPitchRoll=function(b,c,d){var e=new a;return a.RotationYawPitchRollToRef(b,c,d,e),e},a.RotationYawPitchRollToRef=function(a,b,c,d){f.RotationYawPitchRollToRef(a,b,c,this._tempQuaternion),this._tempQuaternion.toRotationMatrix(d)},a.Scaling=function(b,c,d){var e=a.Zero();return a.ScalingToRef(b,c,d,e),e},a.ScalingToRef=function(a,b,c,d){d.m[0]=a,d.m[1]=0,d.m[2]=0,d.m[3]=0,d.m[4]=0,d.m[5]=b,d.m[6]=0,d.m[7]=0,d.m[8]=0,d.m[9]=0,d.m[10]=c,d.m[11]=0,d.m[12]=0,d.m[13]=0,d.m[14]=0,d.m[15]=1},a.Translation=function(b,c,d){var e=a.Identity();return a.TranslationToRef(b,c,d,e),e},a.TranslationToRef=function(b,c,d,e){a.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,b,c,d,1,e)},a.LookAtLH=function(b,c,d){var e=a.Zero();return a.LookAtLHToRef(b,c,d,e),e},a.LookAtLHToRef=function(b,c,d,f){c.subtractToRef(b,this._zAxis),this._zAxis.normalize(),e.CrossToRef(d,this._zAxis,this._xAxis),this._xAxis.normalize(),e.CrossToRef(this._zAxis,this._xAxis,this._yAxis),this._yAxis.normalize();var g=-e.Dot(this._xAxis,b),h=-e.Dot(this._yAxis,b),i=-e.Dot(this._zAxis,b);return a.FromValuesToRef(this._xAxis.x,this._yAxis.x,this._zAxis.x,0,this._xAxis.y,this._yAxis.y,this._zAxis.y,0,this._xAxis.z,this._yAxis.z,this._zAxis.z,0,g,h,i,1,f)},a.OrthoLH=function(b,c,d,e){var f=2/b,g=2/c,h=1/(e-d),i=d/(d-e);return a.FromValues(f,0,0,0,0,g,0,0,0,0,h,0,0,0,i,1)},a.OrthoOffCenterLH=function(b,c,d,e,f,g){var h=a.Zero();return a.OrthoOffCenterLHToRef(b,c,d,e,f,g,h),h},a.OrthoOffCenterLHToRef=function(a,b,c,d,e,f,g){g.m[0]=2/(b-a),g.m[1]=g.m[2]=g.m[3]=0,g.m[5]=2/(d-c),g.m[4]=g.m[6]=g.m[7]=0,g.m[10]=-1/(e-f),g.m[8]=g.m[9]=g.m[11]=0,g.m[12]=(a+b)/(a-b),g.m[13]=(d+c)/(c-d),g.m[14]=e/(e-f),g.m[15]=1},a.PerspectiveLH=function(b,c,d,e){var f=a.Zero();return f.m[0]=2*d/b,f.m[1]=f.m[2]=f.m[3]=0,f.m[5]=2*d/c,f.m[4]=f.m[6]=f.m[7]=0,f.m[10]=-e/(d-e),f.m[8]=f.m[9]=0,f.m[11]=1,f.m[12]=f.m[13]=f.m[15]=0,f.m[14]=d*e/(d-e),f},a.PerspectiveFovLH=function(b,c,d,e){var f=a.Zero();return a.PerspectiveFovLHToRef(b,c,d,e,f),f},a.PerspectiveFovLHToRef=function(a,b,c,d,e){var f=1/Math.tan(.5*a);e.m[0]=f/b,e.m[1]=e.m[2]=e.m[3]=0,e.m[5]=f,e.m[4]=e.m[6]=e.m[7]=0,e.m[8]=e.m[9]=0,e.m[10]=-d/(c-d),e.m[11]=1,e.m[12]=e.m[13]=e.m[15]=0,e.m[14]=c*d/(c-d)},a.GetFinalMatrix=function(b,c,d,e,f,g){var h=b.width,i=b.height,j=b.x,k=b.y,l=a.FromValues(h/2,0,0,0,0,-i/2,0,0,0,0,g-f,0,j+h/2,i/2+k,f,1);return c.multiply(d).multiply(e).multiply(l)},a.Transpose=function(b){var c=new a;return c.m[0]=b.m[0],c.m[1]=b.m[4],c.m[2]=b.m[8],c.m[3]=b.m[12],c.m[4]=b.m[1],c.m[5]=b.m[5],c.m[6]=b.m[9],c.m[7]=b.m[13],c.m[8]=b.m[2],c.m[9]=b.m[6],c.m[10]=b.m[10],c.m[11]=b.m[14],c.m[12]=b.m[3],c.m[13]=b.m[7],c.m[14]=b.m[11],c.m[15]=b.m[15],c},a.Reflection=function(b){var c=new a;return a.ReflectionToRef(b,c),c},a.ReflectionToRef=function(a,b){a.normalize();var c=a.normal.x,d=a.normal.y,e=a.normal.z,f=-2*c,g=-2*d,h=-2*e;b.m[0]=f*c+1,b.m[1]=g*c,b.m[2]=h*c,b.m[3]=0,b.m[4]=f*d,b.m[5]=g*d+1,b.m[6]=h*d,b.m[7]=0,b.m[8]=f*e,b.m[9]=g*e,b.m[10]=h*e+1,b.m[11]=0,b.m[12]=f*a.d,b.m[13]=g*a.d,b.m[14]=h*a.d,b.m[15]=1},a._tempQuaternion=new f,a._xAxis=e.Zero(),a._yAxis=e.Zero(),a._zAxis=e.Zero(),a}();a.Matrix=g;var h=function(){function b(a,b,c,d){this.normal=new e(a,b,c),this.d=d}return b.prototype.asArray=function(){return[this.normal.x,this.normal.y,this.normal.z,this.d]},b.prototype.clone=function(){return new b(this.normal.x,this.normal.y,this.normal.z,this.d)},b.prototype.normalize=function(){var a=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z),b=0;0!=a&&(b=1/a),this.normal.x*=b,this.normal.y*=b,this.normal.z*=b,this.d*=b},b.prototype.transform=function(b){var c=a.Matrix.Transpose(b),d=this.normal.x,e=this.normal.y,f=this.normal.z,g=this.d,h=d*c.m[0]+e*c.m[1]+f*c.m[2]+g*c.m[3],i=d*c.m[4]+e*c.m[5]+f*c.m[6]+g*c.m[7],j=d*c.m[8]+e*c.m[9]+f*c.m[10]+g*c.m[11],k=d*c.m[12]+e*c.m[13]+f*c.m[14]+g*c.m[15];return new a.Plane(h,i,j,k)},b.prototype.dotCoordinate=function(a){return this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z+this.d},b.prototype.copyFromPoints=function(a,b,c){var d,e=b.x-a.x,f=b.y-a.y,g=b.z-a.z,h=c.x-a.x,i=c.y-a.y,j=c.z-a.z,k=f*j-g*i,l=g*h-e*j,m=e*i-f*h,n=Math.sqrt(k*k+l*l+m*m);d=0!=n?1/n:0,this.normal.x=k*d,this.normal.y=l*d,this.normal.z=m*d,this.d=-(this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z)},b.prototype.isFrontFacingTo=function(a,b){var c=e.Dot(this.normal,a);return b>=c},b.prototype.signedDistanceTo=function(a){return e.Dot(a,this.normal)+this.d},b.FromArray=function(b){return new a.Plane(b[0],b[1],b[2],b[3])},b.FromPoints=function(b,c,d){var e=new a.Plane(0,0,0,0);return e.copyFromPoints(b,c,d),e},b.FromPositionAndNormal=function(b,c){var d=new a.Plane(0,0,0,0);return c.normalize(),d.normal=c,d.d=-(c.x*b.x+c.y*b.y+c.z*b.z),d},b.SignedDistanceToPlaneFromPositionAndNormal=function(a,b,c){var d=-(b.x*a.x+b.y*a.y+b.z*a.z);return e.Dot(c,b)+d},b}();a.Plane=h;var i=function(){function a(a,b,c,d){this.x=a,this.y=b,this.width=c,this.height=d}return a.prototype.toGlobal=function(b){var c=b.getRenderWidth(),d=b.getRenderHeight();return new a(this.x*c,this.y*d,this.width*c,this.height*d)},a}();a.Viewport=i;var j=function(){function a(){}return a.GetPlanes=function(b){for(var c=[],d=0;6>d;d++)c.push(new h(0,0,0,0));return a.GetPlanesToRef(b,c),c},a.GetPlanesToRef=function(a,b){b[0].normal.x=a.m[3]+a.m[2],b[0].normal.y=a.m[7]+a.m[6],b[0].normal.z=a.m[10]+a.m[10],b[0].d=a.m[15]+a.m[14],b[0].normalize(),b[1].normal.x=a.m[3]-a.m[2],b[1].normal.y=a.m[7]-a.m[6],b[1].normal.z=a.m[11]-a.m[10],b[1].d=a.m[15]-a.m[14],b[1].normalize(),b[2].normal.x=a.m[3]+a.m[0],b[2].normal.y=a.m[7]+a.m[4],b[2].normal.z=a.m[11]+a.m[8],b[2].d=a.m[15]+a.m[12],b[2].normalize(),b[3].normal.x=a.m[3]-a.m[0],b[3].normal.y=a.m[7]-a.m[4],b[3].normal.z=a.m[11]-a.m[8],b[3].d=a.m[15]-a.m[12],b[3].normalize(),b[4].normal.x=a.m[3]-a.m[1],b[4].normal.y=a.m[7]-a.m[5],b[4].normal.z=a.m[11]-a.m[9],b[4].d=a.m[15]-a.m[13],b[4].normalize(),b[5].normal.x=a.m[3]+a.m[1],b[5].normal.y=a.m[7]+a.m[5],b[5].normal.z=a.m[11]+a.m[9],b[5].d=a.m[15]+a.m[13],b[5].normalize()},a}();a.Frustum=j;var k=function(){function b(a,b){this.origin=a,this.direction=b}return b.prototype.intersectsBoxMinMax=function(a,b){var c=0,d=Number.MAX_VALUE;if(Math.abs(this.direction.x)<1e-7){if(this.origin.x<a.x||this.origin.x>b.x)return!1}else{var e=1/this.direction.x,f=(a.x-this.origin.x)*e,g=(b.x-this.origin.x)*e;if(f>g){var h=f;f=g,g=h}if(c=Math.max(f,c),d=Math.min(g,d),c>d)return!1}if(Math.abs(this.direction.y)<1e-7){if(this.origin.y<a.y||this.origin.y>b.y)return!1}else if(e=1/this.direction.y,f=(a.y-this.origin.y)*e,g=(b.y-this.origin.y)*e,f>g&&(h=f,f=g,g=h),c=Math.max(f,c),d=Math.min(g,d),c>d)return!1;if(Math.abs(this.direction.z)<1e-7){if(this.origin.z<a.z||this.origin.z>b.z)return!1}else if(e=1/this.direction.z,f=(a.z-this.origin.z)*e,g=(b.z-this.origin.z)*e,f>g&&(h=f,f=g,g=h),c=Math.max(f,c),d=Math.min(g,d),c>d)return!1;return!0},b.prototype.intersectsBox=function(a){return this.intersectsBoxMinMax(a.minimum,a.maximum)},b.prototype.intersectsSphere=function(a){var b=a.center.x-this.origin.x,c=a.center.y-this.origin.y,d=a.center.z-this.origin.z,e=b*b+c*c+d*d,f=a.radius*a.radius;if(f>=e)return!0;var g=b*this.direction.x+c*this.direction.y+d*this.direction.z;if(0>g)return!1;var h=e-g*g;return f>=h},b.prototype.intersectsTriangle=function(b,c,d){this._edge1||(this._edge1=a.Vector3.Zero(),this._edge2=a.Vector3.Zero(),this._pvec=a.Vector3.Zero(),this._tvec=a.Vector3.Zero(),this._qvec=a.Vector3.Zero()),c.subtractToRef(b,this._edge1),d.subtractToRef(b,this._edge2),a.Vector3.CrossToRef(this.direction,this._edge2,this._pvec);var f=e.Dot(this._edge1,this._pvec);if(0===f)return null;var g=1/f;this.origin.subtractToRef(b,this._tvec);var h=e.Dot(this._tvec,this._pvec)*g;if(0>h||h>1)return null;e.CrossToRef(this._tvec,this._edge1,this._qvec);var i=e.Dot(this.direction,this._qvec)*g;return 0>i||h+i>1?null:new a.IntersectionInfo(h,i,e.Dot(this._edge2,this._qvec)*g)},b.CreateNew=function(c,d,e,f,g,h,i){var j=a.Vector3.Unproject(new a.Vector3(c,d,0),e,f,g,h,i),k=a.Vector3.Unproject(new a.Vector3(c,d,1),e,f,g,h,i),l=k.subtract(j);return l.normalize(),new b(j,l)},b.Transform=function(c,d){var e=a.Vector3.TransformCoordinates(c.origin,d),f=a.Vector3.TransformNormal(c.direction,d);return new b(e,f)},b}();a.Ray=k,function(a){a[a.LOCAL=0]="LOCAL",a[a.WORLD=1]="WORLD"}(a.Space||(a.Space={}));var l=(a.Space,function(){function b(){}return b.X=new a.Vector3(1,0,0),b.Y=new a.Vector3(0,1,0),b.Z=new a.Vector3(0,0,1),b}());a.Axis=l}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b,c=60,d=[],e=60,f=0,g=function(b,c){return b?b instanceof a.Mesh?null:b instanceof a.SubMesh?b.clone(c):b.clone?b.clone():null:null},h=function(){function h(){}return h.GetFilename=function(a){var b=a.lastIndexOf("/");return 0>b?a:a.substring(b+1)},h.GetDOMTextContent=function(a){for(var b="",c=a.firstChild;c;)3==c.nodeType&&(b+=c.textContent),c=c.nextSibling;return b},h.ToDegrees=function(a){return 180*a/Math.PI},h.ToRadians=function(a){return a*Math.PI/180},h.ExtractMinAndMaxIndexed=function(b,c,d,e){for(var f=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),g=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),h=d;d+e>h;h++){var i=new a.Vector3(b[3*c[h]],b[3*c[h]+1],b[3*c[h]+2]);f=a.Vector3.Minimize(i,f),g=a.Vector3.Maximize(i,g)}return{minimum:f,maximum:g}},h.ExtractMinAndMax=function(b,c,d){for(var e=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),f=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),g=c;c+d>g;g++){var h=new a.Vector3(b[3*g],b[3*g+1],b[3*g+2]);e=a.Vector3.Minimize(h,e),f=a.Vector3.Maximize(h,f)}return{minimum:e,maximum:f}},h.MakeArray=function(a,b){return b===!0||void 0!==a&&null!=a?Array.isArray(a)?a:[a]:void 0},h.GetPointerPrefix=function(){var a="pointer";return navigator.pointerEnabled||(a="mouse"),a},h.QueueNewFrame=function(a){window.requestAnimationFrame?window.requestAnimationFrame(a):window.msRequestAnimationFrame?window.msRequestAnimationFrame(a):window.webkitRequestAnimationFrame?window.webkitRequestAnimationFrame(a):window.mozRequestAnimationFrame?window.mozRequestAnimationFrame(a):window.oRequestAnimationFrame?window.oRequestAnimationFrame(a):window.setTimeout(a,16)},h.RequestFullscreen=function(a){a.requestFullscreen?a.requestFullscreen():a.msRequestFullscreen?a.msRequestFullscreen():a.webkitRequestFullscreen?a.webkitRequestFullscreen():a.mozRequestFullScreen&&a.mozRequestFullScreen()},h.ExitFullscreen=function(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitCancelFullScreen?document.webkitCancelFullScreen():document.msCancelFullScreen&&document.msCancelFullScreen()},h.CleanUrl=function(a){return a=a.replace(/#/gm,"%23")},h.LoadImage=function(b,c,d,e){b=h.CleanUrl(b);var f=new Image;f.crossOrigin="anonymous",f.onload=function(){c(f)},f.onerror=function(a){d(f,a)};var g=function(){f.src=b},i=function(){e.loadImageFromDB(b,f)};if(e&&e.enableTexturesOffline&&a.Database.isUASupportingBlobStorage)e.openAsync(i,g);else if(-1===b.indexOf("file:"))g();else try{var j,k=b.substring(5);try{j=URL.createObjectURL(a.FilesInput.FilesTextures[k],{oneTimeOnly:!0})}catch(l){j=URL.createObjectURL(a.FilesInput.FilesTextures[k])}f.src=j}catch(m){h.Log("Error while trying to load texture: "+k),f.src=null}return f},h.LoadFile=function(b,c,d,e,f){b=h.CleanUrl(b);
var g=function(){var e=new XMLHttpRequest,g=h.BaseUrl+b;e.open("GET",g,!0),f&&(e.responseType="arraybuffer"),e.onprogress=d,e.onreadystatechange=function(){if(4==e.readyState){if(200!=e.status&&!a.Tools.ValidateXHRData(e,f?6:1))throw new Error("Error status: "+e.status+" - Unable to load "+g);c(f?e.response:e.responseText)}},e.send(null)},i=function(){e.loadFileFromDB(b,c,d,g,f)};if(-1!==b.indexOf("file:")){var j=b.substring(5);a.Tools.ReadFile(a.FilesInput.FilesToLoad[j],c,d,!0)}else e&&e.enableSceneOffline?e.openAsync(i,g):g()},h.ReadFile=function(a,b,c,d){var e=new FileReader;e.onload=function(a){b(a.target.result)},e.onprogress=c,d?e.readAsArrayBuffer(a):e.readAsText(a)},h.CheckExtends=function(a,b,c){a.x<b.x&&(b.x=a.x),a.y<b.y&&(b.y=a.y),a.z<b.z&&(b.z=a.z),a.x>c.x&&(c.x=a.x),a.y>c.y&&(c.y=a.y),a.z>c.z&&(c.z=a.z)},h.WithinEpsilon=function(a,b){var c=a-b;return c>=-1.401298e-45&&1.401298e-45>=c},h.DeepCopy=function(a,b,c,d){for(var e in a)if(("_"!==e[0]||d&&-1!==d.indexOf(e))&&(!c||-1===c.indexOf(e))){var f=a[e],h=typeof f;if("function"!=h)if("object"==h)if(f instanceof Array){if(b[e]=[],f.length>0)if("object"==typeof f[0])for(var i=0;i<f.length;i++){var j=g(f[i],b);-1===b[e].indexOf(j)&&b[e].push(j)}else b[e]=f.slice(0)}else b[e]=g(f,b);else b[e]=f}},h.IsEmpty=function(a){for(var b in a)return!1;return!0},h.RegisterTopRootEvents=function(a){for(var b=0;b<a.length;b++){var c=a[b];window.addEventListener(c.name,c.handler,!1);try{window.parent&&window.parent.addEventListener(c.name,c.handler,!1)}catch(d){}}},h.UnregisterTopRootEvents=function(a){for(var b=0;b<a.length;b++){var c=a[b];window.removeEventListener(c.name,c.handler);try{window.parent&&window.parent.removeEventListener(c.name,c.handler)}catch(d){}}},h.GetFps=function(){return e},h.GetDeltaTime=function(){return f},h._MeasureFps=function(){d.push((new Date).getTime());var a=d.length;if(a>=2&&(f=d[a-1]-d[a-2]),a>=c){a>c&&(d.splice(0,1),a=d.length);for(var b=0,g=0;a-1>g;g++)b+=d[g+1]-d[g];e=1e3/(b/(a-1))}},h.CreateScreenshot=function(c,d,e){var f,g,i=d.getScene(),j=null;if(i.activeCamera!==d&&(j=i.activeCamera,i.activeCamera=d),e.precision)f=Math.round(c.getRenderWidth()*e.precision),g=Math.round(f/c.getAspectRatio(d)),e={width:f,height:g};else if(e.width&&e.height)f=e.width,g=e.height;else if(e.width&&!e.height)f=e.width,g=Math.round(f/c.getAspectRatio(d)),e={width:f,height:g};else if(e.height&&!e.width)g=e.height,f=Math.round(g*c.getAspectRatio(d)),e={width:f,height:g};else{if(isNaN(e))return void h.Error("Invalid 'size' parameter !");g=e,f=e}var k=new a.RenderTargetTexture("screenShot",e,c.scenes[0],!1,!1);k.renderList=c.scenes[0].meshes,k.onAfterRender=function(){for(var a=4*f,d=g/2,e=c.readPixels(0,0,f,g),h=0;d>h;h++)for(var i=0;a>i;i++){var j=i+h*a,k=g-h-1,l=i+k*a,m=e[j];e[j]=e[l],e[l]=m}b||(b=document.createElement("canvas")),b.width=f,b.height=g;var n=b.getContext("2d"),o=n.createImageData(f,g);o.data.set(e),n.putImageData(o,0,0);var p=b.toDataURL();if("download"in document.createElement("a")){var q=window.document.createElement("a");q.href=p;var r=new Date,s=r.getFullYear()+"/"+r.getMonth()+"/"+r.getDate()+"-"+r.getHours()+":"+r.getMinutes();q.setAttribute("download","screenshot-"+s+".png"),window.document.body.appendChild(q),q.addEventListener("click",function(){q.parentElement.removeChild(q)}),q.click()}else{var t=window.open(""),u=t.document.createElement("img");u.src=p,t.document.body.appendChild(u)}},k.render(!0),k.dispose(),j&&(i.activeCamera=j)},h.ValidateXHRData=function(b,c){"undefined"==typeof c&&(c=7);try{if(1&c){if(b.responseText&&b.responseText.length>0)return!0;if(1===c)return!1}if(2&c){var d=a.Internals.TGATools.GetTGAHeader(b.response);if(d.width&&d.height&&d.width>0&&d.height>0)return!0;if(2===c)return!1}if(4&c){var e=new Uint8Array(b.response,0,3);return 68==e[0]&&68==e[1]&&83==e[2]?!0:!1}}catch(f){}return!1},Object.defineProperty(h,"NoneLogLevel",{get:function(){return h._NoneLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"MessageLogLevel",{get:function(){return h._MessageLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"WarningLogLevel",{get:function(){return h._WarningLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ErrorLogLevel",{get:function(){return h._ErrorLogLevel},enumerable:!0,configurable:!0}),Object.defineProperty(h,"AllLogLevel",{get:function(){return h._MessageLogLevel|h._WarningLogLevel|h._ErrorLogLevel},enumerable:!0,configurable:!0}),h._FormatMessage=function(a){var b=function(a){return 10>a?"0"+a:""+a},c=new Date;return"BJS - ["+b(c.getHours())+":"+b(c.getMinutes())+":"+b(c.getSeconds())+"]: "+a},h._LogDisabled=function(){},h._LogEnabled=function(a){console.log(h._FormatMessage(a))},h._WarnDisabled=function(){},h._WarnEnabled=function(a){console.warn(h._FormatMessage(a))},h._ErrorDisabled=function(){},h._ErrorEnabled=function(a){console.error(h._FormatMessage(a))},Object.defineProperty(h,"LogLevels",{set:function(a){h.Log=(a&h.MessageLogLevel)===h.MessageLogLevel?h._LogEnabled:h._LogDisabled,h.Warn=(a&h.WarningLogLevel)===h.WarningLogLevel?h._WarnEnabled:h._WarnDisabled,h.Error=(a&h.ErrorLogLevel)===h.ErrorLogLevel?h._ErrorEnabled:h._ErrorDisabled},enumerable:!0,configurable:!0}),h.BaseUrl="",h._NoneLogLevel=0,h._MessageLogLevel=1,h._WarningLogLevel=2,h._ErrorLogLevel=4,h.Log=h._LogEnabled,h.Warn=h._WarnEnabled,h.Error=h._ErrorEnabled,h}();a.Tools=h}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b,c,d){var e=a.createShader("vertex"===c?a.VERTEX_SHADER:a.FRAGMENT_SHADER);if(a.shaderSource(e,(d?d+"\n":"")+b),a.compileShader(e),!a.getShaderParameter(e,a.COMPILE_STATUS))throw new Error(a.getShaderInfoLog(e));return e},c=function(b,c,d){var e=d.NEAREST,f=d.NEAREST;return b===a.Texture.BILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=c?d.LINEAR_MIPMAP_NEAREST:d.LINEAR):b===a.Texture.TRILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=c?d.LINEAR_MIPMAP_LINEAR:d.LINEAR):b===a.Texture.NEAREST_SAMPLINGMODE&&(e=d.NEAREST,f=c?d.NEAREST_MIPMAP_LINEAR:d.NEAREST),{min:f,mag:e}},d=function(a,b){var c=1;do c*=2;while(a>c);return c>b&&(c=b),c},e=function(b,e,f,g,h,i,j,k,l,m){"undefined"==typeof m&&(m=a.Texture.TRILINEAR_SAMPLINGMODE);var n=f.getEngine(),o=d(g,n.getCaps().maxTextureSize),p=d(h,n.getCaps().maxTextureSize);e.bindTexture(e.TEXTURE_2D,b),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,void 0===i?1:i?1:0),l(o,p);var q=c(m,!j,e);e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,q.mag),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,q.min),j||k||e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null),n._activeTexturesCache=[],b._baseWidth=g,b._baseHeight=h,b._width=o,b._height=p,b.isReady=!0,f._removePendingData(b)},f=function(b,c,d,e,g,h){var i,j=function(){d.push(i),e._removePendingData(i),c!=h.length-1?f(b,c+1,d,e,g,h):g(d)},k=function(){e._removePendingData(i)};i=a.Tools.LoadImage(b+h[c],j,k,e.database),e._addPendingData(i)},g=function(){function a(){}return a}();a.EngineCapabilities=g;var h=function(){function h(a,b,c){var d=this;this.isFullscreen=!1,this.isPointerLock=!1,this.forceWireframe=!1,this.cullBackFaces=!0,this.renderEvenInBackground=!0,this.scenes=new Array,this._windowIsBackground=!1,this._runningLoop=!1,this._loadedTexturesCache=new Array,this._activeTexturesCache=new Array,this._compiledEffects={},this._depthMask=!1,this._renderingCanvas=a,this._canvasClientRect=this._renderingCanvas.getBoundingClientRect(),c=c||{},c.antialias=b;try{this._gl=a.getContext("webgl",c)||a.getContext("experimental-webgl",c)}catch(e){throw new Error("WebGL not supported")}if(!this._gl)throw new Error("WebGL not supported");this._onBlur=function(){d._windowIsBackground=!0},this._onFocus=function(){d._windowIsBackground=!1},window.addEventListener("blur",this._onBlur),window.addEventListener("focus",this._onFocus),this._workingCanvas=document.createElement("canvas"),this._workingContext=this._workingCanvas.getContext("2d"),this._hardwareScalingLevel=1/(window.devicePixelRatio||1),this.resize(),this._caps=new g,this._caps.maxTexturesImageUnits=this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),this._caps.maxTextureSize=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),this._caps.maxCubemapTextureSize=this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),this._caps.maxRenderTextureSize=this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),this._caps.standardDerivatives=null!==this._gl.getExtension("OES_standard_derivatives"),this._caps.s3tc=this._gl.getExtension("WEBGL_compressed_texture_s3tc"),this._caps.textureFloat=null!==this._gl.getExtension("OES_texture_float"),this._caps.textureAnisotropicFilterExtension=this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.instancedArrays=this._gl.getExtension("ANGLE_instanced_arrays"),this.setDepthBuffer(!0),this.setDepthFunctionToLessOrEqual(),this.setDepthWrite(!0),this._onFullscreenChange=function(){void 0!==document.fullscreen?d.isFullscreen=document.fullscreen:void 0!==document.mozFullScreen?d.isFullscreen=document.mozFullScreen:void 0!==document.webkitIsFullScreen?d.isFullscreen=document.webkitIsFullScreen:void 0!==document.msIsFullScreen&&(d.isFullscreen=document.msIsFullScreen),d.isFullscreen&&d._pointerLockRequested&&(a.requestPointerLock=a.requestPointerLock||a.msRequestPointerLock||a.mozRequestPointerLock||a.webkitRequestPointerLock,a.requestPointerLock&&a.requestPointerLock())},document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),document.addEventListener("mozfullscreenchange",this._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",this._onFullscreenChange,!1),document.addEventListener("msfullscreenchange",this._onFullscreenChange,!1),this._onPointerLockChange=function(){d.isPointerLock=document.mozPointerLockElement===a||document.webkitPointerLockElement===a||document.msPointerLockElement===a||document.pointerLockElement===a},document.addEventListener("pointerlockchange",this._onPointerLockChange,!1),document.addEventListener("mspointerlockchange",this._onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",this._onPointerLockChange,!1)}return Object.defineProperty(h,"ALPHA_DISABLE",{get:function(){return h._ALPHA_DISABLE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ALPHA_ADD",{get:function(){return h._ALPHA_ADD},enumerable:!0,configurable:!0}),Object.defineProperty(h,"ALPHA_COMBINE",{get:function(){return h._ALPHA_COMBINE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_NONE",{get:function(){return h._DELAYLOADSTATE_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_LOADED",{get:function(){return h._DELAYLOADSTATE_LOADED},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_LOADING",{get:function(){return h._DELAYLOADSTATE_LOADING},enumerable:!0,configurable:!0}),Object.defineProperty(h,"DELAYLOADSTATE_NOTLOADED",{get:function(){return h._DELAYLOADSTATE_NOTLOADED},enumerable:!0,configurable:!0}),Object.defineProperty(h,"Version",{get:function(){return"1.13.0"},enumerable:!0,configurable:!0}),h.prototype.getAspectRatio=function(a){var b=a.viewport;return this.getRenderWidth()*b.width/(this.getRenderHeight()*b.height)},h.prototype.getRenderWidth=function(){return this._currentRenderTarget?this._currentRenderTarget._width:this._renderingCanvas.width},h.prototype.getRenderHeight=function(){return this._currentRenderTarget?this._currentRenderTarget._height:this._renderingCanvas.height},h.prototype.getRenderingCanvas=function(){return this._renderingCanvas},h.prototype.getRenderingCanvasClientRect=function(){return this._renderingCanvas.getBoundingClientRect()},h.prototype.setHardwareScalingLevel=function(a){this._hardwareScalingLevel=a,this.resize()},h.prototype.getHardwareScalingLevel=function(){return this._hardwareScalingLevel},h.prototype.getLoadedTexturesCache=function(){return this._loadedTexturesCache},h.prototype.getCaps=function(){return this._caps},h.prototype.setDepthFunctionToGreater=function(){this._gl.depthFunc(this._gl.GREATER)},h.prototype.setDepthFunctionToGreaterOrEqual=function(){this._gl.depthFunc(this._gl.GEQUAL)},h.prototype.setDepthFunctionToLess=function(){this._gl.depthFunc(this._gl.LESS)},h.prototype.setDepthFunctionToLessOrEqual=function(){this._gl.depthFunc(this._gl.LEQUAL)},h.prototype.stopRenderLoop=function(){this._renderFunction=null,this._runningLoop=!1},h.prototype._renderLoop=function(){var b=this,c=!0;!this.renderEvenInBackground&&this._windowIsBackground&&(c=!1),c&&(this.beginFrame(),this._renderFunction&&this._renderFunction(),this.endFrame()),this._runningLoop&&a.Tools.QueueNewFrame(function(){b._renderLoop()})},h.prototype.runRenderLoop=function(b){var c=this;this._runningLoop=!0,this._renderFunction=b,a.Tools.QueueNewFrame(function(){c._renderLoop()})},h.prototype.switchFullscreen=function(b){this.isFullscreen?a.Tools.ExitFullscreen():(this._pointerLockRequested=b,a.Tools.RequestFullscreen(this._renderingCanvas))},h.prototype.clear=function(a,b,c){this._gl.clearColor(a.r,a.g,a.b,void 0!==a.a?a.a:1),this._depthMask&&this._gl.clearDepth(1);var d=0;b&&(d|=this._gl.COLOR_BUFFER_BIT),c&&this._depthMask&&(d|=this._gl.DEPTH_BUFFER_BIT),this._gl.clear(d)},h.prototype.setViewport=function(a,b,c){var d=b||this._renderingCanvas.width,e=c||this._renderingCanvas.height,f=a.x||0,g=a.y||0;this._cachedViewport=a,this._gl.viewport(f*d,g*e,d*a.width,e*a.height)},h.prototype.setDirectViewport=function(a,b,c,d){this._cachedViewport=null,this._gl.viewport(a,b,c,d)},h.prototype.beginFrame=function(){a.Tools._MeasureFps()},h.prototype.endFrame=function(){this.flushFramebuffer()},h.prototype.resize=function(){this._renderingCanvas.width=this._renderingCanvas.clientWidth/this._hardwareScalingLevel,this._renderingCanvas.height=this._renderingCanvas.clientHeight/this._hardwareScalingLevel,this._canvasClientRect=this._renderingCanvas.getBoundingClientRect()},h.prototype.bindFramebuffer=function(a){this._currentRenderTarget=a;var b=this._gl;b.bindFramebuffer(b.FRAMEBUFFER,a._framebuffer),this._gl.viewport(0,0,a._width,a._height),this.wipeCaches()},h.prototype.unBindFramebuffer=function(a){if(this._currentRenderTarget=null,a.generateMipMaps){var b=this._gl;b.bindTexture(b.TEXTURE_2D,a),b.generateMipmap(b.TEXTURE_2D),b.bindTexture(b.TEXTURE_2D,null)}this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,null)},h.prototype.flushFramebuffer=function(){this._gl.flush()},h.prototype.restoreDefaultFramebuffer=function(){this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,null),this.setViewport(this._cachedViewport),this.wipeCaches()},h.prototype._resetVertexBufferBinding=function(){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,null),this._cachedVertexBuffers=null},h.prototype.createVertexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(a),this._gl.STATIC_DRAW),this._resetVertexBufferBinding(),b.references=1,b},h.prototype.createDynamicVertexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,a,this._gl.DYNAMIC_DRAW),this._resetVertexBufferBinding(),b.references=1,b},h.prototype.updateDynamicVertexBuffer=function(a,b){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a),b instanceof Float32Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,b):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,new Float32Array(b)),this._resetVertexBufferBinding()},h.prototype._resetIndexBufferBinding=function(){this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,null),this._cachedIndexBuffer=null},h.prototype.createIndexBuffer=function(a){var b=this._gl.createBuffer();return this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),b.references=1,b},h.prototype.bindBuffers=function(a,b,c,d,e){if(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==e){this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=e,this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a);for(var f=0,g=0;g<c.length;g++){var h=e.getAttributeLocation(g);h>=0&&this._gl.vertexAttribPointer(h,c[g],this._gl.FLOAT,!1,d,f),f+=4*c[g]}}this._cachedIndexBuffer!==b&&(this._cachedIndexBuffer=b,this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b))},h.prototype.bindMultiBuffers=function(a,b,c){if(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==c){this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=c;for(var d=c.getAttributesNames(),e=0;e<d.length;e++){var f=c.getAttributeLocation(e);if(f>=0){var g=a[d[e]];if(!g)continue;var h=g.getStrideSize();this._gl.bindBuffer(this._gl.ARRAY_BUFFER,g.getBuffer()),this._gl.vertexAttribPointer(f,h,this._gl.FLOAT,!1,4*h,0)}}}this._cachedIndexBuffer!==b&&(this._cachedIndexBuffer=b,this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,b))},h.prototype._releaseBuffer=function(a){return a.references--,0===a.references?(this._gl.deleteBuffer(a),!0):!1},h.prototype.createInstancesBuffer=function(a){var b=this._gl.createBuffer();return b.capacity=a,this._gl.bindBuffer(this._gl.ARRAY_BUFFER,b),this._gl.bufferData(this._gl.ARRAY_BUFFER,a,this._gl.DYNAMIC_DRAW),b},h.prototype.deleteInstancesBuffer=function(a){this._gl.deleteBuffer(a)},h.prototype.updateAndBindInstancesBuffer=function(a,b,c){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,b);for(var d=0;4>d;d++){var e=c[d];this._gl.enableVertexAttribArray(e),this._gl.vertexAttribPointer(e,4,this._gl.FLOAT,!1,64,16*d),this._caps.instancedArrays.vertexAttribDivisorANGLE(e,1)}},h.prototype.unBindInstancesBuffer=function(a,b){this._gl.bindBuffer(this._gl.ARRAY_BUFFER,a);for(var c=0;4>c;c++){var d=b[c];this._gl.disableVertexAttribArray(d),this._caps.instancedArrays.vertexAttribDivisorANGLE(d,0)}},h.prototype.draw=function(a,b,c,d){return d?void this._caps.instancedArrays.drawElementsInstancedANGLE(a?this._gl.TRIANGLES:this._gl.LINES,c,this._gl.UNSIGNED_SHORT,2*b,d):void this._gl.drawElements(a?this._gl.TRIANGLES:this._gl.LINES,c,this._gl.UNSIGNED_SHORT,2*b)},h.prototype._releaseEffect=function(a){this._compiledEffects[a._key]&&(delete this._compiledEffects[a._key],a.getProgram()&&this._gl.deleteProgram(a.getProgram()))},h.prototype.createEffect=function(b,c,d,e,f,g,h,i){var j=b.vertexElement||b.vertex||b,k=b.fragmentElement||b.fragment||b,l=j+"+"+k+"@"+f;if(this._compiledEffects[l])return this._compiledEffects[l];var m=new a.Effect(b,c,d,e,this,f,g,h,i);return m._key=l,this._compiledEffects[l]=m,m},h.prototype.createShaderProgram=function(a,c,d){var e=b(this._gl,a,"vertex",d),f=b(this._gl,c,"fragment",d),g=this._gl.createProgram();this._gl.attachShader(g,e),this._gl.attachShader(g,f),this._gl.linkProgram(g);var h=this._gl.getProgramParameter(g,this._gl.LINK_STATUS);if(!h){var i=this._gl.getProgramInfoLog(g);if(i)throw new Error(i)}return this._gl.deleteShader(e),this._gl.deleteShader(f),g},h.prototype.getUniforms=function(a,b){for(var c=[],d=0;d<b.length;d++)c.push(this._gl.getUniformLocation(a,b[d]));return c},h.prototype.getAttributes=function(a,b){for(var c=[],d=0;d<b.length;d++)try{c.push(this._gl.getAttribLocation(a,b[d]))}catch(e){c.push(-1)}return c},h.prototype.enableEffect=function(a){if(a&&a.getAttributesCount()&&this._currentEffect!==a){this._vertexAttribArrays=this._vertexAttribArrays||[],this._gl.useProgram(a.getProgram());for(var b in this._vertexAttribArrays)b>this._gl.VERTEX_ATTRIB_ARRAY_ENABLED||!this._vertexAttribArrays[b]||(this._vertexAttribArrays[b]=!1,this._gl.disableVertexAttribArray(b));for(var c=a.getAttributesCount(),d=0;c>d;d++){var e=a.getAttributeLocation(d);e>=0&&(this._vertexAttribArrays[e]=!0,this._gl.enableVertexAttribArray(e))}this._currentEffect=a}},h.prototype.setArray=function(a,b){a&&this._gl.uniform1fv(a,b)},h.prototype.setMatrices=function(a,b){a&&this._gl.uniformMatrix4fv(a,!1,b)},h.prototype.setMatrix=function(a,b){a&&this._gl.uniformMatrix4fv(a,!1,b.toArray())},h.prototype.setFloat=function(a,b){a&&this._gl.uniform1f(a,b)},h.prototype.setFloat2=function(a,b,c){a&&this._gl.uniform2f(a,b,c)},h.prototype.setFloat3=function(a,b,c,d){a&&this._gl.uniform3f(a,b,c,d)},h.prototype.setBool=function(a,b){a&&this._gl.uniform1i(a,b)},h.prototype.setFloat4=function(a,b,c,d,e){a&&this._gl.uniform4f(a,b,c,d,e)},h.prototype.setColor3=function(a,b){a&&this._gl.uniform3f(a,b.r,b.g,b.b)},h.prototype.setColor4=function(a,b,c){a&&this._gl.uniform4f(a,b.r,b.g,b.b,c)},h.prototype.setState=function(a){this._cullingState!==a&&(a?(this._gl.cullFace(this.cullBackFaces?this._gl.BACK:this._gl.FRONT),this._gl.enable(this._gl.CULL_FACE)):this._gl.disable(this._gl.CULL_FACE),this._cullingState=a)},h.prototype.setDepthBuffer=function(a){a?this._gl.enable(this._gl.DEPTH_TEST):this._gl.disable(this._gl.DEPTH_TEST)},h.prototype.setDepthWrite=function(a){this._gl.depthMask(a),this._depthMask=a},h.prototype.setColorWrite=function(a){this._gl.colorMask(a,a,a,a)},h.prototype.setAlphaMode=function(b){switch(b){case a.Engine.ALPHA_DISABLE:this.setDepthWrite(!0),this._gl.disable(this._gl.BLEND);break;case a.Engine.ALPHA_COMBINE:this.setDepthWrite(!1),this._gl.blendFuncSeparate(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._gl.enable(this._gl.BLEND);break;case a.Engine.ALPHA_ADD:this.setDepthWrite(!1),this._gl.blendFuncSeparate(this._gl.ONE,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._gl.enable(this._gl.BLEND)}},h.prototype.setAlphaTesting=function(a){this._alphaTest=a},h.prototype.getAlphaTesting=function(){return this._alphaTest},h.prototype.wipeCaches=function(){this._activeTexturesCache=[],this._currentEffect=null,this._cullingState=null,this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null},h.prototype.setSamplingMode=function(b,c){var d=this._gl;d.bindTexture(d.TEXTURE_2D,b);var e=d.NEAREST,f=d.NEAREST;c===a.Texture.BILINEAR_SAMPLINGMODE?(e=d.LINEAR,f=d.LINEAR):c===a.Texture.TRILINEAR_SAMPLINGMODE&&(e=d.LINEAR,f=d.LINEAR_MIPMAP_LINEAR),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,e),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,f),d.bindTexture(d.TEXTURE_2D,null)},h.prototype.createTexture=function(b,c,d,f,g){var h=this;"undefined"==typeof g&&(g=a.Texture.TRILINEAR_SAMPLINGMODE);var i=this._gl.createTexture(),j=b.substr(b.length-4,4).toLowerCase(),k=this.getCaps().s3tc&&".dds"===j,l=".tga"===j;if(f._addPendingData(i),i.url=b,i.noMipmap=c,i.references=1,this._loadedTexturesCache.push(i),l)a.Tools.LoadFile(b,function(b){var j=new Uint8Array(b),k=a.Internals.TGATools.GetTGAHeader(j);e(i,h._gl,f,k.width,k.height,d,c,!1,function(){a.Internals.TGATools.UploadContent(h._gl,j)},g)},null,f.database,!0);else if(k)a.Tools.LoadFile(b,function(j){var k=a.Internals.DDSTools.GetDDSInfo(j),l=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&!c&&k.width>>k.mipmapCount-1==1;e(i,h._gl,f,k.width,k.height,d,!l,k.isFourCC,function(){console.log("loading "+b),a.Internals.DDSTools.UploadDDSLevels(h._gl,h.getCaps().s3tc,j,k,l,1)},g)},null,f.database,!0);else{var m=function(a){e(i,h._gl,f,a.width,a.height,d,c,!1,function(b,c){var d=a.width==b&&a.height==c;d||(h._workingCanvas.width=b,h._workingCanvas.height=c,h._workingContext.drawImage(a,0,0,a.width,a.height,0,0,b,c)),h._gl.texImage2D(h._gl.TEXTURE_2D,0,h._gl.RGBA,h._gl.RGBA,h._gl.UNSIGNED_BYTE,d?a:h._workingCanvas)},g)},n=function(){f._removePendingData(i)};a.Tools.LoadImage(b,m,n,f.database)}return i},h.prototype.createDynamicTexture=function(a,b,e,f){var g=this._gl.createTexture();a=d(a,this._caps.maxTextureSize),b=d(b,this._caps.maxTextureSize),this._gl.bindTexture(this._gl.TEXTURE_2D,g);var h=c(f,e,this._gl);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,h.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,h.min),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],g._baseWidth=a,g._baseHeight=b,g._width=a,g._height=b,g.isReady=!1,g.generateMipMaps=e,g.references=1,this._loadedTexturesCache.push(g),g},h.prototype.updateDynamicTexture=function(a,b,c){this._gl.bindTexture(this._gl.TEXTURE_2D,a),this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,c?1:0),this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,b),a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],a.isReady=!0},h.prototype.updateVideoTexture=function(a,b,c){this._gl.bindTexture(this._gl.TEXTURE_2D,a),this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,c?0:1),b.videoWidth!==a._width||b.videoHeight!==a._height?(a._workingCanvas||(a._workingCanvas=document.createElement("canvas"),a._workingContext=a._workingCanvas.getContext("2d"),a._workingCanvas.width=a._width,a._workingCanvas.height=a._height),a._workingContext.drawImage(b,0,0,b.videoWidth,b.videoHeight,0,0,a._width,a._height),this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,a._workingCanvas)):this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._gl.RGBA,this._gl.UNSIGNED_BYTE,b),a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._activeTexturesCache=[],a.isReady=!0},h.prototype.createRenderTargetTexture=function(b,d){var e=!1,f=!0,g=a.Texture.TRILINEAR_SAMPLINGMODE;void 0!==d&&(e=void 0===d.generateMipMaps?d:d.generateMipmaps,f=void 0===d.generateDepthBuffer?!0:d.generateDepthBuffer,void 0!==d.samplingMode&&(g=d.samplingMode));var h=this._gl,i=h.createTexture();h.bindTexture(h.TEXTURE_2D,i);var j=b.width||b,k=b.height||b,l=c(g,e,h);h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,l.mag),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,l.min),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE),h.texImage2D(h.TEXTURE_2D,0,h.RGBA,j,k,0,h.RGBA,h.UNSIGNED_BYTE,null);var m;f&&(m=h.createRenderbuffer(),h.bindRenderbuffer(h.RENDERBUFFER,m),h.renderbufferStorage(h.RENDERBUFFER,h.DEPTH_COMPONENT16,j,k));var n=h.createFramebuffer();return h.bindFramebuffer(h.FRAMEBUFFER,n),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,i,0),f&&h.framebufferRenderbuffer(h.FRAMEBUFFER,h.DEPTH_ATTACHMENT,h.RENDERBUFFER,m),h.bindTexture(h.TEXTURE_2D,null),h.bindRenderbuffer(h.RENDERBUFFER,null),h.bindFramebuffer(h.FRAMEBUFFER,null),i._framebuffer=n,f&&(i._depthBuffer=m),i._width=j,i._height=k,i.isReady=!0,i.generateMipMaps=e,i.references=1,this._activeTexturesCache=[],this._loadedTexturesCache.push(i),i},h.prototype.createCubeTexture=function(b,c,e,g){var h=this,i=this._gl,j=i.createTexture();j.isCube=!0,j.url=b,j.references=1,this._loadedTexturesCache.push(j);var k=b.substr(b.length-4,4).toLowerCase(),l=this.getCaps().s3tc&&".dds"===k;return l?a.Tools.LoadFile(b,function(b){var c=a.Internals.DDSTools.GetDDSInfo(b),d=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&!g;i.bindTexture(i.TEXTURE_CUBE_MAP,j),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),a.Internals.DDSTools.UploadDDSLevels(h._gl,h.getCaps().s3tc,b,c,d,6),g||c.isFourCC||1!=c.mipmapCount||i.generateMipmap(i.TEXTURE_CUBE_MAP),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,d?i.LINEAR_MIPMAP_LINEAR:i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.bindTexture(i.TEXTURE_CUBE_MAP,null),h._activeTexturesCache=[],j._width=c.width,j._height=c.height,j.isReady=!0}):f(b,0,[],c,function(a){var b=d(a[0].width,h._caps.maxCubemapTextureSize),c=b;h._workingCanvas.width=b,h._workingCanvas.height=c;var e=[i.TEXTURE_CUBE_MAP_POSITIVE_X,i.TEXTURE_CUBE_MAP_POSITIVE_Y,i.TEXTURE_CUBE_MAP_POSITIVE_Z,i.TEXTURE_CUBE_MAP_NEGATIVE_X,i.TEXTURE_CUBE_MAP_NEGATIVE_Y,i.TEXTURE_CUBE_MAP_NEGATIVE_Z];i.bindTexture(i.TEXTURE_CUBE_MAP,j),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,0);for(var f=0;f<e.length;f++)h._workingContext.drawImage(a[f],0,0,a[f].width,a[f].height,0,0,b,c),i.texImage2D(e[f],0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,h._workingCanvas);g||i.generateMipmap(i.TEXTURE_CUBE_MAP),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,g?i.LINEAR:i.LINEAR_MIPMAP_LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.bindTexture(i.TEXTURE_CUBE_MAP,null),h._activeTexturesCache=[],j._width=b,j._height=c,j.isReady=!0},e),j},h.prototype._releaseTexture=function(a){var b=this._gl;a._framebuffer&&b.deleteFramebuffer(a._framebuffer),a._depthBuffer&&b.deleteRenderbuffer(a._depthBuffer),b.deleteTexture(a);for(var c=0;c<this._caps.maxTexturesImageUnits;c++)this._gl.activeTexture(this._gl["TEXTURE"+c]),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,null),this._activeTexturesCache[c]=null;var d=this._loadedTexturesCache.indexOf(a);-1!==d&&this._loadedTexturesCache.splice(d,1)},h.prototype.bindSamplers=function(a){this._gl.useProgram(a.getProgram());for(var b=a.getSamplers(),c=0;c<b.length;c++){var d=a.getUniform(b[c]);this._gl.uniform1i(d,c)}this._currentEffect=null},h.prototype._bindTexture=function(a,b){this._gl.activeTexture(this._gl["TEXTURE"+a]),this._gl.bindTexture(this._gl.TEXTURE_2D,b),this._activeTexturesCache[a]=null},h.prototype.setTextureFromPostProcess=function(a,b){this._bindTexture(a,b._textures.data[b._currentRenderTextureInd])},h.prototype.setTexture=function(b,c){if(!(0>b)){if(!c||!c.isReady())return void(null!=this._activeTexturesCache[b]&&(this._gl.activeTexture(this._gl["TEXTURE"+b]),this._gl.bindTexture(this._gl.TEXTURE_2D,null),this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,null),this._activeTexturesCache[b]=null));if(c instanceof a.VideoTexture)c.update()&&(this._activeTexturesCache[b]=null);else if(c.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED)return void c.delayLoad();if(this._activeTexturesCache[b]!=c){this._activeTexturesCache[b]=c;var d=c.getInternalTexture();if(this._gl.activeTexture(this._gl["TEXTURE"+b]),d.isCube){if(this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP,d),d._cachedCoordinatesMode!==c.coordinatesMode){d._cachedCoordinatesMode=c.coordinatesMode;var e=c.coordinatesMode!==a.Texture.CUBIC_MODE&&c.coordinatesMode!==a.Texture.SKYBOX_MODE?this._gl.REPEAT:this._gl.CLAMP_TO_EDGE;this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP,this._gl.TEXTURE_WRAP_S,e),this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP,this._gl.TEXTURE_WRAP_T,e)}this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP,c)}else{if(this._gl.bindTexture(this._gl.TEXTURE_2D,d),d._cachedWrapU!==c.wrapU)switch(d._cachedWrapU=c.wrapU,c.wrapU){case a.Texture.WRAP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.REPEAT);break;case a.Texture.CLAMP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE);break;case a.Texture.MIRROR_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.MIRRORED_REPEAT)}if(d._cachedWrapV!==c.wrapV)switch(d._cachedWrapV=c.wrapV,c.wrapV){case a.Texture.WRAP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.REPEAT);break;case a.Texture.CLAMP_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);break;case a.Texture.MIRROR_ADDRESSMODE:this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.MIRRORED_REPEAT)
}this._setAnisotropicLevel(this._gl.TEXTURE_2D,c)}}}},h.prototype._setAnisotropicLevel=function(a,b){var c=this._caps.textureAnisotropicFilterExtension;c&&b._cachedAnisotropicFilteringLevel!==b.anisotropicFilteringLevel&&(this._gl.texParameterf(a,c.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropicFilteringLevel,this._caps.maxAnisotropy)),b._cachedAnisotropicFilteringLevel=b.anisotropicFilteringLevel)},h.prototype.readPixels=function(a,b,c,d){var e=new Uint8Array(d*c*4);return this._gl.readPixels(0,0,c,d,this._gl.RGBA,this._gl.UNSIGNED_BYTE,e),e},h.prototype.dispose=function(){for(this.stopRenderLoop();this.scenes.length;)this.scenes[0].dispose();for(var a in this._compiledEffects)this._gl.deleteProgram(this._compiledEffects[a]._program);for(var b in this._vertexAttribArrays)b>this._gl.VERTEX_ATTRIB_ARRAY_ENABLED||!this._vertexAttribArrays[b]||this._gl.disableVertexAttribArray(b);window.removeEventListener("blur",this._onBlur),window.removeEventListener("focus",this._onFocus),document.removeEventListener("fullscreenchange",this._onFullscreenChange),document.removeEventListener("mozfullscreenchange",this._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",this._onFullscreenChange),document.removeEventListener("msfullscreenchange",this._onFullscreenChange),document.removeEventListener("pointerlockchange",this._onPointerLockChange),document.removeEventListener("mspointerlockchange",this._onPointerLockChange),document.removeEventListener("mozpointerlockchange",this._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",this._onPointerLockChange)},h.isSupported=function(){try{var a=document.createElement("canvas"),b=a.getContext("webgl")||a.getContext("experimental-webgl");return null!=b&&!!window.WebGLRenderingContext}catch(c){return!1}},h._ALPHA_DISABLE=0,h._ALPHA_ADD=1,h._ALPHA_COMBINE=2,h._DELAYLOADSTATE_NONE=0,h._DELAYLOADSTATE_LOADED=1,h._DELAYLOADSTATE_LOADING=2,h._DELAYLOADSTATE_NOTLOADED=4,h.Epsilon=.001,h.CollisionsEpsilon=.001,h.ShadersRepository="Babylon/Shaders/",h}();a.Engine=h}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b){this.state="",this.animations=new Array,this._childrenFlag=-1,this._isEnabled=!0,this._isReady=!0,this._currentRenderId=-1,this.name=a,this.id=a,this._scene=b,this._initCache()}return b.prototype.getScene=function(){return this._scene},b.prototype.getEngine=function(){return this._scene.getEngine()},b.prototype.getWorldMatrix=function(){return a.Matrix.Identity()},b.prototype._initCache=function(){this._cache={},this._cache.parent=void 0},b.prototype.updateCache=function(a){(a||!this.isSynchronized())&&(this._cache.parent=this.parent,this._updateCache())},b.prototype._updateCache=function(){},b.prototype._isSynchronized=function(){return!0},b.prototype.isSynchronizedWithParent=function(){return this.parent?this.parent._currentRenderId<=this._currentRenderId:!0},b.prototype.isSynchronized=function(a){var b=this.hasNewParent();return b=b||!this.isSynchronizedWithParent(),b=b||!this._isSynchronized(),a&&this.updateCache(!0),!b},b.prototype.hasNewParent=function(a){return this._cache.parent===this.parent?!1:(a&&(this._cache.parent=this.parent),!0)},b.prototype.isReady=function(){return this._isReady},b.prototype.isEnabled=function(){return this._isEnabled?this.parent?this.parent.isEnabled():!0:!1},b.prototype.setEnabled=function(a){this._isEnabled=a},b.prototype.isDescendantOf=function(a){return this.parent?this.parent===a?!0:this.parent.isDescendantOf(a):!1},b.prototype._getDescendants=function(a,b){for(var c=0;c<a.length;c++){var d=a[c];d.isDescendantOf(this)&&b.push(d)}},b.prototype.getDescendants=function(){var a=[];return this._getDescendants(this._scene.meshes,a),this._getDescendants(this._scene.lights,a),this._getDescendants(this._scene.cameras,a),a},b.prototype._setReady=function(a){if(a!=this._isReady){if(!a)return void(this._isReady=!1);this._isReady=!0,this.onReady&&this.onReady(this)}},b}();a.Node=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.minimum=b,this.maximum=c,this._tempRadiusVector=a.Vector3.Zero();var d=a.Vector3.Distance(b,c);this.center=a.Vector3.Lerp(b,c,.5),this.radius=.5*d,this.centerWorld=a.Vector3.Zero(),this._update(a.Matrix.Identity())}return b.prototype._update=function(b){a.Vector3.TransformCoordinatesToRef(this.center,b,this.centerWorld),a.Vector3.TransformNormalFromFloatsToRef(1,1,1,b,this._tempRadiusVector),this.radiusWorld=Math.max(Math.abs(this._tempRadiusVector.x),Math.abs(this._tempRadiusVector.y),Math.abs(this._tempRadiusVector.z))*this.radius},b.prototype.isInFrustum=function(a){for(var b=0;6>b;b++)if(a[b].dotCoordinate(this.centerWorld)<=-this.radiusWorld)return!1;return!0},b.prototype.intersectsPoint=function(b){var c=this.centerWorld.x-b.x,d=this.centerWorld.y-b.y,e=this.centerWorld.z-b.z,f=Math.sqrt(c*c+d*d+e*e);return Math.abs(this.radiusWorld-f)<a.Engine.Epsilon?!1:!0},b.Intersects=function(a,b){var c=a.centerWorld.x-b.centerWorld.x,d=a.centerWorld.y-b.centerWorld.y,e=a.centerWorld.z-b.centerWorld.z,f=Math.sqrt(c*c+d*d+e*e);return a.radiusWorld+b.radiusWorld<f?!1:!0},b}();a.BoundingSphere=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.minimum=b,this.maximum=c,this.vectors=new Array,this.vectorsWorld=new Array,this.vectors.push(this.minimum.clone()),this.vectors.push(this.maximum.clone()),this.vectors.push(this.minimum.clone()),this.vectors[2].x=this.maximum.x,this.vectors.push(this.minimum.clone()),this.vectors[3].y=this.maximum.y,this.vectors.push(this.minimum.clone()),this.vectors[4].z=this.maximum.z,this.vectors.push(this.maximum.clone()),this.vectors[5].z=this.minimum.z,this.vectors.push(this.maximum.clone()),this.vectors[6].x=this.minimum.x,this.vectors.push(this.maximum.clone()),this.vectors[7].y=this.minimum.y,this.center=this.maximum.add(this.minimum).scale(.5),this.extends=this.maximum.subtract(this.minimum).scale(.5),this.directions=[a.Vector3.Zero(),a.Vector3.Zero(),a.Vector3.Zero()];for(var d=0;d<this.vectors.length;d++)this.vectorsWorld[d]=a.Vector3.Zero();this.minimumWorld=a.Vector3.Zero(),this.maximumWorld=a.Vector3.Zero(),this._update(a.Matrix.Identity())}return b.prototype.getWorldMatrix=function(){return this._worldMatrix},b.prototype._update=function(b){a.Vector3.FromFloatsToRef(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,this.minimumWorld),a.Vector3.FromFloatsToRef(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,this.maximumWorld);for(var c=0;c<this.vectors.length;c++){var d=this.vectorsWorld[c];a.Vector3.TransformCoordinatesToRef(this.vectors[c],b,d),d.x<this.minimumWorld.x&&(this.minimumWorld.x=d.x),d.y<this.minimumWorld.y&&(this.minimumWorld.y=d.y),d.z<this.minimumWorld.z&&(this.minimumWorld.z=d.z),d.x>this.maximumWorld.x&&(this.maximumWorld.x=d.x),d.y>this.maximumWorld.y&&(this.maximumWorld.y=d.y),d.z>this.maximumWorld.z&&(this.maximumWorld.z=d.z)}this.maximumWorld.addToRef(this.minimumWorld,this.center),this.center.scaleInPlace(.5),a.Vector3.FromFloatArrayToRef(b.m,0,this.directions[0]),a.Vector3.FromFloatArrayToRef(b.m,4,this.directions[1]),a.Vector3.FromFloatArrayToRef(b.m,8,this.directions[2]),this._worldMatrix=b},b.prototype.isInFrustum=function(a){return b.IsInFrustum(this.vectorsWorld,a)},b.prototype.intersectsPoint=function(b){var c=a.Engine.Epsilon;return this.maximumWorld.x-b.x<c||c>b.x-this.minimumWorld.x?!1:this.maximumWorld.y-b.y<c||c>b.y-this.minimumWorld.y?!1:this.maximumWorld.z-b.z<c||c>b.z-this.minimumWorld.z?!1:!0},b.prototype.intersectsSphere=function(a){return b.IntersectsSphere(this.minimumWorld,this.maximumWorld,a.centerWorld,a.radiusWorld)},b.prototype.intersectsMinMax=function(a,b){return this.maximumWorld.x<a.x||this.minimumWorld.x>b.x?!1:this.maximumWorld.y<a.y||this.minimumWorld.y>b.y?!1:this.maximumWorld.z<a.z||this.minimumWorld.z>b.z?!1:!0},b.Intersects=function(a,b){return a.maximumWorld.x<b.minimumWorld.x||a.minimumWorld.x>b.maximumWorld.x?!1:a.maximumWorld.y<b.minimumWorld.y||a.minimumWorld.y>b.maximumWorld.y?!1:a.maximumWorld.z<b.minimumWorld.z||a.minimumWorld.z>b.maximumWorld.z?!1:!0},b.IntersectsSphere=function(b,c,d,e){var f=a.Vector3.Clamp(d,b,c),g=a.Vector3.DistanceSquared(d,f);return e*e>=g},b.IsInFrustum=function(a,b){for(var c=0;6>c;c++){for(var d=8,e=0;8>e&&b[c].dotCoordinate(a[e])<0;e++)--d;if(0==d)return!1}return!0},b}();a.BoundingBox=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(b,c){var d=a.Vector3.Dot(c.center,b),e=Math.abs(a.Vector3.Dot(c.directions[0],b))*c.extends.x,f=Math.abs(a.Vector3.Dot(c.directions[1],b))*c.extends.y,g=Math.abs(a.Vector3.Dot(c.directions[2],b))*c.extends.z,h=e+f+g;return{min:d-h,max:d+h}},c=function(a,b,c,d){return!(a>d||c>b)},d=function(a,d,e){var f=b(a,d),g=b(a,e);return c(f.min,f.max,g.min,g.max)},e=function(){function b(b,c){this.minimum=b,this.maximum=c,this.boundingBox=new a.BoundingBox(b,c),this.boundingSphere=new a.BoundingSphere(b,c)}return b.prototype._update=function(a){this.boundingBox._update(a),this.boundingSphere._update(a)},b.prototype.isInFrustum=function(a){return this.boundingSphere.isInFrustum(a)?this.boundingBox.isInFrustum(a):!1},b.prototype._checkCollision=function(a){return a._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)},b.prototype.intersectsPoint=function(a){return this.boundingSphere.centerWorld&&this.boundingSphere.intersectsPoint(a)&&this.boundingBox.intersectsPoint(a)?!0:!1},b.prototype.intersects=function(b,c){if(!this.boundingSphere.centerWorld||!b.boundingSphere.centerWorld)return!1;if(!a.BoundingSphere.Intersects(this.boundingSphere,b.boundingSphere))return!1;if(!a.BoundingBox.Intersects(this.boundingBox,b.boundingBox))return!1;if(!c)return!0;var e=this.boundingBox,f=b.boundingBox;return d(e.directions[0],e,f)&&d(e.directions[1],e,f)&&d(e.directions[2],e,f)&&d(f.directions[0],e,f)&&d(f.directions[1],e,f)&&d(f.directions[2],e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[0],f.directions[2]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[1],f.directions[2]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[0]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[1]),e,f)&&d(a.Vector3.Cross(e.directions[2],f.directions[2]),e,f)?!0:!1},b}();a.BoundingInfo=e}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.diffuse=new a.Color3(1,1,1),this.specular=new a.Color3(1,1,1),this.intensity=1,this.range=Number.MAX_VALUE,this.excludedMeshes=new Array,this._excludedMeshesIds=new Array,d.lights.push(this)}return __extends(c,b),c.prototype.getShadowGenerator=function(){return this._shadowGenerator},c.prototype.transferToEffect=function(){},c.prototype._getWorldMatrix=function(){return a.Matrix.Identity()},c.prototype.getWorldMatrix=function(){this._currentRenderId=this.getScene().getRenderId();var b=this._getWorldMatrix();return this.parent&&this.parent.getWorldMatrix?(this._parentedWorldMatrix||(this._parentedWorldMatrix=a.Matrix.Identity()),b.multiplyToRef(this.parent.getWorldMatrix(),this._parentedWorldMatrix),this._parentedWorldMatrix):b},c.prototype.dispose=function(){this._shadowGenerator&&(this._shadowGenerator.dispose(),this._shadowGenerator=null);var a=this.getScene().lights.indexOf(this);this.getScene().lights.splice(a,1)},c}(a.Node);a.Light=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,d),this.position=c}return __extends(c,b),c.prototype.transferToEffect=function(b,c){return this.parent&&this.parent.getWorldMatrix?(this._transformedPosition||(this._transformedPosition=a.Vector3.Zero()),a.Vector3.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._transformedPosition),void b.setFloat4(c,this._transformedPosition.x,this._transformedPosition.y,this._transformedPosition.z,0)):void b.setFloat4(c,this.position.x,this.position.y,this.position.z,0)},c.prototype.getShadowGenerator=function(){return null},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.PointLight=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d,e,f,g){b.call(this,a,g),this.position=c,this.direction=d,this.angle=e,this.exponent=f}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(this.position)),this.direction},c.prototype.transferToEffect=function(b,c,d){var e;if(this.parent&&this.parent.getWorldMatrix){this._transformedDirection||(this._transformedDirection=a.Vector3.Zero()),this._transformedPosition||(this._transformedPosition=a.Vector3.Zero());var f=this.parent.getWorldMatrix();a.Vector3.TransformCoordinatesToRef(this.position,f,this._transformedPosition),a.Vector3.TransformNormalToRef(this.direction,f,this._transformedDirection),b.setFloat4(c,this._transformedPosition.x,this._transformedPosition.y,this._transformedPosition.z,this.exponent),e=a.Vector3.Normalize(this._transformedDirection)}else b.setFloat4(c,this.position.x,this.position.y,this.position.z,this.exponent),e=a.Vector3.Normalize(this.direction);b.setFloat4(d,e.x,e.y,e.z,Math.cos(.5*this.angle))},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.SpotLight=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,d),this.direction=c,this.position=c.scale(-1)}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(this.position)),this.direction},c.prototype._computeTransformedPosition=function(){return this.parent&&this.parent.getWorldMatrix?(this._transformedPosition||(this._transformedPosition=a.Vector3.Zero()),a.Vector3.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._transformedPosition),!0):!1},c.prototype.transferToEffect=function(b,c){return this.parent&&this.parent.getWorldMatrix?(this._transformedDirection||(this._transformedDirection=a.Vector3.Zero()),a.Vector3.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this._transformedDirection),void b.setFloat4(c,this._transformedDirection.x,this._transformedDirection.y,this._transformedDirection.z,1)):void b.setFloat4(c,this.direction.x,this.direction.y,this.direction.z,1)},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this._worldMatrix},c}(a.Light);a.DirectionalLight=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(c,d){var e=this;this.filter=b.FILTER_VARIANCESHADOWMAP,this._darkness=0,this._transparencyShadow=!1,this._viewMatrix=a.Matrix.Zero(),this._projectionMatrix=a.Matrix.Zero(),this._transformMatrix=a.Matrix.Zero(),this._worldViewProjection=a.Matrix.Zero(),this._light=d,this._scene=d.getScene(),d._shadowGenerator=this,this._shadowMap=new a.RenderTargetTexture(d.name+"_shadowMap",c,this._scene,!1),this._shadowMap.wrapU=a.Texture.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._shadowMap.renderParticles=!1;var f=function(b){var c=b.getRenderingMesh(),d=e._scene,f=d.getEngine();f.setState(b.getMaterial().backFaceCulling);var g=c._getInstancesRenderList(b._id);if(!g.mustReturn){var h=null!==f.getCaps().instancedArrays&&null!==g.visibleInstances;if(e.isReady(b,h)){f.enableEffect(e._effect),c._bind(b,e._effect,!1);var i=b.getMaterial();if(e._effect.setMatrix("viewProjection",e.getTransformMatrix()),i&&i.needAlphaTesting()){var j=i.getAlphaTestTexture();e._effect.setTexture("diffuseSampler",j),e._effect.setMatrix("diffuseMatrix",j.getTextureMatrix())}var k=c.skeleton&&c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind);if(k&&e._effect.setMatrices("mBones",c.skeleton.getTransformMatrices()),h)c._renderWithInstances(b,!1,g,e._effect,f);else if(g.renderSelf[b._id]&&(e._effect.setMatrix("world",c.getWorldMatrix()),c._draw(b,!0)),g.visibleInstances[b._id])for(var l=0;l<g.visibleInstances[b._id].length;l++){var m=g.visibleInstances[b._id][l];e._effect.setMatrix("world",m.getWorldMatrix()),c._draw(b,!0)}}else e._shadowMap.resetRefreshCounter()}};this._shadowMap.customRenderFunction=function(a,b,c){var d;for(d=0;d<a.length;d++)f(a.data[d]);for(d=0;d<b.length;d++)f(b.data[d]);if(e._transparencyShadow)for(d=0;d<c.length;d++)f(c.data[d])}}return Object.defineProperty(b,"FILTER_NONE",{get:function(){return b._FILTER_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"FILTER_VARIANCESHADOWMAP",{get:function(){return b._FILTER_VARIANCESHADOWMAP},enumerable:!0,configurable:!0}),Object.defineProperty(b,"FILTER_POISSONSAMPLING",{get:function(){return b._FILTER_POISSONSAMPLING},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"useVarianceShadowMap",{get:function(){return this.filter===b.FILTER_VARIANCESHADOWMAP},set:function(a){this.filter=a?b.FILTER_VARIANCESHADOWMAP:b.FILTER_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"usePoissonSampling",{get:function(){return this.filter===b.FILTER_POISSONSAMPLING},set:function(a){this.filter=a?b.FILTER_POISSONSAMPLING:b.FILTER_NONE},enumerable:!0,configurable:!0}),b.prototype.isReady=function(b,c){var d=[];this.useVarianceShadowMap&&d.push("#define VSM");var e=[a.VertexBuffer.PositionKind],f=b.getMesh(),g=b.getMaterial();g&&g.needAlphaTesting()&&(d.push("#define ALPHATEST"),f.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(e.push(a.VertexBuffer.UVKind),d.push("#define UV1")),f.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(e.push(a.VertexBuffer.UV2Kind),d.push("#define UV2"))),f.skeleton&&f.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&f.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(e.push(a.VertexBuffer.MatricesIndicesKind),e.push(a.VertexBuffer.MatricesWeightsKind),d.push("#define BONES"),d.push("#define BonesPerMesh "+(f.skeleton.bones.length+1))),c&&(d.push("#define INSTANCES"),e.push("world0"),e.push("world1"),e.push("world2"),e.push("world3"));var h=d.join("\n");return this._cachedDefines!=h&&(this._cachedDefines=h,this._effect=this._scene.getEngine().createEffect("shadowMap",e,["world","mBones","viewProjection","diffuseMatrix"],["diffuseSampler"],h)),this._effect.isReady()},b.prototype.getShadowMap=function(){return this._shadowMap},b.prototype.getLight=function(){return this._light},b.prototype.getTransformMatrix=function(){var b=this._light.position,c=this._light.direction;if(this._light._computeTransformedPosition()&&(b=this._light._transformedPosition),!(this._cachedPosition&&this._cachedDirection&&b.equals(this._cachedPosition)&&c.equals(this._cachedDirection))){this._cachedPosition=b.clone(),this._cachedDirection=c.clone();var d=this._scene.activeCamera;a.Matrix.LookAtLHToRef(b,this._light.position.add(c),a.Vector3.Up(),this._viewMatrix),a.Matrix.PerspectiveFovLHToRef(Math.PI/2,1,d.minZ,d.maxZ,this._projectionMatrix),this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix},b.prototype.getDarkness=function(){return this._darkness},b.prototype.setDarkness=function(a){a>=1?this._darkness=1:0>=a&&(this._darkness=0),elsethis._darkness=a},b.prototype.setTransparencyShadow=function(a){this._transparencyShadow=a},b.prototype.dispose=function(){this._shadowMap.dispose()},b._FILTER_NONE=0,b._FILTER_VARIANCESHADOWMAP=1,b._FILTER_POISSONSAMPLING=2,b}();a.ShadowGenerator=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,e),this.direction=d,this.groundColor=new a.Color3(0,0,0)}return __extends(c,b),c.prototype.setDirectionToTarget=function(b){return this.direction=a.Vector3.Normalize(b.subtract(a.Vector3.Zero())),this.direction},c.prototype.getShadowGenerator=function(){return null},c.prototype.transferToEffect=function(b,c,d){var e=a.Vector3.Normalize(this.direction);b.setFloat4(c,e.x,e.y,e.z,0),b.setColor3(d,this.groundColor.scale(this.intensity))},c.prototype._getWorldMatrix=function(){return this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),this._worldMatrix},c}(a.Light);a.HemisphericLight=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b,c,d){return a.x>c.x+d?!1:c.x-d>b.x?!1:a.y>c.y+d?!1:c.y-d>b.y?!1:a.z>c.z+d?!1:c.z-d>b.z?!1:!0},c=function(a,b,c,d){var e=b*b-4*a*c,f={root:0,found:!1};if(0>e)return f;var g=Math.sqrt(e),h=(-b-g)/(2*a),i=(-b+g)/(2*a);if(h>i){var j=i;i=h,h=j}return h>0&&d>h?(f.root=h,f.found=!0,f):i>0&&d>i?(f.root=i,f.found=!0,f):f},d=function(){function d(){this.radius=new a.Vector3(1,1,1),this.retry=0,this.basePointWorld=a.Vector3.Zero(),this.velocityWorld=a.Vector3.Zero(),this.normalizedVelocity=a.Vector3.Zero(),this._collisionPoint=a.Vector3.Zero(),this._planeIntersectionPoint=a.Vector3.Zero(),this._tempVector=a.Vector3.Zero(),this._tempVector2=a.Vector3.Zero(),this._tempVector3=a.Vector3.Zero(),this._tempVector4=a.Vector3.Zero(),this._edge=a.Vector3.Zero(),this._baseToVertex=a.Vector3.Zero(),this._destinationPoint=a.Vector3.Zero(),this._slidePlaneNormal=a.Vector3.Zero(),this._displacementVector=a.Vector3.Zero()}return d.prototype._initialize=function(b,c,d){this.velocity=c,a.Vector3.NormalizeToRef(c,this.normalizedVelocity),this.basePoint=b,b.multiplyToRef(this.radius,this.basePointWorld),c.multiplyToRef(this.radius,this.velocityWorld),this.velocityWorldLength=this.velocityWorld.length(),this.epsilon=d,this.collisionFound=!1},d.prototype._checkPointInTriangle=function(b,c,d,e,f){c.subtractToRef(b,this._tempVector),d.subtractToRef(b,this._tempVector2),a.Vector3.CrossToRef(this._tempVector,this._tempVector2,this._tempVector4);var g=a.Vector3.Dot(this._tempVector4,f);return 0>g?!1:(e.subtractToRef(b,this._tempVector3),a.Vector3.CrossToRef(this._tempVector2,this._tempVector3,this._tempVector4),g=a.Vector3.Dot(this._tempVector4,f),0>g?!1:(a.Vector3.CrossToRef(this._tempVector3,this._tempVector,this._tempVector4),g=a.Vector3.Dot(this._tempVector4,f),g>=0))},d.prototype._canDoCollision=function(c,d,e,f){var g=a.Vector3.Distance(this.basePointWorld,c),h=Math.max(this.radius.x,this.radius.y,this.radius.z);return g>this.velocityWorldLength+h+d?!1:b(e,f,this.basePointWorld,this.velocityWorldLength+h)?!0:!1},d.prototype._testTriangle=function(b,d,e,f,g){var h,i=!1;d._trianglePlanes||(d._trianglePlanes=[]),d._trianglePlanes[b]||(d._trianglePlanes[b]=new a.Plane(0,0,0,0),d._trianglePlanes[b].copyFromPoints(e,f,g));var j=d._trianglePlanes[b];if(d.getMaterial()||j.isFrontFacingTo(this.normalizedVelocity,0)){var k=j.signedDistanceTo(this.basePoint),l=a.Vector3.Dot(j.normal,this.velocity);if(0==l){if(Math.abs(k)>=1)return;i=!0,h=0}else{h=(-1-k)/l;var m=(1-k)/l;if(h>m){var n=m;m=h,h=n}if(h>1||0>m)return;0>h&&(h=0),h>1&&(h=1)}this._collisionPoint.copyFromFloats(0,0,0);var o=!1,p=1;if(i||(this.basePoint.subtractToRef(j.normal,this._planeIntersectionPoint),this.velocity.scaleToRef(h,this._tempVector),this._planeIntersectionPoint.addInPlace(this._tempVector),this._checkPointInTriangle(this._planeIntersectionPoint,e,f,g,j.normal)&&(o=!0,p=h,this._collisionPoint.copyFrom(this._planeIntersectionPoint))),!o){var q=this.velocity.lengthSquared(),r=q;this.basePoint.subtractToRef(e,this._tempVector);var s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p);u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(e)),this.basePoint.subtractToRef(f,this._tempVector),s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p),u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(f)),this.basePoint.subtractToRef(g,this._tempVector),s=2*a.Vector3.Dot(this.velocity,this._tempVector),t=this._tempVector.lengthSquared()-1,u=c(r,s,t,p),u.found&&(p=u.root,o=!0,this._collisionPoint.copyFrom(g)),f.subtractToRef(e,this._edge),e.subtractToRef(this.basePoint,this._baseToVertex);var v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex);if(r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found){var y=(w*u.root-x)/v;y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),e.addToRef(this._edge,this._collisionPoint))}g.subtractToRef(f,this._edge),f.subtractToRef(this.basePoint,this._baseToVertex),v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex),r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found&&(y=(w*u.root-x)/v,y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),f.addToRef(this._edge,this._collisionPoint))),e.subtractToRef(g,this._edge),g.subtractToRef(this.basePoint,this._baseToVertex),v=this._edge.lengthSquared(),w=a.Vector3.Dot(this._edge,this.velocity),x=a.Vector3.Dot(this._edge,this._baseToVertex),r=v*-q+w*w,s=2*v*a.Vector3.Dot(this.velocity,this._baseToVertex)-2*w*x,t=v*(1-this._baseToVertex.lengthSquared())+x*x,u=c(r,s,t,p),u.found&&(y=(w*u.root-x)/v,y>=0&&1>=y&&(p=u.root,o=!0,this._edge.scaleInPlace(y),g.addToRef(this._edge,this._collisionPoint)))}if(o){var z=p*this.velocity.length();(!this.collisionFound||z<this.nearestDistance)&&(this.intersectionPoint?this.intersectionPoint.copyFrom(this._collisionPoint):this.intersectionPoint=this._collisionPoint.clone(),this.nearestDistance=z,this.collisionFound=!0,this.collidedMesh=d.getMesh())}}},d.prototype._collide=function(a,b,c,d,e,f){for(var g=d;e>g;g+=3){var h=b[c[g]-f],i=b[c[g+1]-f],j=b[c[g+2]-f];this._testTriangle(g,a,j,i,h)}},d.prototype._getResponse=function(b,c){b.addToRef(c,this._destinationPoint),c.scaleInPlace(this.nearestDistance/c.length()),this.basePoint.addToRef(c,b),b.subtractToRef(this.intersectionPoint,this._slidePlaneNormal),this._slidePlaneNormal.normalize(),this._slidePlaneNormal.scaleToRef(this.epsilon,this._displacementVector),b.addInPlace(this._displacementVector),this.intersectionPoint.addInPlace(this._displacementVector),this._slidePlaneNormal.scaleInPlace(a.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint,this._slidePlaneNormal,this._destinationPoint)),this._destinationPoint.subtractInPlace(this._slidePlaneNormal),this._destinationPoint.subtractToRef(this.intersectionPoint,c)},d}();a.Collider=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(d,e,f){b.call(this,d,f),this.position=e,this.upVector=a.Vector3.Up(),this.orthoLeft=null,this.orthoRight=null,this.orthoBottom=null,this.orthoTop=null,this.fov=.8,this.minZ=.1,this.maxZ=1e3,this.inertia=.9,this.mode=c.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new a.Viewport(0,0,1,1),this.subCameras=[],this.layerMask=4294967295,this._computedViewMatrix=a.Matrix.Identity(),this._projectionMatrix=new a.Matrix,this._postProcesses=new Array,this._postProcessesTakenIndices=[],f.cameras.push(this),f.activeCamera||(f.activeCamera=this)}return __extends(c,b),c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.position=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0},c.prototype._updateCache=function(a){a||b.prototype._updateCache.call(this);var c=this.getEngine();this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector),this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._cache.fov=this.fov,this._cache.aspectRatio=c.getAspectRatio(this),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.renderWidth=c.getRenderWidth(),this._cache.renderHeight=c.getRenderHeight()},c.prototype._updateFromScene=function(){this.updateCache(),this._update()},c.prototype._isSynchronized=function(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()},c.prototype._isSynchronizedViewMatrix=function(){return b.prototype._isSynchronized.call(this)?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1},c.prototype._isSynchronizedProjectionMatrix=function(){var b=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!b)return!1;var c=this.getEngine();return b=this.mode===a.Camera.PERSPECTIVE_CAMERA?this._cache.fov===this.fov&&this._cache.aspectRatio===c.getAspectRatio(this):this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===c.getRenderWidth()&&this._cache.renderHeight===c.getRenderHeight()},c.prototype.attachControl=function(){},c.prototype.detachControl=function(){},c.prototype._update=function(){},c.prototype.attachPostProcess=function(b,c){if("undefined"==typeof c&&(c=null),!b.isReusable()&&this._postProcesses.indexOf(b)>-1)return a.Tools.Error("You're trying to reuse a post process not defined as reusable."),0;if(null==c||0>c)return this._postProcesses.push(b),this._postProcessesTakenIndices.push(this._postProcesses.length-1),this._postProcesses.length-1;var d=0;if(this._postProcesses[c]){for(var e=this._postProcesses.length-1,f=e;f>=c+1;--f)this._postProcesses[f+1]=this._postProcesses[f];d=1}for(f=0;f<this._postProcessesTakenIndices.length;++f)if(!(this._postProcessesTakenIndices[f]<c)){e=this._postProcessesTakenIndices.length-1;for(var g=e;g>=f;--g)this._postProcessesTakenIndices[g+1]=this._postProcessesTakenIndices[g]+d;this._postProcessesTakenIndices[f]=c;break}d||-1!=this._postProcessesTakenIndices.indexOf(c)||this._postProcessesTakenIndices.push(c);var h=c+d;return this._postProcesses[h]=b,h},c.prototype.detachPostProcess=function(a,b){"undefined"==typeof b&&(b=null);var c=[];if(b)for(b=b instanceof Array?b:[b],f=0;f<b.length;f++){var d=this._postProcesses[b[f]];d===a?(delete this._postProcesses[b[f]],g=this._postProcessesTakenIndices.indexOf(b[f]),this._postProcessesTakenIndices.splice(g,1)):c.push(f)
}else for(var e=this._postProcesses.length,f=0;e>f;f++)if(this._postProcesses[f]===a){delete this._postProcesses[f];var g=this._postProcessesTakenIndices.indexOf(f);this._postProcessesTakenIndices.splice(g,1)}return c},c.prototype.getWorldMatrix=function(){this._worldMatrix||(this._worldMatrix=a.Matrix.Identity());var b=this.getViewMatrix();return b.invertToRef(this._worldMatrix),this._worldMatrix},c.prototype._getViewMatrix=function(){return a.Matrix.Identity()},c.prototype.getViewMatrix=function(){return this._computedViewMatrix=this._computeViewMatrix(),this.parent&&this.parent.getWorldMatrix&&!this.isSynchronized()?(this._worldMatrix||(this._worldMatrix=a.Matrix.Identity()),this._computedViewMatrix.invertToRef(this._worldMatrix),this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._computedViewMatrix),this._computedViewMatrix.invert(),this._currentRenderId=this.getScene().getRenderId(),this._computedViewMatrix):this._computedViewMatrix},c.prototype._computeViewMatrix=function(a){return!a&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._computedViewMatrix=this._getViewMatrix(),this.parent&&this.parent.getWorldMatrix||(this._currentRenderId=this.getScene().getRenderId()),this._computedViewMatrix)},c.prototype.getProjectionMatrix=function(b){if(!b&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;var c=this.getEngine();if(this.mode===a.Camera.PERSPECTIVE_CAMERA)return this.minZ<=0&&(this.minZ=.1),a.Matrix.PerspectiveFovLHToRef(this.fov,c.getAspectRatio(this),this.minZ,this.maxZ,this._projectionMatrix),this._projectionMatrix;var d=c.getRenderWidth()/2,e=c.getRenderHeight()/2;return a.Matrix.OrthoOffCenterLHToRef(this.orthoLeft||-d,this.orthoRight||d,this.orthoBottom||-e,this.orthoTop||e,this.minZ,this.maxZ,this._projectionMatrix),this._projectionMatrix},c.prototype.dispose=function(){var a=this.getScene().cameras.indexOf(this);this.getScene().cameras.splice(a,1);for(var b=0;b<this._postProcessesTakenIndices.length;++b)this._postProcesses[this._postProcessesTakenIndices[b]].dispose(this)},c.PERSPECTIVE_CAMERA=0,c.ORTHOGRAPHIC_CAMERA=1,c}(a.Node);a.Camera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,d,e),this.cameraDirection=new a.Vector3(0,0,0),this.cameraRotation=new a.Vector2(0,0),this.rotation=new a.Vector3(0,0,0),this.ellipsoid=new a.Vector3(.5,1,.5),this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.speed=2,this.checkCollisions=!1,this.applyGravity=!1,this.noRotationConstraint=!1,this.angularSensibility=2e3,this.lockedTarget=null,this._keys=[],this._collider=new a.Collider,this._needMoveForGravity=!0,this._currentTarget=a.Vector3.Zero(),this._viewMatrix=a.Matrix.Zero(),this._camMatrix=a.Matrix.Zero(),this._cameraTransformMatrix=a.Matrix.Zero(),this._cameraRotationMatrix=a.Matrix.Zero(),this._referencePoint=new a.Vector3(0,0,1),this._transformedReferencePoint=a.Vector3.Zero(),this._oldPosition=a.Vector3.Zero(),this._diffPosition=a.Vector3.Zero(),this._newPosition=a.Vector3.Zero(),this._lookAtTemp=a.Matrix.Zero(),this._tempMatrix=a.Matrix.Zero()}return __extends(c,b),c.prototype._getLockedTargetPosition=function(){return this.lockedTarget?this.lockedTarget.position||this.lockedTarget:null},c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.lockedTarget=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},c.prototype._updateCache=function(a){a||b.prototype._updateCache.call(this);var c=this._getLockedTargetPosition();c?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(c):this._cache.lockedTarget=c.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation)},c.prototype._isSynchronizedViewMatrix=function(){if(!b.prototype._isSynchronizedViewMatrix.call(this))return!1;var a=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(a):!a)&&this._cache.rotation.equals(this.rotation)},c.prototype._computeLocalCameraSpeed=function(){return this.speed*(a.Tools.GetDeltaTime()/(10*a.Tools.GetFps()))},c.prototype.setTarget=function(b){this.upVector.normalize(),a.Matrix.LookAtLHToRef(this.position,b,this.upVector,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);var c=b.subtract(this.position);this.rotation.y=c.x>=0?-Math.atan(c.z/c.x)+Math.PI/2:-Math.atan(c.z/c.x)-Math.PI/2,this.rotation.z=-Math.acos(a.Vector3.Dot(new a.Vector3(0,1,0),this.upVector)),isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0)},c.prototype.getTarget=function(){return this._currentTarget},c.prototype.attachControl=function(b,c){var d,e=this,f=this.getEngine();this._attachedElement||(this._attachedElement=b,void 0===this._onMouseDown&&(this._onMouseDown=function(a){d={x:a.clientX,y:a.clientY},c||a.preventDefault()},this._onMouseUp=function(a){d=null,c||a.preventDefault()},this._onMouseOut=function(a){d=null,e._keys=[],c||a.preventDefault()},this._onMouseMove=function(a){if(d||f.isPointerLock){var b,g;f.isPointerLock?(b=a.movementX||a.mozMovementX||a.webkitMovementX||a.msMovementX||0,g=a.movementY||a.mozMovementY||a.webkitMovementY||a.msMovementY||0):(b=a.clientX-d.x,g=a.clientY-d.y),e.cameraRotation.y+=b/e.angularSensibility,e.cameraRotation.x+=g/e.angularSensibility,d={x:a.clientX,y:a.clientY},c||a.preventDefault()}},this._onKeyDown=function(a){if(-1!==e.keysUp.indexOf(a.keyCode)||-1!==e.keysDown.indexOf(a.keyCode)||-1!==e.keysLeft.indexOf(a.keyCode)||-1!==e.keysRight.indexOf(a.keyCode)){var b=e._keys.indexOf(a.keyCode);-1===b&&e._keys.push(a.keyCode),c||a.preventDefault()}},this._onKeyUp=function(a){if(-1!==e.keysUp.indexOf(a.keyCode)||-1!==e.keysDown.indexOf(a.keyCode)||-1!==e.keysLeft.indexOf(a.keyCode)||-1!==e.keysRight.indexOf(a.keyCode)){var b=e._keys.indexOf(a.keyCode);b>=0&&e._keys.splice(b,1),c||a.preventDefault()}},this._onLostFocus=function(){e._keys=[]},this._reset=function(){e._keys=[],d=null,e.cameraDirection=new a.Vector3(0,0,0),e.cameraRotation=new a.Vector2(0,0)}),b.addEventListener("mousedown",this._onMouseDown,!1),b.addEventListener("mouseup",this._onMouseUp,!1),b.addEventListener("mouseout",this._onMouseOut,!1),b.addEventListener("mousemove",this._onMouseMove,!1),a.Tools.RegisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]))},c.prototype.detachControl=function(b){this._attachedElement==b&&(b.removeEventListener("mousedown",this._onMouseDown),b.removeEventListener("mouseup",this._onMouseUp),b.removeEventListener("mouseout",this._onMouseOut),b.removeEventListener("mousemove",this._onMouseMove),a.Tools.UnregisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]),this._attachedElement=null,this._reset&&this._reset())},c.prototype._collideWithWorld=function(b){var c;c=this.parent?a.Vector3.TransformCoordinates(this.position,this.parent.getWorldMatrix()):this.position,c.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._collider.radius=this.ellipsoid,this.getScene()._getNewPosition(this._oldPosition,b,this._collider,3,this._newPosition),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>a.Engine.CollisionsEpsilon&&(this.position.addInPlace(this._diffPosition),this.onCollide&&this.onCollide(this._collider.collidedMesh))},c.prototype._checkInputs=function(){this._localDirection||(this._localDirection=a.Vector3.Zero(),this._transformedDirection=a.Vector3.Zero());for(var b=0;b<this._keys.length;b++){var c=this._keys[b],d=this._computeLocalCameraSpeed();-1!==this.keysLeft.indexOf(c)?this._localDirection.copyFromFloats(-d,0,0):-1!==this.keysUp.indexOf(c)?this._localDirection.copyFromFloats(0,0,d):-1!==this.keysRight.indexOf(c)?this._localDirection.copyFromFloats(d,0,0):-1!==this.keysDown.indexOf(c)&&this._localDirection.copyFromFloats(0,0,-d),this.getViewMatrix().invertToRef(this._cameraTransformMatrix),a.Vector3.TransformNormalToRef(this._localDirection,this._cameraTransformMatrix,this._transformedDirection),this.cameraDirection.addInPlace(this._transformedDirection)}},c.prototype._update=function(){this._checkInputs();var b=this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0,c=Math.abs(this.cameraRotation.x)>0||Math.abs(this.cameraRotation.y)>0;if(b)if(this.checkCollisions&&this.getScene().collisionsEnabled){if(this._collideWithWorld(this.cameraDirection),this.applyGravity){var d=this.position;this._collideWithWorld(this.getScene().gravity),this._needMoveForGravity=0!=a.Vector3.DistanceSquared(d,this.position)}}else this.position.addInPlace(this.cameraDirection);if(c&&(this.rotation.x+=this.cameraRotation.x,this.rotation.y+=this.cameraRotation.y,!this.noRotationConstraint)){var e=Math.PI/2*.95;this.rotation.x>e&&(this.rotation.x=e),this.rotation.x<-e&&(this.rotation.x=-e)}b&&(Math.abs(this.cameraDirection.x)<a.Engine.Epsilon&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<a.Engine.Epsilon&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<a.Engine.Epsilon&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),c&&(Math.abs(this.cameraRotation.x)<a.Engine.Epsilon&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<a.Engine.Epsilon&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia))},c.prototype._getViewMatrix=function(){return this.lockedTarget?this._currentTarget.copyFrom(this._getLockedTargetPosition()):(0!=this.upVector.x||1!=this.upVector.y||0!=this.upVector.z?(a.Matrix.LookAtLHToRef(a.Vector3.Zero(),this._referencePoint,this.upVector,this._lookAtTemp),a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),this._lookAtTemp.multiplyToRef(this._cameraRotationMatrix,this._tempMatrix),this._lookAtTemp.invert(),this._tempMatrix.multiplyToRef(this._lookAtTemp,this._cameraRotationMatrix)):a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),a.Vector3.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget)),a.Matrix.LookAtLHToRef(this.position,this._currentTarget,this.upVector,this._viewMatrix),this._viewMatrix},c}(a.Camera);a.FreeCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){b.call(this,a,c,d),this._offsetX=null,this._offsetY=null,this._pointerCount=0,this._pointerPressed=[],this.angularSensibility=2e5,this.moveSensibility=500}return __extends(c,b),c.prototype.attachControl=function(b,c){var d,e=this;this._attachedCanvas||(this._attachedCanvas=b,void 0===this._onPointerDown&&(this._onPointerDown=function(a){c||a.preventDefault(),e._pointerPressed.push(a.pointerId),1===e._pointerPressed.length&&(d={x:a.clientX,y:a.clientY})},this._onPointerUp=function(a){c||a.preventDefault();var b=e._pointerPressed.indexOf(a.pointerId);-1!==b&&(e._pointerPressed.splice(b,1),0==b&&(d=null,e._offsetX=null,e._offsetY=null))},this._onPointerMove=function(a){if(c||a.preventDefault(),d){var b=e._pointerPressed.indexOf(a.pointerId);0==b&&(e._offsetX=a.clientX-d.x,e._offsetY=-(a.clientY-d.y))}},this._onLostFocus=function(){e._offsetX=null,e._offsetY=null}),b.addEventListener("pointerdown",this._onPointerDown),b.addEventListener("pointerup",this._onPointerUp),b.addEventListener("pointerout",this._onPointerUp),b.addEventListener("pointermove",this._onPointerMove),a.Tools.RegisterTopRootEvents([{name:"blur",handler:this._onLostFocus}]))},c.prototype.detachControl=function(b){this._attachedCanvas==b&&(b.removeEventListener("pointerdown",this._onPointerDown),b.removeEventListener("pointerup",this._onPointerUp),b.removeEventListener("pointerout",this._onPointerUp),b.removeEventListener("pointermove",this._onPointerMove),a.Tools.UnregisterTopRootEvents([{name:"blur",handler:this._onLostFocus}]),this._attachedCanvas=null)},c.prototype._checkInputs=function(){if(this._offsetX)if(this.cameraRotation.y+=this._offsetX/this.angularSensibility,this._pointerPressed.length>1)this.cameraRotation.x+=-this._offsetY/this.angularSensibility;else{var b=this._computeLocalCameraSpeed(),c=new a.Vector3(0,0,b*this._offsetY/this.moveSensibility);a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,0,this._cameraRotationMatrix),this.cameraDirection.addInPlace(a.Vector3.TransformCoordinates(c,this._cameraRotationMatrix))}},c}(a.FreeCamera);a.TouchCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d){var e=this;b.call(this,a,c,d),this._offsetX=null,this._offsetY=null,this._orientationGamma=0,this._orientationBeta=0,this._initialOrientationGamma=0,this._initialOrientationBeta=0,this.angularSensibility=1e4,this.moveSensibility=50,window.addEventListener("resize",function(){e._initialOrientationGamma=null},!1)}return __extends(c,b),c.prototype.attachControl=function(a){var b=this;this._attachedCanvas||(this._attachedCanvas=a,this._orientationChanged||(this._orientationChanged=function(a){b._initialOrientationGamma||(b._initialOrientationGamma=a.gamma,b._initialOrientationBeta=a.beta),b._orientationGamma=a.gamma,b._orientationBeta=a.beta,b._offsetY=b._initialOrientationBeta-b._orientationBeta,b._offsetX=b._initialOrientationGamma-b._orientationGamma}),window.addEventListener("deviceorientation",this._orientationChanged))},c.prototype.detachControl=function(a){this._attachedCanvas==a&&(window.removeEventListener("deviceorientation",this._orientationChanged),this._attachedCanvas=null,this._orientationGamma=0,this._orientationBeta=0,this._initialOrientationGamma=0,this._initialOrientationBeta=0)},c.prototype._checkInputs=function(){if(this._offsetX){this.cameraRotation.y-=this._offsetX/this.angularSensibility;var b=this._computeLocalCameraSpeed(),c=new a.Vector3(0,0,b*this._offsetY/this.moveSensibility);a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,0,this._cameraRotationMatrix),this.cameraDirection.addInPlace(a.Vector3.TransformCoordinates(c,this._cameraRotationMatrix))}},c}(a.FreeCamera);a.DeviceOrientationCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=a.Tools.GetPointerPrefix(),c=function(c){function d(b,d,e,f,g,h){c.call(this,b,a.Vector3.Zero(),h),this.alpha=d,this.beta=e,this.radius=f,this.target=g,this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.lowerAlphaLimit=null,this.upperAlphaLimit=null,this.lowerBetaLimit=.01,this.upperBetaLimit=Math.PI,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.angularSensibility=1e3,this.wheelPrecision=3,this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.zoomOnFactor=1,this._keys=[],this._viewMatrix=new a.Matrix,this.checkCollisions=!1,this.collisionRadius=new a.Vector3(.5,.5,.5),this._collider=new a.Collider,this._previousPosition=a.Vector3.Zero(),this._collisionVelocity=a.Vector3.Zero(),this._newPosition=a.Vector3.Zero(),this.getViewMatrix()}return __extends(d,c),d.prototype._getTargetPosition=function(){return this.target.position||this.target},d.prototype._initCache=function(){c.prototype._initCache.call(this),this._cache.target=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.alpha=void 0,this._cache.beta=void 0,this._cache.radius=void 0},d.prototype._updateCache=function(a){a||c.prototype._updateCache.call(this),this._cache.target.copyFrom(this._getTargetPosition()),this._cache.alpha=this.alpha,this._cache.beta=this.beta,this._cache.radius=this.radius},d.prototype._isSynchronizedViewMatrix=function(){return c.prototype._isSynchronizedViewMatrix.call(this)?this._cache.target.equals(this._getTargetPosition())&&this._cache.alpha===this.alpha&&this._cache.beta===this.beta&&this._cache.radius===this.radius:!1},d.prototype.attachControl=function(c,d){var e,f,g=this;if(!this._attachedElement){this._attachedElement=c;var h=this.getEngine();void 0===this._onPointerDown&&(this._onPointerDown=function(a){f||(f=a.pointerId,e={x:a.clientX,y:a.clientY},d||a.preventDefault())},this._onPointerUp=function(a){e=null,f=null,d||a.preventDefault()},this._onPointerMove=function(a){if(e&&f===a.pointerId){var b=a.clientX-e.x,c=a.clientY-e.y;g.inertialAlphaOffset-=b/g.angularSensibility,g.inertialBetaOffset-=c/g.angularSensibility,e={x:a.clientX,y:a.clientY},d||a.preventDefault()}},this._onMouseMove=function(a){if(h.isPointerLock){var b=a.movementX||a.mozMovementX||a.webkitMovementX||a.msMovementX||0,c=a.movementY||a.mozMovementY||a.webkitMovementY||a.msMovementY||0;g.inertialAlphaOffset-=b/g.angularSensibility,g.inertialBetaOffset-=c/g.angularSensibility,d||a.preventDefault()}},this._wheel=function(a){var b=0;a.wheelDelta?b=a.wheelDelta/(40*g.wheelPrecision):a.detail&&(b=-a.detail/g.wheelPrecision),b&&(g.inertialRadiusOffset+=b),a.preventDefault&&(d||a.preventDefault())},this._onKeyDown=function(a){if(-1!==g.keysUp.indexOf(a.keyCode)||-1!==g.keysDown.indexOf(a.keyCode)||-1!==g.keysLeft.indexOf(a.keyCode)||-1!==g.keysRight.indexOf(a.keyCode)){var b=g._keys.indexOf(a.keyCode);-1===b&&g._keys.push(a.keyCode),a.preventDefault&&(d||a.preventDefault())}},this._onKeyUp=function(a){if(-1!==g.keysUp.indexOf(a.keyCode)||-1!==g.keysDown.indexOf(a.keyCode)||-1!==g.keysLeft.indexOf(a.keyCode)||-1!==g.keysRight.indexOf(a.keyCode)){var b=g._keys.indexOf(a.keyCode);b>=0&&g._keys.splice(b,1),a.preventDefault&&(d||a.preventDefault())}},this._onLostFocus=function(){g._keys=[],f=null},this._onGestureStart=function(a){void 0!==window.MSGesture&&(g._MSGestureHandler||(g._MSGestureHandler=new MSGesture,g._MSGestureHandler.target=c),g._MSGestureHandler.addPointer(a.pointerId))},this._onGesture=function(a){g.radius*=a.scale,a.preventDefault&&(d||(a.stopPropagation(),a.preventDefault()))},this._reset=function(){g._keys=[],g.inertialAlphaOffset=0,g.inertialBetaOffset=0,g.inertialRadiusOffset=0,e=null,f=null}),c.addEventListener(b+"down",this._onPointerDown,!1),c.addEventListener(b+"up",this._onPointerUp,!1),c.addEventListener(b+"out",this._onPointerUp,!1),c.addEventListener(b+"move",this._onPointerMove,!1),c.addEventListener("mousemove",this._onMouseMove,!1),c.addEventListener("MSPointerDown",this._onGestureStart,!1),c.addEventListener("MSGestureChange",this._onGesture,!1),c.addEventListener("mousewheel",this._wheel,!1),c.addEventListener("DOMMouseScroll",this._wheel,!1),a.Tools.RegisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}])}},d.prototype.detachControl=function(c){this._attachedElement==c&&(c.removeEventListener(b+"down",this._onPointerDown),c.removeEventListener(b+"up",this._onPointerUp),c.removeEventListener(b+"out",this._onPointerUp),c.removeEventListener(b+"move",this._onPointerMove),c.removeEventListener("mousemove",this._onMouseMove),c.removeEventListener("MSPointerDown",this._onGestureStart),c.removeEventListener("MSGestureChange",this._onGesture),c.removeEventListener("mousewheel",this._wheel),c.removeEventListener("DOMMouseScroll",this._wheel),a.Tools.UnregisterTopRootEvents([{name:"keydown",handler:this._onKeyDown},{name:"keyup",handler:this._onKeyUp},{name:"blur",handler:this._onLostFocus}]),this._MSGestureHandler=null,this._attachedElement=null,this._reset&&this._reset())},d.prototype._update=function(){for(var b=0;b<this._keys.length;b++){var c=this._keys[b];-1!==this.keysLeft.indexOf(c)?this.inertialAlphaOffset-=.01:-1!==this.keysUp.indexOf(c)?this.inertialBetaOffset-=.01:-1!==this.keysRight.indexOf(c)?this.inertialAlphaOffset+=.01:-1!==this.keysDown.indexOf(c)&&(this.inertialBetaOffset+=.01)}(0!=this.inertialAlphaOffset||0!=this.inertialBetaOffset||0!=this.inertialRadiusOffset)&&(this.alpha+=this.inertialAlphaOffset,this.beta+=this.inertialBetaOffset,this.radius-=this.inertialRadiusOffset,this.inertialAlphaOffset*=this.inertia,this.inertialBetaOffset*=this.inertia,this.inertialRadiusOffset*=this.inertia,Math.abs(this.inertialAlphaOffset)<a.Engine.Epsilon&&(this.inertialAlphaOffset=0),Math.abs(this.inertialBetaOffset)<a.Engine.Epsilon&&(this.inertialBetaOffset=0),Math.abs(this.inertialRadiusOffset)<a.Engine.Epsilon&&(this.inertialRadiusOffset=0)),this.lowerAlphaLimit&&this.alpha<this.lowerAlphaLimit&&(this.alpha=this.lowerAlphaLimit),this.upperAlphaLimit&&this.alpha>this.upperAlphaLimit&&(this.alpha=this.upperAlphaLimit),this.lowerBetaLimit&&this.beta<this.lowerBetaLimit&&(this.beta=this.lowerBetaLimit),this.upperBetaLimit&&this.beta>this.upperBetaLimit&&(this.beta=this.upperBetaLimit),this.lowerRadiusLimit&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit),this.upperRadiusLimit&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit)},d.prototype.setPosition=function(a){var b=a.subtract(this._getTargetPosition());this.radius=b.length(),this.alpha=Math.acos(b.x/Math.sqrt(Math.pow(b.x,2)+Math.pow(b.z,2))),b.z<0&&(this.alpha=2*Math.PI-this.alpha),this.beta=Math.acos(b.y/this.radius)},d.prototype._getViewMatrix=function(){var b=Math.cos(this.alpha),c=Math.sin(this.alpha),d=Math.cos(this.beta),e=Math.sin(this.beta),f=this._getTargetPosition();return f.addToRef(new a.Vector3(this.radius*b*e,this.radius*d,this.radius*c*e),this.position),this.checkCollisions&&(this._collider.radius=this.collisionRadius,this.position.subtractToRef(this._previousPosition,this._collisionVelocity),this.getScene()._getNewPosition(this._previousPosition,this._collisionVelocity,this._collider,3,this._newPosition),this._newPosition.equalsWithEpsilon(this.position)||(this.position.copyFrom(this._previousPosition),this.alpha=this._previousAlpha,this.beta=this._previousBeta,this.radius=this._previousRadius,this.onCollide&&this.onCollide(this._collider.collidedMesh))),a.Matrix.LookAtLHToRef(this.position,f,this.upVector,this._viewMatrix),this._previousAlpha=this.alpha,this._previousBeta=this.beta,this._previousRadius=this.radius,this._previousPosition.copyFrom(this.position),this._viewMatrix},d.prototype.zoomOn=function(b){b=b||this.getScene().meshes;var c=a.Mesh.MinMax(b),d=a.Vector3.Distance(c.min,c.max);this.radius=d*this.zoomOnFactor,this.focusOn({min:c.min,max:c.max,distance:d})},d.prototype.focusOn=function(b){var c,d;void 0===b.min?(c=b||this.getScene().meshes,c=a.Mesh.MinMax(c),d=a.Vector3.Distance(c.min,c.max)):(c=b,d=b.distance),this.target=a.Mesh.Center(c),this.maxZ=2*d},d}(a.Camera);a.ArcRotateCamera=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.autoClear=!0,this.clearColor=new a.Color3(.2,.2,.3),this.ambientColor=new a.Color3(0,0,0),this.forceWireframe=!1,this.cameraToUseForPointers=null,this.fogMode=a.Scene.FOGMODE_NONE,this.fogColor=new a.Color3(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.lightsEnabled=!0,this.lights=new Array,this.cameras=new Array,this.activeCameras=new Array,this.meshes=new Array,this._geometries=new Array,this.materials=new Array,this.multiMaterials=new Array,this.defaultMaterial=new a.StandardMaterial("default material",this),this.texturesEnabled=!0,this.textures=new Array,this.particlesEnabled=!0,this.particleSystems=new Array,this.spriteManagers=new Array,this.layers=new Array,this.skeletons=new Array,this.lensFlareSystems=new Array,this.collisionsEnabled=!0,this.gravity=new a.Vector3(0,-9,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.customRenderTargets=new Array,this.importedMeshesFiles=new Array,this._actionManagers=new Array,this._meshesForIntersections=new a.SmartArray(256),this._totalVertices=0,this._activeVertices=0,this._activeParticles=0,this._lastFrameDuration=0,this._evaluateActiveMeshesDuration=0,this._renderTargetsDuration=0,this._particlesDuration=0,this._renderDuration=0,this._spritesDuration=0,this._animationRatio=0,this._renderId=0,this._executeWhenReadyTimeoutId=-1,this._toBeDisposed=new a.SmartArray(256),this._onReadyCallbacks=new Array,this._pendingData=[],this._onBeforeRenderCallbacks=new Array,this._activeMeshes=new a.SmartArray(256),this._processedMaterials=new a.SmartArray(256),this._renderTargets=new a.SmartArray(256),this._activeParticleSystems=new a.SmartArray(256),this._activeSkeletons=new a.SmartArray(32),this._activeAnimatables=new Array,this._transformMatrix=a.Matrix.Zero(),this._scaledPosition=a.Vector3.Zero(),this._scaledVelocity=a.Vector3.Zero(),this._engine=b,b.scenes.push(this),this._renderingManager=new a.RenderingManager(this),this.postProcessManager=new a.PostProcessManager(this),this.postProcessRenderPipelineManager=new a.PostProcessRenderPipelineManager,this._boundingBoxRenderer=new a.BoundingBoxRenderer(this),this.attachControl()}return Object.defineProperty(b.prototype,"meshUnderPointer",{get:function(){return this._meshUnderPointer},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"pointerX",{get:function(){return this._pointerX},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"pointerY",{get:function(){return this._pointerY},enumerable:!0,configurable:!0}),b.prototype.getBoundingBoxRenderer=function(){return this._boundingBoxRenderer},b.prototype.getEngine=function(){return this._engine},b.prototype.getTotalVertices=function(){return this._totalVertices},b.prototype.getActiveVertices=function(){return this._activeVertices},b.prototype.getActiveParticles=function(){return this._activeParticles},b.prototype.getLastFrameDuration=function(){return this._lastFrameDuration},b.prototype.getEvaluateActiveMeshesDuration=function(){return this._evaluateActiveMeshesDuration},b.prototype.getActiveMeshes=function(){return this._activeMeshes},b.prototype.getRenderTargetsDuration=function(){return this._renderTargetsDuration},b.prototype.getRenderDuration=function(){return this._renderDuration},b.prototype.getParticlesDuration=function(){return this._particlesDuration},b.prototype.getSpritesDuration=function(){return this._spritesDuration},b.prototype.getAnimationRatio=function(){return this._animationRatio},b.prototype.getRenderId=function(){return this._renderId},b.prototype._updatePointerPosition=function(a){var b=this._engine.getRenderingCanvasClientRect();this._pointerX=a.clientX-b.left,this._pointerY=a.clientY-b.top,this.cameraToUseForPointers&&(this._pointerX=this._pointerX-this.cameraToUseForPointers.viewport.x*this._engine.getRenderWidth(),this._pointerY=this._pointerY-this.cameraToUseForPointers.viewport.y*this._engine.getRenderHeight())},b.prototype.attachControl=function(){var b=this;this._onPointerMove=function(a){var c=b._engine.getRenderingCanvas();b._updatePointerPosition(a);var d=b.pick(b._pointerX,b._pointerY,function(a){return a.isPickable&&a.isVisible&&a.isReady()&&a.actionManager&&a.actionManager.hasPointerTriggers},!1,b.cameraToUseForPointers);d.hit?(b.setPointerOverMesh(d.pickedMesh),c.style.cursor="pointer",b._meshUnderPointer=d.pickedMesh):(b.setPointerOverMesh(null),c.style.cursor="",b._meshUnderPointer=null)},this._onPointerDown=function(c){var d=null;b.onPointerDown||(d=function(a){return a.isPickable&&a.isVisible&&a.isReady()&&a.actionManager&&a.actionManager.hasPickTriggers}),b._updatePointerPosition(c);var e=b.pick(b._pointerX,b._pointerY,d,!1,b.cameraToUseForPointers);if(e.hit&&e.pickedMesh.actionManager){switch(c.button){case 0:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnLeftPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh));break;case 1:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnCenterPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh));break;case 2:e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnRightPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh))}e.pickedMesh.actionManager.processTrigger(a.ActionManager.OnPickTrigger,a.ActionEvent.CreateNew(e.pickedMesh))}b.onPointerDown&&b.onPointerDown(c,e)},this._onKeyDown=function(c){b.actionManager&&b.actionManager.processTrigger(a.ActionManager.OnKeyDownTrigger,a.ActionEvent.CreateNewFromScene(b,c))},this._onKeyUp=function(c){b.actionManager&&b.actionManager.processTrigger(a.ActionManager.OnKeyUpTrigger,a.ActionEvent.CreateNewFromScene(b,c))};var c=a.Tools.GetPointerPrefix();this._engine.getRenderingCanvas().addEventListener(c+"move",this._onPointerMove,!1),this._engine.getRenderingCanvas().addEventListener(c+"down",this._onPointerDown,!1),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)},b.prototype.detachControl=function(){var b=a.Tools.GetPointerPrefix();this._engine.getRenderingCanvas().removeEventListener(b+"move",this._onPointerMove),this._engine.getRenderingCanvas().removeEventListener(b+"down",this._onPointerDown),window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)},b.prototype.isReady=function(){if(this._pendingData.length>0)return!1;for(var b=0;b<this._geometries.length;b++){var c=this._geometries[b];if(c.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING)return!1}for(b=0;b<this.meshes.length;b++){var d=this.meshes[b];if(!d.isReady())return!1;var e=d.material;if(e&&!e.isReady(d))return!1}return!0},b.prototype.registerBeforeRender=function(a){this._onBeforeRenderCallbacks.push(a)},b.prototype.unregisterBeforeRender=function(a){var b=this._onBeforeRenderCallbacks.indexOf(a);b>-1&&this._onBeforeRenderCallbacks.splice(b,1)},b.prototype._addPendingData=function(a){this._pendingData.push(a)},b.prototype._removePendingData=function(a){var b=this._pendingData.indexOf(a);-1!==b&&this._pendingData.splice(b,1)},b.prototype.getWaitingItemsCount=function(){return this._pendingData.length},b.prototype.executeWhenReady=function(a){var b=this;this._onReadyCallbacks.push(a),-1===this._executeWhenReadyTimeoutId&&(this._executeWhenReadyTimeoutId=setTimeout(function(){b._checkIsReady()},150))},b.prototype._checkIsReady=function(){var a=this;return this.isReady()?(this._onReadyCallbacks.forEach(function(a){a()}),this._onReadyCallbacks=[],void(this._executeWhenReadyTimeoutId=-1)):void(this._executeWhenReadyTimeoutId=setTimeout(function(){a._checkIsReady()},150))},b.prototype.beginAnimation=function(b,c,d,e,f,g,h){if(void 0===f&&(f=1),this.stopAnimation(b),h||(h=new a.Animatable(this,b,c,d,e,f,g)),b.animations&&h.appendAnimations(b,b.animations),b.getAnimatables)for(var i=b.getAnimatables(),j=0;j<i.length;j++)this.beginAnimation(i[j],c,d,e,f,g,h);return h},b.prototype.beginDirectAnimation=function(b,c,d,e,f,g,h){void 0===g&&(g=1);var i=new a.Animatable(this,b,d,e,f,g,h,c);return i},b.prototype.getAnimatableByTarget=function(a){for(var b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===a)return this._activeAnimatables[b];return null},b.prototype.stopAnimation=function(a){var b=this.getAnimatableByTarget(a);b&&b.stop()},b.prototype._animate=function(){this._animationStartDate||(this._animationStartDate=(new Date).getTime());for(var a=(new Date).getTime(),b=a-this._animationStartDate,c=0;c<this._activeAnimatables.length;c++)this._activeAnimatables[c]._animate(b)||(this._activeAnimatables.splice(c,1),c--)
},b.prototype.getViewMatrix=function(){return this._viewMatrix},b.prototype.getProjectionMatrix=function(){return this._projectionMatrix},b.prototype.getTransformMatrix=function(){return this._transformMatrix},b.prototype.setTransformMatrix=function(a,b){this._viewMatrix=a,this._projectionMatrix=b,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)},b.prototype.setActiveCameraByID=function(a){var b=this.getCameraByID(a);return b?(this.activeCamera=b,b):null},b.prototype.setActiveCameraByName=function(a){var b=this.getCameraByName(a);return b?(this.activeCamera=b,b):null},b.prototype.getMaterialByID=function(a){for(var b=0;b<this.materials.length;b++)if(this.materials[b].id===a)return this.materials[b];return null},b.prototype.getMaterialByName=function(a){for(var b=0;b<this.materials.length;b++)if(this.materials[b].name===a)return this.materials[b];return null},b.prototype.getCameraByID=function(a){for(var b=0;b<this.cameras.length;b++)if(this.cameras[b].id===a)return this.cameras[b];return null},b.prototype.getCameraByName=function(a){for(var b=0;b<this.cameras.length;b++)if(this.cameras[b].name===a)return this.cameras[b];return null},b.prototype.getLightByName=function(a){for(var b=0;b<this.lights.length;b++)if(this.lights[b].name===a)return this.lights[b];return null},b.prototype.getLightByID=function(a){for(var b=0;b<this.lights.length;b++)if(this.lights[b].id===a)return this.lights[b];return null},b.prototype.getGeometryByID=function(a){for(var b=0;b<this._geometries.length;b++)if(this._geometries[b].id===a)return this._geometries[b];return null},b.prototype.pushGeometry=function(a,b){return!b&&this.getGeometryByID(a.id)?!1:(this._geometries.push(a),!0)},b.prototype.getGeometries=function(){return this._geometries},b.prototype.getMeshByID=function(a){for(var b=0;b<this.meshes.length;b++)if(this.meshes[b].id===a)return this.meshes[b];return null},b.prototype.getLastMeshByID=function(a){for(var b=this.meshes.length-1;b>=0;b--)if(this.meshes[b].id===a)return this.meshes[b];return null},b.prototype.getLastEntryByID=function(a){for(var b=this.meshes.length-1;b>=0;b--)if(this.meshes[b].id===a)return this.meshes[b];for(b=this.cameras.length-1;b>=0;b--)if(this.cameras[b].id===a)return this.cameras[b];for(b=this.lights.length-1;b>=0;b--)if(this.lights[b].id===a)return this.lights[b];return null},b.prototype.getMeshByName=function(a){for(var b=0;b<this.meshes.length;b++)if(this.meshes[b].name===a)return this.meshes[b];return null},b.prototype.getLastSkeletonByID=function(a){for(var b=this.skeletons.length-1;b>=0;b--)if(this.skeletons[b].id===a)return this.skeletons[b];return null},b.prototype.getSkeletonById=function(a){for(var b=0;b<this.skeletons.length;b++)if(this.skeletons[b].id===a)return this.skeletons[b];return null},b.prototype.getSkeletonByName=function(a){for(var b=0;b<this.skeletons.length;b++)if(this.skeletons[b].name===a)return this.skeletons[b];return null},b.prototype.isActiveMesh=function(a){return-1!==this._activeMeshes.indexOf(a)},b.prototype._evaluateSubMesh=function(a,b){if(1==b.subMeshes.length||a.isInFrustum(this._frustumPlanes)){var c=a.getMaterial();b.showSubMeshesBoundingBox&&this._boundingBoxRenderer.renderList.push(a.getBoundingInfo().boundingBox),c&&(c.getRenderTargetTextures&&-1===this._processedMaterials.indexOf(c)&&(this._processedMaterials.push(c),this._renderTargets.concat(c.getRenderTargetTextures())),this._activeVertices+=a.verticesCount,this._renderingManager.dispatch(a))}},b.prototype._evaluateActiveMeshes=function(){this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._boundingBoxRenderer.reset(),this._frustumPlanes?a.Frustum.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=a.Frustum.GetPlanes(this._transformMatrix);var b,c;if(this._selectionOctree){var d=this._selectionOctree.select(this._frustumPlanes);b=d.data,c=d.length}else c=this.meshes.length,b=this.meshes;for(var e=0;c>e;e++){var f=b[e];this._totalVertices+=f.getTotalVertices(),f.isReady()&&(f.computeWorldMatrix(),f._preActivate(),f.actionManager&&f.actionManager.hasSpecificTriggers([a.ActionManager.OnIntersectionEnterTrigger,a.ActionManager.OnIntersectionExitTrigger])&&this._meshesForIntersections.pushNoDuplicate(f),f.isEnabled()&&f.isVisible&&f.visibility>0&&0!=(f.layerMask&this.activeCamera.layerMask)&&f.isInFrustum(this._frustumPlanes)&&(this._activeMeshes.push(f),f._activate(this._renderId),this._activeMesh(f)))}var g=(new Date).getTime();if(this.particlesEnabled)for(var h=0;h<this.particleSystems.length;h++){var i=this.particleSystems[h];i.isStarted()&&(!i.emitter.position||i.emitter&&i.emitter.isEnabled())&&(this._activeParticleSystems.push(i),i.animate())}this._particlesDuration+=(new Date).getTime()-g},b.prototype._activeMesh=function(a){if(a.skeleton&&this._activeSkeletons.pushNoDuplicate(a.skeleton),a.showBoundingBox&&this._boundingBoxRenderer.renderList.push(a.getBoundingInfo().boundingBox),a.subMeshes){var b,c;if(a._submeshesOctree&&a.useOctreeForRenderingSelection){var d=a._submeshesOctree.select(this._frustumPlanes);b=d.length,c=d.data}else c=a.subMeshes,b=c.length;for(var e=0;b>e;e++){var f=c[e];this._evaluateSubMesh(f,a)}}},b.prototype.updateTransformMatrix=function(a){this.setTransformMatrix(this.activeCamera.getViewMatrix(),this.activeCamera.getProjectionMatrix(a))},b.prototype._renderForCamera=function(a){var b=this._engine;if(this.activeCamera=a,!this.activeCamera)throw new Error("Active camera not set");b.setViewport(this.activeCamera.viewport),this._renderId++,this.updateTransformMatrix(),this.beforeCameraRender&&this.beforeCameraRender(this.activeCamera);var c=(new Date).getTime();this._evaluateActiveMeshes(),this._evaluateActiveMeshesDuration+=(new Date).getTime()-c;for(var d=0;d<this._activeSkeletons.length;d++){var e=this._activeSkeletons.data[d];e.prepare()}for(var f=0;f<this.customRenderTargets.length;f++){var g=this.customRenderTargets[f];this._renderTargets.push(g)}var h=(new Date).getTime();if(this.renderTargetsEnabled){for(var i=0;i<this._renderTargets.length;i++)g=this._renderTargets.data[i],g._shouldRender()&&(this._renderId++,g.render());this._renderId++}this._renderTargets.length>0&&b.restoreDefaultFramebuffer(),this._renderTargetsDuration=(new Date).getTime()-h,this.postProcessManager._prepareFrame();var j=(new Date).getTime();if(this.layers.length){b.setDepthBuffer(!1);var k,l;for(k=0;k<this.layers.length;k++)l=this.layers[k],l.isBackground&&l.render();b.setDepthBuffer(!0)}this._renderingManager.render(null,null,!0,!0),this._boundingBoxRenderer.render();for(var m=0;m<this.lensFlareSystems.length;m++)this.lensFlareSystems[m].render();if(this.layers.length){for(b.setDepthBuffer(!1),k=0;k<this.layers.length;k++)l=this.layers[k],l.isBackground||l.render();b.setDepthBuffer(!0)}this._renderDuration+=(new Date).getTime()-j,this.postProcessManager._finalizeFrame(a.isIntermediate),this.activeCamera._updateFromScene(),this._renderTargets.reset(),this.afterCameraRender&&this.afterCameraRender(this.activeCamera)},b.prototype._processSubCameras=function(a){if(0==a.subCameras.length)return void this._renderForCamera(a);for(var b=0;b<a.subCameras.length;b++)this._renderForCamera(a.subCameras[b]);this.activeCamera=a,this.setTransformMatrix(this.activeCamera.getViewMatrix(),this.activeCamera.getProjectionMatrix()),this.activeCamera._updateFromScene()},b.prototype._checkIntersections=function(){for(var b=0;b<this._meshesForIntersections.length;b++)for(var c=this._meshesForIntersections.data[b],d=0;d<c.actionManager.actions.length;d++){var e=c.actionManager.actions[d];if(e.trigger==a.ActionManager.OnIntersectionEnterTrigger||e.trigger==a.ActionManager.OnIntersectionExitTrigger){var f=e.getTriggerParameter(),g=f.intersectsMesh(c,!1),h=c._intersectionsInProgress.indexOf(f);if(g&&-1===h&&e.trigger==a.ActionManager.OnIntersectionEnterTrigger)c.actionManager.processTrigger(a.ActionManager.OnIntersectionEnterTrigger,a.ActionEvent.CreateNew(c)),c._intersectionsInProgress.push(f);else if(!g&&h>-1&&e.trigger==a.ActionManager.OnIntersectionExitTrigger){c.actionManager.processTrigger(a.ActionManager.OnIntersectionExitTrigger,a.ActionEvent.CreateNew(c));var i=c._intersectionsInProgress.indexOf(f);i>-1&&c._intersectionsInProgress.splice(i,1)}}}},b.prototype.render=function(){var c=(new Date).getTime();this._particlesDuration=0,this._spritesDuration=0,this._activeParticles=0,this._renderDuration=0,this._evaluateActiveMeshesDuration=0,this._totalVertices=0,this._activeVertices=0,this._meshesForIntersections.reset(),this.actionManager&&this.actionManager.processTrigger(a.ActionManager.OnEveryFrameTrigger,null),this.beforeRender&&this.beforeRender();for(var d=0;d<this._onBeforeRenderCallbacks.length;d++)this._onBeforeRenderCallbacks[d]();var e=Math.max(b.MinDeltaTime,Math.min(a.Tools.GetDeltaTime(),b.MaxDeltaTime));this._animationRatio=.06*e,this._animate(),this._physicsEngine&&this._physicsEngine._runOneStep(e/1e3),this._engine.clear(this.clearColor,this.autoClear||this.forceWireframe,!0);for(var f=0;f<this.lights.length;f++){var g=this.lights[f],h=g.getShadowGenerator();g.isEnabled()&&h&&-1!==h.getShadowMap().getScene().textures.indexOf(h.getShadowMap())&&this._renderTargets.push(h.getShadowMap())}if(this.postProcessRenderPipelineManager.update(),this.activeCameras.length>0)for(var i=this._renderId,j=0;j<this.activeCameras.length;j++)this._renderId=i,this._processSubCameras(this.activeCameras[j]);else this._processSubCameras(this.activeCamera);this._checkIntersections(),this.afterRender&&this.afterRender();for(var k=0;k<this._toBeDisposed.length;k++)this._toBeDisposed.data[k].dispose(),this._toBeDisposed[k]=null;this._toBeDisposed.reset(),this._lastFrameDuration=(new Date).getTime()-c},b.prototype.dispose=function(){this.beforeRender=null,this.afterRender=null,this.skeletons=[],this._boundingBoxRenderer.dispose(),this.onDispose&&this.onDispose(),this.detachControl();var a,b=this._engine.getRenderingCanvas();for(a=0;a<this.cameras.length;a++)this.cameras[a].detachControl(b);for(;this.lights.length;)this.lights[0].dispose();for(;this.meshes.length;)this.meshes[0].dispose(!0);for(;this.cameras.length;)this.cameras[0].dispose();for(;this.materials.length;)this.materials[0].dispose();for(;this.particleSystems.length;)this.particleSystems[0].dispose();for(;this.spriteManagers.length;)this.spriteManagers[0].dispose();for(;this.layers.length;)this.layers[0].dispose();for(;this.textures.length;)this.textures[0].dispose();this.postProcessManager.dispose(),this._physicsEngine&&this.disablePhysicsEngine(),a=this._engine.scenes.indexOf(this),this._engine.scenes.splice(a,1),this._engine.wipeCaches()},b.prototype._getNewPosition=function(a,b,c,d,e,f){"undefined"==typeof f&&(f=null),a.divideToRef(c.radius,this._scaledPosition),b.divideToRef(c.radius,this._scaledVelocity),c.retry=0,c.initialVelocity=this._scaledVelocity,c.initialPosition=this._scaledPosition,this._collideWithWorld(this._scaledPosition,this._scaledVelocity,c,d,e,f),e.multiplyInPlace(c.radius)},b.prototype._collideWithWorld=function(b,c,d,e,f,g){"undefined"==typeof g&&(g=null);var h=10*a.Engine.CollisionsEpsilon;if(d.retry>=e)return void f.copyFrom(b);d._initialize(b,c,h);for(var i=0;i<this.meshes.length;i++){var j=this.meshes[i];j.isEnabled()&&j.checkCollisions&&j.subMeshes&&j!==g&&j._checkCollision(d)}return d.collisionFound?((0!=c.x||0!=c.y||0!=c.z)&&d._getResponse(b,c),c.length()<=h?void f.copyFrom(b):(d.retry++,void this._collideWithWorld(b,c,d,e,f,g))):void b.addToRef(c,f)},b.prototype.createOrUpdateSelectionOctree=function(b,c){"undefined"==typeof b&&(b=64),"undefined"==typeof c&&(c=2),this._selectionOctree||(this._selectionOctree=new a.Octree(a.Octree.CreationFuncForMeshes,b,c));for(var d=new a.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e=new a.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),f=0;f<this.meshes.length;f++){var g=this.meshes[f];g.computeWorldMatrix(!0);var h=g.getBoundingInfo().boundingBox.minimumWorld,i=g.getBoundingInfo().boundingBox.maximumWorld;a.Tools.CheckExtends(h,d,e),a.Tools.CheckExtends(i,d,e)}return this._selectionOctree.update(d,e,this.meshes),this._selectionOctree},b.prototype.createPickingRay=function(b,c,d,e){var f=this._engine;if(!e){if(!this.activeCamera)throw new Error("Active camera not set");e=this.activeCamera}var g=e.viewport,h=g.toGlobal(f);return b=b/this._engine.getHardwareScalingLevel()-h.x,c=c/this._engine.getHardwareScalingLevel()-(this._engine.getRenderHeight()-h.y-h.height),a.Ray.CreateNew(b/window.devicePixelRatio,c/window.devicePixelRatio,h.width,h.height,d?d:a.Matrix.Identity(),e.getViewMatrix(),e.getProjectionMatrix())},b.prototype._internalPick=function(b,c,d){for(var e=null,f=0;f<this.meshes.length;f++){var g=this.meshes[f];if(c){if(!c(g))continue}else if(!g.isEnabled()||!g.isVisible||!g.isPickable)continue;var h=g.getWorldMatrix(),i=b(h),j=g.intersects(i,d);if(j&&j.hit&&(d||null==e||!(j.distance>=e.distance))&&(e=j,d))break}return e||new a.PickingInfo},b.prototype.pick=function(a,b,c,d,e){var f=this;return this._internalPick(function(c){return f.createPickingRay(a,b,c,e)},c,d)},b.prototype.pickWithRay=function(b,c,d){var e=this;return this._internalPick(function(c){return e._pickWithRayInverseMatrix||(e._pickWithRayInverseMatrix=a.Matrix.Identity()),c.invertToRef(e._pickWithRayInverseMatrix),a.Ray.Transform(b,e._pickWithRayInverseMatrix)},c,d)},b.prototype.setPointerOverMesh=function(b){this._pointerOverMesh!==b&&(this._pointerOverMesh&&this._pointerOverMesh.actionManager&&this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOutTrigger,a.ActionEvent.CreateNew(this._pointerOverMesh)),this._pointerOverMesh=b,this._pointerOverMesh&&this._pointerOverMesh.actionManager&&this._pointerOverMesh.actionManager.processTrigger(a.ActionManager.OnPointerOverTrigger,a.ActionEvent.CreateNew(this._pointerOverMesh)))},b.prototype.getPointerOverMesh=function(){return this._pointerOverMesh},b.prototype.getPhysicsEngine=function(){return this._physicsEngine},b.prototype.enablePhysics=function(b,c){return this._physicsEngine?!0:(this._physicsEngine=new a.PhysicsEngine(c),this._physicsEngine.isSupported()?(this._physicsEngine._initialize(b),!0):(this._physicsEngine=null,!1))},b.prototype.disablePhysicsEngine=function(){this._physicsEngine&&(this._physicsEngine.dispose(),this._physicsEngine=void 0)},b.prototype.isPhysicsEnabled=function(){return void 0!==this._physicsEngine},b.prototype.setGravity=function(a){this._physicsEngine&&this._physicsEngine._setGravity(a)},b.prototype.createCompoundImpostor=function(a,b){if(a.parts&&(b=a,a=a.parts),!this._physicsEngine)return null;for(var c=0;c<a.length;c++){var d=a[c].mesh;d._physicImpostor=a[c].impostor,d._physicsMass=b.mass/a.length,d._physicsFriction=b.friction,d._physicRestitution=b.restitution}return this._physicsEngine._registerMeshesAsCompound(a,b)},b.prototype.deleteCompoundImpostor=function(b){for(var c=0;c<b.parts.length;c++){var d=b.parts[c].mesh;d._physicImpostor=a.PhysicsEngine.NoImpostor,this._physicsEngine._unregisterMesh(d)}},b.prototype._getByTags=function(b,c){if(void 0===c)return b;var d=[];for(var e in b){var f=b[e];a.Tags.MatchesQuery(f,c)&&d.push(f)}return d},b.prototype.getMeshesByTags=function(a){return this._getByTags(this.meshes,a)},b.prototype.getCamerasByTags=function(a){return this._getByTags(this.cameras,a)},b.prototype.getLightsByTags=function(a){return this._getByTags(this.lights,a)},b.prototype.getMaterialByTags=function(a){return this._getByTags(this.materials,a).concat(this._getByTags(this.multiMaterials,a))},b.FOGMODE_NONE=0,b.FOGMODE_EXP=1,b.FOGMODE_EXP2=2,b.FOGMODE_LINEAR=3,b.MinDeltaTime=1,b.MaxDeltaTime=1e3,b}();a.Scene=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(c,d,e,f,g){switch(this._engine=c instanceof a.Mesh?c.getScene().getEngine():c,this._updatable=f,this._data=d,g||this.create(),this._kind=e,e){case b.PositionKind:this._strideSize=3;break;case b.NormalKind:this._strideSize=3;break;case b.UVKind:this._strideSize=2;break;case b.UV2Kind:this._strideSize=2;break;case b.ColorKind:this._strideSize=3;break;case b.MatricesIndicesKind:this._strideSize=4;break;case b.MatricesWeightsKind:this._strideSize=4}}return b.prototype.isUpdatable=function(){return this._updatable},b.prototype.getData=function(){return this._data},b.prototype.getBuffer=function(){return this._buffer},b.prototype.getStrideSize=function(){return this._strideSize},b.prototype.create=function(a){(a||!this._buffer)&&(a=a||this._data,this._buffer||(this._buffer=this._updatable?this._engine.createDynamicVertexBuffer(4*a.length):this._engine.createVertexBuffer(a)),this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,a),this._data=a))},b.prototype.update=function(a){this.create(a)},b.prototype.dispose=function(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)},Object.defineProperty(b,"PositionKind",{get:function(){return b._PositionKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"NormalKind",{get:function(){return b._NormalKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"UVKind",{get:function(){return b._UVKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"UV2Kind",{get:function(){return b._UV2Kind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ColorKind",{get:function(){return b._ColorKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"MatricesIndicesKind",{get:function(){return b._MatricesIndicesKind},enumerable:!0,configurable:!0}),Object.defineProperty(b,"MatricesWeightsKind",{get:function(){return b._MatricesWeightsKind},enumerable:!0,configurable:!0}),b._PositionKind="position",b._NormalKind="normal",b._UVKind="uv",b._UV2Kind="uv2",b._ColorKind="color",b._MatricesIndicesKind="matricesIndices",b._MatricesWeightsKind="matricesWeights",b}();a.VertexBuffer=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.position=new a.Vector3(0,0,0),this.rotation=new a.Vector3(0,0,0),this.scaling=new a.Vector3(1,1,1),this.billboardMode=a.AbstractMesh.BILLBOARDMODE_NONE,this.visibility=1,this.infiniteDistance=!1,this.isVisible=!0,this.isPickable=!0,this.showBoundingBox=!1,this.showSubMeshesBoundingBox=!1,this.onDispose=null,this.checkCollisions=!1,this.renderingGroupId=0,this.receiveShadows=!1,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.layerMask=4294967295,this._physicImpostor=a.PhysicsEngine.NoImpostor,this.ellipsoid=new a.Vector3(.5,1,.5),this.ellipsoidOffset=new a.Vector3(0,0,0),this._collider=new a.Collider,this._oldPositionForCollisions=new a.Vector3(0,0,0),this._diffPositionForCollisions=new a.Vector3(0,0,0),this._newPositionForCollisions=new a.Vector3(0,0,0),this._localScaling=a.Matrix.Zero(),this._localRotation=a.Matrix.Zero(),this._localTranslation=a.Matrix.Zero(),this._localBillboard=a.Matrix.Zero(),this._localPivotScaling=a.Matrix.Zero(),this._localPivotScalingRotation=a.Matrix.Zero(),this._localWorld=a.Matrix.Zero(),this._worldMatrix=a.Matrix.Zero(),this._rotateYByPI=a.Matrix.RotationY(Math.PI),this._absolutePosition=a.Vector3.Zero(),this._collisionsTransformMatrix=a.Matrix.Zero(),this._collisionsScalingMatrix=a.Matrix.Zero(),this._isDirty=!1,this._pivotMatrix=a.Matrix.Identity(),this._isDisposed=!1,this._renderId=0,this._intersectionsInProgress=new Array,d.meshes.push(this)}return __extends(c,b),Object.defineProperty(c,"BILLBOARDMODE_NONE",{get:function(){return c._BILLBOARDMODE_NONE},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_X",{get:function(){return c._BILLBOARDMODE_X},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_Y",{get:function(){return c._BILLBOARDMODE_Y},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_Z",{get:function(){return c._BILLBOARDMODE_Z},enumerable:!0,configurable:!0}),Object.defineProperty(c,"BILLBOARDMODE_ALL",{get:function(){return c._BILLBOARDMODE_ALL},enumerable:!0,configurable:!0}),c.prototype.getTotalVertices=function(){return 0},c.prototype.getIndices=function(){return null},c.prototype.getVerticesData=function(){return null},c.prototype.isVerticesDataPresent=function(){return!1},c.prototype.getBoundingInfo=function(){return this._boundingInfo||this._updateBoundingInfo(),this._boundingInfo},c.prototype._preActivate=function(){},c.prototype._activate=function(a){this._renderId=a},c.prototype.getWorldMatrix=function(){return this._currentRenderId!==this.getScene().getRenderId()&&this.computeWorldMatrix(),this._worldMatrix},Object.defineProperty(c.prototype,"worldMatrixFromCache",{get:function(){return this._worldMatrix},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"absolutePosition",{get:function(){return this._absolutePosition},enumerable:!0,configurable:!0}),c.prototype.rotate=function(b,c,d){if(this.rotationQuaternion||(this.rotationQuaternion=a.Quaternion.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation=a.Vector3.Zero()),d&&0!=d){if(this.parent){var e=this.parent.getWorldMatrix().clone();e.invert(),b=a.Vector3.TransformNormal(b,e)}f=a.Quaternion.RotationAxis(b,c),this.rotationQuaternion=f.multiply(this.rotationQuaternion)}else{var f=a.Quaternion.RotationAxis(b,c);this.rotationQuaternion=this.rotationQuaternion.multiply(f)}},c.prototype.translate=function(a,b,c){var d=a.scale(b);if(c&&0!=c)this.setAbsolutePosition(this.getAbsolutePosition().add(d));else{var e=this.getPositionExpressedInLocalSpace().add(d);this.setPositionWithLocalVector(e)}},c.prototype.getAbsolutePosition=function(){return this.computeWorldMatrix(),this._absolutePosition},c.prototype.setAbsolutePosition=function(b){if(b){var c,d,e;if(void 0===b.x){if(arguments.length<3)return;c=arguments[0],d=arguments[1],e=arguments[2]}else c=b.x,d=b.y,e=b.z;if(this.parent){var f=this.parent.getWorldMatrix().clone();f.invert();var g=new a.Vector3(c,d,e);this.position=a.Vector3.TransformCoordinates(g,f)}else this.position.x=c,this.position.y=d,this.position.z=e}},c.prototype.setPivotMatrix=function(a){this._pivotMatrix=a,this._cache.pivotMatrixUpdated=!0},c.prototype.getPivotMatrix=function(){return this._pivotMatrix},c.prototype._isSynchronized=function(){if(this._isDirty)return!1;if(this.billboardMode!==c.BILLBOARDMODE_NONE)return!1;if(this._cache.pivotMatrixUpdated)return!1;if(this.infiniteDistance)return!1;if(!this._cache.position.equals(this.position))return!1;if(this.rotationQuaternion){if(!this._cache.rotationQuaternion.equals(this.rotationQuaternion))return!1}else if(!this._cache.rotation.equals(this.rotation))return!1;return this._cache.scaling.equals(this.scaling)?!0:!1},c.prototype._initCache=function(){b.prototype._initCache.call(this),this._cache.localMatrixUpdated=!1,this._cache.position=a.Vector3.Zero(),this._cache.scaling=a.Vector3.Zero(),this._cache.rotation=a.Vector3.Zero(),this._cache.rotationQuaternion=new a.Quaternion(0,0,0,0)},c.prototype.markAsDirty=function(a){"rotation"===a&&(this.rotationQuaternion=null),this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0},c.prototype._updateBoundingInfo=function(){if(this._boundingInfo=this._boundingInfo||new a.BoundingInfo(this.absolutePosition,this.absolutePosition),this._boundingInfo._update(this.worldMatrixFromCache),this.subMeshes)for(var b=0;b<this.subMeshes.length;b++){var c=this.subMeshes[b];c.updateBoundingInfo(this.worldMatrixFromCache)}},c.prototype.computeWorldMatrix=function(b){if(!b&&(this._currentRenderId==this.getScene().getRenderId()||this.isSynchronized(!0)))return this._worldMatrix;if(this._cache.position.copyFrom(this.position),this._cache.scaling.copyFrom(this.scaling),this._cache.pivotMatrixUpdated=!1,this._currentRenderId=this.getScene().getRenderId(),this._isDirty=!1,a.Matrix.ScalingToRef(this.scaling.x,this.scaling.y,this.scaling.z,this._localScaling),this.rotationQuaternion?(this.rotationQuaternion.toRotationMatrix(this._localRotation),this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)):(a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._localRotation),this._cache.rotation.copyFrom(this.rotation)),this.infiniteDistance&&!this.parent){var d=this.getScene().activeCamera,e=d.getWorldMatrix(),f=new a.Vector3(e.m[12],e.m[13],e.m[14]);a.Matrix.TranslationToRef(this.position.x+f.x,this.position.y+f.y,this.position.z+f.z,this._localTranslation)}else a.Matrix.TranslationToRef(this.position.x,this.position.y,this.position.z,this._localTranslation);if(this._pivotMatrix.multiplyToRef(this._localScaling,this._localPivotScaling),this._localPivotScaling.multiplyToRef(this._localRotation,this._localPivotScalingRotation),this.billboardMode!==c.BILLBOARDMODE_NONE){var g=this.position.clone(),h=this.getScene().activeCamera.position.clone();this.parent&&this.parent.position&&(g.addInPlace(this.parent.position),a.Matrix.TranslationToRef(g.x,g.y,g.z,this._localTranslation)),(this.billboardMode&c.BILLBOARDMODE_ALL)===c.BILLBOARDMODE_ALL?h=this.getScene().activeCamera.position:(this.billboardMode&a.AbstractMesh.BILLBOARDMODE_X&&(h.x=g.x+a.Engine.Epsilon),this.billboardMode&a.AbstractMesh.BILLBOARDMODE_Y&&(h.y=g.y+.001),this.billboardMode&a.AbstractMesh.BILLBOARDMODE_Z&&(h.z=g.z+.001)),a.Matrix.LookAtLHToRef(g,h,a.Vector3.Up(),this._localBillboard),this._localBillboard.m[12]=this._localBillboard.m[13]=this._localBillboard.m[14]=0,this._localBillboard.invert(),this._localPivotScalingRotation.multiplyToRef(this._localBillboard,this._localWorld),this._rotateYByPI.multiplyToRef(this._localWorld,this._localPivotScalingRotation)}return this._localPivotScalingRotation.multiplyToRef(this._localTranslation,this._localWorld),this.parent&&this.parent.getWorldMatrix&&this.billboardMode===a.AbstractMesh.BILLBOARDMODE_NONE?this._localWorld.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix):this._worldMatrix.copyFrom(this._localWorld),this._updateBoundingInfo(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._worldMatrix},c.prototype.setPositionWithLocalVector=function(b){this.computeWorldMatrix(),this.position=a.Vector3.TransformNormal(b,this._localWorld)},c.prototype.getPositionExpressedInLocalSpace=function(){this.computeWorldMatrix();var b=this._localWorld.clone();return b.invert(),a.Vector3.TransformNormal(this.position,b)},c.prototype.locallyTranslate=function(b){this.computeWorldMatrix(),this.position=a.Vector3.TransformCoordinates(b,this._localWorld)},c.prototype.lookAt=function(b,c,d,e){c=c||0,d=d||0,e=e||0;var f=b.subtract(this.position),g=-Math.atan2(f.z,f.x)-Math.PI/2,h=Math.sqrt(f.x*f.x+f.z*f.z),i=Math.atan2(f.y,h);this.rotationQuaternion=a.Quaternion.RotationYawPitchRoll(g+c,i+d,e)},c.prototype.isInFrustum=function(a){return this._boundingInfo.isInFrustum(a)?!0:!1},c.prototype.intersectsMesh=function(a,b){return this._boundingInfo&&a._boundingInfo?this._boundingInfo.intersects(a._boundingInfo,b):!1},c.prototype.intersectsPoint=function(a){return this._boundingInfo?this._boundingInfo.intersectsPoint(a):!1},c.prototype.setPhysicsState=function(b,c){var d=this.getScene().getPhysicsEngine();if(d){if(b.impostor&&(c=b,b=b.impostor),b=b||a.PhysicsEngine.NoImpostor,b===a.PhysicsEngine.NoImpostor)return void d._unregisterMesh(this);c.mass=c.mass||0,c.friction=c.friction||.2,c.restitution=c.restitution||.9,this._physicImpostor=b,this._physicsMass=c.mass,this._physicsFriction=c.friction,this._physicRestitution=c.restitution,d._registerMesh(this,b,c)}},c.prototype.getPhysicsImpostor=function(){return this._physicImpostor?this._physicImpostor:a.PhysicsEngine.NoImpostor},c.prototype.getPhysicsMass=function(){return this._physicsMass?this._physicsMass:0},c.prototype.getPhysicsFriction=function(){return this._physicsFriction?this._physicsFriction:0},c.prototype.getPhysicsRestitution=function(){return this._physicRestitution?this._physicRestitution:0},c.prototype.applyImpulse=function(a,b){this._physicImpostor&&this.getScene().getPhysicsEngine()._applyImpulse(this,a,b)},c.prototype.setPhysicsLinkWith=function(a,b,c,d){this._physicImpostor&&this.getScene().getPhysicsEngine()._createLink(this,a,b,c,d)},c.prototype.updatePhysicsBodyPosition=function(){this._physicImpostor&&this.getScene().getPhysicsEngine()._updateBodyPosition(this)},c.prototype.moveWithCollisions=function(b){var c=this.getAbsolutePosition();c.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPositionForCollisions),this._oldPositionForCollisions.addInPlace(this.ellipsoidOffset),this._collider.radius=this.ellipsoid,this.getScene()._getNewPosition(this._oldPositionForCollisions,b,this._collider,3,this._newPositionForCollisions,this),this._newPositionForCollisions.subtractToRef(this._oldPositionForCollisions,this._diffPositionForCollisions),this._diffPositionForCollisions.length()>a.Engine.CollisionsEpsilon&&this.position.addInPlace(this._diffPositionForCollisions)},c.prototype.createOrUpdateSubmeshesOctree=function(b,c){"undefined"==typeof b&&(b=64),"undefined"==typeof c&&(c=2),this._submeshesOctree||(this._submeshesOctree=new a.Octree(a.Octree.CreationFuncForSubMeshes,b,c)),this.computeWorldMatrix(!0);var d=this.getBoundingInfo().boundingBox;return this._submeshesOctree.update(d.minimumWorld,d.maximumWorld,this.subMeshes),this._submeshesOctree},c.prototype._collideForSubMesh=function(b,c,d){if(this._generatePointsArray(),!b._lastColliderWorldVertices||!b._lastColliderTransformMatrix.equals(c)){b._lastColliderTransformMatrix=c.clone(),b._lastColliderWorldVertices=[],b._trianglePlanes=[];for(var e=b.verticesStart,f=b.verticesStart+b.verticesCount,g=e;f>g;g++)b._lastColliderWorldVertices.push(a.Vector3.TransformCoordinates(this._positions[g],c))}d._collide(b,b._lastColliderWorldVertices,this.getIndices(),b.indexStart,b.indexStart+b.indexCount,b.verticesStart)},c.prototype._processCollisionsForSubMeshes=function(a,b){var c,d;if(this._submeshesOctree&&this.useOctreeForCollisions){var e=a.velocityWorldLength+Math.max(a.radius.x,a.radius.y,a.radius.z),f=this._submeshesOctree.intersects(a.basePointWorld,e);d=f.length,c=f.data}else c=this.subMeshes,d=c.length;for(var g=0;d>g;g++){var h=c[g];d>1&&!h._checkCollision(a)||this._collideForSubMesh(h,b,a)}},c.prototype._checkCollision=function(b){this._boundingInfo._checkCollision(b)&&(a.Matrix.ScalingToRef(1/b.radius.x,1/b.radius.y,1/b.radius.z,this._collisionsScalingMatrix),this.worldMatrixFromCache.multiplyToRef(this._collisionsScalingMatrix,this._collisionsTransformMatrix),this._processCollisionsForSubMeshes(b,this._collisionsTransformMatrix))},c.prototype._generatePointsArray=function(){return!1},c.prototype.intersects=function(b,c){var d=new a.PickingInfo;if(!(this.subMeshes&&this._boundingInfo&&b.intersectsSphere(this._boundingInfo.boundingSphere)&&b.intersectsBox(this._boundingInfo.boundingBox)))return d;if(!this._generatePointsArray())return d;var e,f,g=null;if(this._submeshesOctree&&this.useOctreeForPicking){var h=a.Ray.Transform(b,this.getWorldMatrix()),i=this._submeshesOctree.intersectsRay(h);f=i.length,e=i.data}else e=this.subMeshes,f=e.length;for(var j=0;f>j;j++){var k=e[j];if(!(f>1)||k.canIntersects(b)){var l=k.intersects(b,this._positions,this.getIndices(),c);if(l&&(c||!g||l.distance<g.distance)&&(g=l,c))break}}if(g){var m=this.getWorldMatrix(),n=a.Vector3.TransformCoordinates(b.origin,m),o=b.direction.clone();o.normalize(),o=o.scale(g.distance);var p=a.Vector3.TransformNormal(o,m),q=n.add(p);return d.hit=!0,d.distance=a.Vector3.Distance(n,q),d.pickedPoint=q,d.pickedMesh=this,d.bu=g.bu,d.bv=g.bv,d.faceId=g.faceId,d}return d},c.prototype.clone=function(){return null},c.prototype.releaseSubMeshes=function(){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose();
else this.subMeshes=new Array},c.prototype.dispose=function(b){for(this.getPhysicsImpostor()!=a.PhysicsEngine.NoImpostor&&this.setPhysicsState(a.PhysicsEngine.NoImpostor),e=0;e<this._intersectionsInProgress.length;e++){var c=this._intersectionsInProgress[e],d=c._intersectionsInProgress.indexOf(this);c._intersectionsInProgress.splice(d,1)}this._intersectionsInProgress=[],this.releaseSubMeshes();var e=this.getScene().meshes.indexOf(this);if(this.getScene().meshes.splice(e,1),b)for(e=0;e<this.getScene().meshes.length;e++){var f=this.getScene().meshes[e];f.parent===this&&(f.parent=null,f.computeWorldMatrix(!0))}else{for(e=0;e<this.getScene().particleSystems.length;e++)this.getScene().particleSystems[e].emitter==this&&(this.getScene().particleSystems[e].dispose(),e--);var g=this.getScene().meshes.slice(0);for(e=0;e<g.length;e++)g[e].parent==this&&g[e].dispose()}this._isDisposed=!0,this.onDispose&&this.onDispose()},c._BILLBOARDMODE_NONE=0,c._BILLBOARDMODE_X=1,c._BILLBOARDMODE_Y=2,c._BILLBOARDMODE_Z=4,c._BILLBOARDMODE_ALL=7,c}(a.Node);a.AbstractMesh=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function a(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=new Array}return a}();a._InstancesBatch=b;var c=function(c){function d(d,e){c.call(this,d,e),this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.instances=new Array,this._onBeforeRenderCallbacks=new Array,this._onAfterRenderCallbacks=new Array,this._visibleInstances={},this._renderIdForInstances=new Array,this._batchCache=new b,this._instancesBufferSize=2048}return __extends(d,c),d.prototype.getTotalVertices=function(){return this._geometry?this._geometry.getTotalVertices():0},d.prototype.getVerticesData=function(a){return this._geometry?this._geometry.getVerticesData(a):null},d.prototype.getVertexBuffer=function(a){return this._geometry?this._geometry.getVertexBuffer(a):void 0},d.prototype.isVerticesDataPresent=function(a){return this._geometry?this._geometry.isVerticesDataPresent(a):this._delayInfo?-1!==this._delayInfo.indexOf(a):!1},d.prototype.getVerticesDataKinds=function(){if(!this._geometry){var a=[];if(this._delayInfo)for(var b in this._delayInfo)a.push(b);return a}return this._geometry.getVerticesDataKinds()},d.prototype.getTotalIndices=function(){return this._geometry?this._geometry.getTotalIndices():0},d.prototype.getIndices=function(){return this._geometry?this._geometry.getIndices():[]},d.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING?!1:c.prototype.isReady.call(this)},d.prototype.isDisposed=function(){return this._isDisposed},d.prototype._preActivate=function(){var a=this.getScene().getRenderId();this._preActivateId!=a&&(this._preActivateId=a,this._visibleInstances=null)},d.prototype._registerInstanceForRenderId=function(a,b){this._visibleInstances||(this._visibleInstances={},this._visibleInstances.defaultRenderId=b,this._visibleInstances.selfDefaultRenderId=this._renderId),this._visibleInstances[b]||(this._visibleInstances[b]=new Array),this._visibleInstances[b].push(a)},d.prototype.refreshBoundingInfo=function(){var b=this.getVerticesData(a.VertexBuffer.PositionKind);if(b){var c=a.Tools.ExtractMinAndMax(b,0,this.getTotalVertices());this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)}if(this.subMeshes)for(var d=0;d<this.subMeshes.length;d++)this.subMeshes[d].refreshBoundingInfo();this._updateBoundingInfo()},d.prototype._createGlobalSubMesh=function(){var b=this.getTotalVertices();return b&&this.getIndices()?(this.releaseSubMeshes(),new a.SubMesh(0,0,b,0,this.getTotalIndices(),this)):null},d.prototype.subdivide=function(b){if(!(1>b)){for(var c=this.getTotalIndices(),d=c/b|0,e=0;d%3!=0;)d++;this.releaseSubMeshes();for(var f=0;b>f&&!(e>=c);f++)a.SubMesh.CreateFromIndices(0,e,Math.min(d,c-e),this),e+=d;this.synchronizeInstances()}},d.prototype.setVerticesData=function(b,c,d){if(b instanceof Array){var e=c;c=b,b=e,a.Tools.Warn("Deprecated usage of setVerticesData detected (since v1.12). Current signature is setVerticesData(kind, data, updatable).")}if(this._geometry)this._geometry.setVerticesData(b,c,d);else{var f=new a.VertexData;f.set(c,b);var g=this.getScene();new a.Geometry(a.Geometry.RandomId(),g,f,d,this)}},d.prototype.updateVerticesData=function(a,b,c,d){this._geometry&&(d?(this.makeGeometryUnique(),this.updateVerticesData(a,b,c,!1)):this._geometry.updateVerticesData(a,b,c))},d.prototype.makeGeometryUnique=function(){if(this._geometry){var b=this._geometry.copy(a.Geometry.RandomId());b.applyToMesh(this)}},d.prototype.setIndices=function(b){if(this._geometry)this._geometry.setIndices(b);else{var c=new a.VertexData;c.indices=b;var d=this.getScene();new a.Geometry(a.Geometry.RandomId(),d,c,!1,this)}},d.prototype._bind=function(a,b,c){var d=this.getScene().getEngine(),e=this._geometry.getIndexBuffer();c&&(e=a.getLinesIndexBuffer(this.getIndices(),d)),d.bindMultiBuffers(this._geometry.getVertexBuffers(),e,b)},d.prototype._draw=function(a,b,c){if(this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){var d=this.getScene().getEngine();d.draw(b,b?a.indexStart:0,b?a.indexCount:a.linesIndexCount,c)}},d.prototype.registerBeforeRender=function(a){this._onBeforeRenderCallbacks.push(a)},d.prototype.unregisterBeforeRender=function(a){var b=this._onBeforeRenderCallbacks.indexOf(a);b>-1&&this._onBeforeRenderCallbacks.splice(b,1)},d.prototype.registerAfterRender=function(a){this._onAfterRenderCallbacks.push(a)},d.prototype.unregisterAfterRender=function(a){var b=this._onAfterRenderCallbacks.indexOf(a);b>-1&&this._onAfterRenderCallbacks.splice(b,1)},d.prototype._getInstancesRenderList=function(a){var b=this.getScene();if(this._batchCache.mustReturn=!1,this._batchCache.renderSelf[a]=this.isEnabled()&&this.isVisible,this._batchCache.visibleInstances[a]=null,this._visibleInstances){var c=b.getRenderId();this._batchCache.visibleInstances[a]=this._visibleInstances[c];var d=this._renderId;if(!this._batchCache.visibleInstances[a]&&this._visibleInstances.defaultRenderId&&(this._batchCache.visibleInstances[a]=this._visibleInstances[this._visibleInstances.defaultRenderId],c=this._visibleInstances.defaultRenderId,d=this._visibleInstances.selfDefaultRenderId),this._batchCache.visibleInstances[a]&&this._batchCache.visibleInstances[a].length){if(this._renderIdForInstances[a]===c)return this._batchCache.mustReturn=!0,this._batchCache;c!==d&&(this._batchCache.renderSelf[a]=!1)}this._renderIdForInstances[a]=c}return this._batchCache},d.prototype._renderWithInstances=function(a,b,c,d,e){for(var f=this.instances.length+1,g=16*f*4;this._instancesBufferSize<g;)this._instancesBufferSize*=2;(!this._worldMatricesInstancesBuffer||this._worldMatricesInstancesBuffer.capacity<this._instancesBufferSize)&&(this._worldMatricesInstancesBuffer&&e.deleteInstancesBuffer(this._worldMatricesInstancesBuffer),this._worldMatricesInstancesBuffer=e.createInstancesBuffer(this._instancesBufferSize),this._worldMatricesInstancesArray=new Float32Array(this._instancesBufferSize/4));var h=0,i=0,j=this.getWorldMatrix();c.renderSelf[a._id]&&(j.copyToArray(this._worldMatricesInstancesArray,h),h+=16,i++);var k=c.visibleInstances[a._id];if(k)for(var l=0;l<k.length;l++){var m=k[l];m.getWorldMatrix().copyToArray(this._worldMatricesInstancesArray,h),h+=16,i++}var n=d.getAttributeLocationByName("world0"),o=d.getAttributeLocationByName("world1"),p=d.getAttributeLocationByName("world2"),q=d.getAttributeLocationByName("world3"),r=[n,o,p,q];e.updateAndBindInstancesBuffer(this._worldMatricesInstancesBuffer,this._worldMatricesInstancesArray,r),this._draw(a,!b,i),e.unBindInstancesBuffer(this._worldMatricesInstancesBuffer,r)},d.prototype.render=function(a){var b=this.getScene(),c=this._getInstancesRenderList(a._id);if(!c.mustReturn&&this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){for(var d=0;d<this._onBeforeRenderCallbacks.length;d++)this._onBeforeRenderCallbacks[d]();var e=b.getEngine(),f=null!==e.getCaps().instancedArrays&&null!==c.visibleInstances[a._id],g=a.getMaterial();if(g&&g.isReady(this,f)){g._preBind();var h=g.getEffect(),i=e.forceWireframe||g.wireframe;this._bind(a,h,i);var j=this.getWorldMatrix();if(g.bind(j,this),f)this._renderWithInstances(a,i,c,h,e);else if(c.renderSelf[a._id]&&this._draw(a,!i),c.visibleInstances[a._id])for(var k=0;k<c.visibleInstances[a._id].length;k++){var l=c.visibleInstances[a._id][k];j=l.getWorldMatrix(),g.bindOnlyWorldMatrix(j),this._draw(a,!i)}for(g.unbind(),d=0;d<this._onAfterRenderCallbacks.length;d++)this._onAfterRenderCallbacks[d]()}}},d.prototype.getEmittedParticleSystems=function(){for(var a=new Array,b=0;b<this.getScene().particleSystems.length;b++){var c=this.getScene().particleSystems[b];c.emitter===this&&a.push(c)}return a},d.prototype.getHierarchyEmittedParticleSystems=function(){var a=new Array,b=this.getDescendants();b.push(this);for(var c=0;c<this.getScene().particleSystems.length;c++){var d=this.getScene().particleSystems[c];-1!==b.indexOf(d.emitter)&&a.push(d)}return a},d.prototype.getChildren=function(){for(var a=[],b=0;b<this.getScene().meshes.length;b++){var c=this.getScene().meshes[b];c.parent==this&&a.push(c)}return a},d.prototype._checkDelayState=function(){var b=this,c=this,d=this.getScene();this._geometry?this._geometry.load(d):c.delayLoadState===a.Engine.DELAYLOADSTATE_NOTLOADED&&(c.delayLoadState=a.Engine.DELAYLOADSTATE_LOADING,d._addPendingData(c),a.Tools.LoadFile(this.delayLoadingFile,function(c){b._delayLoadingFunction(JSON.parse(c),b),b.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,d._removePendingData(b)},function(){},d.database))},d.prototype.isInFrustum=function(b){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADING?!1:c.prototype.isInFrustum.call(this,b)?(this._checkDelayState(),!0):!1},d.prototype.setMaterialByID=function(a){for(var b=this.getScene().materials,c=0;c<b.length;c++)if(b[c].id==a)return void(this.material=b[c]);var d=this.getScene().multiMaterials;for(c=0;c<d.length;c++)if(d[c].id==a)return void(this.material=d[c])},d.prototype.getAnimatables=function(){var a=[];return this.material&&a.push(this.material),a},d.prototype.bakeTransformIntoVertices=function(b){if(this.isVerticesDataPresent(a.VertexBuffer.PositionKind)){this._resetPointsArrayCache();for(var c=this.getVerticesData(a.VertexBuffer.PositionKind),d=[],e=0;e<c.length;e+=3)a.Vector3.TransformCoordinates(a.Vector3.FromArray(c,e),b).toArray(d,e);if(this.setVerticesData(a.VertexBuffer.PositionKind,d,this.getVertexBuffer(a.VertexBuffer.PositionKind).isUpdatable()),this.isVerticesDataPresent(a.VertexBuffer.NormalKind)){for(c=this.getVerticesData(a.VertexBuffer.NormalKind),e=0;e<c.length;e+=3)a.Vector3.TransformNormal(a.Vector3.FromArray(c,e),b).toArray(d,e);this.setVerticesData(a.VertexBuffer.NormalKind,d,this.getVertexBuffer(a.VertexBuffer.NormalKind).isUpdatable())}}},d.prototype._resetPointsArrayCache=function(){this._positions=null},d.prototype._generatePointsArray=function(){if(this._positions)return!0;this._positions=[];var b=this.getVerticesData(a.VertexBuffer.PositionKind);if(!b)return!1;for(var c=0;c<b.length;c+=3)this._positions.push(a.Vector3.FromArray(b,c));return!0},d.prototype.clone=function(b,c,d){var e=new a.Mesh(b,this.getScene());if(this._geometry.applyToMesh(e),a.Tools.DeepCopy(this,e,["name","material","skeleton"],[]),e.material=this.material,c&&(e.parent=c),!d)for(var f=0;f<this.getScene().meshes.length;f++){var g=this.getScene().meshes[f];g.parent==this&&g.clone(g.name,e)}for(f=0;f<this.getScene().particleSystems.length;f++){var h=this.getScene().particleSystems[f];h.emitter==this&&h.clone(h.name,e)}return e.computeWorldMatrix(!0),e},d.prototype.dispose=function(a){for(this._geometry&&this._geometry.releaseForMesh(this,!0),this._worldMatricesInstancesBuffer&&(this.getEngine().deleteInstancesBuffer(this._worldMatricesInstancesBuffer),this._worldMatricesInstancesBuffer=null);this.instances.length;)this.instances[0].dispose();c.prototype.dispose.call(this,a)},d.prototype.convertToFlatShadedMesh=function(){for(var b=this.getVerticesDataKinds(),c=[],d=[],e=[],f=!1,g=0;g<b.length;g++){var h=b[g],i=this.getVertexBuffer(h);h!==a.VertexBuffer.NormalKind?(c[h]=i,d[h]=c[h].getData(),e[h]=[]):(f=i.isUpdatable(),b.splice(g,1),g--)}var j=this.subMeshes.slice(0),k=this.getIndices(),l=this.getTotalIndices();for(r=0;l>r;r++){var m=k[r];for(g=0;g<b.length;g++){h=b[g];for(var n=c[h].getStrideSize(),o=0;n>o;o++)e[h].push(d[h][m*n+o])}}for(var p=[],q=e[a.VertexBuffer.PositionKind],r=0;l>r;r+=3){k[r]=r,k[r+1]=r+1,k[r+2]=r+2;for(var s=a.Vector3.FromArray(q,3*r),t=a.Vector3.FromArray(q,3*(r+1)),u=a.Vector3.FromArray(q,3*(r+2)),v=s.subtract(t),w=u.subtract(t),x=a.Vector3.Normalize(a.Vector3.Cross(v,w)),y=0;3>y;y++)p.push(x.x),p.push(x.y),p.push(x.z)}for(this.setIndices(k),this.setVerticesData(a.VertexBuffer.NormalKind,p,f),g=0;g<b.length;g++)h=b[g],this.setVerticesData(h,e[h],c[h].isUpdatable());this.releaseSubMeshes();for(var z=0;z<j.length;z++){var A=j[z];new a.SubMesh(A.materialIndex,A.indexStart,A.indexCount,A.indexStart,A.indexCount,this)}this.synchronizeInstances()},d.prototype.createInstance=function(b){return new a.InstancedMesh(b,this)},d.prototype.synchronizeInstances=function(){for(var a=0;a<this.instances.length;a++){var b=this.instances[a];b._syncSubMeshes()}},d.CreateBox=function(b,c,d,e){var f=new a.Mesh(b,d),g=a.VertexData.CreateBox(c);return g.applyToMesh(f,e),f},d.CreateSphere=function(b,c,d,e,f){var g=new a.Mesh(b,e),h=a.VertexData.CreateSphere(c,d);return h.applyToMesh(g,f),g},d.CreateCylinder=function(b,c,d,e,f,g,h,i){void 0!==h&&h instanceof a.Scene||(void 0!==h&&(i=h),h=g,g=1);var j=new a.Mesh(b,h),k=a.VertexData.CreateCylinder(c,d,e,f,g);return k.applyToMesh(j,i),j},d.CreateTorus=function(b,c,d,e,f,g){var h=new a.Mesh(b,f),i=a.VertexData.CreateTorus(c,d,e);return i.applyToMesh(h,g),h},d.CreateTorusKnot=function(b,c,d,e,f,g,h,i,j){var k=new a.Mesh(b,i),l=a.VertexData.CreateTorusKnot(c,d,e,f,g,h);return l.applyToMesh(k,j),k},d.CreateLines=function(b,c,d,e){var f=new a.LinesMesh(b,d,e),g=a.VertexData.CreateLines(c);return g.applyToMesh(f,e),f},d.CreatePlane=function(b,c,d,e){var f=new a.Mesh(b,d),g=a.VertexData.CreatePlane(c);return g.applyToMesh(f,e),f},d.CreateGround=function(b,c,d,e,f,g){var h=new a.GroundMesh(b,f);h._setReady(!1),h._subdivisions=e;var i=a.VertexData.CreateGround(c,d,e);return i.applyToMesh(h,g),h._setReady(!0),h},d.CreateTiledGround=function(b,c,d,e,f,g,h,i,j){var k=new a.Mesh(b,i),l=a.VertexData.CreateTiledGround(c,d,e,f,g,h);return l.applyToMesh(k,j),k},d.CreateGroundFromHeightMap=function(b,c,d,e,f,g,h,i,j){var k=new a.GroundMesh(b,i);k._subdivisions=f,k._setReady(!1);var l=function(b){var c=document.createElement("canvas"),i=c.getContext("2d"),l=b.width,m=b.height;c.width=l,c.height=m,i.drawImage(b,0,0);var n=i.getImageData(0,0,l,m).data,o=a.VertexData.CreateGroundFromHeightMap(d,e,f,g,h,n,l,m);o.applyToMesh(k,j),k._setReady(!0)};return a.Tools.LoadImage(c,l,function(){},i.database),k},d.MinMax=function(a){var b=null,c=null;for(var d in a){var e=a[d],f=e.getBoundingInfo().boundingBox;b?(b.MinimizeInPlace(f.minimumWorld),c.MaximizeInPlace(f.maximumWorld)):(b=f.minimumWorld,c=f.maximumWorld)}return{min:b,max:c}},d.Center=function(b){var c=void 0!==b.min?b:a.Mesh.MinMax(b);return a.Vector3.Center(c.min,c.max)},d}(a.AbstractMesh);a.Mesh=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d){b.call(this,c,d),this.generateOctree=!1,this._worldInverse=new a.Matrix}return __extends(c,b),Object.defineProperty(c.prototype,"subdivisions",{get:function(){return this._subdivisions},enumerable:!0,configurable:!0}),c.prototype.optimize=function(){this.subdivide(this._subdivisions),this.createOrUpdateSubmeshesOctree(32)},c.prototype.getHeightAtCoordinates=function(b,c){var d=new a.Ray(new a.Vector3(b,this.getBoundingInfo().boundingBox.maximumWorld.y+1,c),new a.Vector3(0,-1,0));this.getWorldMatrix().invertToRef(this._worldInverse),d=a.Ray.Transform(d,this._worldInverse);var e=this.intersects(d);return e.hit?e.pickedPoint.y:0},c}(a.Mesh);a.GroundMesh=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c){b.call(this,a,c.getScene()),c.instances.push(this),this._sourceMesh=c,this.position.copyFrom(c.position),this.rotation.copyFrom(c.rotation),this.scaling.copyFrom(c.scaling),c.rotationQuaternion&&(this.rotationQuaternion=c.rotationQuaternion.clone()),this.infiniteDistance=c.infiniteDistance,this.setPivotMatrix(c.getPivotMatrix()),this.refreshBoundingInfo(),this._syncSubMeshes()}return __extends(c,b),Object.defineProperty(c.prototype,"receiveShadows",{get:function(){return this._sourceMesh.receiveShadows},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"material",{get:function(){return this._sourceMesh.material},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"visibility",{get:function(){return this._sourceMesh.visibility},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"skeleton",{get:function(){return this._sourceMesh.skeleton},enumerable:!0,configurable:!0}),c.prototype.getTotalVertices=function(){return this._sourceMesh.getTotalVertices()},Object.defineProperty(c.prototype,"sourceMesh",{get:function(){return this._sourceMesh},enumerable:!0,configurable:!0}),c.prototype.getVerticesData=function(a){return this._sourceMesh.getVerticesData(a)},c.prototype.isVerticesDataPresent=function(a){return this._sourceMesh.isVerticesDataPresent(a)},c.prototype.getIndices=function(){return this._sourceMesh.getIndices()},Object.defineProperty(c.prototype,"_positions",{get:function(){return this._sourceMesh._positions},enumerable:!0,configurable:!0}),c.prototype.refreshBoundingInfo=function(){var b=this._sourceMesh.getVerticesData(a.VertexBuffer.PositionKind);if(b){var c=a.Tools.ExtractMinAndMax(b,0,this._sourceMesh.getTotalVertices());this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)}this._updateBoundingInfo()},c.prototype._preActivate=function(){this.sourceMesh._preActivate()},c.prototype._activate=function(a){this.sourceMesh._registerInstanceForRenderId(this,a)},c.prototype._syncSubMeshes=function(){this.releaseSubMeshes();for(var a=0;a<this._sourceMesh.subMeshes.length;a++)this._sourceMesh.subMeshes[a].clone(this,this._sourceMesh)},c.prototype._generatePointsArray=function(){return this._sourceMesh._generatePointsArray()},c.prototype.clone=function(b,c,d){var e=this._sourceMesh.createInstance(b);if(a.Tools.DeepCopy(this,e,["name"],[]),this.refreshBoundingInfo(),c&&(e.parent=c),!d)for(var f=0;f<this.getScene().meshes.length;f++){var g=this.getScene().meshes[f];g.parent==this&&g.clone(g.name,e)}return e.computeWorldMatrix(!0),e},c.prototype.dispose=function(a){var c=this._sourceMesh.instances.indexOf(this);this._sourceMesh.instances.splice(c,1),b.prototype.dispose.call(this,a)},c}(a.AbstractMesh);a.InstancedMesh=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h){"undefined"==typeof h&&(h=!0),this.materialIndex=a,this.verticesStart=b,this.verticesCount=c,this.indexStart=d,this.indexCount=e,this._renderId=0,this._mesh=f,this._renderingMesh=g||f,f.subMeshes.push(this),this._id=f.subMeshes.length-1,h&&this.refreshBoundingInfo()}return b.prototype.getBoundingInfo=function(){return this._boundingInfo},b.prototype.getMesh=function(){return this._mesh},b.prototype.getRenderingMesh=function(){return this._renderingMesh},b.prototype.getMaterial=function(){var b=this._renderingMesh.material;if(b&&b instanceof a.MultiMaterial){var c=b;return c.getSubMaterial(this.materialIndex)}return b?b:this._mesh.getScene().defaultMaterial},b.prototype.refreshBoundingInfo=function(){var b=this._renderingMesh.getVerticesData(a.VertexBuffer.PositionKind);if(!b)return void(this._boundingInfo=this._mesh._boundingInfo);var c,d=this._renderingMesh.getIndices();c=0===this.indexStart&&this.indexCount===d.length?a.Tools.ExtractMinAndMax(b,this.verticesStart,this.verticesCount):a.Tools.ExtractMinAndMaxIndexed(b,d,this.indexStart,this.indexCount),this._boundingInfo=new a.BoundingInfo(c.minimum,c.maximum)},b.prototype._checkCollision=function(a){return this._boundingInfo._checkCollision(a)},b.prototype.updateBoundingInfo=function(a){this._boundingInfo||this.refreshBoundingInfo(),this._boundingInfo._update(a)},b.prototype.isInFrustum=function(a){return this._boundingInfo.isInFrustum(a)},b.prototype.render=function(){this._renderingMesh.render(this)},b.prototype.getLinesIndexBuffer=function(a,b){if(!this._linesIndexBuffer){for(var c=[],d=this.indexStart;d<this.indexStart+this.indexCount;d+=3)c.push(a[d],a[d+1],a[d+1],a[d+2],a[d+2],a[d]);this._linesIndexBuffer=b.createIndexBuffer(c),this.linesIndexCount=c.length}return this._linesIndexBuffer},b.prototype.canIntersects=function(a){return a.intersectsBox(this._boundingInfo.boundingBox)},b.prototype.intersects=function(a,b,c,d){for(var e=null,f=this.indexStart;f<this.indexStart+this.indexCount;f+=3){var g=b[c[f]],h=b[c[f+1]],i=b[c[f+2]],j=a.intersectsTriangle(g,h,i);if(j&&(d||!e||j.distance<e.distance)&&(e=j,e.faceId=f/3,d))break}return e},b.prototype.clone=function(c,d){var e=new b(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,c,d,!1);return e._boundingInfo=new a.BoundingInfo(this._boundingInfo.minimum,this._boundingInfo.maximum),e},b.prototype.dispose=function(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);var a=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(a,1)},b.CreateFromIndices=function(b,c,d,e,f){var g=Number.MAX_VALUE,h=-Number.MAX_VALUE;f=f||e;for(var i=f.getIndices(),j=c;c+d>j;j++){var k=i[j];g>k&&(g=k),k>h&&(h=k)}return new a.SubMesh(b,g,h-g+1,c,d,e,f)},b}();a.SubMesh=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.hasAlpha=!1,this.getAlphaFromRGB=!1,this.level=1,this.isCube=!1,this.isRenderTarget=!1,this.animations=new Array,this.coordinatesIndex=0,this.coordinatesMode=a.Texture.EXPLICIT_MODE,this.wrapU=a.Texture.WRAP_ADDRESSMODE,this.wrapV=a.Texture.WRAP_ADDRESSMODE,this.anisotropicFilteringLevel=4,this._scene=b,this._scene.textures.push(this)}return b.prototype.getScene=function(){return this._scene},b.prototype.getTextureMatrix=function(){return null},b.prototype.getReflectionTextureMatrix=function(){return null},b.prototype.getInternalTexture=function(){return this._texture},b.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_NOTLOADED?!0:this._texture?this._texture.isReady:!1},b.prototype.getSize=function(){return this._texture._width?{width:this._texture._width,height:this._texture._height}:this._texture._size?{width:this._texture._size,height:this._texture._size}:{width:0,height:0}},b.prototype.getBaseSize=function(){return this.isReady()?this._texture._size?{width:this._texture._size,height:this._texture._size}:{width:this._texture._baseWidth,height:this._texture._baseHeight}:{width:0,height:0}},b.prototype._getFromCache=function(a,b){for(var c=this._scene.getEngine().getLoadedTexturesCache(),d=0;d<c.length;d++){var e=c[d];if(e.url===a&&e.noMipmap===b)return e.references++,e}return null},b.prototype.delayLoad=function(){},b.prototype.releaseInternalTexture=function(){if(this._texture){var a=this._scene.getEngine().getLoadedTexturesCache();if(this._texture.references--,0==this._texture.references){var b=a.indexOf(this._texture);a.splice(b,1),this._scene.getEngine()._releaseTexture(this._texture),delete this._texture}}},b.prototype.clone=function(){return null},b.prototype.dispose=function(){var a=this._scene.textures.indexOf(this);a>=0&&this._scene.textures.splice(a,1),void 0!==this._texture&&(this.releaseInternalTexture(),this.onDispose&&this.onDispose())},b}();a.BaseTexture=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.index=b,this._opaqueSubMeshes=new a.SmartArray(256),this._transparentSubMeshes=new a.SmartArray(256),this._alphaTestSubMeshes=new a.SmartArray(256),this._scene=c}return b.prototype.render=function(b,c){if(b)return b(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,c),!0;if(0===this._opaqueSubMeshes.length&&0===this._alphaTestSubMeshes.length&&0===this._transparentSubMeshes.length)return!1;var d,e,f=this._scene.getEngine();for(d=0;d<this._opaqueSubMeshes.length;d++)e=this._opaqueSubMeshes.data[d],this._activeVertices+=e.verticesCount,e.render();for(f.setAlphaTesting(!0),d=0;d<this._alphaTestSubMeshes.length;d++)e=this._alphaTestSubMeshes.data[d],this._activeVertices+=e.verticesCount,e.render();if(f.setAlphaTesting(!1),c&&c(),this._transparentSubMeshes.length){for(d=0;d<this._transparentSubMeshes.length;d++)e=this._transparentSubMeshes.data[d],e._distanceToCamera=e.getBoundingInfo().boundingSphere.centerWorld.subtract(this._scene.activeCamera.position).length();var g=this._transparentSubMeshes.data.slice(0,this._transparentSubMeshes.length);for(g.sort(function(a,b){return a._distanceToCamera<b._distanceToCamera?1:a._distanceToCamera>b._distanceToCamera?-1:0}),f.setAlphaMode(a.Engine.ALPHA_COMBINE),d=0;d<g.length;d++)e=g[d],this._activeVertices+=e.verticesCount,e.render();f.setAlphaMode(a.Engine.ALPHA_DISABLE)}return!0},b.prototype.prepare=function(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset()},b.prototype.dispatch=function(a){var b=a.getMaterial(),c=a.getMesh();b.needAlphaBlending()||c.visibility<1?(b.alpha>0||c.visibility<1)&&this._transparentSubMeshes.push(a):b.needAlphaTesting()?this._alphaTestSubMeshes.push(a):this._opaqueSubMeshes.push(a)},b}();a.RenderingGroup=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a){this._renderingGroups=new Array,this._scene=a}return b.prototype._renderParticles=function(a,b){if(0!==this._scene._activeParticleSystems.length){for(var c=(new Date).getTime(),d=0;d<this._scene._activeParticleSystems.length;d++){var e=this._scene._activeParticleSystems.data[d];e.renderingGroupId===a&&(this._clearDepthBuffer(),e.emitter.position&&b&&-1===b.indexOf(e.emitter)||(this._scene._activeParticles+=e.render()))}this._scene._particlesDuration+=(new Date).getTime()-c}},b.prototype._renderSprites=function(a){if(0!==this._scene.spriteManagers.length){for(var b=(new Date).getTime(),c=0;c<this._scene.spriteManagers.length;c++){var d=this._scene.spriteManagers[c];d.renderingGroupId===a&&(this._clearDepthBuffer(),d.render())}this._scene._spritesDuration+=(new Date).getTime()-b}},b.prototype._clearDepthBuffer=function(){this._depthBufferAlreadyCleaned||(this._scene.getEngine().clear(0,!1,!0),this._depthBufferAlreadyCleaned=!0)},b.prototype.render=function(b,c,d,e){for(var f=this,g=0;g<a.RenderingManager.MAX_RENDERINGGROUPS;g++){this._depthBufferAlreadyCleaned=!1;var h=this._renderingGroups[g];h?(this._clearDepthBuffer(),h.render(b,function(){e&&f._renderSprites(g)})||this._renderingGroups.splice(g,1)):e&&this._renderSprites(g),d&&this._renderParticles(g,c)}},b.prototype.reset=function(){for(var a in this._renderingGroups){var b=this._renderingGroups[a];b.prepare()}},b.prototype.dispatch=function(b){var c=b.getMesh(),d=c.renderingGroupId||0;this._renderingGroups[d]||(this._renderingGroups[d]=new a.RenderingGroup(d,this._scene)),this._renderingGroups[d].dispatch(b)},b.MAX_RENDERINGGROUPS=4,b}();a.RenderingManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(d,e,f,g,h){"undefined"==typeof h&&(h=c.TRILINEAR_SAMPLINGMODE),b.call(this,e),this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.name=d,this.url=d,this._noMipmap=f,this._invertY=g,this._samplingMode=h,d&&(this._texture=this._getFromCache(d,f),this._texture||(e.useDelayedTextureLoading?this.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED:this._texture=e.getEngine().createTexture(d,f,g,e,this._samplingMode)))}return __extends(c,b),c.prototype.delayLoad=function(){this.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED&&(this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||(this._texture=this.getScene().getEngine().createTexture(this.url,this._noMipmap,this._invertY,this.getScene(),this._samplingMode)))},c.prototype._prepareRowForTextureGeneration=function(b,c,d,e){b-=this.uOffset+.5,c-=this.vOffset+.5,d-=.5,a.Vector3.TransformCoordinatesFromFloatsToRef(b,c,d,this._rowGenerationMatrix,e),e.x*=this.uScale,e.y*=this.vScale,e.x+=.5,e.y+=.5,e.z+=.5},c.prototype.getTextureMatrix=function(){return this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng?this._cachedTextureMatrix:(this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedTextureMatrix||(this._cachedTextureMatrix=a.Matrix.Zero(),this._rowGenerationMatrix=new a.Matrix,this._t0=a.Vector3.Zero(),this._t1=a.Vector3.Zero(),this._t2=a.Vector3.Zero()),a.Matrix.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix.m[0]=this._t1.x,this._cachedTextureMatrix.m[1]=this._t1.y,this._cachedTextureMatrix.m[2]=this._t1.z,this._cachedTextureMatrix.m[4]=this._t2.x,this._cachedTextureMatrix.m[5]=this._t2.y,this._cachedTextureMatrix.m[6]=this._t2.z,this._cachedTextureMatrix.m[8]=this._t0.x,this._cachedTextureMatrix.m[9]=this._t0.y,this._cachedTextureMatrix.m[10]=this._t0.z,this._cachedTextureMatrix)},c.prototype.getReflectionTextureMatrix=function(){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale===this._cachedUScale&&this.vScale===this._cachedVScale&&this.coordinatesMode===this._cachedCoordinatesMode)return this._cachedTextureMatrix;switch(this._cachedTextureMatrix||(this._cachedTextureMatrix=a.Matrix.Zero(),this._projectionModeMatrix=a.Matrix.Zero()),this.coordinatesMode){case a.Texture.SPHERICAL_MODE:a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix[0]=-.5*this.uScale,this._cachedTextureMatrix[5]=-.5*this.vScale,this._cachedTextureMatrix[12]=.5+this.uOffset,this._cachedTextureMatrix[13]=.5+this.vOffset;break;case a.Texture.PLANAR_MODE:a.Matrix.IdentityToRef(this._cachedTextureMatrix),this._cachedTextureMatrix[0]=this.uScale,this._cachedTextureMatrix[5]=this.vScale,this._cachedTextureMatrix[12]=this.uOffset,this._cachedTextureMatrix[13]=this.vOffset;break;case a.Texture.PROJECTION_MODE:a.Matrix.IdentityToRef(this._projectionModeMatrix),this._projectionModeMatrix.m[0]=.5,this._projectionModeMatrix.m[5]=-.5,this._projectionModeMatrix.m[10]=0,this._projectionModeMatrix.m[12]=.5,this._projectionModeMatrix.m[13]=.5,this._projectionModeMatrix.m[14]=1,this._projectionModeMatrix.m[15]=1,this.getScene().getProjectionMatrix().multiplyToRef(this._projectionModeMatrix,this._cachedTextureMatrix);
break;default:a.Matrix.IdentityToRef(this._cachedTextureMatrix)}return this._cachedTextureMatrix},c.prototype.clone=function(){var b=new a.Texture(this._texture.url,this.getScene(),this._noMipmap,this._invertY);return b.hasAlpha=this.hasAlpha,b.level=this.level,b.wrapU=this.wrapU,b.wrapV=this.wrapV,b.coordinatesIndex=this.coordinatesIndex,b.coordinatesMode=this.coordinatesMode,b.uOffset=this.uOffset,b.vOffset=this.vOffset,b.uScale=this.uScale,b.vScale=this.vScale,b.uAng=this.uAng,b.vAng=this.vAng,b.wAng=this.wAng,b},c.NEAREST_SAMPLINGMODE=1,c.BILINEAR_SAMPLINGMODE=2,c.TRILINEAR_SAMPLINGMODE=3,c.EXPLICIT_MODE=0,c.SPHERICAL_MODE=1,c.PLANAR_MODE=2,c.CUBIC_MODE=3,c.PROJECTION_MODE=4,c.SKYBOX_MODE=5,c.CLAMP_ADDRESSMODE=0,c.WRAP_ADDRESSMODE=1,c.MIRROR_ADDRESSMODE=2,c}(a.BaseTexture);a.Texture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){b.call(this,d),this.coordinatesMode=a.Texture.CUBIC_MODE,this.name=c,this.url=c,this._noMipmap=f,this.hasAlpha=!1,this._texture=this._getFromCache(c,f),e||(e=["_px.jpg","_py.jpg","_pz.jpg","_nx.jpg","_ny.jpg","_nz.jpg"]),this._extensions=e,this._texture||(d.useDelayedTextureLoading?this.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED:this._texture=d.getEngine().createCubeTexture(c,d,e,f)),this.isCube=!0,this._textureMatrix=a.Matrix.Identity()}return __extends(c,b),c.prototype.clone=function(){var b=new a.CubeTexture(this.url,this.getScene(),this._extensions,this._noMipmap);return b.level=this.level,b.wrapU=this.wrapU,b.wrapV=this.wrapV,b.coordinatesIndex=this.coordinatesIndex,b.coordinatesMode=this.coordinatesMode,b},c.prototype.delayLoad=function(){this.delayLoadState==a.Engine.DELAYLOADSTATE_NOTLOADED&&(this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||(this._texture=this.getScene().getEngine().createCubeTexture(this.url,this.getScene(),this._extensions)))},c.prototype.getReflectionTextureMatrix=function(){return this._textureMatrix},c}(a.BaseTexture);a.CubeTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g){"undefined"==typeof g&&(g=!0),b.call(this,null,e,!f),this.renderList=new Array,this.renderParticles=!0,this.renderSprites=!1,this.coordinatesMode=a.Texture.PROJECTION_MODE,this._currentRefreshId=-1,this._refreshRate=1,this.name=c,this.isRenderTarget=!0,this._size=d,this._generateMipMaps=f,this._doNotChangeAspectRatio=g,this._texture=e.getEngine().createRenderTargetTexture(d,f),this._renderingManager=new a.RenderingManager(e)}return __extends(c,b),c.prototype.resetRefreshCounter=function(){this._currentRefreshId=-1},Object.defineProperty(c.prototype,"refreshRate",{get:function(){return this._refreshRate},set:function(a){this._refreshRate=a,this.resetRefreshCounter()},enumerable:!0,configurable:!0}),c.prototype._shouldRender=function(){return-1===this._currentRefreshId?(this._currentRefreshId=1,!0):this.refreshRate==this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)},c.prototype.getRenderSize=function(){return this._size},c.prototype.resize=function(a,b){this.releaseInternalTexture(),this._texture=this.getScene().getEngine().createRenderTargetTexture(a,b)},c.prototype.render=function(a){var b=this.getScene(),c=b.getEngine();if(this._waitingRenderList){this.renderList=[];for(var d=0;d<this._waitingRenderList.length;d++){var e=this._waitingRenderList[d];this.renderList.push(b.getMeshByID(e))}delete this._waitingRenderList}if(this.renderList&&0!=this.renderList.length){a&&b.postProcessManager._prepareFrame(this._texture)||c.bindFramebuffer(this._texture),c.clear(b.clearColor,!0,!0),this._renderingManager.reset();for(var f=0;f<this.renderList.length;f++){var g=this.renderList[f];if(g){if(!g.isReady()||g.material&&!g.material.isReady()){this.resetRefreshCounter();continue}if(g.isEnabled()&&g.isVisible&&g.subMeshes&&0!=(g.layerMask&b.activeCamera.layerMask)){g._activate(b.getRenderId());for(var h=0;h<g.subMeshes.length;h++){var i=g.subMeshes[h];b._activeVertices+=i.verticesCount,this._renderingManager.dispatch(i)}}}}this._doNotChangeAspectRatio||b.updateTransformMatrix(!0),this.onBeforeRender&&this.onBeforeRender(),this._renderingManager.render(this.customRenderFunction,this.renderList,this.renderParticles,this.renderSprites),a&&b.postProcessManager._finalizeFrame(!1,this._texture),this.onAfterRender&&this.onAfterRender(),c.unBindFramebuffer(this._texture),this._doNotChangeAspectRatio||b.updateTransformMatrix(!0)}},c.prototype.clone=function(){var b=this.getSize(),c=new a.RenderTargetTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.coordinatesMode=this.coordinatesMode,c.renderList=this.renderList.slice(0),c},c}(a.Texture);a.RenderTargetTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){var g=this;b.call(this,c,d,e,f,!0),this.mirrorPlane=new a.Plane(0,1,0,1),this._transformMatrix=a.Matrix.Zero(),this._mirrorMatrix=a.Matrix.Zero(),this.onBeforeRender=function(){a.Matrix.ReflectionToRef(g.mirrorPlane,g._mirrorMatrix),g._savedViewMatrix=e.getViewMatrix(),g._mirrorMatrix.multiplyToRef(g._savedViewMatrix,g._transformMatrix),e.setTransformMatrix(g._transformMatrix,e.getProjectionMatrix()),e.clipPlane=g.mirrorPlane,e.getEngine().cullBackFaces=!1},this.onAfterRender=function(){e.setTransformMatrix(g._savedViewMatrix,e.getProjectionMatrix()),e.getEngine().cullBackFaces=!0,delete e.clipPlane}}return __extends(c,b),c.prototype.clone=function(){var b=this.getSize(),c=new a.MirrorTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.mirrorPlane=this.mirrorPlane.clone(),c.renderList=this.renderList.slice(0),c},c}(a.RenderTargetTexture);a.MirrorTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g){"undefined"==typeof g&&(g=a.Texture.TRILINEAR_SAMPLINGMODE),b.call(this,null,e,!f),this.name=c,this.wrapU=a.Texture.CLAMP_ADDRESSMODE,this.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._generateMipMaps=f,d.getContext?(this._canvas=d,this._texture=e.getEngine().createDynamicTexture(d.width,d.height,f,g)):(this._canvas=document.createElement("canvas"),this._texture=d.width?e.getEngine().createDynamicTexture(d.width,d.height,f,g):e.getEngine().createDynamicTexture(d,d,f,g));var h=this.getSize();this._canvas.width=h.width,this._canvas.height=h.height,this._context=this._canvas.getContext("2d")}return __extends(c,b),c.prototype.getContext=function(){return this._context},c.prototype.update=function(a){this.getScene().getEngine().updateDynamicTexture(this._texture,this._canvas,void 0===a?!0:a)},c.prototype.drawText=function(a,b,c,d,e,f,g){var h=this.getSize();if(f&&(this._context.fillStyle=f,this._context.fillRect(0,0,h.width,h.height)),this._context.font=d,null===b){var i=this._context.measureText(a);b=(h.width-i.width)/2}this._context.fillStyle=e,this._context.fillText(a,b,c),this.update(g)},c.prototype.clone=function(){var b=this.getSize(),c=new a.DynamicTexture(this.name,b.width,this.getScene(),this._generateMipMaps);return c.hasAlpha=this.hasAlpha,c.level=this.level,c.wrapU=this.wrapU,c.wrapV=this.wrapV,c},c}(a.Texture);a.DynamicTexture=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i){"undefined"==typeof i&&(i=a.Texture.TRILINEAR_SAMPLINGMODE);var j=this;b.call(this,null,f,!g,h),this._autoLaunch=!0,this.name=c,this.wrapU=a.Texture.WRAP_ADDRESSMODE,this.wrapV=a.Texture.WRAP_ADDRESSMODE;var k=e.width||e,l=e.height||e;this._texture=f.getEngine().createDynamicTexture(k,l,g,i);var m=this.getSize();this.video=document.createElement("video"),this.video.width=m.width,this.video.height=m.height,this.video.autoplay=!1,this.video.loop=!0,this.video.addEventListener("canplaythrough",function(){j._texture&&(j._texture.isReady=!0)}),d.forEach(function(a){var b=document.createElement("source");b.src=a,j.video.appendChild(b)}),this._lastUpdate=(new Date).getTime()}return __extends(c,b),c.prototype.update=function(){this._autoLaunch&&(this._autoLaunch=!1,this.video.play());var a=(new Date).getTime();return a-this._lastUpdate<15?!1:(this._lastUpdate=a,this.getScene().getEngine().updateVideoTexture(this._texture,this.video,this._invertY),!0)},c}(a.Texture);a.VideoTexture=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h,i){var j=this;this._isReady=!1,this._compilationError="",this._valueCache=[],this._engine=e,this.name=a,this.defines=f,this._uniformsNames=c.concat(d),this._samplers=d,this._attributesNames=b,this.onError=i,this.onCompiled=h;var k,l;k=a.vertexElement?document.getElementById(a.vertexElement):a.vertex||a,l=a.fragmentElement?document.getElementById(a.fragmentElement):a.fragment||a,this._loadVertexShader(k,function(a){j._loadFragmentShader(l,function(c){j._prepareEffect(a,c,b,f,g)})})}return b.prototype.isReady=function(){return this._isReady},b.prototype.getProgram=function(){return this._program},b.prototype.getAttributesNames=function(){return this._attributesNames},b.prototype.getAttributeLocation=function(a){return this._attributes[a]},b.prototype.getAttributeLocationByName=function(a){var b=this._attributesNames.indexOf(a);return this._attributes[b]},b.prototype.getAttributesCount=function(){return this._attributes.length},b.prototype.getUniformIndex=function(a){return this._uniformsNames.indexOf(a)},b.prototype.getUniform=function(a){return this._uniforms[this._uniformsNames.indexOf(a)]},b.prototype.getSamplers=function(){return this._samplers},b.prototype.getCompilationError=function(){return this._compilationError},b.prototype._loadVertexShader=function(b,c){if(b instanceof HTMLElement){var d=a.Tools.GetDOMTextContent(b);return void c(d)}if(a.Effect.ShadersStore[b+"VertexShader"])return void c(a.Effect.ShadersStore[b+"VertexShader"]);var e;e="."===b[0]?b:a.Engine.ShadersRepository+b,a.Tools.LoadFile(e+".vertex.fx",c)},b.prototype._loadFragmentShader=function(b,c){if(b instanceof HTMLElement){var d=a.Tools.GetDOMTextContent(b);return void c(d)}if(a.Effect.ShadersStore[b+"PixelShader"])return void c(a.Effect.ShadersStore[b+"PixelShader"]);var e;e="."===b[0]?b:a.Engine.ShadersRepository+b,a.Tools.LoadFile(e+".fragment.fx",c)},b.prototype._prepareEffect=function(b,c,d,e,f,g){try{var h=this._engine;this._program=h.createShaderProgram(b,c,e),this._uniforms=h.getUniforms(this._program,this._uniformsNames),this._attributes=h.getAttributes(this._program,d);for(var i=0;i<this._samplers.length;i++){var j=this.getUniform(this._samplers[i]);null==j&&(this._samplers.splice(i,1),i--)}h.bindSamplers(this),this._isReady=!0,this.onCompiled&&this.onCompiled(this)}catch(k){if(!g&&f){for(i=0;i<f.length;i++)e=e.replace(f[i],"");this._prepareEffect(b,c,d,e,f,!0)}else a.Tools.Error("Unable to compile effect: "+this.name),a.Tools.Error("Defines: "+e),a.Tools.Error("Optional defines: "+f),a.Tools.Error("Error: "+k.message),this._compilationError=k.message,this.onError&&this.onError(this,this._compilationError)}},b.prototype._bindTexture=function(a,b){this._engine._bindTexture(this._samplers.indexOf(a),b)},b.prototype.setTexture=function(a,b){this._engine.setTexture(this._samplers.indexOf(a),b)},b.prototype.setTextureFromPostProcess=function(a,b){this._engine.setTextureFromPostProcess(this._samplers.indexOf(a),b)},b.prototype._cacheFloat2=function(a,b,c){return this._valueCache[a]?(this._valueCache[a][0]=b,void(this._valueCache[a][1]=c)):void(this._valueCache[a]=[b,c])},b.prototype._cacheFloat3=function(a,b,c,d){return this._valueCache[a]?(this._valueCache[a][0]=b,this._valueCache[a][1]=c,void(this._valueCache[a][2]=d)):void(this._valueCache[a]=[b,c,d])},b.prototype._cacheFloat4=function(a,b,c,d,e){return this._valueCache[a]?(this._valueCache[a][0]=b,this._valueCache[a][1]=c,this._valueCache[a][2]=d,void(this._valueCache[a][3]=e)):void(this._valueCache[a]=[b,c,d,e])},b.prototype.setArray=function(a,b){return this._engine.setArray(this.getUniform(a),b),this},b.prototype.setMatrices=function(a,b){return this._engine.setMatrices(this.getUniform(a),b),this},b.prototype.setMatrix=function(a,b){return this._engine.setMatrix(this.getUniform(a),b),this},b.prototype.setFloat=function(a,b){return this._valueCache[a]&&this._valueCache[a]===b?this:(this._valueCache[a]=b,this._engine.setFloat(this.getUniform(a),b),this)},b.prototype.setBool=function(a,b){return this._valueCache[a]&&this._valueCache[a]===b?this:(this._valueCache[a]=b,this._engine.setBool(this.getUniform(a),b?1:0),this)},b.prototype.setVector2=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.x&&this._valueCache[a][1]==b.y?this:(this._cacheFloat2(a,b.x,b.y),this._engine.setFloat2(this.getUniform(a),b.x,b.y),this)},b.prototype.setFloat2=function(a,b,c){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c?this:(this._cacheFloat2(a,b,c),this._engine.setFloat2(this.getUniform(a),b,c),this)},b.prototype.setVector3=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.x&&this._valueCache[a][1]==b.y&&this._valueCache[a][2]==b.z?this:(this._cacheFloat3(a,b.x,b.y,b.z),this._engine.setFloat3(this.getUniform(a),b.x,b.y,b.z),this)},b.prototype.setFloat3=function(a,b,c,d){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c&&this._valueCache[a][2]==d?this:(this._cacheFloat3(a,b,c,d),this._engine.setFloat3(this.getUniform(a),b,c,d),this)},b.prototype.setFloat4=function(a,b,c,d,e){return this._valueCache[a]&&this._valueCache[a][0]==b&&this._valueCache[a][1]==c&&this._valueCache[a][2]==d&&this._valueCache[a][3]==e?this:(this._cacheFloat4(a,b,c,d,e),this._engine.setFloat4(this.getUniform(a),b,c,d,e),this)},b.prototype.setColor3=function(a,b){return this._valueCache[a]&&this._valueCache[a][0]==b.r&&this._valueCache[a][1]==b.g&&this._valueCache[a][2]==b.b?this:(this._cacheFloat3(a,b.r,b.g,b.b),this._engine.setColor3(this.getUniform(a),b),this)},b.prototype.setColor4=function(a,b,c){return this._valueCache[a]&&this._valueCache[a][0]==b.r&&this._valueCache[a][1]==b.g&&this._valueCache[a][2]==b.b&&this._valueCache[a][3]==c?this:(this._cacheFloat4(a,b.r,b.g,b.b,c),this._engine.setColor4(this.getUniform(a),b,c),this)},b.ShadersStore={anaglyphPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\n\nvoid main(void)\n{\n    vec4 leftFrag = texture2D(leftSampler, vUV);\n    leftFrag = vec4(1.0, leftFrag.g, leftFrag.b, 1.0);\n\n	vec4 rightFrag = texture2D(textureSampler, vUV);\n    rightFrag = vec4(rightFrag.r, 1.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(rightFrag.rgb * leftFrag.rgb, 1.0);\n}",blackAndWhitePixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(0.3, 0.59, 0.11));\n	gl_FragColor = vec4(luminance, luminance, luminance, 1.0);\n}",blurPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Parameters\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nvoid main(void)\n{\n	float weights[7];\n	weights[0] = 0.05;\n	weights[1] = 0.1;\n	weights[2] = 0.2;\n	weights[3] = 0.3;\n	weights[4] = 0.2;\n	weights[5] = 0.1;\n	weights[6] = 0.05;\n\n	vec2 texelSize = vec2(1.0 / screenSize.x, 1.0 / screenSize.y);\n	vec2 texelStep = texelSize * direction * blurWidth;\n	vec2 start = vUV - 3.0 * texelStep;\n\n	vec4 baseColor = vec4(0., 0., 0., 0.);\n	vec2 texelOffset = vec2(0., 0.);\n\n	for (int i = 0; i < 7; i++)\n	{\n		baseColor += texture2D(textureSampler, start + texelOffset) * weights[i];\n		texelOffset += texelStep;\n	}\n\n	gl_FragColor = baseColor;\n}",colorPixelShader:"precision mediump float;\n\nuniform vec3 color;\n\nvoid main(void) {\n	gl_FragColor = vec4(color, 1.);\n}",colorVertexShader:"precision mediump float;\n\n// Attributes\nattribute vec3 position;\n\n// Uniforms\nuniform mat4 worldViewProjection;\n\nvoid main(void) {\n	gl_Position = worldViewProjection * vec4(position, 1.0);\n}",convolutionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform float kernel[9];\n\nvoid main(void)\n{\n	vec2 onePixel = vec2(1.0, 1.0) / screenSize;\n	vec4 colorSum =\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, -1)) * kernel[0] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, -1)) * kernel[1] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, -1)) * kernel[2] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 0)) * kernel[3] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 0)) * kernel[4] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 0)) * kernel[5] +\n		texture2D(textureSampler, vUV + onePixel * vec2(-1, 1)) * kernel[6] +\n		texture2D(textureSampler, vUV + onePixel * vec2(0, 1)) * kernel[7] +\n		texture2D(textureSampler, vUV + onePixel * vec2(1, 1)) * kernel[8];\n\n	float kernelWeight =\n		kernel[0] +\n		kernel[1] +\n		kernel[2] +\n		kernel[3] +\n		kernel[4] +\n		kernel[5] +\n		kernel[6] +\n		kernel[7] +\n		kernel[8];\n\n	if (kernelWeight <= 0.0) {\n		kernelWeight = 1.0;\n	}\n\n	gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1);\n}",defaultPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\nuniform float darkness0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\nuniform float darkness1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\nuniform float darkness2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\nuniform float darkness3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Reflection\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\nuniform mat4 view;\n\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return vPositionUVW;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return darkness;\n	}\n	return 1.;\n}\n\nfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float visibility = 1.;\n\n	vec2 poissonDisk[4];\n	poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n	poissonDisk[1] = vec2(0.94558609, -0.76890725);\n	poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n	poissonDisk[3] = vec2(0.34495938, 0.29387760);\n\n	// Poisson Sampling\n	for (int i = 0; i<4; i++){\n		if (unpack(texture2D(shadowSampler, uv + poissonDisk[i] / 1500.0))  <  depth.z){\n			visibility -= 0.2;\n		}\n	}\n	return visibility;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n// Bump\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform sampler2D bumpSampler;\n\n// Thanks to http://www.thetenthplanet.de/archives/1180\nmat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\n{\n	// get edge vectors of the pixel triangle\n	vec3 dp1 = dFdx(p);\n	vec3 dp2 = dFdy(p);\n	vec2 duv1 = dFdx(uv);\n	vec2 duv2 = dFdy(uv);\n\n	// solve the linear system\n	vec3 dp2perp = cross(dp2, normal);\n	vec3 dp1perp = cross(normal, dp1);\n	vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n	vec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\n\n	// construct a scale-invariant frame \n	float invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\n	return mat3(tangent * invmax, binormal * invmax, normal);\n}\n\nvec3 perturbNormal(vec3 viewDir)\n{\n	vec3 map = texture2D(bumpSampler, vBumpUV).xyz * vBumpInfos.y;\n	map = map * 255. / 127. - 128. / 127.;\n	mat3 TBN = cotangent_frame(vNormalW, -viewDir, vBumpUV);\n	return normalize(TBN * map);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nstruct lightingInfo\n{\n	vec3 diffuse;\n	vec3 specular;\n};\n\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 lightVectorW;\n	float attenuation = 1.0;\n	if (lightData.w == 0.)\n	{\n		vec3 direction = lightData.xyz - vPositionW;\n\n		attenuation = max(0., 1.0 - length(direction) / range);\n		lightVectorW = normalize(direction);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, max(1., vSpecularColor.a));\n\n	result.diffuse = ndl * diffuseColor * attenuation;\n	result.specular = specComp * specularColor * attenuation;\n\n	return result;\n}\n\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range) {\n	lightingInfo result;\n\n	vec3 direction = lightData.xyz - vPositionW;\n	vec3 lightVectorW = normalize(direction);\n	float attenuation = max(0., 1.0 - length(direction) / range);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result.diffuse = ndl * spotAtten * diffuseColor * attenuation;\n		result.specular = specComp * specularColor * spotAtten * attenuation;\n\n		return result;\n	}\n\n	result.diffuse = vec3(0.);\n	result.specular = vec3(0.);\n\n	return result;\n}\n\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	lightingInfo result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result.diffuse = mix(groundColor, diffuseColor, ndl);\n	result.specular = specComp * specularColor;\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n#ifdef ALPHAFROMDIFFUSE\n	alpha *= baseColor.a;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = normalize(vNormalW);\n\n#ifdef BUMP\n	normalW = perturbNormal(viewDirectionW);\n#endif\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef HEMILIGHT0\n	lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	#ifdef SHADOWPCF0\n		shadow = computeShadowWithPCF(vPositionFromLight0, shadowSampler0);\n	#else\n		shadow = computeShadow(vPositionFromLight0, shadowSampler0, darkness0);\n	#endif\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	#ifdef SHADOWPCF1\n		shadow = computeShadowWithPCF(vPositionFromLight1, shadowSampler1);\n	#else\n		shadow = computeShadow(vPositionFromLight1, shadowSampler1, darkness1);\n	#endif\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	#ifdef SHADOWPCF2\n		shadow = computeShadowWithPCF(vPositionFromLight2, shadowSampler2);\n	#else\n		shadow = computeShadow(vPositionFromLight2, shadowSampler2, darkness2);\n	#endif	\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	#ifdef SHADOWPCF3\n		shadow = computeShadowWithPCF(vPositionFromLight3, shadowSampler3);\n	#else\n		shadow = computeShadow(vPositionFromLight3, shadowSampler3, darkness3);\n	#endif	\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info.diffuse * shadow;\n	specularBase += info.specular * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	vec3 vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), normalW);\n\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y * shadow;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y * shadow;\n	}\n#endif\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n\n#ifdef OPACITYRGB\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n	alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n\n\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}",defaultVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\n\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif\n\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vPositionUVW;\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef REFLECTION\n	vPositionUVW = position;\n#endif \n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n#ifdef INSTANCES\n	finalWorld = mat4(world0, world1, world2, world3);\n#else\n	finalWorld = world;\n#endif\n#endif\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * worldPos;\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * worldPos;\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * worldPos;\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * worldPos;\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}",displayPassPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(passSampler, vUV);\n}",filterPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform mat4 kernelMatrix;\n\nvoid main(void)\n{\n	vec3 baseColor = texture2D(textureSampler, vUV).rgb;\n	vec3 updatedColor = (kernelMatrix * vec4(baseColor, 1.0)).rgb;\n\n	gl_FragColor = vec4(updatedColor, 1.0);\n}",fxaaPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 texelSize;\n\nvoid main(){\n	vec2 localTexelSize = texelSize;\n	vec4 rgbNW = texture2D(textureSampler, (vUV + vec2(-1.0, -1.0) * localTexelSize));\n	vec4 rgbNE = texture2D(textureSampler, (vUV + vec2(1.0, -1.0) * localTexelSize));\n	vec4 rgbSW = texture2D(textureSampler, (vUV + vec2(-1.0, 1.0) * localTexelSize));\n	vec4 rgbSE = texture2D(textureSampler, (vUV + vec2(1.0, 1.0) * localTexelSize));\n	vec4 rgbM = texture2D(textureSampler, vUV);\n	vec4 luma = vec4(0.299, 0.587, 0.114, 1.0);\n	float lumaNW = dot(rgbNW, luma);\n	float lumaNE = dot(rgbNE, luma);\n	float lumaSW = dot(rgbSW, luma);\n	float lumaSE = dot(rgbSE, luma);\n	float lumaM = dot(rgbM, luma);\n	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n	vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n	float dirReduce = max(\n		(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n		FXAA_REDUCE_MIN);\n\n	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n		dir * rcpDirMin)) * localTexelSize;\n\n	vec4 rgbA = 0.5 * (\n		texture2D(textureSampler, vUV + dir * (1.0 / 3.0 - 0.5)) +\n		texture2D(textureSampler, vUV + dir * (2.0 / 3.0 - 0.5)));\n\n	vec4 rgbB = rgbA * 0.5 + 0.25 * (\n		texture2D(textureSampler, vUV + dir *  -0.5) +\n		texture2D(textureSampler, vUV + dir * 0.5));\n	float lumaB = dot(rgbB, luma);\n	if ((lumaB < lumaMin) || (lumaB > lumaMax)) {\n		gl_FragColor = rgbA;\n	}\n	else {\n		gl_FragColor = rgbB;\n	}\n}",layerPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}",layerVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 textureMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = vec2(textureMatrix * vec4(position * madd + madd, 1.0, 0.0));\n	gl_Position = vec4(position, 0.0, 1.0);\n}",legacydefaultPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_PROJECTION	4.\n\n// Constants\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\nuniform vec4 vSpecularColor;\nuniform vec3 vEmissiveColor;\n\n// Input\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n// Lights\n#ifdef LIGHT0\nuniform vec4 vLightData0;\nuniform vec4 vLightDiffuse0;\nuniform vec3 vLightSpecular0;\n#ifdef SHADOW0\nvarying vec4 vPositionFromLight0;\nuniform sampler2D shadowSampler0;\n#endif\n#ifdef SPOTLIGHT0\nuniform vec4 vLightDirection0;\n#endif\n#ifdef HEMILIGHT0\nuniform vec3 vLightGround0;\n#endif\n#endif\n\n#ifdef LIGHT1\nuniform vec4 vLightData1;\nuniform vec4 vLightDiffuse1;\nuniform vec3 vLightSpecular1;\n#ifdef SHADOW1\nvarying vec4 vPositionFromLight1;\nuniform sampler2D shadowSampler1;\n#endif\n#ifdef SPOTLIGHT1\nuniform vec4 vLightDirection1;\n#endif\n#ifdef HEMILIGHT1\nuniform vec3 vLightGround1;\n#endif\n#endif\n\n#ifdef LIGHT2\nuniform vec4 vLightData2;\nuniform vec4 vLightDiffuse2;\nuniform vec3 vLightSpecular2;\n#ifdef SHADOW2\nvarying vec4 vPositionFromLight2;\nuniform sampler2D shadowSampler2;\n#endif\n#ifdef SPOTLIGHT2\nuniform vec4 vLightDirection2;\n#endif\n#ifdef HEMILIGHT2\nuniform vec3 vLightGround2;\n#endif\n#endif\n\n#ifdef LIGHT3\nuniform vec4 vLightData3;\nuniform vec4 vLightDiffuse3;\nuniform vec3 vLightSpecular3;\n#ifdef SHADOW3\nvarying vec4 vPositionFromLight3;\nuniform sampler2D shadowSampler3;\n#endif\n#ifdef SPOTLIGHT3\nuniform vec4 vLightDirection3;\n#endif\n#ifdef HEMILIGHT3\nuniform vec3 vLightGround3;\n#endif\n#endif\n\n// Samplers\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY	\nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nvarying vec3 vReflectionUVW;\nuniform samplerCube reflectionCubeSampler;\nuniform sampler2D reflection2DSampler;\nuniform vec3 vReflectionInfos;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n// Shadows\n#ifdef SHADOWS\n\nfloat unpack(vec4 color)\n{\n	const vec4 bitShift = vec4(1. / (255. * 255. * 255.), 1. / (255. * 255.), 1. / 255., 1.);\n	return dot(color, bitShift);\n}\n\nfloat unpackHalf(vec2 color)\n{\n	return color.x + (color.y / 255.0);\n}\n\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	float shadow = unpack(texture2D(shadowSampler, uv));\n\n	if (depth.z > shadow)\n	{\n		return 0.;\n	}\n	return 1.;\n}\n\n// Thanks to http://devmaster.net/\nfloat ChebychevInequality(vec2 moments, float t)\n{\n	if (t <= moments.x)\n	{\n		return 1.0;\n	}\n\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, 0.);\n\n	float d = t - moments.x;\n	return variance / (variance + d * d);\n}\n\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler)\n{\n	vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n	vec2 uv = 0.5 * depth.xy + vec2(0.5, 0.5);\n\n	if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n	{\n		return 1.0;\n	}\n\n	vec4 texel = texture2D(shadowSampler, uv);\n\n	vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n	return clamp(1.3 - ChebychevInequality(moments, depth.z), 0., 1.0);\n}\n#endif\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return clamp(fogCoeff, 0.0, 1.0);\n}\n#endif\n\n// Light Computing\nmat3 computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW;\n	if (lightData.w == 0.)\n	{\n		lightVectorW = normalize(lightData.xyz - vPositionW);\n	}\n	else\n	{\n		lightVectorW = normalize(-lightData.xyz);\n	}\n\n	// diffuse\n	float ndl = max(0., dot(vNormal, lightVectorW));\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightVectorW);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = max(0., pow(specComp, max(1.0, vSpecularColor.a)));\n\n	result[0] = ndl * diffuseColor.rgb;\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec4 diffuseColor, vec3 specularColor) {\n	mat3 result;\n\n	vec3 lightVectorW = normalize(lightData.xyz - vPositionW);\n\n	// diffuse\n	float cosAngle = max(0., dot(-lightDirection.xyz, lightVectorW));\n	float spotAtten = 0.0;\n\n	if (cosAngle >= lightDirection.w)\n	{\n		cosAngle = max(0., pow(cosAngle, lightData.w));\n		spotAtten = max(0., (cosAngle - lightDirection.w) / (1. - cosAngle));\n\n		// Diffuse\n		float ndl = max(0., dot(vNormal, -lightDirection.xyz));\n\n		// Specular\n		vec3 angleW = normalize(viewDirectionW - lightDirection.xyz);\n		float specComp = max(0., dot(vNormal, angleW));\n		specComp = pow(specComp, vSpecularColor.a);\n\n		result[0] = ndl * spotAtten * diffuseColor.rgb;\n		result[1] = specComp * specularColor * spotAtten;\n		result[2] = vec3(0.);\n\n		return result;\n	}\n\n	result[0] = vec3(0.);\n	result[1] = vec3(0.);\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nmat3 computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 diffuseColor, vec3 specularColor, vec3 groundColor) {\n	mat3 result;\n\n	// Diffuse\n	float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n\n	// Specular\n	vec3 angleW = normalize(viewDirectionW + lightData.xyz);\n	float specComp = max(0., dot(vNormal, angleW));\n	specComp = pow(specComp, vSpecularColor.a);\n\n	result[0] = mix(groundColor, diffuseColor.rgb, ndl);\n	result[1] = specComp * specularColor;\n	result[2] = vec3(0.);\n\n	return result;\n}\n\nvoid main(void) {\n	// Clip plane\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n\n	vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n\n	// Base color\n	vec4 baseColor = vec4(1., 1., 1., 1.);\n	vec3 diffuseColor = vDiffuseColor.rgb;\n\n#ifdef VERTEXCOLOR\n	diffuseColor *= vColor;\n#endif\n\n#ifdef DIFFUSE\n	baseColor = texture2D(diffuseSampler, vDiffuseUV);\n\n#ifdef ALPHATEST\n	if (baseColor.a < 0.4)\n		discard;\n#endif\n\n	baseColor.rgb *= vDiffuseInfos.y;\n#endif\n\n	// Bump\n	vec3 normalW = normalize(vNormalW);\n\n	// Ambient color\n	vec3 baseAmbientColor = vec3(1., 1., 1.);\n\n#ifdef AMBIENT\n	baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n#endif\n\n	// Lighting\n	vec3 diffuseBase = vec3(0., 0., 0.);\n	vec3 specularBase = vec3(0., 0., 0.);\n	float shadow = 1.;\n\n#ifdef LIGHT0\n#ifdef SPOTLIGHT0\n	mat3 info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef HEMILIGHT0\n	mat3 info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0, vLightGround0);\n#endif\n#ifdef POINTDIRLIGHT0\n	mat3 info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0, vLightSpecular0);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n	shadow = computeShadowWithVSM(vPositionFromLight0, shadowSampler0);\n#else\n	shadow = computeShadow(vPositionFromLight0, shadowSampler0);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT1\n#ifdef SPOTLIGHT1\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef HEMILIGHT1\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1, vLightGround1);\n#endif\n#ifdef POINTDIRLIGHT1\n	info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1, vLightSpecular1);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n	shadow = computeShadowWithVSM(vPositionFromLight1, shadowSampler1);\n#else\n	shadow = computeShadow(vPositionFromLight1, shadowSampler1);\n#endif\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT2\n#ifdef SPOTLIGHT2\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef HEMILIGHT2\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2, vLightGround2);\n#endif\n#ifdef POINTDIRLIGHT2\n	info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2, vLightSpecular2);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n	shadow = computeShadowWithVSM(vPositionFromLight2, shadowSampler2);\n#else\n	shadow = computeShadow(vPositionFromLight2, shadowSampler2);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n#ifdef LIGHT3\n#ifdef SPOTLIGHT3\n	info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef HEMILIGHT3\n	info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3, vLightGround3);\n#endif\n#ifdef POINTDIRLIGHT3\n	info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3, vLightSpecular3);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n	shadow = computeShadowWithVSM(vPositionFromLight3, shadowSampler3);\n#else\n	shadow = computeShadow(vPositionFromLight3, shadowSampler3);\n#endif	\n#else\n	shadow = 1.;\n#endif\n	diffuseBase += info[0] * shadow;\n	specularBase += info[1] * shadow;\n#endif\n\n	// Reflection\n	vec3 reflectionColor = vec3(0., 0., 0.);\n\n#ifdef REFLECTION\n	if (vReflectionInfos.z != 0.0)\n	{\n		reflectionColor = textureCube(reflectionCubeSampler, vReflectionUVW).rgb * vReflectionInfos.y;\n	}\n	else\n	{\n		vec2 coords = vReflectionUVW.xy;\n\n		if (vReflectionInfos.x == MAP_PROJECTION)\n		{\n			coords /= vReflectionUVW.z;\n		}\n\n		coords.y = 1.0 - coords.y;\n\n		reflectionColor = texture2D(reflection2DSampler, coords).rgb * vReflectionInfos.y;\n	}\n#endif\n\n	// Alpha\n	float alpha = vDiffuseColor.a;\n\n#ifdef OPACITY\n	vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n#ifdef OPACITYRGB\n	opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n	alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n	alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n#endif\n\n	// Emissive\n	vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n	emissiveColor += texture2D(emissiveSampler, vEmissiveUV).rgb * vEmissiveInfos.y;\n#endif\n\n	// Specular map\n	vec3 specularColor = vSpecularColor.rgb;\n#ifdef SPECULAR\n	specularColor = texture2D(specularSampler, vSpecularUV).rgb * vSpecularInfos.y;\n#endif\n\n	// Composition\n	vec3 finalDiffuse = clamp(diffuseBase * diffuseColor + emissiveColor + vAmbientColor, 0.0, 1.0) * baseColor.rgb;\n	vec3 finalSpecular = specularBase * specularColor;\n\n	vec4 color = vec4(finalDiffuse * baseAmbientColor + finalSpecular + reflectionColor, alpha);\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	color.rgb = fog * color.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = color;\n}",legacydefaultVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAP_EXPLICIT	0.\n#define MAP_SPHERICAL	1.\n#define MAP_PLANAR		2.\n#define MAP_CUBIC		3.\n#define MAP_PROJECTION	4.\n#define MAP_SKYBOX		5.\n\n// Attributes\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec3 color;\n#endif\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniforms\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n\n#ifdef REFLECTION\nuniform vec3 vEyePosition;\nvarying vec3 vReflectionUVW;\nuniform vec3 vReflectionInfos;\nuniform mat4 reflectionMatrix;\n#endif\n\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef SPECULAR\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n// Output\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n\n#ifdef VERTEXCOLOR\nvarying vec3 vColor;\n#endif\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\n#ifdef SHADOWS\n#ifdef LIGHT0\nuniform mat4 lightMatrix0;\nvarying vec4 vPositionFromLight0;\n#endif\n#ifdef LIGHT1\nuniform mat4 lightMatrix1;\nvarying vec4 vPositionFromLight1;\n#endif\n#ifdef LIGHT2\nuniform mat4 lightMatrix2;\nvarying vec4 vPositionFromLight2;\n#endif\n#ifdef LIGHT3\nuniform mat4 lightMatrix3;\nvarying vec4 vPositionFromLight3;\n#endif\n#endif\n\n#ifdef REFLECTION\nvec3 computeReflectionCoords(float mode, vec4 worldPos, vec3 worldNormal)\n{\n	if (mode == MAP_SPHERICAL)\n	{\n		vec3 coords = vec3(view * vec4(worldNormal, 0.0));\n\n		return vec3(reflectionMatrix * vec4(coords, 1.0));\n	}\n	else if (mode == MAP_PLANAR)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = normalize(reflect(viewDir, worldNormal));\n\n		return vec3(reflectionMatrix * vec4(coords, 1));\n	}\n	else if (mode == MAP_CUBIC)\n	{\n		vec3 viewDir = worldPos.xyz - vEyePosition;\n		vec3 coords = reflect(viewDir, worldNormal);\n\n		return vec3(reflectionMatrix * vec4(coords, 0));\n	}\n	else if (mode == MAP_PROJECTION)\n	{\n		return vec3(reflectionMatrix * (view * worldPos));\n	}\n	else if (mode == MAP_SKYBOX)\n	{\n		return position;\n	}\n\n	return vec3(0, 0, 0);\n}\n#endif\n\nvoid main(void) {\n	mat4 finalWorld;\n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n\n#ifdef BONES4\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = world * (m0 + m1 + m2 + m3);\n#else\n	finalWorld = world * (m0 + m1 + m2);\n#endif \n\n#else\n	finalWorld = world;\n#endif\n\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n\n	vec4 worldPos = finalWorld * vec4(position, 1.0);\n	vPositionW = vec3(worldPos);\n	vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n\n	// Texture coordinates\n#ifndef UV1\n	vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n	vec2 uv2 = vec2(0., 0.);\n#endif\n\n#ifdef DIFFUSE\n	if (vDiffuseInfos.x == 0.)\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vDiffuseUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef AMBIENT\n	if (vAmbientInfos.x == 0.)\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef OPACITY\n	if (vOpacityInfos.x == 0.)\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef REFLECTION\n	vReflectionUVW = computeReflectionCoords(vReflectionInfos.x, vec4(vPositionW, 1.0), vNormalW);\n#endif\n\n#ifdef EMISSIVE\n	if (vEmissiveInfos.x == 0.)\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef SPECULAR\n	if (vSpecularInfos.x == 0.)\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vSpecularUV = vec2(specularMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n#ifdef BUMP\n	if (vBumpInfos.x == 0.)\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n	}\n	else\n	{\n		vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n	}\n#endif\n\n	// Clip plane\n#ifdef CLIPPLANE\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n\n	// Fog\n#ifdef FOG\n	fFogDistance = (view * worldPos).z;\n#endif\n\n	// Shadows\n#ifdef SHADOWS\n#ifdef LIGHT0\n	vPositionFromLight0 = lightMatrix0 * worldPos;\n#endif\n#ifdef LIGHT1\n	vPositionFromLight1 = lightMatrix1 * worldPos;\n#endif\n#ifdef LIGHT2\n	vPositionFromLight2 = lightMatrix2 * worldPos;\n#endif\n#ifdef LIGHT3\n	vPositionFromLight3 = lightMatrix3 * worldPos;\n#endif\n#endif\n\n	// Vertex color\n#ifdef VERTEXCOLOR\n	vColor = color;\n#endif\n}",lensFlarePixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\n// Color\nuniform vec4 color;\n\nvoid main(void) {\n	vec4 baseColor = texture2D(textureSampler, vUV);\n\n	gl_FragColor = baseColor * color;\n}",lensFlareVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Uniforms\nuniform mat4 viewportMatrix;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = viewportMatrix * vec4(position, 0.0, 1.0);\n}",oculusDistortionCorrectionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\n\nvec2 HmdWarp(vec2 in01) {\n\n	vec2 theta = (in01 - LensCenter) * ScaleIn; // Scales to [-1, 1]\n	float rSq = theta.x * theta.x + theta.y * theta.y;\n	vec2 rvector = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n	return LensCenter + Scale * rvector;\n}\n\n\n\nvoid main(void)\n{\n	vec2 tc = HmdWarp(vUV);\n	if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	else{\n		gl_FragColor = vec4(texture2D(textureSampler, tc).rgb, 1.0);\n	}\n}",particlesPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {\n#ifdef CLIPPLANE\n	if (fClipDistance > 0.0)\n		discard;\n#endif\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	gl_FragColor = (baseColor * textureMask + (vec4(1., 1., 1., 1.) - textureMask)) * vColor;\n}",particlesVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 color;\nattribute vec4 options;\n\n// Uniforms\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nuniform mat4 invView;\nvarying float fClipDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	float size = options.y;\n	float angle = options.x;\n	vec2 offset = options.zw;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n	\n	vColor = color;\n	vUV = offset;\n\n	// Clip plane\n#ifdef CLIPPLANE\n	vec4 worldPos = invView * vec4(viewPos, 1.0);\n	fClipDistance = dot(worldPos, vClipPlane);\n#endif\n}",passPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nvoid main(void) \n{\n	gl_FragColor = texture2D(textureSampler, vUV);\n}",postprocessVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec2 position;\n\n// Output\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {	\n\n	vUV = position * madd + madd;\n	gl_Position = vec4(position, 0.0, 1.0);\n}",refractionPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\n// Parameters\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\n\nvoid main() {\n	float ref = 1.0 - texture2D(refractionSampler, vUV).r;\n\n	vec2 uv = vUV - vec2(0.5);\n	vec2 offset = uv * depth * ref;\n	vec3 sourceColor = texture2D(textureSampler, vUV - offset).rgb;\n\n	gl_FragColor = vec4(sourceColor + sourceColor * ref * colorLevel, 1.0);\n}",shadowMapPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 pack(float depth)\n{\n	const vec4 bitOffset = vec4(255. * 255. * 255., 255. * 255., 255., 1.);\n	const vec4 bitMask = vec4(0., 1. / 255., 1. / 255., 1. / 255.);\n	\n	vec4 comp = mod(depth * bitOffset * vec4(254.), vec4(255.)) / vec4(254.);\n	comp -= comp.xxyz * bitMask;\n	\n	return comp;\n}\n\n// Thanks to http://devmaster.net/\nvec2 packHalf(float depth) \n{ \n	const vec2 bitOffset = vec2(1.0 / 255., 0.);\n	vec2 color = vec2(depth, fract(depth * 255.));\n\n	return color - (color.yy * bitOffset);\n}\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n\nvoid main(void)\n{\n#ifdef ALPHATEST\n	if (texture2D(diffuseSampler, vUV).a < 0.4)\n		discard;\n#endif\n\n#ifdef VSM\n	float moment1 = gl_FragCoord.z / gl_FragCoord.w;\n	float moment2 = moment1 * moment1;\n	gl_FragColor = vec4(packHalf(moment1), packHalf(moment2));\n#else\n	gl_FragColor = pack(vPosition.z / vPosition.w);\n#endif\n}",shadowMapVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attribute\nattribute vec3 position;\n#ifdef BONES\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#endif\n\n// Uniform\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif\n\nuniform mat4 viewProjection;\n#ifdef BONES\nuniform mat4 mBones[BonesPerMesh];\n#endif\n\n#ifndef VSM\nvarying vec4 vPosition;\n#endif\n\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n\nvoid main(void)\n{\n#ifdef INSTANCES\n	mat4 finalWorld = mat4(world0, world1, world2, world3);\n#else\n	mat4 finalWorld = world;\n#endif\n\n#ifdef BONES\n	mat4 m0 = mBones[int(matricesIndices.x)] * matricesWeights.x;\n	mat4 m1 = mBones[int(matricesIndices.y)] * matricesWeights.y;\n	mat4 m2 = mBones[int(matricesIndices.z)] * matricesWeights.z;\n	mat4 m3 = mBones[int(matricesIndices.w)] * matricesWeights.w;\n	finalWorld = finalWorld * (m0 + m1 + m2 + m3);\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n#else\n#ifndef VSM\n	vPosition = viewProjection * finalWorld * vec4(position, 1.0);\n#endif\n	gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n#endif\n\n#ifdef ALPHATEST\n#ifdef UV1\n	vUV = vec2(diffuseMatrix * vec4(uv, 1.0, 0.0));\n#endif\n#ifdef UV2\n	vUV = vec2(diffuseMatrix * vec4(uv2, 1.0, 0.0));\n#endif\n#endif\n}",spritesPixelShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform bool alphaTest;\n\nvarying vec4 vColor;\n\n// Samplers\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n// Fog\n#ifdef FOG\n\n#define FOGMODE_NONE    0.\n#define FOGMODE_EXP     1.\n#define FOGMODE_EXP2    2.\n#define FOGMODE_LINEAR  3.\n#define E 2.71828\n\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\n\nfloat CalcFogFactor()\n{\n	float fogCoeff = 1.0;\n	float fogStart = vFogInfos.y;\n	float fogEnd = vFogInfos.z;\n	float fogDensity = vFogInfos.w;\n\n	if (FOGMODE_LINEAR == vFogInfos.x)\n	{\n		fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\n	}\n	else if (FOGMODE_EXP == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\n	}\n	else if (FOGMODE_EXP2 == vFogInfos.x)\n	{\n		fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\n	}\n\n	return min(1., max(0., fogCoeff));\n}\n#endif\n\n\nvoid main(void) {\n	vec4 baseColor = texture2D(diffuseSampler, vUV);\n\n	if (alphaTest) \n	{\n		if (baseColor.a < 0.95)\n			discard;\n	}\n\n	baseColor *= vColor;\n\n#ifdef FOG\n	float fog = CalcFogFactor();\n	baseColor.rgb = fog * baseColor.rgb + (1.0 - fog) * vFogColor;\n#endif\n\n	gl_FragColor = baseColor;\n}",spritesVertexShader:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Attributes\nattribute vec3 position;\nattribute vec4 options;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\n// Uniforms\nuniform vec2 textureInfos;\nuniform mat4 view;\nuniform mat4 projection;\n\n// Output\nvarying vec2 vUV;\nvarying vec4 vColor;\n\n#ifdef FOG\nvarying float fFogDistance;\n#endif\n\nvoid main(void) {	\n	vec3 viewPos = (view * vec4(position, 1.0)).xyz; \n	vec3 cornerPos;\n	\n	float angle = options.x;\n	float size = options.y;\n	vec2 offset = options.zw;\n	vec2 uvScale = textureInfos.xy;\n\n	cornerPos = vec3(offset.x - 0.5, offset.y  - 0.5, 0.) * size;\n\n	// Rotate\n	vec3 rotatedCorner;\n	rotatedCorner.x = cornerPos.x * cos(angle) - cornerPos.y * sin(angle);\n	rotatedCorner.y = cornerPos.x * sin(angle) + cornerPos.y * cos(angle);\n	rotatedCorner.z = 0.;\n\n	// Position\n	viewPos += rotatedCorner;\n	gl_Position = projection * vec4(viewPos, 1.0);   \n\n	// Color\n	vColor = color;\n	\n	// Texture\n	vec2 uvOffset = vec2(abs(offset.x - cellInfo.x), 1.0 - abs(offset.y - cellInfo.y));\n\n	vUV = (uvOffset + cellInfo.zw) * uvScale;\n\n	// Fog\n#ifdef FOG\n	fFogDistance = viewPos.z;\n#endif\n}"},b
}();a.Effect=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c){this.name=a,this.checkReadyOnEveryCall=!0,this.checkReadyOnlyOnce=!1,this.state="",this.alpha=1,this.wireframe=!1,this.backFaceCulling=!0,this._wasPreviouslyReady=!1,this.id=a,this._scene=b,c||b.materials.push(this)}return a.prototype.isReady=function(){return!0},a.prototype.getEffect=function(){return this._effect},a.prototype.getScene=function(){return this._scene},a.prototype.needAlphaBlending=function(){return this.alpha<1},a.prototype.needAlphaTesting=function(){return!1},a.prototype.getAlphaTestTexture=function(){return null},a.prototype.trackCreation=function(){},a.prototype._preBind=function(){var a=this._scene.getEngine();a.enableEffect(this._effect),a.setState(this.backFaceCulling)},a.prototype.bind=function(){},a.prototype.bindOnlyWorldMatrix=function(){},a.prototype.unbind=function(){},a.prototype.dispose=function(a){var b=this._scene.materials.indexOf(this);this._scene.materials.splice(b,1),a&&this._effect&&(this._scene.getEngine()._releaseEffect(this._effect),this._effect=null),this.onDispose&&this.onDispose()},a}();a.Material=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=4,c=function(c){function d(b,d){var e=this;c.call(this,b,d),this.ambientColor=new a.Color3(0,0,0),this.diffuseColor=new a.Color3(1,1,1),this.specularColor=new a.Color3(1,1,1),this.specularPower=64,this.emissiveColor=new a.Color3(0,0,0),this.useAlphaFromDiffuseTexture=!1,this._cachedDefines=null,this._renderTargets=new a.SmartArray(16),this._worldViewProjectionMatrix=a.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._baseColor=new a.Color3,this._scaledDiffuse=new a.Color3,this._scaledSpecular=new a.Color3,this.getRenderTargetTextures=function(){return e._renderTargets.reset(),e.reflectionTexture&&e.reflectionTexture.isRenderTarget&&e._renderTargets.push(e.reflectionTexture),e._renderTargets}}return __extends(d,c),d.prototype.needAlphaBlending=function(){return this.alpha<1||null!=this.opacityTexture||this._shouldUseAlphaFromDiffuseTexture()},d.prototype.needAlphaTesting=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha&&!this.diffuseTexture.getAlphaFromRGB},d.prototype._shouldUseAlphaFromDiffuseTexture=function(){return null!=this.diffuseTexture&&this.diffuseTexture.hasAlpha&&this.useAlphaFromDiffuseTexture},d.prototype.getAlphaTestTexture=function(){return this.diffuseTexture},d.prototype.isReady=function(c,d){if(this.checkReadyOnlyOnce&&this._wasPreviouslyReady)return!0;var e=this.getScene();if(!this.checkReadyOnEveryCall&&this._renderId===e.getRenderId())return!0;var f=e.getEngine(),g=[],h=new Array;if(e.texturesEnabled){if(this.diffuseTexture&&a.StandardMaterial.DiffuseTextureEnabled){if(!this.diffuseTexture.isReady())return!1;g.push("#define DIFFUSE")}if(this.ambientTexture&&a.StandardMaterial.AmbientTextureEnabled){if(!this.ambientTexture.isReady())return!1;g.push("#define AMBIENT")}if(this.opacityTexture&&a.StandardMaterial.OpacityTextureEnabled){if(!this.opacityTexture.isReady())return!1;g.push("#define OPACITY"),this.opacityTexture.getAlphaFromRGB&&g.push("#define OPACITYRGB")}if(this.reflectionTexture&&a.StandardMaterial.ReflectionTextureEnabled){if(!this.reflectionTexture.isReady())return!1;g.push("#define REFLECTION")}if(this.emissiveTexture&&a.StandardMaterial.EmissiveTextureEnabled){if(!this.emissiveTexture.isReady())return!1;g.push("#define EMISSIVE")}if(this.specularTexture&&a.StandardMaterial.SpecularTextureEnabled){if(!this.specularTexture.isReady())return!1;g.push("#define SPECULAR"),h.push(g[g.length-1])}}if(e.getEngine().getCaps().standardDerivatives&&this.bumpTexture&&a.StandardMaterial.BumpTextureEnabled){if(!this.bumpTexture.isReady())return!1;g.push("#define BUMP"),h.push(g[g.length-1])}e.clipPlane&&g.push("#define CLIPPLANE"),f.getAlphaTesting()&&g.push("#define ALPHATEST"),this._shouldUseAlphaFromDiffuseTexture()&&g.push("#define ALPHAFROMDIFFUSE"),e.fogMode!==a.Scene.FOGMODE_NONE&&(g.push("#define FOG"),h.push(g[g.length-1]));var i=!1,j=0;if(e.lightsEnabled)for(var k=0;k<e.lights.length;k++){var l=e.lights[k];if(l.isEnabled()){if(l._excludedMeshesIds.length>0){for(var m=0;m<l._excludedMeshesIds.length;m++){var n=e.getMeshByID(l._excludedMeshesIds[m]);n&&l.excludedMeshes.push(n)}l._excludedMeshesIds=[]}if(!c||-1===l.excludedMeshes.indexOf(c)){g.push("#define LIGHT"+j),j>0&&h.push(g[g.length-1]);var o;o=l instanceof a.SpotLight?"#define SPOTLIGHT"+j:l instanceof a.HemisphericLight?"#define HEMILIGHT"+j:"#define POINTDIRLIGHT"+j,g.push(o),j>0&&h.push(g[g.length-1]);var p=l.getShadowGenerator();if(c&&c.receiveShadows&&p&&(g.push("#define SHADOW"+j),j>0&&h.push(g[g.length-1]),i||(g.push("#define SHADOWS"),i=!0),p.useVarianceShadowMap&&(g.push("#define SHADOWVSM"+j),j>0&&h.push(g[g.length-1])),p.usePoissonSampling&&(g.push("#define SHADOWPCF"+j),j>0&&h.push(g[g.length-1]))),j++,j==b)break}}}var q=[a.VertexBuffer.PositionKind,a.VertexBuffer.NormalKind];c&&(c.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(q.push(a.VertexBuffer.UVKind),g.push("#define UV1")),c.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(q.push(a.VertexBuffer.UV2Kind),g.push("#define UV2")),c.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(q.push(a.VertexBuffer.ColorKind),g.push("#define VERTEXCOLOR")),c.skeleton&&c.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&c.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(q.push(a.VertexBuffer.MatricesIndicesKind),q.push(a.VertexBuffer.MatricesWeightsKind),g.push("#define BONES"),g.push("#define BonesPerMesh "+(c.skeleton.bones.length+1)),g.push("#define BONES4"),h.push(g[g.length-1])),d&&(g.push("#define INSTANCES"),q.push("world0"),q.push("world1"),q.push("world2"),q.push("world3")));var r=g.join("\n");if(this._cachedDefines!=r){this._cachedDefines=r;var s="default";e.getEngine().getCaps().standardDerivatives||(s="legacydefault"),this._effect=e.getEngine().createEffect(s,q,["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","vLightData0","vLightDiffuse0","vLightSpecular0","vLightDirection0","vLightGround0","lightMatrix0","vLightData1","vLightDiffuse1","vLightSpecular1","vLightDirection1","vLightGround1","lightMatrix1","vLightData2","vLightDiffuse2","vLightSpecular2","vLightDirection2","vLightGround2","lightMatrix2","vLightData3","vLightDiffuse3","vLightSpecular3","vLightDirection3","vLightGround3","lightMatrix3","vFogInfos","vFogColor","vDiffuseInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","mBones","vClipPlane","diffuseMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","specularMatrix","bumpMatrix","darkness0","darkness1","darkness2","darkness3"],["diffuseSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","specularSampler","bumpSampler","shadowSampler0","shadowSampler1","shadowSampler2","shadowSampler3"],r,h,this.onCompiled,this.onError)}return this._effect.isReady()?(this._renderId=e.getRenderId(),this._wasPreviouslyReady=!0,!0):!1},d.prototype.unbind=function(){this.reflectionTexture&&this.reflectionTexture.isRenderTarget&&this._effect.setTexture("reflection2DSampler",null)},d.prototype.bindOnlyWorldMatrix=function(a){this._effect.setMatrix("world",a)},d.prototype.bind=function(c,d){var e=this.getScene();if(this._baseColor.copyFrom(this.diffuseColor),this.bindOnlyWorldMatrix(c),this._effect.setMatrix("viewProjection",e.getTransformMatrix()),d.skeleton&&d.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&d.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&this._effect.setMatrices("mBones",d.skeleton.getTransformMatrices()),this.diffuseTexture&&a.StandardMaterial.DiffuseTextureEnabled&&(this._effect.setTexture("diffuseSampler",this.diffuseTexture),this._effect.setFloat2("vDiffuseInfos",this.diffuseTexture.coordinatesIndex,this.diffuseTexture.level),this._effect.setMatrix("diffuseMatrix",this.diffuseTexture.getTextureMatrix()),this._baseColor.copyFromFloats(1,1,1)),this.ambientTexture&&a.StandardMaterial.AmbientTextureEnabled&&(this._effect.setTexture("ambientSampler",this.ambientTexture),this._effect.setFloat2("vAmbientInfos",this.ambientTexture.coordinatesIndex,this.ambientTexture.level),this._effect.setMatrix("ambientMatrix",this.ambientTexture.getTextureMatrix())),this.opacityTexture&&a.StandardMaterial.OpacityTextureEnabled&&(this._effect.setTexture("opacitySampler",this.opacityTexture),this._effect.setFloat2("vOpacityInfos",this.opacityTexture.coordinatesIndex,this.opacityTexture.level),this._effect.setMatrix("opacityMatrix",this.opacityTexture.getTextureMatrix())),this.reflectionTexture&&a.StandardMaterial.ReflectionTextureEnabled&&(this.reflectionTexture.isCube?this._effect.setTexture("reflectionCubeSampler",this.reflectionTexture):this._effect.setTexture("reflection2DSampler",this.reflectionTexture),this._effect.setMatrix("reflectionMatrix",this.reflectionTexture.getReflectionTextureMatrix()),this._effect.setFloat3("vReflectionInfos",this.reflectionTexture.coordinatesMode,this.reflectionTexture.level,this.reflectionTexture.isCube?1:0)),this.emissiveTexture&&a.StandardMaterial.EmissiveTextureEnabled&&(this._effect.setTexture("emissiveSampler",this.emissiveTexture),this._effect.setFloat2("vEmissiveInfos",this.emissiveTexture.coordinatesIndex,this.emissiveTexture.level),this._effect.setMatrix("emissiveMatrix",this.emissiveTexture.getTextureMatrix())),this.specularTexture&&a.StandardMaterial.SpecularTextureEnabled&&(this._effect.setTexture("specularSampler",this.specularTexture),this._effect.setFloat2("vSpecularInfos",this.specularTexture.coordinatesIndex,this.specularTexture.level),this._effect.setMatrix("specularMatrix",this.specularTexture.getTextureMatrix())),this.bumpTexture&&e.getEngine().getCaps().standardDerivatives&&a.StandardMaterial.BumpTextureEnabled&&(this._effect.setTexture("bumpSampler",this.bumpTexture),this._effect.setFloat2("vBumpInfos",this.bumpTexture.coordinatesIndex,this.bumpTexture.level),this._effect.setMatrix("bumpMatrix",this.bumpTexture.getTextureMatrix())),e.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),this._effect.setVector3("vEyePosition",e.activeCamera.position),this._effect.setColor3("vAmbientColor",this._globalAmbientColor),this._effect.setColor4("vDiffuseColor",this._baseColor,this.alpha*d.visibility),this._effect.setColor4("vSpecularColor",this.specularColor,this.specularPower),this._effect.setColor3("vEmissiveColor",this.emissiveColor),e.lightsEnabled)for(var f=0,g=0;g<e.lights.length;g++){var h=e.lights[g];if(h.isEnabled()&&(!d||-1===h.excludedMeshes.indexOf(d))){h instanceof a.PointLight?h.transferToEffect(this._effect,"vLightData"+f):h instanceof a.DirectionalLight?h.transferToEffect(this._effect,"vLightData"+f):h instanceof a.SpotLight?h.transferToEffect(this._effect,"vLightData"+f,"vLightDirection"+f):h instanceof a.HemisphericLight&&h.transferToEffect(this._effect,"vLightData"+f,"vLightGround"+f),h.diffuse.scaleToRef(h.intensity,this._scaledDiffuse),h.specular.scaleToRef(h.intensity,this._scaledSpecular),this._effect.setColor4("vLightDiffuse"+f,this._scaledDiffuse,h.range),this._effect.setColor3("vLightSpecular"+f,this._scaledSpecular);var i=h.getShadowGenerator();if(d.receiveShadows&&i&&(this._effect.setMatrix("lightMatrix"+f,i.getTransformMatrix()),this._effect.setTexture("shadowSampler"+f,i.getShadowMap()),this._effect.setFloat("darkness"+f,i.getDarkness())),f++,f==b)break}}if(e.clipPlane){var j=e.clipPlane;this._effect.setFloat4("vClipPlane",j.normal.x,j.normal.y,j.normal.z,j.d)}(e.fogMode!==a.Scene.FOGMODE_NONE||this.reflectionTexture)&&this._effect.setMatrix("view",e.getViewMatrix()),e.fogMode!==a.Scene.FOGMODE_NONE&&(this._effect.setFloat4("vFogInfos",e.fogMode,e.fogStart,e.fogEnd,e.fogDensity),this._effect.setColor3("vFogColor",e.fogColor))},d.prototype.getAnimatables=function(){var a=[];return this.diffuseTexture&&this.diffuseTexture.animations&&this.diffuseTexture.animations.length>0&&a.push(this.diffuseTexture),this.ambientTexture&&this.ambientTexture.animations&&this.ambientTexture.animations.length>0&&a.push(this.ambientTexture),this.opacityTexture&&this.opacityTexture.animations&&this.opacityTexture.animations.length>0&&a.push(this.opacityTexture),this.reflectionTexture&&this.reflectionTexture.animations&&this.reflectionTexture.animations.length>0&&a.push(this.reflectionTexture),this.emissiveTexture&&this.emissiveTexture.animations&&this.emissiveTexture.animations.length>0&&a.push(this.emissiveTexture),this.specularTexture&&this.specularTexture.animations&&this.specularTexture.animations.length>0&&a.push(this.specularTexture),this.bumpTexture&&this.bumpTexture.animations&&this.bumpTexture.animations.length>0&&a.push(this.bumpTexture),a},d.prototype.dispose=function(a){this.diffuseTexture&&this.diffuseTexture.dispose(),this.ambientTexture&&this.ambientTexture.dispose(),this.opacityTexture&&this.opacityTexture.dispose(),this.reflectionTexture&&this.reflectionTexture.dispose(),this.emissiveTexture&&this.emissiveTexture.dispose(),this.specularTexture&&this.specularTexture.dispose(),this.bumpTexture&&this.bumpTexture.dispose(),c.prototype.dispose.call(this,a)},d.prototype.clone=function(b){var c=new a.StandardMaterial(b,this.getScene());return c.checkReadyOnEveryCall=this.checkReadyOnEveryCall,c.alpha=this.alpha,c.wireframe=this.wireframe,c.backFaceCulling=this.backFaceCulling,this.diffuseTexture&&this.diffuseTexture.clone&&(c.diffuseTexture=this.diffuseTexture.clone()),this.ambientTexture&&this.ambientTexture.clone&&(c.ambientTexture=this.ambientTexture.clone()),this.opacityTexture&&this.opacityTexture.clone&&(c.opacityTexture=this.opacityTexture.clone()),this.reflectionTexture&&this.reflectionTexture.clone&&(c.reflectionTexture=this.reflectionTexture.clone()),this.emissiveTexture&&this.emissiveTexture.clone&&(c.emissiveTexture=this.emissiveTexture.clone()),this.specularTexture&&this.specularTexture.clone&&(c.specularTexture=this.specularTexture.clone()),this.bumpTexture&&this.bumpTexture.clone&&(c.bumpTexture=this.bumpTexture.clone()),c.ambientColor=this.ambientColor.clone(),c.diffuseColor=this.diffuseColor.clone(),c.specularColor=this.specularColor.clone(),c.specularPower=this.specularPower,c.emissiveColor=this.emissiveColor.clone(),c},d.DiffuseTextureEnabled=!0,d.AmbientTextureEnabled=!0,d.OpacityTextureEnabled=!0,d.ReflectionTextureEnabled=!0,d.EmissiveTextureEnabled=!0,d.SpecularTextureEnabled=!0,d.BumpTextureEnabled=!0,d}(a.Material);a.StandardMaterial=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c){a.call(this,b,c,!0),this.subMaterials=new Array,c.multiMaterials.push(this)}return __extends(b,a),b.prototype.getSubMaterial=function(a){return 0>a||a>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[a]},b.prototype.isReady=function(a){for(var b=0;b<this.subMaterials.length;b++){var c=this.subMaterials[b];if(c&&!this.subMaterials[b].isReady(a))return!1}return!0},b}(a.Material);a.MultiMaterial=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.idbFactory=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,this.callbackManifestChecked=c,this.currentSceneUrl=a.Database.ReturnFullUrlLocation(b),this.db=null,this.enableSceneOffline=!1,this.enableTexturesOffline=!1,this.manifestVersionFound=0,this.mustUpdateRessources=!1,this.hasReachedQuota=!1,this.checkManifestFile()}return b.prototype.checkManifestFile=function(){function b(){a.Tools.Log("Valid manifest file not found. Scene & textures will be loaded directly from the web server."),d.enableSceneOffline=!1,d.enableTexturesOffline=!1,d.callbackManifestChecked(!1)}var c=this,d=this,e=this.currentSceneUrl+".manifest",f=new XMLHttpRequest,g=e+(null==e.match(/\?/)?"?":"&")+(new Date).getTime();f.open("GET",g,!0),f.addEventListener("load",function(){if(200===f.status||a.Tools.ValidateXHRData(f,1))try{var d=JSON.parse(f.response);c.enableSceneOffline=d.enableSceneOffline,c.enableTexturesOffline=d.enableTexturesOffline,d.version&&!isNaN(parseInt(d.version))&&(c.manifestVersionFound=d.version),c.callbackManifestChecked&&c.callbackManifestChecked(!0)}catch(e){b()}else b()},!1),f.addEventListener("error",function(){b()},!1);try{f.send()}catch(h){a.Tools.Error("Error on XHR send request."),d.callbackManifestChecked(!1)}},b.prototype.openAsync=function(b,c){function d(){f.isSupported=!1,c&&c()}var e=this,f=this;if(this.idbFactory&&(this.enableSceneOffline||this.enableTexturesOffline))if(this.db)b&&b();else{this.hasReachedQuota=!1,this.isSupported=!0;var g=this.idbFactory.open("babylonjs",1);g.onerror=function(){d()},g.onblocked=function(){a.Tools.Error("IDB request blocked. Please reload the page."),d()},g.onsuccess=function(){e.db=g.result,b()},g.onupgradeneeded=function(b){e.db=b.target.result;try{b.oldVersion>0&&(e.db.deleteObjectStore("scenes"),e.db.deleteObjectStore("versions"),e.db.deleteObjectStore("textures"));{e.db.createObjectStore("scenes",{keyPath:"sceneUrl"}),e.db.createObjectStore("versions",{keyPath:"sceneUrl"}),e.db.createObjectStore("textures",{keyPath:"textureUrl"})}}catch(c){a.Tools.Error("Error while creating object stores. Exception: "+c.message),d()}}}else this.isSupported=!1,c&&c()},b.prototype.loadImageFromDB=function(b,c){var d=this,e=a.Database.ReturnFullUrlLocation(b),f=function(){d.hasReachedQuota||null===d.db?c.src=b:d._saveImageIntoDBAsync(e,c)};this.mustUpdateRessources?f():this._loadImageFromDBAsync(e,c,f)},b.prototype._loadImageFromDBAsync=function(b,c,d){if(this.isSupported&&null!==this.db){var e,f=this.db.transaction(["textures"]);f.onabort=function(){c.src=b},f.oncomplete=function(){var f;if(e){var g=window.URL||window.webkitURL;f=g.createObjectURL(e.data,{oneTimeOnly:!0}),c.onerror=function(){a.Tools.Error("Error loading image from blob URL: "+f+" switching back to web url: "+b),c.src=b},c.src=f}else d()};var g=f.objectStore("textures").get(b);g.onsuccess=function(a){e=a.target.result},g.onerror=function(){a.Tools.Error("Error loading texture "+b+" from DB."),c.src=b}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c.src=b},b.prototype._saveImageIntoDBAsync=function(b,c){var d=this;if(this.isSupported){var e=function(){var a;if(f){var b=window.URL||window.webkitURL;try{a=b.createObjectURL(f,{oneTimeOnly:!0})}catch(d){a=b.createObjectURL(f)}}c.src=a};if(a.Database.isUASupportingBlobStorage){var f,g=new XMLHttpRequest;g.open("GET",b,!0),g.responseType="blob",g.addEventListener("load",function(){if(200===g.status){f=g.response;var h=d.db.transaction(["textures"],"readwrite");h.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(this.hasReachedQuota=!0)}catch(b){}e()},h.oncomplete=function(){e()};var i={textureUrl:b,data:f};try{var j=h.objectStore("textures").put(i);j.onsuccess=function(){},j.onerror=function(){e()}}catch(k){25===k.code&&(a.Database.isUASupportingBlobStorage=!1),c.src=b}}else c.src=b},!1),g.addEventListener("error",function(){a.Tools.Error("Error in XHR request in BABYLON.Database."),c.src=b},!1),g.send()}else c.src=b}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c.src=b},b.prototype._checkVersionFromDB=function(a,b){var c=this,d=function(){c._saveVersionIntoDBAsync(a,b)};this._loadVersionFromDBAsync(a,b,d)},b.prototype._loadVersionFromDBAsync=function(b,c,d){var e=this;if(this.isSupported){var f;try{var g=this.db.transaction(["versions"]);g.oncomplete=function(){f?e.manifestVersionFound>f.data?(e.mustUpdateRessources=!0,d()):c(f.data):(e.mustUpdateRessources=!0,d())},g.onabort=function(){c(-1)};var h=g.objectStore("versions").get(b);h.onsuccess=function(a){f=a.target.result},h.onerror=function(){a.Tools.Error("Error loading version for scene "+b+" from DB."),c(-1)}}catch(i){a.Tools.Error("Error while accessing 'versions' object store (READ OP). Exception: "+i.message),c(-1)}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c(-1)},b.prototype._saveVersionIntoDBAsync=function(b,c){var d=this;if(this.isSupported&&!this.hasReachedQuota)try{var e=this.db.transaction(["versions"],"readwrite");e.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(d.hasReachedQuota=!0)}catch(b){}c(-1)},e.oncomplete=function(){c(d.manifestVersionFound)};var f={sceneUrl:b,data:this.manifestVersionFound},g=e.objectStore("versions").put(f);g.onsuccess=function(){},g.onerror=function(){a.Tools.Error("Error in DB add version request in BABYLON.Database.")}}catch(h){a.Tools.Error("Error while accessing 'versions' object store (WRITE OP). Exception: "+h.message),c(-1)}else c(-1)},b.prototype.loadFileFromDB=function(b,c,d,e,f){var g=this,h=a.Database.ReturnFullUrlLocation(b),i=function(){g._saveFileIntoDBAsync(h,c,d)};this._checkVersionFromDB(h,function(a){-1!==a?g.mustUpdateRessources?g._saveFileIntoDBAsync(h,c,d,f):g._loadFileFromDBAsync(h,c,i,f):e()})},b.prototype._loadFileFromDBAsync=function(b,c,d){if(this.isSupported){var e;e=-1!==b.indexOf(".babylon")?"scenes":"textures";var f,g=this.db.transaction([e]);g.oncomplete=function(){f?c(f.data):d()},g.onabort=function(){d()};var h=g.objectStore(e).get(b);h.onsuccess=function(a){f=a.target.result},h.onerror=function(){a.Tools.Error("Error loading file "+b+" from DB."),d()}}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c()},b.prototype._saveFileIntoDBAsync=function(b,c,d,e){var f=this;if(this.isSupported){var g;g=-1!==b.indexOf(".babylon")?"scenes":"textures";var h,i=new XMLHttpRequest;i.open("GET",b,!0),e&&(i.responseType="arraybuffer"),i.onprogress=d,i.addEventListener("load",function(){if(200===i.status||a.Tools.ValidateXHRData(i,e?6:1))if(h=e?i.response:i.responseText,f.hasReachedQuota)c(h);else{var d=f.db.transaction([g],"readwrite");d.onabort=function(a){try{"QuotaExceededError"===a.srcElement.error.name&&(this.hasReachedQuota=!0)}catch(b){}c(h)},d.oncomplete=function(){c(h)};var j;j="scenes"===g?{sceneUrl:b,data:h,version:f.manifestVersionFound}:{textureUrl:b,data:h};try{var k=d.objectStore(g).put(j);k.onsuccess=function(){},k.onerror=function(){a.Tools.Error("Error in DB add file request in BABYLON.Database.")}}catch(l){c(h)}}else c()},!1),i.addEventListener("error",function(){a.Tools.Error("error on XHR request."),c()},!1),i.send()}else a.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),c()},b.isUASupportingBlobStorage=!0,b.parseURL=function(a){var b=document.createElement("a");b.href=a;var c=a.substring(a.lastIndexOf("/")+1,a.length),d=a.substring(0,a.indexOf(c,0));return d},b.ReturnFullUrlLocation=function(b){return-1===b.indexOf("http:/")?a.Database.parseURL(window.location.href)+b:b},b}();a.Database=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g){this.name=b,this.cellSize=e,this.sprites=new Array,this.renderingGroupId=0,this._vertexDeclaration=[3,4,4,4],this._vertexStrideSize=60,this._capacity=d,this._spriteTexture=new a.Texture(c,f,!0,!1),this._spriteTexture.wrapU=a.Texture.CLAMP_ADDRESSMODE,this._spriteTexture.wrapV=a.Texture.CLAMP_ADDRESSMODE,this._epsilon=void 0===g?.01:g,this._scene=f,this._scene.spriteManagers.push(this),this._vertexDeclaration=[3,4,4,4],this._vertexStrideSize=60,this._vertexBuffer=f.getEngine().createDynamicVertexBuffer(d*this._vertexStrideSize*4);for(var h=[],i=0,j=0;d>j;j++)h.push(i),h.push(i+1),h.push(i+2),h.push(i),h.push(i+2),h.push(i+3),i+=4;this._indexBuffer=f.getEngine().createIndexBuffer(h),this._vertices=new Float32Array(d*this._vertexStrideSize),this._effectBase=this._scene.getEngine().createEffect("sprites",["position","options","cellInfo","color"],["view","projection","textureInfos","alphaTest"],["diffuseSampler"],""),this._effectFog=this._scene.getEngine().createEffect("sprites",["position","options","cellInfo","color"],["view","projection","textureInfos","alphaTest","vFogInfos","vFogColor"],["diffuseSampler"],"#define FOG")}return b.prototype._appendSpriteVertex=function(a,b,c,d,e){var f=15*a;0==c?c=this._epsilon:1==c&&(c=1-this._epsilon),0==d?d=this._epsilon:1==d&&(d=1-this._epsilon),this._vertices[f]=b.position.x,this._vertices[f+1]=b.position.y,this._vertices[f+2]=b.position.z,this._vertices[f+3]=b.angle,this._vertices[f+4]=b.size,this._vertices[f+5]=c,this._vertices[f+6]=d,this._vertices[f+7]=b.invertU?1:0,this._vertices[f+8]=b.invertV?1:0;var g=b.cellIndex/e>>0;this._vertices[f+9]=b.cellIndex-g*e,this._vertices[f+10]=g,this._vertices[f+11]=b.color.r,this._vertices[f+12]=b.color.g,this._vertices[f+13]=b.color.b,this._vertices[f+14]=b.color.a},b.prototype.render=function(){if(this._effectBase.isReady()&&this._effectFog.isReady()&&this._spriteTexture&&this._spriteTexture.isReady()){for(var b=this._scene.getEngine(),c=this._spriteTexture.getBaseSize(),d=a.Tools.GetDeltaTime(),e=Math.min(this._capacity,this.sprites.length),f=c.width/this.cellSize,g=0,h=0;e>h;h++){var i=this.sprites[h];i&&(i._animate(d),this._appendSpriteVertex(g++,i,0,0,f),this._appendSpriteVertex(g++,i,1,0,f),this._appendSpriteVertex(g++,i,1,1,f),this._appendSpriteVertex(g++,i,0,1,f))}b.updateDynamicVertexBuffer(this._vertexBuffer,this._vertices,e*this._vertexStrideSize);var j=this._effectBase;this._scene.fogMode!==a.Scene.FOGMODE_NONE&&(j=this._effectFog),b.enableEffect(j);var k=this._scene.getViewMatrix();j.setTexture("diffuseSampler",this._spriteTexture),j.setMatrix("view",k),j.setMatrix("projection",this._scene.getProjectionMatrix()),j.setFloat2("textureInfos",this.cellSize/c.width,this.cellSize/c.height),this._scene.fogMode!==a.Scene.FOGMODE_NONE&&(j.setFloat4("vFogInfos",this._scene.fogMode,this._scene.fogStart,this._scene.fogEnd,this._scene.fogDensity),j.setColor3("vFogColor",this._scene.fogColor)),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,j),j.setBool("alphaTest",!0),b.setColorWrite(!1),b.draw(!0,0,6*e),b.setColorWrite(!0),j.setBool("alphaTest",!1),b.setAlphaMode(a.Engine.ALPHA_COMBINE),b.draw(!0,0,6*e),b.setAlphaMode(a.Engine.ALPHA_DISABLE)}},b.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this._spriteTexture&&(this._spriteTexture.dispose(),this._spriteTexture=null);var a=this._scene.spriteManagers.indexOf(this);this._scene.spriteManagers.splice(a,1),this.onDispose&&this.onDispose()},b}();a.SpriteManager=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c){this.name=b,this.color=new a.Color4(1,1,1,1),this.size=1,this.angle=0,this.cellIndex=0,this.invertU=0,this.invertV=0,this.animations=new Array,this._animationStarted=!1,this._loopAnimation=!1,this._fromIndex=0,this._toIndex=0,this._delay=0,this._direction=1,this._frameCount=0,this._time=0,this._manager=c,this._manager.sprites.push(this),this.position=a.Vector3.Zero()}return b.prototype.playAnimation=function(a,b,c,d){this._fromIndex=a,this._toIndex=b,this._loopAnimation=c,this._delay=d,this._animationStarted=!0,this._direction=b>a?1:-1,this.cellIndex=a,this._time=0},b.prototype.stopAnimation=function(){this._animationStarted=!1},b.prototype._animate=function(a){this._animationStarted&&(this._time+=a,this._time>this._delay&&(this._time=this._time%this._delay,this.cellIndex+=this._direction,this.cellIndex==this._toIndex&&(this._loopAnimation?this.cellIndex=this._fromIndex:(this._animationStarted=!1,this.disposeWhenFinishedAnimating&&this.dispose()))))},b.prototype.dispose=function(){for(var a=0;a<this._manager.sprites.length;a++)this._manager.sprites[a]==this&&this._manager.sprites.splice(a,1)},b}();a.Sprite=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.name=b,this._vertexDeclaration=[2],this._vertexStrideSize=8,this.texture=c?new a.Texture(c,d,!0):null,this.isBackground=void 0===e?!0:e,this.color=void 0===f?new a.Color4(1,1,1,1):f,this._scene=d,this._scene.layers.push(this);var g=[];g.push(1,1),g.push(-1,1),g.push(-1,-1),g.push(1,-1),this._vertexBuffer=d.getEngine().createVertexBuffer(g);var h=[];h.push(0),h.push(1),h.push(2),h.push(0),h.push(2),h.push(3),this._indexBuffer=d.getEngine().createIndexBuffer(h),this._effect=this._scene.getEngine().createEffect("layer",["position"],["textureMatrix","color"],["textureSampler"],"")}return b.prototype.render=function(){if(this._effect.isReady()&&this.texture&&this.texture.isReady()){var b=this._scene.getEngine();b.enableEffect(this._effect),b.setState(!1),this._effect.setTexture("textureSampler",this.texture),this._effect.setMatrix("textureMatrix",this.texture.getTextureMatrix()),this._effect.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,this._effect),b.setAlphaMode(a.Engine.ALPHA_COMBINE),b.draw(!0,0,6),b.setAlphaMode(a.Engine.ALPHA_DISABLE)}},b.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null);var a=this._scene.layers.indexOf(this);this._scene.layers.splice(a,1),this.onDispose&&this.onDispose()},b}();a.Layer=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this.position=a.Vector3.Zero(),this.direction=a.Vector3.Zero(),this.color=new a.Color4(0,0,0,0),this.colorStep=new a.Color4(0,0,0,0),this.lifeTime=1,this.age=0,this.size=0,this.angle=0,this.angularSpeed=0}return b}();a.Particle=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(a,b){if(a==b)return a;var c=Math.random();return c*(b-a)+a},c=function(){function c(c,d,e,f){var g=this;this.name=c,this.fragmentElement=f,this.renderingGroupId=0,this.emitter=null,this.emitRate=10,this.manualEmitCount=-1,this.updateSpeed=.01,this.targetStopDuration=0,this.disposeOnStop=!1,this.minEmitPower=1,this.maxEmitPower=1,this.minLifeTime=1,this.maxLifeTime=1,this.minSize=1,this.maxSize=1,this.minAngularSpeed=0,this.maxAngularSpeed=0,this.blendMode=a.ParticleSystem.BLENDMODE_ONEONE,this.forceDepthWrite=!1,this.gravity=a.Vector3.Zero(),this.direction1=new a.Vector3(0,1,0),this.direction2=new a.Vector3(0,1,0),this.minEmitBox=new a.Vector3(-.5,-.5,-.5),this.maxEmitBox=new a.Vector3(.5,.5,.5),this.color1=new a.Color4(1,1,1,1),this.color2=new a.Color4(1,1,1,1),this.colorDead=new a.Color4(0,0,0,1),this.textureMask=new a.Color4(1,1,1,1),this.particles=new Array,this._vertexDeclaration=[3,4,4],this._vertexStrideSize=44,this._stockParticles=new Array,this._newPartsExcess=0,this._scaledColorStep=new a.Color4(0,0,0,0),this._colorDiff=new a.Color4(0,0,0,0),this._scaledDirection=a.Vector3.Zero(),this._scaledGravity=a.Vector3.Zero(),this._currentRenderId=-1,this._started=!1,this._stopped=!1,this._actualFrame=0,this.id=c,this._capacity=d,this._scene=e,e.particleSystems.push(this),this._vertexBuffer=e.getEngine().createDynamicVertexBuffer(d*this._vertexStrideSize*4);for(var h=[],i=0,j=0;d>j;j++)h.push(i),h.push(i+1),h.push(i+2),h.push(i),h.push(i+2),h.push(i+3),i+=4;this._indexBuffer=e.getEngine().createIndexBuffer(h),this._vertices=new Float32Array(d*this._vertexStrideSize),this.startDirectionFunction=function(c,d,e){var f=b(g.direction1.x,g.direction2.x),h=b(g.direction1.y,g.direction2.y),i=b(g.direction1.z,g.direction2.z);
a.Vector3.TransformNormalFromFloatsToRef(f*c,h*c,i*c,d,e)},this.startPositionFunction=function(c,d){var e=b(g.minEmitBox.x,g.maxEmitBox.x),f=b(g.minEmitBox.y,g.maxEmitBox.y),h=b(g.minEmitBox.z,g.maxEmitBox.z);a.Vector3.TransformCoordinatesFromFloatsToRef(e,f,h,c,d)}}return c.prototype.getCapacity=function(){return this._capacity},c.prototype.isAlive=function(){return this._alive},c.prototype.isStarted=function(){return this._started},c.prototype.start=function(){this._started=!0,this._stopped=!1,this._actualFrame=0},c.prototype.stop=function(){this._stopped=!0},c.prototype._appendParticleVertex=function(a,b,c,d){var e=11*a;this._vertices[e]=b.position.x,this._vertices[e+1]=b.position.y,this._vertices[e+2]=b.position.z,this._vertices[e+3]=b.color.r,this._vertices[e+4]=b.color.g,this._vertices[e+5]=b.color.b,this._vertices[e+6]=b.color.a,this._vertices[e+7]=b.angle,this._vertices[e+8]=b.size,this._vertices[e+9]=c,this._vertices[e+10]=d},c.prototype._update=function(c){this._alive=this.particles.length>0;for(var d=0;d<this.particles.length;d++){var e=this.particles[d];e.age+=this._scaledUpdateSpeed,e.age>=e.lifeTime?(this._stockParticles.push(this.particles.splice(d,1)[0]),d--):(e.colorStep.scaleToRef(this._scaledUpdateSpeed,this._scaledColorStep),e.color.addInPlace(this._scaledColorStep),e.color.a<0&&(e.color.a=0),e.angle+=e.angularSpeed*this._scaledUpdateSpeed,e.direction.scaleToRef(this._scaledUpdateSpeed,this._scaledDirection),e.position.addInPlace(this._scaledDirection),this.gravity.scaleToRef(this._scaledUpdateSpeed,this._scaledGravity),e.direction.addInPlace(this._scaledGravity))}var f;for(f=this.emitter.position?this.emitter.getWorldMatrix():a.Matrix.Translation(this.emitter.x,this.emitter.y,this.emitter.z),d=0;c>d&&this.particles.length!=this._capacity;d++){0!==this._stockParticles.length?(e=this._stockParticles.pop(),e.age=0):e=new a.Particle,this.particles.push(e);var g=b(this.minEmitPower,this.maxEmitPower);this.startDirectionFunction(g,f,e.direction),e.lifeTime=b(this.minLifeTime,this.maxLifeTime),e.size=b(this.minSize,this.maxSize),e.angularSpeed=b(this.minAngularSpeed,this.maxAngularSpeed),this.startPositionFunction(f,e.position);var h=b(0,1);a.Color4.LerpToRef(this.color1,this.color2,h,e.color),this.colorDead.subtractToRef(e.color,this._colorDiff),this._colorDiff.scaleToRef(1/e.lifeTime,e.colorStep)}},c.prototype._getEffect=function(){var a=[];this._scene.clipPlane&&a.push("#define CLIPPLANE");var b=a.join("\n");if(this._cachedDefines!=b){this._cachedDefines=b;var c;c=this.fragmentElement?{vertex:"particles",fragmentElement:this.fragmentElement}:"particles",this._effect=this._scene.getEngine().createEffect(c,["position","color","options"],["invView","view","projection","vClipPlane","textureMask"],["diffuseSampler"],b)}return this._effect},c.prototype.animate=function(){if(this._started){var a=this._getEffect();if(this.emitter&&a.isReady()&&this.particleTexture&&this.particleTexture.isReady()&&this._currentRenderId!==this._scene.getRenderId()){this._currentRenderId=this._scene.getRenderId(),this._scaledUpdateSpeed=this.updateSpeed*this._scene.getAnimationRatio();var b;this.manualEmitCount>-1?(b=this.manualEmitCount,this.manualEmitCount=0):b=this.emitRate;var c=b*this._scaledUpdateSpeed>>0;this._newPartsExcess+=b*this._scaledUpdateSpeed-c,this._newPartsExcess>1&&(c+=this._newPartsExcess>>0,this._newPartsExcess-=this._newPartsExcess>>0),this._alive=!1,this._stopped?c=0:(this._actualFrame+=this._scaledUpdateSpeed,this.targetStopDuration&&this._actualFrame>=this.targetStopDuration&&this.stop()),this._update(c),this._stopped&&(this._alive||(this._started=!1,this.disposeOnStop&&this._scene._toBeDisposed.push(this)));for(var d=0,e=0;e<this.particles.length;e++){var f=this.particles[e];this._appendParticleVertex(d++,f,0,0),this._appendParticleVertex(d++,f,1,0),this._appendParticleVertex(d++,f,1,1),this._appendParticleVertex(d++,f,0,1)}var g=this._scene.getEngine();g.updateDynamicVertexBuffer(this._vertexBuffer,this._vertices,this.particles.length*this._vertexStrideSize)}}},c.prototype.render=function(){var b=this._getEffect();if(!(this.emitter&&b.isReady()&&this.particleTexture&&this.particleTexture.isReady()&&this.particles.length))return 0;var c=this._scene.getEngine();c.enableEffect(b);var d=this._scene.getViewMatrix();if(b.setTexture("diffuseSampler",this.particleTexture),b.setMatrix("view",d),b.setMatrix("projection",this._scene.getProjectionMatrix()),b.setFloat4("textureMask",this.textureMask.r,this.textureMask.g,this.textureMask.b,this.textureMask.a),this._scene.clipPlane){var e=this._scene.clipPlane,f=d.clone();f.invert(),b.setMatrix("invView",f),b.setFloat4("vClipPlane",e.normal.x,e.normal.y,e.normal.z,e.d)}return c.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,b),c.setAlphaMode(this.blendMode===a.ParticleSystem.BLENDMODE_ONEONE?a.Engine.ALPHA_ADD:a.Engine.ALPHA_COMBINE),this.forceDepthWrite&&c.setDepthWrite(!0),c.draw(!0,0,6*this.particles.length),c.setAlphaMode(a.Engine.ALPHA_DISABLE),this.particles.length},c.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.particleTexture&&(this.particleTexture.dispose(),this.particleTexture=null);var a=this._scene.particleSystems.indexOf(this);this._scene.particleSystems.splice(a,1),this.onDispose&&this.onDispose()},c.prototype.clone=function(b,c){var d=new a.ParticleSystem(b,this._capacity,this._scene);return a.Tools.DeepCopy(this,d,["particles"],["_vertexDeclaration","_vertexStrideSize"]),void 0===c&&(c=this.emitter),d.emitter=c,this.particleTexture&&(d.particleTexture=new a.Texture(this.particleTexture.url,this._scene)),d.start(),d},c.BLENDMODE_ONEONE=0,c.BLENDMODE_STANDARD=1,c}();a.ParticleSystem=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,c,d,e,f){this.name=a,this.targetProperty=c,this.framePerSecond=d,this.dataType=e,this.loopMode=f,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this.targetPropertyPath=c.split("."),this.dataType=e,this.loopMode=void 0===f?b.ANIMATIONLOOPMODE_CYCLE:f}return b.prototype.isStopped=function(){return this._stopped},b.prototype.getKeys=function(){return this._keys},b.prototype.floatInterpolateFunction=function(a,b,c){return a+(b-a)*c},b.prototype.quaternionInterpolateFunction=function(b,c,d){return a.Quaternion.Slerp(b,c,d)},b.prototype.vector3InterpolateFunction=function(b,c,d){return a.Vector3.Lerp(b,c,d)},b.prototype.color3InterpolateFunction=function(b,c,d){return a.Color3.Lerp(b,c,d)},b.prototype.clone=function(){var a=new b(this.name,this.targetPropertyPath.join("."),this.framePerSecond,this.dataType,this.loopMode);return a.setKeys(this._keys),a},b.prototype.setKeys=function(a){this._keys=a.slice(0),this._offsetsCache={},this._highLimitsCache={}},b.prototype._interpolate=function(a,c,d,e,f){if(d===b.ANIMATIONLOOPMODE_CONSTANT&&c>0)return f.clone?f.clone():f;this.currentFrame=a;for(var g=0;g<this._keys.length;g++)if(this._keys[g+1].frame>=a){var h=this._keys[g].value,i=this._keys[g+1].value,j=(a-this._keys[g].frame)/(this._keys[g+1].frame-this._keys[g].frame);switch(this.dataType){case b.ANIMATIONTYPE_FLOAT:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.floatInterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return e*c+this.floatInterpolateFunction(h,i,j)}break;case b.ANIMATIONTYPE_QUATERNION:var k=null;switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:k=this.quaternionInterpolateFunction(h,i,j);break;case b.ANIMATIONLOOPMODE_RELATIVE:k=this.quaternionInterpolateFunction(h,i,j).add(e.scale(c))}return k;case b.ANIMATIONTYPE_VECTOR3:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.vector3InterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return this.vector3InterpolateFunction(h,i,j).add(e.scale(c))}case b.ANIMATIONTYPE_COLOR3:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:return this.color3InterpolateFunction(h,i,j);case b.ANIMATIONLOOPMODE_RELATIVE:return this.color3InterpolateFunction(h,i,j).add(e.scale(c))}case b.ANIMATIONTYPE_MATRIX:switch(d){case b.ANIMATIONLOOPMODE_CYCLE:case b.ANIMATIONLOOPMODE_CONSTANT:case b.ANIMATIONLOOPMODE_RELATIVE:return h}}break}return this._keys[this._keys.length-1].value},b.prototype.animate=function(a,c,d,e,f){if(!this.targetPropertyPath||this.targetPropertyPath.length<1)return this._stopped=!0,!1;var g=!0;if(0!=this._keys[0].frame){var h={frame:0,value:this._keys[0].value};this._keys.splice(0,0,h)}(c<this._keys[0].frame||c>this._keys[this._keys.length-1].frame)&&(c=this._keys[0].frame),(d<this._keys[0].frame||d>this._keys[this._keys.length-1].frame)&&(d=this._keys[this._keys.length-1].frame);var i=d-c,j=a*this.framePerSecond*f/1e3;if(j>i&&!e)k=0,g=!1,l=this._keys[this._keys.length-1].value;else{var k=0,l=0;if(this.loopMode!=b.ANIMATIONLOOPMODE_CYCLE){var m=d.toString()+c.toString();if(!this._offsetsCache[m]){var n=this._interpolate(c,0,b.ANIMATIONLOOPMODE_CYCLE),o=this._interpolate(d,0,b.ANIMATIONLOOPMODE_CYCLE);switch(this.dataType){case b.ANIMATIONTYPE_FLOAT:this._offsetsCache[m]=o-n;break;case b.ANIMATIONTYPE_QUATERNION:this._offsetsCache[m]=o.subtract(n);break;case b.ANIMATIONTYPE_VECTOR3:this._offsetsCache[m]=o.subtract(n);case b.ANIMATIONTYPE_COLOR3:this._offsetsCache[m]=o.subtract(n)}this._highLimitsCache[m]=o}l=this._highLimitsCache[m],k=this._offsetsCache[m]}}var p=j/i>>0,q=g?c+j%i:d,r=this._interpolate(q,p,this.loopMode,k,l);if(this.targetPropertyPath.length>1){for(var s=this._target[this.targetPropertyPath[0]],t=1;t<this.targetPropertyPath.length-1;t++)s=s[this.targetPropertyPath[t]];s[this.targetPropertyPath[this.targetPropertyPath.length-1]]=r}else this._target[this.targetPropertyPath[0]]=r;return this._target.markAsDirty&&this._target.markAsDirty(this.targetProperty),g||(this._stopped=!0),g},Object.defineProperty(b,"ANIMATIONTYPE_FLOAT",{get:function(){return b._ANIMATIONTYPE_FLOAT},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_VECTOR3",{get:function(){return b._ANIMATIONTYPE_VECTOR3},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_QUATERNION",{get:function(){return b._ANIMATIONTYPE_QUATERNION},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_MATRIX",{get:function(){return b._ANIMATIONTYPE_MATRIX},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONTYPE_COLOR3",{get:function(){return b._ANIMATIONTYPE_COLOR3},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_RELATIVE",{get:function(){return b._ANIMATIONLOOPMODE_RELATIVE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_CYCLE",{get:function(){return b._ANIMATIONLOOPMODE_CYCLE},enumerable:!0,configurable:!0}),Object.defineProperty(b,"ANIMATIONLOOPMODE_CONSTANT",{get:function(){return b._ANIMATIONLOOPMODE_CONSTANT},enumerable:!0,configurable:!0}),b._ANIMATIONTYPE_FLOAT=0,b._ANIMATIONTYPE_VECTOR3=1,b._ANIMATIONTYPE_QUATERNION=2,b._ANIMATIONTYPE_MATRIX=3,b._ANIMATIONTYPE_COLOR3=4,b._ANIMATIONLOOPMODE_RELATIVE=0,b._ANIMATIONLOOPMODE_CYCLE=1,b._ANIMATIONLOOPMODE_CONSTANT=2,b}();a.Animation=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c,d,e,f,g,h){"undefined"==typeof c&&(c=0),"undefined"==typeof d&&(d=100),"undefined"==typeof e&&(e=!1),"undefined"==typeof f&&(f=1),this.target=b,this.fromFrame=c,this.toFrame=d,this.loopAnimation=e,this.speedRatio=f,this.onAnimationEnd=g,this._animations=new Array,this._paused=!1,this.animationStarted=!1,h&&this.appendAnimations(b,h),this._scene=a,a._activeAnimatables.push(this)}return a.prototype.appendAnimations=function(a,b){for(var c=0;c<b.length;c++){var d=b[c];d._target=a,this._animations.push(d)}},a.prototype.getAnimationByTargetProperty=function(a){for(var b=this._animations,c=0;c<b.length;c++)if(b[c].targetProperty===a)return b[c];return null},a.prototype.pause=function(){this._paused=!0},a.prototype.restart=function(){this._paused=!1},a.prototype.stop=function(){var a=this._scene._activeAnimatables.indexOf(this);a>-1&&this._scene._activeAnimatables.splice(a,1),this.onAnimationEnd&&this.onAnimationEnd()},a.prototype._animate=function(a){if(this._paused)return!0;this._localDelayOffset||(this._localDelayOffset=a);for(var b=!1,c=this._animations,d=0;d<c.length;d++){var e=c[d],f=e.animate(a-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this.speedRatio);b=b||f}return!b&&this.onAnimationEnd&&this.onAnimationEnd(),b},a}();a.Animatable=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d){"undefined"==typeof d&&(d=2),this.maxDepth=d,this.dynamicContent=new Array,this._maxBlockCapacity=c||64,this._selectionContent=new a.SmartArray(1024),this._creationFunc=b}return b.prototype.update=function(a,c,d){b._CreateBlocks(a,c,d,this._maxBlockCapacity,0,this.maxDepth,this,this._creationFunc)},b.prototype.addMesh=function(a){for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.addEntry(a)}},b.prototype.select=function(a,b){this._selectionContent.reset();for(var c=0;c<this.blocks.length;c++){var d=this.blocks[c];d.select(a,this._selectionContent,b)}return b?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b.prototype.intersects=function(a,b,c){this._selectionContent.reset();for(var d=0;d<this.blocks.length;d++){var e=this.blocks[d];e.intersects(a,b,this._selectionContent,c)}return c?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b.prototype.intersectsRay=function(a){this._selectionContent.reset();for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.intersectsRay(a,this._selectionContent)}return this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent},b._CreateBlocks=function(b,c,d,e,f,g,h,i){h.blocks=new Array;for(var j=new a.Vector3((c.x-b.x)/2,(c.y-b.y)/2,(c.z-b.z)/2),k=0;2>k;k++)for(var l=0;2>l;l++)for(var m=0;2>m;m++){var n=b.add(j.multiplyByFloats(k,l,m)),o=b.add(j.multiplyByFloats(k+1,l+1,m+1)),p=new a.OctreeBlock(n,o,e,f+1,g,i);p.addEntries(d),h.blocks.push(p)}},b.CreationFuncForMeshes=function(a,b){a.getBoundingInfo().boundingBox.intersectsMinMax(b.minPoint,b.maxPoint)&&b.entries.push(a)},b.CreationFuncForSubMeshes=function(a,b){a.getBoundingInfo().boundingBox.intersectsMinMax(b.minPoint,b.maxPoint)&&b.entries.push(a)},b}();a.Octree=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f){this.entries=new Array,this._boundingVectors=new Array,this._capacity=c,this._depth=d,this._maxDepth=e,this._creationFunc=f,this._minPoint=a,this._maxPoint=b,this._boundingVectors.push(a.clone()),this._boundingVectors.push(b.clone()),this._boundingVectors.push(a.clone()),this._boundingVectors[2].x=b.x,this._boundingVectors.push(a.clone()),this._boundingVectors[3].y=b.y,this._boundingVectors.push(a.clone()),this._boundingVectors[4].z=b.z,this._boundingVectors.push(b.clone()),this._boundingVectors[5].z=a.z,this._boundingVectors.push(b.clone()),this._boundingVectors[6].x=a.x,this._boundingVectors.push(b.clone()),this._boundingVectors[7].y=a.y}return Object.defineProperty(b.prototype,"capacity",{get:function(){return this._capacity},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"minPoint",{get:function(){return this._minPoint},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"maxPoint",{get:function(){return this._maxPoint},enumerable:!0,configurable:!0}),b.prototype.addEntry=function(a){if(this.blocks)for(var b=0;b<this.blocks.length;b++){var c=this.blocks[b];c.addEntry(a)}else this._creationFunc(a,this),this.entries.length>this.capacity&&this._depth<this._maxDepth&&this.createInnerBlocks()},b.prototype.addEntries=function(a){for(var b=0;b<a.length;b++){var c=a[b];this.addEntry(c)}},b.prototype.select=function(b,c,d){if(a.BoundingBox.IsInFrustum(this._boundingVectors,b)){if(this.blocks){for(var e=0;e<this.blocks.length;e++){var f=this.blocks[e];f.select(b,c,d)}return}d?c.concat(this.entries):c.concatWithNoDuplicate(this.entries)}},b.prototype.intersects=function(b,c,d,e){if(a.BoundingBox.IntersectsSphere(this._minPoint,this._maxPoint,b,c)){if(this.blocks){for(var f=0;f<this.blocks.length;f++){var g=this.blocks[f];g.intersects(b,c,d,e)}return}e?d.concat(this.entries):d.concatWithNoDuplicate(this.entries)}},b.prototype.intersectsRay=function(a,b){if(a.intersectsBoxMinMax(this._minPoint,this._maxPoint)){if(this.blocks){for(var c=0;c<this.blocks.length;c++){var d=this.blocks[c];d.intersectsRay(a,b)}return}b.concatWithNoDuplicate(this.entries)}},b.prototype.createInnerBlocks=function(){a.Octree._CreateBlocks(this._minPoint,this._maxPoint,this.entries,this._capacity,this._depth,this._maxDepth,this,this._creationFunc)},b}();a.OctreeBlock=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e){this.name=b,this.children=new Array,this.animations=new Array,this._worldTransform=new a.Matrix,this._absoluteTransform=new a.Matrix,this._invertedAbsoluteTransform=new a.Matrix,this._skeleton=c,this._matrix=e,this._baseMatrix=e,c.bones.push(this),d?(this._parent=d,d.children.push(this)):this._parent=null,this._updateDifferenceMatrix()}return b.prototype.getParent=function(){return this._parent},b.prototype.getLocalMatrix=function(){return this._matrix},b.prototype.getBaseMatrix=function(){return this._baseMatrix},b.prototype.getWorldMatrix=function(){return this._worldTransform},b.prototype.getInvertedAbsoluteTransform=function(){return this._invertedAbsoluteTransform},b.prototype.getAbsoluteMatrix=function(){for(var a=this._matrix.clone(),b=this._parent;b;)a=a.multiply(b.getLocalMatrix()),b=b.getParent();return a},b.prototype.updateMatrix=function(a){this._matrix=a,this._skeleton._markAsDirty(),this._updateDifferenceMatrix()},b.prototype._updateDifferenceMatrix=function(){this._parent?this._matrix.multiplyToRef(this._parent._absoluteTransform,this._absoluteTransform):this._absoluteTransform.copyFrom(this._matrix),this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);for(var a=0;a<this.children.length;a++)this.children[a]._updateDifferenceMatrix()},b.prototype.markAsDirty=function(){this._skeleton._markAsDirty()},b}();a.Bone=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d){this.name=b,this.id=c,this.bones=new Array,this._isDirty=!0,this._identity=a.Matrix.Identity(),this.bones=[],this._scene=d,d.skeletons.push(this)}return b.prototype.getTransformMatrices=function(){return this._transformMatrices},b.prototype._markAsDirty=function(){this._isDirty=!0},b.prototype.prepare=function(){if(this._isDirty){this._transformMatrices&&this._transformMatrices.length===16*(this.bones.length+1)||(this._transformMatrices=new Float32Array(16*(this.bones.length+1)));for(var a=0;a<this.bones.length;a++){var b=this.bones[a],c=b.getParent();c?b.getLocalMatrix().multiplyToRef(c.getWorldMatrix(),b.getWorldMatrix()):b.getWorldMatrix().copyFrom(b.getLocalMatrix()),b.getInvertedAbsoluteTransform().multiplyToArray(b.getWorldMatrix(),this._transformMatrices,16*a)}this._identity.copyToArray(this._transformMatrices,16*this.bones.length),this._isDirty=!1}},b.prototype.getAnimatables=function(){if(!this._animatables||this._animatables.length!=this.bones.length){this._animatables=[];for(var a=0;a<this.bones.length;a++)this._animatables.push(this.bones[a])}return this._animatables},b.prototype.clone=function(b,c){for(var d=new a.Skeleton(b,c||b,this._scene),e=0;e<this.bones.length;e++){var f=this.bones[e],g=null;if(f.getParent()){var h=this.bones.indexOf(f.getParent());g=d.bones[h]}var i=new a.Bone(f.name,d,g,f.getBaseMatrix());a.Tools.DeepCopy(f.animations,i.animations)}return d},b}();a.Skeleton=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g,h,i,j){this.name=b,this.width=-1,this.height=-1,this._reusable=!1,this._textures=new a.SmartArray(2),this._currentRenderTextureInd=0,null!=g?(this._camera=g,this._scene=g.getScene(),g.attachPostProcess(this),this._engine=this._scene.getEngine()):this._engine=i,this._renderRatio=f,this.renderTargetSamplingMode=h?h:a.Texture.NEAREST_SAMPLINGMODE,this._reusable=j||!1,e=e||[],e.push("textureSampler"),this._effect=this._engine.createEffect({vertex:"postprocess",fragment:c},["position"],d||[],e,"")}return b.prototype.isReusable=function(){return this._reusable},b.prototype.activate=function(a,b){a=a||this._camera;var c=a.getScene(),d=(b?b._width:this._engine.getRenderingCanvas().width)*this._renderRatio,e=(b?b._height:this._engine.getRenderingCanvas().height)*this._renderRatio;if(this.width!==d||this.height!==e){if(this._textures.length>0){for(var f=0;f<this._textures.length;f++)this._engine._releaseTexture(this._textures.data[f]);this._textures.reset()}this.width=d,this.height=e,this._textures.push(this._engine.createRenderTargetTexture({width:this.width,height:this.height},{generateMipMaps:!1,generateDepthBuffer:a._postProcesses.indexOf(this)===a._postProcessesTakenIndices[0],samplingMode:this.renderTargetSamplingMode})),this._reusable&&this._textures.push(this._engine.createRenderTargetTexture({width:this.width,height:this.height},{generateMipMaps:!1,generateDepthBuffer:a._postProcesses.indexOf(this)===a._postProcessesTakenIndices[0],samplingMode:this.renderTargetSamplingMode})),this.onSizeChanged&&this.onSizeChanged()}this._engine.bindFramebuffer(this._textures.data[this._currentRenderTextureInd]),this.onActivate&&this.onActivate(a),this._engine.clear(c.clearColor,c.autoClear||c.forceWireframe,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2)},b.prototype.apply=function(){return this._effect.isReady()?(this._engine.enableEffect(this._effect),this._engine.setState(!1),this._engine.setAlphaMode(a.Engine.ALPHA_DISABLE),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._effect._bindTexture("textureSampler",this._textures.data[this._currentRenderTextureInd]),this.onApply&&this.onApply(this._effect),this._effect):null},b.prototype.dispose=function(a){if(a=a||this._camera,this._textures.length>0){for(var b=0;b<this._textures.length;b++)this._engine._releaseTexture(this._textures.data[b]);this._textures.reset()}a.detachPostProcess(this);var c=a._postProcesses.indexOf(this);c===a._postProcessesTakenIndices[0]&&a._postProcessesTakenIndices.length>0&&(this._camera._postProcesses[a._postProcessesTakenIndices[0]].width=-1)},b}();a.PostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a){this._vertexDeclaration=[2],this._vertexStrideSize=8,this._scene=a;var b=[];b.push(1,1),b.push(-1,1),b.push(-1,-1),b.push(1,-1),this._vertexBuffer=a.getEngine().createVertexBuffer(b);var c=[];c.push(0),c.push(1),c.push(2),c.push(0),c.push(2),c.push(3),this._indexBuffer=a.getEngine().createIndexBuffer(c)}return a.prototype._prepareFrame=function(a){var b=this._scene.activeCamera._postProcesses,c=this._scene.activeCamera._postProcessesTakenIndices;return 0!==c.length&&this._scene.postProcessesEnabled?(b[this._scene.activeCamera._postProcessesTakenIndices[0]].activate(this._scene.activeCamera,a),!0):!1},a.prototype._finalizeFrame=function(a,b){var c=this._scene.activeCamera._postProcesses,d=this._scene.activeCamera._postProcessesTakenIndices;if(0!==d.length&&this._scene.postProcessesEnabled){for(var e=this._scene.getEngine(),f=0;f<d.length&&(f<d.length-1?c[d[f+1]].activate(this._scene.activeCamera):b?e.bindFramebuffer(b):e.restoreDefaultFramebuffer(),!a);f++){var g=c[d[f]].apply();g&&(e.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,g),e.draw(!0,0,6))}e.setDepthBuffer(!0),e.setDepthWrite(!0)}},a.prototype.dispose=function(){this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)},a}();a.PostProcessManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"pass",null,null,c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.PassPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i,j){"undefined"==typeof h&&(h=a.Texture.BILINEAR_SAMPLINGMODE);var k=this;b.call(this,c,"blur",["screenSize","direction","blurWidth"],null,f,g,h,i,j),this.direction=d,this.blurWidth=e,this.onApply=function(a){a.setFloat2("screenSize",k.width,k.height),a.setVector2("direction",k.direction),a.setFloat("blurWidth",k.blurWidth)}}return __extends(c,b),c}(a.PostProcess);a.BlurPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g,h){var i=this;a.call(this,b,"filter",["kernelMatrix"],null,d,e,f,g,h),this.kernelMatrix=c,this.onApply=function(a){a.setMatrix("kernelMatrix",i.kernelMatrix)}}return __extends(b,a),b}(a.PostProcess);a.FilterPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f,g,h,i,j,k,l){var m=this;b.call(this,c,"refraction",["baseColor","depth","colorLevel"],["refractionSampler"],h,i,j,k,l),this.color=e,this.depth=f,this.colorLevel=g,this.onActivate=function(b){m._refRexture=m._refRexture||new a.Texture(d,b.getScene())},this.onApply=function(a){a.setColor3("baseColor",m.color),a.setFloat("depth",m.depth),a.setFloat("colorLevel",m.colorLevel),a.setTexture("refractionSampler",m._refRexture)}}return __extends(c,b),c.prototype.dispose=function(a){this._refRexture&&this._refRexture.dispose(),b.prototype.dispose.call(this,a)},c}(a.PostProcess);a.RefractionPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"blackAndWhite",null,null,c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.BlackAndWhitePostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g,h){var i=this;a.call(this,b,"convolution",["kernel","screenSize"],null,d,e,f,g,h),this.kernel=c,this.onApply=function(a){a.setFloat2("screenSize",i.width,i.height),a.setArray("kernel",i.kernel)}}return __extends(b,a),b.EdgeDetect0Kernel=[1,0,-1,0,0,0,-1,0,1],b.EdgeDetect1Kernel=[0,1,0,1,-4,1,0,1,0],b.EdgeDetect2Kernel=[-1,-1,-1,-1,8,-1,-1,-1,-1],b.SharpenKernel=[0,-1,0,-1,5,-1,0,-1,0],b.EmbossKernel=[-2,-1,0,-1,1,1,0,1,2],b.GaussianKernel=[0,1,0,1,1,1,0,1,0],b}(a.PostProcess);a.ConvolutionPostProcess=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){var h=this;a.call(this,b,"fxaa",["texelSize"],null,c,d,e,f,g),this.onSizeChanged=function(){h.texelWidth=1/h.width,h.texelHeight=1/h.height},this.onApply=function(a){a.setFloat2("texelSize",h.texelWidth,h.texelHeight)}}return __extends(b,a),b}(a.PostProcess);a.FxaaPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.size=b,this.position=c,this.dispose=function(){this.texture&&this.texture.dispose();var a=this._system.lensFlares.indexOf(this);this._system.lensFlares.splice(a,1)},this.color=d||new a.Color3(1,1,1),this.texture=e?new a.Texture(e,f.getScene(),!0):null,this._system=f,f.lensFlares.push(this)}return b}();a.LensFlare=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c){this.name=a,this.lensFlares=new Array,this.borderLimit=300,this._vertexDeclaration=[2],this._vertexStrideSize=8,this._isEnabled=!0,this._scene=c,this._emitter=b,c.lensFlareSystems.push(this),this.meshesSelectionPredicate=function(a){return a.material&&a.isVisible&&a.isEnabled()&&a.checkCollisions&&0!=(a.layerMask&c.activeCamera.layerMask)};var d=[];d.push(1,1),d.push(-1,1),d.push(-1,-1),d.push(1,-1),this._vertexBuffer=c.getEngine().createVertexBuffer(d);var e=[];e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),this._indexBuffer=c.getEngine().createIndexBuffer(e),this._effect=this._scene.getEngine().createEffect("lensFlare",["position"],["color","viewportMatrix"],["textureSampler"],"")}return Object.defineProperty(b.prototype,"isEnabled",{get:function(){return this._isEnabled},set:function(a){this._isEnabled=a},enumerable:!0,configurable:!0}),b.prototype.getScene=function(){return this._scene},b.prototype.getEmitter=function(){return this._emitter},b.prototype.getEmitterPosition=function(){return this._emitter.getAbsolutePosition?this._emitter.getAbsolutePosition():this._emitter.position},b.prototype.computeEffectivePosition=function(b){var c=this.getEmitterPosition();return c=a.Vector3.Project(c,a.Matrix.Identity(),this._scene.getTransformMatrix(),b),this._positionX=c.x,this._positionY=c.y,c=a.Vector3.TransformCoordinates(this.getEmitterPosition(),this._scene.getViewMatrix()),c.z>0&&this._positionX>b.x&&this._positionX<b.x+b.width&&this._positionY>b.y&&this._positionY<b.y+b.height?!0:!1},b.prototype._isVisible=function(){if(!this._isEnabled)return!1;var b=this.getEmitterPosition(),c=b.subtract(this._scene.activeCamera.position),d=c.length();c.normalize();var e=new a.Ray(this._scene.activeCamera.position,c),f=this._scene.pickWithRay(e,this.meshesSelectionPredicate,!0);return!f.hit||f.distance>d},b.prototype.render=function(){if(!this._effect.isReady())return!1;var b=this._scene.getEngine(),c=this._scene.activeCamera.viewport,d=c.toGlobal(b);if(!this.computeEffectivePosition(d))return!1;if(!this._isVisible())return!1;var e,f;e=this._positionX<this.borderLimit+d.x?this.borderLimit+d.x-this._positionX:this._positionX>d.x+d.width-this.borderLimit?this._positionX-d.x-d.width+this.borderLimit:0,f=this._positionY<this.borderLimit+d.y?this.borderLimit+d.y-this._positionY:this._positionY>d.y+d.height-this.borderLimit?this._positionY-d.y-d.height+this.borderLimit:0;var g=e>f?e:f;g>this.borderLimit&&(g=this.borderLimit);var h=1-g/this.borderLimit;if(0>h)return!1;h>1&&(h=1);var i=d.x+d.width/2,j=d.y+d.height/2,k=i-this._positionX,l=j-this._positionY;b.enableEffect(this._effect),b.setState(!1),b.setDepthBuffer(!1),b.setAlphaMode(a.Engine.ALPHA_ADD),b.bindBuffers(this._vertexBuffer,this._indexBuffer,this._vertexDeclaration,this._vertexStrideSize,this._effect);for(var m=0;m<this.lensFlares.length;m++){var n=this.lensFlares[m],o=i-k*n.position,p=j-l*n.position,q=n.size,r=n.size*b.getAspectRatio(this._scene.activeCamera),s=2*(o/d.width)-1,t=1-2*(p/d.height),u=a.Matrix.FromValues(q/2,0,0,0,0,r/2,0,0,0,0,1,0,s,t,0,1);this._effect.setMatrix("viewportMatrix",u),this._effect.setTexture("textureSampler",n.texture),this._effect.setFloat4("color",n.color.r*h,n.color.g*h,n.color.b*h,1),b.draw(!0,0,6)
}return b.setDepthBuffer(!0),b.setAlphaMode(a.Engine.ALPHA_DISABLE),!0},b.prototype.dispose=function(){for(this._vertexBuffer&&(this._scene.getEngine()._releaseBuffer(this._vertexBuffer),this._vertexBuffer=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null);this.lensFlares.length;)this.lensFlares[0].dispose();var a=this._scene.lensFlareSystems.indexOf(this);this._scene.lensFlareSystems.splice(a,1)},b}();a.LensFlareSystem=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c){this.bu=a,this.bv=b,this.distance=c,this.faceId=0}return a}();a.IntersectionInfo=b;var c=function(){function b(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1}return b.prototype.getNormal=function(){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(a.VertexBuffer.NormalKind))return null;var b=this.pickedMesh.getIndices(),c=this.pickedMesh.getVerticesData(a.VertexBuffer.NormalKind),d=a.Vector3.FromArray(c,3*b[3*this.faceId]),e=a.Vector3.FromArray(c,3*b[3*this.faceId+1]),f=a.Vector3.FromArray(c,3*b[3*this.faceId+2]);return d=d.scale(this.bu),e=e.scale(this.bv),f=f.scale(1-this.bu-this.bv),new a.Vector3(d.x+e.x+f.x,d.y+e.y+f.y,d.z+e.z+f.z)},b.prototype.getTextureCoordinates=function(){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(a.VertexBuffer.UVKind))return null;var b=this.pickedMesh.getIndices(),c=this.pickedMesh.getVerticesData(a.VertexBuffer.UVKind),d=a.Vector2.FromArray(c,2*b[3*this.faceId]),e=a.Vector2.FromArray(c,2*b[3*this.faceId+1]),f=a.Vector2.FromArray(c,2*b[3*this.faceId+2]);return d=d.scale(this.bu),e=e.scale(this.bv),f=f.scale(1-this.bu-this.bv),new a.Vector2(d.x+e.x+f.x,d.y+e.y+f.y)},b}();a.PickingInfo=c}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f,g,h){this.engine=a,this.canvas=c,this.currentScene=b,this.sceneLoadedCallback=d,this.progressCallback=e,this.additionnalRenderLoopLogicCallback=f,this.textureLoadingCallback=g,this.startingProcessingFilesCallback=h}return b.prototype.monitorElementForDragNDrop=function(a){var b=this;a&&(this.elementToMonitor=a,this.elementToMonitor.addEventListener("dragenter",function(a){b.drag(a)},!1),this.elementToMonitor.addEventListener("dragover",function(a){b.drag(a)},!1),this.elementToMonitor.addEventListener("drop",function(a){b.drop(a)},!1))},b.prototype.renderFunction=function(){if(this.additionnalRenderLoopLogicCallback&&this.additionnalRenderLoopLogicCallback(),this.currentScene){if(this.textureLoadingCallback){var a=this.currentScene.getWaitingItemsCount();a>0&&this.textureLoadingCallback(a)}this.currentScene.render()}},b.prototype.drag=function(a){a.stopPropagation(),a.preventDefault()},b.prototype.drop=function(a){a.stopPropagation(),a.preventDefault(),this.loadFiles(a)},b.prototype.loadFiles=function(b){var c=this,d=this;this.startingProcessingFilesCallback&&this.startingProcessingFilesCallback();var e,f;if(b&&b.dataTransfer&&b.dataTransfer.files&&(f=b.dataTransfer.files),b&&b.target&&b.target.files&&(f=b.target.files),f&&f.length>0){for(var g=0;g<f.length;g++)switch(f[g].type){case"image/jpeg":case"image/png":a.FilesInput.FilesTextures[f[g].name]=f[g];break;case"image/targa":case"image/vnd.ms-dds":a.FilesInput.FilesToLoad[f[g].name]=f[g];break;default:-1!==f[g].name.indexOf(".babylon")&&-1===f[g].name.indexOf(".manifest")&&-1===f[g].name.indexOf(".incremental")&&-1===f[g].name.indexOf(".babylonmeshdata")&&-1===f[g].name.indexOf(".babylongeometrydata")&&(e=f[g])}e?(this.currentScene&&(this.engine.stopRenderLoop(),this.currentScene.dispose()),a.SceneLoader.Load("file:",e,this.engine,function(a){d.currentScene=a,d.currentScene.executeWhenReady(function(){d.currentScene.activeCamera&&d.currentScene.activeCamera.attachControl(d.canvas),d.sceneLoadedCallback&&d.sceneLoadedCallback(e,d.currentScene),d.engine.runRenderLoop(function(){d.renderFunction()})})},function(a){c.progressCallback&&c.progressCallback(a)})):a.Tools.Error("Please provide a valid .babylon file.")}},b.FilesTextures=new Array,b.FilesToLoad=new Array,b}();a.FilesInput=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this._registeredMeshes=[],this.updateBodyPosition=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent){var d=c.body.body;return d.setPosition(a.position.x,a.position.y,a.position.z),void d.setOrientation(a.rotation.x,a.rotation.y,a.rotation.z)}if(c.mesh.parent===a){a.computeWorldMatrix(!0),c.mesh.computeWorldMatrix(!0);var e=c.mesh.getAbsolutePosition(),f=a.rotation;return d=c.body.body,d.setPosition(e.x,e.y,e.z),void d.setOrientation(f.x,f.y,f.z)}}}}return b.prototype._checkWithEpsilon=function(b){return b<a.PhysicsEngine.Epsilon?a.PhysicsEngine.Epsilon:b},b.prototype.initialize=function(){this._world=new OIMO.World,this._world.clear()},b.prototype.setGravity=function(a){this._world.gravity=a},b.prototype.registerMesh=function(b,c,d){var e=null;switch(this.unregisterMesh(b),b.computeWorldMatrix(!0),c){case a.PhysicsEngine.SphereImpostor:var f=b.getBoundingInfo().boundingBox,g=f.maximumWorld.x-f.minimumWorld.x,h=f.maximumWorld.y-f.minimumWorld.y,i=f.maximumWorld.z-f.minimumWorld.z,j=Math.max(this._checkWithEpsilon(g),this._checkWithEpsilon(h),this._checkWithEpsilon(i))/2;e=new OIMO.Body({type:"sphere",size:[j],pos:[b.position.x,b.position.y,b.position.z],rot:[b.rotation.x/OIMO.TO_RAD,b.rotation.y/OIMO.TO_RAD,b.rotation.z/OIMO.TO_RAD],move:0!=d.mass,config:[d.mass,d.friction,d.restitution],world:this._world}),this._registeredMeshes.push({mesh:b,body:e});break;case a.PhysicsEngine.PlaneImpostor:case a.PhysicsEngine.BoxImpostor:f=b.getBoundingInfo().boundingBox;var k=f.minimumWorld,l=f.maximumWorld,m=l.subtract(k),n=this._checkWithEpsilon(m.x),o=this._checkWithEpsilon(m.y),p=this._checkWithEpsilon(m.z);e=new OIMO.Body({type:"box",size:[n,o,p],pos:[b.position.x,b.position.y,b.position.z],rot:[b.rotation.x/OIMO.TO_RAD,b.rotation.y/OIMO.TO_RAD,b.rotation.z/OIMO.TO_RAD],move:0!=d.mass,config:[d.mass,d.friction,d.restitution],world:this._world}),this._registeredMeshes.push({mesh:b,body:e})}return e},b.prototype.registerMeshesAsCompound=function(a,b){for(var c=[],d=[],e=[],f=[],g=a[0].mesh,h=0;h<a.length;h++){var i=a[h],j=this._createBodyAsCompound(i,b,g);c.push(j.type),d.push.apply(d,j.size),e.push.apply(e,j.pos),f.push.apply(f,j.rot)}var k=new OIMO.Body({type:c,size:d,pos:e,rot:f,move:0!=b.mass,config:[b.mass,b.friction,b.restitution],world:this._world});return this._registeredMeshes.push({mesh:g,body:k}),k},b.prototype._createBodyAsCompound=function(b){var c=null,d=b.mesh;switch(b.impostor){case a.PhysicsEngine.SphereImpostor:var e=d.getBoundingInfo().boundingBox,f=e.maximumWorld.x-e.minimumWorld.x,g=e.maximumWorld.y-e.minimumWorld.y,h=e.maximumWorld.z-e.minimumWorld.z,i=Math.max(this._checkWithEpsilon(f),this._checkWithEpsilon(g),this._checkWithEpsilon(h))/2;c={type:"sphere",size:[i,-1,-1],pos:[d.position.x,d.position.y,d.position.z],rot:[d.rotation.x/OIMO.TO_RAD,d.rotation.y/OIMO.TO_RAD,d.rotation.z/OIMO.TO_RAD]};break;case a.PhysicsEngine.PlaneImpostor:case a.PhysicsEngine.BoxImpostor:e=d.getBoundingInfo().boundingBox;var j=e.minimumWorld,k=e.maximumWorld,l=k.subtract(j),m=this._checkWithEpsilon(l.x),n=this._checkWithEpsilon(l.y),o=this._checkWithEpsilon(l.z),p=d.position;c={type:"box",size:[m,n,o],pos:[p.x,p.y,p.z],rot:[d.rotation.x/OIMO.TO_RAD,d.rotation.y/OIMO.TO_RAD,d.rotation.z/OIMO.TO_RAD]}}return c},b.prototype.unregisterMesh=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent)return c.body&&(this._world.removeRigidBody(c.body.body),this._unbindBody(c.body)),void this._registeredMeshes.splice(b,1)}},b.prototype._unbindBody=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];c.body===a&&(c.body=null)}},b.prototype.applyImpulse=function(a,b,c){for(var d=0;d<this._registeredMeshes.length;d++){var e=this._registeredMeshes[d];if(e.mesh===a||e.mesh===a.parent)return void e.body.body.applyImpulse(c.scale(OIMO.INV_SCALE),b.scale(OIMO.INV_SCALE))}},b.prototype.createLink=function(a,b,c,d,e){for(var f=null,g=null,h=0;h<this._registeredMeshes.length;h++){var i=this._registeredMeshes[h];i.mesh===a?f=i.body.body:i.mesh===b&&(g=i.body.body)}return f&&g?(e||(e={}),new OIMO.Link({type:e.type,body1:f,body2:g,min:e.min,max:e.max,axe1:e.axe1,axe2:e.axe2,pos1:[c.x,c.y,c.z],pos2:[d.x,d.y,d.z],collision:e.collision,spring:e.spring,world:this._world}),!0):!1},b.prototype.dispose=function(){for(this._world.clear();this._registeredMeshes.length;)this.unregisterMesh(this._registeredMeshes[0].mesh)},b.prototype.isSupported=function(){return void 0!==OIMO},b.prototype._getLastShape=function(a){for(var b=a.shapes;b.next;)b=b.next;return b},b.prototype.runOneStep=function(){this._world.step();for(var b,c=this._registeredMeshes.length;c--;){var d=this._registeredMeshes[c].body.body,e=this._registeredMeshes[c].mesh;if(!d.sleeping)if(d.shapes.next){var f=this._getLastShape(d);e.position.x=f.position.x*OIMO.WORLD_SCALE,e.position.y=f.position.y*OIMO.WORLD_SCALE,e.position.z=f.position.z*OIMO.WORLD_SCALE;var g=a.Matrix.FromArray(d.getMatrix());e.rotationQuaternion||(e.rotationQuaternion=new a.Quaternion(0,0,0,1)),e.rotationQuaternion.fromRotationMatrix(g)}else b=d.getMatrix(),g=a.Matrix.FromArray(b),e.position.x=g.m[12],e.position.y=g.m[13],e.position.z=g.m[14],e.rotationQuaternion||(e.rotationQuaternion=new a.Quaternion(0,0,0,1)),e.rotationQuaternion.fromRotationMatrix(g)}},b}();a.OimoJSPlugin=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this._currentPlugin=b||new a.OimoJSPlugin}return b.prototype._initialize=function(a){this._currentPlugin.initialize(),this._setGravity(a)},b.prototype._runOneStep=function(a){a>.1?a=.1:0>=a&&(a=1/60),this._currentPlugin.runOneStep(a)},b.prototype._setGravity=function(b){this.gravity=b||new a.Vector3(0,-9.82,0),this._currentPlugin.setGravity(this.gravity)},b.prototype._registerMesh=function(a,b,c){return this._currentPlugin.registerMesh(a,b,c)},b.prototype._registerMeshesAsCompound=function(a,b){return this._currentPlugin.registerMeshesAsCompound(a,b)},b.prototype._unregisterMesh=function(a){this._currentPlugin.unregisterMesh(a)},b.prototype._applyImpulse=function(a,b,c){this._currentPlugin.applyImpulse(a,b,c)},b.prototype._createLink=function(a,b,c,d,e){return this._currentPlugin.createLink(a,b,c,d,e)},b.prototype._updateBodyPosition=function(a){this._currentPlugin.updateBodyPosition(a)},b.prototype.dispose=function(){this._currentPlugin.dispose()},b.prototype.isSupported=function(){return this._currentPlugin.isSupported()},b.NoImpostor=0,b.SphereImpostor=1,b.BoxImpostor=2,b.PlaneImpostor=3,b.CompoundImpostor=4,b.MeshImpostor=4,b.CapsuleImpostor=5,b.ConeImpostor=6,b.CylinderImpostor=7,b.ConvexHullImpostor=8,b.Epsilon=.001,b}();a.PhysicsEngine=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(b){var c={};if(c.name=b.name,c.id=b.id,c.tags=a.Tags.GetTags(b),b instanceof a.PointLight)c.type=0,c.position=b.position.asArray();else if(b instanceof a.DirectionalLight){c.type=1;var d=b;c.position=d.position.asArray(),c.direction=d.direction.asArray()}else if(b instanceof a.SpotLight){c.type=2;var e=b;c.position=e.position.asArray(),c.direction=e.position.asArray(),c.angle=e.angle,c.exponent=e.exponent}else if(b instanceof a.HemisphericLight){c.type=3;var f=b;c.direction=f.direction.asArray(),c.groundColor=f.groundColor.asArray()}return b.intensity&&(c.intensity=b.intensity),c.range=b.range,c.diffuse=b.diffuse.asArray(),c.specular=b.specular.asArray(),c},c=function(b){var c={};return c.name=b.name,c.tags=a.Tags.GetTags(b),c.id=b.id,c.position=b.position.asArray(),b.parent&&(c.parentId=b.parent.id),c.rotation=b.rotation.asArray(),b.lockedTarget&&b.lockedTarget.id&&(c.lockedTargetId=b.lockedTarget.id),c.fov=b.fov,c.minZ=b.minZ,c.maxZ=b.maxZ,c.speed=b.speed,c.inertia=b.inertia,c.checkCollisions=b.checkCollisions,c.applyGravity=b.applyGravity,b.ellipsoid&&(c.ellipsoid=b.ellipsoid.asArray()),d(b,c),c.layerMask=b.layerMask,c},d=function(a,b){if(a.animations){b.animations=[];for(var c=0;c<a.animations.length;c++){var d=a.animations[c];b.animations.push(e(d))}}},e=function(b){var c={};c.name=b.name,c.property=b.targetProperty,c.framePerSecond=b.framePerSecond,c.dataType=b.dataType,c.loopBehavior=b.loopMode;var d=b.dataType;c.keys=[];for(var e=b.getKeys(),f=0;f<e.length;f++){var g=e[f],h={};switch(h.frame=g.frame,d){case a.Animation.ANIMATIONTYPE_FLOAT:h.values=[g.value];break;case a.Animation.ANIMATIONTYPE_QUATERNION:case a.Animation.ANIMATIONTYPE_MATRIX:case a.Animation.ANIMATIONTYPE_VECTOR3:h.values=g.value.asArray()}c.keys.push(h)}return c},f=function(b){var c={};c.name=b.name,c.id=b.id,c.tags=a.Tags.GetTags(b),c.materials=[];for(var d=0;d<b.subMaterials.length;d++){var e=b.subMaterials[d];c.materials.push(e?e.id:null)}return c},g=function(b){var c={};return c.name=b.name,c.ambient=b.ambientColor.asArray(),c.diffuse=b.diffuseColor.asArray(),c.specular=b.specularColor.asArray(),c.specularPower=b.specularPower,c.emissive=b.emissiveColor.asArray(),c.alpha=b.alpha,c.id=b.id,c.tags=a.Tags.GetTags(b),c.backFaceCulling=b.backFaceCulling,b.diffuseTexture&&(c.diffuseTexture=h(b.diffuseTexture)),b.ambientTexture&&(c.ambientTexture=h(b.ambientTexture)),b.opacityTexture&&(c.opacityTexture=h(b.opacityTexture)),b.reflectionTexture&&(c.reflectionTexture=h(b.reflectionTexture)),b.emissiveTexture&&(c.emissiveTexture=h(b.emissiveTexture)),b.specularTexture&&(c.specularTexture=h(b.specularTexture)),b.bumpTexture&&(c.bumpTexture=h(b.bumpTexture)),c},h=function(b){var c={};if(!b.name)return null;if(b instanceof a.CubeTexture)return c.name=b.name,c.hasAlpha=b.hasAlpha,c.level=b.level,c.coordinatesMode=b.coordinatesMode,c;if(b instanceof a.MirrorTexture){var e=b;c.renderTargetSize=e.getRenderSize(),c.renderList=[];for(var f=0;f<e.renderList.length;f++)c.renderList.push(e.renderList[f].id);c.mirrorPlane=e.mirrorPlane.asArray()}else if(b instanceof a.RenderTargetTexture){var g=b;for(c.renderTargetSize=g.getRenderSize(),c.renderList=[],f=0;f<g.renderList.length;f++)c.renderList.push(g.renderList[f].id)}var h=b;return c.name=b.name,c.hasAlpha=b.hasAlpha,c.level=b.level,c.coordinatesIndex=b.coordinatesIndex,c.coordinatesMode=b.coordinatesMode,c.uOffset=h.uOffset,c.vOffset=h.vOffset,c.uScale=h.uScale,c.vScale=h.vScale,c.uAng=h.uAng,c.vAng=h.vAng,c.wAng=h.wAng,c.wrapU=b.wrapU,c.wrapV=b.wrapV,d(b,c),c},i=function(a){var b={};b.name=a.name,b.id=a.id,b.bones=[];for(var c=0;c<a.bones.length;c++){var d=a.bones[c],f={parentBoneIndex:d.getParent()?a.bones.indexOf(d.getParent()):-1,name:d.name,matrix:d.getLocalMatrix().toArray()};b.bones.push(f),d.animations&&d.animations.length>0&&(f.animation=e(d.animations[0]))}return b},j=function(a){var b={};return b.emitterId=a.emitter.id,b.capacity=a.getCapacity(),a.particleTexture&&(b.textureName=a.particleTexture.name),b.minAngularSpeed=a.minAngularSpeed,b.maxAngularSpeed=a.maxAngularSpeed,b.minSize=a.minSize,b.maxSize=a.maxSize,b.minLifeTime=a.minLifeTime,b.maxLifeTime=a.maxLifeTime,b.emitRate=a.emitRate,b.minEmitBox=a.minEmitBox.asArray(),b.maxEmitBox=a.maxEmitBox.asArray(),b.gravity=a.gravity.asArray(),b.direction1=a.direction1.asArray(),b.direction2=a.direction2.asArray(),b.color1=a.color1.asArray(),b.color2=a.color2.asArray(),b.colorDead=a.colorDead.asArray(),b.updateSpeed=a.updateSpeed,b.targetStopDuration=a.targetStopDuration,b.textureMask=a.textureMask.asArray(),b.blendMode=a.blendMode,b},k=function(b){var c={};c.emitterId=b.getEmitter().id,c.borderLimit=b.borderLimit,c.flares=[];for(var d=0;d<b.lensFlares.length;d++){var e=b.lensFlares[d];c.flares.push({size:e.size,position:e.position,color:e.color.asArray(),textureName:a.Tools.GetFilename(e.texture.name)})}return c},l=function(a){var b={},c=a.getShadowGenerator();b.lightId=a.id,b.mapSize=c.getShadowMap().getRenderSize(),b.useVarianceShadowMap=c.useVarianceShadowMap,b.usePoissonSampling=c.usePoissonSampling,b.renderList=[];for(var d=0;d<c.getShadowMap().renderList.length;d++){var e=c.getShadowMap().renderList[d];b.renderList.push(e.id)}return b},m=[],n=function(b,c){if(!m[b.id]){if(b instanceof a.Geometry.Primitives.Box)c.boxes.push(r(b));else if(b instanceof a.Geometry.Primitives.Sphere)c.spheres.push(s(b));else if(b instanceof a.Geometry.Primitives.Cylinder)c.cylinders.push(t(b));else if(b instanceof a.Geometry.Primitives.Torus)c.toruses.push(u(b));else if(b instanceof a.Geometry.Primitives.Ground)c.grounds.push(v(b));else if(b instanceof a.Geometry.Primitives.Plane)c.planes.push(w(b));else if(b instanceof a.Geometry.Primitives.TorusKnot)c.torusKnots.push(x(b));else{if(b instanceof a.Geometry.Primitives._Primitive)throw new Error("Unknow primitive type");c.vertexData.push(p(b))}m[b.id]=!0}},o=function(b){var c={};return c.id=b.id,a.Tags.HasTags(b)&&(c.tags=a.Tags.GetTags(b)),c},p=function(b){var c=o(b);return b.isVerticesDataPresent(a.VertexBuffer.PositionKind)&&(c.positions=b.getVerticesData(a.VertexBuffer.PositionKind)),b.isVerticesDataPresent(a.VertexBuffer.NormalKind)&&(c.normals=b.getVerticesData(a.VertexBuffer.NormalKind)),b.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(c.uvs=b.getVerticesData(a.VertexBuffer.UVKind)),b.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(c.uvs2=b.getVerticesData(a.VertexBuffer.UV2Kind)),b.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(c.colors=b.getVerticesData(a.VertexBuffer.ColorKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&(c.matricesIndices=b.getVerticesData(a.VertexBuffer.MatricesIndicesKind),c.matricesIndices._isExpanded=!0),b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(c.matricesWeights=b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)),c.indices=b.getIndices(),c},q=function(a){var b=o(a);return b.canBeRegenerated=a.canBeRegenerated(),b},r=function(a){var b=q(a);return b.size=a.size,b},s=function(a){var b=q(a);return b.segments=a.segments,b.diameter=a.diameter,b},t=function(a){var b=q(a);return b.height=a.height,b.diameterTop=a.diameterTop,b.diameterBottom=a.diameterBottom,b.tessellation=a.tessellation,b},u=function(a){var b=q(a);return b.diameter=a.diameter,b.thickness=a.thickness,b.tessellation=a.tessellation,b},v=function(a){var b=q(a);return b.width=a.width,b.height=a.height,b.subdivisions=a.subdivisions,b},w=function(a){var b=q(a);return b.size=a.size,b},x=function(a){var b=q(a);return b.radius=a.radius,b.tube=a.tube,b.radialSegments=a.radialSegments,b.tubularSegments=a.tubularSegments,b.p=a.p,b.q=a.q,b},y=function(b,c){var e={};e.name=b.name,e.id=b.id,a.Tags.HasTags(b)&&(e.tags=a.Tags.GetTags(b)),e.position=b.position.asArray(),b.rotationQuaternion?e.rotationQuaternion=b.rotationQuaternion.asArray():b.rotation&&(e.rotation=b.rotation.asArray()),e.scaling=b.scaling.asArray(),e.localMatrix=b.getPivotMatrix().asArray(),e.isEnabled=b.isEnabled(),e.isVisible=b.isVisible,e.infiniteDistance=b.infiniteDistance,e.pickable=b.isPickable,e.receiveShadows=b.receiveShadows,e.billboardMode=b.billboardMode,e.visibility=b.visibility,e.checkCollisions=b.checkCollisions,b.parent&&(e.parentId=b.parent.id);var f=b._geometry;if(f){var g=f.id;e.geometryId=g,b.getScene().getGeometryByID(g)||n(f,c.geometries),e.subMeshes=[];for(var h=0;h<b.subMeshes.length;h++){var i=b.subMeshes[h];e.subMeshes.push({materialIndex:i.materialIndex,verticesStart:i.verticesStart,verticesCount:i.verticesCount,indexStart:i.indexStart,indexCount:i.indexCount})}}if(b.material?e.materialId=b.material.id:b.material=null,b.skeleton&&(e.skeletonId=b.skeleton.id),b.getPhysicsImpostor()!==a.PhysicsEngine.NoImpostor)switch(e.physicsMass=b.getPhysicsMass(),e.physicsFriction=b.getPhysicsFriction(),e.physicsRestitution=b.getPhysicsRestitution(),b.getPhysicsImpostor()){case a.PhysicsEngine.BoxImpostor:e.physicsImpostor=1;break;case a.PhysicsEngine.SphereImpostor:e.physicsImpostor=2}return d(b,e),e.layerMask=b.layerMask,e},z=function(){function d(){}return d.Serialize=function(d){var e={};e.useDelayedTextureLoading=d.useDelayedTextureLoading,e.autoClear=d.autoClear,e.clearColor=d.clearColor.asArray(),e.ambientColor=d.ambientColor.asArray(),e.gravity=d.gravity.asArray(),d.fogMode&&0!==d.fogMode&&(e.fogMode=d.fogMode,e.fogColor=d.fogColor.asArray(),e.fogStart=d.fogStart,e.fogEnd=d.fogEnd,e.fogDensity=d.fogDensity),e.lights=[];for(var h=0;h<d.lights.length;h++){var o=d.lights[h];e.lights.push(b(o))}for(e.cameras=[],h=0;h<d.cameras.length;h++){var p=d.cameras[h];p instanceof a.FreeCamera&&e.cameras.push(c(p))}for(d.activeCamera&&(e.activeCameraID=d.activeCamera.id),e.materials=[],e.multiMaterials=[],h=0;h<d.materials.length;h++){var q=d.materials[h];q instanceof a.StandardMaterial?e.materials.push(g(q)):q instanceof a.MultiMaterial&&e.multiMaterials.push(f(q))}for(e.skeletons=[],h=0;h<d.skeletons.length;h++)e.skeletons.push(i(d.skeletons[h]));e.geometries={},e.geometries.boxes=[],e.geometries.spheres=[],e.geometries.cylinders=[],e.geometries.toruses=[],e.geometries.grounds=[],e.geometries.planes=[],e.geometries.torusKnots=[],e.geometries.vertexData=[],m=[];for(var r=d.getGeometries(),h=0;h<r.length;h++){var s=r[h];s.isReady()&&n(s,e.geometries)}for(e.meshes=[],h=0;h<d.meshes.length;h++){var t=d.meshes[h];if(t instanceof a.Mesh){var u=t;(u.delayLoadState===a.Engine.DELAYLOADSTATE_LOADED||u.delayLoadState===a.Engine.DELAYLOADSTATE_NONE)&&e.meshes.push(y(u,e))}}for(e.particleSystems=[],h=0;h<d.particleSystems.length;h++)e.particleSystems.push(j(d.particleSystems[h]));for(e.lensFlareSystems=[],h=0;h<d.lensFlareSystems.length;h++)e.lensFlareSystems.push(k(d.lensFlareSystems[h]));for(e.shadowGenerators=[],h=0;h<d.lights.length;h++)o=d.lights[h],o.getShadowGenerator()&&e.shadowGenerators.push(l(o));return e},d}();a.SceneSerializer=z}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return Object.defineProperty(b,"ForceFullSceneLoadingForIncremental",{get:function(){return b._ForceFullSceneLoadingForIncremental},set:function(a){b._ForceFullSceneLoadingForIncremental=a},enumerable:!0,configurable:!0}),b._getPluginForFilename=function(a){for(var b=a.lastIndexOf("."),c=a.substring(b).toLowerCase(),d=0;d<this._registeredPlugins.length;d++){var e=this._registeredPlugins[d];if(-1!==e.extensions.indexOf(c))return e}return this._registeredPlugins[this._registeredPlugins.length-1]},b.RegisterPlugin=function(a){a.extensions=a.extensions.toLowerCase(),b._registeredPlugins.push(a)},b.ImportMesh=function(b,c,d,e,f,g,h){var i=this,j=function(){e.database=k;var j=i._getPluginForFilename(d),l=function(a){var g=[],i=[],k=[];return j.importMesh(b,e,a,c,g,i,k)?void(f&&(e.importedMeshesFiles.push(c+d),f(g,i,k))):void(h&&h(e))};return d.substr&&"data:"===d.substr(0,5)?void l(d.substr(5)):void a.Tools.LoadFile(c+d,function(a){l(a)},g,k)},k=new a.Database(c+d,j)},b.Load=function(b,c,d,e,f,g){var h,i=this._getPluginForFilename(c.name||c),j=function(c){var f=new a.Scene(d);return f.database=h,i.load(f,c,b)?void(e&&e(f)):void(g&&g(f))},k=function(){a.Tools.LoadFile(b+c,j,f,h)};return c.substr&&"data:"===c.substr(0,5)?void j(c.substr(5)):void(-1===b.indexOf("file:")?h=new a.Database(b+c,k):a.Tools.ReadFile(c,j,f))},b._ForceFullSceneLoadingForIncremental=!1,b._registeredPlugins=new Array,b}();a.SceneLoader=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(){var b=function(b,c,d){var e=new a.CubeTexture(b+c.name,d);return e.name=c.name,e.hasAlpha=c.hasAlpha,e.level=c.level,e.coordinatesMode=c.coordinatesMode,e},c=function(c,d,e){if(!d.name&&!d.isRenderTarget)return null;if(d.isCube)return b(c,d,e);var f;if(d.mirrorPlane?(f=new a.MirrorTexture(d.name,d.renderTargetSize,e),f._waitingRenderList=d.renderList,f.mirrorPlane=a.Plane.FromArray(d.mirrorPlane)):d.isRenderTarget?(f=new a.RenderTargetTexture(d.name,d.renderTargetSize,e),f._waitingRenderList=d.renderList):f=new a.Texture(c+d.name,e),f.name=d.name,f.hasAlpha=d.hasAlpha,f.getAlphaFromRGB=d.getAlphaFromRGB,f.level=d.level,f.coordinatesIndex=d.coordinatesIndex,f.coordinatesMode=d.coordinatesMode,f.uOffset=d.uOffset,f.vOffset=d.vOffset,f.uScale=d.uScale,f.vScale=d.vScale,f.uAng=d.uAng,f.vAng=d.vAng,f.wAng=d.wAng,f.wrapU=d.wrapU,f.wrapV=d.wrapV,d.animations)for(var g=0;g<d.animations.length;g++){var h=d.animations[g];f.animations.push(k(h))}return f},d=function(b,c){for(var d=new a.Skeleton(b.name,b.id,c),e=0;e<b.bones.length;e++){var f=b.bones[e],g=null;f.parentBoneIndex>-1&&(g=d.bones[f.parentBoneIndex]);var h=new a.Bone(f.name,d,g,a.Matrix.FromArray(f.matrix));f.animation&&h.animations.push(k(f.animation))}return d},e=function(b,d,e){var f;return f=new a.StandardMaterial(b.name,d),f.ambientColor=a.Color3.FromArray(b.ambient),f.diffuseColor=a.Color3.FromArray(b.diffuse),f.specularColor=a.Color3.FromArray(b.specular),f.specularPower=b.specularPower,f.emissiveColor=a.Color3.FromArray(b.emissive),f.alpha=b.alpha,f.id=b.id,a.Tags.AddTagsTo(f,b.tags),f.backFaceCulling=b.backFaceCulling,f.wireframe=b.wireframe,b.diffuseTexture&&(f.diffuseTexture=c(e,b.diffuseTexture,d)),b.ambientTexture&&(f.ambientTexture=c(e,b.ambientTexture,d)),b.opacityTexture&&(f.opacityTexture=c(e,b.opacityTexture,d)),b.reflectionTexture&&(f.reflectionTexture=c(e,b.reflectionTexture,d)),b.emissiveTexture&&(f.emissiveTexture=c(e,b.emissiveTexture,d)),b.specularTexture&&(f.specularTexture=c(e,b.specularTexture,d)),b.bumpTexture&&(f.bumpTexture=c(e,b.bumpTexture,d)),f},f=function(a,b,c,d){for(var f=0;f<b.materials.length;f++){var g=b.materials[f];if(g.id===a)return e(g,c,d)}return null},g=function(b,c){var d=new a.MultiMaterial(b.name,c);d.id=b.id,a.Tags.AddTagsTo(d,b.tags);for(var e=0;e<b.materials.length;e++){var f=b.materials[e];d.subMaterials.push(f?c.getMaterialByID(f):null)}return d},h=function(b,c,d){var e=c.getLastEntryByID(b.emitterId),f=new a.LensFlareSystem("lensFlareSystem#"+b.emitterId,e,c);f.borderLimit=b.borderLimit;for(var g=0;g<b.flares.length;g++){var h=b.flares[g];new a.LensFlare(h.size,h.position,a.Color3.FromArray(h.color),d+h.textureName,f)}return f},i=function(b,c,d){var e=c.getLastMeshByID(b.emitterId),f=new a.ParticleSystem("particles#"+e.name,b.capacity,c);return b.textureName&&(f.particleTexture=new a.Texture(d+b.textureName,c),f.particleTexture.name=b.textureName),f.minAngularSpeed=b.minAngularSpeed,f.maxAngularSpeed=b.maxAngularSpeed,f.minSize=b.minSize,f.maxSize=b.maxSize,f.minLifeTime=b.minLifeTime,f.maxLifeTime=b.maxLifeTime,f.emitter=e,f.emitRate=b.emitRate,f.minEmitBox=a.Vector3.FromArray(b.minEmitBox),f.maxEmitBox=a.Vector3.FromArray(b.maxEmitBox),f.gravity=a.Vector3.FromArray(b.gravity),f.direction1=a.Vector3.FromArray(b.direction1),f.direction2=a.Vector3.FromArray(b.direction2),f.color1=a.Color4.FromArray(b.color1),f.color2=a.Color4.FromArray(b.color2),f.colorDead=a.Color4.FromArray(b.colorDead),f.updateSpeed=b.updateSpeed,f.targetStopDuration=b.targetStopFrame,f.textureMask=a.Color4.FromArray(b.textureMask),f.blendMode=b.blendMode,f.start(),f},j=function(b,c){for(var d=c.getLightByID(b.lightId),e=new a.ShadowGenerator(b.mapSize,d),f=0;f<b.renderList.length;f++){var g=c.getMeshByID(b.renderList[f]);e.getShadowMap().renderList.push(g)}return b.usePoissonSampling?e.usePoissonSampling=!0:e.useVarianceShadowMap=b.useVarianceShadowMap,e},k=function(b){for(var c=new a.Animation(b.name,b.property,b.framePerSecond,b.dataType,b.loopBehavior),d=b.dataType,e=[],f=0;f<b.keys.length;f++){var g,h=b.keys[f];switch(d){case a.Animation.ANIMATIONTYPE_FLOAT:g=h.values[0];break;case a.Animation.ANIMATIONTYPE_QUATERNION:g=a.Quaternion.FromArray(h.values);break;case a.Animation.ANIMATIONTYPE_MATRIX:g=a.Matrix.FromArray(h.values);break;case a.Animation.ANIMATIONTYPE_VECTOR3:default:g=a.Vector3.FromArray(h.values)}e.push({frame:h.frame,value:g})}return c.setKeys(e),c},l=function(b,c){var d;switch(b.type){case 0:d=new a.PointLight(b.name,a.Vector3.FromArray(b.position),c);break;case 1:d=new a.DirectionalLight(b.name,a.Vector3.FromArray(b.direction),c),d.position=a.Vector3.FromArray(b.position);break;case 2:d=new a.SpotLight(b.name,a.Vector3.FromArray(b.position),a.Vector3.FromArray(b.direction),b.angle,b.exponent,c);break;case 3:d=new a.HemisphericLight(b.name,a.Vector3.FromArray(b.direction),c),d.groundColor=a.Color3.FromArray(b.groundColor)}if(d.id=b.id,a.Tags.AddTagsTo(d,b.tags),void 0!==b.intensity&&(d.intensity=b.intensity),b.range&&(d.range=b.range),d.diffuse=a.Color3.FromArray(b.diffuse),d.specular=a.Color3.FromArray(b.specular),b.excludedMeshesIds&&(d._excludedMeshesIds=b.excludedMeshesIds),b.animations)for(var e=0;e<b.animations.length;e++){var f=b.animations[e];d.animations.push(k(f))}b.autoAnimate&&c.beginAnimation(d,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1)},m=function(b,c){var d=new a.FreeCamera(b.name,a.Vector3.FromArray(b.position),c);if(d.id=b.id,a.Tags.AddTagsTo(d,b.tags),b.parentId&&(d._waitingParentId=b.parentId),b.target?d.setTarget(a.Vector3.FromArray(b.target)):d.rotation=a.Vector3.FromArray(b.rotation),b.lockedTargetId&&(d._waitingLockedTargetId=b.lockedTargetId),d.fov=b.fov,d.minZ=b.minZ,d.maxZ=b.maxZ,d.speed=b.speed,d.inertia=b.inertia,d.checkCollisions=b.checkCollisions,d.applyGravity=b.applyGravity,b.ellipsoid&&(d.ellipsoid=a.Vector3.FromArray(b.ellipsoid)),b.animations)for(var e=0;e<b.animations.length;e++){var f=b.animations[e];d.animations.push(k(f))}return b.autoAnimate&&c.beginAnimation(d,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1),d.layerMask=b.layerMask&&!isNaN(b.layerMask)?Math.abs(parseInt(b.layerMask)):4294967295,d},n=function(a,b){var c=a.id;return b.getGeometryByID(c)},o=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Box(b.id,c,b.size,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},p=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Sphere(b.id,c,b.segments,b.diameter,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},q=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Cylinder(b.id,c,b.height,b.diameterTop,b.diameterBottom,b.tessellation,b.subdivisions,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},r=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Torus(b.id,c,b.diameter,b.thickness,b.tessellation,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},s=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Ground(b.id,c,b.width,b.height,b.subdivisions,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},t=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.Plane(b.id,c,b.size,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},u=function(b,c){if(n(b,c))return null;var d=new a.Geometry.Primitives.TorusKnot(b.id,c,b.radius,b.tube,b.radialSegments,b.tubularSegments,b.p,b.q,b.canBeRegenerated,null);return a.Tags.AddTagsTo(d,b.tags),c.pushGeometry(d,!0),d},v=function(b,c,d){if(n(b,c))return null;var e=new a.Geometry(b.id,c);return a.Tags.AddTagsTo(e,b.tags),b.delayLoadingFile?(e.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED,e.delayLoadingFile=d+b.delayLoadingFile,e._boundingInfo=new a.BoundingInfo(a.Vector3.FromArray(b.boundingBoxMinimum),a.Vector3.FromArray(b.boundingBoxMaximum)),e._delayInfo=[],b.hasUVs&&e._delayInfo.push(a.VertexBuffer.UVKind),b.hasUVs2&&e._delayInfo.push(a.VertexBuffer.UV2Kind),b.hasColors&&e._delayInfo.push(a.VertexBuffer.ColorKind),b.hasMatricesIndices&&e._delayInfo.push(a.VertexBuffer.MatricesIndicesKind),b.hasMatricesWeights&&e._delayInfo.push(a.VertexBuffer.MatricesWeightsKind),e._delayLoadingFunction=y):y(b,e),c.pushGeometry(e,!0),e},w=function(b,c,d){var e=new a.Mesh(b.name,c);if(e.id=b.id,a.Tags.AddTagsTo(e,b.tags),e.position=a.Vector3.FromArray(b.position),b.rotationQuaternion?e.rotationQuaternion=a.Quaternion.FromArray(b.rotationQuaternion):b.rotation&&(e.rotation=a.Vector3.FromArray(b.rotation)),e.scaling=a.Vector3.FromArray(b.scaling),b.localMatrix?e.setPivotMatrix(a.Matrix.FromArray(b.localMatrix)):b.pivotMatrix&&e.setPivotMatrix(a.Matrix.FromArray(b.pivotMatrix)),e.setEnabled(b.isEnabled),e.isVisible=b.isVisible,e.infiniteDistance=b.infiniteDistance,e.showBoundingBox=b.showBoundingBox,e.showSubMeshesBoundingBox=b.showSubMeshesBoundingBox,void 0!==b.pickable&&(e.isPickable=b.pickable),e.receiveShadows=b.receiveShadows,e.billboardMode=b.billboardMode,void 0!==b.visibility&&(e.visibility=b.visibility),e.checkCollisions=b.checkCollisions,e._shouldGenerateFlatShading=b.useFlatShading,b.parentId&&(e.parent=c.getLastEntryByID(b.parentId)),b.delayLoadingFile?(e.delayLoadState=a.Engine.DELAYLOADSTATE_NOTLOADED,e.delayLoadingFile=d+b.delayLoadingFile,e._boundingInfo=new a.BoundingInfo(a.Vector3.FromArray(b.boundingBoxMinimum),a.Vector3.FromArray(b.boundingBoxMaximum)),e._delayInfo=[],b.hasUVs&&e._delayInfo.push(a.VertexBuffer.UVKind),b.hasUVs2&&e._delayInfo.push(a.VertexBuffer.UV2Kind),b.hasColors&&e._delayInfo.push(a.VertexBuffer.ColorKind),b.hasMatricesIndices&&e._delayInfo.push(a.VertexBuffer.MatricesIndicesKind),b.hasMatricesWeights&&e._delayInfo.push(a.VertexBuffer.MatricesWeightsKind),e._delayLoadingFunction=z,a.SceneLoader.ForceFullSceneLoadingForIncremental&&e._checkDelayState()):z(b,e),b.materialId?e.setMaterialByID(b.materialId):e.material=null,b.skeletonId>-1&&(e.skeleton=c.getLastSkeletonByID(b.skeletonId)),b.physicsImpostor&&(c.isPhysicsEnabled()||c.enablePhysics(),e.setPhysicsState({impostor:b.physicsImpostor,mass:b.physicsMass,friction:b.physicsFriction,restitution:b.physicsRestitution})),b.animations)for(var f=0;f<b.animations.length;f++){var g=b.animations[f];
e.animations.push(k(g))}if(b.autoAnimate&&c.beginAnimation(e,b.autoAnimateFrom,b.autoAnimateTo,b.autoAnimateLoop,1),e.layerMask=b.layerMask&&!isNaN(b.layerMask)?Math.abs(parseInt(b.layerMask)):4294967295,b.instances)for(var h=0;h<b.instances.length;h++){var i=b.instances[h],j=e.createInstance(i.name);if(a.Tags.AddTagsTo(j,i.tags),j.position=a.Vector3.FromArray(i.position),i.rotationQuaternion?j.rotationQuaternion=a.Quaternion.FromArray(i.rotationQuaternion):i.rotation&&(j.rotation=a.Vector3.FromArray(i.rotation)),j.scaling=a.Vector3.FromArray(i.scaling),j.checkCollisions=e.checkCollisions,b.animations)for(f=0;f<b.animations.length;f++)g=b.animations[f],j.animations.push(k(g))}return e},x=function(a,b,c){b=b instanceof Array?b:[b];for(var d in b)if(a.name===b[d])return c.push(a.id),!0;return a.parentId&&-1!==c.indexOf(a.parentId)?(c.push(a.id),!0):!1},y=function(b,c){var d=new a.VertexData,e=b.positions;e&&d.set(e,a.VertexBuffer.PositionKind);var f=b.normals;f&&d.set(f,a.VertexBuffer.NormalKind);var g=b.uvs;g&&d.set(g,a.VertexBuffer.UVKind);var h=b.uv2s;h&&d.set(h,a.VertexBuffer.UV2Kind);var i=b.colors;i&&d.set(i,a.VertexBuffer.ColorKind);var j=b.matricesIndices;j&&d.set(j,a.VertexBuffer.MatricesIndicesKind);var k=b.matricesWeights;k&&d.set(k,a.VertexBuffer.MatricesWeightsKind);var l=b.indices;l&&(d.indices=l),c.setAllVerticesData(d,b.updatable)},z=function(b,c){var d=c.getScene(),e=b.geometryId;if(e){var f=d.getGeometryByID(e);f&&f.applyToMesh(c)}else if(b.positions&&b.normals&&b.indices){if(c.setVerticesData(a.VertexBuffer.PositionKind,b.positions,!1),c.setVerticesData(a.VertexBuffer.NormalKind,b.normals,!1),b.uvs&&c.setVerticesData(a.VertexBuffer.UVKind,b.uvs,!1),b.uvs2&&c.setVerticesData(a.VertexBuffer.UV2Kind,b.uvs2,!1),b.colors&&c.setVerticesData(a.VertexBuffer.ColorKind,b.colors,!1),b.matricesIndices)if(b.matricesIndices._isExpanded)delete b.matricesIndices._isExpanded,c.setVerticesData(a.VertexBuffer.MatricesIndicesKind,b.matricesIndices,!1);else{for(var g=[],h=0;h<b.matricesIndices.length;h++){var i=b.matricesIndices[h];g.push(255&i),g.push((65280&i)>>8),g.push((16711680&i)>>16),g.push(i>>24)}c.setVerticesData(a.VertexBuffer.MatricesIndicesKind,g,!1)}b.matricesWeights&&c.setVerticesData(a.VertexBuffer.MatricesWeightsKind,b.matricesWeights,!1),c.setIndices(b.indices)}if(b.subMeshes){c.subMeshes=[];for(var j=0;j<b.subMeshes.length;j++){var k=b.subMeshes[j];new a.SubMesh(k.materialIndex,k.verticesStart,k.verticesCount,k.indexStart,k.indexCount,c)}}c._shouldGenerateFlatShading&&(c.convertToFlatShadedMesh(),delete c._shouldGenerateFlatShading),c.computeWorldMatrix(!0),d._selectionOctree&&d._selectionOctree.addMesh(c)};a.SceneLoader.RegisterPlugin({extensions:".babylon",importMesh:function(a,b,c,e,h,j,k){for(var l=JSON.parse(c),m=[],n=[],o=[],p=0;p<l.meshes.length;p++){var q=l.meshes[p];if(!a||x(q,a,o)){if(a instanceof Array&&delete a[a.indexOf(q.name)],q.materialId){var r=-1!==n.indexOf(q.materialId);if(!r)for(var s=0;s<l.multiMaterials.length;s++){var t=l.multiMaterials[s];if(t.id==q.materialId){for(var u=0;u<t.materials.length;u++){var v=t.materials[u];n.push(v),f(v,l,b,e)}n.push(t.id),g(t,b),r=!0;break}}r||(n.push(q.materialId),f(q.materialId,l,b,e))}if(q.skeletonId>-1&&b.skeletons){var y=m.indexOf(q.skeletonId)>-1;if(!y)for(var z=0;z<l.skeletons.length;z++){var A=l.skeletons[z];A.id===q.skeletonId&&(k.push(d(A,b)),m.push(A.id))}}var B=w(q,b,e);h.push(B)}}if(l.particleSystems)for(p=0;p<l.particleSystems.length;p++){var C=l.particleSystems[p];-1!==o.indexOf(C.emitterId)&&j.push(i(C,b,e))}return!0},load:function(b,c,f){var k=JSON.parse(c);b.useDelayedTextureLoading=k.useDelayedTextureLoading&&!a.SceneLoader.ForceFullSceneLoadingForIncremental,b.autoClear=k.autoClear,b.clearColor=a.Color3.FromArray(k.clearColor),b.ambientColor=a.Color3.FromArray(k.ambientColor),b.gravity=a.Vector3.FromArray(k.gravity),k.fogMode&&0!==k.fogMode&&(b.fogMode=k.fogMode,b.fogColor=a.Color3.FromArray(k.fogColor),b.fogStart=k.fogStart,b.fogEnd=k.fogEnd,b.fogDensity=k.fogDensity);for(var n=0;n<k.lights.length;n++){var x=k.lights[n];l(x,b)}for(n=0;n<k.cameras.length;n++){var y=k.cameras[n];m(y,b)}if(k.activeCameraID&&b.setActiveCameraByID(k.activeCameraID),k.materials)for(n=0;n<k.materials.length;n++){var z=k.materials[n];e(z,b,f)}if(k.multiMaterials)for(n=0;n<k.multiMaterials.length;n++){var A=k.multiMaterials[n];g(A,b)}if(k.skeletons)for(n=0;n<k.skeletons.length;n++){var B=k.skeletons[n];d(B,b)}var C=k.geometries;if(C){var D=C.boxes;if(D)for(n=0;n<D.length;n++){var E=D[n];o(E,b)}var F=C.spheres;if(F)for(n=0;n<F.length;n++){var G=F[n];p(G,b)}var H=C.cylinders;if(H)for(n=0;n<H.length;n++){var I=H[n];q(I,b)}var J=C.toruses;if(J)for(n=0;n<J.length;n++){var K=J[n];r(K,b)}var L=C.grounds;if(L)for(n=0;n<L.length;n++){var M=L[n];s(M,b)}var N=C.planes;if(N)for(n=0;n<N.length;n++){var O=N[n];t(O,b)}var P=C.torusKnots;if(P)for(n=0;n<P.length;n++){var Q=P[n];u(Q,b)}var R=C.vertexData;if(R)for(n=0;n<R.length;n++){var S=R[n];v(S,b,f)}}for(n=0;n<k.meshes.length;n++){var T=k.meshes[n];w(T,b,f)}for(n=0;n<b.cameras.length;n++){var U=b.cameras[n];if(U._waitingParentId&&(U.parent=b.getLastEntryByID(U._waitingParentId),delete U._waitingParentId),U instanceof a.FreeCamera){var V=U;V._waitingLockedTargetId&&(V.lockedTarget=b.getLastEntryByID(V._waitingLockedTargetId),delete V._waitingLockedTargetId)}}if(k.particleSystems)for(n=0;n<k.particleSystems.length;n++){var W=k.particleSystems[n];i(W,b,f)}if(k.lensFlareSystems)for(n=0;n<k.lensFlareSystems.length;n++){var X=k.lensFlareSystems[n];h(X,b,f)}if(k.shadowGenerators)for(n=0;n<k.shadowGenerators.length;n++){var Y=k.shadowGenerators[n];j(Y,b)}return!0}})}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=0,c=function(){function b(a,b,c){this.pos=a,this.normal=b,this.uv=c}return b.prototype.clone=function(){return new b(this.pos.clone(),this.normal.clone(),this.uv.clone())},b.prototype.flip=function(){this.normal=this.normal.scale(-1)},b.prototype.interpolate=function(c,d){return new b(a.Vector3.Lerp(this.pos,c.pos,d),a.Vector3.Lerp(this.normal,c.normal,d),a.Vector2.Lerp(this.uv,c.uv,d))},b}(),d=function(){function b(a,b){this.normal=a,this.w=b}return b.FromPoints=function(c,d,e){var f=e.subtract(c),g=d.subtract(c);if(0===f.lengthSquared()||0===g.lengthSquared())return null;var h=a.Vector3.Normalize(a.Vector3.Cross(f,g));return new b(h,a.Vector3.Dot(h,c))},b.prototype.clone=function(){return new b(this.normal.clone(),this.w)},b.prototype.flip=function(){this.normal.scaleInPlace(-1),this.w=-this.w},b.prototype.splitPolygon=function(c,d,f,g,h){for(var i=0,j=1,k=2,l=3,m=0,n=[],o=0;o<c.vertices.length;o++){var p=a.Vector3.Dot(this.normal,c.vertices[o].pos)-this.w,q=p<-b.EPSILON?k:p>b.EPSILON?j:i;m|=q,n.push(q)}switch(m){case i:(a.Vector3.Dot(this.normal,c.plane.normal)>0?d:f).push(c);break;case j:g.push(c);break;case k:h.push(c);break;case l:var r=[],s=[];for(o=0;o<c.vertices.length;o++){var t=(o+1)%c.vertices.length,u=n[o],v=n[t],w=c.vertices[o],x=c.vertices[t];if(u!=k&&r.push(w),u!=j&&s.push(u!=k?w.clone():w),(u|v)==l){p=(this.w-a.Vector3.Dot(this.normal,w.pos))/a.Vector3.Dot(this.normal,x.pos.subtract(w.pos));var y=w.interpolate(x,p);r.push(y),s.push(y.clone())}}if(r.length>=3){var z=new e(r,c.shared);z.plane&&g.push(z)}s.length>=3&&(z=new e(s,c.shared),z.plane&&h.push(z))}},b.EPSILON=1e-5,b}(),e=function(){function a(a,b){this.vertices=a,this.shared=b,this.plane=d.FromPoints(a[0].pos,a[1].pos,a[2].pos)}return a.prototype.clone=function(){var b=this.vertices.map(function(a){return a.clone()});return new a(b,this.shared)},a.prototype.flip=function(){this.vertices.reverse().map(function(a){a.flip()}),this.plane.flip()},a}(),f=function(){function a(a){this.plane=null,this.front=null,this.back=null,this.polygons=[],a&&this.build(a)}return a.prototype.clone=function(){var b=new a;return b.plane=this.plane&&this.plane.clone(),b.front=this.front&&this.front.clone(),b.back=this.back&&this.back.clone(),b.polygons=this.polygons.map(function(a){return a.clone()}),b},a.prototype.invert=function(){for(var a=0;a<this.polygons.length;a++)this.polygons[a].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();var b=this.front;this.front=this.back,this.back=b},a.prototype.clipPolygons=function(a){if(!this.plane)return a.slice();for(var b=[],c=[],d=0;d<a.length;d++)this.plane.splitPolygon(a[d],b,c,b,c);return this.front&&(b=this.front.clipPolygons(b)),c=this.back?this.back.clipPolygons(c):[],b.concat(c)},a.prototype.clipTo=function(a){this.polygons=a.clipPolygons(this.polygons),this.front&&this.front.clipTo(a),this.back&&this.back.clipTo(a)},a.prototype.allPolygons=function(){var a=this.polygons.slice();return this.front&&(a=a.concat(this.front.allPolygons())),this.back&&(a=a.concat(this.back.allPolygons())),a},a.prototype.build=function(b){if(b.length){this.plane||(this.plane=b[0].plane.clone());for(var c=[],d=[],e=0;e<b.length;e++)this.plane.splitPolygon(b[e],this.polygons,this.polygons,c,d);c.length&&(this.front||(this.front=new a),this.front.build(c)),d.length&&(this.back||(this.back=new a),this.back.build(d))}},a}(),g=function(){function d(){this.polygons=new Array}return d.FromMesh=function(f){var g,h,i,j,k,l,m=[];if(!(f instanceof a.Mesh))throw"BABYLON.CSG:Wrong Mesh type,must be BABYLON.Mesh";f.computeWorldMatrix(!0);for(var n=f.getWorldMatrix(),o=f.position.clone(),p=f.rotation.clone(),q=f.scaling.clone(),r=f.getIndices(),s=f.getVerticesData(a.VertexBuffer.PositionKind),t=f.getVerticesData(a.VertexBuffer.NormalKind),u=f.getVerticesData(a.VertexBuffer.UVKind),v=f.subMeshes,w=0,x=v.length;x>w;w++)for(var y=v[w].indexStart,z=v[w].indexCount+v[w].indexStart;z>y;y+=3){l=[];for(var A=0;3>A;A++)h=new a.Vector3(t[3*r[y+A]],t[3*r[y+A]+1],t[3*r[y+A]+2]),i=new a.Vector2(u[2*r[y+A]],u[2*r[y+A]+1]),j=new a.Vector3(s[3*r[y+A]],s[3*r[y+A]+1],s[3*r[y+A]+2]),a.Vector3.TransformCoordinatesToRef(j,n,j),a.Vector3.TransformNormalToRef(h,n,h),g=new c(j,h,i),l.push(g);k=new e(l,{subMeshId:w,meshId:b,materialIndex:v[w].materialIndex}),k.plane&&m.push(k)}var B=d.FromPolygons(m);return B.matrix=n,B.position=o,B.rotation=p,B.scaling=q,b++,B},d.FromPolygons=function(b){var c=new a.CSG;return c.polygons=b,c},d.prototype.clone=function(){var b=new a.CSG;return b.polygons=this.polygons.map(function(a){return a.clone()}),b.copyTransformAttributes(this),b},d.prototype.toPolygons=function(){return this.polygons},d.prototype.union=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.unionInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),this.polygons=b.allPolygons()},d.prototype.subtract=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.invert(),b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),b.invert(),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.subtractInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.invert(),b.clipTo(c),c.clipTo(b),c.invert(),c.clipTo(b),c.invert(),b.build(c.allPolygons()),b.invert(),this.polygons=b.allPolygons()},d.prototype.intersect=function(a){var b=new f(this.clone().polygons),c=new f(a.clone().polygons);return b.invert(),c.clipTo(b),c.invert(),b.clipTo(c),c.clipTo(b),b.build(c.allPolygons()),b.invert(),d.FromPolygons(b.allPolygons()).copyTransformAttributes(this)},d.prototype.intersectInPlace=function(a){var b=new f(this.polygons),c=new f(a.polygons);b.invert(),c.clipTo(b),c.invert(),b.clipTo(c),c.clipTo(b),b.build(c.allPolygons()),b.invert(),this.polygons=b.allPolygons()},d.prototype.inverse=function(){var a=this.clone();return a.inverseInPlace(),a},d.prototype.inverseInPlace=function(){this.polygons.map(function(a){a.flip()})},d.prototype.copyTransformAttributes=function(a){return this.matrix=a.matrix,this.position=a.position,this.rotation=a.rotation,this.scaling=a.scaling,this},d.prototype.buildMeshGeometry=function(b,c,d){var e=this.matrix.clone();e.invert();var f,g,h,i=new a.Mesh(b,c),j=[],k=[],l=[],m=[],n=a.Vector3.Zero(),o=a.Vector3.Zero(),p=a.Vector2.Zero(),q=this.polygons,r=[0,0,0],s={},t=0,u={};d&&q.sort(function(a,b){return a.shared.meshId===b.shared.meshId?a.shared.subMeshId-b.shared.subMeshId:a.shared.meshId-b.shared.meshId});for(var v=0,w=q.length;w>v;v++){f=q[v],u[f.shared.meshId]||(u[f.shared.meshId]={}),u[f.shared.meshId][f.shared.subMeshId]||(u[f.shared.meshId][f.shared.subMeshId]={indexStart:+1/0,indexEnd:-1/0,materialIndex:f.shared.materialIndex}),h=u[f.shared.meshId][f.shared.subMeshId];for(var x=2,y=f.vertices.length;y>x;x++){r[0]=0,r[1]=x-1,r[2]=x;for(var z=0;3>z;z++)n.copyFrom(f.vertices[r[z]].pos),o.copyFrom(f.vertices[r[z]].normal),p.copyFrom(f.vertices[r[z]].uv),a.Vector3.TransformCoordinatesToRef(n,e,n),a.Vector3.TransformNormalToRef(o,e,o),g=s[n.x+","+n.y+","+n.z],("undefined"==typeof g||l[3*g]!==o.x||l[3*g+1]!==o.y||l[3*g+2]!==o.z||m[2*g]!==p.x||m[2*g+1]!==p.y)&&(j.push(n.x,n.y,n.z),m.push(p.x,p.y),l.push(o.x,o.y,o.z),g=s[n.x+","+n.y+","+n.z]=j.length/3-1),k.push(g),h.indexStart=Math.min(t,h.indexStart),h.indexEnd=Math.max(t,h.indexEnd),t++}}if(i.setVerticesData(a.VertexBuffer.PositionKind,j),i.setVerticesData(a.VertexBuffer.NormalKind,l),i.setVerticesData(a.VertexBuffer.UVKind,m),i.setIndices(k),d){var A,B=0;i.subMeshes.length=0;for(var C in u){A=-1;for(var D in u[C])h=u[C][D],a.SubMesh.CreateFromIndices(h.materialIndex+B,h.indexStart,h.indexEnd-h.indexStart+1,i),A=Math.max(h.materialIndex,A);B+=++A}}return i},d.prototype.toMesh=function(a,b,c,d){var e=this.buildMeshGeometry(a,c,d);return e.material=b,e.position.copyFrom(this.position),e.rotation.copyFrom(this.rotation),e.scaling.copyFrom(this.scaling),e.computeWorldMatrix(!0),e},d}();a.CSG=g}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){var g=this;b.call(this,c,"oculusDistortionCorrection",["LensCenter","Scale","ScaleIn","HmdWarpParam"],null,f.PostProcessScaleFactor,d,a.Texture.BILINEAR_SAMPLINGMODE,null,null),this._isRightEye=e,this._distortionFactors=f.DistortionK,this._postProcessScaleFactor=f.PostProcessScaleFactor,this._lensCenterOffset=f.LensCenterOffset,this.onSizeChanged=function(){g.aspectRatio=.5*g.width/g.height,g._scaleIn=new a.Vector2(2,2/g.aspectRatio),g._scaleFactor=new a.Vector2(.5*(1/g._postProcessScaleFactor),.5*(1/g._postProcessScaleFactor)*g.aspectRatio),g._lensCenter=new a.Vector2(g._isRightEye?.5-.5*g._lensCenterOffset:.5+.5*g._lensCenterOffset,.5)},this.onApply=function(a){a.setFloat2("LensCenter",g._lensCenter.x,g._lensCenter.y),a.setFloat2("Scale",g._scaleFactor.x,g._scaleFactor.y),a.setFloat2("ScaleIn",g._scaleIn.x,g._scaleIn.y),a.setFloat4("HmdWarpParam",g._distortionFactors[0],g._distortionFactors[1],g._distortionFactors[2],g._distortionFactors[3])}}return __extends(c,b),c}(a.PostProcess);a.OculusDistortionCorrectionPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){a[a.X=0]="X",a[a.Y=1]="Y",a[a.Z=2]="Z"}(a.JoystickAxis||(a.JoystickAxis={}));var b=(a.JoystickAxis,function(){function b(c){var d=this;this._leftJoystick=c?!0:!1,this._joystickIndex=b._globalJoystickIndex,b._globalJoystickIndex++,this._axisTargetedByLeftAndRight=0,this._axisTargetedByUpAndDown=1,this.reverseLeftRight=!1,this.reverseUpDown=!1,this._touches=new a.VirtualJoystick.Collection,this.deltaPosition=a.Vector3.Zero(),this._joystickSensibility=25,this._inversedSensibility=1/(this._joystickSensibility/1e3),this._rotationSpeed=25,this._inverseRotationSpeed=1/(this._rotationSpeed/1e3),this._rotateOnAxisRelativeToMesh=!1,b.vjCanvas||(window.addEventListener("resize",function(){b.vjCanvasWidth=window.innerWidth,b.vjCanvasHeight=window.innerHeight,b.vjCanvas.width=b.vjCanvasWidth,b.vjCanvas.height=b.vjCanvasHeight,b.halfWidth=b.vjCanvasWidth/2,b.halfHeight=b.vjCanvasHeight/2},!1),b.vjCanvas=document.createElement("canvas"),b.vjCanvasWidth=window.innerWidth,b.vjCanvasHeight=window.innerHeight,b.vjCanvas.width=window.innerWidth,b.vjCanvas.height=window.innerHeight,b.vjCanvas.style.width="100%",b.vjCanvas.style.height="100%",b.vjCanvas.style.position="absolute",b.vjCanvas.style.backgroundColor="transparent",b.vjCanvas.style.top="0px",b.vjCanvas.style.left="0px",b.vjCanvas.style.zIndex="5",b.vjCanvas.style.msTouchAction="none",b.vjCanvasContext=b.vjCanvas.getContext("2d"),b.vjCanvasContext.strokeStyle="#ffffff",b.vjCanvasContext.lineWidth=2,document.body.appendChild(b.vjCanvas)),b.halfWidth=b.vjCanvas.width/2,b.halfHeight=b.vjCanvas.height/2,this.pressed=!1,this._joystickColor="cyan",this._joystickPointerID=-1,this._joystickPointerPos=new a.Vector2(0,0),this._joystickPointerStartPos=new a.Vector2(0,0),this._deltaJoystickVector=new a.Vector2(0,0),b.vjCanvas.addEventListener("pointerdown",function(a){d._onPointerDown(a)},!1),b.vjCanvas.addEventListener("pointermove",function(a){d._onPointerMove(a)},!1),b.vjCanvas.addEventListener("pointerup",function(a){d._onPointerUp(a)},!1),b.vjCanvas.addEventListener("pointerout",function(a){d._onPointerUp(a)},!1),b.vjCanvas.addEventListener("contextmenu",function(a){a.preventDefault()},!1),requestAnimationFrame(function(){d._drawVirtualJoystick()})}return b.prototype.setJoystickSensibility=function(a){this._joystickSensibility=a,this._inversedSensibility=1/(this._joystickSensibility/1e3)},b.prototype._onPointerDown=function(a){var c;a.preventDefault(),c=this._leftJoystick===!0?a.clientX<b.halfWidth:a.clientX>b.halfWidth,c&&this._joystickPointerID<0?(this._joystickPointerID=a.pointerId,this._joystickPointerStartPos.x=a.clientX,this._joystickPointerStartPos.y=a.clientY,this._joystickPointerPos=this._joystickPointerStartPos.clone(),this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this.pressed=!0,this._touches.add(a.pointerId.toString(),a)):b._globalJoystickIndex<2&&this._action&&(this._action(),this._touches.add(a.pointerId.toString(),a))},b.prototype._onPointerMove=function(a){if(this._joystickPointerID==a.pointerId){this._joystickPointerPos.x=a.clientX,this._joystickPointerPos.y=a.clientY,this._deltaJoystickVector=this._joystickPointerPos.clone(),this._deltaJoystickVector=this._deltaJoystickVector.subtract(this._joystickPointerStartPos);var b=this.reverseLeftRight?-1:1,c=b*this._deltaJoystickVector.x/this._inversedSensibility;switch(this._axisTargetedByLeftAndRight){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,c));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,c));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,c))}var d=this.reverseUpDown?1:-1,e=d*this._deltaJoystickVector.y/this._inversedSensibility;switch(this._axisTargetedByUpAndDown){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,e));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,e));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,e))}}else this._touches.item(a.pointerId.toString())&&(this._touches.item(a.pointerId.toString()).x=a.clientX,this._touches.item(a.pointerId.toString()).y=a.clientY)},b.prototype._onPointerUp=function(a){this._clearCanvas(),this._joystickPointerID==a.pointerId&&(this._joystickPointerID=-1,this.pressed=!1),this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this._touches.remove(a.pointerId.toString())},b.prototype.setJoystickColor=function(a){this._joystickColor=a},b.prototype.setActionOnTouch=function(a){this._action=a},b.prototype.setAxisForLeftRight=function(a){switch(a){case 0:case 1:case 2:this._axisTargetedByLeftAndRight=a;break;default:this._axisTargetedByLeftAndRight=0}},b.prototype.setAxisForUpDown=function(a){switch(a){case 0:case 1:case 2:this._axisTargetedByUpAndDown=a;break;default:this._axisTargetedByUpAndDown=1}},b.prototype._clearCanvas=function(){this._leftJoystick?b.vjCanvasContext.clearRect(0,0,b.vjCanvasWidth/2,b.vjCanvasHeight):b.vjCanvasContext.clearRect(b.vjCanvasWidth/2,0,b.vjCanvasWidth,b.vjCanvasHeight)},b.prototype._drawVirtualJoystick=function(){var a=this;this.pressed&&(this._clearCanvas(),this._touches.forEach(function(c){c.pointerId===a._joystickPointerID?(b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.lineWidth=6,b.vjCanvasContext.arc(a._joystickPointerStartPos.x,a._joystickPointerStartPos.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke(),b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.lineWidth=2,b.vjCanvasContext.arc(a._joystickPointerStartPos.x,a._joystickPointerStartPos.y,60,0,2*Math.PI,!0),b.vjCanvasContext.stroke(),b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle=a._joystickColor,b.vjCanvasContext.arc(a._joystickPointerPos.x,a._joystickPointerPos.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke()):(b.vjCanvasContext.beginPath(),b.vjCanvasContext.fillStyle="white",b.vjCanvasContext.beginPath(),b.vjCanvasContext.strokeStyle="red",b.vjCanvasContext.lineWidth=6,b.vjCanvasContext.arc(c.x,c.y,40,0,2*Math.PI,!0),b.vjCanvasContext.stroke())})),requestAnimationFrame(function(){a._drawVirtualJoystick()})},b.prototype.releaseCanvas=function(){b.vjCanvas&&(document.body.removeChild(b.vjCanvas),b.vjCanvas=null)},b._globalJoystickIndex=0,b}());a.VirtualJoystick=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){var b=function(){function a(){this._count=0,this._collection=new Array}return a.prototype.Count=function(){return this._count},a.prototype.add=function(a,b){return void 0!=this._collection[a]?void 0:(this._collection[a]=b,++this._count)},a.prototype.remove=function(a){return void 0==this._collection[a]?void 0:(delete this._collection[a],--this._count)},a.prototype.item=function(a){return this._collection[a]},a.prototype.forEach=function(a){var b;for(b in this._collection)this._collection.hasOwnProperty(b)&&a(this._collection[b])},a}();a.Collection=b}(a.VirtualJoystick||(a.VirtualJoystick={}));a.VirtualJoystick}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b={HResolution:1280,VResolution:800,HScreenSize:.149759993,VScreenSize:.0935999975,VScreenCenter:.0467999987,EyeToScreenDistance:.0410000011,LensSeparationDistance:.063500002,InterpupillaryDistance:.064000003,DistortionK:[1,.219999999,.239999995,0],ChromaAbCorrection:[.995999992,-.00400000019,1.01400006,0],PostProcessScaleFactor:1.714605507808412,LensCenterOffset:.151976421},c=function(c){function d(d,e,f,g){c.call(this,d,e,f),this._workMatrix=new a.Matrix,this._actualUp=new a.Vector3(0,0,0),this._aspectRatioAspectRatio=b.HResolution/(2*b.VResolution),this._aspectRatioFov=2*Math.atan(b.PostProcessScaleFactor*b.VScreenSize/(2*b.EyeToScreenDistance));var h=b.HScreenSize/4-b.LensSeparationDistance/2,i=4*h/b.HScreenSize;this._hMatrix=a.Matrix.Translation(g?i:-i,0,0),this.viewport=new a.Viewport(g?0:.5,0,.5,1),this._preViewMatrix=a.Matrix.Translation(g?.5*b.InterpupillaryDistance:-.5*b.InterpupillaryDistance,0,0);new a.OculusDistortionCorrectionPostProcess("Oculus Distortion",this,!g,b)}return __extends(d,c),d.prototype.getProjectionMatrix=function(){return a.Matrix.PerspectiveFovLHToRef(this._aspectRatioFov,this._aspectRatioAspectRatio,this.minZ,this.maxZ,this._workMatrix),this._workMatrix.multiplyToRef(this._hMatrix,this._projectionMatrix),this._projectionMatrix},d.prototype._getViewMatrix=function(){return a.Matrix.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix),a.Vector3.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),a.Vector3.TransformNormalToRef(this.upVector,this._cameraRotationMatrix,this._actualUp),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),a.Matrix.LookAtLHToRef(this.position,this._currentTarget,this._actualUp,this._workMatrix),this._workMatrix.multiplyToRef(this._preViewMatrix,this._viewMatrix),this._viewMatrix},d}(a.FreeCamera),d=function(a){function b(b,d,e){a.call(this,b,d,e),this._leftCamera=new c(b+"_left",d.clone(),e,!0),this._rightCamera=new c(b+"_right",d.clone(),e,!1),this.subCameras.push(this._leftCamera),this.subCameras.push(this._rightCamera),this._deviceOrientationHandler=this._onOrientationEvent.bind(this)}return __extends(b,a),b.prototype._update=function(){this._leftCamera.position.copyFrom(this.position),this._rightCamera.position.copyFrom(this.position),this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),a.prototype._update.call(this)},b.prototype._updateCamera=function(a){a.minZ=this.minZ,a.maxZ=this.maxZ,a.rotation.x=this.rotation.x,a.rotation.y=this.rotation.y,a.rotation.z=this.rotation.z},b.prototype._onOrientationEvent=function(a){var b=a.alpha/180*Math.PI,c=a.beta/180*Math.PI,d=a.gamma/180*Math.PI;return this._offsetOrientation?(this.rotation.y+=b-this._offsetOrientation.yaw,this.rotation.x+=c-this._offsetOrientation.pitch,this.rotation.z+=this._offsetOrientation.roll-d,this._offsetOrientation.yaw=b,this._offsetOrientation.pitch=c,this._offsetOrientation.roll=d,void 0):void(this._offsetOrientation={yaw:b,pitch:c,roll:d})},b.prototype.attachControl=function(b,c){a.prototype.attachControl.call(this,b,c),window.addEventListener("deviceorientation",this._deviceOrientationHandler)},b.prototype.detachControl=function(b){a.prototype.detachControl.call(this,b),window.removeEventListener("deviceorientation",this._deviceOrientationHandler)},b}(a.FreeCamera);a.OculusCamera=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){b.call(this,c,d,e),this._leftjoystick=new a.VirtualJoystick(!0),this._leftjoystick.setAxisForUpDown(2),this._leftjoystick.setAxisForLeftRight(0),this._leftjoystick.setJoystickSensibility(.15),this._rightjoystick=new a.VirtualJoystick(!1),this._rightjoystick.setAxisForUpDown(0),this._rightjoystick.setAxisForLeftRight(1),this._rightjoystick.reverseUpDown=!0,this._rightjoystick.setJoystickSensibility(.05),this._rightjoystick.setJoystickColor("yellow")}return __extends(c,b),c.prototype._checkInputs=function(){var b=a.Matrix.RotationYawPitchRoll(this.rotation.y,this.rotation.x,0),c=a.Vector3.TransformCoordinates(this._leftjoystick.deltaPosition,b);this.cameraDirection=this.cameraDirection.add(c),this.cameraRotation=this.cameraRotation.add(this._rightjoystick.deltaPosition),this._leftjoystick.pressed||(this._leftjoystick.deltaPosition=this._leftjoystick.deltaPosition.scale(.9)),this._rightjoystick.pressed||(this._rightjoystick.deltaPosition=this._rightjoystick.deltaPosition.scale(.9))},c.prototype.dispose=function(){this._leftjoystick.releaseCanvas()},c}(a.FreeCamera);a.VirtualJoysticksCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e,f){b.call(this,c,d),this._textures=new Array,this._floats=new Array,this._floatsArrays={},this._colors3=new Array,this._colors4=new Array,this._vectors2=new Array,this._vectors3=new Array,this._matrices=new Array,this._cachedWorldViewMatrix=new a.Matrix,this._shaderPath=e,f.needAlphaBlending=f.needAlphaBlending||!1,f.needAlphaTesting=f.needAlphaTesting||!1,f.attributes=f.attributes||["position","normal","uv"],f.uniforms=f.uniforms||["worldViewProjection"],f.samplers=f.samplers||[],this._options=f}return __extends(c,b),c.prototype.needAlphaBlending=function(){return this._options.needAlphaBlending},c.prototype.needAlphaTesting=function(){return this._options.needAlphaTesting},c.prototype._checkUniform=function(a){-1===this._options.uniforms.indexOf(a)&&this._options.uniforms.push(a)},c.prototype.setTexture=function(a,b){return-1===this._options.samplers.indexOf(a)&&this._options.samplers.push(a),this._textures[a]=b,this},c.prototype.setFloat=function(a,b){return this._checkUniform(a),this._floats[a]=b,this},c.prototype.setFloats=function(a,b){return this._checkUniform(a),this._floatsArrays[a]=b,this},c.prototype.setColor3=function(a,b){return this._checkUniform(a),this._colors3[a]=b,this},c.prototype.setColor4=function(a,b){return this._checkUniform(a),this._colors4[a]=b,this},c.prototype.setVector2=function(a,b){return this._checkUniform(a),this._vectors2[a]=b,this},c.prototype.setVector3=function(a,b){return this._checkUniform(a),this._vectors3[a]=b,this},c.prototype.setMatrix=function(a,b){return this._checkUniform(a),this._matrices[a]=b,this},c.prototype.isReady=function(){var a=this.getScene().getEngine();return this._effect=a.createEffect(this._shaderPath,this._options.attributes,this._options.uniforms,this._options.samplers,"",null,this.onCompiled,this.onError),this._effect.isReady()?!0:!1},c.prototype.bind=function(a){-1!==this._options.uniforms.indexOf("world")&&this._effect.setMatrix("world",a),-1!==this._options.uniforms.indexOf("view")&&this._effect.setMatrix("view",this.getScene().getViewMatrix()),-1!==this._options.uniforms.indexOf("worldView")&&(a.multiplyToRef(this.getScene().getViewMatrix(),this._cachedWorldViewMatrix),this._effect.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==this._options.uniforms.indexOf("projection")&&this._effect.setMatrix("projection",this.getScene().getProjectionMatrix()),-1!==this._options.uniforms.indexOf("worldViewProjection")&&this._effect.setMatrix("worldViewProjection",a.multiply(this.getScene().getTransformMatrix()));for(var b in this._textures)this._effect.setTexture(b,this._textures[b]);for(b in this._floats)this._effect.setFloat(b,this._floats[b]);for(b in this._floatsArrays)this._effect.setArray(b,this._floatsArrays[b]);for(b in this._colors3)this._effect.setColor3(b,this._colors3[b]);for(b in this._colors4){var c=this._colors4[b];this._effect.setFloat4(b,c.r,c.g,c.b,c.a)}for(b in this._vectors2)this._effect.setVector2(b,this._vectors2[b]);for(b in this._vectors3)this._effect.setVector3(b,this._vectors3[b]);for(b in this._matrices)this._effect.setMatrix(b,this._matrices[b])},c.prototype.dispose=function(a){for(var c in this._textures)this._textures[c].dispose();this._textures=[],b.prototype.dispose.call(this,a)},c}(a.Material);a.ShaderMaterial=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return b.prototype.set=function(b,c){switch(c){case a.VertexBuffer.PositionKind:this.positions=b;break;case a.VertexBuffer.NormalKind:this.normals=b;break;case a.VertexBuffer.UVKind:this.uvs=b;break;case a.VertexBuffer.UV2Kind:this.uv2s=b;break;case a.VertexBuffer.ColorKind:this.colors=b;break;case a.VertexBuffer.MatricesIndicesKind:this.matricesIndices=b;break;case a.VertexBuffer.MatricesWeightsKind:this.matricesWeights=b}},b.prototype.applyToMesh=function(a,b){this._applyTo(a,b)},b.prototype.applyToGeometry=function(a,b){this._applyTo(a,b)},b.prototype.updateMesh=function(a){this._update(a)},b.prototype.updateGeometry=function(a){this._update(a)},b.prototype._applyTo=function(b,c){this.positions&&b.setVerticesData(a.VertexBuffer.PositionKind,this.positions,c),this.normals&&b.setVerticesData(a.VertexBuffer.NormalKind,this.normals,c),this.uvs&&b.setVerticesData(a.VertexBuffer.UVKind,this.uvs,c),this.uv2s&&b.setVerticesData(a.VertexBuffer.UV2Kind,this.uv2s,c),this.colors&&b.setVerticesData(a.VertexBuffer.ColorKind,this.colors,c),this.matricesIndices&&b.setVerticesData(a.VertexBuffer.MatricesIndicesKind,this.matricesIndices,c),this.matricesWeights&&b.setVerticesData(a.VertexBuffer.MatricesWeightsKind,this.matricesWeights,c),this.indices&&b.setIndices(this.indices)
},b.prototype._update=function(b,c,d){this.positions&&b.updateVerticesData(a.VertexBuffer.PositionKind,this.positions,c,d),this.normals&&b.updateVerticesData(a.VertexBuffer.NormalKind,this.normals,c,d),this.uvs&&b.updateVerticesData(a.VertexBuffer.UVKind,this.uvs,c,d),this.uv2s&&b.updateVerticesData(a.VertexBuffer.UV2Kind,this.uv2s,c,d),this.colors&&b.updateVerticesData(a.VertexBuffer.ColorKind,this.colors,c,d),this.matricesIndices&&b.updateVerticesData(a.VertexBuffer.MatricesIndicesKind,this.matricesIndices,c,d),this.matricesWeights&&b.updateVerticesData(a.VertexBuffer.MatricesWeightsKind,this.matricesWeights,c,d),this.indices&&b.setIndices(this.indices)},b.prototype.transform=function(b){var c=a.Vector3.Zero();if(this.positions)for(var d=a.Vector3.Zero(),e=0;e<this.positions.length;e+=3)a.Vector3.FromArrayToRef(this.positions,e,d),a.Vector3.TransformCoordinatesToRef(d,b,c),this.positions[e]=c.x,this.positions[e+1]=c.y,this.positions[e+2]=c.z;if(this.normals){var f=a.Vector3.Zero();for(e=0;e<this.normals.length;e+=3)a.Vector3.FromArrayToRef(this.normals,e,f),a.Vector3.TransformNormalToRef(f,b,c),this.normals[e]=c.x,this.normals[e+1]=c.y,this.normals[e+2]=c.z}},b.prototype.merge=function(a){if(a.indices){this.indices||(this.indices=[]);for(var b=this.positions?this.positions.length/3:0,c=0;c<a.indices.length;c++)this.indices.push(a.indices[c]+b)}if(a.positions)for(this.positions||(this.positions=[]),c=0;c<a.positions.length;c++)this.positions.push(a.positions[c]);if(a.normals)for(this.normals||(this.normals=[]),c=0;c<a.normals.length;c++)this.normals.push(a.normals[c]);if(a.uvs)for(this.uvs||(this.uvs=[]),c=0;c<a.uvs.length;c++)this.uvs.push(a.uvs[c]);if(a.uv2s)for(this.uv2s||(this.uv2s=[]),c=0;c<a.uv2s.length;c++)this.uv2s.push(a.uv2s[c]);if(a.matricesIndices)for(this.matricesIndices||(this.matricesIndices=[]),c=0;c<a.matricesIndices.length;c++)this.matricesIndices.push(a.matricesIndices[c]);if(a.matricesWeights)for(this.matricesWeights||(this.matricesWeights=[]),c=0;c<a.matricesWeights.length;c++)this.matricesWeights.push(a.matricesWeights[c]);if(a.colors)for(this.colors||(this.colors=[]),c=0;c<a.colors.length;c++)this.colors.push(a.colors[c])},b.ExtractFromMesh=function(a){return b._ExtractFrom(a)},b.ExtractFromGeometry=function(a){return b._ExtractFrom(a)},b._ExtractFrom=function(b){var c=new a.VertexData;return b.isVerticesDataPresent(a.VertexBuffer.PositionKind)&&(c.positions=b.getVerticesData(a.VertexBuffer.PositionKind)),b.isVerticesDataPresent(a.VertexBuffer.NormalKind)&&(c.normals=b.getVerticesData(a.VertexBuffer.NormalKind)),b.isVerticesDataPresent(a.VertexBuffer.UVKind)&&(c.uvs=b.getVerticesData(a.VertexBuffer.UVKind)),b.isVerticesDataPresent(a.VertexBuffer.UV2Kind)&&(c.uv2s=b.getVerticesData(a.VertexBuffer.UV2Kind)),b.isVerticesDataPresent(a.VertexBuffer.ColorKind)&&(c.colors=b.getVerticesData(a.VertexBuffer.ColorKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesIndicesKind)&&(c.matricesIndices=b.getVerticesData(a.VertexBuffer.MatricesIndicesKind)),b.isVerticesDataPresent(a.VertexBuffer.MatricesWeightsKind)&&(c.matricesWeights=b.getVerticesData(a.VertexBuffer.MatricesWeightsKind)),c.indices=b.getIndices(),c},b.CreateBox=function(b){var c=[new a.Vector3(0,0,1),new a.Vector3(0,0,-1),new a.Vector3(1,0,0),new a.Vector3(-1,0,0),new a.Vector3(0,1,0),new a.Vector3(0,-1,0)],d=[],e=[],f=[],g=[];b=b||1;for(var h=0;h<c.length;h++){var i=c[h],j=new a.Vector3(i.y,i.z,i.x),k=a.Vector3.Cross(i,j),l=e.length/3;d.push(l),d.push(l+1),d.push(l+2),d.push(l),d.push(l+2),d.push(l+3);var m=i.subtract(j).subtract(k).scale(b/2);e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(1,1),m=i.subtract(j).add(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(0,1),m=i.add(j).add(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(0,0),m=i.add(j).subtract(k).scale(b/2),e.push(m.x,m.y,m.z),f.push(i.x,i.y,i.z),g.push(1,0)}var n=new a.VertexData;return n.indices=d,n.positions=e,n.normals=f,n.uvs=g,n},b.CreateSphere=function(b,c){b=b||32,c=c||1;for(var d=c/2,e=2+b,f=2*e,g=[],h=[],i=[],j=[],k=0;e>=k;k++){for(var l=k/e,m=l*Math.PI,n=0;f>=n;n++){var o=n/f,p=o*Math.PI*2,q=a.Matrix.RotationZ(-m),r=a.Matrix.RotationY(p),s=a.Vector3.TransformCoordinates(a.Vector3.Up(),q),t=a.Vector3.TransformCoordinates(s,r),u=t.scale(d),v=a.Vector3.Normalize(u);h.push(u.x,u.y,u.z),i.push(v.x,v.y,v.z),j.push(l,o)}if(k>0)for(var w=h.length/3,x=w-2*(f+1);w>x+f+2;x++)g.push(x),g.push(x+1),g.push(x+f+1),g.push(x+f+1),g.push(x+1),g.push(x+f+2)}var y=new a.VertexData;return y.indices=g,y.positions=h,y.normals=i,y.uvs=j,y},b.CreateCylinder=function(b,c,d,e,f){"undefined"==typeof f&&(f=1);var g=c/2,h=d/2,i=[],j=[],k=[],l=[];b=b||1,c=c||.5,d=d||1,e=e||16,f=f||1,f=1>f?1:f;for(var m=function(b){var c=2*b*Math.PI/e,d=Math.cos(c),f=Math.sin(c);return new a.Vector3(d,0,f)},n=function(c){var d=c?g:h;if(0!=d){var f=j.length/3,k=new a.Vector3(0,b/2,0),n=new a.Vector2(.5,.5);for(c||(k.scaleInPlace(-1),n.x=-n.x),r=0;e>r;r++){var o=m(r),p=o.scale(d).add(k),q=new a.Vector2(o.x*n.x+.5,o.z*n.y+.5);j.push(p.x,p.y,p.z),l.push(q.x,q.y)}for(var r=0;e-2>r;r++)c?(i.push(f),i.push(f+(r+1)%e),i.push(f+(r+2)%e)):(i.push(f),i.push(f+(r+2)%e),i.push(f+(r+1)%e))}},o=new a.Vector3(0,-1,0).scale(b/2),p=new a.Vector3(0,1,0).scale(b/f),q=e+1,r=0;e>=r;r++)for(var s,t=m(r),u=new a.Vector2(r/e,0),v=h,w=0;f>=w;w++)s=t.scale(v),s.addInPlace(o.add(p.scale(w))),u.y+=1/f,v+=(g-h)/f,j.push(s.x,s.y,s.z),l.push(u.x,u.y);f+=1;for(var w=0;f-1>w;w++)for(var r=0;e>=r;r++)i.push(r*f+w),i.push((r*f+(w+f))%(q*f)),i.push(r*f+(w+1)),i.push(r*f+(w+1)),i.push((r*f+(w+f))%(q*f)),i.push((r*f+(w+f+1))%(q*f));n(!0),n(!1),a.VertexData.ComputeNormals(j,i,k);var x=new a.VertexData;return x.indices=i,x.positions=j,x.normals=k,x.uvs=l,x},b.CreateTorus=function(b,c,d){var e=[],f=[],g=[],h=[];b=b||1,c=c||.5,d=d||16;for(var i=d+1,j=0;d>=j;j++)for(var k=j/d,l=j*Math.PI*2/d-Math.PI/2,m=a.Matrix.Translation(b/2,0,0).multiply(a.Matrix.RotationY(l)),n=0;d>=n;n++){var o=1-n/d,p=n*Math.PI*2/d+Math.PI,q=Math.cos(p),r=Math.sin(p),s=new a.Vector3(q,r,0),t=s.scale(c/2),u=new a.Vector2(k,o);t=a.Vector3.TransformCoordinates(t,m),s=a.Vector3.TransformNormal(s,m),f.push(t.x,t.y,t.z),g.push(s.x,s.y,s.z),h.push(u.x,u.y);var v=(j+1)%i,w=(n+1)%i;e.push(j*i+n),e.push(j*i+w),e.push(v*i+n),e.push(j*i+w),e.push(v*i+w),e.push(v*i+n)}var x=new a.VertexData;return x.indices=e,x.positions=f,x.normals=g,x.uvs=h,x},b.CreateLines=function(b){for(var c=[],d=[],e=0;e<b.length;e++)d.push(b[e].x,b[e].y,b[e].z),e>0&&(c.push(e-1),c.push(e));var f=new a.VertexData;return f.indices=c,f.positions=d,f},b.CreateGround=function(b,c,d){var e,f,g=[],h=[],i=[],j=[];for(b=b||1,c=c||1,d=d||1,e=0;d>=e;e++)for(f=0;d>=f;f++){var k=new a.Vector3(f*b/d-b/2,0,(d-e)*c/d-c/2),l=new a.Vector3(0,1,0);h.push(k.x,k.y,k.z),i.push(l.x,l.y,l.z),j.push(f/d,1-e/d)}for(e=0;d>e;e++)for(f=0;d>f;f++)g.push(f+1+(e+1)*(d+1)),g.push(f+1+e*(d+1)),g.push(f+e*(d+1)),g.push(f+(e+1)*(d+1)),g.push(f+1+(e+1)*(d+1)),g.push(f+e*(d+1));var m=new a.VertexData;return m.indices=g,m.positions=h,m.normals=i,m.uvs=j,m},b.CreateTiledGround=function(b,c,d,e,f,g){function h(b,c,d,e){var f=n.length/3,h=g.w+1;for(i=0;i<g.h;i++)for(j=0;j<g.w;j++){var k=[f+j+i*h,f+(j+1)+i*h,f+(j+1)+(i+1)*h,f+j+(i+1)*h];m.push(k[1]),m.push(k[2]),m.push(k[3]),m.push(k[0]),m.push(k[1]),m.push(k[3])}var l=a.Vector3.Zero(),q=new a.Vector3(0,1,0);for(i=0;i<=g.h;i++)for(l.z=i*(e-c)/g.h+c,j=0;j<=g.w;j++)l.x=j*(d-b)/g.w+b,l.y=0,n.push(l.x,l.y,l.z),o.push(q.x,q.y,q.z),p.push(j/g.w,i/g.h)}"undefined"==typeof f&&(f={w:1,h:1}),"undefined"==typeof g&&(g={w:1,h:1});var i,j,k,l,m=[],n=[],o=[],p=[];f.h=f.w<1?1:f.h,f.w=f.w<1?1:f.w,g.w=g.w<1?1:g.w,g.h=g.h<1?1:g.h;var q={w:(d-b)/f.w,h:(e-c)/f.h};for(k=0;k<f.h;k++)for(l=0;l<f.w;l++)h(b+l*q.w,c+k*q.h,b+(l+1)*q.w,c+(k+1)*q.h);var r=new a.VertexData;return r.indices=m,r.positions=n,r.normals=o,r.uvs=p,r},b.CreateGroundFromHeightMap=function(b,c,d,e,f,g,h,i){var j,k,l=[],m=[],n=[],o=[];for(j=0;d>=j;j++)for(k=0;d>=k;k++){var p=new a.Vector3(k*b/d-b/2,0,(d-j)*c/d-c/2),q=(p.x+b/2)/b*(h-1)|0,r=(1-(p.z+c/2)/c)*(i-1)|0,s=4*(q+r*h),t=g[s]/255,u=g[s+1]/255,v=g[s+2]/255,w=.3*t+.59*u+.11*v;p.y=e+(f-e)*w,m.push(p.x,p.y,p.z),n.push(0,0,0),o.push(k/d,1-j/d)}for(j=0;d>j;j++)for(k=0;d>k;k++)l.push(k+1+(j+1)*(d+1)),l.push(k+1+j*(d+1)),l.push(k+j*(d+1)),l.push(k+(j+1)*(d+1)),l.push(k+1+(j+1)*(d+1)),l.push(k+j*(d+1));a.VertexData.ComputeNormals(m,l,n);var x=new a.VertexData;return x.indices=l,x.positions=m,x.normals=n,x.uvs=o,x},b.CreatePlane=function(b){var c=[],d=[],e=[],f=[];b=b||1;var g=b/2;d.push(-g,-g,0),e.push(0,0,-1),f.push(0,0),d.push(g,-g,0),e.push(0,0,-1),f.push(1,0),d.push(g,g,0),e.push(0,0,-1),f.push(1,1),d.push(-g,g,0),e.push(0,0,-1),f.push(0,1),c.push(0),c.push(1),c.push(2),c.push(0),c.push(2),c.push(3);var h=new a.VertexData;return h.indices=c,h.positions=d,h.normals=e,h.uvs=f,h},b.CreateTorusKnot=function(b,c,d,e,f,g){var h=[],i=[],j=[],k=[];b=b||2,c=c||.5,d=d||32,e=e||32,f=f||2,g=g||3;for(var l=function(c){var d=Math.cos(c),e=Math.sin(c),h=g/f*c,i=Math.cos(h),j=b*(2+i)*.5*d,k=b*(2+i)*e*.5,l=b*Math.sin(h)*.5;return new a.Vector3(j,k,l)},m=0;d>=m;m++){var n=m%d,o=n/d*2*f*Math.PI,p=l(o),q=l(o+.01),r=q.subtract(p),s=q.add(p),t=a.Vector3.Cross(r,s);s=a.Vector3.Cross(t,r),t.normalize(),s.normalize();for(var u=0;e>u;u++){var v=u%e,w=v/e*2*Math.PI,x=-c*Math.cos(w),y=c*Math.sin(w);i.push(p.x+x*s.x+y*t.x),i.push(p.y+x*s.y+y*t.y),i.push(p.z+x*s.z+y*t.z),k.push(m/d),k.push(u/e)}}for(m=0;d>m;m++)for(u=0;e>u;u++){var z=(u+1)%e,A=m*e+u,B=(m+1)*e+u,C=(m+1)*e+z,D=m*e+z;h.push(D),h.push(B),h.push(A),h.push(D),h.push(C),h.push(B)}a.VertexData.ComputeNormals(i,h,j);var E=new a.VertexData;return E.indices=h,E.positions=i,E.normals=j,E.uvs=k,E},b.ComputeNormals=function(b,c,d){var e,f=[],g=[];for(e=0;e<b.length;e+=3){var h=new a.Vector3(b[e],b[e+1],b[e+2]);f.push(h),g.push([])}var i=[];for(e=0;e<c.length/3;e++){var j=c[3*e],k=c[3*e+1],l=c[3*e+2],m=f[j],n=f[k],o=f[l],p=m.subtract(n),q=o.subtract(n);i[e]=a.Vector3.Normalize(a.Vector3.Cross(p,q)),g[j].push(e),g[k].push(e),g[l].push(e)}for(e=0;e<f.length;e++){for(var r=g[e],s=a.Vector3.Zero(),t=0;t<r.length;t++)s.addInPlace(i[r[t]]);s=a.Vector3.Normalize(s.scale(1/r.length)),d[3*e]=s.x,d[3*e+1]=s.y,d[3*e+2]=s.z}},b}();a.VertexData=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b,c){b._leftCamera.isIntermediate=!0,b.subCameras.push(b._leftCamera),b.subCameras.push(b._rightCamera),b._leftTexture=new a.PassPostProcess(c+"_leftTexture",1,b._leftCamera),b._anaglyphPostProcess=new a.AnaglyphPostProcess(c+"_anaglyph",1,b._rightCamera),b._anaglyphPostProcess.onApply=function(a){a.setTextureFromPostProcess("leftSampler",b._leftTexture)},b._update()},c=function(c){function d(d,e,f,g,h,i,j){c.call(this,d,e,f,g,h,j),this._eyeSpace=a.Tools.ToRadians(i),this._leftCamera=new a.ArcRotateCamera(d+"_left",e-this._eyeSpace,f,g,h,j),this._rightCamera=new a.ArcRotateCamera(d+"_right",e+this._eyeSpace,f,g,h,j),b(this,d)}return __extends(d,c),d.prototype._update=function(){this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),this._leftCamera.alpha=this.alpha-this._eyeSpace,this._rightCamera.alpha=this.alpha+this._eyeSpace,c.prototype._update.call(this)},d.prototype._updateCamera=function(a){a.beta=this.beta,a.radius=this.radius,a.minZ=this.minZ,a.maxZ=this.maxZ,a.fov=this.fov,a.target=this.target},d}(a.ArcRotateCamera);a.AnaglyphArcRotateCamera=c;var d=function(c){function d(d,e,f,g){c.call(this,d,e,g),this._eyeSpace=a.Tools.ToRadians(f),this._transformMatrix=new a.Matrix,this._leftCamera=new a.FreeCamera(d+"_left",e.clone(),g),this._rightCamera=new a.FreeCamera(d+"_right",e.clone(),g),b(this,d)}return __extends(d,c),d.prototype._getSubCameraPosition=function(b,c){var d=this.getTarget();a.Matrix.Translation(-d.x,-d.y,-d.z).multiplyToRef(a.Matrix.RotationY(b),this._transformMatrix),this._transformMatrix=this._transformMatrix.multiply(a.Matrix.Translation(d.x,d.y,d.z)),a.Vector3.TransformCoordinatesToRef(this.position,this._transformMatrix,c)},d.prototype._update=function(){this._getSubCameraPosition(-this._eyeSpace,this._leftCamera.position),this._getSubCameraPosition(this._eyeSpace,this._rightCamera.position),this._updateCamera(this._leftCamera),this._updateCamera(this._rightCamera),c.prototype._update.call(this)},d.prototype._updateCamera=function(a){a.minZ=this.minZ,a.maxZ=this.maxZ,a.fov=this.fov,a.viewport=this.viewport,a.setTarget(this.getTarget())},d}(a.FreeCamera);a.AnaglyphFreeCamera=d}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"anaglyph",null,["leftSampler"],c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.AnaglyphPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){}return b.EnableFor=function(a){a._tags=a._tags||{},a.hasTags=function(){return b.HasTags(a)},a.addTags=function(c){return b.AddTagsTo(a,c)},a.removeTags=function(c){return b.RemoveTagsFrom(a,c)},a.matchesTagsQuery=function(c){return b.MatchesQuery(a,c)}},b.DisableFor=function(a){delete a._tags,delete a.hasTags,delete a.addTags,delete a.removeTags,delete a.matchesTagsQuery},b.HasTags=function(b){return b._tags?!a.Tools.IsEmpty(b._tags):!1},b.GetTags=function(a){return a._tags?a._tags:null},b.AddTagsTo=function(a,c){if(c){var d=c.split(" ");for(var e in d)b._AddTagTo(a,d[e])}},b._AddTagTo=function(a,c){c=c.trim(),""!==c&&"true"!==c&&"false"!==c&&(c.match(/[\s]/)||c.match(/^([!]|([|]|[&]){2})/)||(b.EnableFor(a),a._tags[c]=!0))},b.RemoveTagsFrom=function(a,c){if(b.HasTags(a)){var d=c.split(" ");for(var e in d)b._RemoveTagFrom(a,d[e])}},b._RemoveTagFrom=function(a,b){delete a._tags[b]},b.MatchesQuery=function(c,d){return void 0===d?!0:""===d?b.HasTags(c):a.Internals.AndOrNotEvaluator.Eval(d,function(a){return b.HasTags(c)&&c._tags[a]})},b}();a.Tags=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(a){var b=function(){function a(){}return a.Eval=function(b,c){return b=b.match(/\([^\(\)]*\)/g)?b.replace(/\([^\(\)]*\)/g,function(b){return b=b.slice(1,b.length-1),a._HandleParenthesisContent(b,c)}):a._HandleParenthesisContent(b,c),"true"===b?!0:"false"===b?!1:a.Eval(b,c)},a._HandleParenthesisContent=function(b,c){c=c||function(a){return"true"===a?!0:!1};var d,e=b.split("||");for(var f in e){var g=a._SimplifyNegation(e[f].trim()),h=g.split("&&");if(h.length>1)for(var i=0;i<h.length;++i){var j=a._SimplifyNegation(h[i].trim());if(d="true"!==j&&"false"!==j?"!"===j[0]?!c(j.substring(1)):c(j):"true"===j?!0:!1,!d){g="false";break}}if(d||"true"===g){d=!0;break}d="true"!==g&&"false"!==g?"!"===g[0]?!c(g.substring(1)):c(g):"true"===g?!0:!1}return d?"true":"false"},a._SimplifyNegation=function(a){return a=a.replace(/^[\s!]+/,function(a){return a=a.replace(/[\s]/g,function(){return""}),a.length%2?"!":""}),a=a.trim(),"!true"===a?a="false":"!false"===a&&(a="true"),a},a}();a.AndOrNotEvaluator=b}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b,c,d,e,f,g){this._enabled=!0,this._refCount=0,this._name=c,this._renderTexture=new a.RenderTargetTexture(c,d,b),this.setRenderList(e),this._renderTexture.onBeforeRender=f,this._renderTexture.onAfterRender=g,this._scene=b}return b.prototype._incRefCount=function(){return 0===this._refCount&&this._scene.customRenderTargets.push(this._renderTexture),++this._refCount},b.prototype._decRefCount=function(){return this._refCount--,this._refCount<=0&&this._scene.customRenderTargets.splice(this._scene.customRenderTargets.indexOf(this._renderTexture),1),this._refCount},b.prototype._update=function(){this.setRenderList(this._renderList)},b.prototype.setRenderList=function(a){this._renderTexture.renderList=a},b.prototype.getRenderTexture=function(){return this._renderTexture},b}();a.PostProcessRenderPass=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b,c,d,e,f){this._engine=a,this._name=b,this._postProcessType=c,this._ratio=d||1,this._samplingMode=e||null,this._singleInstance=f||!0,this._cameras=[],this._postProcesses=[],this._indicesForCamera=[],this._renderPasses=[],this._renderEffectAsPasses=[],this.parameters=function(){}}return b._GetInstance=function(a,c,d,e){for(var f,g,h=[],i=b._GetParametersNames(c),j=0;j<i.length;j++)switch(i[j]){case"name":h[j]=c.toString();break;case"ratio":h[j]=d;break;case"camera":h[j]=null;break;case"samplingMode":h[j]=e;break;case"engine":h[j]=a;break;case"reusable":h[j]=!0;break;default:h[j]=null}return f=function(){},f.prototype=c.prototype,g=new f,c.apply(g,h),g},b._GetParametersNames=function(a){var b=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,c=a.toString().replace(b,""),d=c.slice(c.indexOf("(")+1,c.indexOf(")")).match(/([^\s,]+)/g);return null===d&&(d=[]),d},b.prototype._update=function(){for(var a in this._renderPasses)this._renderPasses[a]._update()},b.prototype.addPass=function(a){this._renderPasses[a._name]=a,this._linkParameters()},b.prototype.removePass=function(a){delete this._renderPasses[a._name],this._linkParameters()},b.prototype.addRenderEffectAsPass=function(a){this._renderEffectAsPasses[a._name]=a,this._linkParameters()},b.prototype.getPass=function(a){for(var b in this._renderPasses)if(b===a)return this._renderPasses[a]},b.prototype.emptyPasses=function(){this._renderPasses.length=0,this._linkParameters()},b.prototype._attachCameras=function(c){for(var d,e=a.Tools.MakeArray(c||this._cameras),f=0;f<e.length;f++){var g=e[f],h=g.name;d=this._singleInstance?0:h,this._postProcesses[d]=this._postProcesses[d]||b._GetInstance(this._engine,this._postProcessType,this._ratio,this._samplingMode);var i=g.attachPostProcess(this._postProcesses[d]);null===this._indicesForCamera[h]&&(this._indicesForCamera[h]=[]),this._indicesForCamera[h].push(i),-1===this._cameras.indexOf(g)&&(this._cameras[h]=g);for(var j in this._renderPasses)this._renderPasses[j]._incRefCount()}this._linkParameters()},b.prototype._detachCameras=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){var e=c[d],f=e.name;e.detachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f]);var g=this._cameras.indexOf(f);this._indicesForCamera.splice(g,1),this._cameras.splice(g,1);for(var h in this._renderPasses)this._renderPasses[h]._decRefCount()}},b.prototype._enable=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){for(var e=c[d],f=e.name,g=0;g<this._indicesForCamera[f].length;g++)void 0===e._postProcesses[this._indicesForCamera[f][g]]&&b[d].attachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f][g]);for(var h in this._renderPasses)this._renderPasses[h]._incRefCount()}},b.prototype._disable=function(b){for(var c=a.Tools.MakeArray(b||this._cameras),d=0;d<c.length;d++){var e=c[d],f=e.Name;e.detachPostProcess(this._postProcesses[this._singleInstance?0:f],this._indicesForCamera[f]);for(var g in this._renderPasses)this._renderPasses[g]._decRefCount()}},b.prototype.getPostProcess=function(a){return this._singleInstance?this._postProcesses[0]:this._postProcesses[a.name]},b.prototype._linkParameters=function(){var a=this;for(var b in this._postProcesses)this._postProcesses[b].onApply=function(b){a.parameters(b),a._linkTextures(b)}},b.prototype._linkTextures=function(a){for(var b in this._renderPasses)a.setTexture(b,this._renderPasses[b].getRenderTexture());for(var c in this._renderEffectAsPasses)a.setTextureFromPostProcess(c+"Sampler",this._renderEffectAsPasses[c].getPostProcess())},b}();a.PostProcessRenderEffect=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(a,b){this._engine=a,this._name=b,this._renderEffects=[],this._renderEffectsForIsolatedPass=[],this._cameras=[]}return b.prototype.addEffect=function(a){this._renderEffects[a._name]=a},b.prototype._enableEffect=function(b,c){var d=this._renderEffects[b];d&&d.enable(a.Tools.MakeArray(c||this._cameras))},b.prototype._disableEffect=function(b,c){var d=this._renderEffects[b];d&&d.disable(a.Tools.MakeArray(c||this._cameras))},b.prototype._attachCameras=function(b,c){for(var d=a.Tools.MakeArray(b||this._cameras),e=[],f=0;f<d.length;f++){var g=d[f],h=g.name;-1===this._cameras.indexOf(g)?this._cameras[h]=g:c&&e.push(f)}for(var f=0;f<e.length;f++)b.splice(e[f],1);for(var i in this._renderEffects)this._renderEffects[i]._attachCameras(d)},b.prototype._detachCameras=function(b){var c=a.Tools.MakeArray(b||this._cameras);for(var d in this._renderEffects)this._renderEffects[d]._detachCameras(c);for(var e=0;e<c.length;e++)this._cameras.splice(this._cameras.indexOf(c[e]),1)},b.prototype._enableDisplayOnlyPass=function(c,d){var e=a.Tools.MakeArray(d||this._cameras),f=null;for(var g in this._renderEffects)if(f=this._renderEffects[g].getPass(c),null!=f)break;if(null!==f){for(var g in this._renderEffects)this._renderEffects[g]._disable(e);f._name=b.PASS_SAMPLER_NAME;for(var h=0;h<e.length;h++){var i=e[h],j=i.name;this._renderEffectsForIsolatedPass[j]=this._renderEffectsForIsolatedPass[j]||new a.PostProcessRenderEffect(this._engine,b.PASS_EFFECT_NAME,"BABYLON.DisplayPassPostProcess",1,null,null),this._renderEffectsForIsolatedPass[j].emptyPasses(),this._renderEffectsForIsolatedPass[j].addPass(f),this._renderEffectsForIsolatedPass[j]._attachCameras(i)}}},b.prototype._disableDisplayOnlyPass=function(c){for(var d=a.Tools.MakeArray(c||this._cameras),e=0;e<d.length;e++){var f=d[e],g=f.name;this._renderEffectsForIsolatedPass[g]=this._renderEffectsForIsolatedPass[g]||new a.PostProcessRenderEffect(this._engine,b.PASS_EFFECT_NAME,"BABYLON.DisplayPassPostProcess",1,null,null),this._renderEffectsForIsolatedPass[g]._disable(f)}for(var h in this._renderEffects)this._renderEffects[h]._enable(d)},b.prototype._update=function(){for(var a in this._renderEffects)this._renderEffects[a]._update();for(var b=0;b<this._cameras.length;b++){var c=this._cameras[b].name;this._renderEffectsForIsolatedPass[c]&&this._renderEffectsForIsolatedPass[c]._update()}},b.PASS_EFFECT_NAME="passEffect",b.PASS_SAMPLER_NAME="passSampler",b}();a.PostProcessRenderPipeline=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(){this._renderPipelines=[]}return a.prototype.addPipeline=function(a){this._renderPipelines[a._name]=a},a.prototype.attachCamerasToRenderPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.attachCameras(b,c)},a.prototype.detachCamerasFromRenderPipeline=function(a,b){var c=this._renderPipelines[a];c&&c.detachCameras(b)},a.prototype.enableEffectInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.enableEffect(b,c)},a.prototype.disableEffectInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.disableEffect(b,c)},a.prototype.enableDisplayOnlyPassInPipeline=function(a,b,c){var d=this._renderPipelines[a];d&&d.enableDisplayOnlyPass(b,c)},a.prototype.disableDisplayOnlyPassInPipeline=function(a,b){var c=this._renderPipelines[a];c&&c.disableDisplayOnlyPass(b)},a.prototype.update=function(){for(var a in this._renderPipelines)this._renderPipelines[a]._update()},a}();a.PostProcessRenderPipelineManager=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e,f,g){a.call(this,b,"displayPass",["passSampler"],["passSampler"],c,d,e,f,g)}return __extends(b,a),b}(a.PostProcess);a.DisplayPassPostProcess=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(b){this.frontColor=new a.Color3(1,1,1),this.backColor=new a.Color3(.1,.1,.1),this.showBackLines=!0,this.renderList=new a.SmartArray(32),this._scene=b,this._colorShader=new a.ShaderMaterial("colorShader",b,"color",{attributes:["position"],uniforms:["worldViewProjection","color"]});var c=this._scene.getEngine(),d=a.VertexData.CreateBox(1);this._vb=new a.VertexBuffer(c,d.positions,a.VertexBuffer.PositionKind,!1),this._ib=c.createIndexBuffer([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,7,1,6,2,5,3,4])}return b.prototype.reset=function(){this.renderList.reset()},b.prototype.render=function(){if(0!=this.renderList.length&&this._colorShader.isReady()){var b=this._scene.getEngine();b.setDepthWrite(!1),this._colorShader._preBind();for(var c=0;c<this.renderList.length;c++){var d=this.renderList.data[c],e=d.minimum,f=d.maximum,g=f.subtract(e),h=e.add(g.scale(.5)),i=a.Matrix.Scaling(g.x,g.y,g.z).multiply(a.Matrix.Translation(h.x,h.y,h.z)).multiply(d.getWorldMatrix());b.bindBuffers(this._vb.getBuffer(),this._ib,[3],12,this._colorShader.getEffect()),this.showBackLines&&(b.setDepthFunctionToGreaterOrEqual(),this._colorShader.setColor3("color",this.backColor),this._colorShader.bind(i),b.draw(!1,0,24)),b.setDepthFunctionToLess(),this._colorShader.setColor3("color",this.frontColor),this._colorShader.bind(i),b.draw(!1,0,24)}this._colorShader.unbind(),b.setDepthFunctionToLessOrEqual(),b.setDepthWrite(!0)}},b.prototype.dispose=function(){this._colorShader.dispose(),this._vb.dispose(),this._scene.getEngine()._releaseBuffer(this._ib)},b}();a.BoundingBoxRenderer=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(b){var c=function(){function b(){}return b.GetTGAHeader=function(a){var b=0,c={id_length:a[b++],colormap_type:a[b++],image_type:a[b++],colormap_index:a[b++]|a[b++]<<8,colormap_length:a[b++]|a[b++]<<8,colormap_size:a[b++],origin:[a[b++]|a[b++]<<8,a[b++]|a[b++]<<8],width:a[b++]|a[b++]<<8,height:a[b++]|a[b++]<<8,pixel_size:a[b++],flags:a[b++]};return c},b.UploadContent=function(c,d){if(d.length<19)return void a.Tools.Error("Unable to load TGA file - Not enough data to contain header");var e=18,f=b.GetTGAHeader(d);if(f.id_length+e>d.length)return void a.Tools.Error("Unable to load TGA file - Not enough data");e+=f.id_length;var g=!1,h=!1,i=!1,j=!1;switch(f.image_type){case b._TYPE_RLE_INDEXED:g=!0;case b._TYPE_INDEXED:h=!0;break;case b._TYPE_RLE_RGB:g=!0;case b._TYPE_RGB:i=!0;break;case b._TYPE_RLE_GREY:g=!0;case b._TYPE_GREY:j=!0}var k,l,m=(15&f.flags,f.pixel_size>>3),n=f.width*f.height*m;if(h&&(l=d.subarray(e,e+=f.colormap_length*(f.colormap_size>>3))),g){k=new Uint8Array(n);for(var o,p,q,r=0,s=new Uint8Array(m);n>e;)if(o=d[e++],p=(127&o)+1,128&o){for(q=0;m>q;++q)s[q]=d[e++];for(q=0;p>q;++q)k.set(s,r+q*m);r+=m*p}else{for(p*=m,q=0;p>q;++q)k[r+q]=d[e++];r+=p}}else k=d.subarray(e,e+=h?f.width*f.height:n);var t,u,v,w,x,y;switch((f.flags&b._ORIGIN_MASK)>>b._ORIGIN_SHIFT){default:case b._ORIGIN_UL:t=0,v=1,y=f.width,u=0,w=1,x=f.height;break;case b._ORIGIN_BL:t=0,v=1,y=f.width,u=f.height-1,w=-1,x=-1;break;case b._ORIGIN_UR:t=f.width-1,v=-1,y=-1,u=0,w=1,x=f.height;break;case b._ORIGIN_BR:t=f.width-1,v=-1,y=-1,u=f.height-1,w=-1,x=-1}var z="_getImageData"+(j?"Grey":"")+f.pixel_size+"bits",A=b[z](f,l,k,u,w,x,t,v,y);c.texImage2D(c.TEXTURE_2D,0,c.RGBA,f.width,f.height,0,c.RGBA,c.UNSIGNED_BYTE,A)},b._getImageData8bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=b,o=a.width,p=a.height,q=0,r=new Uint8Array(o*p*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,q++)j=m[q],r[4*(k+o*l)+3]=255,r[4*(k+o*l)+2]=n[3*j+0],r[4*(k+o*l)+1]=n[3*j+1],r[4*(k+o*l)+0]=n[3*j+2];return r},b._getImageData16bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=a.width,o=a.height,p=0,q=new Uint8Array(n*o*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,p+=2)j=m[p+0]+(m[p+1]<<8),q[4*(k+n*l)+0]=(31744&j)>>7,q[4*(k+n*l)+1]=(992&j)>>2,q[4*(k+n*l)+2]=(31&j)>>3,q[4*(k+n*l)+3]=32768&j?0:255;return q},b._getImageData24bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=3)p[4*(j+m*k)+3]=255,p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+1]=l[o+1],p[4*(j+m*k)+0]=l[o+2];return p},b._getImageData32bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=4)p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+1]=l[o+1],p[4*(j+m*k)+0]=l[o+2],p[4*(j+m*k)+3]=l[o+3];return p},b._getImageDataGrey8bits=function(a,b,c,d,e,f,g,h,i){var j,k,l,m=c,n=a.width,o=a.height,p=0,q=new Uint8Array(n*o*4);for(l=d;l!==f;l+=e)for(k=g;k!==i;k+=h,p++)j=m[p],q[4*(k+n*l)+0]=j,q[4*(k+n*l)+1]=j,q[4*(k+n*l)+2]=j,q[4*(k+n*l)+3]=255;return q},b._getImageDataGrey16bits=function(a,b,c,d,e,f,g,h,i){var j,k,l=c,m=a.width,n=a.height,o=0,p=new Uint8Array(m*n*4);for(k=d;k!==f;k+=e)for(j=g;j!==i;j+=h,o+=2)p[4*(j+m*k)+0]=l[o+0],p[4*(j+m*k)+1]=l[o+0],p[4*(j+m*k)+2]=l[o+0],p[4*(j+m*k)+3]=l[o+1];return p},b._TYPE_NO_DATA=0,b._TYPE_INDEXED=1,b._TYPE_RGB=2,b._TYPE_GREY=3,b._TYPE_RLE_INDEXED=9,b._TYPE_RLE_RGB=10,b._TYPE_RLE_GREY=11,b._ORIGIN_MASK=48,b._ORIGIN_SHIFT=4,b._ORIGIN_BL=0,b._ORIGIN_BR=1,b._ORIGIN_UL=2,b._ORIGIN_UR=3,b}();b.TGATools=c}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){!function(b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}function d(a){return String.fromCharCode(255&a,a>>8&255,a>>16&255,a>>24&255)}var e=542327876,f=131072,g=512,h=4,i=64,j=131072,k=c("DXT1"),l=c("DXT3"),m=c("DXT5"),n=31,o=0,p=1,q=2,r=3,s=4,t=7,u=20,v=21,w=22,x=28,y=function(){function b(){}return b.GetDDSInfo=function(a){var b=new Int32Array(a,0,n),c=1;return b[q]&f&&(c=Math.max(1,b[t])),{width:b[s],height:b[r],mipmapCount:c,isFourCC:(b[u]&h)===h,isRGB:(b[u]&i)===i,isLuminance:(b[u]&j)===j,isCube:(b[x]&g)===g}},b.GetRGBAArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+4*(j+i*a);f[h+2]=g[k],f[h+1]=g[k+1],f[h]=g[k+2],f[h+3]=g[k+3],h+=4}return f},b.GetRGBArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+3*(j+i*a);f[h+2]=g[k],f[h+1]=g[k+1],f[h]=g[k+2],h+=3}return f},b.GetLuminanceArrayBuffer=function(a,b,c,d,e){for(var f=new Uint8Array(d),g=new Uint8Array(e),h=0,i=b-1;i>=0;i--)for(var j=0;a>j;j++){var k=c+(j+i*a);f[h]=g[k],h++}return f},b.UploadDDSLevels=function(c,g,h,i,j,u){var x,y,z,A,B,C,D,E,F,G,H=new Int32Array(h,0,n);if(H[o]!=e)return void a.Tools.Error("Invalid magic number in DDS header");if(!i.isFourCC&&!i.isRGB&&!i.isLuminance)return void a.Tools.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(i.isFourCC)switch(x=H[v]){case k:y=8,z=g.COMPRESSED_RGBA_S3TC_DXT1_EXT;break;case l:y=16,z=g.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case m:y=16,z=g.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;default:return void console.error("Unsupported FourCC code:",d(x))}F=1,H[q]&f&&j!==!1&&(F=Math.max(1,H[t]));for(var I=H[w],J=0;u>J;J++){var K=1==u?c.TEXTURE_2D:c.TEXTURE_CUBE_MAP_POSITIVE_X+J;for(A=H[s],B=H[r],D=H[p]+4,G=0;F>G;++G){if(i.isRGB)24==I?(C=A*B*3,E=b.GetRGBArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.RGB,A,B,0,c.RGB,c.UNSIGNED_BYTE,E)):(C=A*B*4,E=b.GetRGBAArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.RGBA,A,B,0,c.RGBA,c.UNSIGNED_BYTE,E));else if(i.isLuminance){var L=c.getParameter(c.UNPACK_ALIGNMENT),M=A,N=Math.floor((A+L-1)/L)*L;C=N*(B-1)+M,E=b.GetLuminanceArrayBuffer(A,B,D,C,h),c.texImage2D(K,G,c.LUMINANCE,A,B,0,c.LUMINANCE,c.UNSIGNED_BYTE,E)}else C=Math.max(4,A)/4*Math.max(4,B)/4*y,E=new Uint8Array(h,D,C),c.compressedTexImage2D(K,G,z,A,B,0,E);D+=C,A*=.5,B*=.5,A=Math.max(1,A),B=Math.max(1,B)}}},b}();b.DDSTools=y}(a.Internals||(a.Internals={}));a.Internals}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(b){this.length=0,this._duplicateId=0,this.data=new Array(b),this._id=a._GlobalId++}return a.prototype.push=function(a){this.data[this.length++]=a,this.length>this.data.length&&(this.data.length*=2),a.__smartArrayFlags||(a.__smartArrayFlags={}),a.__smartArrayFlags[this._id]=this._duplicateId},a.prototype.pushNoDuplicate=function(a){a.__smartArrayFlags&&a.__smartArrayFlags[this._id]===this._duplicateId||this.push(a)
},a.prototype.sort=function(a){this.data.sort(a)},a.prototype.reset=function(){this.length=0,this._duplicateId++},a.prototype.concat=function(a){if(0!==a.length){this.length+a.length>this.data.length&&(this.data.length=2*(this.length+a.length));for(var b=0;b<a.length;b++)this.data[this.length++]=(a.data||a)[b]}},a.prototype.concatWithNoDuplicate=function(a){if(0!==a.length){this.length+a.length>this.data.length&&(this.data.length=2*(this.length+a.length));for(var b=0;b<a.length;b++){var c=(a.data||a)[b];this.pushNoDuplicate(c)}}},a.prototype.indexOf=function(a){var b=this.data.indexOf(a);return b>=this.length?-1:b},a._GlobalId=0,a}();a.SmartArray=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function b(){this._registeredMeshes=[],this._physicsMaterials=[],this.updateBodyPosition=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a||c.mesh===a.parent){var d=c.body.body;return d.position.set(a.position.x,a.position.z,a.position.y),d.quaternion.x=a.rotationQuaternion.x,d.quaternion.z=a.rotationQuaternion.y,d.quaternion.y=a.rotationQuaternion.z,void(d.quaternion.w=-a.rotationQuaternion.w)}}}}return b.prototype.initialize=function(a){"undefined"==typeof a&&(a=10),this._world=new CANNON.World,this._world.broadphase=new CANNON.NaiveBroadphase,this._world.solver.iterations=a},b.prototype._checkWithEpsilon=function(b){return b<a.PhysicsEngine.Epsilon?a.PhysicsEngine.Epsilon:b},b.prototype.runOneStep=function(b){this._world.step(b);for(var c=0;c<this._registeredMeshes.length;c++){var d=this._registeredMeshes[c];d.isChild||(d.mesh.position.x=d.body.position.x,d.mesh.position.y=d.body.position.z,d.mesh.position.z=d.body.position.y,d.mesh.rotationQuaternion||(d.mesh.rotationQuaternion=new a.Quaternion(0,0,0,1)),d.mesh.rotationQuaternion.x=d.body.quaternion.x,d.mesh.rotationQuaternion.y=d.body.quaternion.z,d.mesh.rotationQuaternion.z=d.body.quaternion.y,d.mesh.rotationQuaternion.w=-d.body.quaternion.w)}},b.prototype.setGravity=function(a){this._world.gravity.set(a.x,a.z,a.y)},b.prototype.registerMesh=function(b,c,d){switch(this.unregisterMesh(b),b.computeWorldMatrix(!0),c){case a.PhysicsEngine.SphereImpostor:var e=b.getBoundingInfo().boundingBox,f=e.maximumWorld.x-e.minimumWorld.x,g=e.maximumWorld.y-e.minimumWorld.y,h=e.maximumWorld.z-e.minimumWorld.z;return this._createSphere(Math.max(this._checkWithEpsilon(f),this._checkWithEpsilon(g),this._checkWithEpsilon(h))/2,b,d);case a.PhysicsEngine.BoxImpostor:e=b.getBoundingInfo().boundingBox;var i=e.minimumWorld,j=e.maximumWorld,k=j.subtract(i).scale(.5);return this._createBox(this._checkWithEpsilon(k.x),this._checkWithEpsilon(k.y),this._checkWithEpsilon(k.z),b,d);case a.PhysicsEngine.PlaneImpostor:return this._createPlane(b,d);case a.PhysicsEngine.MeshImpostor:var l=b.getVerticesData(a.VertexBuffer.PositionKind),m=b.getIndices();return this._createConvexPolyhedron(l,m,b,d)}return null},b.prototype._createSphere=function(a,b,c){var d=new CANNON.Sphere(a);return c?this._createRigidBodyFromShape(d,b,c.mass,c.friction,c.restitution):d},b.prototype._createBox=function(a,b,c,d,e){var f=new CANNON.Box(new CANNON.Vec3(a,c,b));return e?this._createRigidBodyFromShape(f,d,e.mass,e.friction,e.restitution):f},b.prototype._createPlane=function(a,b){var c=new CANNON.Plane;return b?this._createRigidBodyFromShape(c,a,b.mass,b.friction,b.restitution):c},b.prototype._createConvexPolyhedron=function(b,c,d,e){var f=[],g=[];d.computeWorldMatrix(!0);for(var h=0;h<b.length;h+=3){var i=a.Vector3.Zero();a.Vector3.TransformNormalFromFloatsToRef(b[h],b[h+1],b[h+2],d.getWorldMatrix(),i),f.push(new CANNON.Vec3(i.x,i.z,i.y))}for(var j=0;j<c.length;j+=3)g.push([c[j],c[j+2],c[j+1]]);var k=new CANNON.ConvexPolyhedron(f,g);return e?this._createRigidBodyFromShape(k,d,e.mass,e.friction,e.restitution):k},b.prototype._addMaterial=function(a,b){var c,d;for(c=0;c<this._physicsMaterials.length;c++)if(d=this._physicsMaterials[c],d.friction===a&&d.restitution===b)return d;var e=new CANNON.Material;for(e.friction=a,e.restitution=b,this._physicsMaterials.push(e),c=0;c<this._physicsMaterials.length;c++){d=this._physicsMaterials[c];var f=new CANNON.ContactMaterial(d,e,d.friction*e.friction,d.restitution*e.restitution);f.contactEquationStiffness=1e10,f.contactEquationRegularizationTime=10,this._world.addContactMaterial(f)}return e},b.prototype._createRigidBodyFromShape=function(b,c,d,e,f){var g=null;c.rotationQuaternion&&(g=c.rotationQuaternion.clone(),c.rotationQuaternion=new a.Quaternion(0,0,0,1));var h=this._addMaterial(e,f),i=new CANNON.RigidBody(d,b,h);return g&&(i.quaternion.x=g.x,i.quaternion.z=g.y,i.quaternion.y=g.z,i.quaternion.w=-g.w),i.position.set(c.position.x,c.position.z,c.position.y),this._world.add(i),this._registeredMeshes.push({mesh:c,body:i,material:h}),i},b.prototype.registerMeshesAsCompound=function(a,b){for(var c=new CANNON.Compound,d=0;d<a.length;d++){var e=a[d].mesh,f=this.registerMesh(e,a[d].impostor);0==d?c.addChild(f,new CANNON.Vec3(0,0,0)):c.addChild(f,new CANNON.Vec3(e.position.x,e.position.z,e.position.y))}var g=a[0].mesh,h=this._createRigidBodyFromShape(c,g,b.mass,b.friction,b.restitution);return h.parts=a,h},b.prototype._unbindBody=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];c.body===a&&(c.body=null)}},b.prototype.unregisterMesh=function(a){for(var b=0;b<this._registeredMeshes.length;b++){var c=this._registeredMeshes[b];if(c.mesh===a)return c.body&&(this._world.remove(c.body),this._unbindBody(c.body)),void this._registeredMeshes.splice(b,1)}},b.prototype.applyImpulse=function(a,b,c){for(var d=new CANNON.Vec3(c.x,c.z,c.y),e=new CANNON.Vec3(b.x,b.z,b.y),f=0;f<this._registeredMeshes.length;f++){var g=this._registeredMeshes[f];if(g.mesh===a)return void g.body.applyImpulse(e,d)}},b.prototype.createLink=function(a,b,c,d){for(var e=null,f=null,g=0;g<this._registeredMeshes.length;g++){var h=this._registeredMeshes[g];h.mesh===a?e=h.body:h.mesh===b&&(f=h.body)}if(!e||!f)return!1;var i=new CANNON.PointToPointConstraint(e,new CANNON.Vec3(c.x,c.z,c.y),f,new CANNON.Vec3(d.x,d.z,d.y));return this._world.addConstraint(i),!0},b.prototype.dispose=function(){for(;this._registeredMeshes.length;)this.unregisterMesh(this._registeredMeshes[0].mesh)},b.prototype.isSupported=function(){return void 0!==window.CANNON},b}();a.CannonJSPlugin=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function a(a){this._actionManager=a}return a.prototype.isValid=function(){return!0},a.prototype._getProperty=function(a){return this._actionManager._getProperty(a)},a.prototype._getEffectiveTarget=function(a,b){return this._actionManager._getEffectiveTarget(a,b)},a}();a.Condition=b;var c=function(a){function b(c,d,e,f,g){"undefined"==typeof g&&(g=b.IsEqual),a.call(this,c),this.propertyPath=e,this.value=f,this.operator=g,this._target=this._getEffectiveTarget(d,this.propertyPath),this._property=this._getProperty(this.propertyPath)}return __extends(b,a),Object.defineProperty(b,"IsEqual",{get:function(){return b._IsEqual},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsDifferent",{get:function(){return b._IsDifferent},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsGreater",{get:function(){return b._IsGreater},enumerable:!0,configurable:!0}),Object.defineProperty(b,"IsLesser",{get:function(){return b._IsLesser},enumerable:!0,configurable:!0}),b.prototype.isValid=function(){switch(this.operator){case b.IsGreater:return this._target[this._property]>this.value;case b.IsLesser:return this._target[this._property]<this.value;case b.IsEqual:case b.IsDifferent:var a;return a=this.value.equals?this.value.equals(this._target[this._property]):this.value===this._target[this._property],this.operator===b.IsEqual?a:!a}return!1},b._IsEqual=0,b._IsDifferent=1,b._IsGreater=2,b._IsLesser=3,b}(b);a.ValueCondition=c;var d=function(a){function b(b,c){a.call(this,b),this.predicate=c}return __extends(b,a),b.prototype.isValid=function(){return this.predicate()},b}(b);a.PredicateCondition=d;var e=function(a){function b(b,c,d){a.call(this,b),this.value=d,this._target=c}return __extends(b,a),b.prototype.isValid=function(){return this._target.state===this.value},b}(b);a.StateCondition=e}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b){this.triggerOptions=a,a.parameter?(this.trigger=a.trigger,this._triggerParameter=a.parameter):this.trigger=a,this._nextActiveAction=this,this._condition=b}return a.prototype._prepare=function(){},a.prototype.getTriggerParameter=function(){return this._triggerParameter},a.prototype._executeCurrent=function(a){if(this._condition){var b=this._actionManager.getScene().getRenderId();if(this._condition._evaluationId===b){if(!this._condition._currentResult)return}else{if(this._condition._evaluationId=b,!this._condition.isValid())return void(this._condition._currentResult=!1);this._condition._currentResult=!0}}this._nextActiveAction.execute(a),this._nextActiveAction=this._nextActiveAction._child?this._nextActiveAction._child:this},a.prototype.execute=function(){},a.prototype.then=function(a){return this._child=a,a._actionManager=this._actionManager,a._prepare(),a},a.prototype._getProperty=function(a){return this._actionManager._getProperty(a)},a.prototype._getEffectiveTarget=function(a,b){return this._actionManager._getEffectiveTarget(a,b)},a}();a.Action=b}(BABYLON||(BABYLON={}));var BABYLON;!function(a){var b=function(){function a(a,b,c,d,e){this.source=a,this.pointerX=b,this.pointerY=c,this.meshUnderPointer=d,this.sourceEvent=e}return a.CreateNew=function(b){var c=b.getScene();return new a(b,c.pointerX,c.pointerY,c.meshUnderPointer)},a.CreateNewFromScene=function(b,c){return new a(null,b.pointerX,b.pointerY,b.meshUnderPointer,c)},a}();a.ActionEvent=b;var c=function(){function b(a){this.actions=new Array,this._scene=a,a._actionManagers.push(this)}return Object.defineProperty(b,"NothingTrigger",{get:function(){return b._NothingTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPickTrigger",{get:function(){return b._OnPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnLeftPickTrigger",{get:function(){return b._OnLeftPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnRightPickTrigger",{get:function(){return b._OnRightPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnCenterPickTrigger",{get:function(){return b._OnCenterPickTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPointerOverTrigger",{get:function(){return b._OnPointerOverTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnPointerOutTrigger",{get:function(){return b._OnPointerOutTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnEveryFrameTrigger",{get:function(){return b._OnEveryFrameTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnIntersectionEnterTrigger",{get:function(){return b._OnIntersectionEnterTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnIntersectionExitTrigger",{get:function(){return b._OnIntersectionExitTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnKeyDownTrigger",{get:function(){return b._OnKeyDownTrigger},enumerable:!0,configurable:!0}),Object.defineProperty(b,"OnKeyUpTrigger",{get:function(){return b._OnKeyUpTrigger},enumerable:!0,configurable:!0}),b.prototype.dispose=function(){var a=this._scene._actionManagers.indexOf(this);a>-1&&this._scene._actionManagers.splice(a,1)},b.prototype.getScene=function(){return this._scene},b.prototype.hasSpecificTriggers=function(a){for(var b=0;b<this.actions.length;b++){var c=this.actions[b];if(a.indexOf(c.trigger)>-1)return!0}return!1},Object.defineProperty(b.prototype,"hasPointerTriggers",{get:function(){for(var a=0;a<this.actions.length;a++){var c=this.actions[a];if(c.trigger>=b._OnPickTrigger&&c.trigger<=b._OnPointerOutTrigger)return!0}return!1},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"hasPickTriggers",{get:function(){for(var a=0;a<this.actions.length;a++){var c=this.actions[a];if(c.trigger>=b._OnPickTrigger&&c.trigger<=b._OnCenterPickTrigger)return!0}return!1},enumerable:!0,configurable:!0}),b.prototype.registerAction=function(c){return c.trigger===b.OnEveryFrameTrigger&&this.getScene().actionManager!==this?(a.Tools.Warn("OnEveryFrameTrigger can only be used with scene.actionManager"),null):(this.actions.push(c),c._actionManager=this,c._prepare(),c)},b.prototype.processTrigger=function(a,c){for(var d=0;d<this.actions.length;d++){var e=this.actions[d];if(e.trigger===a){if(a==b.OnKeyUpTrigger||a==b.OnKeyDownTrigger){var f=e.getTriggerParameter();if(f&&c.sourceEvent.key!==f)continue}e._executeCurrent(c)}}},b.prototype._getEffectiveTarget=function(a,b){for(var c=b.split("."),d=0;d<c.length-1;d++)a=a[c[d]];return a},b.prototype._getProperty=function(a){var b=a.split(".");return b[b.length-1]},b._NothingTrigger=0,b._OnPickTrigger=1,b._OnLeftPickTrigger=2,b._OnRightPickTrigger=3,b._OnCenterPickTrigger=4,b._OnPointerOverTrigger=5,b._OnPointerOutTrigger=6,b._OnEveryFrameTrigger=7,b._OnIntersectionEnterTrigger=8,b._OnIntersectionExitTrigger=9,b._OnKeyDownTrigger=10,b._OnKeyUpTrigger=11,b}();a.ActionManager=c}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(a,c,d,e,f,g,h){"undefined"==typeof f&&(f=1e3),b.call(this,a,g),this.propertyPath=d,this.value=e,this.duration=f,this.stopOtherAnimations=h,this._target=c}return __extends(c,b),c.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},c.prototype.execute=function(){var b,c=this._actionManager.getScene(),d=[{frame:0,value:this._target[this._property]},{frame:100,value:this.value}];if("number"==typeof this.value)b=a.Animation.ANIMATIONTYPE_FLOAT;else if(this.value instanceof a.Color3)b=a.Animation.ANIMATIONTYPE_COLOR3;else if(this.value instanceof a.Vector3)b=a.Animation.ANIMATIONTYPE_VECTOR3;else if(this.value instanceof a.Matrix)b=a.Animation.ANIMATIONTYPE_MATRIX;else{if(!(this.value instanceof a.Quaternion))return void a.Tools.Warn("InterpolateValueAction: Unsupported type ("+typeof this.value+")");b=a.Animation.ANIMATIONTYPE_QUATERNION}var e=new a.Animation("InterpolateValueAction",this._property,100*(1e3/this.duration),b,a.Animation.ANIMATIONLOOPMODE_CONSTANT);e.setKeys(d),this.stopOtherAnimations&&c.stopAnimation(this._target),c.beginDirectAnimation(this._target,[e],0,100)},c}(a.Action);a.InterpolateValueAction=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(a){function b(b,c,d,e){a.call(this,b,e),this.propertyPath=d,this._target=c}return __extends(b,a),b.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},b.prototype.execute=function(){this._target[this._property]=!this._target[this._property]},b}(a.Action);a.SwitchBooleanAction=b;var c=function(a){function b(b,c,d,e){a.call(this,b,e),this.value=d,this._target=c}return __extends(b,a),b.prototype.execute=function(){this._target.state=this.value},b}(a.Action);a.SetStateAction=c;var d=function(a){function b(b,c,d,e,f){a.call(this,b,f),this.propertyPath=d,this.value=e,this._target=c}return __extends(b,a),b.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath)},b.prototype.execute=function(){this._target[this._property]=this.value},b}(a.Action);a.SetValueAction=d;var e=function(b){function c(a,c,d,e,f){b.call(this,a,f),this.propertyPath=d,this.value=e,this._target=c}return __extends(c,b),c.prototype._prepare=function(){this._target=this._getEffectiveTarget(this._target,this.propertyPath),this._property=this._getProperty(this.propertyPath),"number"!=typeof this._target[this._property]&&a.Tools.Warn("Warning: IncrementValueAction can only be used with number values")},c.prototype.execute=function(){this._target[this._property]+=this.value},c}(a.Action);a.IncrementValueAction=e;var f=function(a){function b(b,c,d,e,f,g){a.call(this,b,g),this.from=d,this.to=e,this.loop=f,this._target=c}return __extends(b,a),b.prototype._prepare=function(){},b.prototype.execute=function(){var a=this._actionManager.getScene();a.beginAnimation(this._target,this.from,this.to,this.loop)},b}(a.Action);a.PlayAnimationAction=f;var g=function(a){function b(b,c,d){a.call(this,b,d),this._target=c}return __extends(b,a),b.prototype._prepare=function(){},b.prototype.execute=function(){var a=this._actionManager.getScene();a.stopAnimation(this._target)},b}(a.Action);a.StopAnimationAction=g;var h=function(b){function c(c,d){"undefined"==typeof c&&(c=a.ActionManager.NothingTrigger),b.call(this,c,d)}return __extends(c,b),c.prototype.execute=function(){},c}(a.Action);a.DoNothingAction=h;var i=function(a){function b(b,c,d){a.call(this,b,d),this.children=c}return __extends(b,a),b.prototype._prepare=function(){for(var a=0;a<this.children.length;a++)this.children[a]._actionManager=this._actionManager,this.children[a]._prepare()},b.prototype.execute=function(a){for(var b=0;b<this.children.length;b++)this.children[b].execute(a)},b}(a.Action);a.CombineAction=i;var j=function(a){function b(b,c,d){a.call(this,b,d),this.func=c}return __extends(b,a),b.prototype.execute=function(a){this.func(a)},b}(a.Action);a.ExecuteCodeAction=j;var k=function(b){function c(a,c,d,e){b.call(this,a,e),this._target=c,this._parent=d}return __extends(c,b),c.prototype._prepare=function(){},c.prototype.execute=function(){if(this._target.parent!==this._parent){var b=this._parent.getWorldMatrix().clone();b.invert(),this._target.position=a.Vector3.TransformCoordinates(this._target.position,b),this._target.parent=this._parent}},c}(a.Action);a.SetParentAction=k}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function b(b,c,d,e,f){this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this._totalVertices=0,this._indices=[],this.id=b,this._engine=c.getEngine(),this._meshes=[],this._scene=c,d?this.setAllVerticesData(d,e):(this._totalVertices=0,this._indices=[]),f&&this.applyToMesh(f)}return b.prototype.getScene=function(){return this._scene},b.prototype.getEngine=function(){return this._engine},b.prototype.isReady=function(){return this.delayLoadState===a.Engine.DELAYLOADSTATE_LOADED||this.delayLoadState===a.Engine.DELAYLOADSTATE_NONE},b.prototype.setAllVerticesData=function(a,b){a.applyToGeometry(this,b)},b.prototype.setVerticesData=function(b,c,d){if(this._vertexBuffers=this._vertexBuffers||{},this._vertexBuffers[b]&&this._vertexBuffers[b].dispose(),this._vertexBuffers[b]=new a.VertexBuffer(this._engine,c,b,d,0===this._meshes.length),b===a.VertexBuffer.PositionKind){var e=this._vertexBuffers[b].getStrideSize();this._totalVertices=c.length/e;for(var f=a.Tools.ExtractMinAndMax(c,0,this._totalVertices),g=this._meshes,h=g.length,i=0;h>i;i++){var j=g[i];j._resetPointsArrayCache(),j._boundingInfo=new a.BoundingInfo(f.minimum,f.maximum),j._createGlobalSubMesh(),j.computeWorldMatrix(!0)}}},b.prototype.updateVerticesData=function(b,c,d){var e=this.getVertexBuffer(b);if(e&&(e.update(c),b===a.VertexBuffer.PositionKind)){var f;if(d){var g=e.getStrideSize();this._totalVertices=c.length/g,f=a.Tools.ExtractMinAndMax(c,0,this._totalVertices)}for(var h=this._meshes,i=h.length,j=0;i>j;j++){var k=h[j];k._resetPointsArrayCache(),d&&(k._boundingInfo=new a.BoundingInfo(f.minimum,f.maximum))}}},b.prototype.getTotalVertices=function(){return this.isReady()?this._totalVertices:0},b.prototype.getVerticesData=function(a){var b=this.getVertexBuffer(a);return b?b.getData():null},b.prototype.getVertexBuffer=function(a){return this.isReady()?this._vertexBuffers[a]:null},b.prototype.getVertexBuffers=function(){return this.isReady()?this._vertexBuffers:null},b.prototype.isVerticesDataPresent=function(a){return this._vertexBuffers?void 0!==this._vertexBuffers[a]:this._delayInfo?-1!==this._delayInfo.indexOf(a):!1},b.prototype.getVerticesDataKinds=function(){var a=[];if(!this._vertexBuffers&&this._delayInfo)for(var b in this._delayInfo)a.push(b);else for(b in this._vertexBuffers)a.push(b);return a},b.prototype.setIndices=function(a){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=a,0!==this._meshes.length&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices));for(var b=this._meshes,c=b.length,d=0;c>d;d++)b[d]._createGlobalSubMesh()},b.prototype.getTotalIndices=function(){return this.isReady()?this._indices.length:0},b.prototype.getIndices=function(){return this.isReady()?this._indices:null},b.prototype.getIndexBuffer=function(){return this.isReady()?this._indexBuffer:null},b.prototype.releaseForMesh=function(a,b){var c=this._meshes,d=c.indexOf(a);if(-1!==d){for(var e in this._vertexBuffers)this._vertexBuffers[e].dispose();this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer)&&(this._indexBuffer=null),c.splice(d,1),a._geometry=null,0==c.length&&b&&this.dispose()}},b.prototype.applyToMesh=function(a){if(a._geometry!==this){var b=a._geometry;b&&b.releaseForMesh(a);var c=this._meshes;a._geometry=this,this._scene.pushGeometry(this),c.push(a),this.isReady()?this._applyToMesh(a):a._boundingInfo=this._boundingInfo}},b.prototype._applyToMesh=function(b){var c=this._meshes.length;for(var d in this._vertexBuffers)if(1===c&&this._vertexBuffers[d].create(),this._vertexBuffers[d]._buffer.references=c,d===a.VertexBuffer.PositionKind){b._resetPointsArrayCache();var e=a.Tools.ExtractMinAndMax(this._vertexBuffers[d].getData(),0,this._totalVertices);b._boundingInfo=new a.BoundingInfo(e.minimum,e.maximum),b._createGlobalSubMesh()}1===c&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices)),this._indexBuffer&&(this._indexBuffer.references=c)},b.prototype.load=function(b,c){var d=this;if(this.delayLoadState!==a.Engine.DELAYLOADSTATE_LOADING){if(this.isReady())return void(c&&c());this.delayLoadState=a.Engine.DELAYLOADSTATE_LOADING,b._addPendingData(this),a.Tools.LoadFile(this.delayLoadingFile,function(e){d._delayLoadingFunction(JSON.parse(e),d),d.delayLoadState=a.Engine.DELAYLOADSTATE_LOADED,d._delayInfo=[],b._removePendingData(d);for(var f=d._meshes,g=f.length,h=0;g>h;h++)d._applyToMesh(f[h]);c&&c()},function(){},b.database)}},b.prototype.dispose=function(){for(var b=this._meshes,c=b.length,d=0;c>d;d++)this.releaseForMesh(b[d]);this._meshes=[];for(var e in this._vertexBuffers)this._vertexBuffers[e].dispose();this._vertexBuffers=[],this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=a.Engine.DELAYLOADSTATE_NONE,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null;var f=this._scene.getGeometries();d=f.indexOf(this),d>-1&&f.splice(d,1)},b.prototype.copy=function(b){var c=new a.VertexData;c.indices=[];for(var d=this.getIndices(),e=0;e<d.length;e++)c.indices.push(d[e]);var f=!1,g=!1;for(var h in this._vertexBuffers)c.set(this.getVerticesData(h),h),g||(f=this.getVertexBuffer(h).isUpdatable(),g=!f);var i=new a.Geometry(b,this._scene,c,f,null);i.delayLoadState=this.delayLoadState,i.delayLoadingFile=this.delayLoadingFile,i._delayLoadingFunction=this._delayLoadingFunction;for(h in this._delayInfo)i._delayInfo=i._delayInfo||[],i._delayInfo.push(h);var j=a.Tools.ExtractMinAndMax(this.getVerticesData(a.VertexBuffer.PositionKind),0,this.getTotalVertices());return i._boundingInfo=new a.BoundingInfo(j.minimum,j.maximum),i},b.ExtractFromMesh=function(a,b){var c=a._geometry;return c?c.copy(b):null},b.RandomId=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(a){var b=16*Math.random()|0,c="x"==a?b:3&b|8;return c.toString(16)})},b}();a.Geometry=b,function(b){!function(c){var d=function(a){function b(b,c,d,e,f){this._beingRegenerated=!0,this._canBeRegenerated=e,a.call(this,b,c,d,!1,f),this._beingRegenerated=!1}return __extends(b,a),b.prototype.canBeRegenerated=function(){return this._canBeRegenerated},b.prototype.regenerate=function(){this._canBeRegenerated&&(this._beingRegenerated=!0,this.setAllVerticesData(this._regenerateVertexData(),!1),this._beingRegenerated=!1)},b.prototype.asNewGeometry=function(b){return a.prototype.copy.call(this,b)},b.prototype.setAllVerticesData=function(b){this._beingRegenerated&&a.prototype.setAllVerticesData.call(this,b,!1)},b.prototype.setVerticesData=function(b,c){this._beingRegenerated&&a.prototype.setVerticesData.call(this,b,c,!1)},b.prototype._regenerateVertexData=function(){throw new Error("Abstract method")},b.prototype.copy=function(){throw new Error("Must be overriden in sub-classes.")},b}(b);c._Primitive=d;var e=function(b){function c(a,c,d,e,f){this.size=d,b.call(this,a,c,this._regenerateVertexData(),e,f)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateBox(this.size)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.size,this.canBeRegenerated(),null)},c}(d);c.Box=e;var f=function(b){function c(a,c,d,e,f,g){this.segments=d,this.diameter=e,b.call(this,a,c,this._regenerateVertexData(),f,g)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateSphere(this.segments,this.diameter)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.segments,this.diameter,this.canBeRegenerated(),null)},c}(d);c.Sphere=f;var g=function(b){function c(a,c,d,e,f,g,h,i,j){"undefined"==typeof h&&(h=1),this.height=d,this.diameterTop=e,this.diameterBottom=f,this.tessellation=g,this.subdivisions=h,b.call(this,a,c,this._regenerateVertexData(),i,j)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateCylinder(this.height,this.diameterTop,this.diameterBottom,this.tessellation,this.subdivisions)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.height,this.diameterTop,this.diameterBottom,this.tessellation,this.subdivisions,this.canBeRegenerated(),null)},c}(d);c.Cylinder=g;var h=function(b){function c(a,c,d,e,f,g,h){this.diameter=d,this.thickness=e,this.tessellation=f,b.call(this,a,c,this._regenerateVertexData(),g,h)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTorus(this.diameter,this.thickness,this.tessellation)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.diameter,this.thickness,this.tessellation,this.canBeRegenerated(),null)},c}(d);c.Torus=h;var i=function(b){function c(a,c,d,e,f,g,h){this.width=d,this.height=e,this.subdivisions=f,b.call(this,a,c,this._regenerateVertexData(),g,h)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateGround(this.width,this.height,this.subdivisions)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.width,this.height,this.subdivisions,this.canBeRegenerated(),null)},c}(d);c.Ground=i;var j=function(b){function c(a,c,d,e,f,g,h,i,j,k){this.xmin=d,this.zmin=e,this.xmax=f,this.zmax=g,this.subdivisions=h,this.precision=i,b.call(this,a,c,this._regenerateVertexData(),j,k)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTiledGround(this.xmin,this.zmin,this.xmax,this.zmax,this.subdivisions,this.precision)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.xmin,this.zmin,this.xmax,this.zmax,this.subdivisions,this.precision,this.canBeRegenerated(),null)},c}(d);c.TiledGround=j;var k=function(b){function c(a,c,d,e,f){this.size=d,b.call(this,a,c,this._regenerateVertexData(),e,f)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreatePlane(this.size)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.size,this.canBeRegenerated(),null)},c}(d);c.Plane=k;var l=function(b){function c(a,c,d,e,f,g,h,i,j,k){this.radius=d,this.tube=e,this.radialSegments=f,this.tubularSegments=g,this.p=h,this.q=i,b.call(this,a,c,this._regenerateVertexData(),j,k)}return __extends(c,b),c.prototype._regenerateVertexData=function(){return a.VertexData.CreateTorusKnot(this.radius,this.tube,this.radialSegments,this.tubularSegments,this.p,this.q)},c.prototype.copy=function(a){return new c(a,this.getScene(),this.radius,this.tube,this.radialSegments,this.tubularSegments,this.p,this.q,this.canBeRegenerated(),null)},c}(d);c.TorusKnot=l}(b.Primitives||(b.Primitives={}));b.Primitives}(a.Geometry||(a.Geometry={}));var b=a.Geometry}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(){function b(a){var b=this;this.babylonGamepads=[],this.oneGamepadConnected=!1,this.isMonitoring=!1,this.gamepadEventSupported="GamepadEvent"in window,this.gamepadSupportAvailable=navigator.getGamepads||!!navigator.webkitGetGamepads||!!navigator.msGetGamepads||!!navigator.webkitGamepads,this.buttonADataURL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAA9aSURBVHja7FtpbBzneX7m3otcihSpm9Z9UJalxPKhVLZlp6ktNzEaxE0CtAnQAgnSoPWPBi3syuiPwordFi5Qt2haFygCoylSV4Vby6os1I3kOLYrS65kXXQoypJJSaFEUTyXy925+rzfzC6HFFlL1kpAIe7i5czO7H7zPs97ft8MtTAMcSu/dNzirxkCZgiYIWCGgBkCZgi4hV/mDR5fSxAt+0ZiX0ucDxMSTJLK+f83BFSA6TFgK75OclshouKBFbA+xaV4k7Z+fD6sNRlmjYFXQMu4NiUVS/oHe5/ecnHo3MYxd7QthN9UcsdW6FqEPwgDOFbqpAajL2VlTrTULzj4Ow8+s4+nipSxWMoxIUkyrl/pGswFtIR7WzHgDCX77K7vfHNkbOA+AryjYZadb27OIJdzCNZBKmXw4kbk35qPsTEfJbeEkZESentHMdBfGtY142gu1bDvqV/925f4tQJlNCaj4hXX7RHXS0AFuJEAXvfHr/zmk67vPjir0V68aFEe8xtuQ6O1FHlrEXLmHBiaDUtzYBlpNYjrF+GFZfhhCcPeBQy53ehzT+H8QBe6uwfRf7l8xjKsvX/y5X98jl8fThDhJ4i46QQkrS5I6v7oX7/++77vPtLUlFnZtnIRlubvxRxnHbJmE79sxD/SqG0oZk8MFarRqufUkQAFrxcXSkfx0eB+nOggKX2jHYZhvf79r/z4L2IiipO84aYRkASfefnAX695p3P3c9mM/UufuaMVdzRvxVx7A0xaWdOMqVULJ6Z3TZv6KmHo0ztK6CkfxpHe3Th0pAuF0fLbn1u+9cmv3vW77bE3fGoSPi0BVfAvvPEHm9rPv//iooWz5m9Z/wCWZx+Go9UrN48QTD9IGMZ1cJIzTPisRQclPMrhME4W9mDfB2+i+2z/+TXz7/z2E7/85+9OIuGGE6BV3H77zm/d33nx6Ktr18zFg2t+DQude2n1tLJ8tcJ90vDhpG5Am7qTkJAQErywiLOld7G3/d9xvL0Hy1vWPbbtS3//00Q4hDeaAFXintrx1fu7+jp2r13bgofX/gaazbVkJQdLT9P6VqRFDSu2hIgXlBUBLgtCr3cce47/CMePX0Rr08qtzz7+8k8TpfKGtcKq1jPZre7oObyjdWkGd628l7AXwvMCeL7HjO6qrS8S1E5kTE9tfbiur665ccU9EB1EF9Ep0WXesEZIJb9j5/b/XUtzNrt29Rw0og2lchmBVqLo8LSAHlCixbTpddGm8Y7pjkttCCUP+JQy3FiatNuxdvUx9F4ayopO/OL9sQeEN4oA/eHn577oWPbGVes11PsrUBxjDafze1Te1VzouqnK2TgmLQljQqmrnAsT+iaPVb5b2co7EC+QhBgUeM1R1AcrsGp9Jy6+4W8U3fZ8r+e3EnOI2uaAX3l+zgNB4O9rW5/B8tY5WGo9BtOrJ4uMfUl+uj0B8HTmPXj8Pex86xVEnTDBBSE2r78fX9i09RPyZfT2A5ceIMSPwDOH8JH7Kk5+fAHtR0Zh6MZ9e7534Wc3wgO0sXLhD9OpFOa0egjGMhguD8BgTJooMfPbV1h/umz25ondcFP90IzY2iTgrfY9uH31aqSc9CeSEHkBEyITv28M8XMGc2/z0HGCpWCs8BS/9sWrDYOrJuCBZ+vu5sUfXbicia5kYGzUw4DWTwJKbApSjHuTBBjT2H68zg0MD4KlEwabZi0Y7wd85u/3O9/B6sVrPlEXeiF9nMmRxPt6Qf4y/HyIbh3HwkdF1zefGt5fUwK8wP2WAGwh02MFE/5ogYr3Qg/STL0W3d8aB1ppa+Pw0uI2Tz6/134Mg+UoIGZlZ2HMLaJYHkPICr6//RBamvPj/UA4dYKsegGrXqAXMaqNsDT6SreOY5Gu/FptCeBFN+caAphGiKFiGaOjA3AJHoGt6r7GgNbjqjo5yQkBUVHQ8PaJExjiaZ2yue12nO27gCNdHSptvf/xGdw11I2UZSmvCIJgQiJMhoEfeqpNDvUSRvUB5hMX9fUecg0aBi+Hm2uaAz633bmbm1VN8+h07LfKJdkOkQB2fL4BTlsj8No4YLG2putMSjwjp3QNvZdH8YsiExV501isFjU30lpF7D8dVfCA8sFHp7BuWYtaIwiCsCrCSDVhh9IX8k0CoHsoMQ84FrfFAE3zQAK0VaLzO9tK79XKAxSj+aYALt3XLfNipZD1v492YexrE/sP0zBgUIQIoYaflAXbz16CzyY6YKqYl8uheTarRioD7xAxCQHUpv18L1Yud+Iloujtk4zQo9WZcKURqjbHclzKvj0Gvcw8UA6oY2WqonSuGQGb5I+TJgEFEsB4daXzc0eopabcX13W0BXwgAnRZL4Q62s8ppnR/pFz/QjF+tRvxeIsY/cizGwRt83P4czACL8HdA1JUivCNGVogvdkNkgaGDNe4CvXFyJ8n+B5XGLJ1FmJXJ53AzjZKgGbatkKL5c/liNWIPO8uM/4VO2uKCQZjLmBqQAGJ4EmI8NMabDTOuyUobYXmPlCEpiqA1IkYdWSBpjpEDl6wsrF9aAjqHNOPXDyXAGprAknY5B0btOGGk/GlfE1taqofCNuuYNIJ+omOiZ1rpUHtEYWjkpWoP5EWV2sb5isA7aIQTHHxaIniNADui8PIs0Eb6SY/Z0UQc+j+mXYuoM7Vy/Age7zkBUyCZGLhRLSOYcWpfXFA1wPhqup8JNKq5UkKeoqSHxPLSoqnUQtw5ioc60IyE/VkOji8mYE2nZELNgCXLaOkGDFJBg4OzCMDEcxCfAzS1pQX5fHSNDLClLGwmwzls6vQ09hGFJYegdZ1hha2bqIBNelB5Qjog02TzpFNVEquYpMuTSYr/lcQPKPJHoRQ8W1GYO3lDgpO9pPWTEZEQGnuodg5Hyk66Lyd8fKOQQ6gqyWict7GeuWz8HQyWEFw+bB7ksF3Nk2V1nfpZTLQqSLslzXlDmHpsQ1osVoy/Solwf/GpdErpaAQUqjWxL2GWcWaSfAMIis7RBwiuCdtD1OgmNHBJCg7r4uZBnbdjaaq+3YewB+USYicY8juYPnMtloqdCjG3f39eO+3JKIAFadSiiZigBdgdcqItMxsmZbIbvUIKlzzQjoEgLGRjU2KTp8AjRCkzEnAG0mtQh8Ku0oAqok8JzP+Lw0MkB3jpKjKpapaL5WKZxafDdBqoC6O8LtyMAQhoZdzG7MwLU8FUYKPINcl+qimismRj26v2I71I3jDxfdpM41I6CTsmG4X0djKyc8RYu9t0Vl2QJbBJ5xFPiICJIg1hdhR3fs5HnWeldleZXABLA98b7Y5HtjkgwNEtbTN4iFC5oI3I1CTsAbsfVjAizJB3Qbx9HphRp6eqr3TDprSYA0FI/3ntOxbpUNM2OjpEcE6HYEWkhIKw+ICeBxi+T09F1WZU+iJq2n8fRDf4Ymu3XSrcOIgg8H9uOFn31fNUVC0oddZ7B5YxtDwlTgo66SEici2fokwCJjju0hw7J54WypQsB7tSRAza+H+nld30Y+m2b7SS+Qn9PKFl1egRciHIfWpxC8x+7tdA97+3zUcNyWX4Ci/THOoD2x/hmlQTox+3gDjWYeg/4gmF853xjBpUsjaGnJR24fu36FNzX5pmfY7EPStlSLIgb6gwk616QRYk8tS88/l/2PT/loyqbQkEmhPpNGNp1CmvtieQHvONGtL4sdy9Hjp5kkpTWmSzM7L529hErHs0cCpt2qW00BymDV3JXSU8HkAXKIjtNnedxS48m4Mr5cR9YlMrx+XTqNRmbP2ZkMOjvHKir/PNa5pouiitFjH44iZ6YwO5tFAy+eo6SdpOUJyhBQTJR+HT9HYLJaFve0PqQmTQLaVOCdmIRIWE+wrmWTzG8iAugF7qgWjSWkGbYa32EjJQTkGFv5dBZNJKCeHdb77UPXZP1rWhKLZ4Rqjv2Fz86lLMNlpusCY9BnqTNUIyTgrVhhs7rVq2KoW2TSxWlXLOCqWX4svmpzZdEjWvgQcdVWPnu+i4ClUS+HyLIFnsVf/9eBduw8eKYy2D1XMxO8Jg+IB9wl+3s/uAC3qKMpXY88m/ecnUHaSis3Na8Ab1UtaCh3j1y+sm8m9o0J+9Fv9MR4Zhw6DufTWasOebsOs+xZKHJOtvtQtertulrwV+0BtH5yWvyW7CxubsCTX9+KUQZ4ga7qmdGUFmrya8QWHwcxlReMF8Mw4QETrR8oy7tq2ivH5Tvya8n8aXZMGc4An/nRDpy52FfR8b5KCJCImt8YkYF/KDtnegfwz3sPodGajQajCTk9z/4mQ6iphMWv9AA9IeMWdyYdn+gBkVc5amwHWV6lHvVaI2YZzfinN95Ngv/htcT/p31CRNbdV8l8e++xD5HPNeHxhx5Bgf18kTN5T1kvjBfEjGjBJCai4gnjHqAnlvqS8e9NeujEjEul/NokDbai4V/2voafHD1S0evdWLeb8ojMNyly5fS//ffbcD0L33j4K4RX4rtMh/UUGLXmr6BWXN9MEFAhYfzmZ6hcXI+TpISRH8061Ui68gTWGUJP4aU9P8ZrB39S+Xkx1ummPSMkbebnJcxU1jm4D5eGhvB7j32HJcpUJHhxLIfxTZpxwGa8eKrHC51a9Tmp+N5P1RsQ01cJAwEflHw8/+pfYn/HgaQ+n7/a1vd6k+BUS2XvVD401TXhu488gQ0r71QUuLJsrWT8mSYtfkBMm0BAmFhNrgDX4oRqqeaJMw4c6TyIv/qPP0Xf8KUJ6sXuP1XluuEEyGsD5TXKgsqBNQvW4RtbnkDb4ttJQlGt/IQqLMJE7tWqOSBZCSrL6dFSqq3AnzhzDC/tewHt5w4nr3suvgN0+P8o3TeegFe3vYDHtj+xhLt/Q3kkeW5d693YuuHXsWHZPcixW4tCwo+trVU9QEs8G6HFqW5kdBiHTu3H64dfxpGuK8r665Tv7tz2D6e/tP23cT0E1OA5QR2iiIbs1i9u/9qTPPC12CtwlIofjZVvW/BZ3LVsC5bPW4u5DQuxaPay2NpRIuy61IkLA+dw8hdHceDUPpw49z9TXUysvWPXtl3bQ4yQtMJ1a18DAsbvRO/atvM5DXXPPbp9yzP8+GXBXTkngKYBdTWvE5RXdm87+HQEfLh2T57UIAdM95Js9+04LKSDbLzG31+Omxpx9xfxKR6AukkhMP0aKuUHsag5VEzE3fGSddsUVu6KFzIE+H/iJry0mX+bu8VfMwTMEDBDwAwBMwTMEHALv/5XgAEASpR5N6rB30UAAAAASUVORK5CYII=",this._callbackGamepadConnected=a,this.gamepadSupportAvailable?(this.gamepadEventSupported?(window.addEventListener("gamepadconnected",function(a){b._onGamepadConnected(a)
},!1),window.addEventListener("gamepaddisconnected",function(a){b._onGamepadDisconnected(a)},!1)):this._startMonitoringGamepads(),this.oneGamepadConnected||this._insertGamepadDOMInstructions()):this._insertGamepadDOMNotSupported()}return b.prototype._insertGamepadDOMInstructions=function(){b.gamepadDOMInfo=document.createElement("div");var a=document.createElement("img");a.src=this.buttonADataURL;var c=document.createElement("span");c.innerHTML="<strong>to activate gamepad</strong>",b.gamepadDOMInfo.appendChild(a),b.gamepadDOMInfo.appendChild(c),b.gamepadDOMInfo.style.position="absolute",b.gamepadDOMInfo.style.width="100%",b.gamepadDOMInfo.style.height="48px",b.gamepadDOMInfo.style.bottom="0px",b.gamepadDOMInfo.style.backgroundColor="rgba(1, 1, 1, 0.15)",b.gamepadDOMInfo.style.textAlign="center",b.gamepadDOMInfo.style.zIndex="10",a.style.position="relative",a.style.bottom="8px",c.style.position="relative",c.style.fontSize="32px",c.style.bottom="32px",c.style.color="green",document.body.appendChild(b.gamepadDOMInfo)},b.prototype._insertGamepadDOMNotSupported=function(){b.gamepadDOMInfo=document.createElement("div");var a=document.createElement("span");a.innerHTML="<strong>gamepad not supported</strong>",b.gamepadDOMInfo.appendChild(a),b.gamepadDOMInfo.style.position="absolute",b.gamepadDOMInfo.style.width="100%",b.gamepadDOMInfo.style.height="40px",b.gamepadDOMInfo.style.bottom="0px",b.gamepadDOMInfo.style.backgroundColor="rgba(1, 1, 1, 0.15)",b.gamepadDOMInfo.style.textAlign="center",b.gamepadDOMInfo.style.zIndex="10",a.style.position="relative",a.style.fontSize="32px",a.style.color="red",document.body.appendChild(b.gamepadDOMInfo)},b.prototype.dispose=function(){document.body.removeChild(b.gamepadDOMInfo)},b.prototype._onGamepadConnected=function(a){var b=this._addNewGamepad(a.gamepad);this._callbackGamepadConnected&&this._callbackGamepadConnected(b),this._startMonitoringGamepads()},b.prototype._addNewGamepad=function(c){this.oneGamepadConnected||(this.oneGamepadConnected=!0,b.gamepadDOMInfo&&(document.body.removeChild(b.gamepadDOMInfo),b.gamepadDOMInfo=null));var d;return d=-1!==c.id.search("Xbox 360")||-1!==c.id.search("xinput")?new a.Xbox360Pad(c.id,c.index,c):new a.GenericPad(c.id,c.index,c),this.babylonGamepads.push(d),d},b.prototype._onGamepadDisconnected=function(a){for(var b in this.babylonGamepads)if(this.babylonGamepads[b].index==a.gamepad.index){this.babylonGamepads.splice(b,1);break}0==this.babylonGamepads.length&&this._stopMonitoringGamepads()},b.prototype._startMonitoringGamepads=function(){this.isMonitoring||(this.isMonitoring=!0,this._checkGamepadsStatus())},b.prototype._stopMonitoringGamepads=function(){this.isMonitoring=!1},b.prototype._checkGamepadsStatus=function(){var a=this;this._updateGamepadObjects();for(var b in this.babylonGamepads)this.babylonGamepads[b].update();this.isMonitoring&&(window.requestAnimationFrame?window.requestAnimationFrame(function(){a._checkGamepadsStatus()}):window.mozRequestAnimationFrame?window.mozRequestAnimationFrame(function(){a._checkGamepadsStatus()}):window.webkitRequestAnimationFrame&&window.webkitRequestAnimationFrame(function(){a._checkGamepadsStatus()}))},b.prototype._updateGamepadObjects=function(){for(var a=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads?navigator.webkitGetGamepads():[],b=0;b<a.length;b++)if(a[b])if(a[b].index in this.babylonGamepads)this.babylonGamepads[b].browserGamepad=a[b];else{var c=this._addNewGamepad(a[b]);this._callbackGamepadConnected&&this._callbackGamepadConnected(c)}},b}();a.Gamepads=b;var c=function(){function a(a,b){this.x=a,this.y=b}return a}();a.StickValues=c;var d=function(){function a(a,b,c){this.id=a,this.index=b,this.browserGamepad=c,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[0],y:this.browserGamepad.axes[1]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[2],y:this.browserGamepad.axes[3]})}return a.prototype.onleftstickchanged=function(a){this._onleftstickchanged=a},a.prototype.onrightstickchanged=function(a){this._onrightstickchanged=a},Object.defineProperty(a.prototype,"leftStick",{get:function(){return this._leftStick},set:function(a){!this._onleftstickchanged||this._leftStick.x===a.x&&this._leftStick.y===a.y||this._onleftstickchanged(a),this._leftStick=a},enumerable:!0,configurable:!0}),Object.defineProperty(a.prototype,"rightStick",{get:function(){return this._rightStick},set:function(a){!this._onrightstickchanged||this._rightStick.x===a.x&&this._rightStick.y===a.y||this._onrightstickchanged(a),this._rightStick=a},enumerable:!0,configurable:!0}),a.prototype.update=function(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[0],y:this.browserGamepad.axes[1]}),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[2],y:this.browserGamepad.axes[3]})},a}();a.Gamepad=d;var e=function(a){function b(b,c,d){a.call(this,b,c,d),this.id=b,this.index=c,this.gamepad=d,this._buttons=new Array(d.buttons.length)}return __extends(b,a),b.prototype.onbuttondown=function(a){this._onbuttondown=a},b.prototype.onbuttonup=function(a){this._onbuttonup=a},b.prototype._setButtonValue=function(a,b,c){return a!==b&&(this._onbuttondown&&1===a&&this._onbuttondown(c),this._onbuttonup&&0===a&&this._onbuttonup(c)),a},b.prototype.update=function(){a.prototype.update.call(this);for(var b=0;b<this._buttons.length;b++)this._buttons[b]=this._setButtonValue(this.gamepad.buttons[b].value,this._buttons[b],b)},b}(d);a.GenericPad=e,function(a){a[a.A=0]="A",a[a.B=1]="B",a[a.X=2]="X",a[a.Y=3]="Y",a[a.Start=4]="Start",a[a.Back=5]="Back",a[a.LB=6]="LB",a[a.RB=7]="RB",a[a.LeftStick=8]="LeftStick",a[a.RightStick=9]="RightStick"}(a.Xbox360Button||(a.Xbox360Button={}));a.Xbox360Button;!function(a){a[a.Up=0]="Up",a[a.Down=1]="Down",a[a.Left=2]="Left",a[a.Right=3]="Right"}(a.Xbox360Dpad||(a.Xbox360Dpad={}));var f=(a.Xbox360Dpad,function(a){function b(){a.apply(this,arguments),this._leftTrigger=0,this._rightTrigger=0,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0}return __extends(b,a),b.prototype.onlefttriggerchanged=function(a){this._onlefttriggerchanged=a},b.prototype.onrighttriggerchanged=function(a){this._onrighttriggerchanged=a},Object.defineProperty(b.prototype,"leftTrigger",{get:function(){return this._leftTrigger},set:function(a){this._onlefttriggerchanged&&this._leftTrigger!==a&&this._onlefttriggerchanged(a),this._leftTrigger=a},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"rightTrigger",{get:function(){return this._rightTrigger},set:function(a){this._onrighttriggerchanged&&this._rightTrigger!==a&&this._onrighttriggerchanged(a),this._rightTrigger=a},enumerable:!0,configurable:!0}),b.prototype.onbuttondown=function(a){this._onbuttondown=a},b.prototype.onbuttonup=function(a){this._onbuttonup=a},b.prototype.ondpaddown=function(a){this._ondpaddown=a},b.prototype.ondpadup=function(a){this._ondpadup=a},b.prototype._setButtonValue=function(a,b,c){return a!==b&&(this._onbuttondown&&1===a&&this._onbuttondown(c),this._onbuttonup&&0===a&&this._onbuttonup(c)),a},b.prototype._setDPadValue=function(a,b,c){return a!==b&&(this._ondpaddown&&1===a&&this._ondpaddown(c),this._ondpadup&&0===a&&this._ondpadup(c)),a},Object.defineProperty(b.prototype,"buttonA",{get:function(){return this._buttonA},set:function(a){this._buttonA=this._setButtonValue(a,this._buttonA,0)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonB",{get:function(){return this._buttonB},set:function(a){this._buttonB=this._setButtonValue(a,this._buttonB,1)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonX",{get:function(){return this._buttonX},set:function(a){this._buttonX=this._setButtonValue(a,this._buttonX,2)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonY",{get:function(){return this._buttonY},set:function(a){this._buttonY=this._setButtonValue(a,this._buttonY,3)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonStart",{get:function(){return this._buttonStart},set:function(a){this._buttonStart=this._setButtonValue(a,this._buttonStart,4)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonBack",{get:function(){return this._buttonBack},set:function(a){this._buttonBack=this._setButtonValue(a,this._buttonBack,5)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonLB",{get:function(){return this._buttonLB},set:function(a){this._buttonLB=this._setButtonValue(a,this._buttonLB,6)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonRB",{get:function(){return this._buttonRB},set:function(a){this._buttonRB=this._setButtonValue(a,this._buttonRB,7)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonLeftStick",{get:function(){return this._buttonLeftStick},set:function(a){this._buttonLeftStick=this._setButtonValue(a,this._buttonLeftStick,8)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"buttonRightStick",{get:function(){return this._buttonRightStick},set:function(a){this._buttonRightStick=this._setButtonValue(a,this._buttonRightStick,9)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadUp",{get:function(){return this._dPadUp},set:function(a){this._dPadUp=this._setDPadValue(a,this._dPadUp,0)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadDown",{get:function(){return this._dPadDown},set:function(a){this._dPadDown=this._setDPadValue(a,this._dPadDown,1)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadLeft",{get:function(){return this._dPadLeft},set:function(a){this._dPadLeft=this._setDPadValue(a,this._dPadLeft,2)},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"dPadRight",{get:function(){return this._dPadRight},set:function(a){this._dPadRight=this._setDPadValue(a,this._dPadRight,3)},enumerable:!0,configurable:!0}),b.prototype.update=function(){a.prototype.update.call(this),this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value},b}(d));a.Xbox360Pad=f}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){var f=this;b.call(this,c,d,e),this.angularSensibility=200,this.moveSensibility=75,this._gamepads=new a.Gamepads(function(a){f._onNewGameConnected(a)})}return __extends(c,b),c.prototype._onNewGameConnected=function(a){0===a.index&&(this._gamepad=a)},c.prototype._checkInputs=function(){if(this._gamepad){var b=this._gamepad.leftStick,c=b.x/this.moveSensibility,d=b.y/this.moveSensibility;b.x=Math.abs(c)>.005?0+c:0,b.y=Math.abs(d)>.005?0+d:0;var e=this._gamepad.rightStick,f=e.x/this.angularSensibility,g=e.y/this.angularSensibility;e.x=Math.abs(f)>.001?0+f:0,e.y=Math.abs(g)>.001?0+g:0;var h=a.Matrix.RotationYawPitchRoll(this.rotation.y,this.rotation.x,0),i=a.Vector3.TransformCoordinates(new a.Vector3(b.x,0,-b.y),h);this.cameraDirection=this.cameraDirection.add(i),this.cameraRotation=this.cameraRotation.add(new a.Vector3(e.y,e.x,0))}},c.prototype.dispose=function(){this._gamepads.dispose()},c}(a.FreeCamera);a.GamepadCamera=b}(BABYLON||(BABYLON={}));var __extends=this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);c.prototype=b.prototype,a.prototype=new c},BABYLON;!function(a){var b=function(b){function c(c,d,e){"undefined"==typeof e&&(e=!1),b.call(this,c,d),this.color=new a.Color3(1,1,1),this._indices=new Array,this._colorShader=new a.ShaderMaterial("colorShader",d,"color",{attributes:["position"],uniforms:["worldViewProjection","color"]})}return __extends(c,b),Object.defineProperty(c.prototype,"material",{get:function(){return this._colorShader},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"isPickable",{get:function(){return!1},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"checkCollisions",{get:function(){return!1},enumerable:!0,configurable:!0}),c.prototype._bind=function(){var b=this.getScene().getEngine(),c=this._geometry.getIndexBuffer();b.bindBuffers(this._geometry.getVertexBuffer(a.VertexBuffer.PositionKind).getBuffer(),c,[3],12,this._colorShader.getEffect()),this._colorShader.setColor3("color",this.color)},c.prototype._draw=function(a){if(this._geometry&&this._geometry.getVertexBuffers()&&this._geometry.getIndexBuffer()){var b=this.getScene().getEngine();b.draw(!1,a.indexStart,a.indexCount)}},c.prototype.intersects=function(){return null},c.prototype.dispose=function(a){this._colorShader.dispose(),b.prototype.dispose.call(this,a)},c}(a.Mesh);a.LinesMesh=b}(BABYLON||(BABYLON={}));module.exports=BABYLON;
},{}],"jQuery":[function(require,module,exports){
/*!
 * jQuery JavaScript Library v1.11.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-17T15:27Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "1.11.2",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1, IE<9
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1, IE<9
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery(function() {
	// Minified: var a,b,c,d
	var val, div, body, container;

	body = document.getElementsByTagName( "body" )[ 0 ];
	if ( !body || !body.style ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	div = document.createElement( "div" );
	container = document.createElement( "div" );
	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
		if ( val ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	// Minified: var a,b,c
	var input = document.createElement( "input" ),
		div = document.createElement( "div" ),
		fragment = document.createDocumentFragment();

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: IE < 9, Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var shrinkWrapBlocksVal;

	support.shrinkWrapBlocks = function() {
		if ( shrinkWrapBlocksVal != null ) {
			return shrinkWrapBlocksVal;
		}

		// Will be changed later if needed.
		shrinkWrapBlocksVal = false;

		// Minified: var b,c,d
		var div, body, container;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		// Support: IE6
		// Check if elements with layout shrink-wrap their children
		if ( typeof div.style.zoom !== strundefined ) {
			// Reset CSS: box-sizing; display; margin; border
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;" +
				"padding:1px;width:1px;zoom:1";
			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
			shrinkWrapBlocksVal = div.offsetWidth !== 3;
		}

		body.removeChild( container );

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	// Minified: var b,c,d,e,f,g, h,i
	var div, style, a, pixelPositionVal, boxSizingReliableVal,
		reliableHiddenOffsetsVal, reliableMarginRightVal;

	// Setup
	div = document.createElement( "div" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];
	style = a && a.style;

	// Finish early in limited (non-browser) environments
	if ( !style ) {
		return;
	}

	style.cssText = "float:left;opacity:.5";

	// Support: IE<9
	// Make sure that element opacity exists (as opposed to filter)
	support.opacity = style.opacity === "0.5";

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
		style.WebkitBoxSizing === "";

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal == null ) {
				computeStyleTests();
			}
			return reliableHiddenOffsetsVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		// Support: Android 2.3
		reliableMarginRight: function() {
			if ( reliableMarginRightVal == null ) {
				computeStyleTests();
			}
			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		// Minified: var b,c,d,j
		var div, body, container, contents;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";

		// Support: IE<9
		// Assume reasonable values in the absence of getComputedStyle
		pixelPositionVal = boxSizingReliableVal = false;
		reliableMarginRightVal = true;

		// Check for getComputedStyle so that this code is not run in IE<9.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Support: Android 2.3
			// Div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			contents = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			contents.style.cssText = div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
			contents.style.marginRight = contents.style.width = "0";
			div.style.width = "1px";

			reliableMarginRightVal =
				!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

			div.removeChild( contents );
		}

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		contents = div.getElementsByTagName( "td" );
		contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
		reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		if ( reliableHiddenOffsetsVal ) {
			contents[ 0 ].style.display = "";
			contents[ 1 ].style.display = "none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		}

		body.removeChild( container );
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display && display !== "none" || !hidden ) {
				jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	// Minified: var a,b,c,d,e
	var input, div, select, a, opt;

	// Setup
	div = document.createElement( "div" );
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off, url.length ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],"lodash":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.6.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.6.0';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_DROP_WHILE_FLAG = 0,
      LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   */
  var reComboMarks = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /**
   * Used to match [ES template delimiters](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
   * In addition to special characters the forward slash is escaped to allow for
   * easier `eval` use and `Function` compilation.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
    ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
    '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
          othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of each element
   * in a collection and stable sort them in the following order:
   *
   * If orders is unspecified, sort in ascending order for all properties.
   * Otherwise, for each property, sort in ascending order if its corresponding value in
   * orders is true, and descending order if false.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        return result * (orders[index] ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
        ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        push = arrayProto.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = isNative(Set = context.Set) && Set,
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
            result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsFinite = context.isFinite,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,
     * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,
     * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,
     * `without`, `wrap`, `xor`, `zip`, and `zipObject`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,
     * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
     * `isFinite`,`isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `sum`, `template`, `trim`, `trimLeft`,
     * `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) {
     *   return sum + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = /\bthis\b/.test(function() { return this; });

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = null;
      this.__dir__ = 1;
      this.__dropCount__ = 0;
      this.__filtered__ = false;
      this.__iteratees__ = null;
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = null;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.__actions__,
          iteratees = this.__iteratees__,
          views = this.__views__,
          result = new LazyWrapper(this.__wrapped__);

      result.__actions__ = actions ? arrayCopy(actions) : null;
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var dir = this.__dir__,
          isRight = dir < 0,
          view = getView(0, array.length, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          takeCount = nativeMin(length, this.__takeCount__),
          iteratees = this.__iteratees__,
          iterLength = iteratees ? iteratees.length : 0,
          resIndex = 0,
          result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type;

          if (type == LAZY_DROP_WHILE_FLAG) {
            if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
              data.count = 0;
              data.done = false;
            }
            data.index = index;
            if (!data.done) {
              var limit = data.limit;
              if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                continue outer;
              }
            }
          } else {
            var computed = iteratee(value);
            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
          length = array.length,
          result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
          length = array.length,
          result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     */
    function arraySum(array) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +array[length] || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          length = collection.length,
          isArr = isLength(length),
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return typeof thisArg == 'undefined'
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return typeof thisArg == 'undefined'
        ? baseProperty(func + '')
        : baseMatchesProperty(func + '', thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= 200) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} isDeep Specify a deep flatten.
     * @param {boolean} isStrict Restrict flattening to arrays and `arguments` objects.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
              valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
          othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
          value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = (objTag == objectTag || (isLoose && objTag == funcTag)),
          othIsObj = (othTag == objectTag || (isLoose && othTag == funcTag)),
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (isLoose) {
        if (!isSameTag && !(objIsObj && othIsObj)) {
          return false;
        }
      } else {
        var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (valWrapped || othWrapped) {
          return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
        if (!isSameTag) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var index = -1,
          length = props.length,
          noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
              ? values[index] !== object[props[index]]
              : !(props[index] in object)
            ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index],
            objValue = object[key],
            srcValue = values[index];

        if (noCustomizer && strictCompareFlags[index]) {
          var result = typeof objValue != 'undefined' || (key in object);
        } else {
          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
          length = props.length;

      if (!length) {
        return constant(true);
      }
      if (length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value &&
              (typeof value != 'undefined' || (key in toObject(object)));
          };
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value &&
            (typeof value != 'undefined' || (key in toObject(object)));
        };
      }
      return function(object) {
        return object != null && baseIsEqual(value, object[key], null, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
            (isCommon || (result === result ? (result !== value) : (value === value)))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : ((value && value.length) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string[]} props The property names to sort by.
     * @param {boolean[]} orders The sort orders of `props`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, props, orders) {
      var index = -1,
          length = collection.length,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var length = props.length,
            criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= 200,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var args = [result],
            action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
            computed = iteratee(array[mid]),
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
            result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee.
     *
     * **Note:** This function is used to create `_.countBy`, `_.groupBy`, `_.indexBy`,
     * and `_.partition`.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var args = arguments,
            length = args.length,
            object = args[0];

        if (length < 2 || object == null) {
          return object;
        }
        var customizer = args[length - 2],
            thisArg = args[length - 1],
            guard = args[3];

        if (length > 3 && typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(args[1], args[2], guard)) {
          customizer = length == 3 ? null : customizer;
          length = 2;
        }
        var index = 0;
        while (++index < length) {
          var source = args[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? collection.length : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = null;
        }
        var result = createWrapper(func, flag, null, null, null, null, null, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
            noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      }
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var length = arguments.length;
        if (!length) {
          return function() { return arguments[0]; };
        }
        var wrapper,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var funcName = wrapper ? '' : getFuncName(func);
          wrapper = funcName == 'wrapper' ? new LodashWrapper([]) : wrapper;
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];
          funcName = getFuncName(func);

          var data = funcName == 'wrapper' ? getData(func) : null;
          if (data && isLaziable(data[0])) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments;
          if (wrapper && args.length == 1 && isArray(args[0])) {
            return wrapper.plant(args[0]).value();
          }
          var index = 0,
              result = funcs[index].apply(this, args);

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return string && ((fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string));
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, null, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
          key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : null,
                newHoldersRight = isCurry ? null : argsHolders,
                newPartials = isCurry ? args : null,
                newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var func = getCallback(iteratee);
        return (func === baseCallback && iteratee == null)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = null;
      }
      var data = isBindKey ? null : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length,
          result = true;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isLoose
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isLoose) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var skipCtor = isLoose,
          index = -1;

      while (++index < objLength) {
        var key = objProps[index],
            result = isLoose ? key in other : hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
              othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isLoose
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
          computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? (current < computed) : (current > computed)) ||
            (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    var getFuncName = (function() {
      if (!support.funcNames) {
        return constant('');
      }
      if (constant.name == 'constant') {
        return baseProperty('name');
      }
      return function(func) {
        var result = func.name,
            array = realNames[result],
            length = array ? array.length : 0;

        while (length--) {
          var data = array[length],
              otherFunc = data.func;

          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result;
      };
    }());

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
            prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      if (prereq) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func);
      return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
          support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
          (!hasOwnProperty.call(value, 'constructor') &&
            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length,
          support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isArray(array) || isArguments(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
            other = array[index];

        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = [],
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
        }
      }
      argsLength = args.length;
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [],
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          argsIndex = argsLength;
          while (--argsIndex) {
            var cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`
     *  - [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    comparisons are like strict equality comparisons, e.g. `===`, except
     *    that `NaN` matches `NaN`
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      array || (array = []);
      indexes = baseFlatten(indexes);

      var length = indexes.length,
          result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
          result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return (isArray(array) || isArguments(array))
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapper = wrapper.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapper.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapper = wrapper.plant(other);
     *
     * otherWrapper.value();
     * // => [9, 16]
     *
     * wrapper.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse(), this.__chain__);
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = null;
      }
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * comparisons are like strict equality comparisons, e.g. `===`, except that
     * `NaN` matches `NaN`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, methodName, args) {
      var index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
     * `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`,
     * `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`,
     * `trimRight`, `trunc`, `random`, `range`, `sample`, `some`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     *  create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `includes`, `merge`, `sortByAll`, and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight =  createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
          length = collection.length,
          result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = null;
      }
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      var index = -1,
          length = collection.length,
          result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll() {
      var args = arguments,
          collection = args[0],
          guard = args[3],
          index = 0,
          length = args.length - 1;

      if (collection == null) {
        return [];
      }
      var props = Array(length);
      while (index < length) {
        props[index] = args[++index];
      }
      if (guard && isIterateeCall(args[1], args[2], guard)) {
        props = args[1];
      }
      return baseSortByOrder(collection, baseFlatten(props), []);
    }

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the property names to sort by. A truthy value in `orders`
     * will sort the corresponding property name in ascending order while a
     * falsey value will sort it in descending order.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string[]} props The property names to sort by.
     * @param {boolean[]} orders The sort orders of `props`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);
     * // => [['barney', 36], ['barney', 26], ['fred', 40], ['fred', 30]]
     */
    function sortByOrder(collection, props, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(props, orders, guard)) {
        orders = null;
      }
      if (!isArray(props)) {
        props = props == null ? [] : [props];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, props, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            cache = memoized.cache,
            key = resolver ? resolver.apply(this, args) : args[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(typeof start == 'undefined' ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return isLength(length) && objToString.call(value) == argsTag;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) &&
        (objToString.call(value).indexOf('Element') > -1);
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
      };
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return objToString.call(value) == funcTag;
    };

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (!!value && type == 'object');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
          length = props.length;

      if (!length) {
        return true;
      }
      if (object == null) {
        return false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return value === object[key] && (typeof value != 'undefined' || (key in toObject(object)));
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(toObject(object), props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = restParam(function(args) {
      var object = args[0];
      if (object == null) {
        return object;
      }
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 3 };
     *
     * _.has(object, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
            length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it is set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (typeof end === 'undefined') {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= start && value < end;
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dÃ©jÃ  vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMarks, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = typeof position == 'undefined'
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it is shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function which compares the property value of `key` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(key, value) {
      return baseMatchesProperty(key + '', baseClone(value, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function
     * for mixins to avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * // use `_.runInContext` to avoid conflicts (esp. in Node.js)
     * var _ = require('lodash').runInContext();
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj && keys(source),
            methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', 'barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The opposite of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     *
     * _.map(['a', 'c'], _.propertyOf(object));
     * // => [3, 2]
     *
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it is
     * set to `start` with `start` then set to `0`. If `start` is less than `end`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(ceil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return augend + addend;
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      var func = getCallback(),
          noIteratee = iteratee == null;

      if (!(func === baseCallback && noIteratee)) {
        noIteratee = false;
        iteratee = func(iteratee, thisArg, 3);
      }
      return noIteratee
        ? arraySum(isArray(collection) ? collection : toIterable(collection))
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {
      var isFilter = type != LAZY_MAP_FLAG,
          isDropWhile = type == LAZY_DROP_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var filtered = this.__filtered__,
            result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

        iteratees.push({
          'done': false,
          'count': 0,
          'index': 0,
          'iteratee': getCallback(iteratee, thisArg, 1),
          'limit': -1,
          'type': type
        });

        result.__filtered__ = filtered || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__,
            result = (filtered && !index) ? this.dropWhile() : this.clone();

        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
        if (filtered) {
          if (index) {
            result.__takeCount__ = nativeMin(result.__takeCount__, n);
          } else {
            last(result.__iteratees__).limit = n;
          }
        } else {
          var views = result.__views__ || (result.__views__ = []);
          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.toArray = function() {
      return this.drop(0);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (!lodashFunc) {
        return;
      }
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments,
            length = args.length,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // avoid lazy use if the iteratee has a `length` other than `1`
          isLazy = useLazy = false;
        }
        var onlyLazy = isLazy && !isHybrid;
        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (useLazy) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
              result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.__actions__)) {
            var actions = result.__actions__ || (result.__actions__ = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name,
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': null }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvYXBwLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9iaXJkLWNhbWVyYS5qcyIsInNyYy9tb2R1bGVzL2NhbWVyYXMvY2FtZXJhLWNvbXB1dGVyLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9jYW1lcmEtY29udGFpbmVyLmpzIiwic3JjL21vZHVsZXMvY2FtZXJhcy9leGFtaW5lLWNhbWVyYS5qcyIsInNyYy9tb2R1bGVzL2NhbWVyYXMvaGlrZXItY2FtZXJhLmpzIiwic3JjL21vZHVsZXMvZGVtLmpzIiwic3JjL21vZHVsZXMvZXZlbnRzLmpzIiwic3JjL21vZHVsZXMvcG9pLmpzIiwic3JjL21vZHVsZXMvc2NlbmUuanMiLCJzcmMvbW9kdWxlcy9zZXR0aW5ncy5qcyIsInNyYy9tb2R1bGVzL3RpbGUtY29udGFpbmVyLmpzIiwic3JjL21vZHVsZXMvdHJlay5qcyIsInNyYy9tb2R1bGVzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9wbHVnaW5zL0JlemllclBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9nc2FwL3NyYy91bmNvbXByZXNzZWQvcGx1Z2lucy9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL2dzYXAvc3JjL3VuY29tcHJlc3NlZC9lYXNpbmcvRWFzZVBhY2suanMiLCJub2RlX21vZHVsZXMvZ3NhcC9zcmMvdW5jb21wcmVzc2VkL1RpbWVsaW5lTGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nc2FwL3NyYy91bmNvbXByZXNzZWQvVHdlZW5MaXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYnlsb25qcy9iYWJ5bG9uLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2o2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3dUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNod0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFtVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIFJhbmRvM0QoKSB7XG5cbiAgICAgICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG5cbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL3NldHRpbmdzJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvZGVtJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvZXZlbnRzJykoUkFORE8pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvcG9pJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvc2NlbmUnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy90aWxlLWNvbnRhaW5lcicpKFJBTkRPKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL3RyZWsnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy91dGlscycpKFJBTkRPLCBCQUJZTE9OKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL2NhbWVyYXMvY2FtZXJhLWNvbXB1dGVyJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvY2FtZXJhcy9jYW1lcmEtY29udGFpbmVyJykoUkFORE8sIEJBQllMT04pO1xuICAgICAgICByZXF1aXJlKCcuL21vZHVsZXMvY2FtZXJhcy9iaXJkLWNhbWVyYScpKFJBTkRPLCBCQUJZTE9OKTtcbiAgICAgICAgcmVxdWlyZSgnLi9tb2R1bGVzL2NhbWVyYXMvZXhhbWluZS1jYW1lcmEnKShSQU5ETywgQkFCWUxPTik7XG4gICAgICAgIHJlcXVpcmUoJy4vbW9kdWxlcy9jYW1lcmFzL2hpa2VyLWNhbWVyYScpKFJBTkRPLCBCQUJZTE9OKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0KGN1c3RvbVNldHRpbmdzLCBjYW52YXMsIGNhbWVyYUlEKSB7XG5cbiAgICAgICAgICAgICQuZWFjaChjdXN0b21TZXR0aW5ncywgZnVuY3Rpb24gKHNldHRpbmdOYW1lLCBzZXR0aW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBSQU5ETy5TRVRUSU5HU1tzZXR0aW5nTmFtZV0gPSBzZXR0aW5nVmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgUkFORE8uU1RBUlRfVElNRSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHZhciBzY2VuZSA9IG5ldyBSQU5ETy5TY2VuZShjYW52YXMsIGNhbWVyYUlEKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNjZW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXQ6IGluaXRcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LlJhbmRvM0QgPSBSYW5kbzNEO1xuICAgIH1cbn0pKCk7IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLkJpcmRDYW1lcmEuanNcbiAqXG4gKiBCaXJkQ2FtZXJhIGNsYXNzIDpcbiAqICBJdCBpcyBhIGNhbWVyYSB3aGljaCBsb29rIGxpa2UgdGhlIEZyZWVDYW1lcmEgb2YgQmFieWxvbkpTLlxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vQmFieWxvbkpTL0JhYnlsb24uanMvd2lraS8wNS1DYW1lcmFzLlxuICpcbiAqICBUaGUgZGlmZmVyZW5jZXMgYXJlIDpcbiAqICAgICAgLSBwZXJtaXRlcyB0byB0cmFuc2xhdGUgaXQgb2Ygd29ybGQncyBYIGFuZCBaIGF4aXMgaW5zdGVhZCBvZlxuICogIGxvY2FsZSdzIG9uZS5cbiAqICAgICAgLSB0aGVyZSBpcyBhIHdoZWVsIHpvb20uXG4gKlxuICogIEl0IGdpdmVzIHRoZSBpbXByZXNzaW9uIG9mIGZseWluZy4gVGhhdCdzIHdoeSBpdCBpcyBjYWxsZWQgQmlyZENhbWVyYVxuICpcbiAqIEBhdXRob3I6IEPDqWxpYW4gR0FSQ0lBXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFJBTkRPLCBCQUJZTE9OKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhID0gZnVuY3Rpb24gKG5hbWUsIHBvc2l0aW9uLCBzY2VuZSkge1xuICAgICAgICBCQUJZTE9OLkNhbWVyYS5jYWxsKHRoaXMsIG5hbWUsIHBvc2l0aW9uLCBzY2VuZSk7XG5cbiAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjIoMCwgMCk7XG4gICAgICAgIHRoaXMuem9vbURpcmVjdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICB0aGlzLmVsbGlwc29pZCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMC41LCAxLCAwLjUpO1xuXG4gICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgdGhpcy5rZXlzVXAgPSBbMzhdO1xuICAgICAgICB0aGlzLmtleXNEb3duID0gWzQwXTtcbiAgICAgICAgdGhpcy5rZXlzTGVmdCA9IFszN107XG4gICAgICAgIHRoaXMua2V5c1JpZ2h0ID0gWzM5XTtcblxuICAgICAgICAvLyBDb2xsaXNpb25zXG4gICAgICAgIHRoaXMuX2NvbGxpZGVyID0gbmV3IEJBQllMT04uQ29sbGlkZXIoKTtcbiAgICAgICAgdGhpcy5fbmVlZE1vdmVGb3JHcmF2aXR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBJbnRlcm5hbHNcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdNYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhbU1hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCA9IEJBQllMT04uTWF0cml4Llplcm8oKTtcbiAgICAgICAgdGhpcy5fcmVmZXJlbmNlUG9pbnQgPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50ID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fb2xkUG9zaXRpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9kaWZmUG9zaXRpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9uZXdQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2xvb2tBdFRlbXAgPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3RlbXBNYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQWZ0ZXJab29tID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJBQllMT04uQ2FtZXJhLnByb3RvdHlwZSk7XG5cbiAgICAvLyBNZW1iZXJzXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuc3BlZWQgPSAyLjA7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuY2hlY2tDb2xsaXNpb25zID0gZmFsc2U7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuYXBwbHlHcmF2aXR5ID0gZmFsc2U7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUubm9Sb3RhdGlvbkNvbnN0cmFpbnQgPSBmYWxzZTtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5hbmd1bGFyU2Vuc2liaWxpdHkgPSAyMDAwLjA7XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUubG9ja2VkVGFyZ2V0ID0gbnVsbDtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5vbkNvbGxpZGUgPSBudWxsO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLndoZWVsUHJlY2lzaW9uID0gMC4zO1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5sb3dlclJhZGl1c0xpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS51cHBlclJhZGl1c0xpbWl0ID0gbnVsbDtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRUYXJnZXQucG9zaXRpb24gfHwgdGhpcy5sb2NrZWRUYXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIENhY2hlXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2luaXRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB0aGlzLl9jYWNoZS5yb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfTtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLl91cGRhdGVDYWNoZSA9IGZ1bmN0aW9uIChpZ25vcmVQYXJlbnRDbGFzcykge1xuICAgICAgICBpZiAoIWlnbm9yZVBhcmVudENsYXNzKVxuICAgICAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl91cGRhdGVDYWNoZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBsb2NrZWRUYXJnZXRQb3NpdGlvbiA9IHRoaXMuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGlmICghbG9ja2VkVGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA9IGxvY2tlZFRhcmdldFBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQuY29weUZyb20obG9ja2VkVGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUucm90YXRpb24uY29weUZyb20odGhpcy5yb3RhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIFN5bmNocm9uaXplZFxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXguY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2tlZFRhcmdldFBvc2l0aW9uID0gdGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKTtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA/IHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5lcXVhbHMobG9ja2VkVGFyZ2V0UG9zaXRpb24pIDogIWxvY2tlZFRhcmdldFBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgdGhpcy5fY2FjaGUucm90YXRpb24uZXF1YWxzKHRoaXMucm90YXRpb24pO1xuICAgIH07XG5cbiAgICAvLyBNZXRob2RzXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVlZCAqICgoQkFCWUxPTi5Ub29scy5HZXREZWx0YVRpbWUoKSAvIChCQUJZTE9OLlRvb2xzLkdldEZwcygpICogMTAuMCkpKTtcbiAgICB9O1xuXG4gICAgLy8gVGFyZ2V0XG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB0aGlzLnVwVmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIEJBQllMT04uTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB0aGlzLnVwVmVjdG9yLCB0aGlzLl9jYW1NYXRyaXgpO1xuICAgICAgICB0aGlzLl9jYW1NYXRyaXguaW52ZXJ0KCk7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi54ID0gTWF0aC5hdGFuKHRoaXMuX2NhbU1hdHJpeC5tWzZdIC8gdGhpcy5fY2FtTWF0cml4Lm1bMTBdKTtcblxuICAgICAgICB2YXIgdkRpciA9IHRhcmdldC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAodkRpci54ID49IDAuMCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gKC1NYXRoLmF0YW4odkRpci56IC8gdkRpci54KSArIE1hdGguUEkgLyAyLjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ID0gKC1NYXRoLmF0YW4odkRpci56IC8gdkRpci54KSAtIE1hdGguUEkgLyAyLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbi56ID0gLU1hdGguYWNvcyhCQUJZTE9OLlZlY3RvcjMuRG90KG5ldyBCQUJZTE9OLlZlY3RvcjMoMCwgMS4wLCAwKSwgdGhpcy51cFZlY3RvcikpO1xuXG4gICAgICAgIGlmIChpc05hTih0aGlzLnJvdGF0aW9uLngpKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMucm90YXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5yb3RhdGlvbi56KSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi56ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGFyZ2V0O1xuICAgIH07XG5cbiAgICAvLyBDb250cm9sc1xuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmF0dGFjaENvbnRyb2wgPSBmdW5jdGlvbiAoZWxlbWVudCwgbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbjtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgZW5naW5lID0gdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uTW91c2VEb3duID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlT3V0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoYXQuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1Bvc2l0aW9uICYmICFlbmdpbmUuaXNQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVuZ2luZS5pc1BvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBldnQuY2xpZW50WCAtIHByZXZpb3VzUG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IGV2dC5jbGllbnRZIC0gcHJldmlvdXNQb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBldnQubW92ZW1lbnRYIHx8IGV2dC5tb3pNb3ZlbWVudFggfHwgZXZ0LndlYmtpdE1vdmVtZW50WCB8fCBldnQubXNNb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IGV2dC5tb3ZlbWVudFkgfHwgZXZ0Lm1vek1vdmVtZW50WSB8fCBldnQud2Via2l0TW92ZW1lbnRZIHx8IGV2dC5tc01vdmVtZW50WSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQucm90YXRpb25EaXJlY3Rpb24ueSArPSBvZmZzZXRYIC8gdGhhdC5hbmd1bGFyU2Vuc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgdGhhdC5yb3RhdGlvbkRpcmVjdGlvbi54ICs9IG9mZnNldFkgLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvICh0aGF0LndoZWVsUHJlY2lzaW9uICogNDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIHRoYXQud2hlZWxQcmVjaXNpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhKVxuICAgICAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsUmFkaXVzT2Zmc2V0ICs9IGRlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzVXAuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0Rvd24uaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0xlZnQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c1JpZ2h0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0Ll9rZXlzLmluZGV4T2YoZXZ0LmtleUNvZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2tleXMucHVzaChldnQua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uS2V5VXAgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQua2V5c1VwLmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNEb3duLmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNMZWZ0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNSaWdodC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhhdC5fa2V5cy5pbmRleE9mKGV2dC5rZXlDb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fa2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbkxvc3RGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhhdC5tb3ZlRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB0aGF0LnJvdGF0aW9uRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMigwLCAwKTtcbiAgICAgICAgICAgICAgICB0aGF0Lnpvb21EaXJlY3Rpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLl9vbk1vdXNlT3V0LCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuXG4gICAgICAgIEJBQllMT04uVG9vbHMuUmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG4gICAgfTtcblxuICAgIFJBTkRPLkJpcmRDYW1lcmEucHJvdG90eXBlLmRldGFjaENvbnRyb2wgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRFbGVtZW50ICE9IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fb25XaGVlbCk7XG5cbiAgICAgICAgQkFCWUxPTi5Ub29scy5VbnJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5ZG93blwiLCBoYW5kbGVyOiB0aGlzLl9vbktleURvd24gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXl1cFwiLCBoYW5kbGVyOiB0aGlzLl9vbktleVVwIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYmx1clwiLCBoYW5kbGVyOiB0aGlzLl9vbkxvc3RGb2N1cyB9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9yZXNldCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5CaXJkQ2FtZXJhLnByb3RvdHlwZS5fY29sbGlkZVdpdGhXb3JsZCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICB2YXIgZ2xvYmFsUG9zaXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBnbG9iYWxQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0aGlzLnBvc2l0aW9uLCB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsb2JhbFBvc2l0aW9uLnN1YnRyYWN0RnJvbUZsb2F0c1RvUmVmKDAsIHRoaXMuZWxsaXBzb2lkLnksIDAsIHRoaXMuX29sZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fY29sbGlkZXIucmFkaXVzID0gdGhpcy5lbGxpcHNvaWQ7XG5cbiAgICAgICAgdGhpcy5nZXRTY2VuZSgpLl9nZXROZXdQb3NpdGlvbih0aGlzLl9vbGRQb3NpdGlvbiwgdmVsb2NpdHksIHRoaXMuX2NvbGxpZGVyLCAzLCB0aGlzLl9uZXdQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX25ld1Bvc2l0aW9uLnN1YnRyYWN0VG9SZWYodGhpcy5fb2xkUG9zaXRpb24sIHRoaXMuX2RpZmZQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RpZmZQb3NpdGlvbi5sZW5ndGgoKSA+IEJBQllMT04uRW5naW5lLkNvbGxpc2lvbnNFcHNpbG9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5fZGlmZlBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ29sbGlkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db2xsaWRlKHRoaXMuX2NvbGxpZGVyLmNvbGxpZGVkTWVzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2NoZWNrSW5wdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlcyB3aXRoIHRoZSBrZXlib2FyZFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gdGhpcy5fa2V5c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgc3BlZWQgPSB0aGlzLl9jb21wdXRlTG9jYWxDYW1lcmFTcGVlZCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzTGVmdC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKC1zcGVlZCwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMua2V5c1VwLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoMCwgMCwgc3BlZWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmtleXNSaWdodC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKHNwZWVkLCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5rZXlzRG93bi5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKDAsIDAsIC1zcGVlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCA9IEJBQllMT04uTWF0cml4LlJvdGF0aW9uWSh0aGlzLnJvdGF0aW9uLnkpO1xuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKFxuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCxcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbi5hZGRJblBsYWNlKHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdXNlIHdoZWVsIHpvb21cbiAgICAgICAgaWYgKHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQpIHtcbiAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoMCwgMCwgMSwgdGhpcy5fcmVmZXJlbmNlUG9pbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmdldFZpZXdNYXRyaXgoKS5pbnZlcnRUb1JlZih0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZmVyZW5jZVBvaW50LFxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeCxcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21EaXJlY3Rpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuem9vbURpcmVjdGlvbi5zY2FsZUluUGxhY2UodGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJbnB1dHMoKTtcblxuICAgICAgICB2YXIgbmVlZFRvTW92ZSA9IChcbiAgICAgICAgICAgIHRoaXMuX25lZWRNb3ZlRm9yR3Jhdml0eSB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5tb3ZlRGlyZWN0aW9uLngpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5tb3ZlRGlyZWN0aW9uLnkpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5tb3ZlRGlyZWN0aW9uLnopID4gMFxuICAgICAgICApO1xuICAgICAgICB2YXIgbmVlZFRvUm90YXRlID0gKFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5yb3RhdGlvbkRpcmVjdGlvbi54KSA+IDAgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMucm90YXRpb25EaXJlY3Rpb24ueSkgPiAwXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZWVkVG9ab29tID0gKFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy56b29tRGlyZWN0aW9uLngpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy56b29tRGlyZWN0aW9uLnkpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy56b29tRGlyZWN0aW9uLnopID4gMFxuICAgICAgICApO1xuICAgICAgICB2YXIgbmVlZENvbGxpc2lvbnMgPSB0aGlzLmNoZWNrQ29sbGlzaW9ucyAmJiB0aGlzLl9zY2VuZS5jb2xsaXNpb25zRW5hYmxlZDtcblxuICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgaWYgKG5lZWRUb1JvdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi54ICs9IHRoaXMucm90YXRpb25EaXJlY3Rpb24ueDtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueSArPSB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uLnk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5ub1JvdGF0aW9uQ29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IChNYXRoLlBJIC8gMikgKiAwLjk1O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm90YXRpb24ueCA+IGxpbWl0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggPSBsaW1pdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3RhdGlvbi54IDwgLWxpbWl0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggPSAtbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlcyBhbmQgY29sbGlzaW9uc1xuICAgICAgICBpZiAobmVlZFRvWm9vbSAmJiBuZWVkVG9Nb3ZlKSB7XG4gICAgICAgICAgICBpZiAobmVlZENvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRlV2l0aFdvcmxkKHRoaXMuem9vbURpcmVjdGlvbi5hZGQodGhpcy5tb3ZlRGlyZWN0aW9uKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLnpvb21EaXJlY3Rpb24uYWRkKHRoaXMubW92ZURpcmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5lZWRUb1pvb20pIHtcbiAgICAgICAgICAgIGlmIChuZWVkQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVXaXRoV29ybGQodGhpcy56b29tRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuem9vbURpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobmVlZFRvTW92ZSkge1xuICAgICAgICAgICAgaWYgKG5lZWRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZVdpdGhXb3JsZCh0aGlzLm1vdmVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5tb3ZlRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZXJ0aWFcbiAgICAgICAgaWYgKG5lZWRUb01vdmUpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLm1vdmVEaXJlY3Rpb24ueCkgPCBCQUJZTE9OLkVuZ2luZS5lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbi54ID0gMDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMubW92ZURpcmVjdGlvbi55KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5tb3ZlRGlyZWN0aW9uLnopIDwgQkFCWUxPTi5FbmdpbmUuZXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVEaXJlY3Rpb24ueiA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMubW92ZURpcmVjdGlvbi5zY2FsZUluUGxhY2UodGhpcy5pbmVydGlhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZFRvUm90YXRlKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5yb3RhdGlvbkRpcmVjdGlvbi54KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbi54ID0gMDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMucm90YXRpb25EaXJlY3Rpb24ueSkgPCBCQUJZTE9OLkVuZ2luZS5lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24ueSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24uc2NhbGVJblBsYWNlKHRoaXMuaW5lcnRpYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRUb1pvb20pIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0KSA8IEJBQllMT04uRW5naW5lLmVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQgKj0gdGhpcy5pbmVydGlhO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRhcmdldDtcbiAgICB9O1xuXG4gICAgUkFORE8uQmlyZENhbWVyYS5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJBQllMT04uVmVjdG9yMy5Gcm9tRmxvYXRzVG9SZWYoMCwgMCwgMSwgdGhpcy5fcmVmZXJlbmNlUG9pbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5sb2NrZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGVcbiAgICAgICAgICAgIGlmICh0aGlzLnVwVmVjdG9yLnggIT0gMCB8fCB0aGlzLnVwVmVjdG9yLnkgIT0gMS4wIHx8IHRoaXMudXBWZWN0b3IueiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguTG9va0F0TEhUb1JlZihCQUJZTE9OLlZlY3RvcjMuWmVybygpLCB0aGlzLl9yZWZlcmVuY2VQb2ludCwgdGhpcy51cFZlY3RvciwgdGhpcy5fbG9va0F0VGVtcCk7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksIHRoaXMucm90YXRpb24ueCwgdGhpcy5yb3RhdGlvbi56LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rQXRUZW1wLm11bHRpcGx5VG9SZWYodGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgsIHRoaXMuX3RlbXBNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvb2tBdFRlbXAuaW52ZXJ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcE1hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX2xvb2tBdFRlbXAsIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQkFCWUxPTi5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksIHRoaXMucm90YXRpb24ueCwgdGhpcy5yb3RhdGlvbi56LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMuX3JlZmVyZW5jZVBvaW50LCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCwgdGhpcy5fdHJhbnNmb3JtZWRSZWZlcmVuY2VQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGluZyB0YXJnZXQgYW5kIGZpbmFsIG1hdHJpeFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGRUb1JlZih0aGlzLl90cmFuc2Zvcm1lZFJlZmVyZW5jZVBvaW50LCB0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQuY29weUZyb20odGhpcy5fZ2V0TG9ja2VkVGFyZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBCQUJZTE9OLk1hdHJpeC5Mb29rQXRMSFRvUmVmKHRoaXMucG9zaXRpb24sIHRoaXMuX2N1cnJlbnRUYXJnZXQsIHRoaXMudXBWZWN0b3IsIHRoaXMuX3ZpZXdNYXRyaXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld01hdHJpeDtcbiAgICB9O1xufTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uQ2FtZXJhQ29tcHV0ZXIuanNcbiAqXG4gKiBDYW1lcmFDb21wdXRlciBjbGFzcyA6XG4gKiAgVXNlZCB0byBzZXBhcmF0ZSBjYWxjdWxhdGlvbnMgZnJvbSB0aGUgQ2FtZXJhQ29udGFpbmVyXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIgPSBmdW5jdGlvbiAoY2VudGVyLCBleHRlbnQsIGFsdGl0dWRlcywgb2Zmc2V0cywgc2NlbmUsIG51bWJlcikge1xuICAgICAgICB0aGlzLl9jZW50ZXIgICAgICAgID0ge1xuICAgICAgICAgICAgJ3gnIDogY2VudGVyLnggKyBvZmZzZXRzLngsXG4gICAgICAgICAgICAneScgOiBjZW50ZXIueSxcbiAgICAgICAgICAgICd6JyA6IGNlbnRlci56ICsgb2Zmc2V0cy56XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RvdGFsRXh0ZW50ICAgPSB7XG4gICAgICAgICAgICAneCcgOiB7XG4gICAgICAgICAgICAgICAgJ21pbicgOiBleHRlbnQueC5taW4gKyBvZmZzZXRzLngsXG4gICAgICAgICAgICAgICAgJ21heCcgOiBleHRlbnQueC5tYXggKyBvZmZzZXRzLnhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAneScgOiB7XG4gICAgICAgICAgICAgICAgJ21pbicgOiBleHRlbnQueS5taW4sXG4gICAgICAgICAgICAgICAgJ21heCcgOiBleHRlbnQueS5tYXhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAneicgOiB7XG4gICAgICAgICAgICAgICAgJ21pbicgOiBleHRlbnQuei5taW4gKyBvZmZzZXRzLnosXG4gICAgICAgICAgICAgICAgJ21heCcgOiBleHRlbnQuei5tYXggKyBvZmZzZXRzLnpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGVzID0gYWx0aXR1ZGVzO1xuICAgICAgICB0aGlzLl9zcXVhcmVzICAgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxwaGFTcXVhcmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1iZXIgPSBudW1iZXIgfHwgNTtcbiAgICB9O1xuXG4gICAgLyogTWV0aG9kcyAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbFBvc2l0aW9uVG9SZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlU3F1YXJlcyAoKTtcbiAgICAgICAgdGhpcy5fZmluZEFscGhhU3F1YXJlICgpO1xuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvblRvUmVmIChpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAvL34gdGhpcy5fYnVpbGRTcXVhcmVWaWV3ZXIoKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsVGFyZ2V0VG9SZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFRhcmdldCkge1xuICAgICAgICBpbml0aWFsVGFyZ2V0LnggPSB0aGlzLl9jZW50ZXIueDtcbiAgICAgICAgaW5pdGlhbFRhcmdldC55ID0gMDtcbiAgICAgICAgaW5pdGlhbFRhcmdldC56ID0gdGhpcy5fY2VudGVyLno7XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5jb21wdXRlTGltaXRzVG9SZWYgPSBmdW5jdGlvbiAobGltaXRzKSB7XG4gICAgICAgIGxpbWl0cy5sb3dlclggPSB0aGlzLl90b3RhbEV4dGVudC54Lm1pbjtcbiAgICAgICAgbGltaXRzLnVwcGVyWCA9IHRoaXMuX3RvdGFsRXh0ZW50LngubWF4O1xuICAgICAgICBsaW1pdHMubG93ZXJaID0gdGhpcy5fdG90YWxFeHRlbnQuei5taW47XG4gICAgICAgIGxpbWl0cy51cHBlclogPSB0aGlzLl90b3RhbEV4dGVudC56Lm1heDtcblxuICAgICAgICBsaW1pdHMubG93ZXJSYWRpdXMgPSBSQU5ETy5TRVRUSU5HUy5NSU5fVEhJQ0tORVNTICsgdGhpcy5fY2VudGVyLnk7XG4gICAgICAgIGxpbWl0cy51cHBlclJhZGl1cyA9IDgwMDA7XG4gICAgfTtcblxuXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLl9nZW5lcmF0ZVNxdWFyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpbGwgc3F1YXJlJ3MgZXh0ZW50cyAobmVlZGVkIHRvIGRldGVybWluZSBpbmRpY2VzKVxuICAgICAgICB2YXIgc3F1YXJlR3JpZCA9IFJBTkRPLlV0aWxzLmNyZWF0ZUZsYXRHcmlkKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd4JyA6IHRoaXMuX3RvdGFsRXh0ZW50LngubWluLFxuICAgICAgICAgICAgICAgICd5JyA6IHRoaXMuX3RvdGFsRXh0ZW50LnoubWluXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd4JyA6IHRoaXMuX3RvdGFsRXh0ZW50LngubWF4LFxuICAgICAgICAgICAgICAgICd5JyA6IHRoaXMuX3RvdGFsRXh0ZW50LnoubWluXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd4JyA6IHRoaXMuX3RvdGFsRXh0ZW50LngubWF4LFxuICAgICAgICAgICAgICAgICd5JyA6IHRoaXMuX3RvdGFsRXh0ZW50LnoubWF4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICd4JyA6IHRoaXMuX3RvdGFsRXh0ZW50LngubWluLFxuICAgICAgICAgICAgICAgICd5JyA6IHRoaXMuX3RvdGFsRXh0ZW50LnoubWF4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyKzEsXG4gICAgICAgICAgICB0aGlzLl9udW1iZXIrMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9maWxsRXh0ZW50cyAoc3F1YXJlR3JpZCk7XG5cbiAgICAgICAgLy8gRmlsbCBzcXVhcmUncyB0eXBlc1xuICAgICAgICB0aGlzLl9maWxsVHlwZXMgKCk7XG5cbiAgICAgICAgLy8gRmlsbCBzcXVhcmUncyBpbmRpY2VzXG4gICAgICAgIHZhciBlbGV2YXRlZFBvaW50cyA9IFJBTkRPLlV0aWxzLmNyZWF0ZUVsZXZhdGlvbkdyaWQgKFxuICAgICAgICAgICAgdGhpcy5fdG90YWxFeHRlbnQueC5taW4sXG4gICAgICAgICAgICB0aGlzLl90b3RhbEV4dGVudC54Lm1heCxcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsRXh0ZW50LnoubWluLFxuICAgICAgICAgICAgdGhpcy5fdG90YWxFeHRlbnQuei5tYXgsXG4gICAgICAgICAgICB0aGlzLl9hbHRpdHVkZXNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fZmlsbEluZGljZXMgKGVsZXZhdGVkUG9pbnRzKTtcblxuICAgICAgICAvLyBGaWxsIHNxdWFyZSdzIG5laWdoYm9yaG9vZFxuICAgICAgICB0aGlzLl9maWxsTmVpZ2hib3Job29kICgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fZmlsbEV4dGVudHMoKSA6IEZpbGwgdGhlIGV4dGVudCBwcm9wZXJ0eSBvZiBhbGwgc3F1YXJlc1xuICAgICAqICAtIGdyaWQgOiBhIGZsYXQgZ3JpZCBjb250YWluaW5nIHBvaW50cyBvZiBzcXVhcmVzXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLl9maWxsRXh0ZW50cyA9IGZ1bmN0aW9uIChncmlkKSB7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDAgOyByb3cgPCBncmlkLmxlbmd0aC0xIDsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDAgOyBjb2wgPCBncmlkW3Jvd10ubGVuZ3RoLTEgOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NxdWFyZXMucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnZXh0ZW50JyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd4JyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluJyA6IGdyaWRbcm93XVtjb2xdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCcgOiBncmlkW3JvdysxXVtjb2wrMV0ueFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd6JyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluJyA6IGdyaWRbcm93XVtjb2xdLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCcgOiBncmlkW3JvdysxXVtjb2wrMV0ueVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29tcHV0ZXIuX2ZpbGxUeXBlcygpIDogRmlsbCB0aGUgdHlwZSBwcm9wZXJ0eSBvZiBhbGwgc3F1YXJlc1xuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5fZmlsbFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDT1JORVIgdHlwZXNcbiAgICAgICAgdGhpcy5fc3F1YXJlc1swXS50eXBlID0gXCJDT1JORVJcIjsgLy8gbGVmdC1kb3duIGNvcm5lclxuICAgICAgICB0aGlzLl9zcXVhcmVzW3RoaXMuX251bWJlciAtIDFdLnR5cGUgPSBcIkNPUk5FUlwiOyAvLyByaWdodC1kb3duIGNvcm5lclxuICAgICAgICB0aGlzLl9zcXVhcmVzWyh0aGlzLl9udW1iZXIgLSAxKSAqIHRoaXMuX251bWJlcl0udHlwZSA9IFwiQ09STkVSXCI7IC8vIGxlZnQtdXAgY29ybmVyXG4gICAgICAgIHRoaXMuX3NxdWFyZXNbKHRoaXMuX251bWJlciAqIHRoaXMuX251bWJlcikgLSAxXS50eXBlID0gXCJDT1JORVJcIjsgLy8gcmlnaHQtdXAgY29ybmVyXG5cbiAgICAgICAgLy8gRXh0ZXJuIEJPUkRFUiB0eXBlc1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX251bWJlciAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1tpXS50eXBlID0gXCJFWFRCT1JERVJcIjsgLy8gZG93biBib3JkZXJcbiAgICAgICAgICAgIHRoaXMuX3NxdWFyZXNbKHRoaXMuX251bWJlciAtIDEpICogdGhpcy5fbnVtYmVyICsgaV0udHlwZSA9IFwiRVhUQk9SREVSXCI7IC8vIHRvcCBib3JkZXJcbiAgICAgICAgICAgIHRoaXMuX3NxdWFyZXNbdGhpcy5fbnVtYmVyICogaV0udHlwZSA9IFwiRVhUQk9SREVSXCI7IC8vIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICB0aGlzLl9zcXVhcmVzW3RoaXMuX251bWJlciAqIGkgKyB0aGlzLl9udW1iZXIgLTFdLnR5cGUgPSBcIkVYVEJPUkRFUlwiOy8vIHJpZ2h0IGJvcmRlclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJuIEJPUkRFUiB0eXBlc1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX251bWJlciAtIDE7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1tpICsgdGhpcy5fbnVtYmVyXS50eXBlID0gXCJJTlRCT1JERVJcIjsvLyBkb3duIGludGVybmFsIGJvcmRlclxuICAgICAgICAgICAgdGhpcy5fc3F1YXJlc1tpICsgdGhpcy5fbnVtYmVyICsgKHRoaXMuX251bWJlci0zKSAqIHRoaXMuX251bWJlcl0udHlwZSA9IFwiSU5UQk9SREVSXCI7XG4gICAgICAgICAgICB0aGlzLl9zcXVhcmVzW2kgKiB0aGlzLl9udW1iZXIgKyAxXS50eXBlID0gXCJJTlRCT1JERVJcIjtcbiAgICAgICAgICAgIHRoaXMuX3NxdWFyZXNbaSAqIHRoaXMuX251bWJlciArIDEgKyAodGhpcy5fbnVtYmVyLTMpXS50eXBlID0gXCJJTlRCT1JERVJcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCTEFDSyB0eXBlc1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLl9zcXVhcmVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NxdWFyZXNbaXRdLnR5cGUpIHRoaXMuX3NxdWFyZXNbaXRdLnR5cGUgPSBcIkJMQUNLXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29tcHV0ZXIuX2ZpbGxJbmRpY2VzKCkgOiBGaWxsIHRoZSBpbmRleCBwcm9wZXJ0eSBvZiBhbGwgc3F1YXJlc1xuICAgICAqICAtIGVsZXZhdGVkUG9pbnRzIDogYSB0d28tYXJyYXkgb2YgYWxsIDNEIHBvaW50cyBvZiB0aGUgREVNXG4gICAgICpcbiAgICAgKiBOQiA6IEl0IG5lZWRzIHRvIGhhdmUgYWxyZWFkeSBjb21wdXRlZCB0aGUgZXh0ZW50IGFuZCB0aGUgdHlwZSBvZiBlYWNoIHNxdWFyZVxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbXB1dGVyLnByb3RvdHlwZS5fZmlsbEluZGljZXMgPSBmdW5jdGlvbiAoZWxldmF0ZWRQb2ludHMpIHtcbiAgICAgICAgLy8gSW5jcmVtZW50IGluZGljZXMgb2Ygc3F1YXJlcyB3aXRoIGVsZXZhdGVkIHBvaW50cyB3aGljaCBhcmUgaW5zaWRlXG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGVsZXZhdGVkUG9pbnRzLmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGVsZXZhdGVkUG9pbnRzW3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGVsZXZhdGVkUG9pbnRzW3Jvd11bY29sXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLl9zcXVhcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcXVhcmUgPSB0aGlzLl9zcXVhcmVzW2l0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNxdWFyZS50eXBlICE9IFwiQkxBQ0tcIiAmJiBSQU5ETy5VdGlscy5pc0luRXh0ZW50KHBvc2l0aW9uLCBzcXVhcmUuZXh0ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNxdWFyZS5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZS5pbmRleCArPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZS5uYl9hbHQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3F1YXJlLmluZGV4ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUubmJfYWx0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbmRleCBiZXR3ZWVuIDAgYW5kIDEwIHdoaWNoIHJlcHJlc2VudHMgdGhlIGVsZXZhdGlvbidzIGF2ZXJhZ2Ugb2YgYSBzcXVhcmVcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGhpcy5fc3F1YXJlcykge1xuICAgICAgICAgICAgdmFyIHNxdWFyZSA9IHRoaXMuX3NxdWFyZXNbaXRdO1xuICAgICAgICAgICAgc3F1YXJlLmluZGV4ID0gc3F1YXJlLmluZGV4IC8gc3F1YXJlLm5iX2FsdDtcbiAgICAgICAgICAgIHNxdWFyZS5pbmRleCA9IHNxdWFyZS5pbmRleCAqIDEwIC8gKHRoaXMuX3RvdGFsRXh0ZW50LnkubWF4ICAtIHRoaXMuX3RvdGFsRXh0ZW50LnkubWluKTtcbiAgICAgICAgICAgIGlmIChzcXVhcmUudHlwZSA9PSBcIkJMQUNLXCIpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUuaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb21wdXRlci5fZmlsbE5laWdoYm9yaG9vZCgpIDogRmlsbCB0aGUgbmVpZ2hib3Job29kIHByb3BlcnR5IG9mIHNxdWFyZXNcbiAgICAgKiB3aGljaCBhcmUgb2YgQ09STkVSIG9yIEVYVEJPUkRFUiB0eXBlc1xuICAgICAqXG4gICAgICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIFRoZSBuZWlnaGJvcmhvb2QgY29udGFpbnMgYWxsIG5laWdoYm91cnMgb2YgYSBzcXVhcmUgZm9sbG93aW5nIHRoaXMgc2NoZWR1bGUgOlxuICAgICAqXG4gICAgICogICAgICAgICAgQ09STkVSIDpcbiAgICAgKiAgICAgIHxcbiAgICAgKiAgICAgIG5cbiAgICAgKiAgICAgIG4gblxuICAgICAqICAgICAgcyBuIG4gX1xuICAgICAqXG4gICAgICogICAgICAgICAgRVhUQk9SREVSIDpcbiAgICAgKiAgICAgIG4gbiBuXG4gICAgICogICAgXyBuIHMgbiBfXG4gICAgICpcbiAgICAgKiBXaXRoXG4gICAgICogIHMgPSBzcXVhcmUgd2Ugd2FudCB0byBnZXQgaXRzIG5laWdoYm91cnNcbiAgICAgKiAgbiA9IG5laWdoYm91cnMgb2YgdGhlIHNxdWFyZVxuICAgICAqXG4gICAgICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIE5CIDogLSBUaGUgc3F1YXJlIHdpbGwgYmUgY291bnRlZCBpbiBpdHMgbmVpZ2hib3Job29kXG4gICAgICogICAgICAtIEl0IG5lZWRzIHRvIGhhdmUgYWxyZWFkeSBjb21wdXRlZCB0aGUgaW5kZXggb2YgZWFjaCBzcXVhcmVcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX2ZpbGxOZWlnaGJvcmhvb2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkeCwgZHksIHRfZHgsIHRfZHkgPSBbLXRoaXMuX251bWJlciwgdGhpcy5fbnVtYmVyXTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyID0gMDsgY3VyciA8IHRoaXMuX3NxdWFyZXMubGVuZ3RoOyBjdXJyKyspIHtcbiAgICAgICAgICAgIHZhciBzcXVhcmUgPSB0aGlzLl9zcXVhcmVzW2N1cnJdO1xuXG4gICAgICAgICAgICBpZiAoc3F1YXJlLnR5cGUgPT0gXCJDT1JORVJcIikge1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyciV0aGlzLl9udW1iZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkeCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkeCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3F1YXJlc1tjdXJyICsgdGhpcy5fbnVtYmVyXSkge1xuICAgICAgICAgICAgICAgICAgICBkeSA9IHRoaXMuX251bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gLXRoaXMuX251bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3F1YXJlLm5laWdoYm9yaG9vZC5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaChjdXJyICsgZHgpO1xuICAgICAgICAgICAgICAgIHNxdWFyZS5uZWlnaGJvcmhvb2QucHVzaChjdXJyICsgMiAqIGR4KTtcbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2goY3VyciArIGR5KTtcbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2goY3VyciArIDIgKiBkeSk7XG4gICAgICAgICAgICAgICAgc3F1YXJlLm5laWdoYm9yaG9vZC5wdXNoKGN1cnIgKyBkeCArIGR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNxdWFyZS50eXBlID09IFwiRVhUQk9SREVSXCIpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIldGhpcy5fbnVtYmVyID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdF9keCA9IFswLCAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyciV0aGlzLl9udW1iZXIgPT0gdGhpcy5fbnVtYmVyIC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRfZHggPSBbLTEsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdF9keCA9IFstMSwgMCwgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdF9keCkge1xuICAgICAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2ggKGN1cnIgKyB0X2R4W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiB0X2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3F1YXJlc1tjdXJyICsgdF9keVtqXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kLnB1c2ggKGN1cnIgKyB0X2R4W2ldICsgdF9keVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUubmVpZ2hib3Job29kID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29tcHV0ZXIuX2ZpbmRBbHBoYVNxdWFyZSgpIDogRmluZCB0aGUgQWxwaGEgU3F1YXJlXG4gICAgICogIFRoZSBhbHBoYSBzcXVhcmUgaXMgdGhlIHNxdWFyZSB3aGljaCBoYXZlIHRoZSBuZWlnaGJvcmhvb2Qgd2l0aCB0aGUgbG93ZXN0IGluZGljZXMgdmFsdWVzXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29tcHV0ZXIucHJvdG90eXBlLl9maW5kQWxwaGFTcXVhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5fYWxwaGFTcXVhcmUgPSBfLm1pbih0aGlzLl9zcXVhcmVzLCBmdW5jdGlvbiAoc3F1YXJlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgICAgIGlmICghc3F1YXJlLm5laWdoYm9yaG9vZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpdCBpbiBzcXVhcmUubmVpZ2hib3Job29kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoYXQuX3NxdWFyZXNbc3F1YXJlLm5laWdoYm9yaG9vZFtpdF1dLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbXB1dGVyLl9zZXRQb3NpdGlvblRvUmVmKCkgOiBzZXQgdGhlIHBvc2l0aW9uIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqICBhY2NvcmRpbmcgdG8gdGhlIGFscGhhIHNxdWFyZSBwb3NpdGlvblxuICAgICAqXG4gICAgICogIC0gcmVzdWx0IDogcmVmZXJlbmNlIHRvIHRoZSBwb3NpdGlvbiB0byBjaGFuZ2VcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX3NldFBvc2l0aW9uVG9SZWYgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIC8vIEFscGhhIHBvc2l0aW9uIDogZWxldmF0aW9uIGRvIG5vdCBtYXR0ZXJcbiAgICAgICAgdmFyIEEgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKFxuICAgICAgICAgICAgKHRoaXMuX2FscGhhU3F1YXJlLmV4dGVudC54Lm1heCArIHRoaXMuX2FscGhhU3F1YXJlLmV4dGVudC54Lm1pbikgLzIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgKHRoaXMuX2FscGhhU3F1YXJlLmV4dGVudC56Lm1heCArIHRoaXMuX2FscGhhU3F1YXJlLmV4dGVudC56Lm1pbikgLzJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDZW50ZXIgcG9zaXRpb25cbiAgICAgICAgdmFyIE8gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKFxuICAgICAgICAgICAgdGhpcy5fY2VudGVyLngsXG4gICAgICAgICAgICB0aGlzLl9jZW50ZXIueSxcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlci56XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gMi41O1xuICAgICAgICB2YXIgT0MgPSBBLnN1YnRyYWN0KE8pLnNjYWxlKHNjYWxlKTtcblxuICAgICAgICAvLyBDYW1lcmEgcG9zaXRpb25cbiAgICAgICAgdmFyIEMgPSBPQy5hZGQoTyk7XG4gICAgICAgIHJlc3VsdC54ID0gQy54O1xuICAgICAgICByZXN1bHQueSA9IHRoaXMuX2NlbnRlci55ICsgKHRoaXMuX3RvdGFsRXh0ZW50LnkubWF4IC0gdGhpcy5fdG90YWxFeHRlbnQueS5taW4pO1xuICAgICAgICByZXN1bHQueiA9IEMuejtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29tcHV0ZXIuX2J1aWxkU3F1YXJlVmlld2VyKCkgOiBidWlsZCBhIHZpZXdlciB3aGljaCBtYXRlcmlhbGl6ZVxuICAgICAqICBkaWZmZXJlbnRzIHNxdWFyZXMgaW4gc3BoZXJlcyBvZiBjb2xvclxuICAgICAqXG4gICAgICogIENPUk5FUiBzcXVhcmVzIGFyZSBncmVlblxuICAgICAqICBFeHRlcm4gQk9SREVSIHNxdWFyZXMgYXJlIGJsdWVcbiAgICAgKiAgSW50ZXJuIEJPUkRFUiBzcXVhcmVzIGFyZSBvcmFuZ2VcbiAgICAgKiAgSW50ZXJuIHNxdWFyZXMgYXJlIGJsYWNrXG4gICAgICogIEFscGhhIFNxdWFyZSBpcyByZWRcbiAgICAgKi9cbiAgICBSQU5ETy5DYW1lcmFDb21wdXRlci5wcm90b3R5cGUuX2J1aWxkU3F1YXJlVmlld2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLl9zcXVhcmVzKSB7XG4gICAgICAgICAgICB2YXIgc3BoZXJlID0gQkFCWUxPTi5NZXNoLkNyZWF0ZVNwaGVyZShcbiAgICAgICAgICAgICAgICBcIlNxdWFyZSBcIiArIGl0LFxuICAgICAgICAgICAgICAgIDEwLCAxMDAsXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NlbmVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNwaGVyZS5wb3NpdGlvbi54ID0gKHRoaXMuX3NxdWFyZXNbaXRdLmV4dGVudC54Lm1pbiArIHRoaXMuX3NxdWFyZXNbaXRdLmV4dGVudC54Lm1heCkgLzI7XG4gICAgICAgICAgICBzcGhlcmUucG9zaXRpb24ueSA9IHRoaXMuX3RvdGFsRXh0ZW50LnkubWF4O1xuICAgICAgICAgICAgc3BoZXJlLnBvc2l0aW9uLnogPSAodGhpcy5fc3F1YXJlc1tpdF0uZXh0ZW50LnoubWluICsgdGhpcy5fc3F1YXJlc1tpdF0uZXh0ZW50LnoubWF4KSAvMjtcbiAgICAgICAgICAgIHNwaGVyZS5tYXRlcmlhbCA9IG5ldyBCQUJZTE9OLlN0YW5kYXJkTWF0ZXJpYWwoXCJTcXVhcmUgXCIgKyBpdCArIFwiIC0gTWF0ZXJpYWxcIiwgdGhpcy5fc2NlbmUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhU3F1YXJlID09IHRoaXMuX3NxdWFyZXNbaXRdKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlLm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG5ldyBCQUJZTE9OLkNvbG9yMygxLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3NxdWFyZXNbaXRdLnR5cGUgPT0gXCJDT1JORVJcIikge1xuICAgICAgICAgICAgICAgIHNwaGVyZS5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMCwgMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zcXVhcmVzW2l0XS50eXBlID09IFwiRVhUQk9SREVSXCIpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmUubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbmV3IEJBQllMT04uQ29sb3IzKDAsIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3F1YXJlc1tpdF0udHlwZSA9PSBcIklOVEJPUkRFUlwiKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlLm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG5ldyBCQUJZTE9OLkNvbG9yMygxLCAwLjUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3F1YXJlc1tpdF0udHlwZSA9PSBcIkJMQUNLXCIpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmUubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbmV3IEJBQllMT04uQ29sb3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwaGVyZSA9IEJBQllMT04uTWVzaC5DcmVhdGVTcGhlcmUoXCJDZW50ZXJcIiwgMTAsIDEwMCwgdGhpcy5fc2NlbmUpO1xuICAgICAgICBzcGhlcmUucG9zaXRpb24ueCA9IHRoaXMuX2NlbnRlci54O1xuICAgICAgICBzcGhlcmUucG9zaXRpb24ueSA9IHRoaXMuX3RvdGFsRXh0ZW50LnkubWF4O1xuICAgICAgICBzcGhlcmUucG9zaXRpb24ueiA9IHRoaXMuX2NlbnRlci56O1xuICAgIH07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5DYW1lcmFDb250YWluZXIuanNcbiAqXG4gKiBDYW1lcmFDb250YWluZXIgY2xhc3MgOlxuICogIEEgY29udGFpbmVyIHdoaWNoIHdpbGwgY29udGFpbnMgYWxsIGNhbWVyYXMgb2YgdGhlIHNjZW5lXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyID0gZnVuY3Rpb24gKGNhbnZhcywgc2NlbmUsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMuX3N3aXRjaEVuYWJsZWQgPSBwYXJhbXMuc3dpdGNoRW5hYmxlZCB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlciA9IG5ldyBSQU5ETy5DYW1lcmFDb21wdXRlciAoXG4gICAgICAgICAgICBwYXJhbXMuZGVtQ2VudGVyLFxuICAgICAgICAgICAgcGFyYW1zLmRlbUV4dGVudCxcbiAgICAgICAgICAgIHBhcmFtcy5kZW1BbHRpdHVkZXMsXG4gICAgICAgICAgICBwYXJhbXMub2Zmc2V0cyB8fCBCQUJZTE9OLlZlY3RvcjMuWmVybygpLFxuICAgICAgICAgICAgc2NlbmUsXG4gICAgICAgICAgICA2XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFzID0ge307XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uUGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xzQXR0YWNoZWQgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQmVmb3JlU3dpdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0QmVmb3JlU3dpdGNoID0gbnVsbDtcblxuICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFRhcmdldCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMubGltaXRzID0ge1xuICAgICAgICAgICAgJ2xvd2VyWCcgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICd1cHBlclgnICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAnbG93ZXJaJyAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgJ3VwcGVyWicgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICdsb3dlclJhZGl1cycgICA6IG51bGwsXG4gICAgICAgICAgICAndXBwZXJSYWRpdXMnICAgOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfTtcblxuICAgIC8vIFN0YXRpYyBBcnJheSBkZWZpbmluZyBwb3NzaWJsZXMgY2FtZXJhcyBJRHNcbiAgICBSQU5ETy5DYW1lcmFJRHMgPSBbXCJleGFtaW5lXCIsIFwiYmlyZFwiLCBcImhpa2VyXCJdO1xuXG4gICAgLyogTWV0aG9kcyAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tcHV0ZUluaXRpYWxQYXJhbWV0ZXJzICgpO1xuICAgICAgICB0aGlzLl9idWlsZEJpcmRDYW1lcmEgKCk7XG4gICAgICAgIHRoaXMuX2J1aWxkRXhhbWluZUNhbWVyYSAoKTtcbiAgICAgICAgdGhpcy5fYnVpbGRIaWtlckNhbWVyYSAoKTtcbiAgICAgICAgdGhpcy5faW5pdEludGVyZmFjZSgpO1xuICAgICAgICB0aGlzLl9jYW1lcmFTd2l0Y2hlciAoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uQ2FtZXJhQ29udGFpbmVyLl9idWlsZEV4YW1pbmVDYW1lcmEoKSA6IGJ1aWxkIG9mIHRoZSBFeGFtaW5lIGNhbWVyYVxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX2J1aWxkRXhhbWluZUNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4YW1pbmVfY2FtZXJhID0gbmV3IFJBTkRPLkV4YW1pbmVDYW1lcmEoXG4gICAgICAgICAgICBcIkV4YW1pbmUgQ2FtZXJhXCIsMCwgMCwgMCxcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFRhcmdldCxcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lXG4gICAgICAgICk7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmlkID0gXCJleGFtaW5lXCI7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmtleXNVcCAgICAgPSBbOTAsIDM4XTsgLy8gVG91Y2hlIFogYW5kIHVwXG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmtleXNEb3duICAgPSBbODMsIDQwXTsgLy8gVG91Y2hlIFMgYW5kIGRvd25cbiAgICAgICAgZXhhbWluZV9jYW1lcmEua2V5c0xlZnQgICA9IFs4MSwgMzddOyAvLyBUb3VjaGUgUSBhbmQgbGVmdFxuICAgICAgICBleGFtaW5lX2NhbWVyYS5rZXlzUmlnaHQgID0gWzY4LCAzOV07IC8vIFRvdWNoZSBEIGFuZCByaWdodFxuXG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLndoZWVsUHJlY2lzaW9uID0gMC4yO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS5jaGVja0NvbGxpc2lvbnMgPSB0cnVlO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS5lbGxpcHNvaWQueSA9IFJBTkRPLlNFVFRJTkdTLkNPTExJU0lPTlNfT0ZGU0VUO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS5tYXhaID0gNTAwMDA7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLnNwZWVkID0gUkFORE8uU0VUVElOR1MuQ0FNX1NQRUVEX0YgO1xuXG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLmxvd2VyWExpbWl0ID0gdGhpcy5saW1pdHMubG93ZXJYO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS5sb3dlclpMaW1pdCA9IHRoaXMubGltaXRzLmxvd2VyWjtcbiAgICAgICAgZXhhbWluZV9jYW1lcmEudXBwZXJYTGltaXQgPSB0aGlzLmxpbWl0cy51cHBlclg7XG4gICAgICAgIGV4YW1pbmVfY2FtZXJhLnVwcGVyWkxpbWl0ID0gdGhpcy5saW1pdHMudXBwZXJaO1xuICAgICAgICBleGFtaW5lX2NhbWVyYS51cHBlckJldGFMaW1pdCA9IE1hdGguUEkvMjtcblxuICAgICAgICB0aGlzLmNhbWVyYXMuZXhhbWluZSA9IGV4YW1pbmVfY2FtZXJhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5DYW1lcmFDb250YWluZXIuX2J1aWxkQmlyZENhbWVyYSgpIDogYnVpbGQgb2YgdGhlIEJpcmQgY2FtZXJhXG4gICAgICovXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fYnVpbGRCaXJkQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmlyZF9jYW1lcmEgPSBuZXcgUkFORE8uQmlyZENhbWVyYShcbiAgICAgICAgICAgIFwiQmlyZCBDYW1lcmFcIixcbiAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5aZXJvKCksXG4gICAgICAgICAgICB0aGlzLl9zY2VuZVxuICAgICAgICApO1xuICAgICAgICBiaXJkX2NhbWVyYS5pZCA9IFwiYmlyZFwiO1xuICAgICAgICBiaXJkX2NhbWVyYS5rZXlzVXAgICAgID0gWzkwLCAzOF07IC8vIFRvdWNoZSBaIGFuZCB1cFxuICAgICAgICBiaXJkX2NhbWVyYS5rZXlzRG93biAgID0gWzgzLCA0MF07IC8vIFRvdWNoZSBTIGFuZCBkb3duXG4gICAgICAgIGJpcmRfY2FtZXJhLmtleXNMZWZ0ICAgPSBbODEsIDM3XTsgLy8gVG91Y2hlIFEgYW5kIGxlZnRcbiAgICAgICAgYmlyZF9jYW1lcmEua2V5c1JpZ2h0ICA9IFs2OCwgMzldOyAvLyBUb3VjaGUgRCBhbmQgcmlnaHRcblxuICAgICAgICBiaXJkX2NhbWVyYS5jaGVja0NvbGxpc2lvbnMgPSB0cnVlO1xuICAgICAgICBiaXJkX2NhbWVyYS5lbGxpcHNvaWQueSA9IFJBTkRPLlNFVFRJTkdTLkNPTExJU0lPTlNfT0ZGU0VUO1xuICAgICAgICBiaXJkX2NhbWVyYS5tYXhaID0gNTAwMDA7XG4gICAgICAgIGJpcmRfY2FtZXJhLnNwZWVkID0gUkFORE8uU0VUVElOR1MuQ0FNX1NQRUVEX0YgO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhcy5iaXJkID0gYmlyZF9jYW1lcmE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5fYnVpbGRIaWtlckNhbWVyYSgpIDogYnVpbGQgb2YgdGhlIEhpa2VyIGNhbWVyYVxuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX2J1aWxkSGlrZXJDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoaWtlcl9jYW1lcmEgPSBuZXcgUkFORE8uSGlrZXJDYW1lcmEoXG4gICAgICAgICAgICBcIkhpa2VyIENhbWVyYVwiLFxuICAgICAgICAgICAgQkFCWUxPTi5WZWN0b3IzLlplcm8oKSxcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lXG4gICAgICAgICk7XG4gICAgICAgIGhpa2VyX2NhbWVyYS5pZCA9IFwiaGlrZXJcIjtcblxuICAgICAgICBoaWtlcl9jYW1lcmEuY2hlY2tDb2xsaXNpb25zID0gdHJ1ZTtcbiAgICAgICAgaGlrZXJfY2FtZXJhLm1heFogPSA1MDAwMDtcblxuICAgICAgICBoaWtlcl9jYW1lcmEucmV0dXJuU3BlZWQgPSBSQU5ETy5TRVRUSU5HUy5IQ0FNX1JFVFVSTl9TUEVFRDtcbiAgICAgICAgaGlrZXJfY2FtZXJhLmZvbGxvd1NwZWVkID0gUkFORE8uU0VUVElOR1MuSENBTV9GT0xMT1dfU1BFRUQ7XG5cblxuICAgICAgICB0aGlzLmNhbWVyYXMuaGlrZXIgPSBoaWtlcl9jYW1lcmE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5zZXRBY3RpdmVDYW1lcmEoKSA6IHNldCB0aGUgYWN0aXZlIGNhbWVyYSBvZiB0aGUgc2NlbmVcbiAgICAgKiAgICAgIC0gbmV3SUQ6IElEIG9mIHRoZSBjYW1lcmEgd2Ugd2FudCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICpcbiAgICAgKiBOQiA6IG5ld0lEIHNob3VsZCBiZSBpbiB0aGUgc3RhdGljIGFycmF5IFJBTkRPLmNhbWVyYUlEc1xuICAgICAqL1xuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuc2V0QWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKG5ld0lEKSB7XG4gICAgICAgIGlmIChSQU5ETy5DYW1lcmFJRHMuaW5kZXhPZihuZXdJRCkgPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSQU5ETy5DYW1lcmFDb250YWluZXIuc2V0QWN0aXZlQ2FtZXJhICgpIDogXCIgKyBuZXdJRCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaXMgbm90IGFuIGF2YWlsYWJsZSBjYW1lcmEncyBJRFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRJRCA9IHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5pZDtcblxuICAgICAgICAvLyBSZWNvcmQgaW5mb3JtYXRpb25zIG9mIHRoZSBvbGQgY2FtZXJhXG4gICAgICAgIHRoaXMuX3JlY29yZEluZm9CZWZvcmVTd2l0Y2gob2xkSUQpO1xuXG4gICAgICAgIC8vIEF0dGFjaCAmIGRldGFjaCBjb250cm9scyBvZiBjYW1lcmFzXG4gICAgICAgIGlmICh0aGlzLl9jb250cm9sc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYXNbb2xkSURdLmRldGFjaENvbnRyb2woKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbWVyYXNbbmV3SURdLmF0dGFjaENvbnRyb2wodGhpcy5fY2FudmFzKTtcbiAgICAgICAgdGhpcy5fY29udHJvbHNBdHRhY2hlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNhbWVyYVxuICAgICAgICB0aGlzLl9zY2VuZS5zZXRBY3RpdmVDYW1lcmFCeUlEIChuZXdJRCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0QnlEZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSW50ZXJmYWNlIGNoYW5nZXNcbiAgICAgICAgJChcIi5jb250cm9scy0tXCIgKyBvbGRJRCkuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgICAgICQoXCIuY2FtZXJhLS1cIiAgICsgb2xkSUQpLnJlbW92ZUNsYXNzKFwiY2FtZXJhLS1zZWxlY3RlZFwiKTtcbiAgICAgICAgJChcIi5jb250cm9scy0tXCIgKyBuZXdJRCkuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAkKFwiLmNhbWVyYS0tXCIgICArIG5ld0lEKS5hZGRDbGFzcyhcImNhbWVyYS0tc2VsZWN0ZWRcIik7XG4gICAgfTtcblxuICAgIFJBTkRPLkNhbWVyYUNvbnRhaW5lci5wcm90b3R5cGUuX3JlY29yZEluZm9CZWZvcmVTd2l0Y2ggPSBmdW5jdGlvbiAob2xkSUQpIHtcbiAgICAgICAgaWYgKG9sZElEID09IFwiZXhhbWluZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkJlZm9yZVN3aXRjaCAgPSB0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEJlZm9yZVN3aXRjaCAgICA9IHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS50YXJnZXQuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uQmVmb3JlU3dpdGNoICA9IG51bGw7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYgKG9sZElEID09IFwiYmlyZFwiIHx8IG9sZElEID09IFwiaGlrZXJcIikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25CZWZvcmVTd2l0Y2ggID0gdGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbkJlZm9yZVN3aXRjaCAgPSB0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEucm90YXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEJlZm9yZVN3aXRjaCAgICA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5zZXRBbmltYXRpb25QYXRoID0gZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvblBhdGggPSB2ZXJ0aWNlcztcbiAgICAgICAgdGhpcy5jYW1lcmFzLmhpa2VyLnNldFBhdGgodmVydGljZXMpO1xuICAgICAgICB0aGlzLmVuYWJsZUNhbWVyYSAoXCJoaWtlclwiKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fY2FtZXJhU3dpdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZEFycmF5ID0gUkFORE8uQ2FtZXJhSURzO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zd2l0Y2hFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgJChcIi5jYW1lcmFfc3dpdGNoZXJcIikuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaXQgaW4gaWRBcnJheSkge1xuICAgICAgICAgICAgLy8gVGhlIGhpa2VyIGNhbWVyYSBtdXN0IG5vdCBiZSBhY3RpdmUgdW50aWwgaGlzIHBhdGggaGFzIG5vdCBiZWVuIHNldFxuICAgICAgICAgICAgaWYgKGlkQXJyYXlbaXRdICE9IFwiaGlrZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FtZXJhKGlkQXJyYXlbaXRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xpY2sgZXZlbnRcbiAgICAgICAgICAgICQoXCIuY2FtZXJhLS1cIiArIGlkQXJyYXlbaXRdKS5jbGljayh7aWQgOiBpZEFycmF5W2l0XX0sIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgICAgICBpZigkKHRoaXMpLmhhc0NsYXNzKCdjYW1lcmEtLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVDYW1lcmEgKGUuZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5lbmFibGVDYW1lcmEgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgJChcIi5jYW1lcmEtLVwiICsgaWQgKS5yZW1vdmVDbGFzcyhcImNhbWVyYS0tZGlzYWJsZWRcIik7XG4gICAgICAgICQoXCIuY2FtZXJhLS1cIiArIGlkICkuYWRkQ2xhc3MoXCJjYW1lcmEtLWVuYWJsZWRcIik7XG4gICAgICAgICQoXCIuY2FtZXJhLS1cIiArIGlkICsgXCIgaW1nXCIpLmF0dHIoXCJzcmNcIiwgUkFORE8uU0VUVElOR1MuSU1BR0VTX0ZPTERFUiArIGlkICsgXCJfY2FtZXJhLnBuZ1wiKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fcmVzZXRCeURlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVDYW0gPSB0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmE7XG5cbiAgICAgICAgLy8gRXhhbWluZSBDYW1lcmFcbiAgICAgICAgaWYgKGFjdGl2ZUNhbS5pZCA9PSBcImV4YW1pbmVcIikge1xuICAgICAgICAgICAgYWN0aXZlQ2FtLnNldFBvc2l0aW9uKHRoaXMuaW5pdGlhbFBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICAgICAgYWN0aXZlQ2FtLnRhcmdldCA9IHRoaXMuaW5pdGlhbFRhcmdldC5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmlyZCBDYW1lcmFcbiAgICAgICAgZWxzZSBpZiAoYWN0aXZlQ2FtLmlkID09IFwiYmlyZFwiKSB7XG4gICAgICAgICAgICBhY3RpdmVDYW0ucG9zaXRpb24gPSB0aGlzLmluaXRpYWxQb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgYWN0aXZlQ2FtLnNldFRhcmdldCh0aGlzLmluaXRpYWxUYXJnZXQuY2xvbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWtlciBDYW1lcmFcbiAgICAgICAgZWxzZSBpZiAoYWN0aXZlQ2FtLmlkID09IFwiaGlrZXJcIiApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbkJlZm9yZVN3aXRjaCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUNhbS5wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uQmVmb3JlU3dpdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uQmVmb3JlU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2FtLnJvdGF0aW9uID0gdGhpcy5fcm90YXRpb25CZWZvcmVTd2l0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0QmVmb3JlU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ2FtLnNldFRhcmdldCh0aGlzLl90YXJnZXRCZWZvcmVTd2l0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWN0aXZlQ2FtLl9yZXNldCAoKTtcbiAgICB9O1xuXG4gICAgUkFORE8uQ2FtZXJhQ29udGFpbmVyLnByb3RvdHlwZS5fY29tcHV0ZUluaXRpYWxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21wdXRlci5jb21wdXRlSW5pdGlhbFBvc2l0aW9uVG9SZWYgKHRoaXMuaW5pdGlhbFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlci5jb21wdXRlSW5pdGlhbFRhcmdldFRvUmVmICh0aGlzLmluaXRpYWxUYXJnZXQpO1xuXG4gICAgICAgIHRoaXMuX2NvbXB1dGVyLmNvbXB1dGVMaW1pdHNUb1JlZiAodGhpcy5saW1pdHMpO1xuICAgIH07XG5cbiAgICBSQU5ETy5DYW1lcmFDb250YWluZXIucHJvdG90eXBlLl9pbml0SW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLmNhbWVyYXMpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuY2FtZXJhc1tpdF0uaWQ7XG4gICAgICAgICAgICAkKFwiLmNvbnRyb2xzLS1cIiArIGlkICsgXCIgLmNvbnRyb2xzLWRlc2NyaXB0aW9uXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoUkFORE8uU0VUVElOR1MuQ0FNRVJBX01FU1NBR0VTW2lkXSk7XG4gICAgICAgICAgICAkKFwiLmNhbWVyYS0tXCIgICArIGlkICsgXCIgLmNhbWVyYS1kZXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KFJBTkRPLlNFVFRJTkdTLkNBTUVSQV9NRVNTQUdFU1tpZF0pO1xuICAgICAgICB9XG4gICAgfTtcbn07IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLkV4YW1pbmVDYW1lcmEuanNcbiAqXG4gKiBFeGFtaW5lQ2FtZXJhIGNsYXNzIDpcbiAqICBJdCBpcyBhIGNhbWVyYSB3aGljaCBsb29rIGxpa2UgdGhlIEFyY1JvdGF0ZUNhbWVyYSBvZiBCYWJ5bG9uSlMuXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9CYWJ5bG9uSlMvQmFieWxvbi5qcy93aWtpLzA1LUNhbWVyYXMuXG4gKlxuICogIEJ1dCB3ZSBjYW4gYWxzbyB0cmFuc2xhdGUgaXQgb3ZlciB3b3JsZCBheGlzIFggYW5kIFouXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIHZhciBldmVudFByZWZpeCA9IEJBQllMT04uVG9vbHMuR2V0UG9pbnRlclByZWZpeCgpO1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYSA9IGZ1bmN0aW9uIChuYW1lLCBhbHBoYSwgYmV0YSwgcmFkaXVzLCB0YXJnZXQsIHNjZW5lKSB7XG4gICAgICAgIEJBQllMT04uQ2FtZXJhLmNhbGwoXG4gICAgICAgICAgICB0aGlzLCBuYW1lLCBSQU5ETy5FeGFtaW5lQ2FtZXJhLnNwaGVyaWNUb0NhcnRlc2lhbihcbiAgICAgICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgICAgICAgICBiZXRhLFxuICAgICAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgICksIHNjZW5lXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICB0aGlzLmJldGEgPSBiZXRhO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmtleXNVcCA9IFszOF07XG4gICAgICAgIHRoaXMua2V5c0Rvd24gPSBbNDBdO1xuICAgICAgICB0aGlzLmtleXNMZWZ0ID0gWzM3XTtcbiAgICAgICAgdGhpcy5rZXlzUmlnaHQgPSBbMzldO1xuXG4gICAgICAgIC8vIENvbGxpc2lvbnNcbiAgICAgICAgdGhpcy5fY29sbGlkZXIgPSBuZXcgQkFCWUxPTi5Db2xsaWRlcigpO1xuICAgICAgICB0aGlzLl9uZWVkTW92ZUZvckdyYXZpdHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jYW1lcmFSb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjIoMCwgMCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICB0aGlzLmVsbGlwc29pZCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoMC41LCAxLCAwLjUpO1xuXG4gICAgICAgIC8vIEludGVybmFsc1xuICAgICAgICB0aGlzLl92aWV3TWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX29sZFBvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fZGlmZlBvc2l0aW9uID0gQkFCWUxPTi5WZWN0b3IzLlplcm8oKTtcbiAgICAgICAgdGhpcy5fbmV3UG9zaXRpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlKTtcblxuICAgIC8vIE1lbWJlcnNcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5pbmVydGlhbEFscGhhT2Zmc2V0ID0gMDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5pbmVydGlhbEJldGFPZmZzZXQgPSAwO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5sb3dlckFscGhhTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLnVwcGVyQWxwaGFMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUubG93ZXJCZXRhTGltaXQgPSAwLjAxO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLnVwcGVyQmV0YUxpbWl0ID0gTWF0aC5QSTtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5sb3dlclJhZGl1c0xpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS51cHBlclJhZGl1c0xpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5sb3dlclhMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUudXBwZXJYTGltaXQgPSBudWxsO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLmxvd2VyWkxpbWl0ID0gbnVsbDtcbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS51cHBlclpMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuYW5ndWxhclNlbnNpYmlsaXR5ID0gMTAwMC4wO1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLndoZWVsUHJlY2lzaW9uID0gMy4wO1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2dldFRhcmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQucG9zaXRpb24gfHwgdGhpcy50YXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIENhY2hlXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2luaXRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jYWNoZS50YXJnZXQgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB0aGlzLl9jYWNoZS5hbHBoYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FjaGUuYmV0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FjaGUucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUgPSBmdW5jdGlvbiAoaWdub3JlUGFyZW50Q2xhc3MpIHtcbiAgICAgICAgaWYgKCFpZ25vcmVQYXJlbnRDbGFzcylcbiAgICAgICAgICAgIEJBQllMT04uQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9jYWNoZS50YXJnZXQuY29weUZyb20odGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgdGhpcy5fY2FjaGUuYmV0YSA9IHRoaXMuYmV0YTtcbiAgICAgICAgdGhpcy5fY2FjaGUucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgfTtcblxuICAgIC8vIFN5bmNocm9uaXplZFxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXguY2FsbCh0aGlzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUudGFyZ2V0LmVxdWFscyh0aGlzLl9nZXRUYXJnZXRQb3NpdGlvbigpKVxuICAgICAgICAgICAgJiYgdGhpcy5fY2FjaGUuYWxwaGEgPT09IHRoaXMuYWxwaGFcbiAgICAgICAgICAgICYmIHRoaXMuX2NhY2hlLmJldGEgPT09IHRoaXMuYmV0YVxuICAgICAgICAgICAgJiYgdGhpcy5fY2FjaGUucmFkaXVzID09PSB0aGlzLnJhZGl1cztcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVlZCAqICgoQkFCWUxPTi5Ub29scy5HZXREZWx0YVRpbWUoKSAvIChCQUJZTE9OLlRvb2xzLkdldEZwcygpICogMTAuMCkpKTtcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuYXR0YWNoQ29udHJvbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBwb2ludGVySWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGVuZ2luZSA9IHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vblBvaW50ZXJEb3duID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXZ0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb2ludGVySWQgPSBldnQucG9pbnRlcklkO1xuXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2dC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlcklkICE9PSBldnQucG9pbnRlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGV2dC5jbGllbnRYIC0gcHJldmlvdXNQb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gZXZ0LmNsaWVudFkgLSBwcmV2aW91c1Bvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsQWxwaGFPZmZzZXQgLT0gb2Zmc2V0WCAvIHRoYXQuYW5ndWxhclNlbnNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxCZXRhT2Zmc2V0IC09IG9mZnNldFkgLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmdpbmUuaXNQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBldnQubW92ZW1lbnRYIHx8IGV2dC5tb3pNb3ZlbWVudFggfHwgZXZ0LndlYmtpdE1vdmVtZW50WCB8fCBldnQubXNNb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IGV2dC5tb3ZlbWVudFkgfHwgZXZ0Lm1vek1vdmVtZW50WSB8fCBldnQud2Via2l0TW92ZW1lbnRZIHx8IGV2dC5tc01vdmVtZW50WSB8fCAwO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmVydGlhbEFscGhhT2Zmc2V0IC09IG9mZnNldFggLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcbiAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsQmV0YU9mZnNldCAtPSBvZmZzZXRZIC8gdGhhdC5hbmd1bGFyU2Vuc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fd2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC53aGVlbERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvICh0aGF0LndoZWVsUHJlY2lzaW9uICogNDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gLWV2ZW50LmRldGFpbCAvIHRoYXQud2hlZWxQcmVjaXNpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhKVxuICAgICAgICAgICAgICAgICAgICB0aGF0LmluZXJ0aWFsUmFkaXVzT2Zmc2V0ICs9IGRlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5rZXlzVXAuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0Rvd24uaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c0xlZnQuaW5kZXhPZihldnQua2V5Q29kZSkgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoYXQua2V5c1JpZ2h0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0Ll9rZXlzLmluZGV4T2YoZXZ0LmtleUNvZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2tleXMucHVzaChldnQua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uS2V5VXAgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQua2V5c1VwLmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNEb3duLmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNMZWZ0LmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmtleXNSaWdodC5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhhdC5fa2V5cy5pbmRleE9mKGV2dC5rZXlDb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fa2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbkxvc3RGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgcG9pbnRlcklkID0gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93Lk1TR2VzdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoYXQuX01TR2VzdHVyZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fTVNHZXN0dXJlSGFuZGxlciA9IG5ldyBNU0dlc3R1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fTVNHZXN0dXJlSGFuZGxlci50YXJnZXQgPSBjYW52YXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5fTVNHZXN0dXJlSGFuZGxlci5hZGRQb2ludGVyKGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uR2VzdHVyZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yYWRpdXMgKj0gZS5zY2FsZTtcblxuXG4gICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxBbHBoYU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmVydGlhbEJldGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5lcnRpYWxSYWRpdXNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHRoYXQuY2FtZXJhRGlyZWN0aW9uID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb2ludGVySWQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwiZG93blwiLCB0aGlzLl9vblBvaW50ZXJEb3duLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwidXBcIiwgdGhpcy5fb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJvdXRcIiwgdGhpcy5fb25Qb2ludGVyVXAsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50UHJlZml4ICsgXCJtb3ZlXCIsIHRoaXMuX29uUG9pbnRlck1vdmUsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgdGhpcy5fb25HZXN0dXJlU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiTVNHZXN0dXJlQ2hhbmdlXCIsIHRoaXMuX29uR2VzdHVyZSwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl93aGVlbCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcy5fd2hlZWwsIGZhbHNlKTtcblxuICAgICAgICBCQUJZTE9OLlRvb2xzLlJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5ZG93blwiLCBoYW5kbGVyOiB0aGlzLl9vbktleURvd24gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXl1cFwiLCBoYW5kbGVyOiB0aGlzLl9vbktleVVwIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYmx1clwiLCBoYW5kbGVyOiB0aGlzLl9vbkxvc3RGb2N1cyB9XG4gICAgICAgIF0pO1xuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5kZXRhY2hDb250cm9sID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkRWxlbWVudCAhPSBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRQcmVmaXggKyBcImRvd25cIiwgdGhpcy5fb25Qb2ludGVyRG93bik7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwidXBcIiwgdGhpcy5fb25Qb2ludGVyVXApO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRQcmVmaXggKyBcIm91dFwiLCB0aGlzLl9vblBvaW50ZXJVcCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFByZWZpeCArIFwibW92ZVwiLCB0aGlzLl9vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCB0aGlzLl9vbkdlc3R1cmVTdGFydCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TR2VzdHVyZUNoYW5nZVwiLCB0aGlzLl9vbkdlc3R1cmUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl93aGVlbCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCB0aGlzLl93aGVlbCk7XG5cbiAgICAgICAgQkFCWUxPTi5Ub29scy5VbnJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5ZG93blwiLCBoYW5kbGVyOiB0aGlzLl9vbktleURvd24gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXl1cFwiLCBoYW5kbGVyOiB0aGlzLl9vbktleVVwIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYmx1clwiLCBoYW5kbGVyOiB0aGlzLl9vbkxvc3RGb2N1cyB9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuX01TR2VzdHVyZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9hdHRhY2hlZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXNldCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5fY29sbGlkZVdpdGhXb3JsZCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICB2YXIgZ2xvYmFsUG9zaXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBnbG9iYWxQb3NpdGlvbiA9IEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0aGlzLnBvc2l0aW9uLCB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsb2JhbFBvc2l0aW9uLnN1YnRyYWN0RnJvbUZsb2F0c1RvUmVmKDAsIHRoaXMuZWxsaXBzb2lkLnksIDAsIHRoaXMuX29sZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fY29sbGlkZXIucmFkaXVzID0gdGhpcy5lbGxpcHNvaWQ7XG5cbiAgICAgICAgdGhpcy5nZXRTY2VuZSgpLl9nZXROZXdQb3NpdGlvbih0aGlzLl9vbGRQb3NpdGlvbiwgdmVsb2NpdHksIHRoaXMuX2NvbGxpZGVyLCAzLCB0aGlzLl9uZXdQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX25ld1Bvc2l0aW9uLnN1YnRyYWN0VG9SZWYodGhpcy5fb2xkUG9zaXRpb24sIHRoaXMuX2RpZmZQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RpZmZQb3NpdGlvbi5sZW5ndGgoKSA+IEJBQllMT04uRW5naW5lLkNvbGxpc2lvbnNFcHNpbG9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5fZGlmZlBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbGxpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGlkZSh0aGlzLl9jb2xsaWRlci5jb2xsaWRlZE1lc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLl9jaGVja0lucHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24gPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZXMgd2l0aCB0aGUgS2V5Ym9hcmRcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2tleXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IHRoaXMuX2tleXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNwZWVkID0gdGhpcy5fY29tcHV0ZUxvY2FsQ2FtZXJhU3BlZWQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMua2V5c0xlZnQuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cygtc3BlZWQsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmtleXNVcC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKHNwZWVkLCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5rZXlzUmlnaHQuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cyhzcGVlZCwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMua2V5c0Rvd24uaW5kZXhPZihrZXlDb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cygtc3BlZWQsIDAsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdldFZpZXdNYXRyaXgoKS5pbnZlcnRUb1JlZih0aGlzLl9jYW1lcmFUcmFuc2Zvcm1NYXRyaXgpO1xuXG4gICAgICAgICAgICBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYoXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4LFxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzVXAuaW5kZXhPZihrZXlDb2RlKSAgICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgIHRoaXMua2V5c0Rvd24uaW5kZXhPZihrZXlDb2RlKSAgIT09IC0xICkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLmFkZEluUGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIEJBQllMT04uVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIEJBQllMT04uTWF0cml4LlJvdGF0aW9uWSgtTWF0aC5QSS8yKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFEaXJlY3Rpb24uYWRkSW5QbGFjZSh0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJbnB1dHMoKTtcblxuICAgICAgICB2YXIgbmVlZFRvTW92ZVRhcmdldCA9IChcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuY2FtZXJhRGlyZWN0aW9uLngpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueSkgPiAwIHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmNhbWVyYURpcmVjdGlvbi56KSA+IDBcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbmVlZFRvUm90YXRlT3Jab29tID0gKFxuICAgICAgICAgICAgdGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0ICAhPSAwIHx8XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCAgICE9IDAgfHxcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQgIT0gMFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBuZWVkQ29sbGlzaW9ucyA9IHRoaXMuY2hlY2tDb2xsaXNpb25zICYmIHRoaXMuX3NjZW5lLmNvbGxpc2lvbnNFbmFibGVkO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0YXJnZXRcbiAgICAgICAgaWYgKG5lZWRUb01vdmVUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZEluUGxhY2UodGhpcy5jYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIEFscGhhIEJldGEgUmFkaXVzXG4gICAgICAgIGlmIChuZWVkVG9Sb3RhdGVPclpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgICs9IHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuYmV0YSAgICs9IHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgLT0gdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpbWl0c1xuICAgICAgICBpZiAodGhpcy5sb3dlckFscGhhTGltaXQgJiYgdGhpcy5hbHBoYSA8IHRoaXMubG93ZXJBbHBoYUxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmFscGhhID0gdGhpcy5sb3dlckFscGhhTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVwcGVyQWxwaGFMaW1pdCAmJiB0aGlzLmFscGhhID4gdGhpcy51cHBlckFscGhhTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLnVwcGVyQWxwaGFMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG93ZXJCZXRhTGltaXQgJiYgdGhpcy5iZXRhIDwgdGhpcy5sb3dlckJldGFMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5iZXRhID0gdGhpcy5sb3dlckJldGFMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cHBlckJldGFMaW1pdCAmJiB0aGlzLmJldGEgPiB0aGlzLnVwcGVyQmV0YUxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLmJldGEgPSB0aGlzLnVwcGVyQmV0YUxpbWl0O1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhbEJldGFPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvd2VyUmFkaXVzTGltaXQgJiYgdGhpcy5yYWRpdXMgPCB0aGlzLmxvd2VyUmFkaXVzTGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5sb3dlclJhZGl1c0xpbWl0O1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXBwZXJSYWRpdXNMaW1pdCAmJiB0aGlzLnJhZGl1cyA+IHRoaXMudXBwZXJSYWRpdXNMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSB0aGlzLnVwcGVyUmFkaXVzTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb3dlclhMaW1pdCAmJiB0aGlzLnRhcmdldC54IDwgdGhpcy5sb3dlclhMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQueCA9IHRoaXMubG93ZXJYTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cHBlclhMaW1pdCAmJiB0aGlzLnRhcmdldC54ID4gdGhpcy51cHBlclhMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQueCA9IHRoaXMudXBwZXJYTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb3dlclpMaW1pdCAmJiB0aGlzLnRhcmdldC56IDwgdGhpcy5sb3dlclpMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQueiA9IHRoaXMubG93ZXJaTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi56ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cHBlclpMaW1pdCAmJiB0aGlzLnRhcmdldC56ID4gdGhpcy51cHBlclpMaW1pdCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQueiA9IHRoaXMudXBwZXJaTGltaXQ7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi56ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmVzIGFuZCBDb2xsaXNpb25zXG4gICAgICAgIGlmIChuZWVkVG9Sb3RhdGVPclpvb20gJiYgbmVlZFRvTW92ZVRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG5lZWRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZVdpdGhXb3JsZChcbiAgICAgICAgICAgICAgICAgICAgUkFORE8uRXhhbWluZUNhbWVyYS5zcGhlcmljVG9DYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHRoaXMuY2FtZXJhRGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEuc3BoZXJpY1RvQ2FydGVzaWFuKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmV0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuc3VidHJhY3QodGhpcy5wb3NpdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmFkZCh0aGlzLmNhbWVyYURpcmVjdGlvbilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24gKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5lZWRUb1JvdGF0ZU9yWm9vbSkge1xuICAgICAgICAgICAgaWYgKG5lZWRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZVdpdGhXb3JsZChcbiAgICAgICAgICAgICAgICAgICAgUkFORE8uRXhhbWluZUNhbWVyYS5zcGhlcmljVG9DYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZShcbiAgICAgICAgICAgICAgICAgICAgUkFORE8uRXhhbWluZUNhbWVyYS5zcGhlcmljVG9DYXJ0ZXNpYW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiAodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmVlZFRvTW92ZVRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG5lZWRDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZVdpdGhXb3JsZCh0aGlzLmNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLmNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbiAodGhpcy5wb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmVydGlhXG4gICAgICAgIGlmIChuZWVkVG9Nb3ZlVGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueCkgPCBCQUJZTE9OLkVuZ2luZS5FcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnggPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueSkgPCBCQUJZTE9OLkVuZ2luZS5FcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueikgPCBCQUJZTE9OLkVuZ2luZS5FcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uLnogPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmNhbWVyYURpcmVjdGlvbi5zY2FsZUluUGxhY2UodGhpcy5pbmVydGlhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkVG9Sb3RhdGVPclpvb20pIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQpIDwgQkFCWUxPTi5FbmdpbmUuRXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5pbmVydGlhbEJldGFPZmZzZXQpIDwgQkFCWUxPTi5FbmdpbmUuRXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0KSA8IEJBQllMT04uRW5naW5lLkVwc2lsb24pXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldCAgICAqPSB0aGlzLmluZXJ0aWE7XG4gICAgICAgICAgICB0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCAgICAgKj0gdGhpcy5pbmVydGlhO1xuICAgICAgICAgICAgdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCAgICo9IHRoaXMuaW5lcnRpYTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBSQU5ETy5FeGFtaW5lQ2FtZXJhLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHZhciByYWRpdXN2MyA9IHBvc2l0aW9uLnN1YnRyYWN0KHRoaXMuX2dldFRhcmdldFBvc2l0aW9uKCkpO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1c3YzLmxlbmd0aCgpO1xuXG4gICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoLmFjb3MocmFkaXVzdjMueCAvIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KHJhZGl1c3YzLngsIDIpICtcbiAgICAgICAgICAgIE1hdGgucG93KHJhZGl1c3YzLnosIDIpXG4gICAgICAgICkpO1xuICAgICAgICBpZiAocmFkaXVzdjMueiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAyICogTWF0aC5QSSAtIHRoaXMuYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZXRhID0gTWF0aC5hY29zKHJhZGl1c3YzLnkgLyB0aGlzLnJhZGl1cyk7XG4gICAgfTtcblxuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEucHJvdG90eXBlLl9nZXRWaWV3TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCQUJZTE9OLk1hdHJpeC5Mb29rQXRMSFRvUmVmKFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LFxuICAgICAgICAgICAgdGhpcy51cFZlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNYXRyaXhcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmlld01hdHJpeDtcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5aT09NX09OX0ZBQ1RPUiA9IDE7XG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuem9vbU9uID0gZnVuY3Rpb24gKG1lc2hlcykge1xuICAgICAgICBtZXNoZXMgPSBtZXNoZXMgfHwgdGhpcy5fc2NlbmUubWVzaGVzO1xuXG4gICAgICAgIHZhciBtaW5NYXhWZWN0b3IgPSBCQUJZTE9OLk1lc2guTWluTWF4KG1lc2hlcyk7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZShtaW5NYXhWZWN0b3IubWluLCBtaW5NYXhWZWN0b3IubWF4KTtcblxuICAgICAgICB0aGlzLnJhZGl1cyA9IGRpc3RhbmNlICogUkFORE8uRXhhbWluZUNhbWVyYS5aT09NX09OX0ZBQ1RPUjtcblxuICAgICAgICB0aGlzLmZvY3VzT24oe21pbjogbWluTWF4VmVjdG9yLm1pbiwgbWF4OiBtaW5NYXhWZWN0b3IubWF4LCBkaXN0YW5jZTogZGlzdGFuY2V9KTtcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5wcm90b3R5cGUuZm9jdXNPbiA9IGZ1bmN0aW9uIChtZXNoZXNPck1pbk1heFZlY3RvckFuZERpc3RhbmNlKSB7XG4gICAgICAgIHZhciBtZXNoZXNPck1pbk1heFZlY3RvcjtcbiAgICAgICAgdmFyIGRpc3RhbmNlO1xuXG4gICAgICAgIGlmIChtZXNoZXNPck1pbk1heFZlY3RvckFuZERpc3RhbmNlLm1pbiA9PT0gdW5kZWZpbmVkKSB7IC8vIG1lc2hlc1xuICAgICAgICAgICAgbWVzaGVzT3JNaW5NYXhWZWN0b3IgPSBtZXNoZXNPck1pbk1heFZlY3RvckFuZERpc3RhbmNlIHx8IHRoaXMuX3NjZW5lLm1lc2hlcztcbiAgICAgICAgICAgIG1lc2hlc09yTWluTWF4VmVjdG9yID0gQkFCWUxPTi5NZXNoLk1pbk1heChtZXNoZXNPck1pbk1heFZlY3Rvcik7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZShtZXNoZXNPck1pbk1heFZlY3Rvci5taW4sIG1lc2hlc09yTWluTWF4VmVjdG9yLm1heCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vbWluTWF4VmVjdG9yIGFuZCBkaXN0YW5jZVxuICAgICAgICAgICAgbWVzaGVzT3JNaW5NYXhWZWN0b3IgPSBtZXNoZXNPck1pbk1heFZlY3RvckFuZERpc3RhbmNlO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBtZXNoZXNPck1pbk1heFZlY3RvckFuZERpc3RhbmNlLmRpc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YXJnZXQgPSBCQUJZTE9OLk1lc2guQ2VudGVyKG1lc2hlc09yTWluTWF4VmVjdG9yKTtcblxuICAgICAgICB0aGlzLm1heFogPSBkaXN0YW5jZSAqIDI7XG4gICAgfTtcblxuICAgIC8vIFN0YXRpY1xuICAgIFJBTkRPLkV4YW1pbmVDYW1lcmEuc3BoZXJpY1RvQ2FydGVzaWFuID0gZnVuY3Rpb24gKGFscGhhLCBiZXRhLCByYWRpdXMsIGNlbnRlcikge1xuICAgICAgICB2YXIgY29zYSA9IE1hdGguY29zKGFscGhhKTtcbiAgICAgICAgdmFyIHNpbmEgPSBNYXRoLnNpbihhbHBoYSk7XG4gICAgICAgIHZhciBjb3NiID0gTWF0aC5jb3MoYmV0YSk7XG4gICAgICAgIHZhciBzaW5iID0gTWF0aC5zaW4oYmV0YSk7XG5cbiAgICAgICAgY2VudGVyID0gY2VudGVyIHx8IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuYWRkKG5ldyBCQUJZTE9OLlZlY3RvcjMoXG4gICAgICAgICAgICByYWRpdXMgKiBjb3NhICogc2luYixcbiAgICAgICAgICAgIHJhZGl1cyAqIGNvc2IsXG4gICAgICAgICAgICByYWRpdXMgKiBzaW5hICogc2luYlxuICAgICAgICApKTtcbiAgICB9O1xuXG4gICAgUkFORE8uRXhhbWluZUNhbWVyYS5jYXJ0ZXNpYW5Ub1NwaGVyaWMgPSBmdW5jdGlvbiAocG9zaXRpb24sIGNlbnRlcikge1xuICAgICAgICB2YXIgcmFkaXVzdjMgPSBwb3NpdGlvbi5zdWJ0cmFjdChjZW50ZXIpO1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzdjMubGVuZ3RoKCk7XG5cbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5hY29zKHJhZGl1c3YzLnggLyBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyhyYWRpdXN2My54LCAyKSArXG4gICAgICAgICAgICBNYXRoLnBvdyhyYWRpdXN2My56LCAyKVxuICAgICAgICApKTtcbiAgICAgICAgaWYgKHJhZGl1c3YzLnogPCAwKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAyKk1hdGguUEkgLSB0aGlzLmFscGhhO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZXRhID0gTWF0aC5hY29zKHJhZGl1c3YzLnkgLyB0aGlzLnJhZGl1cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnYWxwaGEnOiBhbHBoYSxcbiAgICAgICAgICAgICdiZXRhJzogYmV0YSxcbiAgICAgICAgICAgICdyYWRpdXMnOiByYWRpdXNcbiAgICAgICAgfTtcbiAgICB9O1xufTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uSGlrZXJDYW1lcmEuanNcbiAqXG4gKiBIaWtlckNhbWVyYSBjbGFzcyA6XG4gKiAgSXQgaXMgYSBjYW1lcmEgd2hpY2ggbG9vayBsaWtlIHRoZSBGcmVlQ2FtZXJhIG9mIEJhYnlsb25KUy5cbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL0JhYnlsb25KUy9CYWJ5bG9uLmpzL3dpa2kvMDUtQ2FtZXJhcy5cbiAqXG4gKiAgVGhlIG1ham9yIGRpZmZlcmVuY2VzIGlzIHRoYW4gYWxsIG1vdmVzIGhhdmUgYmVlbiByZXBsYWNlZCBieSBzb21lXG4gKiAgYW5pbWF0aW9uIGNvbnRyb2xzLiBJbiBlZmZlY3QgdGhpcyBjYW1lcmEgd2FzIGRvbmUgdG8gZm9sbG93IGEgcGF0aC5cbiAqXG4gKiAgQWZ0ZXIgaW5zdGFudGlhdGUgdGhlIGNhbWVyYSwgc2V0IHRoZSBjb21tYW5kcyBhbmQgc2V0IHRoZSBwYXRoIHdpdGhcbiAqICBzZXRQYXRoKCkgZnVuY3Rpb24sIHdlIGNhbiBwbGF5LCBwYXVzZSwgc3RvcCwgcmV3aW5kIGFuZCBtb3ZlIGZvcndhcmQgdGhlXG4gKiAgY2FtZXJhIGFsb25nIHRoaXMgcGF0aCBhcyB3ZSB3YW50LlxuICpcbiAqXG4gKiAgQmV3YXJlICEgdGhpcyBjYW1lcmEgd2lsbCBuZWVkIHRvIGhhdmUgaW1wb3J0ZWQgdGhlc2UgbGlicmFyaWVzIDpcblxuPHNjcmlwdCBzcmM9XCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9nc2FwL2xhdGVzdC9lYXNpbmcvRWFzZVBhY2subWluLmpzXCI+PC9zY3JpcHQ+XG48c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2dzYXAvbGF0ZXN0L1R3ZWVuTGl0ZS5taW4uanNcIj48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZ3NhcC9sYXRlc3QvVGltZWxpbmVMaXRlLm1pbi5qc1wiPjwvc2NyaXB0PlxuPHNjcmlwdCBzcmM9XCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9nc2FwL2xhdGVzdC9wbHVnaW5zL0JlemllclBsdWdpbi5taW4uanNcIj48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvZ3NhcC9sYXRlc3QvcGx1Z2lucy9EaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luLm1pbi5qc1wiPjwvc2NyaXB0PlxuXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhID0gZnVuY3Rpb24gKG5hbWUsIHBvc2l0aW9uLCBzY2VuZSkge1xuICAgICAgICBCQUJZTE9OLkNhbWVyYS5jYWxsKHRoaXMsIG5hbWUsIHBvc2l0aW9uLCBzY2VuZSk7XG5cbiAgICAgICAgdGhpcy5jYW1lcmFSb3RhdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjIoMCwgMCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDAsIDApO1xuXG4gICAgICAgIHRoaXMua2V5c1BsYXlQYXVzZSA9IFszMl07XG4gICAgICAgIHRoaXMua2V5c1N0b3AgID0gWzEzXTtcbiAgICAgICAgdGhpcy5rZXlzUmV3aW5kID0gWzQwXTtcbiAgICAgICAgdGhpcy5rZXlzRm9yd2FyZCA9IFszOF07XG5cbiAgICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl92aWV3TWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9jYW1NYXRyaXggPSBCQUJZTE9OLk1hdHJpeC5aZXJvKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VQb2ludCA9IEJBQllMT04uVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQgPSBCQUJZTE9OLlZlY3RvcjMuWmVybygpO1xuICAgICAgICB0aGlzLl9sb29rQXRUZW1wID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuICAgICAgICB0aGlzLl90ZW1wTWF0cml4ID0gQkFCWUxPTi5NYXRyaXguWmVybygpO1xuXG4gICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICB0aGlzLl90aW1lbGluZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGF0aCA9IFtdO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29sZFN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGVuZ2h0T2ZCZXppZXIgPSAwO1xuICAgICAgICB0aGlzLl9wb3NpdGlvblR3ZWVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcm90YXRpb25Ud2VlbiA9IG51bGw7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQkFCWUxPTi5DYW1lcmEucHJvdG90eXBlKTtcblxuICAgIC8vIE1lbWJlcnNcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUucmV0dXJuU3BlZWQgPSAyMDAwO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5mb2xsb3dTcGVlZCA9IDIwO1xuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5jaGVja0NvbGxpc2lvbnMgPSBmYWxzZTtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuYXBwbHlHcmF2aXR5ID0gZmFsc2U7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLm5vUm90YXRpb25Db25zdHJhaW50ID0gZmFsc2U7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmFuZ3VsYXJTZW5zaWJpbGl0eSA9IDIwMDAuMDtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUubG9ja2VkVGFyZ2V0ID0gbnVsbDtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUub25Db2xsaWRlID0gbnVsbDtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUud2hlZWxQcmVjaXNpb24gPSAwLjM7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmluZXJ0aWFsUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUubG93ZXJSYWRpdXNMaW1pdCA9IG51bGw7XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLnVwcGVyUmFkaXVzTGltaXQgPSBudWxsO1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrZWRUYXJnZXQucG9zaXRpb24gfHwgdGhpcy5sb2NrZWRUYXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIENhY2hlXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLl9pbml0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJBQllMT04uQ2FtZXJhLnByb3RvdHlwZS5faW5pdENhY2hlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0ID0gbmV3IEJBQllMT04uVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgdGhpcy5fY2FjaGUucm90YXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuX3VwZGF0ZUNhY2hlID0gZnVuY3Rpb24gKGlnbm9yZVBhcmVudENsYXNzKSB7XG4gICAgICAgIGlmICghaWdub3JlUGFyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIEJBQllMT04uQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NrZWRUYXJnZXRQb3NpdGlvbiA9IHRoaXMuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGlmICghbG9ja2VkVGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldCA9IGxvY2tlZFRhcmdldFBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQuY29weUZyb20obG9ja2VkVGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGUucm90YXRpb24uY29weUZyb20odGhpcy5yb3RhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIFN5bmNocm9uaXplZFxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUJBQllMT04uQ2FtZXJhLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4LmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NrZWRUYXJnZXRQb3NpdGlvbiA9IHRoaXMuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQgPyB0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQuZXF1YWxzKGxvY2tlZFRhcmdldFBvc2l0aW9uKSA6ICFsb2NrZWRUYXJnZXRQb3NpdGlvbilcbiAgICAgICAgICAgICYmIHRoaXMuX2NhY2hlLnJvdGF0aW9uLmVxdWFscyh0aGlzLnJvdGF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gVGFyZ2V0XG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy51cFZlY3Rvci5ub3JtYWxpemUoKTtcblxuICAgICAgICBCQUJZTE9OLk1hdHJpeC5Mb29rQXRMSFRvUmVmKHRoaXMucG9zaXRpb24sIHRhcmdldCwgdGhpcy51cFZlY3RvciwgdGhpcy5fY2FtTWF0cml4KTtcbiAgICAgICAgdGhpcy5fY2FtTWF0cml4LmludmVydCgpO1xuXG4gICAgICAgIHRoaXMucm90YXRpb24ueCA9IE1hdGguYXRhbih0aGlzLl9jYW1NYXRyaXgubVs2XSAvIHRoaXMuX2NhbU1hdHJpeC5tWzEwXSk7XG5cbiAgICAgICAgdmFyIHZEaXIgPSB0YXJnZXQuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHZEaXIueCA+PSAwLjApIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueSA9ICgtTWF0aC5hdGFuKHZEaXIueiAvIHZEaXIueCkgKyBNYXRoLlBJIC8gMi4wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueSA9ICgtTWF0aC5hdGFuKHZEaXIueiAvIHZEaXIueCkgLSBNYXRoLlBJIC8gMi4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucm90YXRpb24ueiA9IC1NYXRoLmFjb3MoQkFCWUxPTi5WZWN0b3IzLkRvdChuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDEuMCwgMCksIHRoaXMudXBWZWN0b3IpKTtcblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5yb3RhdGlvbi54KSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hTih0aGlzLnJvdGF0aW9uLnkpKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMucm90YXRpb24ueikpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24ueiA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIENvbnRyb2xzXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmF0dGFjaENvbnRyb2wgPSBmdW5jdGlvbiAoZWxlbWVudCwgbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbjtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgZW5naW5lID0gdGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uTW91c2VEb3duID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbm9QcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlT3V0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoYXQuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vUHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1Bvc2l0aW9uICYmICFlbmdpbmUuaXNQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVuZ2luZS5pc1BvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBldnQuY2xpZW50WCAtIHByZXZpb3VzUG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IGV2dC5jbGllbnRZIC0gcHJldmlvdXNQb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBldnQubW92ZW1lbnRYIHx8IGV2dC5tb3pNb3ZlbWVudFggfHwgZXZ0LndlYmtpdE1vdmVtZW50WCB8fCBldnQubXNNb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IGV2dC5tb3ZlbWVudFkgfHwgZXZ0Lm1vek1vdmVtZW50WSB8fCBldnQud2Via2l0TW92ZW1lbnRZIHx8IGV2dC5tc01vdmVtZW50WSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuY2FtZXJhUm90YXRpb24ueSArPSBvZmZzZXRYIC8gdGhhdC5hbmd1bGFyU2Vuc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgdGhhdC5jYW1lcmFSb3RhdGlvbi54ICs9IG9mZnNldFkgLyB0aGF0LmFuZ3VsYXJTZW5zaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB5OiBldnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFub1ByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGF0Ll9zdGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fcGF0aC5sZW5ndGggJiYgIXRoYXQuX2lzTW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZ0LmtleUNvZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQua2V5c1Jld2luZC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFwicGF1c2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJyZXdpbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGF0LmtleXNGb3J3YXJkLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJwYXVzZVwiIHx8IHN0YXRlID09IFwic3RvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcImZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbGRTdGF0ZSAgPSBvbGRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3RhdGUgICAgID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25LZXlVcCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGF0Ll9zdGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fcGF0aC5sZW5ndGggJiYgIXRoYXQuX2lzTW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZ0LmtleUNvZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQua2V5c1BsYXlQYXVzZS5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFwic3RvcFwiIHx8IHN0YXRlID09IFwicGF1c2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJwbGF5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwicGxheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcInBhdXNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhhdC5rZXlzU3RvcC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFwicGxheVwiIHx8IHN0YXRlID09IFwicGF1c2VcIiB8fCAhc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwic3RvcFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoYXQua2V5c1Jld2luZC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFwicmV3aW5kXCIgJiYgdGhhdC5fdGltZWxpbmUuX3RpbWUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gXCJzdG9wXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PSBcInJld2luZFwiICYmIHRoYXQuX3RpbWVsaW5lLl90aW1lICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGF1c2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGF0LmtleXNGb3J3YXJkLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGF1c2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9vbGRTdGF0ZSAgPSBvbGRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3RhdGUgICAgID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fb25Mb3N0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoYXQuY2FtZXJhUm90YXRpb24gPSBuZXcgQkFCWUxPTi5WZWN0b3IyKDAsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX3BhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubG9hZFBhdGhPblRpbWVsaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQuX29sZFN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zdGF0ZSA9IFwic3RvcFwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX3Bvc2l0aW9uX3RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fcG9zaXRpb25fdHJhbnNpdGlvbi5raWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9yb3RhdGlvbl90cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3JvdGF0aW9uX3RyYW5zaXRpb24ua2lsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5fb25Nb3VzZU91dCwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcblxuICAgICAgICBCQUJZTE9OLlRvb2xzLlJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbXG4gICAgICAgICAgICB7IG5hbWU6IFwia2V5ZG93blwiLCBoYW5kbGVyOiB0aGlzLl9vbktleURvd24gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXl1cFwiLCBoYW5kbGVyOiB0aGlzLl9vbktleVVwIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYmx1clwiLCBoYW5kbGVyOiB0aGlzLl9vbkxvc3RGb2N1cyB9XG4gICAgICAgIF0pO1xuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuZGV0YWNoQ29udHJvbCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZEVsZW1lbnQgIT0gZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCB0aGlzLl9vbk1vdXNlT3V0KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKTtcblxuICAgICAgICBCQUJZTE9OLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJrZXlkb3duXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5RG93biB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleXVwXCIsIGhhbmRsZXI6IHRoaXMuX29uS2V5VXAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJibHVyXCIsIGhhbmRsZXI6IHRoaXMuX29uTG9zdEZvY3VzIH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBuZWVkVG9Sb3RhdGUgPSAoXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmNhbWVyYVJvdGF0aW9uLngpID4gMCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5jYW1lcmFSb3RhdGlvbi55KSA+IDBcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHN0YXRlSGF2ZUNoYW5nZWQgPSAodGhpcy5fb2xkU3RhdGUgIT0gdGhpcy5fc3RhdGUpO1xuXG4gICAgICAgIC8vIFJvdGF0ZVxuICAgICAgICBpZiAobmVlZFRvUm90YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uLnggKz0gdGhpcy5jYW1lcmFSb3RhdGlvbi54O1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbi55ICs9IHRoaXMuY2FtZXJhUm90YXRpb24ueTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vUm90YXRpb25Db25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gKE1hdGguUEkgLyAyKSAqIDAuOTU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3RhdGlvbi54ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvdGF0aW9uLnggPCAtbGltaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24ueCA9IC1saW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5lcnRpYVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueCkgPCBCQUJZTE9OLkVuZ2luZS5lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhUm90YXRpb24ueCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmNhbWVyYVJvdGF0aW9uLnkpIDwgQkFCWUxPTi5FbmdpbmUuZXBzaWxvbilcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYVJvdGF0aW9uLnkgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLmNhbWVyYVJvdGF0aW9uLnNjYWxlSW5QbGFjZSh0aGlzLmluZXJ0aWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgaWYgKHN0YXRlSGF2ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX29sZFN0YXRlICsgXCIgdG8gXCIgKyB0aGlzLl9zdGF0ZSk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgICAgICAgICAgc3dpdGNoIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdG9wXCIgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG8odGhpcy5fcGF0aFswXSwgdGhpcy5fcGF0aFsxXSwgdGhpcy5yZXR1cm5TcGVlZCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RpbWVsaW5lLnBhdXNlKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5faXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBsYXlcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnBsYXkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicGF1c2VcIiA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJld2luZFwiIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmb3J3YXJkXCIgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZS5wbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX29sZFN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLl9nZXRWaWV3TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBCQUJZTE9OLlZlY3RvcjMuRnJvbUZsb2F0c1RvUmVmKDAsIDAsIDEsIHRoaXMuX3JlZmVyZW5jZVBvaW50KTtcblxuICAgICAgICBpZiAoIXRoaXMubG9ja2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlXG4gICAgICAgICAgICBpZiAodGhpcy51cFZlY3Rvci54ICE9IDAgfHwgdGhpcy51cFZlY3Rvci55ICE9IDEuMCB8fCB0aGlzLnVwVmVjdG9yLnogIT0gMCkge1xuICAgICAgICAgICAgICAgIEJBQllMT04uTWF0cml4Lkxvb2tBdExIVG9SZWYoQkFCWUxPTi5WZWN0b3IzLlplcm8oKSwgdGhpcy5fcmVmZXJlbmNlUG9pbnQsIHRoaXMudXBWZWN0b3IsIHRoaXMuX2xvb2tBdFRlbXApO1xuICAgICAgICAgICAgICAgIEJBQllMT04uTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LCB0aGlzLnJvdGF0aW9uLngsIHRoaXMucm90YXRpb24ueiwgdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9va0F0VGVtcC5tdWx0aXBseVRvUmVmKHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LCB0aGlzLl90ZW1wTWF0cml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rQXRUZW1wLmludmVydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9sb29rQXRUZW1wLCB0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEJBQllMT04uTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LCB0aGlzLnJvdGF0aW9uLngsIHRoaXMucm90YXRpb24ueiwgdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZih0aGlzLl9yZWZlcmVuY2VQb2ludCwgdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgsIHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRpbmcgdGFyZ2V0IGFuZCBmaW5hbCBtYXRyaXhcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkVG9SZWYodGhpcy5fdHJhbnNmb3JtZWRSZWZlcmVuY2VQb2ludCwgdGhpcy5fY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0LmNvcHlGcm9tKHRoaXMuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgQkFCWUxPTi5NYXRyaXguTG9va0F0TEhUb1JlZih0aGlzLnBvc2l0aW9uLCB0aGlzLl9jdXJyZW50VGFyZ2V0LCB0aGlzLnVwVmVjdG9yLCB0aGlzLl92aWV3TWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXg7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24gKHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgcGF0aFxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsbCBwYXRoIGFycmF5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKz0yMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHZlcnRpY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGljZXNbdmVydGljZXMubGVuZ3RoXSAhPSBwYXRoW3BhdGgubGVuZ3RoXSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCB0aGlzIHBhdGggb24gdGhlIHRpbWVsaW5lXG4gICAgICAgIHRoaXMuX2xlbmd0aE9mQmV6aWVyID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLmxvYWRQYXRoT25UaW1lbGluZSAoKTtcbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLmxvYWRQYXRoT25UaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVmVyaWZ5IGlmIHBhdGggYW5kIGxlbmd0aE9mQmV6aWVyIGV4aXN0XG4gICAgICAgIGlmICghdGhpcy5fcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbGVuZ3RoT2ZCZXppZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aE9mQmV6aWVyID0gdGhpcy5fcGF0aC5sZW5ndGggKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVpbml0aWFsaXplIHRpbWVsaW5lXG4gICAgICAgIGlmICh0aGlzLl90aW1lbGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLmtpbGwoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbmV3IFRpbWVsaW5lTGl0ZSh7b25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fb25Db21wbGV0ZVRpbWVsaW5lKCk7XG4gICAgICAgIH19KTtcblxuICAgICAgICAvLyBJbml0aWFscyBwYXJhbWV0ZXJzIG9mIGFuaW1hdGlvblxuICAgICAgICB2YXIgcXVhbnRpdHkgPSB0aGlzLl9sZW5ndGhPZkJlemllcjtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fbGVuZ3RoT2ZCZXppZXIgLyB0aGlzLmZvbGxvd1NwZWVkO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiB0aGlzLl9wYXRoWzBdLngsXG4gICAgICAgICAgICB5OiB0aGlzLl9wYXRoWzBdLnksXG4gICAgICAgICAgICB6OiB0aGlzLl9wYXRoWzBdLnpcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBCZXppZXIgY3VydmVcbiAgICAgICAgdmFyIHR3ZWVuID0gVHdlZW5MaXRlLnRvKHBvc2l0aW9uLCBxdWFudGl0eSwge2JlemllcjogdGhpcy5fcGF0aCwgZWFzZTpMaW5lYXIuZWFzZU5vbmV9KTtcbiAgICAgICAgdmFyIGksIGQgPSAyMDtcblxuICAgICAgICAvLyBMb2FkIHRoZSBCZXppZXIgY3VydmUgb24gdGltZWxpbmVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHF1YW50aXR5LWQ7IGkrKykge1xuICAgICAgICAgICAgdHdlZW4udGltZShpKTsgLy8gSnVtcHMgdG8gdGhlIGFwcHJvcHJpYXRlIHRpbWUgaW4gdGhlIHR3ZWVuLCBjYXVzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gdmFyaWFibGUgdG8gYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSBfLmNsb25lKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHR3ZWVuLnRpbWUoaStkKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gXy5jbG9uZShwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcm90YXRpb25feSA9IFJBTkRPLlV0aWxzLmFuZ2xlRnJvbUF4aXMoY3VycmVudFBvc2l0aW9uLCBjdXJyZW50VGFyZ2V0LCBCQUJZTE9OLkF4aXMuWSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLmFkZChbXG4gICAgICAgICAgICAgICAgVHdlZW5MaXRlLnRvKHRoaXMucG9zaXRpb24sIChkdXJhdGlvbiAvIHF1YW50aXR5KSwge1xuICAgICAgICAgICAgICAgICAgICB4OiBjdXJyZW50UG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogY3VycmVudFBvc2l0aW9uLnkgKyBSQU5ETy5TRVRUSU5HUy5DQU1fT0ZGU0VULFxuICAgICAgICAgICAgICAgICAgICB6OiBjdXJyZW50UG9zaXRpb24ueixcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogXCJMaW5lYXIuZWFzZU5vbmVcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIFR3ZWVuTGl0ZS50byh0aGlzLnJvdGF0aW9uLCAoZHVyYXRpb24gLyBxdWFudGl0eSksIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uYWxSb3RhdGlvbiA6eyB5OiAocm90YXRpb25feSArXCJfc2hvcnRcIiksIHVzZVJhZGlhbnM6dHJ1ZX0gLFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBcIkxpbmVhci5lYXNlTm9uZVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgcXVhbnRpdHkpIHtcbiAgICAgICAgICAgIHR3ZWVuLnRpbWUoaSsrKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lLmFkZChcbiAgICAgICAgICAgICAgICBUd2VlbkxpdGUudG8odGhpcy5wb3NpdGlvbiwgKGR1cmF0aW9uIC8gcXVhbnRpdHkpLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvc2l0aW9uLnkgKyBSQU5ETy5TRVRUSU5HUy5DQU1fT0ZGU0VULFxuICAgICAgICAgICAgICAgICAgICB6OiBwb3NpdGlvbi56LFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBcIkxpbmVhci5lYXNlTm9uZVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRpb24gcGF1c2VkIGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy5fdGltZWxpbmUucGF1c2UoMCk7XG4gICAgfTtcblxuICAgIFJBTkRPLkhpa2VyQ2FtZXJhLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGFyZ2V0O1xuICAgIH07XG5cbiAgICBSQU5ETy5IaWtlckNhbWVyYS5wcm90b3R5cGUuX29uQ29tcGxldGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBcInN0b3BcIjtcbiAgICB9O1xuXG4gICAgUkFORE8uSGlrZXJDYW1lcmEucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uIChmdXR1cmVQb3NpdGlvbiwgZnV0dXJlVGFyZ2V0LCBzcGVlZCwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgeV9yb3RhdGlvbiA9IFJBTkRPLlV0aWxzLmFuZ2xlRnJvbUF4aXMoZnV0dXJlUG9zaXRpb24sIGZ1dHVyZVRhcmdldCwgQkFCWUxPTi5BeGlzLlkpO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IEJBQllMT04uVmVjdG9yMy5EaXN0YW5jZSh0aGlzLnBvc2l0aW9uLCBmdXR1cmVQb3NpdGlvbik7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGRpc3RhbmNlIC8gc3BlZWQ7XG5cbiAgICAgICAgLy8gVHJhbnNsYXRpb25cbiAgICAgICAgdGhpcy5fcG9zaXRpb25Ud2VlbiA9IFR3ZWVuTGl0ZS50byh0aGlzLnBvc2l0aW9uLCBkdXJhdGlvbiwge1xuICAgICAgICAgICAgeDogZnV0dXJlUG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IGZ1dHVyZVBvc2l0aW9uLnkgKyBSQU5ETy5TRVRUSU5HUy5DQU1fT0ZGU0VULFxuICAgICAgICAgICAgejogZnV0dXJlUG9zaXRpb24ueixcbiAgICAgICAgICAgIGVhc2U6ICdlYXNlLWluJyxcbiAgICAgICAgICAgIG9uQ29tcGxldGUgOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKG9uQ29tcGxldGUpID09PSBcImZ1bmN0aW9uXCIpIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUm90YXRpb25cbiAgICAgICAgdGhpcy5fcm90YXRpb25Ud2VlbiA9IFR3ZWVuTGl0ZS50byh0aGlzLnJvdGF0aW9uLCBkdXJhdGlvbiwge1xuICAgICAgICAgICAgZGlyZWN0aW9uYWxSb3RhdGlvbiA6IHtcbiAgICAgICAgICAgICAgICB4OiBcIjBfc2hvcnRcIixcbiAgICAgICAgICAgICAgICB5OiAoeV9yb3RhdGlvbiArIFwiX3Nob3J0XCIpLFxuICAgICAgICAgICAgICAgIHo6IFwiMF9zaG9ydFwiLFxuICAgICAgICAgICAgICAgIHVzZVJhZGlhbnMgOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWFzZTogJ2Vhc2UtaW4nXG4gICAgICAgIH0pO1xuICAgIH07XG59OyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBSYW5kby5EZW0uanNcbiAqXG4gKiBEZW0gY2xhc3MgOlxuICogIFBlcm1pdGVzIHRoZSBjcmVhdGlvbiBvZiBhIERpZ2l0YWwgRWxldmF0aW9uIE1vZGVsIGluIDNEXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uRGVtID0gZnVuY3Rpb24gKGV4dGVudCwgYWx0aXR1ZGVzLCBvZmZzZXRzLCBzY2VuZSkge1xuICAgICAgICAvKiBBdHRyaWJ1dGVzIGRlY2xhcmF0aW9uICovXG4gICAgICAgIHRoaXMuX2V4dGVudCA9IHRoaXMuX3ByZXBhcmVFeHRlbnQoZXh0ZW50LCBvZmZzZXRzKTtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGVzID0gYWx0aXR1ZGVzXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBvZmZzZXRzO1xuICAgICAgICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLl90aWxlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluX3RoaWNrbmVzcyA9IFJBTkRPLlNFVFRJTkdTLk1JTl9USElDS05FU1M7XG5cbiAgICAgICAgdGhpcy5ncm91bmQgPSBuZXcgQkFCWUxPTi5NZXNoKFwiRGlnaXRhbCBFbGV2YXRpb24gTW9kZWxcIiwgc2NlbmUpO1xuICAgICAgICB0aGlzLnNpZGVzICA9IG5ldyBCQUJZTE9OLk1lc2goXCJTaWRlc1wiLCBzY2VuZSk7XG4gICAgICAgIHRoaXMuc2NhbGVWaWV3ZXIgPSBudWxsO1xuXG4gICAgICAgIC8qIEluaXRpYWxpemF0aW9uICovXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH07XG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hZGp1c3Rab29tICgpO1xuXG4gICAgICAgIHZhciB0aWxlQ29udGFpbmVyID0gbmV3IFJBTkRPLlRpbGVDb250YWluZXIoXG4gICAgICAgICAgICB0aGlzLmdldFJlYWxFeHRlbnQoKSxcbiAgICAgICAgICAgIHRoaXMuX2FsdGl0dWRlcyxcbiAgICAgICAgICAgIHRoaXMuX29mZnNldHNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fdGlsZXMgPSB0aWxlQ29udGFpbmVyLl90aWxlcztcbiAgICAgICAgdGhpcy5fZnJhbWUgPSB0aWxlQ29udGFpbmVyLmdldEZyYW1lKCk7XG5cbiAgICAgICAgdGhpcy5idWlsZEdyb3VuZCgpO1xuICAgICAgICB0aGlzLmJ1aWxkU2lkZXMoKTtcbiAgICAgICAgdGhpcy5idWlsZEJhc2VtZW50KCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogUkFORE8uRGVtLl9wcmVwYXJlRXh0ZW50KCkgOiB0cmFuc2xhdGUgZXh0ZW50IG9mIHRoZSBvZmZzZXRzIGluIHBhcmFtZXRlcnNcbiAgICAgKiAgLSBleHRlbnQgOiBleHRlbnQgdG8gdHJhbnNsYXRlXG4gICAgICogIC0gb2Zmc2V0cyA6IHZhbHVlcyBvZiB0aGUgdHJhbnNsYXRpb25cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLl9wcmVwYXJlRXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2Zmc2V0cykge1xuICAgICAgICBleHRlbnQueC5taW4gKz0gb2Zmc2V0cy54O1xuICAgICAgICBleHRlbnQueC5tYXggKz0gb2Zmc2V0cy54O1xuICAgICAgICBleHRlbnQuei5taW4gKz0gb2Zmc2V0cy56O1xuICAgICAgICBleHRlbnQuei5tYXggKz0gb2Zmc2V0cy56O1xuICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFJBTkRPLkRlbS5fYWRqdXN0Wm9vbSgpIDogYWRqdXN0IHRoZSB0aWxlJ3Mgem9vbSBhY2NvcmRpbmcgdGhlIGV4dGVudCBvZiB0aGUgREVNXG4gICAgICogIE1vcmUgdGhlIERFTSBpcyBsYXJnZSwgbW9yZSB0aGUgem9vbSBkZWNyZWFzZWQgYW5kIHNvIHRpbGVzIGFyZSBiaWdnZXIuXG4gICAgICpcbiAgICAgKiBOQiA6IEl0IHRha2UgaW4gY291bnQgdGhlIFJBTkRPLlNFVFRJTkdTLlRJTEVfTlVNQkVSX0xJTUlUIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogbGltaXQgbnVtYmVyIG9mIHRpbGVzLiBUaGlzIG51bWJlciBjYW4gYmUgY2hhbmdlZCBpbiBjb252ZW5pZW5jZSBiZWZvcmUgbGF1bmNoIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLl9hZGp1c3Rab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoUkFORE8uVXRpbHMuZ2V0TnVtYmVyT2ZUaWxlcyhSQU5ETy5TRVRUSU5HUy5USUxFX1pPT00sIHRoaXMuZ2V0UmVhbEV4dGVudCgpKSA+IFJBTkRPLlNFVFRJTkdTLlRJTEVfTlVNQkVSX0xJTUlUKSB7XG4gICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5USUxFX1pPT00gLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uYnVpbGRHcm91bmQoKSA6IGJ1aWxkIHRoZSBncm91bmQgb2YgdGhlIERFTVxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuYnVpbGRHcm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEdyb3VuZCBidWlsZGluZy4uLlxuICAgICAgICBjb25zb2xlLmxvZyhcIkdyb3VuZCBidWlsZGluZy4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICAvLyBDcmVhdGVzIGFsbCB0aWxlc1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgdmFyIG1lc2hUaWxlID0gdGhpcy5fYnVpbGRUaWxlKHRoaXMuX3RpbGVzW2l0XSk7XG4gICAgICAgICAgICBtZXNoVGlsZS5wYXJlbnQgPSB0aGlzLmdyb3VuZDtcblxuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgZnV0dXJlIHRpbGUncyB0ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlVGV4dHVyZSh0aGlzLl90aWxlc1tpdF0uY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JvdW5kIGJ1aWx0ICFcbiAgICAgICAgY29uc29sZS5sb2coXCJHcm91bmQgYnVpbHQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLmJ1aWxkU2lkZXMoKSA6IGJ1aWxkIGZvdXIgc2lkZXMgb2YgdGhlIERFTVxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuYnVpbGRTaWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gU2lkZXMgYnVpbGRpbmcuLi5cbiAgICAgICAgY29uc29sZS5sb2coXCJTaWRlcyBidWlsZGluZy4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICB2YXIgYWx0X21pbiA9IC0gdGhpcy5fbWluX3RoaWNrbmVzcztcblxuICAgICAgICAvLyBDcmVhdGVzIGRpZmZlcmVudHMgc2lkZXNcbiAgICAgICAgdmFyIGVfc2lkZSA9IHRoaXMuX2J1aWxkU2lkZShcIkVhc3QgU2lkZVwiLCAgdGhpcy5fZnJhbWUuZWFzdCwgIGFsdF9taW4sIGZhbHNlKTtcbiAgICAgICAgdmFyIHdfc2lkZSA9IHRoaXMuX2J1aWxkU2lkZShcIldlc3QgU2lkZVwiLCAgdGhpcy5fZnJhbWUud2VzdCwgIGFsdF9taW4sIHRydWUgKTtcbiAgICAgICAgdmFyIG5fc2lkZSA9IHRoaXMuX2J1aWxkU2lkZShcIk5vcnRoIFNpZGVcIiwgdGhpcy5fZnJhbWUubm9ydGgsIGFsdF9taW4sIGZhbHNlKTtcbiAgICAgICAgdmFyIHNfc2lkZSA9IHRoaXMuX2J1aWxkU2lkZShcIlNvdXRoIFNpZGVcIiwgdGhpcy5fZnJhbWUuc291dGgsIGFsdF9taW4sIHRydWUgKTtcblxuICAgICAgICAvLyBTZXQgc2lkZXMgY29udGFpbmVyIGFzIHBhcmVudCBvZiBzaWRlc1xuICAgICAgICBlX3NpZGUucGFyZW50ID0gdGhpcy5zaWRlcztcbiAgICAgICAgd19zaWRlLnBhcmVudCA9IHRoaXMuc2lkZXM7XG4gICAgICAgIG5fc2lkZS5wYXJlbnQgPSB0aGlzLnNpZGVzO1xuICAgICAgICBzX3NpZGUucGFyZW50ID0gdGhpcy5zaWRlcztcblxuICAgICAgICAvLyBTaWRlcyBidWlsdCAhXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2lkZXMgYnVpbHQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLmJ1aWxkQmFzZW1lbnQoKSA6IGJ1aWxkIHRoZSBiYXNlbWVudCBvZiB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5idWlsZEJhc2VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYXNlbWVudCBidWlsZGluZy4uLlxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhc2VtZW50IGJ1aWxkaW5nLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuXG4gICAgICAgIHZhciBBID0ge1xuICAgICAgICAgICAgJ3gnIDogdGhpcy5fZXh0ZW50LngubWluLFxuICAgICAgICAgICAgJ3knIDogdGhpcy5fZXh0ZW50LnoubWluXG4gICAgICAgIH07XG4gICAgICAgIHZhciBCID0ge1xuICAgICAgICAgICAgJ3gnIDogdGhpcy5fZXh0ZW50LngubWF4LFxuICAgICAgICAgICAgJ3knIDogdGhpcy5fZXh0ZW50LnoubWluXG4gICAgICAgIH07XG4gICAgICAgIHZhciBDID0ge1xuICAgICAgICAgICAgJ3gnIDogdGhpcy5fZXh0ZW50LngubWF4LFxuICAgICAgICAgICAgJ3knIDogdGhpcy5fZXh0ZW50LnoubWF4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBEID0ge1xuICAgICAgICAgICAgJ3gnIDogdGhpcy5fZXh0ZW50LngubWluLFxuICAgICAgICAgICAgJ3knIDogdGhpcy5fZXh0ZW50LnoubWF4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiYXNlbWVudCA9IFJBTkRPLlV0aWxzLmNyZWF0ZUdyb3VuZEZyb21FeHRlbnQgKFxuICAgICAgICAgICAgXCJERU0gQmFzZW1lbnRcIiwgQSwgQiwgQywgRCwgMSwgMSwgdGhpcy5fc2NlbmVcbiAgICAgICAgKTtcbiAgICAgICAgYmFzZW1lbnQubWF0ZXJpYWwgPSBuZXcgQkFCWUxPTi5TdGFuZGFyZE1hdGVyaWFsKFwiQmFzZW1lbnQgTWF0ZXJpYWxcIiwgdGhpcy5fc2NlbmUpO1xuICAgICAgICBiYXNlbWVudC5tYXRlcmlhbC5kaWZmdXNlVGV4dHVyZSA9IG5ldyBCQUJZTE9OLlRleHR1cmUoXG4gICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5TSURFX1RFWF9VUkwsXG4gICAgICAgICAgICB0aGlzLl9zY2VuZVxuICAgICAgICApO1xuICAgICAgICBiYXNlbWVudC5wb3NpdGlvbi55IC09IHRoaXMuX21pbl90aGlja25lc3M7XG5cbiAgICAgICAgLy8gQmFzZW1lbnQgYnVpbHQgIVxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhc2VtZW50IGJ1aWx0ICEgXCIgKyAoRGF0ZS5ub3coKSAtIFJBTkRPLlNUQVJUX1RJTUUpICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5fYnVpbGRUaWxlKCkgOiBidWlsZCBhIHRpbGUgb2YgdGhlIERFTVxuICAgICAqICAgICAgLSBkYXRhIDogZGF0YSBvZiBhIHRpbGVcbiAgICAgKlxuICAgICAqICByZXR1cm4gdGhlIHRpbGUgbWVzaFxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuX2J1aWxkVGlsZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBzY2VuZSAgID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIHZhciBlbmdpbmUgID0gc2NlbmUuZ2V0RW5naW5lKCk7XG4gICAgICAgIHZhciB0aGF0ICAgID0gdGhpcztcblxuICAgICAgICAvLyBDcmVhdGVzIFRpbGVcbiAgICAgICAgdmFyIHRpbGUgPSBSQU5ETy5VdGlscy5jcmVhdGVHcm91bmRGcm9tR3JpZChcbiAgICAgICAgICAgIFwiVGlsZVwiLFxuICAgICAgICAgICAgZGF0YS5ncmlkLFxuICAgICAgICAgICAgc2NlbmVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSZWNvbXB1dGVzIG5vcm1hbHMgZm9yIGxpZ2h0cyBhbmQgc2hhZG93c1xuICAgICAgICBSQU5ETy5VdGlscy5jb21wdXRlTWVzaE5vcm1hbHModGlsZSlcblxuICAgICAgICAvLyBTZXQgVXZzIGRhdGEgb2YgdGhlIHRpbGVcbiAgICAgICAgUkFORE8uVXRpbHMuc2V0TWVzaFV2cyh0aWxlLCBkYXRhLnV2KTtcblxuICAgICAgICAvLyBFbmFibGVzIGNvbGxpc2lvbnNcbiAgICAgICAgdGlsZS5jaGVja0NvbGxpc2lvbnMgPSB0cnVlO1xuXG4gICAgICAgIC8vIE1hdGVyaWFsXG4gICAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBCQUJZTE9OLlN0YW5kYXJkTWF0ZXJpYWwoXCJERU0gLSBNYXRlcmlhbFwiLCBzY2VuZSk7XG4gICAgICAgIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRydWU7XG4gICAgICAgIG1hdGVyaWFsLmJhY2tGYWNlQ3VsbGluZyA9IGZhbHNlO1xuICAgICAgICB0aWxlLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uX2J1aWxkU2lkZSgpIDogYnVpbGQgYSBzaWRlIG9mIHRoZSBERU1cbiAgICAgKiAgICAgIC0gbmFtZTogbmFtZSBvZiB0aGUgc2lkZVxuICAgICAqICAgICAgLSBsaW5lOiBBcnJheSBvZiBwb2ludCBjb3JyZXNwb25kaW5nIHRvIGEgYm9yZGVyIG9mIHRoZSBERU1cbiAgICAgKiAgICAgIC0gYWx0X21pbjogYWx0aXR1ZGUgbWluaW1hbGUgb2YgdGhlIERFTVxuICAgICAqICAgICAgLSByZXZlcnNlOiBCb29sZWFuLCBpZiB0cnVlIHJldmVyc2UgdGhlIGxpbmVcbiAgICAgKlxuICAgICAqICByZXR1cm4gdGhlIHNpZGUgbWVzaFxuICAgICAqL1xuICAgIFJBTkRPLkRlbS5wcm90b3R5cGUuX2J1aWxkU2lkZSA9IGZ1bmN0aW9uIChuYW1lLCBsaW5lLCBhbHRfbWluLCByZXZlcnNlKSB7XG4gICAgICAgIHZhciBzY2VuZSA9IHRoaXMuX3NjZW5lO1xuXG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICBsaW5lLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZXMgc2lkZVxuICAgICAgICB2YXIgc2lkZSA9IFJBTkRPLlV0aWxzLmNyZWF0ZVNpZGVGcm9tTGluZShuYW1lLCBsaW5lLCBhbHRfbWluLCBzY2VuZSk7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZVNpZGVVdnMoc2lkZSwgbGluZSwgYWx0X21pbik7XG5cbiAgICAgICAgLy8gU2lkZSBtYXRlcmlhbFxuICAgICAgICBzaWRlLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChuYW1lICsgXCJNYXRlcmlhbFwiLCBzY2VuZSk7XG4gICAgICAgIHNpZGUubWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUgPSBuZXcgQkFCWUxPTi5UZXh0dXJlKFJBTkRPLlNFVFRJTkdTLlNJREVfVEVYX1VSTCwgc2NlbmUpO1xuXG4gICAgICAgIC8vIFJlY29tcHV0ZXMgbm9ybWFscyBmb3IgbGlnaHRzIGFuZCBzaGFkb3dzXG4gICAgICAgIFJBTkRPLlV0aWxzLmNvbXB1dGVNZXNoTm9ybWFscyhzaWRlKTtcblxuICAgICAgICAvLyBFbmFibGVzIGNvbGxpc2lvbnNcbiAgICAgICAgc2lkZS5jaGVja0NvbGxpc2lvbnMgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBzaWRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5EZW0uYXBwbHlUZXh0dXJlcygpIDogTG9hZCB0aWxlJ3MgdGV4dHVyZXMgb3ZlciB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5hcHBseVRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRleHR1cmVzIGFwcGxpY2F0aW9uIC4uLiBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICAvL34gLy8gUHJlcGFyZSBhbGwgdGV4dHVyZXNcbiAgICAgICAgLy9+IGZvciAodmFyIGl0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICAvL34gdGhpcy5fcHJlcGFyZVRleHR1cmUodGhpcy5fdGlsZXNbaXRdLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgLy9+IH1cblxuICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIG1lc2hlcyA9IHRoaXMuZ3JvdW5kLmdldENoaWxkcmVuICgpO1xuICAgICAgICB2YXIgZmluYWxUZXh0dXJlcyA9IHRoaXMuX3RleHR1cmVzO1xuICAgICAgICB2YXIgY2hlY2tlZCA9IFtdO1xuICAgICAgICB2YXIgY291bnQgPSBmaW5hbFRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gZmluYWxUZXh0dXJlcyl7XG4gICAgICAgICAgICBjaGVja2VkLnB1c2goZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbG9vcCAoKXtcbiAgICAgICAgICAgIHZhciBpdCA9IDA7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSA1MDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY250ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNudC0tICYmIGl0IDwgZmluYWxUZXh0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2VkW2l0XSAmJiBmaW5hbFRleHR1cmVzW2l0XS5fdGV4dHVyZS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkW2l0XSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSB3aGVuIGl0J3MgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBtZXNoZXNbaXRdLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUgPSBmaW5hbFRleHR1cmVzW2l0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2VUZXh0dXJlLndyYXBVID0gQkFCWUxPTi5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUud3JhcFYgPSBCQUJZTE9OLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGl0IDwgZmluYWxUZXh0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCAoYXBwbHksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQgKGxvb3AsIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGV4dHVyZXMgYXBwbGllZCAhIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGxvb3AoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uRGVtLl9wcmVwYXJlVGV4dHVyZSgpIDogUHJlcGFyZSBhIHRpbGUgb2YgdGV4dHVyZXMgZm9yIHRoZSBERU0gYW5kIGFkZFxuICAgICAqICBpdCB0byB0aGUgdGV4dHVyZXMgQXJyYXkuXG4gICAgICogICAgICAtIGNvb3JkaW5hdGVzIDogY29vcmRpbmF0ZXMgb2YgYSB0aWxlXG4gICAgICpcbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLl9wcmVwYXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIGVuZ2luZSA9IHNjZW5lLmdldEVuZ2luZSgpO1xuICAgICAgICB2YXIgdXJsID0gUkFORE8uVXRpbHMucmVwbGFjZVVybENvb3JkaW5hdGVzKFxuICAgICAgICAgICAgUkFORE8uU0VUVElOR1MuVElMRV9URVhfVVJMLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICBjb29yZGluYXRlcy55XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2gobmV3IEJBQllMT04uVGV4dHVyZSh1cmwsIHNjZW5lKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5fY29tcHV0ZVNpZGVVdnMoKSA6IENvbXB1dGVzIHV2cyB2YWx1ZXMgb2YgYSBzaWRlXG4gICAgICogICAgICAtIHNpZGUgOiBzaWRlIG1lc2hcbiAgICAgKiAgICAgIC0gbGluZSA6IGxpbmUgb2YgYWx0aXR1ZGVzXG4gICAgICogICAgICAtIGFsdF9taW4gOiBpdCBpcyB0aGUgbWluaW11bSBhbHRpdHVkZSBvZiB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uRGVtLnByb3RvdHlwZS5fY29tcHV0ZVNpZGVVdnMgPSBmdW5jdGlvbiAoc2lkZSwgbGluZSwgYWx0X21pbikge1xuICAgICAgICB2YXIgY1R5cGUgPSAneic7XG4gICAgICAgIGlmIChsaW5lW2xpbmUubGVuZ3RoLTFdLnogLSBsaW5lWzBdLnogPT0gMCkge1xuICAgICAgICAgICAgY1R5cGUgPSAneCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiBsaW5lKSB7XG4gICAgICAgICAgICB1LnB1c2goXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobGluZVtpdF1bY1R5cGVdIC0gbGluZVswXVtjVHlwZV0pICpcbiAgICAgICAgICAgICAgICAxIC8gKE1hdGguYWJzKGxpbmVbbGluZS5sZW5ndGgtMV1bY1R5cGVdIC0gbGluZVswXVtjVHlwZV0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1diA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB1KSB7XG4gICAgICAgICAgICB1di5wdXNoKHVbaXRdKTsgLy8gdSB2YWx1ZVxuICAgICAgICAgICAgdXYucHVzaCgobGluZVtpdF0ueSAtIGFsdF9taW4pLyh0aGlzLl9leHRlbnQueS5tYXggLSBhbHRfbWluKSk7IC8vIHYgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpdCBpbiB1KSB7XG4gICAgICAgICAgICB1di5wdXNoKHVbaXRdKTsgLy8gdSB2YWx1ZVxuICAgICAgICAgICAgdXYucHVzaCgwKTsgLy8gdiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgc2lkZS5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kLCB1dik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLkRlbS5nZXRSZWFsRXh0ZW50KCkgOiBHaXZlIHRoZSByZWFsIGV4dGVudCBvZiB0aGUgREVNLCBpdCBtZWFucyB0aGVcbiAgICAgKiAgZXh0ZW50IGluIG1ldGVycyBpbiB0aGUgb3JpZ2luYWwgcHJvamVjdGlvbi5cbiAgICAgKi9cbiAgICBSQU5ETy5EZW0ucHJvdG90eXBlLmdldFJlYWxFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB7fTtcbiAgICAgICAgZXh0ZW50LnggPSB7fTtcbiAgICAgICAgZXh0ZW50LnkgPSB7fTtcbiAgICAgICAgZXh0ZW50LnogPSB7fTtcbiAgICAgICAgZXh0ZW50LngubWluID0gdGhpcy5fZXh0ZW50LngubWluIC0gdGhpcy5fb2Zmc2V0cy54O1xuICAgICAgICBleHRlbnQueC5tYXggPSB0aGlzLl9leHRlbnQueC5tYXggLSB0aGlzLl9vZmZzZXRzLng7XG4gICAgICAgIGV4dGVudC55Lm1pbiA9IHRoaXMuX2V4dGVudC55Lm1pbjtcbiAgICAgICAgZXh0ZW50LnkubWF4ID0gdGhpcy5fZXh0ZW50LnkubWF4O1xuICAgICAgICBleHRlbnQuei5taW4gPSB0aGlzLl9leHRlbnQuei5taW4gLSB0aGlzLl9vZmZzZXRzLno7XG4gICAgICAgIGV4dGVudC56Lm1heCA9IHRoaXMuX2V4dGVudC56Lm1heCAtIHRoaXMuX29mZnNldHMuejtcbiAgICAgICAgcmV0dXJuIGV4dGVudDtcbiAgICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFJBTkRPKSB7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIFJBTkRPLkV2ZW50cyA9IHt9O1xuICAgIC8qXG4gICAgICogQmluZCBhbmQgVW5iaW5kIGV2ZW50c1xuICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvLyBET00gTGV2ZWwgMiBFdmVudCBtb2RlbFxuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIFJBTkRPLkV2ZW50cy5hZGRFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH07XG4gICAgICAgIFJBTkRPLkV2ZW50cy5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBmbikge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFByb3ByaWV0YXJ5IGxlZ2FjeSBJRSBNb2RlbFxuICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIFJBTkRPLkV2ZW50cy5hZGRFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBmbikge1xuICAgICAgICAgICAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShlbGVtLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgYm91bmQpO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgICAgICB9O1xuICAgICAgICBSQU5ETy5FdmVudHMucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9uXCIgKyB0eXBlLCBmbik7XG4gICAgICAgIH07XG4gICAgfVxufTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uUG9pLmpzXG4gKlxuICogUG9pIGNsYXNzIDpcbiAqICBQZXJtaXRlcyB0aGUgYnVpbGQgb2YgYSBQb2ludCBvZiBJbnRlcmVzdCBpbiAzRFxuICpcbiAqIEBhdXRob3I6IEPDqWxpYW4gR0FSQ0lBXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFJBTkRPLCBCQUJZTE9OKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG5cbiAgICAvKiBDb25zdHJ1Y3RvciAqL1xuICAgIFJBTkRPLlBvaSA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgb2Zmc2V0cywgc2NlbmUpIHtcbiAgICAgICAgdGhpcy5faWQgICAgICAgICAgICA9IGlkXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uICAgICAgPSB7XG4gICAgICAgICAgICAneCcgOiBkYXRhLmNvb3JkaW5hdGVzLnggKyBvZmZzZXRzLngsXG4gICAgICAgICAgICAneScgOiAwLFxuICAgICAgICAgICAgJ3onIDogZGF0YS5jb29yZGluYXRlcy56ICsgb2Zmc2V0cy56XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX25hbWUgICAgICAgICAgPSBkYXRhLnByb3BlcnRpZXMubmFtZTtcbiAgICAgICAgdGhpcy5fdHlwZSAgICAgICAgICA9IGRhdGEucHJvcGVydGllcy50eXBlO1xuICAgICAgICB0aGlzLl9lbGV2YXRpb24gICAgID0gZGF0YS5wcm9wZXJ0aWVzLmVsZXZhdGlvbjtcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gICA9IGRhdGEucHJvcGVydGllcy5kZXNjcmlwdGlvbiB8fCBSQU5ETy5TRVRUSU5HUy5OT19ERVNDUklQVElPTl9NRVNTQUdFO1xuICAgICAgICB0aGlzLl9zY2VuZSAgICAgICAgID0gc2NlbmU7XG5cbiAgICAgICAgdGhpcy5wYW5lbCAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMucGljdG8gICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnNwaGVyZSAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRMaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH07XG5cbiAgICBSQU5ETy5Qb2kucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkUGFuZWwgKCk7XG4gICAgICAgIHRoaXMuX2J1aWxkU3BoZXJlICgpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2NlbmUucmVnaXN0ZXJCZWZvcmVSZW5kZXIoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX3JlZ2lzdGVyQmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5Qb2kuX2J1aWxkUGFuZWwoKSA6IGJ1aWxkIGEgUGFuZWwgd2l0aCBhIHBpY3RvIHdoaWNoIGRlZmluZXMgdGhlIHR5cGUgb2YgUE9JXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5fYnVpbGRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjZW5lICAgICAgID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIHZhciBwb3NpdGlvbiAgICA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgICAgICB2YXIgdGV4dCAgICAgICAgPSB0aGlzLl9uYW1lO1xuICAgICAgICB2YXIgc3JjICAgICAgICAgPSBSQU5ETy5TRVRUSU5HUy5QSUNUT19QUkVGSVggKyB0aGlzLl90eXBlLnBpY3RvZ3JhbTtcbiAgICAgICAgdmFyIGlkICAgICAgICAgID0gdGhpcy5faWQ7XG4gICAgICAgIHZhciBlbGV2YXRpb24gICA9IHRoaXMuX2VsZXZhdGlvbjtcblxuICAgICAgICAvLyBTaXplIG9mIHBhbmVsIChpbiBwaXhlbCBhbmQgaW4gbWV0ZXJzKVxuICAgICAgICB2YXIgcGFuX3NpemUgPSB7XG4gICAgICAgICAgICBweDoge1xuICAgICAgICAgICAgICAgIHdpZHRoIDogNTEyLFxuICAgICAgICAgICAgICAgIGhlaWdodCA6IDUxMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG06IHtcbiAgICAgICAgICAgICAgICB3aWR0aCA6IFJBTkRPLlNFVFRJTkdTLlBJQ1RPX1NJWkUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDogUkFORE8uU0VUVElOR1MuUElDVE9fU0laRSArIDMwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNpemUgb2YgdGhlIHBpY3RvZ3JhbSAoaW4gcGl4ZWxzKVxuICAgICAgICB2YXIgcGljdG9fc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoIDogcGFuX3NpemUucHgud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgOiBwYW5fc2l6ZS5weC5oZWlnaHQgKiBSQU5ETy5TRVRUSU5HUy5QSUNUT19TSVpFIC8gcGFuX3NpemUubS5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCdWlsZGluZyBwYW5lbCBNZXNoXG4gICAgICAgIHZhciBwYW5lbCA9IEJBQllMT04uTWVzaC5DcmVhdGVHcm91bmQoXG4gICAgICAgICAgICBcIlBPSSAtIFBhbmVsXCIsXG4gICAgICAgICAgICBwYW5fc2l6ZS5tLndpZHRoLFxuICAgICAgICAgICAgcGFuX3NpemUubS5oZWlnaHQsXG4gICAgICAgICAgICAyLCBzY2VuZVxuICAgICAgICApO1xuICAgICAgICBwYW5lbC5pZCA9IGlkO1xuICAgICAgICBwYW5lbC5yb3RhdGUgKEJBQllMT04uQXhpcy5YLCAtTWF0aC5QSS8yLCBCQUJZTE9OLlNwYWNlLkxPQ0FMKTtcbiAgICAgICAgcGFuZWwucG9zaXRpb24ueCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHBhbmVsLnBvc2l0aW9uLnkgPSAtMTAwMDtcbiAgICAgICAgcGFuZWwucG9zaXRpb24ueiA9IHBvc2l0aW9uLno7XG4gICAgICAgIHBhbmVsLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcIlBPSSAtIFBhbmVsIC0gTWF0ZXJpYWxcIiwgc2NlbmUpO1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG5cbiAgICAgICAgLy8gUGFuZWwgVGV4dHVyZVxuICAgICAgICB2YXIgcGFuZWxfdGV4ID0gbmV3IEJBQllMT04uRHluYW1pY1RleHR1cmUoXCJQT0kgLSBQYW5lbCAtIFRleHR1cmVcIiwgcGFuX3NpemUucHgud2lkdGgsIHNjZW5lLCB0cnVlKTtcbiAgICAgICAgcGFuZWxfdGV4Lmhhc0FscGhhID0gdHJ1ZTtcbiAgICAgICAgZmlsbFBhbmVsVGV4dHVyZSgpO1xuXG4gICAgICAgIC8vIEJ1aWxkaW5nIHBpY3RvZ3JhbSBDb250YWluZXJcbiAgICAgICAgdmFyIHBpY3RvID0gQkFCWUxPTi5NZXNoLkNyZWF0ZUdyb3VuZChcbiAgICAgICAgICAgIFwiUE9JIC0gUGFuZWxcIixcbiAgICAgICAgICAgIHBhbl9zaXplLm0ud2lkdGgsXG4gICAgICAgICAgICBwYW5fc2l6ZS5tLmhlaWdodCxcbiAgICAgICAgICAgIDIsIHNjZW5lXG4gICAgICAgICk7XG4gICAgICAgIHBpY3RvLmlkID0gaWQ7XG4gICAgICAgIHBpY3RvLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcIlBPSSAtIFBpY3RvIC0gTWF0ZXJpYWxcIiwgc2NlbmUpO1xuICAgICAgICBwaWN0by5yZW5kZXJpbmdHcm91cElkID0gMTtcbiAgICAgICAgdGhpcy5waWN0byA9IHBpY3RvO1xuICAgICAgICBwaWN0by5wYXJlbnQgPSBwYW5lbDtcblxuICAgICAgICAvLyBQaWN0b2dyYW0gVGV4dHVyZVxuICAgICAgICB2YXIgcGljdG9fdGV4ID0gbmV3IEJBQllMT04uRHluYW1pY1RleHR1cmUoXCJQT0kgLSBQaWN0byAtIFRleHR1cmVcIiwgcGFuX3NpemUucHgud2lkdGgsIHNjZW5lLCB0cnVlKTtcbiAgICAgICAgcGljdG9fdGV4Lmhhc0FscGhhID0gdHJ1ZTtcbiAgICAgICAgZmlsbFBpY3RvVGV4dHVyZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbGxQaWN0b1RleHR1cmUgKCkge1xuICAgICAgICAgICAgdmFyIHBpY3RvQ29udGV4dCA9IHBpY3RvX3RleC5nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgdGhlIHBpY3RvZ3JhbSBvbiB0aGUgcGljdG9ncmFtIGNvbnRhaW5lclxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwaWN0b0NvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCwgcGljdG9fc2l6ZS53aWR0aCwgcGljdG9fc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICAgICAgcGljdG9Db250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBwaWN0b190ZXgudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcGljdG8ubWF0ZXJpYWwuZGlmZnVzZVRleHR1cmUgPSBwaWN0b190ZXg7XG4gICAgICAgICAgICAgICAgcGljdG8ubWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlID0gcGljdG9fdGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBzcmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZmlsbFBhbmVsVGV4dHVyZSAoKSB7XG4gICAgICAgICAgICB2YXIgcGFuZWxDb250ZXh0ID0gcGFuZWxfdGV4LmdldENvbnRleHQoKTtcblxuICAgICAgICAgICAgLy8gRHJhd3MgYmFja2dyb3VuZCBvZiB0aGUgcGljdG9ncmFtIG9uIHRoZSBwYW5lbFxuICAgICAgICAgICAgcGFuZWxDb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpXCI7XG4gICAgICAgICAgICBSQU5ETy5VdGlscy5yb3VuZFJlY3QocGFuZWxDb250ZXh0LCAwLCAwLCBwaWN0b19zaXplLndpZHRoLCBwaWN0b19zaXplLmhlaWdodCwgcGFuX3NpemUucHgud2lkdGgvMTApO1xuXG4gICAgICAgICAgICAvLyBTZXQgJiBkcmF3IHRoZSB0ZXh0IG9uIHRoZSBwYW5lbFxuICAgICAgICAgICAgdmFyIHRleHQgPSBlbGV2YXRpb24gKyBcIm1cIjtcbiAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IChwYW5fc2l6ZS5weC5oZWlnaHQgLSBwaWN0b19zaXplLmhlaWdodCkgKiBSQU5ETy5TRVRUSU5HUy5QT0lfTEFCRUxfU0NBTEUgO1xuICAgICAgICAgICAgcGFuZWxDb250ZXh0LmZvbnQgPSBcImJvbGRlciBcIiArIGZvbnRTaXplICsgXCJwdCBBcmlhbFwiO1xuICAgICAgICAgICAgcGFuZWxDb250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZlwiO1xuICAgICAgICAgICAgcGFuZWxDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICBwYW5lbENvbnRleHQuZmlsbFRleHQodGV4dCwgcGFuX3NpemUucHgud2lkdGgvMiwgcGFuX3NpemUucHguaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICBwYW5lbENvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgcGFuZWxfdGV4LnVwZGF0ZSgpO1xuICAgICAgICAgICAgcGFuZWwubWF0ZXJpYWwub3BhY2l0eVRleHR1cmUgICA9IHBhbmVsX3RleDtcbiAgICAgICAgICAgIHBhbmVsLm1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSAgPSBwYW5lbF90ZXg7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5fYnVpbGRTcGhlcmUoKSA6IGJ1aWxkIGEgU3BoZXJlIHdoaWNoIHdpbGwgYmUgb24gdGhlIHJlYWwgcG9zaXRpb25cbiAgICAgKiAgb2YgdGhlIFBPSSBvbiB0aGUgREVNLlxuICAgICAqL1xuICAgIFJBTkRPLlBvaS5wcm90b3R5cGUuX2J1aWxkU3BoZXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NlbmUgICAgICAgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uICAgID0gdGhpcy5fcG9zaXRpb247XG5cbiAgICAgICAgdmFyIHNwaGVyZSA9IEJBQllMT04uTWVzaC5DcmVhdGVTcGhlcmUoXG4gICAgICAgICAgICBcIlBPSSAtIFNwaGVyZVwiLCAxMCwgUkFORE8uU0VUVElOR1MuUE9JX1NJWkUsIHNjZW5lXG4gICAgICAgICk7XG4gICAgICAgIHNwaGVyZS5tYXRlcmlhbCA9IG5ldyBCQUJZTE9OLlN0YW5kYXJkTWF0ZXJpYWwoXG4gICAgICAgICAgICBcIlBPSSAtIFNwaGVyZSAtIE1hdGVyaWFsXCIsIHNjZW5lXG4gICAgICAgICk7XG4gICAgICAgIHNwaGVyZS5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMSwgMSwgMSk7XG4gICAgICAgIHNwaGVyZS5tYXRlcmlhbC5lbWlzc2l2ZUNvbG9yID0gbmV3IEJBQllMT04uQ29sb3IzKDEsIDEsIDEpO1xuICAgICAgICB0aGlzLnNwaGVyZSA9IHNwaGVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uUG9pLl9yZWdpc3RlckJlZm9yZVJlbmRlcigpIDogZnVuY3Rpb24gdG8gY2FsbCBiZWZvcmUgZWFjaCBzY2VuZSByZW5kZXJcbiAgICAgKi9cbiAgICBSQU5ETy5Qb2kucHJvdG90eXBlLl9yZWdpc3RlckJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjZW5lICAgICAgID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIHZhciBwYW5lbCAgICAgICA9IHRoaXMucGFuZWw7XG4gICAgICAgIHZhciBwaWN0byAgICAgICA9IHRoaXMucGljdG87XG5cbiAgICAgICAgLy8gQ29udHJvbHMgdmlzaWJpbGl0eSBhY2NvcmRpbmcgdGhlIERpc3RhbmNlIGZyb20gY2FtZXJhXG4gICAgICAgIGlmIChCQUJZTE9OLlZlY3RvcjMuRGlzdGFuY2UocGFuZWwucG9zaXRpb24sIHNjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbikgPCAzMDApIHtcbiAgICAgICAgICAgIHBhbmVsLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcGljdG8uaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYW5lbC5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgcGljdG8uaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRyb2xzIHBhbmVsIG9yaWVudGF0aW9uXG4gICAgICAgIHBhbmVsLmxvb2tBdChzY2VuZS5hY3RpdmVDYW1lcmEucG9zaXRpb24sIDAsIC1NYXRoLlBJLzIsIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5Qb2kuZHJhcGUoKSA6IGRyYXBlIHRoZSBQT0kgb3ZlciB0aGUgREVNXG4gICAgICogICAgICAtIGdyb3VuZCA6IGdyb3VuZCBvZiB0aGUgREVNXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5kcmFwZSA9IGZ1bmN0aW9uIChncm91bmQpIHtcbiAgICAgICAgUkFORE8uVXRpbHMuZHJhcGVQb2ludCh0aGlzLnBhbmVsLnBvc2l0aW9uLCBncm91bmQsIFJBTkRPLlNFVFRJTkdTLlBPSV9PRkZTRVQpO1xuICAgICAgICB0aGlzLnNwaGVyZS5wb3NpdGlvbiA9IHRoaXMucGFuZWwucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgdGhpcy5zcGhlcmUucG9zaXRpb24ueSAtPSBSQU5ETy5TRVRUSU5HUy5QT0lfT0ZGU0VUO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5Qb2kub25Nb3VzZURvd25IYW5kbGVyKCkgOiBjYWxsYmFjayB0byBydW4gaWYgdGhlIG1vdXNlIGlzIGRvd24gb3ZlciBhIHBpY3RvXG4gICAgICogICAgICAtIGV2dDogZXZlbnQgaW5mb3JtYXRpb25zXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5vbk1vdXNlRG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICQoJy5wb2ktLWNsaWNrZWQnKS50ZXh0KHRoaXMuX25hbWUgKyAnICgnICsgdGhpcy5fZWxldmF0aW9uICsgJ20gKScpO1xuICAgICAgICAkKCcucG9pLS1jbGlja2VkJykuY3NzKCdsZWZ0JywgZXZ0LmNsaWVudFggLSAyMCArICdweCcpO1xuICAgICAgICAkKCcucG9pLS1jbGlja2VkJykuY3NzKCd0b3AnLCAgZXZ0LmNsaWVudFkgLSA0MCArICdweCcpO1xuICAgICAgICAkKCcucG9pLS1jbGlja2VkJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cbiAgICAgICAgJCgnLnBvaV9zaWRlIGgyJykuaHRtbCh0aGlzLl9uYW1lICk7XG4gICAgICAgICQoJy5wb2lfc2lkZSAuZGVzY3JpcHRpb24nKS5odG1sKHRoaXMuX2Rlc2NyaXB0aW9uKTtcbiAgICAgICAgJCgnLnBvaV9zaWRlJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cbiAgICAgICAgJCgnLmludGVyZmFjZScpLmNzcygnd2lkdGgnLCAnODAlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlBvaS5vbk1vdXNlT3ZlckhhbmRsZXIoKSA6IGNhbGxiYWNrIHRvIHJ1biBpZiB0aGUgbW91c2UgaXMgb3ZlciBhIHBpY3RvXG4gICAgICogICAgICAtIGV2dDogZXZlbnQgaW5mb3JtYXRpb25zXG4gICAgICovXG4gICAgUkFORE8uUG9pLnByb3RvdHlwZS5vbk1vdXNlT3ZlckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICQoJy5wb2ktLWhvdmVyJykudGV4dCh0aGlzLl9uYW1lICsgJyAoJyArIHRoaXMuX2VsZXZhdGlvbiArICdtICknKTtcbiAgICAgICAgJCgnLnBvaS0taG92ZXInKS5jc3MoJ2xlZnQnLCBldnQuY2xpZW50WCAtIDIwICsgJ3B4Jyk7XG4gICAgICAgICQoJy5wb2ktLWhvdmVyJykuY3NzKCd0b3AnLCAgZXZ0LmNsaWVudFkgLSA0MCArICdweCcpO1xuICAgICAgICAkKCcucG9pLS1ob3ZlcicpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICAgICQoJyNjYW52YXNfcmVuZGVyZXInKVswXS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfTtcblxuICAgIC8qKiBTdGF0aWNcbiAgICAgKiBSQU5ETy5Qb2kucnVuTW91c2VMaXN0ZW5lcigpIDogU3RhdGljIGZ1bmN0aW9uIHdoaWNoIHJ1biBhbGwgbW91c2VcbiAgICAgKiAgbGlzdGVuZXJzIGxpbmtlZCB0byBQT0lzLCB3ZSBnaXZlIGl0IGEgUE9JJ3MgYXJyYXkgYW5kIGl0IGFkZHNcbiAgICAgKiAgbW91c2UgZXZlbnRzIG92ZXIgYWxsIGl0cyBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICAgICAgLSBjYW52YXMgOiBjYW52YXMgd2hlcmUgdGhlIHNjZW5lIGlzXG4gICAgICogICAgICAtIHBvaXMgOiBhcnJheSBvZiBQT0lzXG4gICAgICogICAgICAtIHNjZW5lIDogc2NlbmVcbiAgICAgKi9cbiAgICBSQU5ETy5Qb2kucnVuTW91c2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChjYW52YXMsIHBvaXMsIHNjZW5lKSB7XG4gICAgICAgIHZhciBjbGlja2VkSUQ7XG5cbiAgICAgICAgLy8gTW91c2VEb3duIEV2ZW50IDogY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG92ZXIgYSBQaWN0byB3aGVuIE1vdXNlIGxlZnQgY2xpY2sgaXMgZG93blxuICAgICAgICBSQU5ETy5FdmVudHMuYWRkRXZlbnQod2luZG93LCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICB2YXIgcGlja1Jlc3VsdCA9IHNjZW5lLnBpY2sgKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgICAgICB2YXIgcGlja2VkTWVzaCA9IHBpY2tSZXN1bHQucGlja2VkTWVzaDtcblxuICAgICAgICAgICAgJCgnLnBvaS0taG92ZXInKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgJCgnLnBvaS0tY2xpY2tlZCcpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICBjbGlja2VkSUQgPSAtMTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWNrIGhpdHMgYSBwaWN0b2dyYW0sIHdlIGRpc3BsYXkgaW5mb3JtYXRpb25zIG9mIFBPSVxuICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuaGl0ICYmIHBpY2tlZE1lc2gubmFtZSA9PSBcIlBPSSAtIFBhbmVsXCIpIHtcbiAgICAgICAgICAgICAgICBwb2lzW3BpY2tlZE1lc2guaWRdLm9uTW91c2VEb3duSGFuZGxlcihldnQpO1xuICAgICAgICAgICAgICAgIGNsaWNrZWRJRCA9IHBpY2tlZE1lc2guaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1vdXNlTW92ZSBFdmVudCA6IGFsd2F5cyBjaGVjayBpZiBtb3VzZSBpcyBvdmVyIGEgUGljdG9cbiAgICAgICAgUkFORE8uRXZlbnRzLmFkZEV2ZW50KHdpbmRvdywgXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIHBpY2tSZXN1bHQgPSBzY2VuZS5waWNrIChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgICAgICAgICAgdmFyIHBpY2tlZE1lc2ggPSBwaWNrUmVzdWx0LnBpY2tlZE1lc2g7XG5cbiAgICAgICAgICAgICQoJy5wb2ktLWhvdmVyJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICQoJyNjYW52YXNfcmVuZGVyZXInKVswXS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgICAgIC8vIGlmIG1vdXNlIGlzIG92ZXIgYSBwaWN0b2dyYW0sIHdlIGRpc3BsYXkgaW5mb3JtYXRpb25zIG9mIFBPSVxuICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuaGl0ICYmIHBpY2tlZE1lc2gubmFtZSA9PSBcIlBPSSAtIFBhbmVsXCJcbiAgICAgICAgICAgICAgICAmJiBjbGlja2VkSUQgIT0gcGlja2VkTWVzaC5pZCkge1xuICAgICAgICAgICAgICAgIHBvaXNbcGlja2VkTWVzaC5pZF0ub25Nb3VzZU92ZXJIYW5kbGVyKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENsb3NlIGJ1dHRvbiBldmVudHMgb2YgdGhlIFBPSSBzaWRlXG4gICAgICAgICQoXCIuY2xvc2VfYnRuXCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoXCIucG9pX3NpZGVcIikuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICQoJy5pbnRlcmZhY2UnKS5jc3MoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQoXCIuY2xvc2VfYnRuXCIpLm1vdXNlb3ZlciggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB0aGlzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSk7XG4gICAgICAgICQoXCIuY2xvc2VfYnRuXCIpLm1vdXNlb3V0KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgfSk7XG4gICAgfTtcblxufTsiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uU2NlbmUuanNcbiAqXG4gKiBTY2VuZSBjbGFzcyA6XG4gKiAgUGVybWl0ZXMgdGhlIGNyZWF0aW9uIGFuZCBtYW5pcHVsYXRpb24gb2YgYSBzY2VuZSAzRCBjb250YWluaW5nIChvciBub3QpIDpcbiAqICAgICAgLSBhIERpZ2l0YWwgRWxldmF0aW9uIE1vZGVsXG4gKiAgICAgIC0gYSBUcmVrIHdoaWNoIGlzIGRyYXBlZCBvdmVyIHRoZSBERU1cbiAqICAgICAgLSBhIHNldCBvZiBQb2ludHMgT2YgSW50ZXJlc3QgZHJhcGVkIG92ZXIgdGhlIERFTSB0b29cbiAqICAgICAgLSBhIHNldCBvZiBDYW1lcmFzXG4gKiAgICAgIC0gYSBzZXQgb2YgbGlnaHRzXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgLyogQ29uc3RydWN0b3IgKi9cbiAgICBSQU5ETy5TY2VuZSA9IGZ1bmN0aW9uIChjYW52YXMsIGNhbWVyYUlEKSB7XG4gICAgICAgIC8vIEF0dHJpYnV0ZXMgZGVjbGFyYXRpb25cbiAgICAgICAgdGhpcy5fY2FudmFzICAgID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9jYW1lcmFJRCAgPSBjYW1lcmFJRDtcblxuICAgICAgICB0aGlzLl9lbmdpbmUgICAgPSBudWxsO1xuICAgICAgICB0aGlzLl9zY2VuZSAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbUNvbnRhaW5lciAgICA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHRzICAgICA9IHt9O1xuICAgICAgICB0aGlzLmRlbSAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRyZWsgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaXMgICAgICAgPSBbXTtcblxuICAgICAgICB0aGlzLl9kZW1fZGF0YSAgPSB7fTtcbiAgICAgICAgdGhpcy5fdHJla19kYXRhID0gW107XG4gICAgICAgIHRoaXMuX3BvaXNfZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9vZmZzZXRzICAgPSB7fTtcbiAgICB9O1xuXG5cbiAgICAvKiBNZXRob2RzICovXG4gICAgUkFORE8uU2NlbmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFJBTkRPLlNUQVJUX1RJTUUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBuZXcgQkFCWUxPTi5FbmdpbmUodGhpcy5fY2FudmFzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fc2NlbmUgID0gbmV3IEJBQllMT04uU2NlbmUodGhpcy5fZW5naW5lKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBSQU5ETy5FdmVudHMuYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhhdC5fZW5naW5lLnJlc2l6ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zY2VuZS5jbGVhckNvbG9yID0gbmV3IEJBQllMT04uQ29sb3I0KDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLl9zY2VuZS5jb2xsaXNpb25zRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2J1aWxkTGlnaHRzKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5TY2VuZS5wcm9jZXNzKCkgOiBsYXVuY2ggdGhlIGJ1aWxkaW5nIHByb2Nlc3Mgb2YgdGhlIHNjZW5lXG4gICAgICogIEl0IGRpc3BsYXlzIDpcbiAgICAgKiAgICAgICAgICAtIFRlcnJhaW5cbiAgICAgKiAgICAgICAgICAtIFRyZWtcbiAgICAgKiAgICAgICAgICAtIFBPSXNcbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICQuZ2V0SlNPTihSQU5ETy5TRVRUSU5HUy5ERU1fVVJMKVxuICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuX3BhcnNlRGVtSnNvbihkYXRhKTtcbiAgICAgICAgICAgIHRoYXQuX2J1aWxkQ2FtZXJhcygpO1xuICAgICAgICAgfSlcbiAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmdldEpTT04oUkFORE8uU0VUVElOR1MuUFJPRklMRV9VUkwpO1xuICAgICAgICAgfSlcbiAgICAgICAgIC5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGF0Ll9wYXJzZVRyZWtKc29uKGRhdGEpO1xuICAgICAgICAgfSlcbiAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmdldEpTT04oUkFORE8uU0VUVElOR1MuUE9JX1VSTCk7XG4gICAgICAgICB9KVxuICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuX3BhcnNlUG9pSnNvbihkYXRhKTtcblxuICAgICAgICAgfSlcbiAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJ1biByZW5kZXJsb29wXG4gICAgICAgICAgICB0aGF0Ll9lbmdpbmUucnVuUmVuZGVyTG9vcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2VuZS5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUaWxlZCBERU0gbWVzaCBidWlsZGluZ1xuICAgICAgICAgICAgdGhhdC5kZW0gPSBuZXcgUkFORE8uRGVtKFxuICAgICAgICAgICAgICAgIHRoYXQuX2RlbV9kYXRhLmV4dGVudCxcbiAgICAgICAgICAgICAgICB0aGF0Ll9kZW1fZGF0YS5hbHRpdHVkZXMsXG4gICAgICAgICAgICAgICAgdGhhdC5fb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2VuZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gVHJlayBidWlsZGluZ1xuICAgICAgICAgICAgdGhhdC50cmVrID0gbmV3IFJBTkRPLlRyZWsgIChcbiAgICAgICAgICAgICAgICB0aGF0Ll90cmVrX2RhdGEsXG4gICAgICAgICAgICAgICAgdGhhdC5fb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2VuZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gUE9JcyBidWlsZGluZ1xuICAgICAgICAgICAgdmFyIGlkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGl0IGluIHRoYXQuX3BvaXNfZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChSQU5ETy5VdGlscy5pc0luRXh0ZW50KHRoYXQuX3BvaXNfZGF0YVtpdF0uY29vcmRpbmF0ZXMsIHRoYXQuZGVtLmdldFJlYWxFeHRlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wb2lzLnB1c2gobmV3IFJBTkRPLlBvaShcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkKyssXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9wb2lzX2RhdGFbaXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3NjZW5lXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJBTkRPLlBvaS5ydW5Nb3VzZUxpc3RlbmVyKHRoYXQuX2NhbnZhcywgdGhhdC5wb2lzLCB0aGF0Ll9zY2VuZSk7XG5cbiAgICAgICAgICAgIC8vIFRvIGV4ZWN1dGUgd2hlbiBzY2VuZSBpcyByZWFkeVxuICAgICAgICAgICAgdGhhdC5fc2NlbmUuZXhlY3V0ZVdoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fZXhlY3V0ZVdoZW5SZWFkeSAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfSlcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uU2NlbmUuX2J1aWxkQ2FtZXJhcygpIDogYnVpbGRzIGNhbWVyYXMgb2YgdGhlIHNjZW5lXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIGNhbWVyYSBJRCBpcyBub3QgYXZhaWxhYmxlLCBpdCBpcyBjaGFuZ2VkIHRvIFwiZGVtb19jYW1lcmFcIlxuICAgICAqL1xuICAgIFJBTkRPLlNjZW5lLnByb3RvdHlwZS5fYnVpbGRDYW1lcmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJhbWV0ZXJzIGZvciB0aGUgQ2FtZXJhIENvbnRhaW5lclxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgJ2RlbUNlbnRlcicgOiB0aGlzLl9kZW1fZGF0YS5jZW50ZXIsXG4gICAgICAgICAgICAnb2Zmc2V0cycgICA6IHRoaXMuX29mZnNldHMsXG4gICAgICAgICAgICAnZGVtRXh0ZW50JyA6IHRoaXMuX2RlbV9kYXRhLmV4dGVudCxcbiAgICAgICAgICAgICdkZW1BbHRpdHVkZXMnOiB0aGlzLl9kZW1fZGF0YS5hbHRpdHVkZXMsXG4gICAgICAgICAgICAnc3dpdGNoRW5hYmxlZCcgOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmNhbUNvbnRhaW5lciA9IG5ldyBSQU5ETy5DYW1lcmFDb250YWluZXIodGhpcy5fY2FudmFzLCB0aGlzLl9zY2VuZSwgcGFyYW1zKTtcblxuICAgICAgICAvLyBDb250cm9sIGNhbWVyYSBJRCBlbnRlcmVkIChleGFtaW5lX2NhbWVyYSBieSBkZWZhdWx0KS4uLlxuICAgICAgICBpZiAoISQuaW5BcnJheSh0aGlzLl9jYW1lcmFJRCwgUkFORE8uQ2FtZXJhSURzKSlcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYUlEID0gXCJleGFtaW5lXCI7XG5cbiAgICAgICAgLy8gLi4uYW5kIHNldCBpdCBhcyBhY3RpdmVcbiAgICAgICAgdGhpcy5jYW1Db250YWluZXIuc2V0QWN0aXZlQ2FtZXJhICh0aGlzLl9jYW1lcmFJRCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9idWlsZExpZ2h0cygpIDogYnVpbGRzIHRoZSBkaWZmZXJlbnRzIGxpZ2h0cyBvZiB0aGUgc2NlbmVcbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX2J1aWxkTGlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NlbmUgPSB0aGlzLl9zY2VuZTtcblxuICAgICAgICAvLyBTdW5cbiAgICAgICAgdGhpcy5saWdodHMuc3VuID0gbGlnaHQgKFxuICAgICAgICAgICAgXCJTdW5cIiwgbmV3IEJBQllMT04uVmVjdG9yMygtNTAwLCAtMTAwMDAsIDApLCAxLjJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTaWRlIExpZ2h0IDFcbiAgICAgICAgdGhpcy5saWdodHMuc2lkZUxpZ2h0MSA9IGxpZ2h0IChcbiAgICAgICAgICAgIFwiU2lkZSBMaWdodCAxXCIsIG5ldyBCQUJZTE9OLlZlY3RvcjMoMSwgMCwgMC44KSwgMS4yXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU2lkZSBMaWdodCAyXG4gICAgICAgIHRoaXMubGlnaHRzLnNpZGVMaWdodDIgPSBsaWdodCAoXG4gICAgICAgICAgICBcIlNpZGUgTGlnaHQgMlwiLCBuZXcgQkFCWUxPTi5WZWN0b3IzKC0xLCAwLCAtMC44KSwgMS4yXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbGlnaHQoKSA6IHJldHVybiBhIGRpcmVjdGlvbmFsIGxpZ2h0XG4gICAgICAgIGZ1bmN0aW9uIGxpZ2h0IChuYW1lLCBkaXJlY3Rpb24sIGludGVuc2l0eSkge1xuICAgICAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IEJBQllMT04uRGlyZWN0aW9uYWxMaWdodChcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBzY2VuZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpZ2h0LmludGVuc2l0eSA9IGludGVuc2l0eTtcbiAgICAgICAgICAgIGxpZ2h0LnNwZWN1bGFyID0gbmV3IEJBQllMT04uQ29sb3I0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9leGVjdXRlV2hlblJlYWR5KCkgOiBmdW5jdGlvbiB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBzY2VuZVxuICAgICAqICBpcyByZWFkeSwgaW4gb3RoZXIgd29yZHMsIHdoZW4gdGhlIHNjZW5lIGhhdmUgYnVpbHQgYWxsIGl0cyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBSQU5ETy5TY2VuZS5wcm90b3R5cGUuX2V4ZWN1dGVXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2NlbmUgaXMgcmVhZHkgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICB2YXIgdHJlayAgICAgICAgICAgID0gdGhpcy50cmVrO1xuICAgICAgICB2YXIgY2FtQ29udGFpbmVyICAgID0gdGhpcy5jYW1Db250YWluZXI7XG4gICAgICAgIHZhciBsaWdodHMgICAgICAgICAgPSB0aGlzLmxpZ2h0cztcblxuICAgICAgICAvLyBJbml0IHNpZGVsaWdodHMgZXhjbHVkZWQgbWVzaGVzIGFycmF5cyB3aXRoIHRoZSB0aWxlc1xuICAgICAgICBsaWdodHMuc2lkZUxpZ2h0MS5leGNsdWRlZE1lc2hlcyA9IHRoaXMuZGVtLmdyb3VuZC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBsaWdodHMuc2lkZUxpZ2h0Mi5leGNsdWRlZE1lc2hlcyA9IHRoaXMuZGVtLmdyb3VuZC5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIC8vIEFwcGx5IERFTSB0ZXh0dXJlc1xuICAgICAgICB0aGlzLmRlbS5hcHBseVRleHR1cmVzKCk7XG5cbiAgICAgICAgLy8gRHJhcGUgdGhlIHRyZWsgd2l0aCBhbiBvbkNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgIHRyZWsuZHJhcGUodGhpcy5kZW0uZ3JvdW5kLCBvbkRyYXBlQ29tcGxldGUpO1xuXG4gICAgICAgIC8vIERyYXBlIFBPSVNcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGhpcy5wb2lzKSB7XG4gICAgICAgICAgICB0aGlzLnBvaXNbaXRdLmRyYXBlKHRoaXMuZGVtLmdyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkRyYXBlQ29tcGxldGUgKCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlcyB0cmVrIHZlcnRpY2VzIC4uLlxuICAgICAgICAgICAgdHJlay51cGRhdGVWZXJ0aWNlcygpO1xuXG4gICAgICAgICAgICAvLyAuLi4gdG8gZ2l2ZSB0aGVtIHRvIHRoZSBjYW1lcmEgY29udGFpbmVyIChmb3IgaGlrZXIgY2FtZXJhKVxuICAgICAgICAgICAgY2FtQ29udGFpbmVyLnNldEFuaW1hdGlvblBhdGgodHJlay5fdmVydGljZXMpO1xuXG4gICAgICAgICAgICAvLyBNZXJnZXMgdGhlIHRyZWsgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VzXG4gICAgICAgICAgICB0cmVrLm1lcmdlKCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBleGNsdWRlZCBtZXNoZXMgb2YgbGlnaHRzXG4gICAgICAgICAgICAkLm1lcmdlKGxpZ2h0cy5zaWRlTGlnaHQxLmV4Y2x1ZGVkTWVzaGVzLCB0cmVrLm1lcmdlZFRyZWtzKTtcbiAgICAgICAgICAgICQubWVyZ2UobGlnaHRzLnNpZGVMaWdodDIuZXhjbHVkZWRNZXNoZXMsIHRyZWsubWVyZ2VkVHJla3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9wYXJzZURlbUpzb24oKSA6IHBhcnNlIGRhdGEgZnJvbSB0aGUgREVNIGpzb25cbiAgICAgKiAgICAgIC0gZGF0YSA6IGRhdGEgZnJvbSBERU0ganNvblxuICAgICAqL1xuICAgIFJBTkRPLlNjZW5lLnByb3RvdHlwZS5fcGFyc2VEZW1Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gQ29udmVyc2lvbnNcbiAgICAgICAgdmFyIG1fY2VudGVyID0gUkFORE8uVXRpbHMudG9NZXRlcnMoZGF0YS5jZW50ZXIpO1xuICAgICAgICB2YXIgbV9leHRlbnQgPSBSQU5ETy5VdGlscy5nZXRNZXRlcnNFeHRlbnQgKGRhdGEuZXh0ZW50KTtcblxuICAgICAgICAvLyBSZWNvcmQgREVNIGV4dGVudFxuICAgICAgICB0aGlzLl9kZW1fZGF0YS5leHRlbnQgPSBtX2V4dGVudDtcbiAgICAgICAgdGhpcy5fZGVtX2RhdGEuZXh0ZW50LnkubWluICo9IFJBTkRPLlNFVFRJTkdTLkFMVElUVURFU19aX1NDQUxFO1xuICAgICAgICB0aGlzLl9kZW1fZGF0YS5leHRlbnQueS5tYXggKj0gUkFORE8uU0VUVElOR1MuQUxUSVRVREVTX1pfU0NBTEU7XG5cbiAgICAgICAgLy8gUmVjb3JkIERFTSBhbHRpdHVkZXMgc2NhbGVkXG4gICAgICAgIHRoaXMuX2RlbV9kYXRhLmFsdGl0dWRlcyA9IFJBTkRPLlV0aWxzLnNjYWxlQXJyYXkyKFxuICAgICAgICAgICAgZGF0YS5hbHRpdHVkZXMsXG4gICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5BTFRJVFVERVNfWl9TQ0FMRVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlY29yZCBERU0gY2VudGVyXG4gICAgICAgIHRoaXMuX2RlbV9kYXRhLmNlbnRlciA9IHtcbiAgICAgICAgICAgICd4JyA6IG1fY2VudGVyLngsXG4gICAgICAgICAgICAneScgOiAodGhpcy5fZGVtX2RhdGEuZXh0ZW50LnkubWluICsgdGhpcy5fZGVtX2RhdGEuZXh0ZW50LnkubWF4KSAvIDIsXG4gICAgICAgICAgICAneicgOiBtX2NlbnRlci55XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVjb3JkcyBzY2VuZSBvZmZzZXRzXG4gICAgICAgIHRoaXMuX29mZnNldHMueCA9IC1tX2NlbnRlci54O1xuICAgICAgICB0aGlzLl9vZmZzZXRzLnogPSAtbV9jZW50ZXIueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uU2NlbmUuX3BhcnNlVHJla0pzb24oKSA6IHBhcnNlIGRhdGEgZnJvbSB0aGUgVHJlayBwcm9maWxlIGpzb25cbiAgICAgKiAgICAgIC0gZGF0YSA6IGRhdGEgZnJvbSBUcmVrIHByb2ZpbGUganNvblxuICAgICAqL1xuICAgIFJBTkRPLlNjZW5lLnByb3RvdHlwZS5fcGFyc2VUcmVrSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaXQgaW4gZGF0YS5wcm9maWxlKXtcbiAgICAgICAgICAgIHZhciB0bXAgPSB7XG4gICAgICAgICAgICAgICAgJ2xuZycgOiBkYXRhLnByb2ZpbGVbaXRdWzJdWzBdLFxuICAgICAgICAgICAgICAgICdsYXQnIDogZGF0YS5wcm9maWxlW2l0XVsyXVsxXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gV2UgdGFrZSBvbmx5IHggYW5kIHogdmFsdWVzIChub3QgdGhlIGFsdGl0dWRlcylcbiAgICAgICAgICAgIHRtcCA9IFJBTkRPLlV0aWxzLnRvTWV0ZXJzKHRtcCk7XG5cbiAgICAgICAgICAgIC8vIHRvTWV0ZXJzKCkgZ2l2ZSB4LXktY29vcmRpbmF0ZXMgYW5kIGJhYnlsb24gdGFrZSB4LXotY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHRtcC56ID0gdG1wLnk7XG4gICAgICAgICAgICBkZWxldGUgdG1wW1wieVwiXTtcblxuICAgICAgICAgICAgLy8gUmVjb3JkXG4gICAgICAgICAgICB0aGlzLl90cmVrX2RhdGEucHVzaCh0bXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlNjZW5lLl9wYXJzZVBvaUpzb24oKSA6IHBhcnNlIGRhdGEgZnJvbSB0aGUgUE9JIGpzb25cbiAgICAgKiAgICAgIC0gZGF0YSA6IGRhdGEgZnJvbSBQT0kganNvblxuICAgICAqL1xuICAgIFJBTkRPLlNjZW5lLnByb3RvdHlwZS5fcGFyc2VQb2lKc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gZGF0YS5mZWF0dXJlcykge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBkYXRhLmZlYXR1cmVzW2l0XTtcblxuICAgICAgICAgICAgLy8gQ29udmVyc2lvblxuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gUkFORE8uVXRpbHMudG9NZXRlcnMoe1xuICAgICAgICAgICAgICAgICdsbmcnIDogZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgICAgICAgICAnbGF0JyA6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZWNvcmRcbiAgICAgICAgICAgIHRoaXMuX3BvaXNfZGF0YS5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2Nvb3JkaW5hdGVzJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3gnOiBjb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgICAgICAneic6IGNvb3JkaW5hdGVzLnlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0aWVzJyA6IGZlYXR1cmUucHJvcGVydGllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufTsiLCIvLyBSYW5kby5TZXR0aW5ncy5qc1xuLy8gR2VuZXJhbCBzZXR0aW5nc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFJBTkRPLCBCQUJZTE9OKSB7XG4gICAgdmFyIFJBTkRPID0gUkFORE8gfHwge307XG4gICAgUkFORE8uU0VUVElOR1MgPSB7fTtcblxuICAgIC8vIExpbmtzXG4gICAgUkFORE8uU0VUVElOR1MuSU1BR0VTX0ZPTERFUiA9ICcnO1xuICAgIFJBTkRPLlNFVFRJTkdTLkRFTV9VUkwgPSAnJzsgLy8gVXJsIG9mIHRoZSBERU0ganNvblxuICAgIFJBTkRPLlNFVFRJTkdTLlBST0ZJTEVfVVJMID0gJyc7IC8vIFVybCBvZiB0aGUgdHJlaydzIHByb2ZpbGUganNvblxuICAgIFJBTkRPLlNFVFRJTkdTLlRJTEVfVEVYX1VSTCA9ICcnOyAvLyBVcmwgb2YgYSB0aWxlIHRleHR1cmVcbiAgICBSQU5ETy5TRVRUSU5HUy5TSURFX1RFWF9VUkwgPSAnJzsgLy8gVXJsIG9mIHRoZSBzaWRlIHRleHR1cmVcbiAgICBSQU5ETy5TRVRUSU5HUy5USUxFX1RFWF9VUkxfU1VCRE9NQUlOUyA9IFsnYScsICdiJywgJ2MnXTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICAvLyBDYW1lcmFcbiAgICBSQU5ETy5TRVRUSU5HUy5DQU1fT0ZGU0VUID0gMjAwOyAvLyBDYW1lcmEncyBhbHRpdHVkZSBvZmZzZXQgKGluIG1ldGVycylcblxuICAgIFJBTkRPLlNFVFRJTkdTLkhDQU1fRk9MTE9XX1NQRUVEID0gMTU7IC8vIEhpa2VyQ2FtZXJhIHNwZWVkIHdoZW4gaXQgZm9sbG93cyB0cmVrXG4gICAgUkFORE8uU0VUVElOR1MuSENBTV9SRVRVUk5fU1BFRUQgPSAxNTAwOyAvLyBIaWtlckNhbWVyYSBzcGVlZCB3aGVuIGl0IGNvbWVzIGJhY2sgdG8gZGVmYXVsdFxuICAgIFJBTkRPLlNFVFRJTkdTLkNBTV9TUEVFRF9GID0gNTA7ICAvLyBDYW1lcmEgc3BlZWQgaW4gRmx5aW5nIG1vZGUoZnJvbSAwIHRvIGluZmluaXR5ICEpXG4gICAgUkFORE8uU0VUVElOR1MuQ09MTElTSU9OU19PRkZTRVQgPSAxNTA7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgLy8gR2VvbWV0cnlcbiAgICBSQU5ETy5TRVRUSU5HUy5BTFRJVFVERVNfWl9TQ0FMRSA9IDEuNDtcbiAgICBSQU5ETy5TRVRUSU5HUy5MSU1JVF9WRVJUX0JZX01FU0ggPSA2NTUzNjtcbiAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX1NQSF9URVNTRUwgPSA1O1xuICAgIFJBTkRPLlNFVFRJTkdTLlRSRUtfQ1lMX1RFU1NFTCA9IDIwO1xuICAgIFJBTkRPLlNFVFRJTkdTLk1JTl9USElDS05FU1MgPSAyMDA7IC8vIE1pbmltdW0gdGhpY2tuZXNzIG9mIHRoZSBERU1cbiAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX09GRlNFVCA9IDI7IC8vIFRyZWsncyBhbHRpdHVkZSBvZmZzZXQgKGluIG1ldGVycylcblxuICAgIFJBTkRPLlNFVFRJTkdTLlRSRUtfQ09MT1IgPSBuZXcgQkFCWUxPTi5Db2xvcjMoMC4xLCAwLjYsIDAuMik7IC8vIFRyZWsgY29sb3IgKGdyZWVuKVxuICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IEJBQllMT04uQ29sb3IzKDAuMSwwLjYsMC4yKTsgLy8gZ3JlZW5cbiAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBCQUJZTE9OLkNvbG9yMygwLjgsMCwwLjIpOyAvLyBmdXNjaGlhXG4gICAgICAgICAgICAgICAgICAgICAvLyBuZXcgQkFCWUxPTi5Db2xvcjMoMC45LDAuNSwwKTsgLy8gb3JhbmdlXG5cbiAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX1dJRFRIID0gMTA7IC8vIFRyZWsgd2lkdGggKGluIG1ldGVycylcblxuICAgIFJBTkRPLlNFVFRJTkdTLlRJTEVfWk9PTSA9IDE3O1xuICAgIFJBTkRPLlNFVFRJTkdTLlRJTEVfTlVNQkVSX0xJTUlUID0gMjAwO1xuXG4gICAgUkFORE8uU0VUVElOR1MuUE9JX09GRlNFVCA9IDEwMDtcbiAgICBSQU5ETy5TRVRUSU5HUy5QT0lfRk9STTEgPSB7XG4gICAgICAgIG9iamVjdE5hbWUgOiAnJyAsXG4gICAgICAgIGZvbGRlcjogJ2JsZW5kZXIvJyxcbiAgICAgICAgZmlsZU5hbWU6ICdwb2kuYmFieWxvbidcbiAgICB9O1xuICAgIFJBTkRPLlNFVFRJTkdTLlBPSV9TSVpFID0gMjA7XG4gICAgUkFORE8uU0VUVElOR1MuUE9JX0xBQkVMX1NDQUxFID0gMTtcbiAgICBSQU5ETy5TRVRUSU5HUy5QSUNUT19TSVpFID0gMTAwO1xuICAgIFJBTkRPLlNFVFRJTkdTLlBJQ1RPX1BSRUZJWCA9ICcnO1xuXG4gICAgUkFORE8uU0VUVElOR1MuTk9fREVTQ1JJUFRJT05fTUVTU0FHRSA9ICc8cD5QYXMgZGUgZGVzY3JpcHRpb24gbGnDqWUgw6AgY2UgcG9pbnQgZFxcJ2ludMOpcsOqdC48L3A+JztcbiAgICBSQU5ETy5TRVRUSU5HUy5DQU1FUkFfTUVTU0FHRVMgPSB7XG4gICAgICAgICdiaXJkJyA6ICdPbiBwZXV0IHN1cnZvbGVyIGxlIHRlcnJhaW4gdGVsIHVuIG9pc2VhdSwgdG91cm5lciBsYSB0w6p0ZSwgbW9udGVyLCBkZXNjZW5kcmUgZXQgc2UgZMOpcGxhY2VyICEnLFxuICAgICAgICAnZXhhbWluZScgOiAnT24gcGV1dCBleGFtaW5lciBsZSB0ZXJyYWluIGVuIGxlIHRvdXJuYW50IGRhbnMgdG91cyBsZXMgc2Vucy4nLFxuICAgICAgICAnaGlrZXInIDogJ0ljaSBvbiBlc3QgZGFucyBsYSBwZWF1IGRcXCd1biByYW5kb25uZXVyLCBvbiBzdWl0IHNhbnMgZWZmb3J0IGxcXCdhdmFuY2VtZW50IGRlIGxcXCdpdGluw6lyYWlyZSwgZW4gcHJvZml0YW50IGRlIGxhIHZ1ZS4nXG4gICAgfTtcblxuICAgIHJldHVybiBSQU5ETztcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUmFuZG8uVGlsZUNvbnRhaW5lci5qc1xuICpcbiAqIFRpbGVDb250YWluZXIgY2xhc3MgOlxuICogIENvbnRhaW5zIGFsbCBkYXRhIGZvciB0aGUgYnVpbGQgb2YgYSB0aWxlZCBEaWdpdGFsIEVsZXZhdGlvbiBNb2RlbFxuICpcbiAqIEBhdXRob3I6IEPDqWxpYW4gR0FSQ0lBXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSQU5ETykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgLyogQ29uc3RydWN0b3IgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyID0gZnVuY3Rpb24gKGV4dGVudCwgYWx0aXR1ZGVzLCBvZmZzZXRzKSB7XG4gICAgICAgIC8qIEF0dHJpYnV0ZXMgZGVjbGFyYXRpb24gKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gXy5jbG9uZShleHRlbnQpO1xuICAgICAgICB0aGlzLl9hbHRpdHVkZXMgPSBfLmNsb25lKGFsdGl0dWRlcyk7XG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBfLmNsb25lKG9mZnNldHMpO1xuICAgICAgICB0aGlzLl9ncmlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGlsZXMgPSB7fTtcblxuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfTtcblxuICAgIC8qIE1ldGhvZHMgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVUaWxlcygpO1xuICAgICAgICB0aGlzLl9qb2luVGlsZXMoKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZVNpemUoKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZVV2cygpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5UaWxlQ29udGFpbmVyLl9nZW5lcmF0ZVRpbGVzKCkgOiBnZW5lcmF0ZXMgYW4gYXJyYXkgb2YgdGlsZXMgd2hpY2ggYXJlIGpzIG9iamVjdHNcbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5fZ2VuZXJhdGVUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHpvb20gPSBSQU5ETy5TRVRUSU5HUy5USUxFX1pPT007XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuICAgICAgICB2YXIgY29sLCByb3c7XG5cbiAgICAgICAgdGhpcy5fZ3JpZCA9IFJBTkRPLlV0aWxzLmNyZWF0ZUVsZXZhdGlvbkdyaWQoXG4gICAgICAgICAgICB0aGlzLl9leHRlbnQueC5taW4sXG4gICAgICAgICAgICB0aGlzLl9leHRlbnQueC5tYXgsXG4gICAgICAgICAgICB0aGlzLl9leHRlbnQuei5taW4sXG4gICAgICAgICAgICB0aGlzLl9leHRlbnQuei5tYXgsXG4gICAgICAgICAgICB0aGlzLl9hbHRpdHVkZXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG5cbiAgICAgICAgdmFyIGN1cnJfaW5kZXgsICBwcmV2X2luZGV4ICA9IG51bGwsXG4gICAgICAgICAgICBjdXJyX3BvaW50LCAgcHJldl9wb2ludCAgPSBudWxsLFxuICAgICAgICAgICAgY3Vycl90aWxlX24sIHByZXZfdGlsZV9uID0gbnVsbCxcbiAgICAgICAgICAgIGxpbmVfdG1wID0gW10sXG4gICAgICAgICAgICBuZXdfbGluZSA9IHRydWU7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRlIGdyaWQgaW4gdGlsZXNcbiAgICAgICAgZm9yIChyb3cgaW4gZ3JpZCkge1xuICAgICAgICAgICAgZm9yIChjb2wgaW4gZ3JpZFtyb3ddKSB7XG4gICAgICAgICAgICAgICAgY3Vycl9wb2ludCA9IGdyaWRbcm93XVtjb2xdO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgdGlsZSBudW1iZXIgY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgIGN1cnJfdGlsZV9uID0gUkFORE8uVXRpbHMubWV0ZXJzMm51bShjdXJyX3BvaW50LngsIGN1cnJfcG9pbnQueiwgem9vbSk7XG4gICAgICAgICAgICAgICAgY3Vycl9pbmRleCA9IFwiXCIgKyB6b29tICsgXCIvXCIgKyBjdXJyX3RpbGVfbi54dGlsZSArIFwiL1wiICsgY3Vycl90aWxlX24ueXRpbGU7XG5cbiAgICAgICAgICAgICAgICAvLyB0aWxlc1tcInoveC95XCJdIGV4aXN0cyBvciBub3RcbiAgICAgICAgICAgICAgICB0aWxlc1tjdXJyX2luZGV4XSA9IHRpbGVzW2N1cnJfaW5kZXhdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aWxlc1tjdXJyX2luZGV4XSkubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgICAgICAgICB0aWxlc1tjdXJyX2luZGV4XS5ncmlkID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzW2N1cnJfaW5kZXhdLmNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgejogem9vbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGN1cnJfdGlsZV9uLnh0aWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY3Vycl90aWxlX24ueXRpbGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIGluZGV4IGV4aXN0cyBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAoIHByZXZfaW5kZXggIT0gbnVsbCAmJiBwcmV2X2luZGV4ICE9IGN1cnJfaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVzW3ByZXZfaW5kZXhdLmdyaWQucHVzaChsaW5lX3RtcCk7IC8vIHB1c2ggdGhlIGxpbmUgaW50byBwcmV2aW91cyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIGxpbmVfdG1wID0gW107IC8vIHJlc2V0IHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZV90bXAucHVzaChfLmNsb25lKGN1cnJfcG9pbnQpKTtcblxuICAgICAgICAgICAgICAgIHByZXZfaW5kZXggPSBjdXJyX2luZGV4O1xuICAgICAgICAgICAgICAgIHByZXZfcG9pbnQgPSBjdXJyX3BvaW50O1xuICAgICAgICAgICAgICAgIG5ld19saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldl90aWxlX24gPSBjdXJyX3RpbGVfbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld19saW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1c2ggdGhlIGxhc3QgbGluZSBvZiB0aGUgbGFzdCB0aWxlXG4gICAgICAgIHRpbGVzW2N1cnJfaW5kZXhdLmdyaWQucHVzaChsaW5lX3RtcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlRpbGVDb250YWluZXIuX2pvaW5UaWxlcygpIDogam9pbnMgdGlsZXMgZGF0YVxuICAgICAqL1xuICAgIFJBTkRPLlRpbGVDb250YWluZXIucHJvdG90eXBlLl9qb2luVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuICAgICAgICB2YXIgY29sLCByb3csIGl0O1xuXG4gICAgICAgIC8vIEpvaW5zIEVhc3QgYW5kIFdlc3Qgc2lkZXMgb2YgdGlsZXNcbiAgICAgICAgZm9yIChpdCBpbiB0aWxlcykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfdGlsZSA9IHRpbGVzW2l0XTtcbiAgICAgICAgICAgIHZhciBuZXh0X2Nvb3JkID0ge1xuICAgICAgICAgICAgICAgIHo6IGN1cnJlbnRfdGlsZS5jb29yZGluYXRlcy56LFxuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRfdGlsZS5jb29yZGluYXRlcy54ICsgMSxcbiAgICAgICAgICAgICAgICB5OiBjdXJyZW50X3RpbGUuY29vcmRpbmF0ZXMueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBuZXh0X2luZGV4ID0gXCJcIiAgKyBuZXh0X2Nvb3JkLnogKyBcIi9cIiArIG5leHRfY29vcmQueCArIFwiL1wiICsgbmV4dF9jb29yZC55ICsgXCJcIjtcblxuICAgICAgICAgICAgLy8gaWYgbmV4dCB0aWxlIGV4aXN0XG4gICAgICAgICAgICBpZiAodGlsZXNbbmV4dF9pbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudF9ncmlkID0gY3VycmVudF90aWxlLmdyaWQ7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfZ3JpZCA9IHRpbGVzW25leHRfaW5kZXhdLmdyaWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCByb3cgaW4gdGhlIGN1cnJlbnQgdGlsZSBncmlkXG4gICAgICAgICAgICAgICAgZm9yIChyb3cgaW4gY3VycmVudF9ncmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2X3BvaW50ID0gY3VycmVudF9ncmlkW3Jvd11bY3VycmVudF9ncmlkW3Jvd10ubGVuZ3RoLTFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dF9wb2ludCA9IG5leHRfZ3JpZFtyb3ddWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gUkFORE8uVXRpbHMubWlkZGxlKHByZXZfcG9pbnQsIG5leHRfcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X2dyaWRbcm93XS5wdXNoKG1pZCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRfZ3JpZFtyb3ddLnNwbGljZSgwLCAwLCBfLmNsb25lKG1pZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEpvaW5zIE5vcnRoIGFuZCBTb3V0aCBzaWRlcyBvZiB0aWxlc1xuICAgICAgICBmb3IgKGl0IGluIHRpbGVzKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudF90aWxlID0gXy5jbG9uZSh0aWxlc1tpdF0pO1xuICAgICAgICAgICAgdmFyIG5leHRfY29vcmQgPSB7XG4gICAgICAgICAgICAgICAgejogY3VycmVudF90aWxlLmNvb3JkaW5hdGVzLnosXG4gICAgICAgICAgICAgICAgeDogY3VycmVudF90aWxlLmNvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICAgICAgeTogY3VycmVudF90aWxlLmNvb3JkaW5hdGVzLnkgKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG5leHRfaW5kZXggPSBcIlwiICArIG5leHRfY29vcmQueiArIFwiL1wiICsgbmV4dF9jb29yZC54ICsgXCIvXCIgKyBuZXh0X2Nvb3JkLnkgKyBcIlwiO1xuXG4gICAgICAgICAgICBpZiAodGlsZXNbbmV4dF9pbmRleF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90aWxlID0gdGlsZXNbbmV4dF9pbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBsaW5lIG9mIGN1cnJlbnQgdGlsZVxuICAgICAgICAgICAgICAgIHZhciBwcmV2X2xpbmUgPSBfLmNsb25lKGN1cnJlbnRfdGlsZS5ncmlkWzBdKTtcblxuICAgICAgICAgICAgICAgIC8vIExhc3QgbGluZSBvZiBuZXh0IHRpbGVcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF9saW5lID0gXy5jbG9uZShuZXh0X3RpbGUuZ3JpZFtuZXh0X3RpbGUuZ3JpZC5sZW5ndGgtMV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IGxpbmUgcGxhY2VkIG9uIHRoZSBtaWRkbGUgb2YgdGhlIGJvdGggcHJldmlvdXNcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHR3byB2YXJpYWJsZXMgdG8gc3RvcmUgdGhpcyBsaW5lXG4gICAgICAgICAgICAgICAgdmFyIG1lZF9saW5lMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtZWRfbGluZTIgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJldl9saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWQgPSBSQU5ETy5VdGlscy5taWRkbGUocHJldl9saW5lW2ldLCBuZXh0X2xpbmVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBtZWRfbGluZTEucHVzaChfLmNsb25lKG1pZCkpO1xuICAgICAgICAgICAgICAgICAgICBtZWRfbGluZTIucHVzaChfLmNsb25lKG1pZCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBcIm1lZGlhbiBsaW5lXCIgZ28gdG8gdGhlIHNvdXRoIG9mIGN1cnJlbnQgdGlsZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfdGlsZS5ncmlkLnNwbGljZSgwLCAwLCBtZWRfbGluZTEpO1xuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgdG8gdGhlIG5vcnRoIG9mIG5leHQgdGlsZVxuICAgICAgICAgICAgICAgIG5leHRfdGlsZS5ncmlkLnB1c2gobWVkX2xpbmUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5UaWxlQ29udGFpbmVyLl9jb21wdXRlU2l6ZSgpIDogY29tcHV0ZXMgaGVpZ2h0IGFuZCB3aWR0aCBvZiBlYWNoIHRpbGUgYW5kIGFkZCBpdCB0byB0aGUgdGlsZXMgZGF0YSBjb250YWluZXJcbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5fY29tcHV0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB0aWxlcykge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aWxlc1tpdF07XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRpbGUuZ3JpZDtcbiAgICAgICAgICAgIHZhciBuID0gZ3JpZC5sZW5ndGgtMTtcbiAgICAgICAgICAgIHZhciBtID0gZ3JpZFswXS5sZW5ndGgtMTtcbiAgICAgICAgICAgIHRpbGUuc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogZ3JpZFswXVttXS54IC0gZ3JpZFswXVswXS54LFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiBncmlkW25dWzBdLnogLSBncmlkWzBdWzBdLnpcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci5fY29tcHV0ZVV2cygpIDogIGNvbXB1dGVzIHV2IHZhbHVlcyBvZiBlYWNoIHRpbGUgYW5kIGFkZCBpdCB0byB0aGUgdGlsZXMgZGF0YSBjb250YWluZXJcbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5fY29tcHV0ZVV2cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fdGlsZXM7XG5cbiAgICAgICAgdmFyIG1heF93aWR0aCA9IF8ubWF4KHRpbGVzLCBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGUuc2l6ZS53aWR0aDtcbiAgICAgICAgfSkuc2l6ZS53aWR0aDtcblxuICAgICAgICB2YXIgbWF4X2hlaWdodCA9IF8ubWF4KHRpbGVzLCBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGUuc2l6ZS5oZWlnaHQ7XG4gICAgICAgIH0pLnNpemUuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudEluVGlsZXNDb29yZGluYXRlcygpO1xuXG4gICAgICAgIC8vIEZpbGwgdGhlIHV2IGRhdGEgb2YgdGlsZXNcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGlsZXNbaXRdO1xuICAgICAgICAgICAgdGlsZS51diA9IHt9O1xuXG4gICAgICAgICAgICAvLyBGaWxsIHUgYXJyYXlcbiAgICAgICAgICAgIGlmICh0aWxlLmNvb3JkaW5hdGVzLnggPT0gZXh0ZW50LngubWluKSB7IC8vIEVhc3QgdGlsZXNcbiAgICAgICAgICAgICAgICB0aWxlLnV2LnUgPSB1VmFsdWVzKHRpbGUsIG1heF93aWR0aCwgXCJlYXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlsZS5jb29yZGluYXRlcy54ID09IGV4dGVudC54Lm1heCkgeyAvLyBXZXN0IHRpbGVzXG4gICAgICAgICAgICAgICAgdGlsZS51di51ID0gdVZhbHVlcyh0aWxlLCBtYXhfd2lkdGgsIFwid2VzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBJbnRlcmlvciB0aWxlc1xuICAgICAgICAgICAgICAgIHRpbGUudXYudSA9IHVWYWx1ZXModGlsZSwgdGlsZS5zaXplLndpZHRoLCBcIm5vcm1hbFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB2IGFycmF5XG4gICAgICAgICAgICBpZiAodGlsZS5jb29yZGluYXRlcy55ID09IGV4dGVudC55Lm1pbikgeyAvLyBOb3J0aCB0aWxlc1xuICAgICAgICAgICAgICAgIHRpbGUudXYudiA9IHZWYWx1ZXModGlsZSwgbWF4X2hlaWdodCwgXCJub3J0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbGUuY29vcmRpbmF0ZXMueSA9PSBleHRlbnQueS5tYXgpIHsgLy8gU291dGggdGlsZXNcbiAgICAgICAgICAgICAgICB0aWxlLnV2LnYgPSB2VmFsdWVzKHRpbGUsIG1heF9oZWlnaHQsIFwic291dGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gSW50ZXJpb3IgdGlsZXNcbiAgICAgICAgICAgICAgICB0aWxlLnV2LnYgPSB2VmFsdWVzKHRpbGUsIHRpbGUuc2l6ZS5oZWlnaHQsIFwibm9ybWFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdVZhbHVlcyh0aWxlLCB3aWR0aCwgc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChzdHJpbmcpID09PSAndW5kZWZpbmVkJykgc3RyaW5nID0gXCJub3JtYWxcIjtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIHN0cmluZyA9PSBcImVhc3RcIiB8fCBzdHJpbmcgPT0gXCJub3JtYWxcIiB8fCBzdHJpbmcgPT0gXCJ3ZXN0XCIsXG4gICAgICAgICAgICAgICAgXCJ1VmFsdWVzKCkgZnVuY3Rpb24gdW5jb3JyZWN0bHkgdXNlZFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoc3RyaW5nID09IFwid2VzdFwiKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gXCJub3JtYWxcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSB0aWxlLmdyaWRbMF0ubGVuZ3RoLTE7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlYXN0XCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHVbbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSBuLTE7IGNvbCA+PSAwOyBjb2wtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNydF94ID0gdGlsZS5ncmlkWzBdW2NvbF0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBueHRfeCA9IHRpbGUuZ3JpZFswXVtjb2wrMV0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbY29sXSA9IHVbY29sKzFdIC0gKE1hdGguYWJzKG54dF94IC0gY3J0X3gpL3dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHVbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAxOyBjb2wgPD0gbjsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcnRfeCA9IHRpbGUuZ3JpZFswXVtjb2xdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJ2X3ggPSB0aWxlLmdyaWRbMF1bY29sLTFdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB1W2NvbF0gPSB1W2NvbC0xXSArIChNYXRoLmFicyhwcnZfeCAtIGNydF94KS93aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuICAgICAgICBmdW5jdGlvbiB2VmFsdWVzKHRpbGUsIGhlaWdodCwgc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChzdHJpbmcpID09PSAndW5kZWZpbmVkJykgc3RyaW5nID0gXCJub3JtYWxcIjtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICAgICAgICAgIHN0cmluZyA9PSBcInNvdXRoXCIgfHwgc3RyaW5nID09IFwibm9ybWFsXCIgfHwgc3RyaW5nID09IFwibm9ydGhcIixcbiAgICAgICAgICAgICAgICBcInVWYWx1ZXMoKSBmdW5jdGlvbiB1bmNvcnJlY3RseSB1c2VkXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT0gXCJub3J0aFwiKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gXCJub3JtYWxcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSB0aWxlLmdyaWQubGVuZ3RoLTE7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzb3V0aFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2W21dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gbS0xOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcnRfeiA9IHRpbGUuZ3JpZFtyb3ddWzBdLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnh0X3ogPSB0aWxlLmdyaWRbcm93KzFdWzBdLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB2W3Jvd10gPSB2W3JvdysxXSAtIChNYXRoLmFicyhueHRfeiAtIGNydF96KS9oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHYucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9ybWFsXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAxOyByb3cgPD0gbTsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcnRfeiA9IHRpbGUuZ3JpZFtyb3ddWzBdLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJ2X3ogPSB0aWxlLmdyaWRbcm93LTFdWzBdLno7XG4gICAgICAgICAgICAgICAgICAgICAgICB2W3Jvd10gPSB2W3Jvdy0xXSArIChNYXRoLmFicyhwcnZfeiAtIGNydF96KS9oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHYucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci50cmFuc2xhdGUoKSA6IHRyYW5zbGF0ZSB0aGUgVGlsZXMgZGF0YSBvZiB0aGUgb2Zmc2V0cyBhdHRyaWJ1dGUgb3Igb2ZcbiAgICAgKiB0aGUgb2Zmc2V0cyBnaXZlbiBpbiBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgUkFORE8uVGlsZUNvbnRhaW5lci5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSwgZHopIHtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fdGlsZXM7XG4gICAgICAgIHZhciBvZmZzZXRzID0ge307XG4gICAgICAgIHZhciBjb2wsIHJvdztcblxuICAgICAgICBpZiAodHlwZW9mKGR4KSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICBvZmZzZXRzLnggPSB0aGlzLl9vZmZzZXRzLng7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIG9mZnNldHMueCA9IGR4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihkeSkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgb2Zmc2V0cy55ID0gdGhpcy5fb2Zmc2V0cy55O1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXRzLnkgPSBkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoZHopID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIG9mZnNldHMueiA9IHRoaXMuX29mZnNldHMuejtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0cy56ID0gZHo7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2xhdGVzIHRoZSB0aWxlcyBwb3NpdGlvbnMgb2YgdGhlIG9mZnNldHNcbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gdGlsZXNbaXRdLmdyaWQ7XG4gICAgICAgICAgICBmb3IgKHJvdyBpbiBncmlkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb2wgaW4gZ3JpZFtyb3ddKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRbcm93XVtjb2xdLnggKz0gb2Zmc2V0cy54O1xuICAgICAgICAgICAgICAgICAgICBncmlkW3Jvd11bY29sXS56ICs9IG9mZnNldHMuejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci5nZXRGcmFtZSgpIDogZ2V0IHRoZSBmcmFtZSBvZiB0aGUgREVNIGNvbXBvc2VkIGJ5IDQgbGluZXNcbiAgICAgKiAgZWFzdCwgd2VzdCwgbm9ydGgsIGFuZCBzb3V0aC5cbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5nZXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyYW1lID0ge307XG4gICAgICAgIGZyYW1lLmVhc3QgID0gW107XG4gICAgICAgIGZyYW1lLndlc3QgID0gW107XG4gICAgICAgIGZyYW1lLm5vcnRoID0gW107XG4gICAgICAgIGZyYW1lLnNvdXRoID0gW107XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3RpbGVzO1xuICAgICAgICB2YXIgY29sLCByb3c7XG5cbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50SW5UaWxlc0Nvb3JkaW5hdGVzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGlsZXNbaXRdO1xuICAgICAgICAgICAgaWYgKCB0aWxlLmNvb3JkaW5hdGVzLnggPT0gZXh0ZW50LngubWF4ICkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0X2NvbCA9IHRpbGUuZ3JpZFswXS5sZW5ndGggLTE7XG4gICAgICAgICAgICAgICAgZm9yIChyb3cgaW4gdGlsZS5ncmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmVhc3QucHVzaCh0aWxlLmdyaWRbcm93XVtsYXN0X2NvbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdGlsZS5jb29yZGluYXRlcy54ID09IGV4dGVudC54Lm1pbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RfY29sID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHJvdyBpbiB0aWxlLmdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUud2VzdC5wdXNoKHRpbGUuZ3JpZFtyb3ddW2ZpcnN0X2NvbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdGlsZS5jb29yZGluYXRlcy55ID09IGV4dGVudC55Lm1pbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdF9yb3cgPSB0aWxlLmdyaWQubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgZm9yIChjb2wgaW4gdGlsZS5ncmlkW2xhc3Rfcm93XSl7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNvdXRoLnB1c2godGlsZS5ncmlkW2xhc3Rfcm93XVtjb2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRpbGUuY29vcmRpbmF0ZXMueSA9PSBleHRlbnQueS5tYXggKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0X3JvdyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb2wgaW4gdGlsZS5ncmlkW2ZpcnN0X3Jvd10pe1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5ub3J0aC5wdXNoKHRpbGUuZ3JpZFtmaXJzdF9yb3ddW2NvbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVGlsZUNvbnRhaW5lci5nZXRFeHRlbnRJblRpbGVzQ29vcmRpbmF0ZXMoKSA6IGdldCB0aGUgeCBhbmQgeSBleHRlbnQgaW4gdGlsZSdzXG4gICAgICogY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBSQU5ETy5UaWxlQ29udGFpbmVyLnByb3RvdHlwZS5nZXRFeHRlbnRJblRpbGVzQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aWxlRXh0ZW50ID0ge307XG4gICAgICAgIHRpbGVFeHRlbnQueCA9IHt9O1xuICAgICAgICB0aWxlRXh0ZW50LnkgPSB7fTtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fdGlsZXM7XG5cbiAgICAgICAgLy8gWCBleHRlbnRcbiAgICAgICAgdGlsZUV4dGVudC54Lm1pbiA9IF8ubWluKHRpbGVzLCBmdW5jdGlvbiAodGlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbGUuY29vcmRpbmF0ZXMueDtcbiAgICAgICAgfSkuY29vcmRpbmF0ZXMueDtcblxuICAgICAgICB0aWxlRXh0ZW50LngubWF4ID0gXy5tYXgodGlsZXMsIGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlsZS5jb29yZGluYXRlcy54O1xuICAgICAgICB9KS5jb29yZGluYXRlcy54O1xuXG4gICAgICAgIC8vIFkgZXh0ZW50XG4gICAgICAgIHRpbGVFeHRlbnQueS5taW4gPSBfLm1pbih0aWxlcywgZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWxlLmNvb3JkaW5hdGVzLnk7XG4gICAgICAgIH0pLmNvb3JkaW5hdGVzLnk7XG4gICAgICAgIHRpbGVFeHRlbnQueS5tYXggPSBfLm1heCh0aWxlcywgZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWxlLmNvb3JkaW5hdGVzLnk7XG4gICAgICAgIH0pLmNvb3JkaW5hdGVzLnk7XG5cbiAgICAgICAgcmV0dXJuIHRpbGVFeHRlbnQ7XG4gICAgfTtcbn07IiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFJhbmRvLlRyZWsuanNcbiAqXG4gKiBUcmVrIGNsYXNzIDpcbiAqICBQZXJtaXRlcyB0aGUgYnVpbGQgb2YgYSBUcmVrIGluIDNEXG4gKlxuICogQGF1dGhvcjogQ8OpbGlhbiBHQVJDSUFcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUkFORE8sIEJBQllMT04pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUkFORE8gPSBSQU5ETyB8fCB7fTtcblxuICAgIC8qIENvbnN0cnVjdG9yICovXG4gICAgUkFORE8uVHJlayA9IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXRzLCBzY2VuZSkge1xuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHRoaXMuX3ByZXBhcmVWZXJ0aWNlcyhkYXRhLCBvZmZzZXRzKTtcbiAgICAgICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcblxuICAgICAgICB0aGlzLnNwaGVyZXMgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5jeWxpbmRlcnMgICA9IG51bGw7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZFRyZWtzID0gW107XG5cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfTtcblxuICAgIC8qIE1ldGhvZHMgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IEJBQllMT04uU3RhbmRhcmRNYXRlcmlhbChcIlRyZWsgTWF0ZXJpYWxcIiwgdGhpcy5fc2NlbmUpXG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gUkFORE8uU0VUVElOR1MuVFJFS19DT0xPUjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5lbWlzc2l2ZUNvbG9yID0gUkFORE8uU0VUVElOR1MuVFJFS19DT0xPUjtcblxuICAgICAgICB0aGlzLmJ1aWxkVHJlayAoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay5fcHJlcGFyZVZlcnRpY2VzKCkgOiB0cmFuc2xhdGUgdGhlIFRyZWsgZGF0YSBvZiB0aGUgb2Zmc2V0cyBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIHJldHVybiB0aGUgYXJyYXkgb2YgdmVydGljZXNcbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5fcHJlcGFyZVZlcnRpY2VzID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldHMpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gXy5tYXAoZGF0YSwgXy5jbG9uZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaXQgaW4gdmVydGljZXMpe1xuICAgICAgICAgICAgdmVydGljZXNbaXRdLnggKz0gb2Zmc2V0cy54O1xuICAgICAgICAgICAgdmVydGljZXNbaXRdLnkgPSAwO1xuICAgICAgICAgICAgdmVydGljZXNbaXRdLnogKz0gb2Zmc2V0cy56O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay5idWlsZFRyZWsoKSA6IGJ1aWxkcyB0aGUgdHJlayB3aXRoIHNwaGVyZXMgYW5kIGN5bGluZGVyc1xuICAgICAqL1xuICAgIFJBTkRPLlRyZWsucHJvdG90eXBlLmJ1aWxkVHJlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVHJlayBidWlsZGluZyAuLi5cbiAgICAgICAgY29uc29sZS5sb2coXCJUcmVrIGJ1aWxkaW5nLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgICAgICB2YXIgdmVydGljZXMgICAgPSB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIHNjZW5lICAgICAgID0gdGhpcy5fc2NlbmU7XG4gICAgICAgIHZhciBtYXRlcmlhbCAgICA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICAgIHZhciBzcGhlcmVzICAgICA9IG5ldyBCQUJZTE9OLk1lc2goXCJUUkVLIC0gU3BoZXJlc1wiLCBzY2VuZSk7XG4gICAgICAgIHZhciBjeWxpbmRlcnMgICA9IG5ldyBCQUJZTE9OLk1lc2goXCJUUkVLIC0gQ3lsaW5kZXJzXCIsIHNjZW5lKTtcbiAgICAgICAgdmFyIG5fc3BoID0gMCwgbl9jeWwgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNwaGVyZSh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIG5fc3BoKys7XG4gICAgICAgICAgICB2YXIgc3BoZXJlID0gQkFCWUxPTi5NZXNoLkNyZWF0ZVNwaGVyZShcbiAgICAgICAgICAgICAgICBcIlNwaGVyZSBcIiArIG5fc3BoLFxuICAgICAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTLlRSRUtfU1BIX1RFU1NFTCxcbiAgICAgICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX1dJRFRILFxuICAgICAgICAgICAgICAgIHNjZW5lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzcGhlcmUucG9zaXRpb24gID0gdmVydGV4O1xuICAgICAgICAgICAgc3BoZXJlLm1hdGVyaWFsICA9IG1hdGVyaWFsO1xuICAgICAgICAgICAgc3BoZXJlLnBhcmVudCAgICA9IHNwaGVyZXM7XG4gICAgICAgICAgICBzcGhlcmUuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ3lsaW5kZXIodmVydGV4QSwgdmVydGV4Qikge1xuICAgICAgICAgICAgbl9jeWwrKztcbiAgICAgICAgICAgIHZhciBjeWxfaGVpZ2h0ID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKHZlcnRleEEsIHZlcnRleEIpO1xuICAgICAgICAgICAgdmFyIGN5bGluZGVyID0gQkFCWUxPTi5NZXNoLkNyZWF0ZUN5bGluZGVyKFxuICAgICAgICAgICAgICAgIFwiQ3lsaW5kZXIgXCIgKyBuX2N5bCxcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIFJBTkRPLlNFVFRJTkdTLlRSRUtfV0lEVEgsXG4gICAgICAgICAgICAgICAgUkFORE8uU0VUVElOR1MuVFJFS19XSURUSCxcbiAgICAgICAgICAgICAgICBSQU5ETy5TRVRUSU5HUy5UUkVLX0NZTF9URVNTRUwsXG4gICAgICAgICAgICAgICAgc2NlbmVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGN5bGluZGVyLm1hdGVyaWFsICAgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIGN5bGluZGVyLnBhcmVudCAgICAgPSBjeWxpbmRlcnM7XG4gICAgICAgICAgICBjeWxpbmRlci5pc1Zpc2libGUgID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByZXYsIGN1cnIgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpdCBpbiB2ZXJ0aWNlcyl7XG4gICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgIHZhciBjdXJyID0gbmV3IEJBQllMT04uVmVjdG9yMyhcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpdF0ueCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpdF0ueSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpdF0uelxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY3JlYXRlU3BoZXJlKGN1cnIpO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVDeWxpbmRlcihwcmV2LCBjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyZWsgYnVpbHQgIVxuICAgICAgICBjb25zb2xlLmxvZyhcIlRyZWsgYnVpbHQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcblxuICAgICAgICB0aGlzLnNwaGVyZXMgPSBzcGhlcmVzO1xuICAgICAgICB0aGlzLmN5bGluZGVycyA9IGN5bGluZGVycztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay5kcmFwZSgpIDogZHJhcGUgdGhlIHRyZWsgb3ZlciB0aGUgZ3JvdW5kXG4gICAgICogICAgICAtIGdyb3VuZCA6IE1lc2ggaW4gd2hpY2ggd2UgZHJhcGUgc3BoZXJlc1xuICAgICAqICAgICAgLSBvbkNvbXBsZXRlIDogY2FsbGJhY2sgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIFJBTkRPLlRyZWsucHJvdG90eXBlLlxuICAgICAqL1xuICAgIFJBTkRPLlRyZWsucHJvdG90eXBlLmRyYXBlID0gZnVuY3Rpb24gKGdyb3VuZCwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgc3BoZXJlcyAgICAgPSB0aGlzLnNwaGVyZXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIGN5bGluZGVycyAgID0gdGhpcy5jeWxpbmRlcnMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIHRyZWtfbGVuZ3RoID0gc3BoZXJlcy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCAgICAgICA9IDA7XG4gICAgICAgIHZhciBjaHVuayAgICAgICA9IDEwMDsgLy8gQnkgY2h1bmtzIG9mIDEwMCBwb2ludHNcbiAgICAgICAgdmFyIHRoYXQgICAgICAgID0gdGhpcztcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlRyZWsgYWRqdXN0bWVudHMgLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgICAgICBkcmFwZUNodW5rKCk7XG5cbiAgICAgICAgLy8gU3RlcCAxIDogZHJhcGUgdGhlIHNwaGVyZXMgb3ZlciB0aGUgZ3JvdW5kXG4gICAgICAgIGZ1bmN0aW9uIGRyYXBlQ2h1bmsgKCkge1xuICAgICAgICAgICAgdmFyIGNudCA9IGNodW5rO1xuICAgICAgICAgICAgd2hpbGUgKGNudC0tICYmIGluZGV4IDwgdHJla19sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBSQU5ETy5VdGlscy5kcmFwZVBvaW50KHNwaGVyZXNbaW5kZXhdLnBvc2l0aW9uLCBncm91bmQsIFJBTkRPLlNFVFRJTkdTLlRSRUtfT0ZGU0VUKTtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgdHJla19sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZHJhcGVDaHVuaywgMSk7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiBkcmFwaW5nIHdlIHBsYWNlIGN5bGluZGVyc1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocGxhY2VDeWxpbmRlcnMsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN0ZXAgMiA6IFBsYWNlIGFsbCBjeWxpbmRlcnMgYmV0d2VlbiBlYWNoIHBhaXJzIG9mIHNwaGVyZXNcbiAgICAgICAgZnVuY3Rpb24gcGxhY2VDeWxpbmRlcnMgKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVrX2xlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICAgICAgICBSQU5ETy5VdGlscy5wbGFjZUN5bGluZGVyKFxuICAgICAgICAgICAgICAgICAgICBjeWxpbmRlcnNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZXNbaV0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZXNbaSsxXS5wb3NpdGlvblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVHJlayBhZGp1c3RlZCAhIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5UcmVrLm1lcmdlKCkgOiBtZXJnZSBhbGwgZWxlbWVudHMgKHNwaGVyZXMgYW5kIGN5bGluZGVycykgb2YgdGhlIFRyZWtcbiAgICAgKi9cbiAgICBSQU5ETy5UcmVrLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmVrIG1lcmdpbmcgLi4uIFwiICsgKERhdGUubm93KCkgLSBSQU5ETy5TVEFSVF9USU1FKSApO1xuICAgICAgICB2YXIgc2NlbmUgICAgICAgPSB0aGlzLl9zY2VuZTtcbiAgICAgICAgdmFyIHNwaGVyZXMgICAgID0gdGhpcy5zcGhlcmVzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBjeWxpbmRlcnMgICA9IHRoaXMuY3lsaW5kZXJzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBtZXNoZXMgICAgICA9IHNwaGVyZXMuY29uY2F0KGN5bGluZGVycyk7XG4gICAgICAgIHZhciBsaW1pdCAgICAgICA9IFJBTkRPLlNFVFRJTkdTLkxJTUlUX1ZFUlRfQllfTUVTSDtcblxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgbk1lcmdlZFRyZWsgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudCArPSBtZXNoZXNbaV0uZ2V0VG90YWxWZXJ0aWNlcygpO1xuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgYnVmZmVyIGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgIGlmIChjb3VudCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgbWVzaGVzW2ldLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG1lc2hlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBidWZmZXIgd2lsbCBub3QgYmUgYWNjZXB0YWJsZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8uLi4gc28gd2UgbWVyZ2UgYWxsIG1lc2hlcyBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkVHJlayA9IG5ldyBCQUJZTE9OLk1lc2goXG4gICAgICAgICAgICAgICAgICAgIFwiTWVyZ2VkIFRyZWsgXCIgKyBuTWVyZ2VkVHJlaysrLCBzY2VuZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgUkFORE8uVXRpbHMubWVyZ2VNZXNoZXMobWVyZ2VkVHJlaywgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBtZXJnZWRUcmVrLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlZFRyZWtzLnB1c2gobWVyZ2VkVHJlayk7XG4gICAgICAgICAgICAgICAgLy8gLi4uIGFuZCB3ZSBwdXNoIHRoZSBjdXJyZW50IG1lc2ggaW4gYSBuZXcgZW1wdHkgYnVmZmVyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2gobWVzaGVzW2ldKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IG1lc2hlc1tpXS5nZXRUb3RhbFZlcnRpY2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgY291bnQgbmV2ZXIgcmVhY2hlZCB0aGUgbGltaXRcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgdmFyIG1lcmdlZFRyZWsgPSBuZXcgQkFCWUxPTi5NZXNoKFxuICAgICAgICAgICAgICAgIFwiTWVyZ2VkIFRyZWsgXCIgKyBuTWVyZ2VkVHJlaysrLCBzY2VuZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJBTkRPLlV0aWxzLm1lcmdlTWVzaGVzKG1lcmdlZFRyZWssIGJ1ZmZlcik7XG4gICAgICAgICAgICBtZXJnZWRUcmVrLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuICAgICAgICAgICAgdGhpcy5tZXJnZWRUcmVrcy5wdXNoKG1lcmdlZFRyZWspO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJlayBtZXJnZWQgISBcIiArIChEYXRlLm5vdygpIC0gUkFORE8uU1RBUlRfVElNRSkgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVHJlay51cGRhdGVWZXJ0aWNlcygpIDogdXBkYXRlIHRoaXMuX3ZlcnRpY2VzIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIFJBTkRPLlRyZWsucHJvdG90eXBlLnVwZGF0ZVZlcnRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmVydGljZXMgICAgPSB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIHNwaGVyZXMgICAgID0gdGhpcy5zcGhlcmVzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHZlcnRpY2VzLmxlbmd0aCA9PSBzcGhlcmVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGl0IGluIHNwaGVyZXMpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS54ID0gc3BoZXJlc1tpdF0ucG9zaXRpb24ueDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS55ID0gc3BoZXJlc1tpdF0ucG9zaXRpb24ueTtcbiAgICAgICAgICAgIHZlcnRpY2VzW2l0XS56ID0gc3BoZXJlc1tpdF0ucG9zaXRpb24uejtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5UcmVrLmdldFRvdGFsVmVydGljZXMoKSA6IGdldCB0aGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSB0cmVrLlxuICAgICAqL1xuICAgIFJBTkRPLlRyZWsucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGhlcmVzQXJyYXkgICAgPSB0aGlzLnNwaGVyZXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIGN5bGluZGVyc0FycmF5ICA9IHRoaXMuY3lsaW5kZXJzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBtZXNoZXMgICAgICAgICAgPSBzcGhlcmVzQXJyYXkuY29uY2F0KGN5bGluZGVyc0FycmF5KTtcblxuICAgICAgICB2YXIgdG90YWxWZXJ0aWNlcyA9IDA7XG4gICAgICAgIGZvciAodmFyIGl0IGluIG1lc2hlcykge1xuICAgICAgICAgICAgdG90YWxWZXJ0aWNlcyArPSBtZXNoZXNbaXRdLmdldFRvdGFsVmVydGljZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b3RhbFZlcnRpY2VzO1xuICAgIH07XG59OyIsIi8vIFJhbmRvLlV0aWxzLmpzXG4vLyBSYW5kbyB1dGlsaXRpZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihSQU5ETywgQkFCWUxPTikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBSQU5ETyA9IFJBTkRPIHx8IHt9O1xuXG4gICAgUkFORE8uVXRpbHMgPSB7fTtcblxuICAgIC8qKioqICAgIEJBQllMT04gZXh0ZW50cyAgICAgKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqICBjcmVhdGVHcm91bmRGcm9tRXh0ZW50KCk6IENyZWF0ZSBhIGdyb3VuZCBmcm9tIGFuIGV4dGVudCBvZiA0IHBvaW50c1xuICAgICAqICAgICAgLSBuYW1lIDogTmFtZSBvZiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSBBIDogbm9ydGh3ZXN0IHZlcnRleFxuICAgICAqICAgICAgLSBCIDogbm9ydGhlYXN0IHZlcnRleFxuICAgICAqICAgICAgLSBDIDogc291dGhlYXN0IHZlcnRleFxuICAgICAqICAgICAgLSBEIDogc291dGh3ZXN0IHZlcnRleFxuICAgICAqICAgICAgLSB3X3N1YmRpdmlzaW9ucyA6IE51bWJlciBvZiBXaWR0aCdzIHN1YmRpdmlzaW9ucyBpbiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSBoX3N1YmRpdmlzaW9ucyA6IE51bWJlciBvZiBIZWlnaHQncyBzdWJkaXZpc2lvbnMgaW4gdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gc2NlbmUgOiBTY2VuZSB3aGljaCBjb250YWlucyB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSB1cGRhdGFibGUgOlxuICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgUkFORE8uVXRpbHMuY3JlYXRlR3JvdW5kRnJvbUV4dGVudCA9IGZ1bmN0aW9uIChuYW1lLCBBLCBCLCBDLCBELCB3X3N1YmRpdmlzaW9ucywgaF9zdWJkaXZpc2lvbnMsIHNjZW5lLCB1cGRhdGFibGUpIHtcbiAgICAgICAgdmFyIGdyb3VuZCA9IG5ldyBCQUJZTE9OLkdyb3VuZE1lc2gobmFtZSwgc2NlbmUpO1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xuICAgICAgICB2YXIgcm93LCBjb2w7XG5cbiAgICAgICAgdmFyIGdyaWQgPSBSQU5ETy5VdGlscy5jcmVhdGVGbGF0R3JpZChBLCBCLCBDLCBELCB3X3N1YmRpdmlzaW9ucysgMSwgaF9zdWJkaXZpc2lvbnMrIDEpO1xuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8PSBoX3N1YmRpdmlzaW9uczsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDw9IHdfc3ViZGl2aXNpb25zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyaWRbcm93XVtjb2xdO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDEuMCwgMCk7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbi54LCAwLCBwb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG4gICAgICAgICAgICAgICAgdXZzLnB1c2goY29sIC8gd19zdWJkaXZpc2lvbnMsIDEuMCAtIHJvdyAvIGhfc3ViZGl2aXNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgaF9zdWJkaXZpc2lvbnM7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHdfc3ViZGl2aXNpb25zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG5cbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAxICsgKHJvdyArIDEpICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCwgcG9zaXRpb25zLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsIG5vcm1hbHMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuVVZLaW5kLCB1dnMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRJbmRpY2VzKGluZGljZXMpO1xuXG4gICAgICAgIHJldHVybiBncm91bmQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICBjcmVhdGVHcm91bmRGcm9tR3JpZCgpOiBDcmVhdGUgYSBncm91bmQgZnJvbSBhIGdyaWQgb2YgMkQgcG9pbnRzXG4gICAgICogICAgICAtIG5hbWUgOiBOYW1lIG9mIHRoZSBuZXcgR3JvdW5kXG4gICAgICogICAgICAtIGdyaWQgOiBncmlkIG9mIDJkIHBvaW50cyAoZWFjaCBwb2ludCBjb250YWlucyBhIHggYW5kIGEgeSlcbiAgICAgKiAgICAgIC0gc2NlbmUgOiBTY2VuZSB3aGljaCBjb250YWlucyB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSB1cGRhdGFibGUgOlxuICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgUkFORE8uVXRpbHMuY3JlYXRlR3JvdW5kRnJvbUdyaWQgPSBmdW5jdGlvbiAobmFtZSwgZ3JpZCwgc2NlbmUsIHVwZGF0YWJsZSkge1xuICAgICAgICB2YXIgZ3JvdW5kID0gbmV3IEJBQllMT04uR3JvdW5kTWVzaChuYW1lLCBzY2VuZSk7XG5cbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgICAgICB2YXIgdXZzID0gW107XG4gICAgICAgIHZhciByb3csIGNvbDtcblxuICAgICAgICB2YXIgaF9zdWJkaXZpc2lvbnMgPSBncmlkLmxlbmd0aC0xO1xuICAgICAgICB2YXIgd19zdWJkaXZpc2lvbnMgPSBncmlkWzBdLmxlbmd0aC0xO1xuXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDw9IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgd19zdWJkaXZpc2lvbnMgPSBncmlkW3Jvd10ubGVuZ3RoLTE7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8PSB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBncmlkW2hfc3ViZGl2aXNpb25zIC0gcm93XVtjb2xdO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBuZXcgQkFCWUxPTi5WZWN0b3IzKDAsIDEuMCwgMCk7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgICAgICAgICAgICBub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG4gICAgICAgICAgICAgICAgdXZzLnB1c2goY29sIC8gd19zdWJkaXZpc2lvbnMsIDEuMCAtIHJvdyAvIGhfc3ViZGl2aXNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgaF9zdWJkaXZpc2lvbnM7IHJvdysrKSB7XG4gICAgICAgICAgICB3X3N1YmRpdmlzaW9ucyA9IGdyaWRbcm93XS5sZW5ndGgtMTtcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgd19zdWJkaXZpc2lvbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyByb3cgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcblxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChjb2wgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIDEgKyAocm93ICsgMSkgKiAod19zdWJkaXZpc2lvbnMgKyAxKSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCBwb3NpdGlvbnMsIHVwZGF0YWJsZSk7XG4gICAgICAgIGdyb3VuZC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCwgbm9ybWFscywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIHV2cywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldEluZGljZXMoaW5kaWNlcyk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VuZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIGNyZWF0ZUdyb3VuZEZyb21WZXJ0aWNlcygpOiBDcmVhdGUgYSBncm91bmQgZnJvbSBhbiBhcnJheSBvZiB2ZXJ0aWNlc1xuICAgICAqICAgICAgLSBuYW1lIDogTmFtZSBvZiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSB2ZXJ0aWNlcyA6IEFycmF5IG9mIHZlcnRpY2VzIGluIEJBQllMT04uVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCBmb3JtYXRcbiAgICAgKiAgICAgIC0gd19zdWJkaXZpc2lvbnMgOiBOdW1iZXIgb2YgV2lkdGgncyBzdWJkaXZpc2lvbnMgaW4gdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gaF9zdWJkaXZpc2lvbnMgOiBOdW1iZXIgb2YgSGVpZ2h0J3Mgc3ViZGl2aXNpb25zIGluIHRoZSBuZXcgR3JvdW5kXG4gICAgICogICAgICAtIHNjZW5lIDogU2NlbmUgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBHcm91bmRcbiAgICAgKiAgICAgIC0gdXBkYXRhYmxlIDpcbiAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIFJBTkRPLlV0aWxzLmNyZWF0ZUdyb3VuZEZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKCBuYW1lLCB2ZXJ0aWNlcywgd19zdWJkaXZpc2lvbnMsIGhfc3ViZGl2aXNpb25zLCBzY2VuZSwgdXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHZlcnRpY2VzLmxlbmd0aCUzID09IDApO1xuICAgICAgICBjb25zb2xlLmFzc2VydCgodmVydGljZXMubGVuZ3RoLzMpID09IHdfc3ViZGl2aXNpb25zKmhfc3ViZGl2aXNpb25zLFxuICAgICAgICAodmVydGljZXMubGVuZ3RoLzMpICsgXCIhPVwiICsgd19zdWJkaXZpc2lvbnMgKyBcIipcIiArIGhfc3ViZGl2aXNpb25zKTtcblxuICAgICAgICB2YXIgZ3JvdW5kID0gQkFCWUxPTi5Hcm91bmRNZXNoKG5hbWUsIHNjZW5lKTtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciB1dnMgPSBbXTtcbiAgICAgICAgdmFyIHJvdywgY29sO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPD0gaF9zdWJkaXZpc2lvbnM7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8PSB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAxLjAsIDApO1xuXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2godmVydGljZXNbaV0sIHZlcnRpY2VzW2krMV0sIHZlcnRpY2VzW2krMl0pO1xuICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTtcbiAgICAgICAgICAgICAgICB1dnMucHVzaChjb2wgLyB3X3N1YmRpdmlzaW9ucywgMS4wIC0gcm93IC8gaF9zdWJkaXZpc2lvbnMpO1xuICAgICAgICAgICAgICAgIGkrPTM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIHBvc2l0aW9ucywgdXBkYXRhYmxlKTtcbiAgICAgICAgZ3JvdW5kLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLCBub3JtYWxzLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlVWS2luZCwgdXZzLCB1cGRhdGFibGUpO1xuICAgICAgICBncm91bmQuc2V0SW5kaWNlcyhpbmRpY2VzKTtcblxuICAgICAgICByZXR1cm4gZ3JvdW5kO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgY3JlYXRlU2lkZUZyb21MaW5lKCk6IENyZWF0ZSBhIHNpZGUgb2YgdGhlIERFTSBmcm9tIGEgbGluZSBvZiBwb2ludHMgKHRvcCBsaW5lKVxuICAgICAqICAgICAgLSBuYW1lIDogTmFtZSBvZiB0aGUgbmV3IEdyb3VuZFxuICAgICAqICAgICAgLSBsaW5lIDogQXJyYXkgb2YgcG9pbnRzIFt7eDogLHk6ICx6OiB9LCAuLi5dXG4gICAgICogICAgICAtIGJhc2UgOiBBbHRpdHVkZSBvZiB0aGUgYmFzZSBsaW5lXG4gICAgICogICAgICAtIHNjZW5lIDogU2NlbmUgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBzaWRlXG4gICAgICogICAgICAtIHVwZGF0YWJsZSA6XG4gICAgICpcbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5jcmVhdGVTaWRlRnJvbUxpbmUgPSBmdW5jdGlvbiAobmFtZSwgbGluZSwgYmFzZSwgc2NlbmUsIHVwZGF0YWJsZSkge1xuICAgICAgICB2YXIgc2lkZSA9IG5ldyBCQUJZTE9OLkdyb3VuZE1lc2gobmFtZSwgc2NlbmUpO1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICAgICAgdmFyIHV2cyA9IFtdO1xuICAgICAgICB2YXIgcm93LCBjb2w7XG5cbiAgICAgICAgdmFyIGhfc3ViZGl2aXNpb25zID0gMVxuICAgICAgICB2YXIgd19zdWJkaXZpc2lvbnMgPSBsaW5lLmxlbmd0aC0xO1xuXG4gICAgICAgIC8vIFBvc2l0aW9ucywgbm9ybWFscywgYW5kIHV2c1xuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8PSBoX3N1YmRpdmlzaW9uczsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDw9IHdfc3ViZGl2aXNpb25zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGxpbmVbY29sXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbmV3IEJBQllMT04uVmVjdG9yMygwLCAxLjAsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uLngsIGJhc2UsIHBvc2l0aW9uLnopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTtcbiAgICAgICAgICAgICAgICB1dnMucHVzaChjb2wgLyB3X3N1YmRpdmlzaW9ucywgMS4wIC0gcm93LzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5kaWNlc1xuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IGhfc3ViZGl2aXNpb25zOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB3X3N1YmRpdmlzaW9uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIHJvdyAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGNvbCArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgMSArIChyb3cgKyAxKSAqICh3X3N1YmRpdmlzaW9ucyArIDEpKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goY29sICsgcm93ICogKHdfc3ViZGl2aXNpb25zICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2lkZS5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLCBwb3NpdGlvbnMsIHVwZGF0YWJsZSk7XG4gICAgICAgIHNpZGUuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsIG5vcm1hbHMsIHVwZGF0YWJsZSk7XG4gICAgICAgIHNpZGUuc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlVWS2luZCwgdXZzLCB1cGRhdGFibGUpO1xuICAgICAgICBzaWRlLnNldEluZGljZXMoaW5kaWNlcyk7XG5cbiAgICAgICAgcmV0dXJuIHNpZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHBsYWNlQ3lsaW5kZXIoKVxuICAgICAqICAgICAgLSBjeWxpbmRlciAoQkFCWUxPTi5NZXNoKTogQkFCWUxPTiBDeWxpbmRlciBvYmplY3RcbiAgICAgKiAgICAgIC0gQSAoQkFCWUxPTi5WZWN0b3IzKTogICAgIEZpcnN0IFBvaW50XG4gICAgICogICAgICAtIEIgKEJBQllMT04uVmVjdG9yMyk6ICAgICBTZWNvbmQgUG9pbnRcbiAgICAgKlxuICAgICAqIFBsYWNlIHRoZSBjeWxpbmRlciBiZXR3ZWVuIGJvdGggcG9pbnRzXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgUkFORE8uVXRpbHMucGxhY2VDeWxpbmRlciA9IGZ1bmN0aW9uIChjeWxpbmRlciwgQSwgQikge1xuICAgICAgICAvLyBJbml0aWFsIHBvc2l0aW9uIGF0IHRoZSBjZW50ZXIgb2YgdGhlIEFCIHZlY3RvclxuICAgICAgICBjeWxpbmRlci5wb3NpdGlvbiA9IG5ldyBCQUJZTE9OLlZlY3RvcjMoXG4gICAgICAgICAgICAoQS54K0IueCkvMixcbiAgICAgICAgICAgIChBLnkrQi55KS8yLFxuICAgICAgICAgICAgKEEueitCLnopLzJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGp1c3Qgc2NhbGUgb2YgY3lsaW5kZXJcbiAgICAgICAgdmFyIG5ld19oZWlnaHQgPSBCQUJZTE9OLlZlY3RvcjMuRGlzdGFuY2UoQSwgQik7XG4gICAgICAgIGN5bGluZGVyLnNjYWxpbmcueSA9IG5ld19oZWlnaHQ7XG5cbiAgICAgICAgLy8gRmlyc3Qgcm90YXRpb25cbiAgICAgICAgdmFyIGFuZ2xlMSA9IFJBTkRPLlV0aWxzLmFuZ2xlRnJvbUF4aXMoQSwgQiwgQkFCWUxPTi5BeGlzLlgpO1xuICAgICAgICBjeWxpbmRlci5yb3RhdGUoXG4gICAgICAgICAgICBCQUJZTE9OLkF4aXMuWCxcbiAgICAgICAgICAgIGFuZ2xlMSxcbiAgICAgICAgICAgIEJBQllMT04uU3BhY2UuTE9DQUxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZWNvbmQgcm90YXRpb25cbiAgICAgICAgdmFyIEggPSBuZXcgQkFCWUxPTi5WZWN0b3IzKEEueCxCLnksQi56KTtcbiAgICAgICAgdmFyIGFuZ2xlMiA9IFJBTkRPLlV0aWxzLmFuZ2xlRnJvbVBvaW50cyhBLCBCLCBIKTtcbiAgICAgICAgY3lsaW5kZXIucm90YXRlKFxuICAgICAgICAgICAgQkFCWUxPTi5BeGlzLlosXG4gICAgICAgICAgICBhbmdsZTIsXG4gICAgICAgICAgICBCQUJZTE9OLlNwYWNlLkxPQ0FMXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGN5bGluZGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlTWVzaE5vcm1hbHMoKSA6IHJlY29tcHV0ZSBub3JtYWxzIG9mIGEgbWVzaCAoZm9yIHRoZSBzaGFkb3dzIGFmdGVyKVxuICAgICAqICAgICAgLSBtZXNoOiBtZXNoIHRvIHJlY29tcHV0ZVxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmNvbXB1dGVNZXNoTm9ybWFscyA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IEJBQllMT04uVmVydGV4RGF0YS5FeHRyYWN0RnJvbU1lc2ggKG1lc2gpO1xuICAgICAgICBCQUJZTE9OLlZlcnRleERhdGEuQ29tcHV0ZU5vcm1hbHModmVydGljZXMucG9zaXRpb25zLCB2ZXJ0aWNlcy5pbmRpY2VzLCB2ZXJ0aWNlcy5ub3JtYWxzKTtcbiAgICAgICAgdmVydGljZXMuYXBwbHlUb01lc2gobWVzaCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldE1lc2hVdnMoKSA6IHNldCB0aGUgbWVzaCB1dnMgdGFraW5nIGZyb20gdGhlIG9iamVjdCB1diB0YWtlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKiAgICAgIG1lc2g6IGJhYnlsb24gbWVzaFxuICAgICAqICAgICAgdXZzOiBvYmplY3QganMgY29udGFpbmluZyB1dnMgdmFsdWVzXG4gICAgICpcbiAgICAgKiBOQjogZm9ybWF0IG9mIHV2IG9iamVjdCBwYXJhbWV0ZXIgOlxuICAgICAqICAgICAgdXYgPSB7XG4gICAgICogICAgICAgICAgdTogW10sXG4gICAgICogICAgICAgICAgdjogW11cbiAgICAgKiAgICAgIH1cbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5zZXRNZXNoVXZzID0gZnVuY3Rpb24gKG1lc2gsIHV2KSB7XG4gICAgICAgIHZhciB1dl9hcnJheSA9IFtdO1xuICAgICAgICB2YXIgY29sLCByb3c7XG4gICAgICAgIGZvciAocm93IGluIHV2LnYpIHtcbiAgICAgICAgICAgIGZvciAoY29sIGluIHV2LnUpIHtcbiAgICAgICAgICAgICAgICB1dl9hcnJheS5wdXNoKHV2LnVbY29sXSk7XG4gICAgICAgICAgICAgICAgdXZfYXJyYXkucHVzaCh1di52W3Jvd10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgICAgICBtZXNoLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQpLmxlbmd0aCA9PSB1dl9hcnJheS5sZW5ndGgsXG4gICAgICAgICAgICBcInNldE1lc2hVdnMoKSA6IHV2cyBpbiBwYXJhbWV0ZXIgYXJlIG5vdCB3ZWxsIHNpemVkXCJcbiAgICAgICAgKTtcblxuICAgICAgICBtZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQsIHV2X2FycmF5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVXRpbHMubWVyZ2VNZXNoZXMoKSA6IE1lcmdlIGEgbWVzaCBhcnJheSBpbiBvbmx5IG9uZSBtZXNoLiBJdCBwZXJtaXRlc1xuICAgICAqIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICAgICAqICAgICAgLSBuZXdNZXNoIDogZnV0dXJlIG1lcmdlZCBNZXNoXG4gICAgICogICAgICAtIGFycmF5T2JqIDogYXJyYXkgb2YgTWVzaGVzIHRvIG1lcmdlXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbiBkaXJlY3RseSBpbnNwaXJlZCBmcm9tIERhdmlkIENhdHVoZSdzIG9uZSBpbiB0aGUgZ2l0aHViIHdpa2kgb2YgQmFieWxvbkpTXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL0JhYnlsb25KUy9CYWJ5bG9uLmpzL3dpa2kvSG93LXRvLW1lcmdlLW1lc2hlc1xuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLm1lcmdlTWVzaGVzID0gZnVuY3Rpb24gKG5ld01lc2gsIGFycmF5T2JqKSB7XG4gICAgICAgIHZhciBhcnJheVBvcyA9IFtdO1xuICAgICAgICB2YXIgYXJyYXlOb3JtYWwgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5VXYgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5VXYyID0gW107XG4gICAgICAgIHZhciBhcnJheUNvbG9yID0gW107XG4gICAgICAgIHZhciBhcnJheU1hdHJpY2VzSW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgYXJyYXlNYXRyaWNlc1dlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIGFycmF5SW5kaWNlID0gW107XG4gICAgICAgIHZhciBzYXZlZFBvc2l0aW9uID0gW107XG4gICAgICAgIHZhciBzYXZlZE5vcm1hbCA9IFtdO1xuICAgICAgICB2YXIgVVZLaW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIFVWMktpbmQgPSB0cnVlO1xuICAgICAgICB2YXIgQ29sb3JLaW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIE1hdHJpY2VzSW5kaWNlc0tpbmQgPSB0cnVlO1xuICAgICAgICB2YXIgTWF0cmljZXNXZWlnaHRzS2luZCA9IHRydWU7XG4gICAgICAgIHZhciBpID0gMCwgaXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSAhPSBhcnJheU9iai5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyYXlPYmpbaV0uaXNWZXJ0aWNlc0RhdGFQcmVzZW50KFtCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmRdKSlcbiAgICAgICAgICAgICAgICBVVktpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghYXJyYXlPYmpbaV0uaXNWZXJ0aWNlc0RhdGFQcmVzZW50KFtCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVjJLaW5kXSkpXG4gICAgICAgICAgICAgICAgVVYyS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFhcnJheU9ialtpXS5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoW0JBQllMT04uVmVydGV4QnVmZmVyLkNvbG9yS2luZF0pKVxuICAgICAgICAgICAgICAgIENvbG9yS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFhcnJheU9ialtpXS5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoW0JBQllMT04uVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmRdKSlcbiAgICAgICAgICAgICAgICBNYXRyaWNlc0luZGljZXNLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWFycmF5T2JqW2ldLmlzVmVydGljZXNEYXRhUHJlc2VudChbQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZF0pKVxuICAgICAgICAgICAgICAgIE1hdHJpY2VzV2VpZ2h0c0tpbmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgIT0gYXJyYXlPYmoubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlID0gMDtcbiAgICAgICAgICAgIHZhciBpdGVyID0gMDtcbiAgICAgICAgICAgIGFycmF5UG9zW2ldID0gYXJyYXlPYmpbaV0uZ2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCk7XG4gICAgICAgICAgICBhcnJheU5vcm1hbFtpXSA9IGFycmF5T2JqW2ldLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKTtcbiAgICAgICAgICAgIGlmIChVVktpbmQpXG4gICAgICAgICAgICAgICAgYXJyYXlVdiA9IGFycmF5VXYuY29uY2F0KGFycmF5T2JqW2ldLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVktpbmQpKTtcbiAgICAgICAgICAgIGlmIChVVjJLaW5kKVxuICAgICAgICAgICAgICAgIGFycmF5VXYyID0gYXJyYXlVdjIuY29uY2F0KGFycmF5T2JqW2ldLmdldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSk7XG4gICAgICAgICAgICBpZiAoQ29sb3JLaW5kKVxuICAgICAgICAgICAgICAgIGFycmF5Q29sb3IgPSBhcnJheUNvbG9yLmNvbmNhdChhcnJheU9ialtpXS5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSk7XG4gICAgICAgICAgICBpZiAoTWF0cmljZXNJbmRpY2VzS2luZClcbiAgICAgICAgICAgICAgICBhcnJheU1hdHJpY2VzSW5kaWNlcyA9IGFycmF5TWF0cmljZXNJbmRpY2VzLmNvbmNhdChhcnJheU9ialtpXS5nZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCkpO1xuICAgICAgICAgICAgaWYgKE1hdHJpY2VzV2VpZ2h0c0tpbmQpXG4gICAgICAgICAgICAgICAgYXJyYXlNYXRyaWNlc1dlaWdodHMgPSBhcnJheU1hdHJpY2VzV2VpZ2h0cy5jb25jYXQoYXJyYXlPYmpbaV0uZ2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpKTtcblxuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gc2F2ZWRQb3NpdGlvbi5sZW5ndGggLyAzO1xuXG4gICAgICAgICAgICBhcnJheU9ialtpXS5jb21wdXRlV29ybGRNYXRyaXgodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgd29ybGRNYXRyaXggPSBhcnJheU9ialtpXS5nZXRXb3JsZE1hdHJpeCgpO1xuXG4gICAgICAgICAgICB3aGlsZSAoaXRlIDwgYXJyYXlQb3NbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXMobmV3IEJBQllMT04uVmVjdG9yMyhhcnJheVBvc1tpXVtpdGVdLCBhcnJheVBvc1tpXVtpdGUgKyAxXSwgYXJyYXlQb3NbaV1baXRlICsgMl0pLCB3b3JsZE1hdHJpeCk7XG4gICAgICAgICAgICAgICAgc2F2ZWRQb3NpdGlvbi5wdXNoKHZlcnRleC54KTtcbiAgICAgICAgICAgICAgICBzYXZlZFBvc2l0aW9uLnB1c2godmVydGV4LnkpO1xuICAgICAgICAgICAgICAgIHNhdmVkUG9zaXRpb24ucHVzaCh2ZXJ0ZXgueik7XG4gICAgICAgICAgICAgICAgaXRlID0gaXRlICsgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpdGVyIDwgYXJyYXlOb3JtYWxbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBCQUJZTE9OLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsKG5ldyBCQUJZTE9OLlZlY3RvcjMoYXJyYXlOb3JtYWxbaV1baXRlcl0sIGFycmF5Tm9ybWFsW2ldW2l0ZXIgKyAxXSwgYXJyYXlOb3JtYWxbaV1baXRlciArIDJdKSwgd29ybGRNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHNhdmVkTm9ybWFsLnB1c2godmVydGV4LngpO1xuICAgICAgICAgICAgICAgIHNhdmVkTm9ybWFsLnB1c2godmVydGV4LnkpO1xuICAgICAgICAgICAgICAgIHNhdmVkTm9ybWFsLnB1c2godmVydGV4LnopO1xuICAgICAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBhcnJheU9ialtpXS5nZXRJbmRpY2VzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChpdCA9IDAgOyBpdCAhPSB0bXAubGVuZ3RoOyBpdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFtpdF0gPSB0bXBbaXRdICsgbWF4VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5SW5kaWNlID0gYXJyYXlJbmRpY2UuY29uY2F0KHRtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheUluZGljZSA9IGFycmF5T2JqW2ldLmdldEluZGljZXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlPYmpbaV0uZGlzcG9zZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsIHNhdmVkUG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgbmV3TWVzaC5zZXRWZXJ0aWNlc0RhdGEoQkFCWUxPTi5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCwgc2F2ZWROb3JtYWwsIGZhbHNlKTtcbiAgICAgICAgaWYgKGFycmF5VXYubGVuZ3RoID4gMClcbiAgICAgICAgICAgIG5ld01lc2guc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlVWS2luZCwgYXJyYXlVdiwgZmFsc2UpO1xuICAgICAgICBpZiAoYXJyYXlVdjIubGVuZ3RoID4gMClcbiAgICAgICAgICAgIG5ld01lc2guc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLlVWMktpbmQsIGFycmF5VXYyLCBmYWxzZSk7XG4gICAgICAgIGlmIChhcnJheUNvbG9yLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQsIGFycmF5Q29sb3IsIGZhbHNlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0cmljZXNJbmRpY2VzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBuZXdNZXNoLnNldFZlcnRpY2VzRGF0YShCQUJZTE9OLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kLCBhcnJheU1hdHJpY2VzSW5kaWNlcywgZmFsc2UpO1xuICAgICAgICBpZiAoYXJyYXlNYXRyaWNlc1dlaWdodHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIG5ld01lc2guc2V0VmVydGljZXNEYXRhKEJBQllMT04uVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQsIGFycmF5TWF0cmljZXNXZWlnaHRzLCBmYWxzZSk7XG5cbiAgICAgICAgbmV3TWVzaC5zZXRJbmRpY2VzKGFycmF5SW5kaWNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUkFORE8uVXRpbHMuZ2V0U2l6ZSAoKSA6IGdldCB0aGUgc2l6ZSBvZiBhIG1lc2hcbiAgICAgKiAgICAgIC0gbWVzaCA6IG1lc2hcbiAgICAgKlxuICAgICAqIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgZGVlcCBvZiB0aGUgbWVzaFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmdldFNpemUgPSBmdW5jdGlvbiAobWVzaCkge1xuICAgICAgICB2YXIgbWlubWF4ID0gQkFCWUxPTi5NZXNoLk1pbk1heChbbWVzaF0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnd2lkdGgnICA6IChtaW5tYXgubWF4LnggLSBtaW5tYXgubWluLngpICxcbiAgICAgICAgICAgICdoZWlnaHQnIDogKG1pbm1heC5tYXgueSAtIG1pbm1heC5taW4ueSkgLFxuICAgICAgICAgICAgJ2RlZXAnICAgOiAobWlubWF4Lm1heC56IC0gbWlubWF4Lm1pbi56KVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJBTkRPLlV0aWxzLmlzSW5FeHRlbnQoKSA6XG4gICAgICogIHJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBjb29yZGluYXRlcyBhcmUgaW4gdGhlIGdpdmVuIGV4dGVudFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmlzSW5FeHRlbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGV4dGVudCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueCA+PSBleHRlbnQueC5taW4gJiZcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggPD0gZXh0ZW50LngubWF4ICYmXG4gICAgICAgICAgICBjb29yZGluYXRlcy56ID49IGV4dGVudC56Lm1pbiAmJlxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueiA8PSBleHRlbnQuei5tYXhcbiAgICAgICAgICk/IHRydWU6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSQU5ETy5VdGlscy5nZXROdW1iZXJPZlRpbGVzKCkgOiByZXR1cm4gdGhlIG51bWJlciBvZiB0aWxlcyBhY2NvcmRpbmcgYSB6b29tIGxldmVsIGFuZFxuICAgICAqIGEgbWV0ZXJzIGV4dGVudC5cbiAgICAgKi9cbiAgICBSQU5ETy5VdGlscy5nZXROdW1iZXJPZlRpbGVzID0gZnVuY3Rpb24gKHpvb20sIGV4dGVudCkge1xuICAgICAgICB2YXIgeFRpbGVNaW4gPSBSQU5ETy5VdGlscy5tZXRlcnMybnVtIChleHRlbnQueC5taW4sIGV4dGVudC56Lm1pbiwgem9vbSkueHRpbGU7XG4gICAgICAgIHZhciB4VGlsZU1heCA9IFJBTkRPLlV0aWxzLm1ldGVyczJudW0gKGV4dGVudC54Lm1heCwgZXh0ZW50LnoubWF4LCB6b29tKS54dGlsZTtcbiAgICAgICAgdmFyIHlUaWxlTWluID0gUkFORE8uVXRpbHMubWV0ZXJzMm51bSAoZXh0ZW50LngubWluLCBleHRlbnQuei5taW4sIHpvb20pLnl0aWxlO1xuICAgICAgICB2YXIgeVRpbGVNYXggPSBSQU5ETy5VdGlscy5tZXRlcnMybnVtIChleHRlbnQueC5tYXgsIGV4dGVudC56Lm1heCwgem9vbSkueXRpbGU7XG4gICAgICAgIHJldHVybiAoeFRpbGVNYXggLSB4VGlsZU1pbiArIDEpICogKHlUaWxlTWluIC0geVRpbGVNYXggKyAxKTtcbiAgICB9O1xuXG4gICAgLyoqKiogICAgR0VPTUVUUlkgICAgICoqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKip0ZXN0ZWRcbiAgICAgKiBtaWRkbGUoKTpcbiAgICAgKiAgICAgIEE6IGZpcnN0IHBvaW50XG4gICAgICogICAgICBCOiBzZWNvbmQgcG9pbnRcbiAgICAgKlxuICAgICAqIHJldHVybiB0aGUgbWlkZGxlIG9mIHRoZSBzZWdtZW50IGZvcm0gYnkgQSBhbmQgQlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLm1pZGRsZSA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoQS54K0IueCkvMixcbiAgICAgICAgICAgIHk6IChBLnkrQi55KS8yLFxuICAgICAgICAgICAgejogKEEueitCLnopLzJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqdGVzdGVkXG4gICAgICogc3ViZGl2aWRlKCkgOiAgaW50ZXJwb2xhdGUgYSBzZWdtZW50IGJldHdlZW4gMiBwb2ludHMgQSBhbmQgQlxuICAgICAqICAgICAgLSBuIDogbnVtYmVyIG9mIHBvaW50cyBleHBlY3RlZCBpbiByZXN1bHRcbiAgICAgKiAgICAgIC0gQSA6IGZpcnN0IHBvaW50XG4gICAgICogICAgICAtIEIgOiBzZWNvbmQgcG9pbnRcbiAgICAgKlxuICAgICAqIHJldHVybiBhbiBhcnJheSBvZiBwb2ludFxuICAgICAqXG4gICAgICogTkIgOiBwb2ludHMgYXJlIGluIHRoZSBmb3JtYXQgOiB7IHggOiAuLiAsIHkgOiAuLiB9XG4gICAgICpcbiAgICAgKlxuICAgICAqIGV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgICAgICAqIEIgICAgICAgICAgICAgICAgICAgKiBCXG4gICAgICogICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAvXG4gICAgICogICAgICAgLyAgICAgIG4gPSA0ICAgICAgICAgICogTTJcbiAgICAgKiAgICAgIC8gICAgICAtLS0tPiAgICAgICAgICAvXG4gICAgICogICAgIC8gICAgICAgICAgICAgICAgICAgICAqIE0xXG4gICAgICogICAgLyAgICAgICAgICAgICAgICAgICAgIC9cbiAgICAgKiBBICogICAgICAgICAgICAgICAgICAgIEEqXG4gICAgICpcbiAgICAgKiAgICAgICAgICByZXN1bHQgOiBbQSwgTTEsIE0yLCBCXVxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuc3ViZGl2aWRlID0gZnVuY3Rpb24gKG4sIEEsIEIpIHtcblxuICAgICAgICBpZiAobjw9MCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKG49PTEpIHJldHVybiBBO1xuXG4gICAgICAgIGlmIChuPT0yKSByZXR1cm4gW0EsQl07XG5cbiAgICAgICAgaWYgKG4+PTMpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IChCLngtQS54KS8obi0xKTtcbiAgICAgICAgICAgIHZhciBkeSA9IChCLnktQS55KS8obi0xKTtcblxuICAgICAgICAgICAgdmFyIHggPSBBLng7XG4gICAgICAgICAgICB2YXIgeSA9IEEueTtcblxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgcmVzLnB1c2goQSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bi0yOyBpKyspe1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICd4JyA6IHgsXG4gICAgICAgICAgICAgICAgICAgICd5JyA6IHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKEIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKnRlc3RlZFxuICAgICAqIGNyZWF0ZUdyaWQoKSA6IGNyZWF0ZSBhIGdyaWQgb2YgcG9pbnRzIGZvciBhbGwgdHlwZSBvZiBxdWFkcmlsYXRlcmVzLCBpbiBwYXJ0aWN1bGFyXG4gICAgICogIHRoZXNlIHdoaWNoIGFyZSBub3Qgc3F1YXJlIG9yIHJlY3RhbmdsZS5cbiAgICAgKiAgICAgIC0gQSwgQiwgQywgRCA6ICB2ZXJ0aWNlcyBvZiBxdWFkcmlsYXRlcmUgdG8gc3ViZGl2aWRlXG4gICAgICogICAgICAtIG5fdmVydGkgOiAgICAgbnVtYmVyIG9mIHBvaW50cyBpbiB2ZXJ0aWNhbCBzaXplXG4gICAgICogICAgICAtIG5faG9yaXogOiAgICAgbnVtYmVyIG9mIHBvaW50cyBpbiBob3Jpem9udGFsIHNpemVcbiAgICAgKlxuICAgICAqXG4gICAgICogTkIgOiAqIG5fdmVydGkgYW5kIG5faG9yaXogY2Fubm90IGJlIGludmVydFxuICAgICAqICAgICAgKiB0aGUgb3JkZXIgb2YgaW5wdXQgcG9pbnRzIGlzIGFsc28gaW1wb3J0YW50LCBpdCBkZXRlcm1pbmVzXG4gICAgICogdGhlIG9yZGVyIG9mIG91dHB1dCBwb2ludHMgOlxuICAgICAqICBbQSwgLi4uLiwgQiwgICAgLT4gZmlyc3QgbGluZVxuICAgICAqICAgLi4uLi4uLi4uLixcbiAgICAgKiAgIEQsIC4uLi4sIENdICAgIC0+IGxhc3QgbGluZVxuICAgICAqXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIG9mIHF1YWRyaWxhdGVyZSA6XG4gICAgICogRCAqLS0tLS0tLS0tLS0tLS0tLS0tKiBDXG4gICAgICogICB8ICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICogICB8ICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICogICB8ICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICogICB8ICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAqICAgfCAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICogQSAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSogQlxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuY3JlYXRlRmxhdEdyaWQgPSBmdW5jdGlvbiAoQSwgQiwgQywgRCwgbl9ob3Jpeiwgbl92ZXJ0aSkge1xuICAgICAgICBpZihuX3ZlcnRpPD0wKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYobl9ob3Jpejw9MCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gc3ViZGl2aWRlIGJvdGggc2lkZXMgb2YgdGhlIHF1YWRcbiAgICAgICAgdmFyIHdlc3Rfc2lkZSA9IFJBTkRPLlV0aWxzLnN1YmRpdmlkZShuX3ZlcnRpLCBBLCBEKTtcbiAgICAgICAgdmFyIGVhc3Rfc2lkZSA9IFJBTkRPLlV0aWxzLnN1YmRpdmlkZShuX3ZlcnRpLCBCLCBDKTtcbiAgICAgICAgdmFyIGdyaWQgPSBbXTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQod2VzdF9zaWRlLmxlbmd0aCA9PSBlYXN0X3NpZGUubGVuZ3RoLFxuICAgICAgICAgICAgXCJjcmVhdGVHcmlkIDogd2VzdF9zaWRlLmxlbmd0aCAhPSBlYXN0X3NpZGUubGVuZ3RoIFxcblwiICtcbiAgICAgICAgICAgIHdlc3Rfc2lkZS5sZW5ndGggK1xuICAgICAgICAgICAgXCIgIT0gXCIgK1xuICAgICAgICAgICAgZWFzdF9zaWRlLmxlbmd0aFxuICAgICAgICApO1xuXG5cbiAgICAgICAgZm9yICh2YXIgaj0wOyBqIDwgbl92ZXJ0aTsgaisrKXtcbiAgICAgICAgICAgIC8vIHN1YmlkaXZpZGUgbGluZXNcbiAgICAgICAgICAgIHZhciBsaW5lID0gUkFORE8uVXRpbHMuc3ViZGl2aWRlKG5faG9yaXosIHdlc3Rfc2lkZVtqXSwgZWFzdF9zaWRlW2pdKTtcbiAgICAgICAgICAgIGdyaWQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuY3JlYXRlRWxldmF0aW9uR3JpZCA9IGZ1bmN0aW9uICh4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBhbHRpdHVkZXMpIHtcbiAgICAgICAgdmFyIEEgPSB7XG4gICAgICAgICAgICAneCcgOiB4bWluLFxuICAgICAgICAgICAgJ3knIDogeW1pblxuICAgICAgICB9O1xuICAgICAgICB2YXIgQiA9IHtcbiAgICAgICAgICAgICd4JyA6IHhtYXgsXG4gICAgICAgICAgICAneScgOiB5bWluXG4gICAgICAgIH07XG4gICAgICAgIHZhciBDID0ge1xuICAgICAgICAgICAgJ3gnIDogeG1heCxcbiAgICAgICAgICAgICd5JyA6IHltYXhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEQgPSB7XG4gICAgICAgICAgICAneCcgOiB4bWluLFxuICAgICAgICAgICAgJ3knIDogeW1heFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcm93LCBjb2w7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBncmlkIGZyb20gZXh0ZW50IGRhdGFzXG4gICAgICAgIHZhciBncmlkID0gUkFORE8uVXRpbHMuY3JlYXRlRmxhdEdyaWQoXG4gICAgICAgICAgICBBLCBCLCBDLCBELFxuICAgICAgICAgICAgYWx0aXR1ZGVzWzBdLmxlbmd0aCxcbiAgICAgICAgICAgIGFsdGl0dWRlcy5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBHaXZlcyBhbHRpdHVkZXMgdG8gdGhlIGdyaWRcbiAgICAgICAgZm9yIChyb3cgaW4gYWx0aXR1ZGVzKXtcbiAgICAgICAgICAgIGZvciAoY29sIGluIGFsdGl0dWRlc1tyb3ddKXtcbiAgICAgICAgICAgICAgICBncmlkW3Jvd11bY29sXS56ID0gZ3JpZFtyb3ddW2NvbF0ueTtcbiAgICAgICAgICAgICAgICBncmlkW3Jvd11bY29sXS55ID0gYWx0aXR1ZGVzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICB9O1xuXG4gICAgLyoqdGVzdGVkXG4gICAgICogYW5nbGVGcm9tQXhpcygpOiBnZXQgYW4gYW5nbGUgZm9yIGEgcm90YXRpb25cbiAgICAgKiAgICAgIC0gQSAgICAgKEJBQllMT04uVmVjdG9yMykgOiBGaXJzdCBwb2ludFxuICAgICAqICAgICAgLSBCICAgICAoQkFCWUxPTi5WZWN0b3IzKSA6IFNlY29uZCBwb2ludFxuICAgICAqICAgICAgLSBheGlzICAoQkFCWUxPTi5WZWN0b3IzKSA6IEF4aXMgb2Ygcm90YXRpb25cbiAgICAgKlxuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIGEgcm90YXRpb24gYXJvdW5kIHkgYXhpc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgICBfIHpcbiAgICAgKiAgICAgICAuLT4gICAgICAgICAgIHxcbiAgICAgKiAgICAgIC8gICAgICAgICAgICAgIHwgICAgICogQlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgICAvXG4gICAgICogICAgICAgICAgICAgICAgICAgICB8ICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAvXG4gICAgICogICAgICAgICAgICAgICAgICAgICB8LyAgICAgICAgICAgICAgIHhcbiAgICAgKiAgICAgICAtLS0tLS0tLS0tLS0tLSotLS0tLS0tLS0tLS0tLS0+XG4gICAgICogICAgICAgICAgICAgICAgICAgICB8QVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqXG4gICAgICogTkIgOiBJdCB1c2VzIGdsb2JhbCBheGlzIG9ubHlcbiAgICAgKiAgKDEsIDAsIDApLCAoMCwgMSwgMCksIG9yICgwLCAwLCAxKVxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuYW5nbGVGcm9tQXhpcyA9IGZ1bmN0aW9uIChBLCBCLCBheGlzKSB7XG4gICAgICAgIHZhciBhbmdsZSwgQUgsIEFCO1xuICAgICAgICBzd2l0Y2ggKGF4aXMpe1xuICAgICAgICAgICAgY2FzZSBCQUJZTE9OLkF4aXMuWCA6XG4gICAgICAgICAgICAgICAgaWYoQS55ID09IEIueSAmJiBBLnogPT0gQi56KSAvLyBJdCBkb24ndCBuZWVkIHJvdGF0aW9uIGFyb3VuZCBYXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIEFIID0gQi55LUEueTtcbiAgICAgICAgICAgICAgICBBQiA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coQi55LUEueSwgMikrXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KEIuei1BLnosIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhBSC9BQik7XG4gICAgICAgICAgICAgICAgaWYgKEIueiA8IEEueilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1hbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQkFCWUxPTi5BeGlzLlkgOlxuICAgICAgICAgICAgICAgIGlmKEEueCA9PSBCLnggJiYgQS56ID09IEIueikgLy8gSXQgZG9uJ3QgbmVlZCByb3RhdGlvbiBhcm91bmQgWVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBBSCA9IEIuei1BLno7XG4gICAgICAgICAgICAgICAgQUIgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KEIuei1BLnosIDIpK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhCLngtQS54LCAyKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhBSC9BQik7XG4gICAgICAgICAgICAgICAgLy9pZiAoYW5nbGUgPiBNYXRoLlBJLzIpXG4gICAgICAgICAgICAgICAgICAgIC8vYW5nbGUgPSAtKChNYXRoLlBJLzIpLWFuZ2xlKVxuICAgICAgICAgICAgICAgIGlmIChCLnggPCBBLngpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJBQllMT04uQXhpcy5aIDpcbiAgICAgICAgICAgICAgICBpZihBLnggPT0gQi54ICYmIEEueSA9PSBCLnkpIC8vIEl0IGRvbid0IG5lZWQgcm90YXRpb24gYXJvdW5kIFpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIEFIID0gQi54LUEueDtcbiAgICAgICAgICAgICAgICBBQiA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coQi54LUEueCwgMikrXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucG93KEIueS1BLnksIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYWNvcyhBSC9BQik7XG4gICAgICAgICAgICAgICAgaWYgKEIueSA8IEEueSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1hbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYW5nbGVGcm9tUG9pbnRzKCkgOiBnZXQgYW4gYW5nbGUgZnJvbSAzIHBvaW50cyBmb3IgYSByb3RhdGlvbiBhcm91bmQgYW4gYXhpc1xuICAgICAqICBvcnRob2dvbmFsIG9mIHRoZSBwbGFuIGZvcm1lZCBieSB0aGUgMyBwb2ludHNcbiAgICAgKiAgICAgIC0gQSAoQkFCWUxPTi5WZWN0b3IzKSA6IEZpcnN0IHBvaW50XG4gICAgICogICAgICAtIEIgKEJBQllMT04uVmVjdG9yMykgOiBTZWNvbmQgcG9pbnRcbiAgICAgKiAgICAgIC0gSCAoQkFCWUxPTi5WZWN0b3IzKSA6IE9ydGhvZ29uYWwgcHJvamVjdGlvbiBvZiBCIG92ZXIgdGhlIGF4aXNcbiAgICAgKlxuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIGEgcm90YXRpb24gYXJvdW5kIHogYXhpc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgICBfIHhcbiAgICAgKiAgICAgICAuLT4gICAgICAgICAgIHxcbiAgICAgKiAgICAgIC8gICAgICAgICAgICBIICogICAgICogQlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgICAvXG4gICAgICogICAgICAgICAgICAgICAgICAgICB8ICAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAgL1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgfCAvXG4gICAgICogICAgICAgICAgICAgICAgICAgICB8LyAgICAgICAgICAgICAgIHlcbiAgICAgKiAgICAgICAtLS0tLS0tLS0tLS0tLSotLS0tLS0tLS0tLS0tLS0+XG4gICAgICogICAgICAgICAgICAgICAgICAgICB8QVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqXG4gICAgICogTkIgOiBJdCBpcyB1c2VkIHdoZW4gd2UgZG9uJ3QgaGF2ZSBlc3BlY2lhbGx5IGNsYXNzaWNhbCBnbG9iYWwgYXhpcy4gRm9yIGV4YW1wbGVcbiAgICAgKiBhZnRlciBhIGZpcnN0IHJvdGF0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuYW5nbGVGcm9tUG9pbnRzID0gZnVuY3Rpb24gKEEsIEIsIEgpIHtcbiAgICAgICAgdmFyIEFIID0gQkFCWUxPTi5WZWN0b3IzLkRpc3RhbmNlKEEsIEgpO1xuICAgICAgICB2YXIgQUIgPSBCQUJZTE9OLlZlY3RvcjMuRGlzdGFuY2UoQSwgQik7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYWNvcyhBSC9BQik7XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHNpZ25cbiAgICAgICAgaWYgKEgueCA8IEIueClcbiAgICAgICAgICAgIHJldHVybiAtYW5nbGU7XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9O1xuXG4gICAgUkFORE8uVXRpbHMucm91bmRSZWN0ID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHcsIGgsIHJhZGl1cykge1xuICAgICAgICB2YXIgciA9IHggKyB3O1xuICAgICAgICB2YXIgYiA9IHkgKyBoO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aD1cIjRcIjtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCtyYWRpdXMsIHkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyLXJhZGl1cywgeSk7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhyLCB5LCByLCB5K3JhZGl1cyk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHIsIHkraC1yYWRpdXMpO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ociwgYiwgci1yYWRpdXMsIGIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4K3JhZGl1cywgYik7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4LCBiLCB4LCBiLXJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkrcmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHgrcmFkaXVzLCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5maWxsKClcbiAgICB9O1xuXG4gICAgLyoqdGVzdGVkXG4gICAgICogIHNjYWxlQXJyYXkyKCkgOiBtdWx0aXBseSBhbGwgdmFsdWVzIG9mIDItZGltZW5zaW9ucyBhcnJheSBieSBhIHNjYWxlIHZhbHVlXG4gICAgICogICAgICAtIGFycmF5MiA6IG9yaWdpbmFsIGFycmF5XG4gICAgICogICAgICAtIHNjYWxlIDogc2NhbGUgdmFsdWVcbiAgICAgKlxuICAgICAqIHJldHVybiBhIG5ldyBhcnJheSB3aGljaCBjb250YWlucyBhbGwgdmFsdWVzIG9mIGFycmF5MiBtdWx0aXBsaWVkXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuc2NhbGVBcnJheTIgPSBmdW5jdGlvbiAoYXJyYXkyLCBzY2FsZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIHJvdyBpbiBhcnJheTIpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgaW4gYXJyYXkyW3Jvd10pIHtcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goYXJyYXkyW3Jvd11bY29sXSAqIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuXG4gICAgLyoqKiogICAgR0VUVEVSUyAgICAgKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKnRlc3RlZFxuICAgICAqIGdldFVybEZyb21Db29yZGluYXRlcygpOiBnZXQgdGhlIHVybCBvZiBhIHRpbGUgdGV4dHVyZVxuICAgICAqICAgICAgeiA6IGxldmVsIG9mIHpvb21cbiAgICAgKiAgICAgIHggOiB4IGNvb3JkaW5hdGVzIG9mIHRpbGVcbiAgICAgKiAgICAgIHkgOiB5IGNvb3JkaW5hdGVzIG9mIHRpbGVcbiAgICAgKlxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnJlcGxhY2VVcmxDb29yZGluYXRlcyA9IGZ1bmN0aW9uICh1cmwsIHosIHgsIHkpIHtcbiAgICAgICAgdmFyIHN1YmRvbWFpbnMgPSBSQU5ETy5TRVRUSU5HUy5USUxFX1RFWF9VUkxfU1VCRE9NQUlOUyxcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5hYnMoeCArIHkpICUgc3ViZG9tYWlucy5sZW5ndGgsXG4gICAgICAgICAgICBzdWJkb21haW4gPSBzdWJkb21haW5zW2luZGV4XTtcblxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcIntzfVwiLCBzdWJkb21haW4pO1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcInt6fVwiLCB6KTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXCJ7eH1cIiwgeCk7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFwie3l9XCIsIHkpO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG5cbiAgICAvKioqKiAgICBDT05WRVJTSU9OUyAgICAgKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKnRlc3RlZFxuICAgICAqIHRvTWV0ZXJzKCkgOiBjb252ZXJ0IGEgcG9pbnQgaW4gbGF0aXR1ZGUvbG9uZ2l0dWRlIHRvIHgveSBtZXRlcnMgY29vcmRpbmF0ZXNcbiAgICAgKiAgICAgIC0gbGF0bG5nIDogcG9pbnQgaW4gbGF0L2xuZ1xuICAgICAqXG4gICAgICogcmV0dXJuIGEgcG9pbnQgaW4gbWV0ZXJzXG4gICAgICpcbiAgICAgKiB7IGxhdCA6IC4uICwgbG5nIDogLi4gfSAgLS0tPiB7IHggOiAuLiAsIHkgOiAuLiB9XG4gICAgICovXG4gICAgUkFORE8uVXRpbHMudG9NZXRlcnMgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG5cbiAgICAgICAgdmFyIFIgPSA2Mzc4MTM3O1xuXG4gICAgICAgIHZhciBkID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIG1heCA9IDEgLSAxKk1hdGgucG93KDEwLCAtMTUpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5zaW4obGF0bG5nLmxhdCAqIGQpLCBtYXgpLCAtbWF4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCA6IFIgKiBsYXRsbmcubG5nICogZCxcbiAgICAgICAgICAgIHkgOiBSICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqdGVzdGVkXG4gICAgICogdG9MYXRsbmcoKSA6IGNvbnZlcnQgYSBwb2ludCBpbiB4L3kgbWV0ZXJzIGNvb3JkaW5hdGVzIHRvIGxhdGl0dWRlL2xvbmdpdHVkZVxuICAgICAqICAgICAgLSBwb2ludCA6IHBvaW50IGluIHgveSBtZXRlcnMgY29vcmRpbmF0ZXNcbiAgICAgKlxuICAgICAqIHJldHVybiBhIHBvaW50IGluIGxhdC9sb25nXG4gICAgICpcbiAgICAgKiB7IHggOiAuLiAsIHkgOiAuLiB9ICAtLS0+ICB7IGxhdCA6IC4uICwgbG5nIDogLi4gfVxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLnRvTGF0bG5nID0gZnVuY3Rpb24gKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIFIgPSA2Mzc4MTM3O1xuXG4gICAgICAgIHZhciBkID0gMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGF0OiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxuICAgICAgICAgICAgbG5nOiBwb2ludC54ICogZCAvIFJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXRNZXRlcnNFeHRlbnQoKSA6IGdldCB0aGUgZXh0ZW50IG9mIHRoZSBERU0gaW4gbWV0ZXJzXG4gICAgICogICAgICAtIGV4dGVudCA6IGV4dGVudCBvZiB0aGUgREVNIGluIGxhdGl0dWRlcy9sb25naXR1ZGVzXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMuZ2V0TWV0ZXJzRXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCkge1xuICAgICAgICB2YXIgbncgPSBSQU5ETy5VdGlscy50b01ldGVycyhleHRlbnQubm9ydGh3ZXN0KTtcbiAgICAgICAgdmFyIG5lID0gUkFORE8uVXRpbHMudG9NZXRlcnMoZXh0ZW50Lm5vcnRoZWFzdCk7XG4gICAgICAgIHZhciBzdyA9IFJBTkRPLlV0aWxzLnRvTWV0ZXJzKGV4dGVudC5zb3V0aHdlc3QpO1xuICAgICAgICB2YXIgc2UgPSBSQU5ETy5VdGlscy50b01ldGVycyhleHRlbnQuc291dGhlYXN0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3gnIDoge1xuICAgICAgICAgICAgICAgICdtaW4nIDogTWF0aC5taW4obncueCwgc3cueCksXG4gICAgICAgICAgICAgICAgJ21heCcgOiBNYXRoLm1pbihuZS54LCBzZS54KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd5JyA6IGV4dGVudC5hbHRpdHVkZXMsXG4gICAgICAgICAgICAneicgOiB7XG4gICAgICAgICAgICAgICAgJ21pbicgOiBNYXRoLm1pbihzdy55LCBzZS55KSxcbiAgICAgICAgICAgICAgICAnbWF4JyA6IE1hdGgubWluKG53LnksIG5lLnkpXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1ldGVyczJudW0oKTogZ2V0IHRoZSB0aWxlIG51bWJlciBvZiB0aGUgdGlsZSBjb250YWluaW5nIGEgcG9pbnRcbiAgICAgKiAgaW4gYSBjZXJ0YWluIGxldmVsIG9mIHpvb21cbiAgICAgKiAgICAgIC0geDogeCBjb29yZGluYXRlIG9mIHBvaW50IChpbiBtZXRlcnMpXG4gICAgICogICAgICAtIHk6IHkgY29vcmRpbmF0ZSBvZiBwb2ludCAoaW4gbWV0ZXJzKVxuICAgICAqICAgICAgLSB6b29tOiB6b29tIGxldmVsXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMubWV0ZXJzMm51bSA9IGZ1bmN0aW9uICh4LCB5LCB6b29tKSB7XG4gICAgICAgIHZhciB0bXBfbGwgPSBSQU5ETy5VdGlscy50b0xhdGxuZyh7XG4gICAgICAgICAgICAneCc6IHgsXG4gICAgICAgICAgICAneSc6IHlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSQU5ETy5VdGlscy5kZWcybnVtKHRtcF9sbC5sYXQsIHRtcF9sbC5sbmcsIHpvb20pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZWcybnVtKCk6IGdldCB0aGUgdGlsZSBudW1iZXIgb2YgdGhlIHRpbGUgY29udGFpbmluZyBhIHBvaW50XG4gICAgICogIGluIGEgY2VydGFpbiBsZXZlbCBvZiB6b29tXG4gICAgICogICAgICAtIGxhdF9kZWc6IGxhdGl0dWRlICBjb29yZGluYXRlIG9mIHBvaW50IChpbiBkZWdyZWVzKVxuICAgICAqICAgICAgLSBsbmdfZGVnOiBsb25naXR1ZGUgY29vcmRpbmF0ZSBvZiBwb2ludCAoaW4gZGVncmVlcylcbiAgICAgKiAgICAgIC0gem9vbTogem9vbSBsZXZlbFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmRlZzJudW0gPSBmdW5jdGlvbiAobGF0X2RlZywgbG5nX2RlZywgem9vbSkge1xuICAgICAgICB2YXIgbGF0X3JhZCA9IGxhdF9kZWcqTWF0aC5QSS8xODA7XG4gICAgICAgIHZhciBuID0gTWF0aC5wb3coMi4wLCB6b29tKTtcbiAgICAgICAgdmFyIHh0aWxlID0gTWF0aC5mbG9vcigobG5nX2RlZyArIDE4MC4wKSAvIDM2MC4wICogbik7XG4gICAgICAgIHZhciB5dGlsZSA9IE1hdGguZmxvb3IoKDEuMCAtIE1hdGgubG9nKE1hdGgudGFuKGxhdF9yYWQpICsgKDEgLyBNYXRoLmNvcyhsYXRfcmFkKSkpIC8gTWF0aC5QSSkgLyAyLjAgKiBuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwieHRpbGVcIjogeHRpbGUsXG4gICAgICAgICAgICBcInl0aWxlXCI6IHl0aWxlXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJhZDJudW0oKTogZ2V0IHRoZSB0aWxlIG51bWJlciBvZiB0aGUgdGlsZSBjb250YWluaW5nIGEgcG9pbnRcbiAgICAgKiAgaW4gYSBjZXJ0YWluIGxldmVsIG9mIHpvb21cbiAgICAgKiAgICAgIC0gbGF0X3JhZDogbGF0aXR1ZGUgIGNvb3JkaW5hdGUgb2YgcG9pbnQgKGluIHJhZGlhbnMpXG4gICAgICogICAgICAtIGxuZ19yYWQ6IGxvbmdpdHVkZSBjb29yZGluYXRlIG9mIHBvaW50IChpbiByYWRpYW5zKVxuICAgICAqICAgICAgLSB6b29tOiB6b29tIGxldmVsXG4gICAgICovXG4gICAgUkFORE8uVXRpbHMucmFkMm51bSA9IGZ1bmN0aW9uIChsYXRfcmFkLCBsbmdfcmFkLCB6b29tKSB7XG4gICAgICAgIHZhciBsYXRfZGVnID0gbGF0X3JhZCoxODAvTWF0aC5QSTtcbiAgICAgICAgdmFyIGxuZ19kZWcgPSBsbmdfcmFkKjE4MC9NYXRoLlBJO1xuICAgICAgICB2YXIgbiA9IE1hdGgucG93KDIuMCwgem9vbSk7XG4gICAgICAgIHZhciB4dGlsZSA9IE1hdGguZmxvb3IoKGxuZ19kZWcgKyAxODAuMCkgLyAzNjAuMCAqIG4pO1xuICAgICAgICB2YXIgeXRpbGUgPSBNYXRoLmZsb29yKCgxLjAgLSBNYXRoLmxvZyhNYXRoLnRhbihsYXRfcmFkKSArICgxIC8gTWF0aC5jb3MobGF0X3JhZCkpKSAvIE1hdGguUEkpIC8gMi4wICogbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInh0aWxlXCI6IHh0aWxlLFxuICAgICAgICAgICAgXCJ5dGlsZVwiOiB5dGlsZVxuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIC8qKioqICAgIFRSQU5TTEFUSU9OUyAgICAgKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKlxuICAgICAqIGRyYXBlUG9pbnQoKSA6IGRyYXBlIGEgcG9pbnQgb3ZlciB0aGUgZ3JvdW5kXG4gICAgICogICAgICAtIHBvaW50OiBwb2ludCB0byBkcmFwZVxuICAgICAqICAgICAgLSBkZW06IGdyb3VuZFxuICAgICAqL1xuICAgIFJBTkRPLlV0aWxzLmRyYXBlUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIGRlbSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpdDtcbiAgICAgICAgaWYgKHR5cGVvZihvZmZzZXQpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBkZW0uZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIHJheSA9ICBuZXcgQkFCWUxPTi5SYXkocG9pbnQsIEJBQllMT04uQXhpcy5ZKTtcbiAgICAgICAgZm9yIChpdCBpbiBjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHBpY2sgPSBjaGlsZHJlbltpdF0uaW50ZXJzZWN0cyhyYXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKHBpY2sucGlja2VkUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBwb2ludC55ID0gcGljay5waWNrZWRQb2ludC55ICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuIiwiLyohXG4gKiBWRVJTSU9OOiBiZXRhIDEuMy40XG4gKiBEQVRFOiAyMDE0LTExLTE1XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vd3d3LmdyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRcdHZhciBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfcjEgPSBbXSxcblx0XHRcdF9yMiA9IFtdLFxuXHRcdFx0X3IzID0gW10sXG5cdFx0XHRfY29yUHJvcHMgPSB7fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRTZWdtZW50ID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR0aGlzLmEgPSBhO1xuXHRcdFx0XHR0aGlzLmIgPSBiO1xuXHRcdFx0XHR0aGlzLmMgPSBjO1xuXHRcdFx0XHR0aGlzLmQgPSBkO1xuXHRcdFx0XHR0aGlzLmRhID0gZCAtIGE7XG5cdFx0XHRcdHRoaXMuY2EgPSBjIC0gYTtcblx0XHRcdFx0dGhpcy5iYSA9IGIgLSBhO1xuXHRcdFx0fSxcblx0XHRcdF9jb3JyZWxhdGUgPSBcIix4LHkseixsZWZ0LHRvcCxyaWdodCxib3R0b20sbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLHBhZGRpbmdMZWZ0LHBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20sYmFja2dyb3VuZFBvc2l0aW9uLGJhY2tncm91bmRQb3NpdGlvbl95LFwiLFxuXHRcdFx0Y3ViaWNUb1F1YWRyYXRpYyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0dmFyIHExID0ge2E6YX0sXG5cdFx0XHRcdFx0cTIgPSB7fSxcblx0XHRcdFx0XHRxMyA9IHt9LFxuXHRcdFx0XHRcdHE0ID0ge2M6ZH0sXG5cdFx0XHRcdFx0bWFiID0gKGEgKyBiKSAvIDIsXG5cdFx0XHRcdFx0bWJjID0gKGIgKyBjKSAvIDIsXG5cdFx0XHRcdFx0bWNkID0gKGMgKyBkKSAvIDIsXG5cdFx0XHRcdFx0bWFiYyA9IChtYWIgKyBtYmMpIC8gMixcblx0XHRcdFx0XHRtYmNkID0gKG1iYyArIG1jZCkgLyAyLFxuXHRcdFx0XHRcdG04ID0gKG1iY2QgLSBtYWJjKSAvIDg7XG5cdFx0XHRcdHExLmIgPSBtYWIgKyAoYSAtIG1hYikgLyA0O1xuXHRcdFx0XHRxMi5iID0gbWFiYyArIG04O1xuXHRcdFx0XHRxMS5jID0gcTIuYSA9IChxMS5iICsgcTIuYikgLyAyO1xuXHRcdFx0XHRxMi5jID0gcTMuYSA9IChtYWJjICsgbWJjZCkgLyAyO1xuXHRcdFx0XHRxMy5iID0gbWJjZCAtIG04O1xuXHRcdFx0XHRxNC5iID0gbWNkICsgKGQgLSBtY2QpIC8gNDtcblx0XHRcdFx0cTMuYyA9IHE0LmEgPSAocTMuYiArIHE0LmIpIC8gMjtcblx0XHRcdFx0cmV0dXJuIFtxMSwgcTIsIHEzLCBxNF07XG5cdFx0XHR9LFxuXHRcdFx0X2NhbGN1bGF0ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihhLCBjdXJ2aW5lc3MsIHF1YWQsIGJhc2ljLCBjb3JyZWxhdGUpIHtcblx0XHRcdFx0dmFyIGwgPSBhLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0aWkgPSAwLFxuXHRcdFx0XHRcdGNwMSA9IGFbMF0uYSxcblx0XHRcdFx0XHRpLCBwMSwgcDIsIHAzLCBzZWcsIG0xLCBtMiwgbW0sIGNwMiwgcWIsIHIxLCByMiwgdGw7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0XHRwMSA9IHNlZy5hO1xuXHRcdFx0XHRcdHAyID0gc2VnLmQ7XG5cdFx0XHRcdFx0cDMgPSBhW2lpKzFdLmQ7XG5cblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRyMSA9IF9yMVtpXTtcblx0XHRcdFx0XHRcdHIyID0gX3IyW2ldO1xuXHRcdFx0XHRcdFx0dGwgPSAoKHIyICsgcjEpICogY3VydmluZXNzICogMC4yNSkgLyAoYmFzaWMgPyAwLjUgOiBfcjNbaV0gfHwgMC41KTtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjEgIT09IDAgPyB0bCAvIHIxIDogMCkpO1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMiAhPT0gMCA/IHRsIC8gcjIgOiAwKSk7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgKCgobTIgLSBtMSkgKiAoKHIxICogMyAvIChyMSArIHIyKSkgKyAwLjUpIC8gNCkgfHwgMCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bTIgPSBwMiArIChwMyAtIHAyKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyBtMikgLyAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtMSArPSBtbTtcblx0XHRcdFx0XHRtMiArPSBtbTtcblxuXHRcdFx0XHRcdHNlZy5jID0gY3AyID0gbTE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IDApIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMSA9IHNlZy5hICsgKHNlZy5jIC0gc2VnLmEpICogMC42OyAvL2luc3RlYWQgb2YgcGxhY2luZyBiIG9uIGEgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBjIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VJbiBvciBFbGFzdGljLmVhc2VJbiB3aGljaCBnb2VzIEJFWU9ORCB0aGUgYmVnaW5uaW5nLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNlZy5kYSA9IHAyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmNhID0gY3AyIC0gcDE7XG5cdFx0XHRcdFx0c2VnLmJhID0gY3AxIC0gcDE7XG5cblx0XHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHAxLCBjcDEsIGNwMiwgcDIpO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0XHRcdGlpICs9IDQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlpKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3AxID0gbTI7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdHNlZy5iID0gY3AxO1xuXHRcdFx0XHRzZWcuYyA9IGNwMSArIChzZWcuZCAtIGNwMSkgKiAwLjQ7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGMgb24gZCBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGIgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZU91dCBvciBFbGFzdGljLmVhc2VPdXQgd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGVuZCwgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0c2VnLmRhID0gc2VnLmQgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmNhID0gc2VnLmMgLSBzZWcuYTtcblx0XHRcdFx0c2VnLmJhID0gY3AxIC0gc2VnLmE7XG5cdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0cWIgPSBjdWJpY1RvUXVhZHJhdGljKHNlZy5hLCBjcDEsIHNlZy5jLCBzZWcuZCk7XG5cdFx0XHRcdFx0YS5zcGxpY2UoaWksIDEsIHFiWzBdLCBxYlsxXSwgcWJbMl0sIHFiWzNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9wYXJzZUFuY2hvcnMgPSBmdW5jdGlvbih2YWx1ZXMsIHAsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGwsIGksIHAxLCBwMiwgcDMsIHRtcDtcblx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdFx0aSA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2ldW3BdKSApID09PSBcInN0cmluZ1wiKSBpZiAodG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzW2ldW3BdID0gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSk7IC8vYWNjb21tb2RhdGUgcmVsYXRpdmUgdmFsdWVzLiBEbyBpdCBpbmxpbmUgaW5zdGVhZCBvZiBicmVha2luZyBpdCBvdXQgaW50byBhIGZ1bmN0aW9uIGZvciBzcGVlZCByZWFzb25zXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMjtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0YVswXSA9IG5ldyBTZWdtZW50KHZhbHVlc1swXVtwXSwgMCwgMCwgdmFsdWVzWyhsIDwgLTEpID8gMCA6IDFdW3BdKTtcblx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cDEgPSB2YWx1ZXNbaV1bcF07XG5cdFx0XHRcdFx0cDIgPSB2YWx1ZXNbaSsxXVtwXTtcblx0XHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQocDEsIDAsIDAsIHAyKTtcblx0XHRcdFx0XHRpZiAoY29ycmVsYXRlKSB7XG5cdFx0XHRcdFx0XHRwMyA9IHZhbHVlc1tpKzJdW3BdO1xuXHRcdFx0XHRcdFx0X3IxW2ldID0gKF9yMVtpXSB8fCAwKSArIChwMiAtIHAxKSAqIChwMiAtIHAxKTtcblx0XHRcdFx0XHRcdF9yMltpXSA9IChfcjJbaV0gfHwgMCkgKyAocDMgLSBwMikgKiAocDMgLSBwMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbaV1bcF0sIDAsIDAsIHZhbHVlc1tpKzFdW3BdKTtcblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0YmV6aWVyVGhyb3VnaCA9IGZ1bmN0aW9uKHZhbHVlcywgY3VydmluZXNzLCBxdWFkcmF0aWMsIGJhc2ljLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdHByb3BzID0gW10sXG5cdFx0XHRcdFx0Zmlyc3QgPSBwcmVwZW5kIHx8IHZhbHVlc1swXSxcblx0XHRcdFx0XHRpLCBwLCBhLCBqLCByLCBsLCBzZWFtbGVzcywgbGFzdDtcblx0XHRcdFx0Y29ycmVsYXRlID0gKHR5cGVvZihjb3JyZWxhdGUpID09PSBcInN0cmluZ1wiKSA/IFwiLFwiK2NvcnJlbGF0ZStcIixcIiA6IF9jb3JyZWxhdGU7XG5cdFx0XHRcdGlmIChjdXJ2aW5lc3MgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGN1cnZpbmVzcyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlc1swXSkge1xuXHRcdFx0XHRcdHByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jaGVjayB0byBzZWUgaWYgdGhlIGxhc3QgYW5kIGZpcnN0IHZhbHVlcyBhcmUgaWRlbnRpY2FsICh3ZWxsLCB3aXRoaW4gMC4wNSkuIElmIHNvLCBtYWtlIHNlYW1sZXNzIGJ5IGFwcGVuZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSB2YWx1ZXMgYXJyYXkgYW5kIHRoZSAybmQtdG8tbGFzdCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGJlZ2lubmluZyAod2UnbGwgcmVtb3ZlIHRob3NlIHNlZ21lbnRzIGxhdGVyKVxuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0XHRzZWFtbGVzcyA9IHRydWU7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhmaXJzdFtwXSAtIGxhc3RbcF0pID4gMC4wNSkgeyAvL2J1aWxkIGluIGEgdG9sZXJhbmNlIG9mICsvLTAuMDUgdG8gYWNjb21tb2RhdGUgcm91bmRpbmcgZXJyb3JzLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCBhbiBvYmplY3QncyBwb3NpdGlvbiB0byA0Ljk0NSwgRmxhc2ggd2lsbCBtYWtlIGl0IDQuOVxuXHRcdFx0XHRcdFx0XHRzZWFtbGVzcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KCk7IC8vZHVwbGljYXRlIHRoZSBhcnJheSB0byBhdm9pZCBjb250YW1pbmF0aW5nIHRoZSBvcmlnaW5hbCB3aGljaCB0aGUgdXNlciBtYXkgYmUgcmV1c2luZyBmb3Igb3RoZXIgdHdlZW5zXG5cdFx0XHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMudW5zaGlmdChwcmVwZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlc1sxXSk7XG5cdFx0XHRcdFx0XHRwcmVwZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAzXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X3IxLmxlbmd0aCA9IF9yMi5sZW5ndGggPSBfcjMubGVuZ3RoID0gMDtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdF9jb3JQcm9wc1twXSA9IChjb3JyZWxhdGUuaW5kZXhPZihcIixcIitwK1wiLFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdG9ialtwXSA9IF9wYXJzZUFuY2hvcnModmFsdWVzLCBwLCBfY29yUHJvcHNbcF0sIHByZXBlbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBfcjEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRfcjFbaV0gPSBNYXRoLnNxcnQoX3IxW2ldKTtcblx0XHRcdFx0XHRfcjJbaV0gPSBNYXRoLnNxcnQoX3IyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWJhc2ljKSB7XG5cdFx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChfY29yUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRcdFx0YSA9IG9ialtwcm9wc1tpXV07XG5cdFx0XHRcdFx0XHRcdGwgPSBhLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRyID0gYVtqKzFdLmRhIC8gX3IyW2pdICsgYVtqXS5kYSAvIF9yMVtqXTtcblx0XHRcdFx0XHRcdFx0XHRfcjNbal0gPSAoX3IzW2pdIHx8IDApICsgciAqIHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSA9IF9yMy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfcjNbaV0gPSBNYXRoLnNxcnQoX3IzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0aiA9IHF1YWRyYXRpYyA/IDQgOiAxO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0YSA9IG9ialtwXTtcblx0XHRcdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyhhLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIF9jb3JQcm9wc1twXSk7IC8vdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCBfcGFyc2VBbmNob3JzKCkgYW5kIF9zZXRTZWdtZW50UmF0aW9zKCkgcmFuIGZpcnN0IHNvIHRoYXQgX3IxLCBfcjIsIGFuZCBfcjMgdmFsdWVzIGFyZSBwb3B1bGF0ZWQgZm9yIGFsbCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZSgwLCBqKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGEubGVuZ3RoIC0gaiwgaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQmV6aWVyRGF0YSA9IGZ1bmN0aW9uKHZhbHVlcywgdHlwZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR0eXBlID0gdHlwZSB8fCBcInNvZnRcIjtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdGluYyA9ICh0eXBlID09PSBcImN1YmljXCIpID8gMyA6IDIsXG5cdFx0XHRcdFx0c29mdCA9ICh0eXBlID09PSBcInNvZnRcIiksXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRhLCBiLCBjLCBkLCBjdXIsIGksIGosIGwsIHAsIGNudCwgdG1wO1xuXHRcdFx0XHRpZiAoc29mdCAmJiBwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZXMgPT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoIDwgaW5jICsgMSkgeyB0aHJvdyBcImludmFsaWQgQmV6aWVyIGRhdGFcIjsgfVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0b2JqW3BdID0gY3VyID0gW107XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRhID0gKHByZXBlbmQgPT0gbnVsbCkgPyB2YWx1ZXNbal1bcF0gOiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2pdW3BdKSApID09PSBcInN0cmluZ1wiICYmIHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpIDogTnVtYmVyKHRtcCk7XG5cdFx0XHRcdFx0XHRpZiAoc29mdCkgaWYgKGogPiAxKSBpZiAoaiA8IGwgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSAoYSArIGN1cltjbnQtMl0pIC8gMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSBhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsID0gY250IC0gaW5jICsgMTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqICs9IGluYykge1xuXHRcdFx0XHRcdFx0YSA9IGN1cltqXTtcblx0XHRcdFx0XHRcdGIgPSBjdXJbaisxXTtcblx0XHRcdFx0XHRcdGMgPSBjdXJbaisyXTtcblx0XHRcdFx0XHRcdGQgPSAoaW5jID09PSAyKSA/IDAgOiBjdXJbaiszXTtcblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSB0bXAgPSAoaW5jID09PSAzKSA/IG5ldyBTZWdtZW50KGEsIGIsIGMsIGQpIDogbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXIubGVuZ3RoID0gY250O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X2FkZEN1YmljTGVuZ3RocyA9IGZ1bmN0aW9uKGEsIHN0ZXBzLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHZhciBpbmMgPSAxIC8gcmVzb2x1dGlvbixcblx0XHRcdFx0XHRqID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0ZCwgZDEsIHMsIGRhLCBjYSwgYmEsIHAsIGksIGludiwgYmV6LCBpbmRleDtcblx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0YmV6ID0gYVtqXTtcblx0XHRcdFx0XHRzID0gYmV6LmE7XG5cdFx0XHRcdFx0ZGEgPSBiZXouZCAtIHM7XG5cdFx0XHRcdFx0Y2EgPSBiZXouYyAtIHM7XG5cdFx0XHRcdFx0YmEgPSBiZXouYiAtIHM7XG5cdFx0XHRcdFx0ZCA9IGQxID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHRcdFx0XHRcdFx0cCA9IGluYyAqIGk7XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gcDtcblx0XHRcdFx0XHRcdGQgPSBkMSAtIChkMSA9IChwICogcCAqIGRhICsgMyAqIGludiAqIChwICogY2EgKyBpbnYgKiBiYSkpICogcCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGogKiByZXNvbHV0aW9uICsgaSAtIDE7XG5cdFx0XHRcdFx0XHRzdGVwc1tpbmRleF0gPSAoc3RlcHNbaW5kZXhdIHx8IDApICsgZCAqIGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlTGVuZ3RoRGF0YSA9IGZ1bmN0aW9uKG9iaiwgcmVzb2x1dGlvbikge1xuXHRcdFx0XHRyZXNvbHV0aW9uID0gcmVzb2x1dGlvbiA+PiAwIHx8IDY7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0XHRcdGQgPSAwLFxuXHRcdFx0XHRcdHRvdGFsID0gMCxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSByZXNvbHV0aW9uIC0gMSxcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRcdGN1ckxTID0gW10sIC8vY3VycmVudCBsZW5ndGggc2VnbWVudHMgYXJyYXlcblx0XHRcdFx0XHRwLCBpLCBsLCBpbmRleDtcblx0XHRcdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0XHRcdF9hZGRDdWJpY0xlbmd0aHMob2JqW3BdLCBhLCByZXNvbHV0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRkICs9IE1hdGguc3FydChhW2ldKTtcblx0XHRcdFx0XHRpbmRleCA9IGkgJSByZXNvbHV0aW9uO1xuXHRcdFx0XHRcdGN1ckxTW2luZGV4XSA9IGQ7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdHRvdGFsICs9IGQ7XG5cdFx0XHRcdFx0XHRpbmRleCA9IChpIC8gcmVzb2x1dGlvbikgPj4gMDtcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2luZGV4XSA9IGN1ckxTO1xuXHRcdFx0XHRcdFx0bGVuZ3Roc1tpbmRleF0gPSB0b3RhbDtcblx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0Y3VyTFMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtsZW5ndGg6dG90YWwsIGxlbmd0aHM6bGVuZ3Rocywgc2VnbWVudHM6c2VnbWVudHN9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdEJlemllclBsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRcdHByb3BOYW1lOiBcImJlemllclwiLFxuXHRcdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0XHR2ZXJzaW9uOiBcIjEuMy40XCIsXG5cdFx0XHRcdFx0QVBJOiAyLFxuXHRcdFx0XHRcdGdsb2JhbDp0cnVlLFxuXG5cdFx0XHRcdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmICh2YXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0dmFycyA9IHt2YWx1ZXM6dmFyc307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9mdW5jID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9yb3VuZCA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMgPSBbXTtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWVSZXMgPSAodmFycy50aW1lUmVzb2x1dGlvbiA9PSBudWxsKSA/IDYgOiBwYXJzZUludCh2YXJzLnRpbWVSZXNvbHV0aW9uLCAxMCk7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFycy52YWx1ZXMgfHwgW10sXG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0ge30sXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IHZhbHVlc1swXSxcblx0XHRcdFx0XHRcdFx0YXV0b1JvdGF0ZSA9IHZhcnMuYXV0b1JvdGF0ZSB8fCB0d2Vlbi52YXJzLm9yaWVudFRvQmV6aWVyLFxuXHRcdFx0XHRcdFx0XHRwLCBpc0Z1bmMsIGksIGosIHByZXBlbmQ7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID8gKGF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkgPyBhdXRvUm90YXRlIDogW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsKChhdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIoYXV0b1JvdGF0ZSkgfHwgMCldXSA6IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdGlzRnVuYyA9IHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIik7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W3BdID0gKCFpc0Z1bmMpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXByZXBlbmQpIGlmIChmaXJzdFtwXSAhPT0gdmFsdWVzWzBdW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlcGVuZCA9IGZpcnN0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9iZXppZXJzID0gKHZhcnMudHlwZSAhPT0gXCJjdWJpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJxdWFkcmF0aWNcIiAmJiB2YXJzLnR5cGUgIT09IFwic29mdFwiKSA/IGJlemllclRocm91Z2godmFsdWVzLCBpc05hTih2YXJzLmN1cnZpbmVzcykgPyAxIDogdmFycy5jdXJ2aW5lc3MsIGZhbHNlLCAodmFycy50eXBlID09PSBcInRocnVCYXNpY1wiKSwgdmFycy5jb3JyZWxhdGUsIHByZXBlbmQpIDogX3BhcnNlQmV6aWVyRGF0YSh2YWx1ZXMsIHZhcnMudHlwZSwgZmlyc3QpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VnQ291bnQgPSB0aGlzLl9iZXppZXJzW3BdLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxkID0gX3BhcnNlTGVuZ3RoRGF0YSh0aGlzLl9iZXppZXJzLCB0aGlzLl90aW1lUmVzKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RoID0gbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGhzID0gbGQubGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHMgPSBsZC5zZWdtZW50cztcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSB0aGlzLl9saSA9IHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IHRoaXMuX2xlbmd0aHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IHRoaXMuX2N1clNlZ1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJlYyA9IDEgLyB0aGlzLl9jdXJTZWcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGF1dG9Sb3RhdGUgPSB0aGlzLl9hdXRvUm90YXRlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zID0gW107XG5cdFx0XHRcdFx0XHRcdGlmICghKGF1dG9Sb3RhdGVbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA9IFthdXRvUm90YXRlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gYXV0b1JvdGF0ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0gOiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXSA9IHRoaXMuX2Z1bmNbcF0gPyB0aGlzLl9mdW5jW3BdLmNhbGwodGhpcy5fdGFyZ2V0KSA6IHRoaXMuX3RhcmdldFtwXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRSYXRpbyA9IHR3ZWVuLnZhcnMucnVuQmFja3dhcmRzID8gMSA6IDA7IC8vd2UgZGV0ZXJtaW5lIHRoZSBzdGFydGluZyByYXRpbyB3aGVuIHRoZSB0d2VlbiBpbml0cyB3aGljaCBpcyBhbHdheXMgMCB1bmxlc3MgdGhlIHR3ZWVuIGhhcyBydW5CYWNrd2FyZHM6dHJ1ZSAoaW5kaWNhdGluZyBpdCdzIGEgZnJvbSgpIHR3ZWVuKSBpbiB3aGljaCBjYXNlIGl0J3MgMS5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnQ291bnQsXG5cdFx0XHRcdFx0XHRcdGZ1bmMgPSB0aGlzLl9mdW5jLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRcdFx0XHRcdG5vdFN0YXJ0ID0gKHYgIT09IHRoaXMuX3N0YXJ0UmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCwgaW52LCBpLCBwLCBiLCB0LCB2YWwsIGwsIGxlbmd0aHMsIGN1clNlZztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9ICh2IDwgMCkgPyAwIDogKHYgPj0gMSkgPyBzZWdtZW50cyAtIDEgOiAoc2VnbWVudHMgKiB2KSA+PiAwO1xuXHRcdFx0XHRcdFx0XHR0ID0gKHYgLSAoY3VySW5kZXggKiAoMSAvIHNlZ21lbnRzKSkpICogc2VnbWVudHM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGhzID0gdGhpcy5fbGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0Y3VyU2VnID0gdGhpcy5fY3VyU2VnO1xuXHRcdFx0XHRcdFx0XHR2ICo9IHRoaXMuX2xlbmd0aDtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX2xpO1xuXHRcdFx0XHRcdFx0XHQvL2ZpbmQgdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgKGlmIHRoZSBjdXJyZW50bHkgY2FjaGVkIG9uZSBpc24ndCBjb3JyZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX2wyICYmIGkgPCBzZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gc2VnbWVudHMgLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fbDIgPSBsZW5ndGhzWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IGxlbmd0aHNbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbKHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwKV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX2wxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9sMSA9IGxlbmd0aHNbLS1pXSkgPj0gdikgeyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX2wxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1sodGhpcy5fc2kgPSBjdXJTZWcubGVuZ3RoIC0gMSkgLSAxXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW3RoaXMuX3NpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdC8vbm93IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHN1Yi1zZWdtZW50ICh3ZSBzcGxpdCBpdCBpbnRvIHRoZSBudW1iZXIgb2YgcGllY2VzIHRoYXQgd2FzIGRlZmluZWQgYnkgXCJwcmVjaXNpb25cIiBhbmQgbWVhc3VyZWQgZWFjaCBvbmUpXG5cdFx0XHRcdFx0XHRcdHYgLT0gdGhpcy5fbDE7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9zaTtcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9zMiAmJiBpIDwgY3VyU2VnLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gY3VyU2VnLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9zMiA9IGN1clNlZ1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX3MxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9zMSA9IGN1clNlZ1stLWldKSA+PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX3MxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHQgPSAoaSArICh2IC0gdGhpcy5fczEpIC8gKHRoaXMuX3MyIC0gdGhpcy5fczEpKSAqIHRoaXMuX3ByZWM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gdDtcblxuXHRcdFx0XHRcdFx0aSA9IHRoaXMuX3Byb3BzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW3BdW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0dmFsID0gKHQgKiB0ICogYi5kYSArIDMgKiBpbnYgKiAodCAqIGIuY2EgKyBpbnYgKiBiLmJhKSkgKiB0ICsgYi5hO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fcm91bmRbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2F1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyID0gdGhpcy5fYXV0b1JvdGF0ZSxcblx0XHRcdFx0XHRcdFx0XHRiMiwgeDEsIHkxLCB4MiwgeTIsIGFkZCwgY29udjtcblx0XHRcdFx0XHRcdFx0aSA9IGFyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGFyW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdGFkZCA9IGFyW2ldWzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IChhcltpXVs0XSA9PT0gdHJ1ZSkgPyAxIDogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIyID0gdGhpcy5fYmV6aWVyc1thcltpXVsxXV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoYiAmJiBiMikgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGdvdCBvdmVyd3JpdHRlbi5cblx0XHRcdFx0XHRcdFx0XHRcdGIgPSBiW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdGIyID0gYjJbY3VySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR4MSA9IGIuYSArIChiLmIgLSBiLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyID0gYi5iICsgKGIuYyAtIGIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDEgKz0gKHgyIC0geDEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyICs9ICgoYi5jICsgKGIuZCAtIGIuYykgKiB0KSAtIHgyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHkxID0gYjIuYSArIChiMi5iIC0gYjIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgPSBiMi5iICsgKGIyLmMgLSBiMi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MSArPSAoeTIgLSB5MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgKz0gKChiMi5jICsgKGIyLmQgLSBiMi5jKSAqIHQpIC0geTIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gbm90U3RhcnQgPyBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogY29udiArIGFkZCA6IHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0cCA9IEJlemllclBsdWdpbi5wcm90b3R5cGU7XG5cblxuXHRcdEJlemllclBsdWdpbi5iZXppZXJUaHJvdWdoID0gYmV6aWVyVGhyb3VnaDtcblx0XHRCZXppZXJQbHVnaW4uY3ViaWNUb1F1YWRyYXRpYyA9IGN1YmljVG9RdWFkcmF0aWM7XG5cdFx0QmV6aWVyUGx1Z2luLl9hdXRvQ1NTID0gdHJ1ZTsgLy9pbmRpY2F0ZXMgdGhhdCB0aGlzIHBsdWdpbiBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgXCJjc3NcIiBvYmplY3QgdXNpbmcgdGhlIGF1dG9DU1MgZmVhdHVyZSBvZiBUd2VlbkxpdGVcblx0XHRCZXppZXJQbHVnaW4ucXVhZHJhdGljVG9DdWJpYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0XHRcdHJldHVybiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0fTtcblxuXHRcdEJlemllclBsdWdpbi5fY3NzUmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBDU1NQbHVnaW4gPSBfZ2xvYmFscy5DU1NQbHVnaW47XG5cdFx0XHRpZiAoIUNTU1BsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgX2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzLFxuXHRcdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5LFxuXHRcdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyxcblx0XHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW47XG5cdFx0XHRfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJlemllclwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHByb3AsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGUgPSB7dmFsdWVzOmV9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbiA9IG5ldyBCZXppZXJQbHVnaW4oKTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGUudmFsdWVzLFxuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXMgPSBbXSxcblx0XHRcdFx0XHR2ID0ge30sXG5cdFx0XHRcdFx0aSwgcCwgZGF0YTtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IF9wYXJzZVRvUHJveHkodCwgdmFsdWVzW2ldLCBjc3NwLCBwdCwgcGx1Z2luLCAobCAhPT0gaSkpO1xuXHRcdFx0XHRcdHBsdWdpblZhbHVlc1tpXSA9IGRhdGEuZW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiBlKSB7XG5cdFx0XHRcdFx0dltwXSA9IGVbcF07IC8vZHVwbGljYXRlIHRoZSB2YXJzIG9iamVjdCBiZWNhdXNlIHdlIG5lZWQgdG8gYWx0ZXIgc29tZSB0aGluZ3Mgd2hpY2ggd291bGQgY2F1c2UgcHJvYmxlbXMgaWYgdGhlIHVzZXIgcGxhbnMgdG8gcmV1c2UgdGhlIHNhbWUgdmFycyBvYmplY3QgZm9yIGFub3RoZXIgdHdlZW4uXG5cdFx0XHRcdH1cblx0XHRcdFx0di52YWx1ZXMgPSBwbHVnaW5WYWx1ZXM7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBcImJlemllclwiLCAwLCAwLCBkYXRhLnB0LCAyKTtcblx0XHRcdFx0cHQuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0UGx1Z2luUmF0aW87XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgPT09IDApIHtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgJiYgISh2LmF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRpID0gKHYuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKHYuYXV0b1JvdGF0ZSk7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gKGRhdGEuZW5kLmxlZnQgIT0gbnVsbCkgPyBbW1wibGVmdFwiLFwidG9wXCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IChkYXRhLmVuZC54ICE9IG51bGwpID8gW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGlmICghY3NzcC5fdHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5hdXRvUm90YXRlID0gY3NzcC5fdGFyZ2V0Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbHVnaW4uX29uSW5pdFR3ZWVuKGRhdGEucHJveHksIHYsIGNzc3AuX3R3ZWVuKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fX0pO1xuXHRcdH07XG5cblx0XHRwLl9yb3VuZFByb3BzID0gZnVuY3Rpb24obG9va3VwLCB2YWx1ZSkge1xuXHRcdFx0dmFyIG9wID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdGkgPSBvcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKGxvb2t1cFtvcFtpXV0gfHwgbG9va3VwLmJlemllciB8fCBsb29rdXAuYmV6aWVyVGhyb3VnaCkge1xuXHRcdFx0XHRcdHRoaXMuX3JvdW5kW29wW2ldXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fcHJvcHMsXG5cdFx0XHRcdHAsIGk7XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy5fYmV6aWVycykge1xuXHRcdFx0XHRpZiAocCBpbiBsb29rdXApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fYmV6aWVyc1twXTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZnVuY1twXTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gcCkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlci5fa2lsbC5jYWxsKHRoaXMsIGxvb2t1cCk7XG5cdFx0fTtcblxufSk7IGlmIChfZ3NTY29wZS5fZ3NEZWZpbmUpIHsgX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKTsgfVxuXG4vL2V4cG9ydCB0byBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlIChwcmVjdXJzb3IgdG8gZnVsbCBtb2R1bGFyIGJ1aWxkIHN5c3RlbSBjb21pbmcgYXQgYSBsYXRlciBkYXRlKVxuKGZ1bmN0aW9uKG5hbWUpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKF9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHMgfHwgX2dzU2NvcGUpW25hbWVdO1xuXHR9O1xuXHRpZiAodHlwZW9mKGRlZmluZSkgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7IC8vQU1EXG5cdFx0ZGVmaW5lKFtcIlR3ZWVuTGl0ZVwiXSwgZ2V0R2xvYmFsKTtcblx0fSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykgeyAvL25vZGVcblx0XHRyZXF1aXJlKFwiLi4vVHdlZW5MaXRlLmpzXCIpO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2V0R2xvYmFsKCk7XG5cdH1cbn0oXCJCZXppZXJQbHVnaW5cIikpO1xuIiwiLyohXG4gKiBWRVJTSU9OOiBiZXRhIDAuMi4xXG4gKiBEQVRFOiAyMDE0LTA3LTE3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vd3d3LmdyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsXG5cdFx0dmVyc2lvbjogXCIwLjIuMVwiLFxuXHRcdEFQSTogMixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhbHVlID0ge3JvdGF0aW9uOnZhbHVlfTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluYWxzID0ge307XG5cdFx0XHR2YXIgY2FwID0gKHZhbHVlLnVzZVJhZGlhbnMgPT09IHRydWUpID8gTWF0aC5QSSAqIDIgOiAzNjAsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRwLCB2LCBzdGFydCwgZW5kLCBkaWYsIHNwbGl0O1xuXHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChwICE9PSBcInVzZVJhZGlhbnNcIikge1xuXHRcdFx0XHRcdHNwbGl0ID0gKHZhbHVlW3BdICsgXCJcIikuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdHYgPSBzcGxpdFswXTtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlRmxvYXQoICh0eXBlb2YodGFyZ2V0W3BdKSAhPT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFtwXSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKSApO1xuXHRcdFx0XHRcdGVuZCA9IHRoaXMuZmluYWxzW3BdID0gKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gc3RhcnQgKyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodi5zdWJzdHIoMikpIDogTnVtYmVyKHYpIHx8IDA7XG5cdFx0XHRcdFx0ZGlmID0gZW5kIC0gc3RhcnQ7XG5cdFx0XHRcdFx0aWYgKHNwbGl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0diA9IHNwbGl0LmpvaW4oXCJfXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcInNob3J0XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSBkaWYgJSBjYXA7XG5cdFx0XHRcdFx0XHRcdGlmIChkaWYgIT09IGRpZiAlIChjYXAgLyAyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpZiA9IChkaWYgPCAwKSA/IGRpZiArIGNhcCA6IGRpZiAtIGNhcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHYuaW5kZXhPZihcIl9jd1wiKSAhPT0gLTEgJiYgZGlmIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiArIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCJjY3dcIikgIT09IC0xICYmIGRpZiA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgLSBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpZiA+IG1pbiB8fCBkaWYgPCAtbWluKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHN0YXJ0LCBzdGFydCArIGRpZiwgcCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vY2FsbGVkIGVhY2ggdGltZSB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkLCBhbmQgdGhlIHJhdGlvIGdldHMgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlciAodHlwaWNhbGx5IGl0J3MgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBpdCBjYW4gZXhjZWVkIHRob3NlIHdoZW4gdXNpbmcgYW4gZWFzZSBsaWtlIEVsYXN0aWMuZWFzZU91dCBvciBCYWNrLmVhc2VPdXQsIGV0Yy4pXG5cdFx0c2V0OiBmdW5jdGlvbihyYXRpbykge1xuXHRcdFx0dmFyIHB0O1xuXHRcdFx0aWYgKHJhdGlvICE9PSAxKSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyLnNldFJhdGlvLmNhbGwodGhpcywgcmF0aW8pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSh0aGlzLmZpbmFsc1twdC5wXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB0aGlzLmZpbmFsc1twdC5wXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHR9KS5fYXV0b0NTUyA9IHRydWU7XG5cbn0pOyBpZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH0iLCIvKiFcbiAqIFZFUlNJT046IGJldGEgMS4xNS4yXG4gKiBEQVRFOiAyMDE1LTAxLTI3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqKi9cbnZhciBfZ3NTY29wZSA9ICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YoZ2xvYmFsKSAhPT0gXCJ1bmRlZmluZWRcIikgPyBnbG9iYWwgOiB0aGlzIHx8IHdpbmRvdzsgLy9oZWxwcyBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIEFNRC9SZXF1aXJlSlMgYW5kIENvbW1vbkpTL05vZGVcbihfZ3NTY29wZS5fZ3NRdWV1ZSB8fCAoX2dzU2NvcGUuX2dzUXVldWUgPSBbXSkpLnB1c2goIGZ1bmN0aW9uKCkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcImVhc2luZy5CYWNrXCIsIFtcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihFYXNlKSB7XG5cdFx0XG5cdFx0dmFyIHcgPSAoX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFscyB8fCBfZ3NTY29wZSksXG5cdFx0XHRncyA9IHcuY29tLmdyZWVuc29jayxcblx0XHRcdF8yUEkgPSBNYXRoLlBJICogMixcblx0XHRcdF9IQUxGX1BJID0gTWF0aC5QSSAvIDIsXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MsXG5cdFx0XHRfY3JlYXRlID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKCl7fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgfHwgZnVuY3Rpb24oKXt9LCAvL3B1dCBhbiBlbXB0eSBmdW5jdGlvbiBpbiBwbGFjZSBqdXN0IGFzIGEgc2FmZXR5IG1lYXN1cmUgaW4gY2FzZSBzb21lb25lIGxvYWRzIGFuIE9MRCB2ZXJzaW9uIG9mIFR3ZWVuTGl0ZS5qcyB3aGVyZSBFYXNlLnJlZ2lzdGVyIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRfd3JhcCA9IGZ1bmN0aW9uKG5hbWUsIEVhc2VPdXQsIEVhc2VJbiwgRWFzZUluT3V0LCBhbGlhc2VzKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIHtcblx0XHRcdFx0XHRlYXNlT3V0Om5ldyBFYXNlT3V0KCksXG5cdFx0XHRcdFx0ZWFzZUluOm5ldyBFYXNlSW4oKSxcblx0XHRcdFx0XHRlYXNlSW5PdXQ6bmV3IEVhc2VJbk91dCgpXG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0XHRfZWFzZVJlZyhDLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0RWFzZVBvaW50ID0gZnVuY3Rpb24odGltZSwgdmFsdWUsIG5leHQpIHtcblx0XHRcdFx0dGhpcy50ID0gdGltZTtcblx0XHRcdFx0dGhpcy52ID0gdmFsdWU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuYyA9IG5leHQudiAtIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuZ2FwID0gbmV4dC50IC0gdGltZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9CYWNrXG5cdFx0XHRfY3JlYXRlQmFjayA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3AxID0gKG92ZXJzaG9vdCB8fCBvdmVyc2hvb3QgPT09IDApID8gb3ZlcnNob290IDogMS43MDE1ODtcblx0XHRcdFx0XHRcdHRoaXMuX3AyID0gdGhpcy5fcDEgKiAxLjUyNTtcblx0XHRcdFx0XHR9LCB0cnVlKSwgXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQyhvdmVyc2hvb3QpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cblx0XHRcdEJhY2sgPSBfd3JhcChcIkJhY2tcIixcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwID0gcCAtIDEpICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgKyB0aGlzLl9wMSkgKyAxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gcCAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwIC0gdGhpcy5fcDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIHAgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCAtIHRoaXMuX3AyKSA6IDAuNSAqICgocCAtPSAyKSAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwICsgdGhpcy5fcDIpICsgMik7XG5cdFx0XHRcdH0pXG5cdFx0XHQpLFxuXG5cblx0XHRcdC8vU2xvd01vXG5cdFx0XHRTbG93TW8gPSBfY2xhc3MoXCJlYXNpbmcuU2xvd01vXCIsIGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdFx0cG93ZXIgPSAocG93ZXIgfHwgcG93ZXIgPT09IDApID8gcG93ZXIgOiAwLjc7XG5cdFx0XHRcdGlmIChsaW5lYXJSYXRpbyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAwLjc7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZWFyUmF0aW8gPiAxKSB7XG5cdFx0XHRcdFx0bGluZWFyUmF0aW8gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3AgPSAobGluZWFyUmF0aW8gIT09IDEpID8gcG93ZXIgOiAwO1xuXHRcdFx0XHR0aGlzLl9wMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMjtcblx0XHRcdFx0dGhpcy5fcDIgPSBsaW5lYXJSYXRpbztcblx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMSArIHRoaXMuX3AyO1xuXHRcdFx0XHR0aGlzLl9jYWxjRW5kID0gKHlveW9Nb2RlID09PSB0cnVlKTtcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0cCA9IFNsb3dNby5wcm90b3R5cGUgPSBuZXcgRWFzZSgpLFxuXHRcdFx0U3RlcHBlZEVhc2UsIFJvdWdoRWFzZSwgX2NyZWF0ZUVsYXN0aWM7XG5cdFx0XHRcblx0XHRwLmNvbnN0cnVjdG9yID0gU2xvd01vO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHR2YXIgciA9IHAgKyAoMC41IC0gcCkgKiB0aGlzLl9wO1xuXHRcdFx0aWYgKHAgPCB0aGlzLl9wMSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCkgOiByIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHAgKiBwICogcCAqIHIpO1xuXHRcdFx0fSBlbHNlIGlmIChwID4gdGhpcy5fcDMpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgOiByICsgKChwIC0gcikgKiAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCAqIHAgKiBwKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSA6IHI7XG5cdFx0fTtcblx0XHRTbG93TW8uZWFzZSA9IG5ldyBTbG93TW8oMC43LCAwLjcpO1xuXHRcdFxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0XHRzdGVwcyA9IHN0ZXBzIHx8IDE7XG5cdFx0XHRcdHRoaXMuX3AxID0gMSAvIHN0ZXBzO1xuXHRcdFx0XHR0aGlzLl9wMiA9IHN0ZXBzICsgMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdHAgPSBTdGVwcGVkRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1x0XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFN0ZXBwZWRFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAocCA8IDApIHtcblx0XHRcdFx0cCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPj0gMSkge1xuXHRcdFx0XHRwID0gMC45OTk5OTk5OTk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCh0aGlzLl9wMiAqIHApID4+IDApICogdGhpcy5fcDE7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IFN0ZXBwZWRFYXNlLmNvbmZpZyA9IGZ1bmN0aW9uKHN0ZXBzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN0ZXBwZWRFYXNlKHN0ZXBzKTtcblx0XHR9O1xuXG5cblx0XHQvL1JvdWdoRWFzZVxuXHRcdFJvdWdoRWFzZSA9IF9jbGFzcyhcImVhc2luZy5Sb3VnaEVhc2VcIiwgZnVuY3Rpb24odmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgdGFwZXIgPSB2YXJzLnRhcGVyIHx8IFwibm9uZVwiLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHBvaW50cyA9ICh2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuXHRcdFx0XHRpID0gcG9pbnRzLFxuXHRcdFx0XHRyYW5kb21pemUgPSAodmFycy5yYW5kb21pemUgIT09IGZhbHNlKSxcblx0XHRcdFx0Y2xhbXAgPSAodmFycy5jbGFtcCA9PT0gdHJ1ZSksXG5cdFx0XHRcdHRlbXBsYXRlID0gKHZhcnMudGVtcGxhdGUgaW5zdGFuY2VvZiBFYXNlKSA/IHZhcnMudGVtcGxhdGUgOiBudWxsLFxuXHRcdFx0XHRzdHJlbmd0aCA9ICh0eXBlb2YodmFycy5zdHJlbmd0aCkgPT09IFwibnVtYmVyXCIpID8gdmFycy5zdHJlbmd0aCAqIDAuNCA6IDAuNCxcblx0XHRcdFx0eCwgeSwgYnVtcCwgaW52WCwgb2JqLCBwbnQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0eCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAoMSAvIHBvaW50cykgKiBpO1xuXHRcdFx0XHR5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZS5nZXRSYXRpbyh4KSA6IHg7XG5cdFx0XHRcdGlmICh0YXBlciA9PT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRidW1wID0gc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwib3V0XCIpIHtcblx0XHRcdFx0XHRpbnZYID0gMSAtIHg7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGFwZXIgPT09IFwiaW5cIikge1xuXHRcdFx0XHRcdGJ1bXAgPSB4ICogeCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHggPCAwLjUpIHsgIC8vXCJib3RoXCIgKHN0YXJ0KVxuXHRcdFx0XHRcdGludlggPSB4ICogMjtcblx0XHRcdFx0XHRidW1wID0gaW52WCAqIGludlggKiAwLjUgKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHRcdC8vXCJib3RoXCIgKGVuZClcblx0XHRcdFx0XHRpbnZYID0gKDEgLSB4KSAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJhbmRvbWl6ZSkge1xuXHRcdFx0XHRcdHkgKz0gKE1hdGgucmFuZG9tKCkgKiBidW1wKSAtIChidW1wICogMC41KTtcblx0XHRcdFx0fSBlbHNlIGlmIChpICUgMikge1xuXHRcdFx0XHRcdHkgKz0gYnVtcCAqIDAuNTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5IC09IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsYW1wKSB7XG5cdFx0XHRcdFx0aWYgKHkgPiAxKSB7XG5cdFx0XHRcdFx0XHR5ID0gMTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPCAwKSB7XG5cdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtjbnQrK10gPSB7eDp4LCB5Onl9O1xuXHRcdFx0fVxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEueCAtIGIueDtcblx0XHRcdH0pO1xuXG5cdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuXHRcdFx0aSA9IHBvaW50cztcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRvYmogPSBhW2ldO1xuXHRcdFx0XHRwbnQgPSBuZXcgRWFzZVBvaW50KG9iai54LCBvYmoueSwgcG50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcHJldiA9IG5ldyBFYXNlUG9pbnQoMCwgMCwgKHBudC50ICE9PSAwKSA/IHBudCA6IHBudC5uZXh0KTtcblx0XHR9LCB0cnVlKTtcblx0XHRwID0gUm91Z2hFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFJvdWdoRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHBudCA9IHRoaXMuX3ByZXY7XG5cdFx0XHRpZiAocCA+IHBudC50KSB7XG5cdFx0XHRcdHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG5cdFx0XHRcdFx0cG50ID0gcG50Lm5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG50ID0gcG50LnByZXY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAocG50LnByZXYgJiYgcCA8PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9wcmV2ID0gcG50O1xuXHRcdFx0cmV0dXJuIChwbnQudiArICgocCAtIHBudC50KSAvIHBudC5nYXApICogcG50LmMpO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJvdWdoRWFzZSh2YXJzKTtcblx0XHR9O1xuXHRcdFJvdWdoRWFzZS5lYXNlID0gbmV3IFJvdWdoRWFzZSgpO1xuXG5cblx0XHQvL0JvdW5jZVxuXHRcdF93cmFwKFwiQm91bmNlXCIsXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoKHAgPSAxIC0gcCkgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIHAgKiBwKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1KTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAxIC0gKDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzUpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiQm91bmNlSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHR2YXIgaW52ZXJ0ID0gKHAgPCAwLjUpO1xuXHRcdFx0XHRpZiAoaW52ZXJ0KSB7XG5cdFx0XHRcdFx0cCA9IDEgLSAocCAqIDIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSAocCAqIDIpIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocCA8IDEgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIHAgKiBwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAxLjUgLyAyLjc1KSAqIHAgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAgPCAyLjUgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuMjUgLyAyLjc1KSAqIHAgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cCA9IDcuNTYyNSAqIChwIC09IDIuNjI1IC8gMi43NSkgKiBwICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGludmVydCA/ICgxIC0gcCkgKiAwLjUgOiBwICogMC41ICsgMC41O1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0NJUkNcblx0XHRfd3JhcChcIkNpcmNcIixcblx0XHRcdF9jcmVhdGUoXCJDaXJjT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHAgPSBwIC0gMSkgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKE1hdGguc3FydCgxIC0gKHAgKiBwKSkgLSAxKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkNpcmNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAqPTIpIDwgMSkgPyAtMC41ICogKE1hdGguc3FydCgxIC0gcCAqIHApIC0gMSkgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAocCAtPSAyKSAqIHApICsgMSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vRWxhc3RpY1xuXHRcdF9jcmVhdGVFbGFzdGljID0gZnVuY3Rpb24obiwgZiwgZGVmKSB7XG5cdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdFx0dGhpcy5fcDEgPSAoYW1wbGl0dWRlID49IDEpID8gYW1wbGl0dWRlIDogMTsgLy9ub3RlOiBpZiBhbXBsaXR1ZGUgaXMgPCAxLCB3ZSBzaW1wbHkgYWRqdXN0IHRoZSBwZXJpb2QgZm9yIGEgbW9yZSBuYXR1cmFsIGZlZWwuIE90aGVyd2lzZSB0aGUgbWF0aCBkb2Vzbid0IHdvcmsgcmlnaHQgYW5kIHRoZSBjdXJ2ZSBzdGFydHMgYXQgMS5cblx0XHRcdFx0XHR0aGlzLl9wMiA9IChwZXJpb2QgfHwgZGVmKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSk7XG5cdFx0XHRcdFx0dGhpcy5fcDMgPSB0aGlzLl9wMiAvIF8yUEkgKiAoTWF0aC5hc2luKDEgLyB0aGlzLl9wMSkgfHwgMCk7XG5cdFx0XHRcdFx0dGhpcy5fcDIgPSBfMlBJIC8gdGhpcy5fcDI7IC8vcHJlY2FsY3VsYXRlIHRvIG9wdGltaXplXG5cdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24oYW1wbGl0dWRlLCBwZXJpb2QpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDKGFtcGxpdHVkZSwgcGVyaW9kKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gQztcblx0XHR9O1xuXHRcdF93cmFwKFwiRWxhc3RpY1wiLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3AxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApICsgMTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMiApKTtcblx0XHRcdH0sIDAuMyksXG5cdFx0XHRfY3JlYXRlRWxhc3RpYyhcIkVsYXN0aWNJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IC0wLjUgKiAodGhpcy5fcDEgKiBNYXRoLnBvdygyLCAxMCAqIChwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyKSkgOiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSAqIDAuNSArIDE7XG5cdFx0XHR9LCAwLjQ1KVxuXHRcdCk7XG5cblxuXHRcdC8vRXhwb1xuXHRcdF93cmFwKFwiRXhwb1wiLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHApO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiRXhwb0luXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgLSAwLjAwMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9Jbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAoKHAgKj0gMikgPCAxKSA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9TaW5lXG5cdFx0X3dyYXAoXCJTaW5lXCIsXG5cdFx0XHRfY3JlYXRlKFwiU2luZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNpbihwICogX0hBTEZfUEkpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlKFwiU2luZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIC1NYXRoLmNvcyhwICogX0hBTEZfUEkpICsgMTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiBwKSAtIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0X2NsYXNzKFwiZWFzaW5nLkVhc2VMb29rdXBcIiwge1xuXHRcdFx0XHRmaW5kOmZ1bmN0aW9uKHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gRWFzZS5tYXBbc107XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpO1xuXG5cdFx0Ly9yZWdpc3RlciB0aGUgbm9uLXN0YW5kYXJkIGVhc2VzXG5cdFx0X2Vhc2VSZWcody5TbG93TW8sIFwiU2xvd01vXCIsIFwiZWFzZSxcIik7XG5cdFx0X2Vhc2VSZWcoUm91Z2hFYXNlLCBcIlJvdWdoRWFzZVwiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFN0ZXBwZWRFYXNlLCBcIlN0ZXBwZWRFYXNlXCIsIFwiZWFzZSxcIik7XG5cdFx0XG5cdFx0cmV0dXJuIEJhY2s7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG59KTsgaWYgKF9nc1Njb3BlLl9nc0RlZmluZSkgeyBfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpOyB9IiwiLyohXG4gKiBWRVJTSU9OOiAxLjE2LjFcbiAqIERBVEU6IDIwMTUtMDMtMTNcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVMaXRlID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRTaW1wbGVUaW1lbGluZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAodGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbiA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAodGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fc29ydENoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRcdHZhbCwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHYpIHtcblx0XHRcdFx0XHR2YWwgPSB2W3BdO1xuXHRcdFx0XHRcdGlmIChfaXNBcnJheSh2YWwpKSBpZiAodmFsLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHZbcF0gPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNBcnJheSh2LnR3ZWVucykpIHtcblx0XHRcdFx0XHR0aGlzLmFkZCh2LnR3ZWVucywgMCwgdi5hbGlnbiwgdi5zdGFnZ2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaW50ZXJuYWxzID0gVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMgPSB7fSxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9jb3B5ID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHR2YXIgY29weSA9IHt9LCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb3B5O1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZUNhbGxiYWNrID0gX2ludGVybmFscy5wYXVzZUNhbGxiYWNrID0gZnVuY3Rpb24odHdlZW4sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0aW1lID0gdGwuX3RvdGFsVGltZSxcblx0XHRcdFx0XHRzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lLFxuXHRcdFx0XHRcdHJldmVyc2VkID0gKHR3ZWVuLl9yYXdQcmV2VGltZSA8IDAgfHwgKHR3ZWVuLl9yYXdQcmV2VGltZSA9PT0gMCAmJiB0bC5fcmV2ZXJzZWQpKSwvL2Rvbid0IHVzZSB0d2Vlbi5yYXRpbyBiZWNhdXNlIGlmIHRoZSBwbGF5aGVhZCBsYW5kcyBleGFjdGx5IG9uIHRvcCBvZiB0aGUgYWRkUGF1c2UoKSwgcmF0aW8gd2lsbCBiZSAxIGV2ZW4gaWYgdGhlIG1hc3RlciB0aW1lbGluZSB3YXMgcmV2ZXJzZWQgKHdoaWNoIGlzIGNvcnJlY3QpLiBUaGUga2V5IGhlcmUgaXMgdG8gc2Vuc2UgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGxheWhlYWQuXG5cdFx0XHRcdFx0bmV4dCA9IHJldmVyc2VkID8gMCA6IF90aW55TnVtLFxuXHRcdFx0XHRcdHByZXYgPSByZXZlcnNlZCA/IF90aW55TnVtIDogMCxcblx0XHRcdFx0XHRzaWJsaW5nO1xuXHRcdFx0XHRpZiAoY2FsbGJhY2sgfHwgIXRoaXMuX2ZvcmNpbmdQbGF5aGVhZCkgeyAvL2lmIHRoZSB1c2VyIGNhbGxzIGEgbWV0aG9kIHRoYXQgbW92ZXMgdGhlIHBsYXloZWFkIChsaWtlIHByb2dyZXNzKCkgb3IgdGltZSgpKSwgaXQgc2hvdWxkIGhvbm9yIHRoYXQgYW5kIHNraXAgYW55IHBhdXNlcyAoYWx0aG91Z2ggaWYgdGhlcmUncyBhIGNhbGxiYWNrIHBvc2l0aW9uZWQgYXQgdGhhdCBwYXVzZSwgaXQgbXVzdCBqdW1wIHRoZXJlIGFuZCBtYWtlIHRoZSBjYWxsIHRvIGVuc3VyZSB0aGUgdGltZSBpcyBFWEFDVExZIHdoYXQgaXQgaXMgc3VwcG9zZWQgdG8gYmUsIGFuZCB0aGVuIHByb2NlZWQgdG8gd2hlcmUgdGhlIHBsYXloZWFkIGlzIGJlaW5nIGZvcmNlZCkuIE90aGVyd2lzZSwgaW1hZ2luZSBwbGFjaW5nIGEgcGF1c2UgaW4gdGhlIG1pZGRsZSBvZiBhIHRpbWVsaW5lIGFuZCB0aGVuIGRvaW5nIHRpbWVsaW5lLnByb2dyZXNzKDAuOSkgLSBpdCB3b3VsZCBnZXQgc3R1Y2sgd2hlcmUgdGhlIHBhdXNlIGlzLlxuXHRcdFx0XHRcdHRsLnBhdXNlKHN0YXJ0VGltZSk7XG5cdFx0XHRcdFx0Ly9ub3cgZmluZCBzaWJsaW5nIHR3ZWVucyB0aGF0IGFyZSBFWEFDVExZIGF0IHRoZSBzYW1lIHNwb3Qgb24gdGhlIHRpbWVsaW5lIGFuZCBhZGp1c3QgdGhlIF9yYXdQcmV2VGltZSBzbyB0aGF0IHRoZXkgZmlyZSAob3IgZG9uJ3QgZmlyZSkgY29ycmVjdGx5IG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpcyBpcyBwcmltYXJpbHkgdG8gYWNjb21tb2RhdGUgemVyby1kdXJhdGlvbiB0d2VlbnMvY2FsbGJhY2tzIHRoYXQgYXJlIHBvc2l0aW9uZWQgcmlnaHQgb24gdG9wIG9mIGEgcGF1c2UuIEZvciBleGFtcGxlLCB0bC50byguLi4pLmNhbGwoLi4uKS5hZGRQYXVzZSguLi4pLmNhbGwoLi4uKSAtIG5vdGljZSB0aGF0IHRoZXJlJ3MgYSBjYWxsKCkgb24gZWFjaCBzaWRlIG9mIHRoZSBwYXVzZSwgc28gd2hlbiBpdCdzIHJ1bm5pbmcgZm9yd2FyZCBpdCBzaG91bGQgY2FsbCB0aGUgZmlyc3Qgb25lIGFuZCB0aGVuIHBhdXNlLCBhbmQgdGhlbiB3aGVuIHJlc3VtZWQsIGNhbGwgdGhlIG90aGVyLiBaZXJvLWR1cmF0aW9uIHR3ZWVucyB1c2UgX3Jhd1ByZXZUaW1lIHRvIHNlbnNlIG1vbWVudHVtIGZpZ3VyZSBvdXQgaWYgZXZlbnRzIHdlcmUgc3VwcHJlc3NlZCB3aGVuIGFycml2aW5nIGRpcmVjdGx5IG9uIHRvcCBvZiB0aGF0IHRpbWUuXG5cdFx0XHRcdFx0c2libGluZyA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmcuX3N0YXJ0VGltZSA9PT0gc3RhcnRUaW1lKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5nLl9yYXdQcmV2VGltZSA9IHByZXY7XG5cdFx0XHRcdFx0XHRzaWJsaW5nID0gc2libGluZy5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2libGluZyA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmcuX3N0YXJ0VGltZSA9PT0gc3RhcnRUaW1lKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5nLl9yYXdQcmV2VGltZSA9IG5leHQ7XG5cdFx0XHRcdFx0XHRzaWJsaW5nID0gc2libGluZy5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShzY29wZSB8fCB0bCwgcGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCB8fCAhdGwuX3BhdXNlZCkgeyAvL3RoZSBjYWxsYmFjayBjb3VsZCBoYXZlIGNhbGxlZCByZXN1bWUoKS5cblx0XHRcdFx0XHRcdHRsLnNlZWsodGltZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdHAgPSBUaW1lbGluZUxpdGUucHJvdG90eXBlID0gbmV3IFNpbXBsZVRpbWVsaW5lKCk7XG5cblx0XHRUaW1lbGluZUxpdGUudmVyc2lvbiA9IFwiMS4xNi4xXCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTGl0ZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBwLl9mb3JjaW5nUGxheWhlYWQgPSBmYWxzZTtcblxuXHRcdC8qIG1pZ2h0IHVzZSBsYXRlci4uLlxuXHRcdC8vdHJhbnNsYXRlcyBhIGxvY2FsIHRpbWUgaW5zaWRlIGFuIGFuaW1hdGlvbiB0byB0aGUgY29ycmVzcG9uZGluZyB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzLlxuXHRcdGZ1bmN0aW9uIGxvY2FsVG9HbG9iYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRpbWUgPSAodGltZSAvIGFuaW1hdGlvbi5fdGltZVNjYWxlKSArIGFuaW1hdGlvbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZTtcblx0XHR9XG5cblx0XHQvL3RyYW5zbGF0ZXMgdGhlIHN1cHBsaWVkIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdGltZSBpbnNpZGUgYSBwYXJ0aWN1bGFyIGFuaW1hdGlvbiwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzXG5cdFx0ZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzY2FsZSA9IDE7XG5cdFx0XHR0aW1lIC09IGxvY2FsVG9HbG9iYWwoMCwgYW5pbWF0aW9uKTtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0c2NhbGUgKj0gYW5pbWF0aW9uLl90aW1lU2NhbGU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lICogc2NhbGU7XG5cdFx0fVxuXHRcdCovXG5cblx0XHRwLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBuZXcgRW5naW5lKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggKCh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlKS5mcm9tKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodG9WYXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIEVuZ2luZS5mcm9tVG8odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdG9WYXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlclRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUoe29uQ29tcGxldGU6b25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZVBhcmFtczpvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlU2NvcGU6b25Db21wbGV0ZUFsbFNjb3BlLCBzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSksXG5cdFx0XHRcdGk7XG5cdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7IC8vc2Vuc2VzIGlmIHRoZSB0YXJnZXRzIG9iamVjdCBpcyBhIHNlbGVjdG9yLiBJZiBpdCBpcywgd2Ugc2hvdWxkIHRyYW5zbGF0ZSBpdCBpbnRvIGFuIGFycmF5LlxuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0fVxuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh2YXJzLnN0YXJ0QXQpIHtcblx0XHRcdFx0XHR2YXJzLnN0YXJ0QXQgPSBfY29weSh2YXJzLnN0YXJ0QXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsLnRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBfY29weSh2YXJzKSwgaSAqIHN0YWdnZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHRsLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUpO1xuXHRcdFx0aWYgKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAocG9zaXRpb24gPT09IHRoaXMuX3RpbWUgJiYgIXRoaXMuX3BhdXNlZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCA9IGZ1bmN0aW9uKHZhcnMsIGlnbm9yZURlbGF5ZWRDYWxscykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRpZiAodmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh2YXJzKSxcblx0XHRcdFx0cm9vdCA9IHRsLl90aW1lbGluZSxcblx0XHRcdFx0dHdlZW4sIG5leHQ7XG5cdFx0XHRpZiAoaWdub3JlRGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0aWdub3JlRGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJvb3QuX3JlbW92ZSh0bCwgdHJ1ZSk7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gMDtcblx0XHRcdHRsLl9yYXdQcmV2VGltZSA9IHRsLl90aW1lID0gdGwuX3RvdGFsVGltZSA9IHJvb3QuX3RpbWU7XG5cdFx0XHR0d2VlbiA9IHJvb3QuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0aWYgKCFpZ25vcmVEZWxheWVkQ2FsbHMgfHwgISh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSAmJiB0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpIHtcblx0XHRcdFx0XHR0bC5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJvb3QuYWRkKHRsLCAwKTtcblx0XHRcdHJldHVybiB0bDtcblx0XHR9O1xuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgY3VyVGltZSwgbCwgaSwgY2hpbGQsIHRsLCBiZWZvcmVSYXdUaW1lO1xuXHRcdFx0aWYgKHR5cGVvZihwb3NpdGlvbikgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcblx0XHRcdFx0aWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0YWxpZ24gPSBhbGlnbiB8fCBcIm5vcm1hbFwiO1xuXHRcdFx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRcdFx0Y3VyVGltZSA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkID0gdmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gbmV3IFRpbWVsaW5lTGl0ZSh7dHdlZW5zOmNoaWxkfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZChjaGlsZCwgY3VyVGltZSk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YoY2hpbGQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsaWduID09PSBcInNlcXVlbmNlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSAtPSBjaGlsZC5kZWxheSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJUaW1lICs9IHN0YWdnZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbCh2YWx1ZSwgcG9zaXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHZhbHVlID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyhcIkNhbm5vdCBhZGQgXCIgKyB2YWx1ZSArIFwiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB2YWx1ZSwgcG9zaXRpb24pO1xuXG5cdFx0XHQvL2lmIHRoZSB0aW1lbGluZSBoYXMgYWxyZWFkeSBlbmRlZCBidXQgdGhlIGluc2VydGVkIHR3ZWVuL3RpbWVsaW5lIGV4dGVuZHMgdGhlIGR1cmF0aW9uLCB3ZSBzaG91bGQgZW5hYmxlIHRoaXMgdGltZWxpbmUgYWdhaW4gc28gdGhhdCBpdCByZW5kZXJzIHByb3Blcmx5LiBXZSBzaG91bGQgYWxzbyBhbGlnbiB0aGUgcGxheWhlYWQgd2l0aCB0aGUgcGFyZW50IHRpbWVsaW5lJ3Mgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdGlmICh0aGlzLl9nYyB8fCB0aGlzLl90aW1lID09PSB0aGlzLl9kdXJhdGlvbikgaWYgKCF0aGlzLl9wYXVzZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA8IHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG5cdFx0XHRcdHRsID0gdGhpcztcblx0XHRcdFx0YmVmb3JlUmF3VGltZSA9ICh0bC5yYXdUaW1lKCkgPiB2YWx1ZS5fc3RhcnRUaW1lKTsgLy9pZiB0aGUgdHdlZW4gaXMgcGxhY2VkIG9uIHRoZSB0aW1lbGluZSBzbyB0aGF0IGl0IHN0YXJ0cyBCRUZPUkUgdGhlIGN1cnJlbnQgcmF3VGltZSwgd2Ugc2hvdWxkIGFsaWduIHRoZSBwbGF5aGVhZCAobW92ZSB0aGUgdGltZWxpbmUpLiBUaGlzIGlzIGJlY2F1c2Ugc29tZXRpbWVzIHVzZXJzIHdpbGwgY3JlYXRlIGEgdGltZWxpbmUsIGxldCBpdCBmaW5pc2gsIGFuZCBtdWNoIGxhdGVyIGFwcGVuZCBhIHR3ZWVuIGFuZCBleHBlY3QgaXQgdG8gcnVuIGluc3RlYWQgb2YganVtcGluZyB0byBpdHMgZW5kIHN0YXRlLiBXaGlsZSB0ZWNobmljYWxseSBvbmUgY291bGQgYXJndWUgdGhhdCBpdCBzaG91bGQganVtcCB0byBpdHMgZW5kIHN0YXRlLCB0aGF0J3Mgbm90IHdoYXQgdXNlcnMgaW50dWl0aXZlbHkgZXhwZWN0LlxuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZVJhd1RpbWUgJiYgdGwuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGwuX2djKSB7XG5cdFx0XHRcdFx0XHR0bC5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlbW92ZSh2YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKHZhbHVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsKG51bGwsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsIHR3ZWVuLCBza2lwRGlzYWJsZSk7XG5cdFx0XHR2YXIgbGFzdCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAoIWxhc3QpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiBsYXN0Ll9zdGFydFRpbWUgKyBsYXN0Ll90b3RhbER1cmF0aW9uIC8gbGFzdC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uKCk7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0T3JMYWJlbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHZhbHVlKSk7XG5cdFx0fTtcblxuXHRcdHAuaW5zZXJ0ID0gcC5pbnNlcnRNdWx0aXBsZSA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgcG9zaXRpb24gfHwgMCwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZE11bHRpcGxlID0gZnVuY3Rpb24odHdlZW5zLCBvZmZzZXRPckxhYmVsLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHR3ZWVucywgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB0d2VlbnMpLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYWRkTGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFkZFBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHR2YXIgdCA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBfcGF1c2VDYWxsYmFjaywgW1wie3NlbGZ9XCIsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlXSwgdGhpcyk7XG5cdFx0XHR0LmRhdGEgPSBcImlzUGF1c2VcIjsgLy8gd2UgdXNlIHRoaXMgZmxhZyBpbiBUd2VlbkxpdGUncyByZW5kZXIoKSBtZXRob2QgdG8gaWRlbnRpZnkgaXQgYXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBzaG91bGRuJ3QgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZpcnR1YWwgcGxheWhlYWQgaXMgTEVBVklORyB0aGUgZXhhY3QgcG9zaXRpb24gd2hlcmUgdGhlIHBhdXNlIGlzLCBvdGhlcndpc2UgdGltZWxpbmUuYWRkUGF1c2UoMSkucGxheSgxKSB3b3VsZCBlbmQgdXAgcGF1c2VkIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cblx0XHRcdHJldHVybiB0aGlzLmFkZCh0LCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xhYmVsc1tsYWJlbF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbFRpbWUgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLl9sYWJlbHNbbGFiZWxdICE9IG51bGwpID8gdGhpcy5fbGFiZWxzW2xhYmVsXSA6IC0xO1xuXHRcdH07XG5cblx0XHRwLl9wYXJzZVRpbWVPckxhYmVsID0gZnVuY3Rpb24odGltZU9yTGFiZWwsIG9mZnNldE9yTGFiZWwsIGFwcGVuZElmQWJzZW50LCBpZ25vcmUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Yob2Zmc2V0T3JMYWJlbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwob2Zmc2V0T3JMYWJlbCwgKGFwcGVuZElmQWJzZW50ICYmIHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwibnVtYmVyXCIgJiYgdGhpcy5fbGFiZWxzW29mZnNldE9yTGFiZWxdID09IG51bGwpID8gdGltZU9yTGFiZWwgLSB0aGlzLmR1cmF0aW9uKCkgOiAwLCBhcHBlbmRJZkFic2VudCk7XG5cdFx0XHR9XG5cdFx0XHRvZmZzZXRPckxhYmVsID0gb2Zmc2V0T3JMYWJlbCB8fCAwO1xuXHRcdFx0aWYgKHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwic3RyaW5nXCIgJiYgKGlzTmFOKHRpbWVPckxhYmVsKSB8fCB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICE9IG51bGwpKSB7IC8vaWYgdGhlIHN0cmluZyBpcyBhIG51bWJlciBsaWtlIFwiMVwiLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGxhYmVsIHdpdGggdGhhdCBuYW1lLCBvdGhlcndpc2UgaW50ZXJwcmV0IGl0IGFzIGEgbnVtYmVyIChhYnNvbHV0ZSB2YWx1ZSkuXG5cdFx0XHRcdGkgPSB0aW1lT3JMYWJlbC5pbmRleE9mKFwiPVwiKTtcblx0XHRcdFx0aWYgKGkgPT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZElmQWJzZW50ID8gKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPSB0aGlzLmR1cmF0aW9uKCkgKyBvZmZzZXRPckxhYmVsKSA6IG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICsgb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRvZmZzZXRPckxhYmVsID0gcGFyc2VJbnQodGltZU9yTGFiZWwuY2hhckF0KGktMSkgKyBcIjFcIiwgMTApICogTnVtYmVyKHRpbWVPckxhYmVsLnN1YnN0cihpKzEpKTtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSAoaSA+IDEpID8gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0aW1lT3JMYWJlbC5zdWJzdHIoMCwgaS0xKSwgMCwgYXBwZW5kSWZBYnNlbnQpIDogdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lT3JMYWJlbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWJlcih0aW1lT3JMYWJlbCkgKyBvZmZzZXRPckxhYmVsO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodHlwZW9mKHBvc2l0aW9uKSA9PT0gXCJudW1iZXJcIikgPyBwb3NpdGlvbiA6IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSk7XG5cdFx0fTtcblxuXHRcdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5KHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHByZXZUaW1lU2NhbGUgPSB0aGlzLl90aW1lU2NhbGUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyKSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW47IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCkgaWYgKHRpbWUgPT09IDAgfHwgdGhpcy5fcmF3UHJldlRpbWUgPCAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9yYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdHRpbWUgPSB0b3RhbER1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuXG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8ICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPj0gMCkpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7IC8vZW5zdXJlcyBwcm9wZXIgR0MgaWYgYSB0aW1lbGluZSBpcyByZXN1bWVkIGFmdGVyIGl0J3MgZmluaXNoZWQgcmV2ZXJzaW5nLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUaW1lID09PSAwKSBpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMudmFycy5vblN0YXJ0LmFwcGx5KHRoaXMudmFycy5vblN0YXJ0U2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uU3RhcnRQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA+PSBwcmV2VGltZSkge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZ1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHRoaXMuX3RpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gcHJldlRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fb25VcGRhdGUuYXBwbHkodGhpcy52YXJzLm9uVXBkYXRlU2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uVXBkYXRlUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydFRpbWUgfHwgcHJldlRpbWVTY2FsZSAhPT0gdGhpcy5fdGltZVNjYWxlKSBpZiAodGhpcy5fdGltZSA9PT0gMCB8fCB0b3RhbER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSkgeyAvL2lmIG9uZSBvZiB0aGUgdHdlZW5zIHRoYXQgd2FzIHJlbmRlcmVkIGFsdGVyZWQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSAobGlrZSBpZiBhbiBvbkNvbXBsZXRlIHJldmVyc2VkIHRoZSB0aW1lbGluZSksIGl0IHByb2JhYmx5IGlzbid0IGNvbXBsZXRlLiBJZiBpdCBpcywgZG9uJ3Qgd29ycnksIGJlY2F1c2Ugd2hhdGV2ZXIgY2FsbCBhbHRlcmVkIHRoZSBzdGFydFRpbWUgd291bGQgY29tcGxldGUgaWYgaXQgd2FzIG5lY2Vzc2FyeSBhdCB0aGUgbmV3IHRpbWUuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyB0aGUgdGltZVNjYWxlIHByb3BlcnR5LiBBbHNvIGNoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uQ29tcGxldGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLnZhcnNbY2FsbGJhY2tdLmFwcGx5KHRoaXMudmFyc1tjYWxsYmFjayArIFwiU2NvcGVcIl0gfHwgdGhpcywgdGhpcy52YXJzW2NhbGxiYWNrICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2hhc1BhdXNlZENoaWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3BhdXNlZCB8fCAoKHR3ZWVuIGluc3RhbmNlb2YgVGltZWxpbmVMaXRlKSAmJiB0d2Vlbi5faGFzUGF1c2VkQ2hpbGQoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLmdldENoaWxkcmVuID0gZnVuY3Rpb24obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgLTk5OTk5OTk5OTk7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdC8vZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVucyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aW1lbGluZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHR3ZWVuLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBuZXN0ZWQpIHtcblx0XHRcdHZhciBkaXNhYmxlZCA9IHRoaXMuX2djLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHR3ZWVucywgaTtcblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIHRydWUpOyAvL2dldFR3ZWVuc09mKCkgZmlsdGVycyBvdXQgZGlzYWJsZWQgdHdlZW5zLCBhbmQgd2UgaGF2ZSB0byBtYXJrIHRoZW0gYXMgX2djID0gdHJ1ZSB3aGVuIHRoZSB0aW1lbGluZSBjb21wbGV0ZXMgaW4gb3JkZXIgdG8gYWxsb3cgY2xlYW4gZ2FyYmFnZSBjb2xsZWN0aW9uLCBzbyB0ZW1wb3JhcmlseSByZS1lbmFibGUgdGhlIHRpbWVsaW5lIGhlcmUuXG5cdFx0XHR9XG5cdFx0XHR0d2VlbnMgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0KTtcblx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0udGltZWxpbmUgPT09IHRoaXMgfHwgKG5lc3RlZCAmJiB0aGlzLl9jb250YWlucyh0d2VlbnNbaV0pKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5yZWNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZWNlbnQ7XG5cdFx0fTtcblxuXHRcdHAuX2NvbnRhaW5zID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRcdHZhciB0bCA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsKSB7XG5cdFx0XHRcdGlmICh0bCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsID0gdGwudGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAwO1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGxhYmVscyA9IHRoaXMuX2xhYmVscyxcblx0XHRcdFx0cDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0dHdlZW4uX3N0YXJ0VGltZSArPSBhbW91bnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChhZGp1c3RMYWJlbHMpIHtcblx0XHRcdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0XHRcdGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdFx0bGFiZWxzW3BdICs9IGFtb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRpZiAoIXZhcnMgJiYgIXRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR3ZWVucyA9ICghdGFyZ2V0KSA/IHRoaXMuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpIDogdGhpcy5nZXRUd2VlbnNPZih0YXJnZXQpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0Y2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0uX2tpbGwodmFycywgdGFyZ2V0KSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKGxhYmVscykge1xuXHRcdFx0dmFyIHR3ZWVucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oZmFsc2UsIHRydWUsIHRydWUpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuc1tpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhYmVscyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7O1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmIChlbmFibGVkID09PSB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZW5hYmxlZCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IHRydWU7XG5cdFx0XHR2YXIgdmFsID0gQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7IC8vanVzdCB0cmlnZ2VycyByZWNhbGN1bGF0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZHVyYXRpb24oKSAhPT0gMCAmJiB2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl9kdXJhdGlvbiAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHZhciBtYXggPSAwLFxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0LFxuXHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gOTk5OTk5OTk5OTk5LFxuXHRcdFx0XHRcdFx0cHJldiwgZW5kO1xuXHRcdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdFx0cHJldiA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgdHdlZW4ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPiBwcmV2U3RhcnQgJiYgdGhpcy5fc29ydENoaWxkcmVuICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgMCAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuXHRcdFx0XHRcdFx0XHRtYXggLT0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IHR3ZWVuLl9zdGFydFRpbWUgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5zaGlmdENoaWxkcmVuKC10d2Vlbi5fc3RhcnRUaW1lLCBmYWxzZSwgLTk5OTk5OTk5OTkpO1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZW5kID0gdHdlZW4uX3N0YXJ0VGltZSArICh0d2Vlbi5fdG90YWxEdXJhdGlvbiAvIHR3ZWVuLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA+IG1heCkge1xuXHRcdFx0XHRcdFx0XHRtYXggPSBlbmQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IG1heDtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMudG90YWxEdXJhdGlvbigpICE9PSAwKSBpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50aW1lU2NhbGUodGhpcy5fdG90YWxEdXJhdGlvbiAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIXZhbHVlKSB7IC8vaWYgdGhlcmUncyBhIHBhdXNlIGRpcmVjdGx5IGF0IHRoZSBzcG90IGZyb20gd2hlcmUgd2UncmUgdW5wYXVzaW5nLCBza2lwIGl0LlxuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPT09IHRpbWUgJiYgdHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9yYXdQcmV2VGltZSA9IDA7IC8vcmVtZW1iZXIsIF9yYXdQcmV2VGltZSBpcyBob3cgemVyby1kdXJhdGlvbiB0d2VlbnMvY2FsbGJhY2tzIHNlbnNlIGRpcmVjdGlvbmFsaXR5IGFuZCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZmlyZS4gSWYgX3Jhd1ByZXZUaW1lIGlzIHRoZSBzYW1lIGFzIF9zdGFydFRpbWUgb24gdGhlIG5leHQgcmVuZGVyLCBpdCB3b24ndCBmaXJlLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0cC51c2VzRnJhbWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRsID09PSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZCA/IHRoaXMuX3RvdGFsVGltZSA6ICh0aGlzLl90aW1lbGluZS5yYXdUaW1lKCkgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVMaXRlO1xuXG5cdH0sIHRydWUpO1xuXG5cbn0pOyBpZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH1cblxuLy9leHBvcnQgdG8gQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZSAocHJlY3Vyc29yIHRvIGZ1bGwgbW9kdWxhciBidWlsZCBzeXN0ZW0gY29taW5nIGF0IGEgbGF0ZXIgZGF0ZSlcbihmdW5jdGlvbihuYW1lKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIChfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzIHx8IF9nc1Njb3BlKVtuYW1lXTtcblx0fTtcblx0aWYgKHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgeyAvL0FNRFxuXHRcdGRlZmluZShbXCJUd2VlbkxpdGVcIl0sIGdldEdsb2JhbCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9ub2RlXG5cdFx0cmVxdWlyZShcIi4vVHdlZW5MaXRlLmpzXCIpOyAvL2RlcGVuZGVuY3lcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdldEdsb2JhbCgpO1xuXHR9XG59KFwiVGltZWxpbmVMaXRlXCIpKTtcbiIsIi8qIVxuICogVkVSU0lPTjogMS4xNi4xXG4gKiBEQVRFOiAyMDE1LTAzLTEzXG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgbW9kdWxlTmFtZSkge1xuXG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9nbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyB8fCB3aW5kb3c7XG5cdFx0aWYgKF9nbG9iYWxzLlR3ZWVuTGl0ZSkge1xuXHRcdFx0cmV0dXJuOyAvL2luIGNhc2UgdGhlIGNvcmUgc2V0IG9mIGNsYXNzZXMgaXMgYWxyZWFkeSBsb2FkZWQsIGRvbid0IGluc3RhbnRpYXRlIHR3aWNlLlxuXHRcdH1cblx0XHR2YXIgX25hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zKSB7XG5cdFx0XHRcdHZhciBhID0gbnMuc3BsaXQoXCIuXCIpLFxuXHRcdFx0XHRcdHAgPSBfZ2xvYmFscywgaTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwW2FbaV1dID0gcCA9IHBbYVtpXV0gfHwge307XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0Z3MgPSBfbmFtZXNwYWNlKFwiY29tLmdyZWVuc29ja1wiKSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0X3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0YXJnZXQsIDApIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2VtcHR5RnVuYyA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfaXNBcnJheSA9IChmdW5jdGlvbigpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIGlmcmFtZSBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIEFycmF5IGdsb2JhbCBpc24ndCBzaGFyZWQsIHRodXMgaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGluIGEgZGlmZmVyZW50IHdpbmRvdy9pZnJhbWUsIFwiKG9iaiBpbnN0YW5jZW9mIEFycmF5KVwiIHdpbGwgZXZhbHVhdGUgZmFsc2UuIFdlIGFkZGVkIHNvbWUgc3BlZWQgb3B0aW1pemF0aW9ucyB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKSB1bmxlc3MgaXQncyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgVkVSWSBzbG93IChsaWtlIDIweCBzbG93ZXIpXG5cdFx0XHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0XHRcdFx0YXJyYXkgPSB0b1N0cmluZy5jYWxsKFtdKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgKHR5cGVvZihvYmopID09PSBcIm9iamVjdFwiICYmICEhb2JqLnB1c2ggJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSBhcnJheSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKSxcblx0XHRcdGEsIGksIHAsIF90aWNrZXIsIF90aWNrZXJBY3RpdmUsXG5cdFx0XHRfZGVmTG9va3VwID0ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0XHQgKiBEZWZpbmVzIGEgR3JlZW5Tb2NrIGNsYXNzLCBvcHRpb25hbGx5IHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgZmlyc3QgYW5kIHBhc3NlZCBpbnRvIHRoZSBkZWZpbml0aW9uLlxuXHRcdFx0ICogVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9hZCBHcmVlblNvY2sgSlMgZmlsZXMgaW4gYW55IG9yZGVyIGV2ZW4gaWYgdGhleSBoYXZlIGludGVyZGVwZW5kZW5jaWVzIChsaWtlIENTU1BsdWdpbiBleHRlbmRzIFR3ZWVuUGx1Z2luIHdoaWNoIGlzXG5cdFx0XHQgKiBpbnNpZGUgVHdlZW5MaXRlLmpzLCBidXQgaWYgQ1NTUGx1Z2luIGlzIGxvYWRlZCBmaXJzdCwgaXQgc2hvdWxkIHdhaXQgdG8gcnVuIGl0cyBjb2RlIHVudGlsIFR3ZWVuTGl0ZS5qcyBsb2FkcyBhbmQgaW5zdGFudGlhdGVzIFR3ZWVuUGx1Z2luXG5cdFx0XHQgKiBhbmQgdGhlbiBwYXNzIFR3ZWVuUGx1Z2luIHRvIENTU1BsdWdpbidzIGRlZmluaXRpb24pLiBUaGlzIGlzIGFsbCBkb25lIGF1dG9tYXRpY2FsbHkgYW5kIGludGVybmFsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRXZlcnkgZGVmaW5pdGlvbiB3aWxsIGJlIGFkZGVkIHRvIGEgXCJjb20uZ3JlZW5zb2NrXCIgZ2xvYmFsIG9iamVjdCAodHlwaWNhbGx5IHdpbmRvdywgYnV0IGlmIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IGlzIGZvdW5kLFxuXHRcdFx0ICogaXQgd2lsbCBnbyB0aGVyZSBhcyBvZiB2MS43KS4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZSB3aWxsIGJlIGZvdW5kIGF0IHdpbmRvdy5jb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSBhbmQgc2luY2UgaXQncyBhIGdsb2JhbCBjbGFzcyB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgYW55d2hlcmUsXG5cdFx0XHQgKiBpdCBpcyBBTFNPIHJlZmVyZW5jZWQgYXQgd2luZG93LlR3ZWVuTGl0ZS4gSG93ZXZlciBzb21lIGNsYXNzZXMgYXJlbid0IGNvbnNpZGVyZWQgZ2xvYmFsLCBsaWtlIHRoZSBiYXNlIGNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24gY2xhc3MsIHNvXG5cdFx0XHQgKiB0aG9zZSB3aWxsIG9ubHkgYmUgYXQgdGhlIHBhY2thZ2UgbGlrZSB3aW5kb3cuY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbi4gQWdhaW4sIGlmIHlvdSBkZWZpbmUgYSBHcmVlblNvY2tHbG9iYWxzIG9iamVjdCBvbiB0aGUgd2luZG93LCBldmVyeXRoaW5nXG5cdFx0XHQgKiBnZXRzIHR1Y2tlZCBuZWF0bHkgaW5zaWRlIHRoZXJlIGluc3RlYWQgb2Ygb24gdGhlIHdpbmRvdyBkaXJlY3RseS4gVGhpcyBhbGxvd3MgeW91IHRvIGRvIGFkdmFuY2VkIHRoaW5ncyBsaWtlIGxvYWQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgR3JlZW5Tb2NrXG5cdFx0XHQgKiBmaWxlcyBhbmQgcHV0IHRoZW0gaW50byBkaXN0aW5jdCBvYmplY3RzIChpbWFnaW5lIGEgYmFubmVyIGFkIHVzZXMgYSBuZXdlciB2ZXJzaW9uIGJ1dCB0aGUgbWFpbiBzaXRlIHVzZXMgYW4gb2xkZXIgb25lKS4gSW4gdGhhdCBjYXNlLCB5b3UgY291bGRcblx0XHRcdCAqIHNhbmRib3ggdGhlIGJhbm5lciBvbmUgbGlrZTpcblx0XHRcdCAqXG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHZhciBncyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge307IC8vdGhlIG5ld2VyIHZlcnNpb24gd2UncmUgYWJvdXQgdG8gbG9hZCBjb3VsZCBub3cgYmUgcmVmZXJlbmNlZCBpbiBhIFwiZ3NcIiBvYmplY3QsIGxpa2UgZ3MuVHdlZW5MaXRlLnRvKC4uLikuIFVzZSB3aGF0ZXZlciBhbGlhcyB5b3Ugd2FudCBhcyBsb25nIGFzIGl0J3MgdW5pcXVlLCBcImdzXCIgb3IgXCJiYW5uZXJcIiBvciB3aGF0ZXZlci5cblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNy9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5fZ3NRdWV1ZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBudWxsOyAvL3Jlc2V0IGl0IGJhY2sgdG8gbnVsbCAoYWxvbmcgd2l0aCB0aGUgc3BlY2lhbCBfZ3NRdWV1ZSB2YXJpYWJsZSkgc28gdGhhdCB0aGUgbmV4dCBsb2FkIG9mIFR3ZWVuTWF4IGFmZmVjdHMgdGhlIHdpbmRvdyBhbmQgd2UgY2FuIHJlZmVyZW5jZSB0aGluZ3MgZGlyZWN0bHkgbGlrZSBUd2VlbkxpdGUudG8oLi4uKVxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS42L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIGdzLlR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS43XG5cdFx0XHQgKiAgICAgVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjZcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbnMgVGhlIG5hbWVzcGFjZSBvZiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgbGVhdmluZyBvZmYgXCJjb20uZ3JlZW5zb2NrLlwiIGFzIHRoYXQncyBhc3N1bWVkLiBGb3IgZXhhbXBsZSwgXCJUd2VlbkxpdGVcIiBvciBcInBsdWdpbnMuQ1NTUGx1Z2luXCIgb3IgXCJlYXNpbmcuQmFja1wiLlxuXHRcdFx0ICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgKGRlc2NyaWJlZCBhcyB0aGVpciBuYW1lc3BhY2VzIG1pbnVzIFwiY29tLmdyZWVuc29jay5cIiBwcmVmaXgpLiBGb3IgZXhhbXBsZSBbXCJUd2VlbkxpdGVcIixcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcImNvcmUuQW5pbWF0aW9uXCJdXG5cdFx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbigpOk9iamVjdH0gZnVuYyBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGFuZCBwYXNzZWQgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyB3aGljaCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGNsYXNzIGZvciB0aGlzIGRlZmluaXRpb24uXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBnbG9iYWwgSWYgdHJ1ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZSAodHlwaWNhbGx5IHdpbmRvdyB1bmxlc3MgeW91IGRlZmluZSBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHR0aGlzLnNjID0gKF9kZWZMb29rdXBbbnNdKSA/IF9kZWZMb29rdXBbbnNdLnNjIDogW107IC8vc3ViY2xhc3Nlc1xuXHRcdFx0XHRfZGVmTG9va3VwW25zXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZ3NDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHZhciBfY2xhc3NlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24oaW5pdCkge1xuXHRcdFx0XHRcdHZhciBpID0gZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdG1pc3NpbmcgPSBpLFxuXHRcdFx0XHRcdFx0Y3VyLCBhLCBuLCBjbDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyID0gX2RlZkxvb2t1cFtkZXBlbmRlbmNpZXNbaV1dIHx8IG5ldyBEZWZpbml0aW9uKGRlcGVuZGVuY2llc1tpXSwgW10pKS5nc0NsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9jbGFzc2VzW2ldID0gY3VyLmdzQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdG1pc3NpbmctLTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5pdCkge1xuXHRcdFx0XHRcdFx0XHRjdXIuc2MucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pc3NpbmcgPT09IDAgJiYgZnVuYykge1xuXHRcdFx0XHRcdFx0YSA9IChcImNvbS5ncmVlbnNvY2suXCIgKyBucykuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRcdFx0biA9IGEucG9wKCk7XG5cdFx0XHRcdFx0XHRjbCA9IF9uYW1lc3BhY2UoYS5qb2luKFwiLlwiKSlbbl0gPSB0aGlzLmdzQ2xhc3MgPSBmdW5jLmFwcGx5KGZ1bmMsIF9jbGFzc2VzKTtcblxuXHRcdFx0XHRcdFx0Ly9leHBvcnRzIHRvIG11bHRpcGxlIGVudmlyb25tZW50c1xuXHRcdFx0XHRcdFx0aWYgKGdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xvYmFsc1tuXSA9IGNsOyAvL3Byb3ZpZGVzIGEgd2F5IHRvIGF2b2lkIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uLiBCeSBkZWZhdWx0LCB0aGUgbWFpbiBjbGFzc2VzIGxpa2UgVHdlZW5MaXRlLCBQb3dlcjEsIFN0cm9uZywgZXRjLiBhcmUgYWRkZWQgdG8gd2luZG93IHVubGVzcyBhIEdyZWVuU29ja0dsb2JhbHMgaXMgZGVmaW5lZC4gU28gaWYgeW91IHdhbnQgdG8gaGF2ZSB0aGluZ3MgYWRkZWQgdG8gYSBjdXN0b20gb2JqZWN0IGluc3RlYWQsIGp1c3QgZG8gc29tZXRoaW5nIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB7fSBiZWZvcmUgbG9hZGluZyBhbnkgR3JlZW5Tb2NrIGZpbGVzLiBZb3UgY2FuIGV2ZW4gc2V0IHVwIGFuIGFsaWFzIGxpa2Ugd2luZG93LkdyZWVuU29ja0dsb2JhbHMgPSB3aW5kb3dzLmdzID0ge30gc28gdGhhdCB5b3UgY2FuIGFjY2VzcyBldmVyeXRoaW5nIGxpa2UgZ3MuVHdlZW5MaXRlLiBBbHNvIHJlbWVtYmVyIHRoYXQgQUxMIGNsYXNzZXMgYXJlIGFkZGVkIHRvIHRoZSB3aW5kb3cuY29tLmdyZWVuc29jayBvYmplY3QgKGluIHRoZWlyIHJlc3BlY3RpdmUgcGFja2FnZXMsIGxpa2UgY29tLmdyZWVuc29jay5lYXNpbmcuUG93ZXIxLCBjb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSwgZXRjLilcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCl7IC8vQU1EXG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lKCh3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCA/IHdpbmRvdy5HcmVlblNvY2tBTURQYXRoICsgXCIvXCIgOiBcIlwiKSArIG5zLnNwbGl0KFwiLlwiKS5wb3AoKSwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2w7IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG5zID09PSBtb2R1bGVOYW1lICYmIHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKXsgLy9ub2RlXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBjbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zY1tpXS5jaGVjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5jaGVjayh0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vdXNlZCB0byBjcmVhdGUgRGVmaW5pdGlvbiBpbnN0YW5jZXMgKHdoaWNoIGJhc2ljYWxseSByZWdpc3RlcnMgYSBjbGFzcyB0aGF0IGhhcyBkZXBlbmRlbmNpZXMpLlxuXHRcdFx0X2dzRGVmaW5lID0gd2luZG93Ll9nc0RlZmluZSA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERlZmluaXRpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vYSBxdWljayB3YXkgdG8gY3JlYXRlIGEgY2xhc3MgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGRlcGVuZGVuY2llcy4gUmV0dXJucyB0aGUgY2xhc3MsIGJ1dCBmaXJzdCByZWdpc3RlcnMgaXQgaW4gdGhlIEdyZWVuU29jayBuYW1lc3BhY2Ugc28gdGhhdCBvdGhlciBjbGFzc2VzIGNhbiBncmFiIGl0IChvdGhlciBjbGFzc2VzIG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgY2xhc3MpLlxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzID0gZnVuY3Rpb24obnMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRmdW5jID0gZnVuYyB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRfZ3NEZWZpbmUobnMsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gZnVuYzsgfSwgZ2xvYmFsKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmM7XG5cdFx0XHR9O1xuXG5cdFx0X2dzRGVmaW5lLmdsb2JhbHMgPSBfZ2xvYmFscztcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgX2Jhc2VQYXJhbXMgPSBbMCwgMCwgMSwgMV0sXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdLFxuXHRcdFx0RWFzZSA9IF9jbGFzcyhcImVhc2luZy5FYXNlXCIsIGZ1bmN0aW9uKGZ1bmMsIGV4dHJhUGFyYW1zLCB0eXBlLCBwb3dlcikge1xuXHRcdFx0XHR0aGlzLl9mdW5jID0gZnVuYztcblx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgMDtcblx0XHRcdFx0dGhpcy5fcG93ZXIgPSBwb3dlciB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wYXJhbXMgPSBleHRyYVBhcmFtcyA/IF9iYXNlUGFyYW1zLmNvbmNhdChleHRyYVBhcmFtcykgOiBfYmFzZVBhcmFtcztcblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2Vhc2VNYXAgPSBFYXNlLm1hcCA9IHt9LFxuXHRcdFx0X2Vhc2VSZWcgPSBFYXNlLnJlZ2lzdGVyID0gZnVuY3Rpb24oZWFzZSwgbmFtZXMsIHR5cGVzLCBjcmVhdGUpIHtcblx0XHRcdFx0dmFyIG5hID0gbmFtZXMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGkgPSBuYS5sZW5ndGgsXG5cdFx0XHRcdFx0dGEgPSAodHlwZXMgfHwgXCJlYXNlSW4sZWFzZU91dCxlYXNlSW5PdXRcIikuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRcdGUsIG5hbWUsIGosIHR5cGU7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYVtpXTtcblx0XHRcdFx0XHRlID0gY3JlYXRlID8gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIG51bGwsIHRydWUpIDogZ3MuZWFzaW5nW25hbWVdIHx8IHt9O1xuXHRcdFx0XHRcdGogPSB0YS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGFbal07XG5cdFx0XHRcdFx0XHRfZWFzZU1hcFtuYW1lICsgXCIuXCIgKyB0eXBlXSA9IF9lYXNlTWFwW3R5cGUgKyBuYW1lXSA9IGVbdHlwZV0gPSBlYXNlLmdldFJhdGlvID8gZWFzZSA6IGVhc2VbdHlwZV0gfHwgbmV3IGVhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRwID0gRWFzZS5wcm90b3R5cGU7XG5cdFx0cC5fY2FsY0VuZCA9IGZhbHNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAodGhpcy5fZnVuYykge1xuXHRcdFx0XHR0aGlzLl9wYXJhbXNbMF0gPSBwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnVuYy5hcHBseShudWxsLCB0aGlzLl9wYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHQgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRwdyA9IHRoaXMuX3Bvd2VyLFxuXHRcdFx0XHRyID0gKHQgPT09IDEpID8gMSAtIHAgOiAodCA9PT0gMikgPyBwIDogKHAgPCAwLjUpID8gcCAqIDIgOiAoMSAtIHApICogMjtcblx0XHRcdGlmIChwdyA9PT0gMSkge1xuXHRcdFx0XHRyICo9IHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAyKSB7XG5cdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSAzKSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gNCkge1xuXHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSAtIHIgOiAodCA9PT0gMikgPyByIDogKHAgPCAwLjUpID8gciAvIDIgOiAxIC0gKHIgLyAyKTtcblx0XHR9O1xuXG5cdFx0Ly9jcmVhdGUgYWxsIHRoZSBzdGFuZGFyZCBlYXNlcyBsaWtlIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIGFuZCBQb3dlcjQgKGVhY2ggd2l0aCBlYXNlSW4sIGVhc2VPdXQsIGFuZCBlYXNlSW5PdXQpXG5cdFx0YSA9IFtcIkxpbmVhclwiLFwiUXVhZFwiLFwiQ3ViaWNcIixcIlF1YXJ0XCIsXCJRdWludCxTdHJvbmdcIl07XG5cdFx0aSA9IGEubGVuZ3RoO1xuXHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0cCA9IGFbaV0rXCIsUG93ZXJcIitpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDEsaSksIHAsIFwiZWFzZU91dFwiLCB0cnVlKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwyLGkpLCBwLCBcImVhc2VJblwiICsgKChpID09PSAwKSA/IFwiLGVhc2VOb25lXCIgOiBcIlwiKSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMyxpKSwgcCwgXCJlYXNlSW5PdXRcIik7XG5cdFx0fVxuXHRcdF9lYXNlTWFwLmxpbmVhciA9IGdzLmVhc2luZy5MaW5lYXIuZWFzZUluO1xuXHRcdF9lYXNlTWFwLnN3aW5nID0gZ3MuZWFzaW5nLlF1YWQuZWFzZUluT3V0OyAvL2ZvciBqUXVlcnkgZm9sa3NcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRXZlbnREaXNwYXRjaGVyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgRXZlbnREaXNwYXRjaGVyID0gX2NsYXNzKFwiZXZlbnRzLkV2ZW50RGlzcGF0Y2hlclwiLCBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXHRcdFx0dGhpcy5fZXZlbnRUYXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcblx0XHR9KTtcblx0XHRwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuXHRcdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBzY29wZSwgdXNlUGFyYW0sIHByaW9yaXR5KSB7XG5cdFx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsaXN0ZW5lciwgaTtcblx0XHRcdGlmIChsaXN0ID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyLmMgPT09IGNhbGxiYWNrICYmIGxpc3RlbmVyLnMgPT09IHNjb3BlKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgbGlzdGVuZXIucHIgPCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3Quc3BsaWNlKGluZGV4LCAwLCB7YzpjYWxsYmFjaywgczpzY29wZSwgdXA6dXNlUGFyYW0sIHByOnByaW9yaXR5fSk7XG5cdFx0XHRpZiAodGhpcyA9PT0gX3RpY2tlciAmJiAhX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLCBpO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobGlzdFtpXS5jID09PSBjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpLCB0LCBsaXN0ZW5lcjtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0dCA9IHRoaXMuX2V2ZW50VGFyZ2V0O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudXApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCwge3R5cGU6dHlwZSwgdGFyZ2V0OnR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4gXHRcdHZhciBfcmVxQW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9LFxuXHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpO1xuXG5cdFx0Ly9ub3cgdHJ5IHRvIGRldGVybWluZSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBjYW5jZWxBbmltYXRpb25GcmFtZSBmdW5jdGlvbnMgYW5kIGlmIG5vbmUgYXJlIGZvdW5kLCB3ZSdsbCB1c2UgYSBzZXRUaW1lb3V0KCkvY2xlYXJUaW1lb3V0KCkgcG9seWZpbGwuXG5cdFx0YSA9IFtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xICYmICFfcmVxQW5pbUZyYW1lKSB7XG5cdFx0XHRfcmVxQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl0gfHwgd2luZG93W2FbaV0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHR9XG5cblx0XHRfY2xhc3MoXCJUaWNrZXJcIiwgZnVuY3Rpb24oZnBzLCB1c2VSQUYpIHtcblx0XHRcdHZhciBfc2VsZiA9IHRoaXMsXG5cdFx0XHRcdF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuXHRcdFx0XHRfdXNlUkFGID0gKHVzZVJBRiAhPT0gZmFsc2UgJiYgX3JlcUFuaW1GcmFtZSksXG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0XHRfdGlja1dvcmQgPSBcInRpY2tcIiwgLy9oZWxwcyByZWR1Y2UgZ2MgYnVyZGVuXG5cdFx0XHRcdF9mcHMsIF9yZXEsIF9pZCwgX2dhcCwgX25leHRUaW1lLFxuXHRcdFx0XHRfdGljayA9IGZ1bmN0aW9uKG1hbnVhbCkge1xuXHRcdFx0XHRcdHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2g7XG5cdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0XHRvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0XHRpZiAoIV9mcHMgfHwgb3ZlcmxhcCA+IDAgfHwgbWFudWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5mcmFtZSsrO1xuXHRcdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gMC4wMDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYW51YWwgIT09IHRydWUpIHsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0XHRcdF9pZCA9IF9yZXEoX3RpY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmRpc3BhdGNoRXZlbnQoX3RpY2tXb3JkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdEV2ZW50RGlzcGF0Y2hlci5jYWxsKF9zZWxmKTtcblx0XHRcdF9zZWxmLnRpbWUgPSBfc2VsZi5mcmFtZSA9IDA7XG5cdFx0XHRfc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8ICgxIC8gX3RpbnlOdW0pOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuc2xlZXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3VzZVJBRiB8fCAhX2NhbmNlbEFuaW1GcmFtZSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jYW5jZWxBbmltRnJhbWUoX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gX2VtcHR5RnVuYztcblx0XHRcdFx0X2lkID0gbnVsbDtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi53YWtlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfaWQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRfc2VsZi5zbGVlcCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zZWxmLmZyYW1lID4gMTApIHsgLy9kb24ndCB0cmlnZ2VyIGxhZ1Ntb290aGluZyBpZiB3ZSdyZSBqdXN0IHdha2luZyB1cCwgYW5kIG1ha2Ugc3VyZSB0aGF0IGF0IGxlYXN0IDEwIGZyYW1lcyBoYXZlIGVsYXBzZWQgYmVjYXVzZSBvZiB0aGUgaU9TIGJ1ZyB0aGF0IHdlIHdvcmsgYXJvdW5kIGJlbG93IHdpdGggdGhlIDEuNS1zZWNvbmQgc2V0VGltb3V0KCkuXG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpIC0gX2xhZ1RocmVzaG9sZCArIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IChfZnBzID09PSAwKSA/IF9lbXB0eUZ1bmMgOiAoIV91c2VSQUYgfHwgIV9yZXFBbmltRnJhbWUpID8gZnVuY3Rpb24oZikgeyByZXR1cm4gc2V0VGltZW91dChmLCAoKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEpIHwgMCk7IH0gOiBfcmVxQW5pbUZyYW1lO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGljaygyKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmZwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfZnBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mcHMgPSB2YWx1ZTtcblx0XHRcdFx0X2dhcCA9IDEgLyAoX2ZwcyB8fCA2MCk7XG5cdFx0XHRcdF9uZXh0VGltZSA9IHRoaXMudGltZSArIF9nYXA7XG5cdFx0XHRcdF9zZWxmLndha2UoKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnVzZVJBRiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfdXNlUkFGO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdF91c2VSQUYgPSB2YWx1ZTtcblx0XHRcdFx0X3NlbGYuZnBzKF9mcHMpO1xuXHRcdFx0fTtcblx0XHRcdF9zZWxmLmZwcyhmcHMpO1xuXG5cdFx0XHQvL2EgYnVnIGluIGlPUyA2IFNhZmFyaSBvY2Nhc2lvbmFsbHkgcHJldmVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHdvcmtpbmcgaW5pdGlhbGx5LCBzbyB3ZSB1c2UgYSAxLjUtc2Vjb25kIHRpbWVvdXQgdGhhdCBhdXRvbWF0aWNhbGx5IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCgpIGlmIGl0IHNlbnNlcyB0aGlzIGNvbmRpdGlvbi5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdXNlUkFGICYmIF9zZWxmLmZyYW1lIDwgNSkge1xuXHRcdFx0XHRcdF9zZWxmLnVzZVJBRihmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDE1MDApO1xuXHRcdH0pO1xuXG5cdFx0cCA9IGdzLlRpY2tlci5wcm90b3R5cGUgPSBuZXcgZ3MuZXZlbnRzLkV2ZW50RGlzcGF0Y2hlcigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBncy5UaWNrZXI7XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFuaW1hdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEFuaW1hdGlvbiA9IF9jbGFzcyhcImNvcmUuQW5pbWF0aW9uXCIsIGZ1bmN0aW9uKGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdHRoaXMudmFycyA9IHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwO1xuXHRcdFx0XHR0aGlzLl9kZWxheSA9IE51bWJlcih2YXJzLmRlbGF5KSB8fCAwO1xuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGUgPSAxO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG5cdFx0XHRcdHRoaXMuX3JldmVyc2VkID0gKHZhcnMucmV2ZXJzZWQgPT09IHRydWUpO1xuXG5cdFx0XHRcdGlmICghX3Jvb3RUaW1lbGluZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHsgLy9zb21lIGJyb3dzZXJzIChsaWtlIGlPUyA2IFNhZmFyaSkgc2h1dCBkb3duIEphdmFTY3JpcHQgZXhlY3V0aW9uIHdoZW4gdGhlIHRhYiBpcyBkaXNhYmxlZCBhbmQgdGhleSBbb2NjYXNpb25hbGx5XSBuZWdsZWN0IHRvIHN0YXJ0IHVwIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhZ2FpbiB3aGVuIHJldHVybmluZyAtIHRoaXMgY29kZSBlbnN1cmVzIHRoYXQgdGhlIGVuZ2luZSBzdGFydHMgdXAgYWdhaW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGwgPSB0aGlzLnZhcnMudXNlRnJhbWVzID8gX3Jvb3RGcmFtZXNUaW1lbGluZSA6IF9yb290VGltZWxpbmU7XG5cdFx0XHRcdHRsLmFkZCh0aGlzLCB0bC5fdGltZSk7XG5cblx0XHRcdFx0aWYgKHRoaXMudmFycy5wYXVzZWQpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRfdGlja2VyID0gQW5pbWF0aW9uLnRpY2tlciA9IG5ldyBncy5UaWNrZXIoKTtcblx0XHRwID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblx0XHRwLl9kaXJ0eSA9IHAuX2djID0gcC5faW5pdHRlZCA9IHAuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHAuX3RvdGFsVGltZSA9IHAuX3RpbWUgPSAwO1xuXHRcdHAuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0cC5fbmV4dCA9IHAuX2xhc3QgPSBwLl9vblVwZGF0ZSA9IHAuX3RpbWVsaW5lID0gcC50aW1lbGluZSA9IG51bGw7XG5cdFx0cC5fcGF1c2VkID0gZmFsc2U7XG5cblxuXHRcdC8vc29tZSBicm93c2VycyAobGlrZSBpT1MpIG9jY2FzaW9uYWxseSBkcm9wIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZXZlbnQgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCB0YWIgYW5kIHRoZW4gY29tZXMgYmFjayBhZ2Fpbiwgc28gd2UgdXNlIGEgMi1zZWNvbmQgc2V0VGltZW91dCgpIHRvIHNlbnNlIGlmL3doZW4gdGhhdCBjb25kaXRpb24gb2NjdXJzIGFuZCB0aGVuIHdha2UoKSB0aGUgdGlja2VyLlxuXHRcdHZhciBfY2hlY2tUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdGlja2VyQWN0aXZlICYmIF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSA+IDIwMDApIHtcblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRUaW1lb3V0KF9jaGVja1RpbWVvdXQsIDIwMDApO1xuXHRcdFx0fTtcblx0XHRfY2hlY2tUaW1lb3V0KCk7XG5cblxuXHRcdHAucGxheSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5wYXVzZSA9IGZ1bmN0aW9uKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChhdFRpbWUgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdW1lID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoTnVtYmVyKHRpbWUpLCBzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlc3RhcnQgPSBmdW5jdGlvbihpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSksIHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2UgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0Ly9zdHViIC0gd2Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gc3ViY2xhc3Nlcy5cblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9nYyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRcdGlmICh0aGlzLl9nYyB8fCAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLCAvL3RoZSAyIHJvb3QgdGltZWxpbmVzIHdvbid0IGhhdmUgYSBfdGltZWxpbmU7IHRoZXkncmUgYWx3YXlzIGFjdGl2ZS5cblx0XHRcdFx0c3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRyYXdUaW1lO1xuXHRcdFx0cmV0dXJuICghdGwgfHwgKCF0aGlzLl9nYyAmJiAhdGhpcy5fcGF1c2VkICYmIHRsLmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSB0bC5yYXdUaW1lKCkpID49IHN0YXJ0VGltZSAmJiByYXdUaW1lIDwgc3RhcnRUaW1lICsgdGhpcy50b3RhbER1cmF0aW9uKCkgLyB0aGlzLl90aW1lU2NhbGUpKTtcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZ2MgPSAhZW5hYmxlZDtcblx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdGlmIChpZ25vcmVUaW1lbGluZSAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRpZiAoZW5hYmxlZCAmJiAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLmFkZCh0aGlzLCB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9kZWxheSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWVsaW5lLl9yZW1vdmUodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLmtpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHRoaXMuX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl91bmNhY2hlID0gZnVuY3Rpb24oaW5jbHVkZVNlbGYpIHtcblx0XHRcdHZhciB0d2VlbiA9IGluY2x1ZGVTZWxmID8gdGhpcyA6IHRoaXMudGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0dHdlZW4uX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9zd2FwU2VsZkluUGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0XHR2YXIgaSA9IHBhcmFtcy5sZW5ndGgsXG5cdFx0XHRcdGNvcHkgPSBwYXJhbXMuY29uY2F0KCk7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHBhcmFtc1tpXSA9PT0gXCJ7c2VsZn1cIikge1xuXHRcdFx0XHRcdGNvcHlbaV0gPSB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9O1xuXG4vLy0tLS1BbmltYXRpb24gZ2V0dGVycy9zZXR0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0aWYgKCh0eXBlIHx8IFwiXCIpLnN1YnN0cigwLDIpID09PSBcIm9uXCIpIHtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnM7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZbdHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNhbGxiYWNrID09IG51bGwpIHtcblx0XHRcdFx0XHRkZWxldGUgdlt0eXBlXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2W3R5cGVdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJQYXJhbXNcIl0gPSAoX2lzQXJyYXkocGFyYW1zKSAmJiBwYXJhbXMuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkgPyB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHBhcmFtcykgOiBwYXJhbXM7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJTY29wZVwiXSA9IHNjb3BlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSBcIm9uVXBkYXRlXCIpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RlbGF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRUaW1lKCB0aGlzLl9zdGFydFRpbWUgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTsgLy90cnVlIGluIGNhc2UgaXQncyBhIFR3ZWVuTWF4IG9yIFRpbWVsaW5lTWF4IHRoYXQgaGFzIGEgcmVwZWF0IC0gd2UnbGwgbmVlZCB0byByZWZyZXNoIHRoZSB0b3RhbER1cmF0aW9uLlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSBpZiAodGhpcy5fdGltZSA+IDApIGlmICh0aGlzLl90aW1lIDwgdGhpcy5fZHVyYXRpb24pIGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSh0aGlzLl90b3RhbFRpbWUgKiAodmFsdWUgLyB0aGlzLl9kdXJhdGlvbiksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy5kdXJhdGlvbih2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSA/IHRoaXMuX2R1cmF0aW9uIDogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHR0aW1lICs9IHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0b3RhbER1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbixcblx0XHRcdFx0XHRcdHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPiB0b3RhbER1cmF0aW9uICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IHRvdGFsRHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICh0aGlzLl9wYXVzZWQgPyB0aGlzLl9wYXVzZVRpbWUgOiB0bC5fdGltZSkgLSAoKCF0aGlzLl9yZXZlcnNlZCA/IHRpbWUgOiB0b3RhbER1cmF0aW9uIC0gdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdGlmICghdGwuX2RpcnR5KSB7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuXHRcdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydFRpbWUgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUuX3RpbWUgIT09ICh0bC5fc3RhcnRUaW1lICsgdGwuX3RvdGFsVGltZSkgLyB0bC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdG90YWxUaW1lICE9PSB0aW1lIHx8IHRoaXMuX2R1cmF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wcm9ncmVzcyA9IHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFydFRpbWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKHRoaXMudGltZWxpbmUpIGlmICh0aGlzLnRpbWVsaW5lLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0XHR0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5lbmRUaW1lID0gZnVuY3Rpb24oaW5jbHVkZVJlcGVhdHMpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWUgKyAoKGluY2x1ZGVSZXBlYXRzICE9IGZhbHNlKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cC50aW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSAmJiB0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR2YXIgcGF1c2VUaW1lID0gdGhpcy5fcGF1c2VUaW1lLFxuXHRcdFx0XHRcdHQgPSAocGF1c2VUaW1lIHx8IHBhdXNlVGltZSA9PT0gMCkgPyBwYXVzZVRpbWUgOiB0aGlzLl90aW1lbGluZS50b3RhbFRpbWUoKTtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90aW1lU2NhbGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdHRoaXMuX3JldmVyc2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMudG90YWxUaW1lKCgodGhpcy5fdGltZWxpbmUgJiYgIXRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIC0gdGhpcy5fdG90YWxUaW1lIDogdGhpcy5fdG90YWxUaW1lKSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSxcblx0XHRcdFx0cmF3LCBlbGFwc2VkO1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXMuX3BhdXNlZCkgaWYgKHRsKSB7XG5cdFx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSAmJiAhdmFsdWUpIHtcblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYXcgPSB0bC5yYXdUaW1lKCk7XG5cdFx0XHRcdGVsYXBzZWQgPSByYXcgLSB0aGlzLl9wYXVzZVRpbWU7XG5cdFx0XHRcdGlmICghdmFsdWUgJiYgdGwuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gZWxhcHNlZDtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wYXVzZVRpbWUgPSB2YWx1ZSA/IHJhdyA6IG51bGw7XG5cdFx0XHRcdHRoaXMuX3BhdXNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRcdGlmICghdmFsdWUgJiYgZWxhcHNlZCAhPT0gMCAmJiB0aGlzLl9pbml0dGVkICYmIHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKCh0bC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMuX3RvdGFsVGltZSA6IChyYXcgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fdGltZVNjYWxlKSwgdHJ1ZSwgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBjaGFuZ2VkIHZpYSBzb21lIG90aGVyIHR3ZWVuIG9yIG1hbnVhbCB1cGRhdGUgYnkgdGhlIHVzZXIsIHdlIHNob3VsZCBmb3JjZSBhIHJlbmRlci5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2djICYmICF2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNpbXBsZVRpbWVsaW5lXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgU2ltcGxlVGltZWxpbmUgPSBfY2xhc3MoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIDAsIHZhcnMpO1xuXHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSB0aGlzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHAgPSBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNpbXBsZVRpbWVsaW5lO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdHAuX2ZpcnN0ID0gcC5fbGFzdCA9IHAuX3JlY2VudCA9IG51bGw7XG5cdFx0cC5fc29ydENoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRwLmFkZCA9IHAuaW5zZXJ0ID0gZnVuY3Rpb24oY2hpbGQsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIHByZXZUd2Vlbiwgc3Q7XG5cdFx0XHRjaGlsZC5fc3RhcnRUaW1lID0gTnVtYmVyKHBvc2l0aW9uIHx8IDApICsgY2hpbGQuX2RlbGF5O1xuXHRcdFx0aWYgKGNoaWxkLl9wYXVzZWQpIGlmICh0aGlzICE9PSBjaGlsZC5fdGltZWxpbmUpIHsgLy93ZSBvbmx5IGFkanVzdCB0aGUgX3BhdXNlVGltZSBpZiBpdCB3YXNuJ3QgaW4gdGhpcyB0aW1lbGluZSBhbHJlYWR5LiBSZW1lbWJlciwgc29tZXRpbWVzIGEgdHdlZW4gd2lsbCBiZSBpbnNlcnRlZCBhZ2FpbiBpbnRvIHRoZSBzYW1lIHRpbWVsaW5lIHdoZW4gaXRzIHN0YXJ0VGltZSBpcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIHR3ZWVucyBpbiB0aGUgVGltZWxpbmVMaXRlL01heCBhcmUgcmUtb3JkZXJlZCBwcm9wZXJseSBpbiB0aGUgbGlua2VkIGxpc3QgKHNvIGV2ZXJ5dGhpbmcgcmVuZGVycyBpbiB0aGUgcHJvcGVyIG9yZGVyKS5cblx0XHRcdFx0Y2hpbGQuX3BhdXNlVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoKHRoaXMucmF3VGltZSgpIC0gY2hpbGQuX3N0YXJ0VGltZSkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC50aW1lbGluZSkge1xuXHRcdFx0XHRjaGlsZC50aW1lbGluZS5fcmVtb3ZlKGNoaWxkLCB0cnVlKTsgLy9yZW1vdmVzIGZyb20gZXhpc3RpbmcgdGltZWxpbmUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgYWRkZWQgdG8gdGhpcyBvbmUuXG5cdFx0XHR9XG5cdFx0XHRjaGlsZC50aW1lbGluZSA9IGNoaWxkLl90aW1lbGluZSA9IHRoaXM7XG5cdFx0XHRpZiAoY2hpbGQuX2djKSB7XG5cdFx0XHRcdGNoaWxkLl9lbmFibGVkKHRydWUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICh0aGlzLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0c3QgPSBjaGlsZC5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAocHJldlR3ZWVuICYmIHByZXZUd2Vlbi5fc3RhcnRUaW1lID4gc3QpIHtcblx0XHRcdFx0XHRwcmV2VHdlZW4gPSBwcmV2VHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VHdlZW4pIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSBwcmV2VHdlZW4uX25leHQ7XG5cdFx0XHRcdHByZXZUd2Vlbi5fbmV4dCA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0dGhpcy5fZmlyc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC5fbmV4dCkge1xuXHRcdFx0XHRjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbGFzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGQuX3ByZXYgPSBwcmV2VHdlZW47XG5cdFx0XHR0aGlzLl9yZWNlbnQgPSBjaGlsZDtcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0aWYgKHR3ZWVuLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdGlmICghc2tpcERpc2FibGUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHdlZW4uX3ByZXYpIHtcblx0XHRcdFx0XHR0d2Vlbi5fcHJldi5fbmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuLl9uZXh0KSB7XG5cdFx0XHRcdFx0dHdlZW4uX25leHQuX3ByZXYgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2xhc3QgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gdHdlZW4udGltZWxpbmUgPSBudWxsO1xuXHRcdFx0XHRpZiAodHdlZW4gPT09IHRoaXMuX3JlY2VudCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRuZXh0O1xuXHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRpZiAodHdlZW4uX2FjdGl2ZSB8fCAodGltZSA+PSB0d2Vlbi5fc3RhcnRUaW1lICYmICF0d2Vlbi5fcGF1c2VkKSkge1xuXHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0fTtcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuTGl0ZSA9IF9jbGFzcyhcIlR3ZWVuTGl0ZVwiLCBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2VlbkxpdGUucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblxuXHRcdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXG5cdFx0XHRcdHZhciBpc1NlbGVjdG9yID0gKHRhcmdldC5qcXVlcnkgfHwgKHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0WzBdICYmICh0YXJnZXRbMF0gPT09IHdpbmRvdyB8fCAodGFyZ2V0WzBdLm5vZGVUeXBlICYmIHRhcmdldFswXS5zdHlsZSAmJiAhdGFyZ2V0Lm5vZGVUeXBlKSkpKSxcblx0XHRcdFx0XHRvdmVyd3JpdGUgPSB0aGlzLnZhcnMub3ZlcndyaXRlLFxuXHRcdFx0XHRcdGksIHRhcmcsIHRhcmdldHM7XG5cblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlID0gKG92ZXJ3cml0ZSA9PSBudWxsKSA/IF9vdmVyd3JpdGVMb29rdXBbVHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGVdIDogKHR5cGVvZihvdmVyd3JpdGUpID09PSBcIm51bWJlclwiKSA/IG92ZXJ3cml0ZSA+PiAwIDogX292ZXJ3cml0ZUxvb2t1cFtvdmVyd3JpdGVdO1xuXG5cdFx0XHRcdGlmICgoaXNTZWxlY3RvciB8fCB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSB8fCAodGFyZ2V0LnB1c2ggJiYgX2lzQXJyYXkodGFyZ2V0KSkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0KTsgIC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gW107XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmcpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpLS1dID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmcpOyAvL2luIGNhc2UgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpKzEsIDEpOyAvL3RvIGF2b2lkIGFuIGVuZGxlc3MgbG9vcCAoY2FuJ3QgaW1hZ2luZSB3aHkgdGhlIHNlbGVjdG9yIHdvdWxkIHJldHVybiBhIHN0cmluZywgYnV0IGp1c3QgaW4gY2FzZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZy5sZW5ndGggJiYgdGFyZyAhPT0gd2luZG93ICYmIHRhcmdbMF0gJiYgKHRhcmdbMF0gPT09IHdpbmRvdyB8fCAodGFyZ1swXS5ub2RlVHlwZSAmJiB0YXJnWzBdLnN0eWxlICYmICF0YXJnLm5vZGVUeXBlKSkpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGlzIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc2VsZWN0b3Igb2JqZWN0cyAobGlrZSBqUXVlcnkgb2JqZWN0cyksIHdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgbGV2ZWwgYW5kIHB1bGwgdGhpbmdzIG91dCBpZiBuZWNlc3NhcnkuIEFsc28gbm90ZSB0aGF0IDxzZWxlY3Q+IGVsZW1lbnRzIHBhc3MgYWxsIHRoZSBjcml0ZXJpYSByZWdhcmRpbmcgbGVuZ3RoIGFuZCB0aGUgZmlyc3QgY2hpbGQgaGF2aW5nIHN0eWxlLCBzbyB3ZSBtdXN0IGFsc28gY2hlY2sgdG8gZW5zdXJlIHRoZSB0YXJnZXQgaXNuJ3QgYW4gSFRNTCBub2RlIGl0c2VsZi5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChfc2xpY2UodGFyZykpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmcsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5nc1tpXS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnLCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5nc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IHt9O1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRhcmdldCwgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5ncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5ncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9kZWxheSA9PT0gMCAmJiB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0XHR0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9pc1NlbGVjdG9yID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRyZXR1cm4gKHYgJiYgdi5sZW5ndGggJiYgdiAhPT0gd2luZG93ICYmIHZbMF0gJiYgKHZbMF0gPT09IHdpbmRvdyB8fCAodlswXS5ub2RlVHlwZSAmJiB2WzBdLnN0eWxlICYmICF2Lm5vZGVUeXBlKSkpOyAvL3dlIGNhbm5vdCBjaGVjayBcIm5vZGVUeXBlXCIgaWYgdGhlIHRhcmdldCBpcyB3aW5kb3cgZnJvbSB3aXRoaW4gYW4gaWZyYW1lLCBvdGhlcndpc2UgaXQgd2lsbCB0cmlnZ2VyIGEgc2VjdXJpdHkgZXJyb3IgaW4gc29tZSBicm93c2VycyBsaWtlIEZpcmVmb3guXG5cdFx0XHR9LFxuXHRcdFx0X2F1dG9DU1MgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdFx0dmFyIGNzcyA9IHt9LFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSAmJiAoIShwIGluIHRhcmdldCkgfHwgcCA9PT0gXCJ0cmFuc2Zvcm1cIiB8fCBwID09PSBcInhcIiB8fCBwID09PSBcInlcIiB8fCBwID09PSBcIndpZHRoXCIgfHwgcCA9PT0gXCJoZWlnaHRcIiB8fCBwID09PSBcImNsYXNzTmFtZVwiIHx8IHAgPT09IFwiYm9yZGVyXCIpICYmICghX3BsdWdpbnNbcF0gfHwgKF9wbHVnaW5zW3BdICYmIF9wbHVnaW5zW3BdLl9hdXRvQ1NTKSkpIHsgLy9ub3RlOiA8aW1nPiBlbGVtZW50cyBjb250YWluIHJlYWQtb25seSBcInhcIiBhbmQgXCJ5XCIgcHJvcGVydGllcy4gV2Ugc2hvdWxkIGFsc28gcHJpb3JpdGl6ZSBlZGl0aW5nIGNzcyB3aWR0aC9oZWlnaHQgcmF0aGVyIHRoYW4gdGhlIGVsZW1lbnQncyBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdFx0Y3NzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdGRlbGV0ZSB2YXJzW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXJzLmNzcyA9IGNzcztcblx0XHRcdH07XG5cblx0XHRwID0gVHdlZW5MaXRlLnByb3RvdHlwZSA9IG5ldyBBbmltYXRpb24oKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gVHdlZW5MaXRlO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXG4vLy0tLS1Ud2VlbkxpdGUgZGVmYXVsdHMsIG92ZXJ3cml0ZSBtYW5hZ2VtZW50LCBhbmQgcm9vdCB1cGRhdGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAucmF0aW8gPSAwO1xuXHRcdHAuX2ZpcnN0UFQgPSBwLl90YXJnZXRzID0gcC5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHAuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdHAuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSBwLl9sYXp5ID0gZmFsc2U7XG5cblx0XHRUd2VlbkxpdGUudmVyc2lvbiA9IFwiMS4xNi4xXCI7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRFYXNlID0gcC5fZWFzZSA9IG5ldyBFYXNlKG51bGwsIG51bGwsIDEsIDEpO1xuXHRcdFR3ZWVuTGl0ZS5kZWZhdWx0T3ZlcndyaXRlID0gXCJhdXRvXCI7XG5cdFx0VHdlZW5MaXRlLnRpY2tlciA9IF90aWNrZXI7XG5cdFx0VHdlZW5MaXRlLmF1dG9TbGVlcCA9IDEyMDtcblx0XHRUd2VlbkxpdGUubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0X3RpY2tlci5sYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHdpbmRvdy4kIHx8IHdpbmRvdy5qUXVlcnkgfHwgZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeTtcblx0XHRcdGlmIChzZWxlY3Rvcikge1xuXHRcdFx0XHRUd2VlbkxpdGUuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yKGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0eXBlb2YoZG9jdW1lbnQpID09PSBcInVuZGVmaW5lZFwiKSA/IGUgOiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSkgOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgoZS5jaGFyQXQoMCkgPT09IFwiI1wiKSA/IGUuc3Vic3RyKDEpIDogZSkpO1xuXHRcdH07XG5cblx0XHR2YXIgX2xhenlUd2VlbnMgPSBbXSxcblx0XHRcdF9sYXp5TG9va3VwID0ge30sXG5cdFx0XHRfaW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMgPSB7aXNBcnJheTpfaXNBcnJheSwgaXNTZWxlY3RvcjpfaXNTZWxlY3RvciwgbGF6eVR3ZWVuczpfbGF6eVR3ZWVuc30sIC8vZ2l2ZXMgdXMgYSB3YXkgdG8gZXhwb3NlIGNlcnRhaW4gcHJpdmF0ZSB2YWx1ZXMgdG8gb3RoZXIgR3JlZW5Tb2NrIGNsYXNzZXMgd2l0aG91dCBjb250YW1pbmF0aW5nIHRoYSBtYWluIFR3ZWVuTGl0ZSBvYmplY3QuXG5cdFx0XHRfcGx1Z2lucyA9IFR3ZWVuTGl0ZS5fcGx1Z2lucyA9IHt9LFxuXHRcdFx0X3R3ZWVuTG9va3VwID0gX2ludGVybmFscy50d2Vlbkxvb2t1cCA9IHt9LFxuXHRcdFx0X3R3ZWVuTG9va3VwTnVtID0gMCxcblx0XHRcdF9yZXNlcnZlZFByb3BzID0gX2ludGVybmFscy5yZXNlcnZlZFByb3BzID0ge2Vhc2U6MSwgZGVsYXk6MSwgb3ZlcndyaXRlOjEsIG9uQ29tcGxldGU6MSwgb25Db21wbGV0ZVBhcmFtczoxLCBvbkNvbXBsZXRlU2NvcGU6MSwgdXNlRnJhbWVzOjEsIHJ1bkJhY2t3YXJkczoxLCBzdGFydEF0OjEsIG9uVXBkYXRlOjEsIG9uVXBkYXRlUGFyYW1zOjEsIG9uVXBkYXRlU2NvcGU6MSwgb25TdGFydDoxLCBvblN0YXJ0UGFyYW1zOjEsIG9uU3RhcnRTY29wZToxLCBvblJldmVyc2VDb21wbGV0ZToxLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczoxLCBvblJldmVyc2VDb21wbGV0ZVNjb3BlOjEsIG9uUmVwZWF0OjEsIG9uUmVwZWF0UGFyYW1zOjEsIG9uUmVwZWF0U2NvcGU6MSwgZWFzZVBhcmFtczoxLCB5b3lvOjEsIGltbWVkaWF0ZVJlbmRlcjoxLCByZXBlYXQ6MSwgcmVwZWF0RGVsYXk6MSwgZGF0YToxLCBwYXVzZWQ6MSwgcmV2ZXJzZWQ6MSwgYXV0b0NTUzoxLCBsYXp5OjEsIG9uT3ZlcndyaXRlOjF9LFxuXHRcdFx0X292ZXJ3cml0ZUxvb2t1cCA9IHtub25lOjAsIGFsbDoxLCBhdXRvOjIsIGNvbmN1cnJlbnQ6MywgYWxsT25TdGFydDo0LCBwcmVleGlzdGluZzo1LCBcInRydWVcIjoxLCBcImZhbHNlXCI6MH0sXG5cdFx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9yb290VGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X25leHRHQ0ZyYW1lID0gMzAsXG5cdFx0XHRfbGF6eVJlbmRlciA9IF9pbnRlcm5hbHMubGF6eVJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSA9IF9sYXp5VHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0XHR0d2Vlbjtcblx0XHRcdFx0X2xhenlMb29rdXAgPSB7fTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dHdlZW4gPSBfbGF6eVR3ZWVuc1tpXTtcblx0XHRcdFx0XHRpZiAodHdlZW4gJiYgdHdlZW4uX2xhenkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKTtcblx0XHRcdFx0XHRcdHR3ZWVuLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cdFx0XHR9O1xuXG5cdFx0X3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci50aW1lO1xuXHRcdF9yb290RnJhbWVzVGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIuZnJhbWU7XG5cdFx0X3Jvb3RUaW1lbGluZS5fYWN0aXZlID0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fYWN0aXZlID0gdHJ1ZTtcblx0XHRzZXRUaW1lb3V0KF9sYXp5UmVuZGVyLCAxKTsgLy9vbiBzb21lIG1vYmlsZSBkZXZpY2VzLCB0aGVyZSBpc24ndCBhIFwidGlja1wiIGJlZm9yZSBjb2RlIHJ1bnMgd2hpY2ggbWVhbnMgYW55IGxhenkgcmVuZGVycyB3b3VsZG4ndCBydW4gYmVmb3JlIHRoZSBuZXh0IG9mZmljaWFsIFwidGlja1wiLlxuXG5cdFx0QW5pbWF0aW9uLl91cGRhdGVSb290ID0gVHdlZW5MaXRlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSwgYSwgcDtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2lmIGNvZGUgaXMgcnVuIG91dHNpZGUgb2YgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBsb29wLCB0aGVyZSBtYXkgYmUgdHdlZW5zIHF1ZXVlZCBBRlRFUiB0aGUgZW5naW5lIHJlZnJlc2hlZCwgc28gd2UgbmVlZCB0byBlbnN1cmUgYW55IHBlbmRpbmcgcmVuZGVycyBvY2N1ciBiZWZvcmUgd2UgcmVmcmVzaCBhZ2Fpbi5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yb290VGltZWxpbmUucmVuZGVyKChfdGlja2VyLnRpbWUgLSBfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLnJlbmRlcigoX3RpY2tlci5mcmFtZSAtIF9yb290RnJhbWVzVGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdEZyYW1lc1RpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHtcblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkgeyAvL2R1bXAgZ2FyYmFnZSBldmVyeSAxMjAgZnJhbWVzIG9yIHdoYXRldmVyIHRoZSB1c2VyIHNldHMgVHdlZW5MaXRlLmF1dG9TbGVlcCB0b1xuXHRcdFx0XHRcdF9uZXh0R0NGcmFtZSA9IF90aWNrZXIuZnJhbWUgKyAocGFyc2VJbnQoVHdlZW5MaXRlLmF1dG9TbGVlcCwgMTApIHx8IDEyMCk7XG5cdFx0XHRcdFx0Zm9yIChwIGluIF90d2Vlbkxvb2t1cCkge1xuXHRcdFx0XHRcdFx0YSA9IF90d2Vlbkxvb2t1cFtwXS50d2VlbnM7XG5cdFx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFbaV0uX2djKSB7XG5cdFx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChhLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgX3R3ZWVuTG9va3VwW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2lmIHRoZXJlIGFyZSBubyBtb3JlIHR3ZWVucyBpbiB0aGUgcm9vdCB0aW1lbGluZXMsIG9yIGlmIHRoZXkncmUgYWxsIHBhdXNlZCwgbWFrZSB0aGUgX3RpbWVyIHNsZWVwIHRvIHJlZHVjZSBsb2FkIG9uIHRoZSBDUFUgc2xpZ2h0bHlcblx0XHRcdFx0XHRwID0gX3Jvb3RUaW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRcdFx0aWYgKCFwIHx8IHAuX3BhdXNlZCkgaWYgKFR3ZWVuTGl0ZS5hdXRvU2xlZXAgJiYgIV9yb290RnJhbWVzVGltZWxpbmUuX2ZpcnN0ICYmIF90aWNrZXIuX2xpc3RlbmVycy50aWNrLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHAgJiYgcC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSBwLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFwKSB7XG5cdFx0XHRcdFx0XHRcdF90aWNrZXIuc2xlZXAoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRfdGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIEFuaW1hdGlvbi5fdXBkYXRlUm9vdCk7XG5cblx0XHR2YXIgX3JlZ2lzdGVyID0gZnVuY3Rpb24odGFyZ2V0LCB0d2Vlbiwgc2NydWIpIHtcblx0XHRcdFx0dmFyIGlkID0gdGFyZ2V0Ll9nc1R3ZWVuSUQsIGEsIGk7XG5cdFx0XHRcdGlmICghX3R3ZWVuTG9va3VwW2lkIHx8ICh0YXJnZXQuX2dzVHdlZW5JRCA9IGlkID0gXCJ0XCIgKyAoX3R3ZWVuTG9va3VwTnVtKyspKV0pIHtcblx0XHRcdFx0XHRfdHdlZW5Mb29rdXBbaWRdID0ge3RhcmdldDp0YXJnZXQsIHR3ZWVuczpbXX07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0YSA9IF90d2Vlbkxvb2t1cFtpZF0udHdlZW5zO1xuXHRcdFx0XHRcdGFbKGkgPSBhLmxlbmd0aCldID0gdHdlZW47XG5cdFx0XHRcdFx0aWYgKHNjcnViKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFbaV0gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIF90d2Vlbkxvb2t1cFtpZF0udHdlZW5zO1xuXHRcdFx0fSxcblxuXHRcdFx0X29uT3ZlcndyaXRlID0gZnVuY3Rpb24ob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IG92ZXJ3cml0dGVuVHdlZW4udmFycy5vbk92ZXJ3cml0ZSwgcjEsIHIyO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIxID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jID0gVHdlZW5MaXRlLm9uT3ZlcndyaXRlO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIyID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHIxICE9PSBmYWxzZSAmJiByMiAhPT0gZmFsc2UpO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHByb3BzLCBtb2RlLCBzaWJsaW5ncykge1xuXHRcdFx0XHR2YXIgaSwgY2hhbmdlZCwgY3VyVHdlZW4sIGw7XG5cdFx0XHRcdGlmIChtb2RlID09PSAxIHx8IG1vZGUgPj0gNCkge1xuXHRcdFx0XHRcdGwgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSAhPT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjdXJUd2Vlbi5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoX29uT3ZlcndyaXRlKGN1clR3ZWVuLCB0d2VlbikgJiYgY3VyVHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1vZGUgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vTk9URTogQWRkIDAuMDAwMDAwMDAwMSB0byBvdmVyY29tZSBmbG9hdGluZyBwb2ludCBlcnJvcnMgdGhhdCBjYW4gY2F1c2UgdGhlIHN0YXJ0VGltZSB0byBiZSBWRVJZIHNsaWdodGx5IG9mZiAod2hlbiBhIHR3ZWVuJ3MgdGltZSgpIGlzIHNldCBmb3IgZXhhbXBsZSlcblx0XHRcdFx0dmFyIHN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWUgKyBfdGlueU51bSxcblx0XHRcdFx0XHRvdmVybGFwcyA9IFtdLFxuXHRcdFx0XHRcdG9Db3VudCA9IDAsXG5cdFx0XHRcdFx0emVyb0R1ciA9ICh0d2Vlbi5fZHVyYXRpb24gPT09IDApLFxuXHRcdFx0XHRcdGdsb2JhbFN0YXJ0O1xuXHRcdFx0XHRpID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pID09PSB0d2VlbiB8fCBjdXJUd2Vlbi5fZ2MgfHwgY3VyVHdlZW4uX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0Ly9pZ25vcmVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl90aW1lbGluZSAhPT0gdHdlZW4uX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRnbG9iYWxTdGFydCA9IGdsb2JhbFN0YXJ0IHx8IF9jaGVja092ZXJsYXAodHdlZW4sIDAsIHplcm9EdXIpO1xuXHRcdFx0XHRcdFx0aWYgKF9jaGVja092ZXJsYXAoY3VyVHdlZW4sIGdsb2JhbFN0YXJ0LCB6ZXJvRHVyKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gc3RhcnRUaW1lKSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSArIGN1clR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIGN1clR3ZWVuLl90aW1lU2NhbGUgPiBzdGFydFRpbWUpIGlmICghKCh6ZXJvRHVyIHx8ICFjdXJUd2Vlbi5faW5pdHRlZCkgJiYgc3RhcnRUaW1lIC0gY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSAwLjAwMDAwMDAwMDIpKSB7XG5cdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpID0gb0NvdW50O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjdXJUd2VlbiA9IG92ZXJsYXBzW2ldO1xuXHRcdFx0XHRcdGlmIChtb2RlID09PSAyKSBpZiAoY3VyVHdlZW4uX2tpbGwocHJvcHMsIHRhcmdldCwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgfHwgKCFjdXJUd2Vlbi5fZmlyc3RQVCAmJiBjdXJUd2Vlbi5faW5pdHRlZCkpIHtcblx0XHRcdFx0XHRcdGlmIChtb2RlICE9PSAyICYmICFfb25PdmVyd3JpdGUoY3VyVHdlZW4sIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjdXJUd2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpKSB7IC8vaWYgYWxsIHByb3BlcnR5IHR3ZWVucyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRfY2hlY2tPdmVybGFwID0gZnVuY3Rpb24odHdlZW4sIHJlZmVyZW5jZSwgemVyb0R1cikge1xuXHRcdFx0XHR2YXIgdGwgPSB0d2Vlbi5fdGltZWxpbmUsXG5cdFx0XHRcdFx0dHMgPSB0bC5fdGltZVNjYWxlLFxuXHRcdFx0XHRcdHQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dCArPSB0bC5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdHRzICo9IHRsLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0aWYgKHRsLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAtMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0IC89IHRzO1xuXHRcdFx0XHRyZXR1cm4gKHQgPiByZWZlcmVuY2UpID8gdCAtIHJlZmVyZW5jZSA6ICgoemVyb0R1ciAmJiB0ID09PSByZWZlcmVuY2UpIHx8ICghdHdlZW4uX2luaXR0ZWQgJiYgdCAtIHJlZmVyZW5jZSA8IDIgKiBfdGlueU51bSkpID8gX3RpbnlOdW0gOiAoKHQgKz0gdHdlZW4udG90YWxEdXJhdGlvbigpIC8gdHdlZW4uX3RpbWVTY2FsZSAvIHRzKSA+IHJlZmVyZW5jZSArIF90aW55TnVtKSA/IDAgOiB0IC0gcmVmZXJlbmNlIC0gX3RpbnlOdW07XG5cdFx0XHR9O1xuXG5cbi8vLS0tLSBUd2VlbkxpdGUgaW5zdGFuY2UgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5faW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdG9wID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdGltbWVkaWF0ZSA9ICEhdi5pbW1lZGlhdGVSZW5kZXIsXG5cdFx0XHRcdGVhc2UgPSB2LmVhc2UsXG5cdFx0XHRcdGksIGluaXRQbHVnaW5zLCBwdCwgcCwgc3RhcnRWYXJzO1xuXHRcdFx0aWYgKHYuc3RhcnRBdCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy9pZiB3ZSd2ZSBydW4gYSBzdGFydEF0IHByZXZpb3VzbHkgKHdoZW4gdGhlIHR3ZWVuIGluc3RhbnRpYXRlZCksIHdlIHNob3VsZCByZXZlcnQgaXQgc28gdGhhdCB0aGUgdmFsdWVzIHJlLWluc3RhbnRpYXRlIGNvcnJlY3RseSBwYXJ0aWN1bGFybHkgZm9yIHJlbGF0aXZlIHR3ZWVucy4gV2l0aG91dCB0aGlzLCBhIFR3ZWVuTGl0ZS5mcm9tVG8ob2JqLCAxLCB7eDpcIis9MTAwXCJ9LCB7eDpcIi09MTAwXCJ9KSwgZm9yIGV4YW1wbGUsIHdvdWxkIGFjdHVhbGx5IGp1bXAgdG8gKz0yMDAgYmVjYXVzZSB0aGUgc3RhcnRBdCB3b3VsZCBydW4gdHdpY2UsIGRvdWJsaW5nIHRoZSByZWxhdGl2ZSBjaGFuZ2UuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2LnN0YXJ0QXQpIHsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIDEsIGZyb20sIHRvKS5mcm9tVG8oZSwgMSwgdG8sIGZyb20pO1xuXHRcdFx0XHRcdHN0YXJ0VmFyc1twXSA9IHYuc3RhcnRBdFtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMub3ZlcndyaXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXJ0VmFycy5pbW1lZGlhdGVSZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRzdGFydFZhcnMubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdHN0YXJ0VmFycy5zdGFydEF0ID0gc3RhcnRWYXJzLmRlbGF5ID0gbnVsbDsgLy9ubyBuZXN0aW5nIG9mIHN0YXJ0QXQgb2JqZWN0cyBhbGxvd2VkIChvdGhlcndpc2UgaXQgY291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCkuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBUd2VlbkxpdGUudG8odGhpcy50YXJnZXQsIDAsIHN0YXJ0VmFycyk7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsOyAvL3R3ZWVucyB0aGF0IHJlbmRlciBpbW1lZGlhdGVseSAobGlrZSBtb3N0IGZyb20oKSBhbmQgZnJvbVRvKCkgdHdlZW5zKSBzaG91bGRuJ3QgcmV2ZXJ0IHdoZW4gdGhlaXIgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSBzdGFydFRpbWUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgY291bGQgaGF2ZSBoYXBwZW5lZCBhbnl0aW1lIGFuZCBpdCBzaG91bGRuJ3QgYmUgZGlyZWN0bHkgY29ycmVsYXRlZCB0byB0aGlzIHR3ZWVuJ3Mgc3RhcnRUaW1lLiBJbWFnaW5lIHNldHRpbmcgdXAgYSBjb21wbGV4IGFuaW1hdGlvbiB3aGVyZSB0aGUgYmVnaW5uaW5nIHN0YXRlcyBvZiB2YXJpb3VzIG9iamVjdHMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGJ1dCB0aGUgdHdlZW4gZG9lc24ndCBoYXBwZW4gZm9yIHF1aXRlIHNvbWUgdGltZSAtIGlmIHdlIHJldmVydCB0byB0aGUgc3RhcnRpbmcgdmFsdWVzIGFzIHNvb24gYXMgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgdHdlZW4ncyBzdGFydFRpbWUsIGl0IHdpbGwgdGhyb3cgdGhpbmdzIG9mZiB2aXN1YWxseS4gUmV2ZXJzaW9uIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBUaW1lbGluZUxpdGUvTWF4IGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlICh3aGljaCBpcyB0aGUgZGVmYXVsdCBpbiB0aGUgY29udmVuaWVuY2UgbWV0aG9kcyBsaWtlIGZyb20oKSkuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChkdXIgIT09IDApIHtcblx0XHRcdFx0XHRcdHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZUxpdGUgb3IgVGltZWxpbmVNYXgsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHYucnVuQmFja3dhcmRzICYmIGR1ciAhPT0gMCkge1xuXHRcdFx0XHQvL2Zyb20oKSB0d2VlbnMgbXVzdCBiZSBoYW5kbGVkIHVuaXF1ZWx5OiB0aGVpciBiZWdpbm5pbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQgYnV0IHdlIGRvbid0IHdhbnQgb3ZlcndyaXRpbmcgdG8gb2NjdXIgeWV0ICh3aGVuIHRpbWUgaXMgc3RpbGwgMCkuIFdhaXQgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucyBiZWZvcmUgZG9pbmcgYWxsIHRoZSByb3V0aW5lcyBsaWtlIG92ZXJ3cml0aW5nLiBBdCB0aGF0IHRpbWUsIHdlIHNob3VsZCByZW5kZXIgYXQgdGhlIEVORCBvZiB0aGUgdHdlZW4gdG8gZW5zdXJlIHRoYXQgdGhpbmdzIGluaXRpYWxpemUgY29ycmVjdGx5IChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBnbyBiYWNrd2FyZHMpXG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lICE9PSAwKSB7IC8vaW4gcmFyZSBjYXNlcyAobGlrZSBpZiBhIGZyb20oKSB0d2VlbiBydW5zIGFuZCB0aGVuIGlzIGludmFsaWRhdGUoKS1lZCksIGltbWVkaWF0ZVJlbmRlciBjb3VsZCBiZSB0cnVlIGJ1dCB0aGUgaW5pdGlhbCBmb3JjZWQtcmVuZGVyIGdldHMgc2tpcHBlZCwgc28gdGhlcmUncyBubyBuZWVkIHRvIGZvcmNlIHRoZSByZW5kZXIgaW4gdGhpcyBjb250ZXh0IHdoZW4gdGhlIF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwXG5cdFx0XHRcdFx0XHRpbW1lZGlhdGUgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdikgeyAvL2NvcHkgcHJvcHMgaW50byBhIG5ldyBvYmplY3QgYW5kIHNraXAgYW55IHJlc2VydmVkIHByb3BzLCBvdGhlcndpc2Ugb25Db21wbGV0ZSBvciBvblVwZGF0ZSBvciBvblN0YXJ0IGNvdWxkIGZpcmUuIFdlIHNob3VsZCwgaG93ZXZlciwgcGVybWl0IGF1dG9DU1MgdG8gZ28gdGhyb3VnaC5cblx0XHRcdFx0XHRcdGlmICghX3Jlc2VydmVkUHJvcHNbcF0gfHwgcCA9PT0gXCJhdXRvQ1NTXCIpIHtcblx0XHRcdFx0XHRcdFx0cHRbcF0gPSB2W3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC5vdmVyd3JpdGUgPSAwO1xuXHRcdFx0XHRcdHB0LmRhdGEgPSBcImlzRnJvbVN0YXJ0XCI7IC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuXHRcdFx0XHRcdHB0LmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRcdHB0LmltbWVkaWF0ZVJlbmRlciA9IGltbWVkaWF0ZTsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBUd2VlbkxpdGUudG8odGhpcy50YXJnZXQsIDAsIHB0KTtcblx0XHRcdFx0XHRpZiAoIWltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5faW5pdCgpOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9lbmFibGVkKGZhbHNlKTsgLy9ubyBuZWVkIHRvIGhhdmUgdGhlIHR3ZWVuIHJlbmRlciBvbiB0aGUgbmV4dCBjeWNsZS4gRGlzYWJsZSBpdCBiZWNhdXNlIHdlJ2xsIGFsd2F5cyBtYW51YWxseSBjb250cm9sIHRoZSByZW5kZXJzIG9mIHRoZSBfc3RhcnRBdCB0d2Vlbi5cblx0XHRcdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZSA9IGVhc2UgPSAoIWVhc2UpID8gVHdlZW5MaXRlLmRlZmF1bHRFYXNlIDogKGVhc2UgaW5zdGFuY2VvZiBFYXNlKSA/IGVhc2UgOiAodHlwZW9mKGVhc2UpID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IEVhc2UoZWFzZSwgdi5lYXNlUGFyYW1zKSA6IF9lYXNlTWFwW2Vhc2VdIHx8IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZTtcblx0XHRcdGlmICh2LmVhc2VQYXJhbXMgaW5zdGFuY2VvZiBBcnJheSAmJiBlYXNlLmNvbmZpZykge1xuXHRcdFx0XHR0aGlzLl9lYXNlID0gZWFzZS5jb25maWcuYXBwbHkoZWFzZSwgdi5lYXNlUGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2Vhc2VUeXBlID0gdGhpcy5fZWFzZS5fdHlwZTtcblx0XHRcdHRoaXMuX2Vhc2VQb3dlciA9IHRoaXMuX2Vhc2UuX3Bvd2VyO1xuXHRcdFx0dGhpcy5fZmlyc3RQVCA9IG51bGw7XG5cblx0XHRcdGlmICh0aGlzLl90YXJnZXRzKSB7XG5cdFx0XHRcdGkgPSB0aGlzLl90YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9pbml0UHJvcHMoIHRoaXMuX3RhcmdldHNbaV0sICh0aGlzLl9wcm9wTG9va3VwW2ldID0ge30pLCB0aGlzLl9zaWJsaW5nc1tpXSwgKG9wID8gb3BbaV0gOiBudWxsKSkgKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbml0UGx1Z2lucyA9IHRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCwgdGhpcy5fcHJvcExvb2t1cCwgdGhpcy5fc2libGluZ3MsIG9wKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluaXRQbHVnaW5zKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkluaXRBbGxQcm9wc1wiLCB0aGlzKTsgLy9yZW9yZGVycyB0aGUgYXJyYXkgaW4gb3JkZXIgb2YgcHJpb3JpdHkuIFVzZXMgYSBzdGF0aWMgVHdlZW5QbHVnaW4gbWV0aG9kIGluIG9yZGVyIHRvIG1pbmltaXplIGZpbGUgc2l6ZSBpbiBUd2VlbkxpdGVcblx0XHRcdH1cblx0XHRcdGlmIChvcCkgaWYgKCF0aGlzLl9maXJzdFBUKSBpZiAodHlwZW9mKHRoaXMudGFyZ2V0KSAhPT0gXCJmdW5jdGlvblwiKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi4gSWYgdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCBpdCdzIHByb2JhYmx5IGEgZGVsYXllZENhbGwgc28gbGV0IGl0IGxpdmUuXG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmICh2LnJ1bkJhY2t3YXJkcykge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHB0LnMgKz0gcHQuYztcblx0XHRcdFx0XHRwdC5jID0gLXB0LmM7XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb25VcGRhdGUgPSB2Lm9uVXBkYXRlO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHAuX2luaXRQcm9wcyA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMpIHtcblx0XHRcdHZhciBwLCBpLCBpbml0UGx1Z2lucywgcGx1Z2luLCBwdCwgdjtcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfbGF6eUxvb2t1cFt0YXJnZXQuX2dzVHdlZW5JRF0pIHtcblx0XHRcdFx0X2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLnZhcnMuY3NzKSBpZiAodGFyZ2V0LnN0eWxlKSBpZiAodGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0Lm5vZGVUeXBlKSBpZiAoX3BsdWdpbnMuY3NzKSBpZiAodGhpcy52YXJzLmF1dG9DU1MgIT09IGZhbHNlKSB7IC8vaXQncyBzbyBjb21tb24gdG8gdXNlIFR3ZWVuTGl0ZS9NYXggdG8gYW5pbWF0ZSB0aGUgY3NzIG9mIERPTSBlbGVtZW50cywgd2UgYXNzdW1lIHRoYXQgaWYgdGhlIHRhcmdldCBpcyBhIERPTSBlbGVtZW50LCB0aGF0J3Mgd2hhdCBpcyBpbnRlbmRlZCAoYSBjb252ZW5pZW5jZSBzbyB0aGF0IHVzZXJzIGRvbid0IGhhdmUgdG8gd3JhcCB0aGluZ3MgaW4gY3NzOnt9LCBhbHRob3VnaCB3ZSBzdGlsbCByZWNvbW1lbmQgaXQgZm9yIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGJvb3N0IGFuZCBiZXR0ZXIgc3BlY2lmaWNpdHkpLiBOb3RlOiB3ZSBjYW5ub3QgY2hlY2sgXCJub2RlVHlwZVwiIG9uIHRoZSB3aW5kb3cgaW5zaWRlIGFuIGlmcmFtZS5cblx0XHRcdFx0X2F1dG9DU1ModGhpcy52YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIHRoaXMudmFycykge1xuXHRcdFx0XHR2ID0gdGhpcy52YXJzW3BdO1xuXHRcdFx0XHRpZiAoX3Jlc2VydmVkUHJvcHNbcF0pIHtcblx0XHRcdFx0XHRpZiAodikgaWYgKCh2IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh2LnB1c2ggJiYgX2lzQXJyYXkodikpKSBpZiAodi5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2ID0gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyh2LCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3BdKCkpLl9vbkluaXRUd2Vlbih0YXJnZXQsIHRoaXMudmFyc1twXSwgdGhpcykpIHtcblxuXHRcdFx0XHRcdC8vdCAtIHRhcmdldCBcdFx0W29iamVjdF1cblx0XHRcdFx0XHQvL3AgLSBwcm9wZXJ0eSBcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3MgLSBzdGFydFx0XHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0Ly9jIC0gY2hhbmdlXHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0Ly9mIC0gaXNGdW5jdGlvblx0W2Jvb2xlYW5dXG5cdFx0XHRcdFx0Ly9uIC0gbmFtZVx0XHRcdFtzdHJpbmddXG5cdFx0XHRcdFx0Ly9wZyAtIGlzUGx1Z2luIFx0W2Jvb2xlYW5dXG5cdFx0XHRcdFx0Ly9wciAtIHByaW9yaXR5XHRcdFtudW1iZXJdXG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6cGx1Z2luLCBwOlwic2V0UmF0aW9cIiwgczowLCBjOjEsIGY6dHJ1ZSwgbjpwLCBwZzp0cnVlLCBwcjpwbHVnaW4uX3ByaW9yaXR5fTtcblx0XHRcdFx0XHRpID0gcGx1Z2luLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwcm9wTG9va3VwW3BsdWdpbi5fb3ZlcndyaXRlUHJvcHNbaV1dID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBsdWdpbi5fcHJpb3JpdHkgfHwgcGx1Z2luLl9vbkluaXRBbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aW5pdFBsdWdpbnMgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9vbkRpc2FibGUgfHwgcGx1Z2luLl9vbkVuYWJsZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHByb3BMb29rdXBbcF0gPSBwdCA9IHtfbmV4dDp0aGlzLl9maXJzdFBULCB0OnRhcmdldCwgcDpwLCBmOih0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSwgbjpwLCBwZzpmYWxzZSwgcHI6MH07XG5cdFx0XHRcdFx0cHQucyA9ICghcHQuZikgPyBwYXJzZUZsb2F0KHRhcmdldFtwXSkgOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCk7XG5cdFx0XHRcdFx0cHQuYyA9ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcih2LnN1YnN0cigyKSkgOiAoTnVtYmVyKHYpIC0gcHQucykgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQpIGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG92ZXJ3cml0dGVuUHJvcHMpIGlmICh0aGlzLl9raWxsKG92ZXJ3cml0dGVuUHJvcHMsIHRhcmdldCkpIHsgLy9hbm90aGVyIHR3ZWVuIG1heSBoYXZlIHRyaWVkIHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHdlZW4gYmVmb3JlIGluaXQoKSB3YXMgY2FsbGVkIChsaWtlIGlmIHR3byB0d2VlbnMgc3RhcnQgYXQgdGhlIHNhbWUgdGltZSwgdGhlIG9uZSBjcmVhdGVkIHNlY29uZCB3aWxsIHJ1biBmaXJzdClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9vdmVyd3JpdGUgPiAxKSBpZiAodGhpcy5fZmlyc3RQVCkgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDEpIGlmIChfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBwcm9wTG9va3VwLCB0aGlzLl9vdmVyd3JpdGUsIHNpYmxpbmdzKSkge1xuXHRcdFx0XHR0aGlzLl9raWxsKHByb3BMb29rdXAsIHRhcmdldCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvcHModGFyZ2V0LCBwcm9wTG9va3VwLCBzaWJsaW5ncywgb3ZlcndyaXR0ZW5Qcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZmlyc3RQVCkgaWYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgZG9uJ3QgbGF6eSByZW5kZXIgYnkgZGVmYXVsdDsgZXZlcnl0aGluZyBlbHNlIGRvZXMuXG5cdFx0XHRcdF9sYXp5TG9va3VwW3RhcmdldC5fZ3NUd2VlbklEXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5pdFBsdWdpbnM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2UmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0aXNDb21wbGV0ZSwgY2FsbGJhY2ssIHB0LCByYXdQcmV2VGltZTtcblx0XHRcdGlmICh0aW1lID49IGR1cmF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDEpIDogMTtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCApIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKGZvcmNlIHx8IHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbik7IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgfHwgcHJldlJhd1ByZXZUaW1lIDwgMCB8fCAocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgIT09IFwiaXNQYXVzZVwiKSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkgeyAvL25vdGU6IHdoZW4gdGhpcy5kYXRhIGlzIFwiaXNQYXVzZVwiLCBpdCdzIGEgY2FsbGJhY2sgYWRkZWQgYnkgYWRkUGF1c2UoKSBvbiBhIHRpbWVsaW5lIHRoYXQgd2Ugc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBMRUFWSU5HIGl0cyBleGFjdCBzdGFydCB0aW1lLiBJbiBvdGhlciB3b3JkcywgdGwuYWRkUGF1c2UoMSkucGxheSgxKSBzaG91bGRuJ3QgcGF1c2UuXG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCAmJiAhKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhID09PSBcImlzUGF1c2VcIikpIHtcblx0XHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHsgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXG5cdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGltZTtcblxuXHRcdFx0XHRpZiAodGhpcy5fZWFzZVR5cGUpIHtcblx0XHRcdFx0XHR2YXIgciA9IHRpbWUgLyBkdXJhdGlvbiwgdHlwZSA9IHRoaXMuX2Vhc2VUeXBlLCBwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXQoKTtcblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8IHRoaXMuX2djKSB7IC8vaW1tZWRpYXRlUmVuZGVyIHR3ZWVucyB0eXBpY2FsbHkgd29uJ3QgaW5pdGlhbGl6ZSB1bnRpbCB0aGUgcGxheWhlYWQgYWR2YW5jZXMgKF90aW1lIGlzIGdyZWF0ZXIgdGhhbiAwKSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdmVyd3JpdGluZyBvY2N1cnMgcHJvcGVybHkuIEFsc28sIGlmIGFsbCBvZiB0aGUgdHdlZW5pbmcgcHJvcGVydGllcyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gKHdoaWNoIHdvdWxkIGNhdXNlIF9nYyB0byBiZSB0cnVlLCBhcyBzZXQgaW4gX2luaXQoKSksIHdlIHNob3VsZG4ndCBjb250aW51ZSBvdGhlcndpc2UgYW4gb25TdGFydCBjYWxsYmFjayBjb3VsZCBiZSBjYWxsZWQgZm9yIGV4YW1wbGUuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFmb3JjZSAmJiB0aGlzLl9maXJzdFBUICYmICgodGhpcy52YXJzLmxhenkgIT09IGZhbHNlICYmIHRoaXMuX2R1cmF0aW9uKSB8fCAodGhpcy52YXJzLmxhenkgJiYgIXRoaXMuX2R1cmF0aW9uKSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gcHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0X2xhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKCh0aGlzLl90aW1lID09PSAwKSA/IDAgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2xhenkgIT09IGZhbHNlKSB7IC8vaW4gY2FzZSBhIGxhenkgcmVuZGVyIGlzIHBlbmRpbmcsIHdlIHNob3VsZCBmbHVzaCBpdCBiZWNhdXNlIHRoZSBuZXcgcmVuZGVyIGlzIG9jY3VycmluZyBub3cgKGltYWdpbmUgYSBsYXp5IHR3ZWVuIGluc3RhbnRpYXRpbmcgYW5kIHRoZW4gaW1tZWRpYXRlbHkgdGhlIHVzZXIgY2FsbHMgdHdlZW4uc2Vlayh0d2Vlbi5kdXJhdGlvbigpKSwgc2tpcHBpbmcgdG8gdGhlIGVuZCAtIHRoZSBlbmQgcmVuZGVyIHdvdWxkIGJlIGZvcmNlZCwgYW5kIHRoZW4gaWYgd2UgZGlkbid0IGZsdXNoIHRoZSBsYXp5IHJlbmRlciwgaXQnZCBmaXJlIEFGVEVSIHRoZSBzZWVrKCksIHJlbmRlcmluZyBpdCBhdCB0aGUgd3JvbmcgdGltZS5cblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPj0gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAgLy9zbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgYSB0d2VlbiAoYXMgb3Bwb3NlZCB0byB0aGUgdGltZWxpbmUgcmVuZGVyaW5nIGl0KSwgdGhlIHRpbWVsaW5lIGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHR3ZWVuIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLlxuXHRcdFx0fVxuXHRcdFx0aWYgKHByZXZUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RpbWUgIT09IDAgfHwgZHVyYXRpb24gPT09IDApIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0XHR0aGlzLnZhcnMub25TdGFydC5hcHBseSh0aGlzLnZhcnMub25TdGFydFNjb3BlIHx8IHRoaXMsIHRoaXMudmFycy5vblN0YXJ0UGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXShwdC5jICogdGhpcy5yYXRpbyArIHB0LnMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5jICogdGhpcy5yYXRpbyArIHB0LnM7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29uVXBkYXRlKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkgaWYgKHRoaXMuX3N0YXJ0QXQgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90aW1lICE9PSBwcmV2VGltZSB8fCBpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUuYXBwbHkodGhpcy52YXJzLm9uVXBkYXRlU2NvcGUgfHwgdGhpcywgdGhpcy52YXJzLm9uVXBkYXRlUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKHRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgIXRoaXMuX29uVXBkYXRlICYmIHRpbWUgIT09IC0wLjAwMDEpIHsgLy8tMC4wMDAxIGlzIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IHdlIHVzZSB3aGVuIGxvb3BpbmcgYmFjayB0byB0aGUgYmVnaW5uaW5nIG9mIGEgcmVwZWF0ZWQgVGltZWxpbmVNYXgsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkbid0IHJlbmRlciB0aGUgX3N0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMudmFyc1tjYWxsYmFja10uYXBwbHkodGhpcy52YXJzW2NhbGxiYWNrICsgXCJTY29wZVwiXSB8fCB0aGlzLCB0aGlzLnZhcnNbY2FsbGJhY2sgKyBcIlBhcmFtc1wiXSB8fCBfYmxhbmtBcnJheSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiByYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0pIHsgLy90aGUgb25Db21wbGV0ZSBvciBvblJldmVyc2VDb21wbGV0ZSBjb3VsZCB0cmlnZ2VyIG1vdmVtZW50IG9mIHRoZSBwbGF5aGVhZCBhbmQgZm9yIHplcm8tZHVyYXRpb24gdHdlZW5zICh3aGljaCBtdXN0IGRpc2Nlcm4gZGlyZWN0aW9uKSB0aGF0IGxhbmQgZGlyZWN0bHkgYmFjayBvbiB0aGVpciBzdGFydCB0aW1lLCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgYWdhaW4gb24gdGhlIG5leHQgcmVuZGVyLiBUaGluayBvZiBzZXZlcmFsIGFkZFBhdXNlKCkncyBpbiBhIHRpbWVsaW5lIHRoYXQgZm9yY2VzIHRoZSBwbGF5aGVhZCB0byBhIGNlcnRhaW4gc3BvdCwgYnV0IHdoYXQgaWYgaXQncyBhbHJlYWR5IHBhdXNlZCBhbmQgYW5vdGhlciB0d2VlbiBpcyB0d2VlbmluZyB0aGUgXCJ0aW1lXCIgb2YgdGhlIHRpbWVsaW5lPyBFYWNoIHRpbWUgaXQgbW92ZXMgW2ZvcndhcmRdIHBhc3QgdGhhdCBzcG90LCBpdCB3b3VsZCBtb3ZlIGJhY2ssIGFuZCBzaW5jZSBzdXBwcmVzc0V2ZW50cyBpcyB0cnVlLCBpdCdkIHJlc2V0IF9yYXdQcmV2VGltZSB0byBfdGlueU51bSBzbyB0aGF0IHdoZW4gaXQgYmVnaW5zIGFnYWluLCB0aGUgY2FsbGJhY2sgd291bGQgZmlyZSAoc28gdWx0aW1hdGVseSBpdCBjb3VsZCBib3VuY2UgYmFjayBhbmQgZm9ydGggZHVyaW5nIHRoYXQgdHdlZW4pLiBBZ2FpbiwgdGhpcyBpcyBhIHZlcnkgdW5jb21tb24gc2NlbmFyaW8sIGJ1dCBwb3NzaWJsZSBub25ldGhlbGVzcy5cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCwgb3ZlcndyaXRpbmdUd2Vlbikge1xuXHRcdFx0aWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0dmFycyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFycyA9PSBudWxsKSBpZiAodGFyZ2V0ID09IG51bGwgfHwgdGFyZ2V0ID09PSB0aGlzLnRhcmdldCkge1xuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gKHRhcmdldCB8fCB0aGlzLl90YXJnZXRzIHx8IHRoaXMudGFyZ2V0KSA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBpLCBvdmVyd3JpdHRlblByb3BzLCBwLCBwdCwgcHJvcExvb2t1cCwgY2hhbmdlZCwga2lsbFByb3BzLCByZWNvcmQsIGtpbGxlZDtcblx0XHRcdGlmICgoX2lzQXJyYXkodGFyZ2V0KSB8fCBfaXNTZWxlY3Rvcih0YXJnZXQpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRpID0gdGFyZ2V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2tpbGwodmFycywgdGFyZ2V0W2ldKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0aGlzLl90YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQgPT09IHRoaXMuX3RhcmdldHNbaV0pIHtcblx0XHRcdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXBbaV0gfHwge307XG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXA7XG5cdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocHJvcExvb2t1cCkge1xuXHRcdFx0XHRcdGtpbGxQcm9wcyA9IHZhcnMgfHwgcHJvcExvb2t1cDtcblx0XHRcdFx0XHRyZWNvcmQgPSAodmFycyAhPT0gb3ZlcndyaXR0ZW5Qcm9wcyAmJiBvdmVyd3JpdHRlblByb3BzICE9PSBcImFsbFwiICYmIHZhcnMgIT09IHByb3BMb29rdXAgJiYgKHR5cGVvZih2YXJzKSAhPT0gXCJvYmplY3RcIiB8fCAhdmFycy5fdGVtcEtpbGwpKTsgLy9fdGVtcEtpbGwgaXMgYSBzdXBlci1zZWNyZXQgd2F5IHRvIGRlbGV0ZSBhIHBhcnRpY3VsYXIgdHdlZW5pbmcgcHJvcGVydHkgYnV0IE5PVCBoYXZlIGl0IHJlbWVtYmVyZWQgYXMgYW4gb2ZmaWNpYWwgb3ZlcndyaXR0ZW4gcHJvcGVydHkgKGxpa2UgaW4gQmV6aWVyUGx1Z2luKVxuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGluZ1R3ZWVuICYmIChUd2VlbkxpdGUub25PdmVyd3JpdGUgfHwgdGhpcy52YXJzLm9uT3ZlcndyaXRlKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcExvb2t1cFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgha2lsbGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRraWxsZWQgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0a2lsbGVkLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghX29uT3ZlcndyaXRlKHRoaXMsIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkKSkgeyAvL2lmIHRoZSBvbk92ZXJ3cml0ZSByZXR1cm5lZCBmYWxzZSwgdGhhdCBtZWFucyB0aGUgdXNlciB3YW50cyB0byBvdmVycmlkZSB0aGUgb3ZlcndyaXRpbmcgKGNhbmNlbCBpdCkuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpZiAoKHB0ID0gcHJvcExvb2t1cFtwXSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHB0LnBnICYmIHB0LnQuX2tpbGwoa2lsbFByb3BzKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlOyAvL3NvbWUgcGx1Z2lucyBuZWVkIHRvIGJlIG5vdGlmaWVkIHNvIHRoZXkgY2FuIHBlcmZvcm0gY2xlYW51cCB0YXNrcyBmaXJzdFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICghcHQucGcgfHwgcHQudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgcHJvcExvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyZWNvcmQpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wc1twXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdGhpcy5fZmlyc3RQVCAmJiB0aGlzLl9pbml0dGVkKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gbnVsbDtcblx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0aGlzLl9hY3RpdmUgPSB0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gKHRoaXMuX3RhcmdldHMpID8ge30gOiBbXTtcblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5hYmxlZCAmJiB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnZXRzW2ldLCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGhpcy50YXJnZXQsIHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIGlmICh0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdHJldHVybiBUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoKGVuYWJsZWQgPyBcIl9vbkVuYWJsZVwiIDogXCJfb25EaXNhYmxlXCIpLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cbi8vLS0tLVR3ZWVuTGl0ZSBzdGF0aWMgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0VHdlZW5MaXRlLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIG9uQ29tcGxldGVTY29wZTpzY29wZSwgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgb25SZXZlcnNlQ29tcGxldGVTY29wZTpzY29wZSwgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCBsYXp5OmZhbHNlLCB1c2VGcmFtZXM6dXNlRnJhbWVzLCBvdmVyd3JpdGU6MH0pO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIDAsIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUpIHtcblx0XHRcdGlmICh0YXJnZXQgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyB0YXJnZXQgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgaSwgYSwgaiwgdDtcblx0XHRcdGlmICgoX2lzQXJyYXkodGFyZ2V0KSB8fCBfaXNTZWxlY3Rvcih0YXJnZXQpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRpID0gdGFyZ2V0Lmxlbmd0aDtcblx0XHRcdFx0YSA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRhID0gYS5jb25jYXQoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldFtpXSwgb25seUFjdGl2ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Ly9ub3cgZ2V0IHJpZCBvZiBhbnkgZHVwbGljYXRlcyAodHdlZW5zIG9mIGFycmF5cyBvZiBvYmplY3RzIGNvdWxkIGNhdXNlIGR1cGxpY2F0ZXMpXG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHQgPSBhW2ldO1xuXHRcdFx0XHRcdGogPSBpO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHQgPT09IGFbal0pIHtcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhID0gX3JlZ2lzdGVyKHRhcmdldCkuY29uY2F0KCk7XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGFbaV0uX2djIHx8IChvbmx5QWN0aXZlICYmICFhW2ldLmlzQWN0aXZlKCkpKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUua2lsbFR3ZWVuc09mID0gVHdlZW5MaXRlLmtpbGxEZWxheWVkQ2FsbHNUbyA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSwgdmFycykge1xuXHRcdFx0aWYgKHR5cGVvZihvbmx5QWN0aXZlKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YXJzID0gb25seUFjdGl2ZTsgLy9mb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKGJlZm9yZSBcIm9ubHlBY3RpdmVcIiBwYXJhbWV0ZXIgd2FzIGluc2VydGVkKVxuXHRcdFx0XHRvbmx5QWN0aXZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIG9ubHlBY3RpdmUpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0YVtpXS5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHdlZW5QbHVnaW4gICAoY291bGQgZWFzaWx5IGJlIHNwbGl0IG91dCBhcyBhIHNlcGFyYXRlIGZpbGUvY2xhc3MsIGJ1dCBpbmNsdWRlZCBmb3IgZWFzZSBvZiB1c2UgKHNvIHRoYXQgcGVvcGxlIGRvbid0IG5lZWQgdG8gaW5jbHVkZSBhbm90aGVyIHNjcmlwdCBjYWxsIGJlZm9yZSBsb2FkaW5nIHBsdWdpbnMgd2hpY2ggaXMgZWFzeSB0byBmb3JnZXQpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgVHdlZW5QbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsIGZ1bmN0aW9uKHByb3BzLCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzID0gKHByb3BzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wTmFtZSA9IHRoaXMuX292ZXJ3cml0ZVByb3BzWzBdO1xuXHRcdFx0XHRcdHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cblx0XHRwID0gVHdlZW5QbHVnaW4ucHJvdG90eXBlO1xuXHRcdFR3ZWVuUGx1Z2luLnZlcnNpb24gPSBcIjEuMTAuMVwiO1xuXHRcdFR3ZWVuUGx1Z2luLkFQSSA9IDI7XG5cdFx0cC5fZmlyc3RQVCA9IG51bGw7XG5cblx0XHRwLl9hZGRUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgb3ZlcndyaXRlUHJvcCwgcm91bmQpIHtcblx0XHRcdHZhciBjLCBwdDtcblx0XHRcdGlmIChlbmQgIT0gbnVsbCAmJiAoYyA9ICh0eXBlb2YoZW5kKSA9PT0gXCJudW1iZXJcIiB8fCBlbmQuY2hhckF0KDEpICE9PSBcIj1cIikgPyBOdW1iZXIoZW5kKSAtIHN0YXJ0IDogcGFyc2VJbnQoZW5kLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIoZW5kLnN1YnN0cigyKSkpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHtfbmV4dDp0aGlzLl9maXJzdFBULCB0OnRhcmdldCwgcDpwcm9wLCBzOnN0YXJ0LCBjOmMsIGY6KHR5cGVvZih0YXJnZXRbcHJvcF0pID09PSBcImZ1bmN0aW9uXCIpLCBuOm92ZXJ3cml0ZVByb3AgfHwgcHJvcCwgcjpyb3VuZH07XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnNldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHZhbDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHR2YWwgPSBwdC5jICogdiArIHB0LnM7XG5cdFx0XHRcdGlmIChwdC5yKSB7XG5cdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4pIHsgLy9wcmV2ZW50cyBpc3N1ZXMgd2l0aCBjb252ZXJ0aW5nIHZlcnkgc21hbGwgbnVtYmVycyB0byBzdHJpbmdzIGluIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0odmFsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0aTtcblx0XHRcdGlmIChsb29rdXBbdGhpcy5fcHJvcE5hbWVdICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxvb2t1cFthW2ldXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAobG9va3VwW3B0Lm5dICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuX3JvdW5kUHJvcHMgPSBmdW5jdGlvbihsb29rdXAsIHZhbHVlKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbdGhpcy5fcHJvcE5hbWVdIHx8IChwdC5uICE9IG51bGwgJiYgbG9va3VwWyBwdC5uLnNwbGl0KHRoaXMuX3Byb3BOYW1lICsgXCJfXCIpLmpvaW4oXCJcIikgXSkpIHsgLy9zb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgdmVyeSBwbHVnaW4tc3BlY2lmaWMgYWRkIGEgcHJlZml4IG5hbWVkIGFmdGVyIHRoZSBfcHJvcE5hbWUgcGx1cyBhbiB1bmRlcnNjb3JlLCBzbyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGF0IGV4dHJhIHN0dWZmIGhlcmUuXG5cdFx0XHRcdFx0cHQuciA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHR3ZWVuKSB7XG5cdFx0XHR2YXIgcHQgPSB0d2Vlbi5fZmlyc3RQVCxcblx0XHRcdFx0Y2hhbmdlZCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dDtcblx0XHRcdGlmICh0eXBlID09PSBcIl9vbkluaXRBbGxQcm9wc1wiKSB7XG5cdFx0XHRcdC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIHJlbmRlciBlYXJsaWVyL2xhdGVyIHRoYW4gb3RoZXJzLCBsaWtlIE1vdGlvbkJsdXJQbHVnaW4gYXBwbGllcyBpdHMgZWZmZWN0cyBhZnRlciBhbGwgeC95L2FscGhhIHR3ZWVucyBoYXZlIHJlbmRlcmVkIG9uIGVhY2ggZnJhbWUuXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LnBnKSBpZiAodHlwZW9mKHB0LnRbdHlwZV0pID09PSBcImZ1bmN0aW9uXCIpIGlmIChwdC50W3R5cGVdKCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlID0gZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIGkgPSBwbHVnaW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGx1Z2luc1tpXS5BUEkgPT09IFR3ZWVuUGx1Z2luLkFQSSkge1xuXHRcdFx0XHRcdF9wbHVnaW5zWyhuZXcgcGx1Z2luc1tpXSgpKS5fcHJvcE5hbWVdID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8vcHJvdmlkZXMgYSBtb3JlIGNvbmNpc2Ugd2F5IHRvIGRlZmluZSBwbHVnaW5zIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYmVzaWRlcyBUd2VlblBsdWdpbiBhbmQgVHdlZW5MaXRlLCB3cmFwcGluZyBjb21tb24gYm9pbGVycGxhdGUgc3R1ZmYgaW50byBvbmUgZnVuY3Rpb24gKGFkZGVkIGluIDEuOS4wKS4gWW91IGRvbid0IE5FRUQgdG8gdXNlIHRoaXMgdG8gZGVmaW5lIGEgcGx1Z2luIC0gdGhlIG9sZCB3YXkgc3RpbGwgd29ya3MgYW5kIGNhbiBiZSB1c2VmdWwgaW4gY2VydGFpbiAocmFyZSkgc2l0dWF0aW9ucy5cblx0XHRfZ3NEZWZpbmUucGx1Z2luID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHRpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnByb3BOYW1lIHx8ICFjb25maWcuaW5pdCB8fCAhY29uZmlnLkFQSSkgeyB0aHJvdyBcImlsbGVnYWwgcGx1Z2luIGRlZmluaXRpb24uXCI7IH1cblx0XHRcdHZhciBwcm9wTmFtZSA9IGNvbmZpZy5wcm9wTmFtZSxcblx0XHRcdFx0cHJpb3JpdHkgPSBjb25maWcucHJpb3JpdHkgfHwgMCxcblx0XHRcdFx0b3ZlcndyaXRlUHJvcHMgPSBjb25maWcub3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdG1hcCA9IHtpbml0OlwiX29uSW5pdFR3ZWVuXCIsIHNldDpcInNldFJhdGlvXCIsIGtpbGw6XCJfa2lsbFwiLCByb3VuZDpcIl9yb3VuZFByb3BzXCIsIGluaXRBbGw6XCJfb25Jbml0QWxsUHJvcHNcIn0sXG5cdFx0XHRcdFBsdWdpbiA9IF9jbGFzcyhcInBsdWdpbnMuXCIgKyBwcm9wTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BOYW1lLnN1YnN0cigxKSArIFwiUGx1Z2luXCIsXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIHByb3BOYW1lLCBwcmlvcml0eSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0ZVByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdH0sIChjb25maWcuZ2xvYmFsID09PSB0cnVlKSksXG5cdFx0XHRcdHAgPSBQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKHByb3BOYW1lKSxcblx0XHRcdFx0cHJvcDtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBQbHVnaW47XG5cdFx0XHRQbHVnaW4uQVBJID0gY29uZmlnLkFQSTtcblx0XHRcdGZvciAocHJvcCBpbiBtYXApIHtcblx0XHRcdFx0aWYgKHR5cGVvZihjb25maWdbcHJvcF0pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRwW21hcFtwcm9wXV0gPSBjb25maWdbcHJvcF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFBsdWdpbi52ZXJzaW9uID0gY29uZmlnLnZlcnNpb247XG5cdFx0XHRUd2VlblBsdWdpbi5hY3RpdmF0ZShbUGx1Z2luXSk7XG5cdFx0XHRyZXR1cm4gUGx1Z2luO1xuXHRcdH07XG5cblxuXHRcdC8vbm93IHJ1biB0aHJvdWdoIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGRpc2NvdmVyZWQgYW5kIGlmIGFueSBhcmUgbWlzc2luZywgbG9nIHRoYXQgdG8gdGhlIGNvbnNvbGUgYXMgYSB3YXJuaW5nLiBUaGlzIGlzIHdoeSBpdCdzIGJlc3QgdG8gaGF2ZSBUd2VlbkxpdGUgbG9hZCBsYXN0IC0gaXQgY2FuIGNoZWNrIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGZvciB5b3UuXG5cdFx0YSA9IHdpbmRvdy5fZ3NRdWV1ZTtcblx0XHRpZiAoYSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YVtpXSgpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChwIGluIF9kZWZMb29rdXApIHtcblx0XHRcdFx0aWYgKCFfZGVmTG9va3VwW3BdLmZ1bmMpIHtcblx0XHRcdFx0XHR3aW5kb3cuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogY29tLmdyZWVuc29jay5cIiArIHApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlOyAvL2Vuc3VyZXMgdGhhdCB0aGUgZmlyc3Qgb2ZmaWNpYWwgYW5pbWF0aW9uIGZvcmNlcyBhIHRpY2tlci50aWNrKCkgdG8gdXBkYXRlIHRoZSB0aW1lIHdoZW4gaXQgaXMgaW5zdGFudGlhdGVkXG5cbn0pKCh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyAmJiB0eXBlb2YoZ2xvYmFsKSAhPT0gXCJ1bmRlZmluZWRcIikgPyBnbG9iYWwgOiB0aGlzIHx8IHdpbmRvdywgXCJUd2VlbkxpdGVcIik7IiwiLyohIEJhYnlsb24gMjAxNC0wOC0wOCAqL1xudmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGEmJihhPTApLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiJiYoYj0wKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9MCksdGhpcy5yPWEsdGhpcy5nPWIsdGhpcy5iPWN9cmV0dXJuIGEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJ7UjogXCIrdGhpcy5yK1wiIEc6XCIrdGhpcy5nK1wiIEI6XCIrdGhpcy5iK1wifVwifSxhLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9MCksYVtiXT10aGlzLnIsYVtiKzFdPXRoaXMuZyxhW2IrMl09dGhpcy5ifSxhLnByb3RvdHlwZS5hc0FycmF5PWZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIHRoaXMudG9BcnJheShhLDApLGF9LGEucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLnIqYi5yLHRoaXMuZypiLmcsdGhpcy5iKmIuYil9LGEucHJvdG90eXBlLm11bHRpcGx5VG9SZWY9ZnVuY3Rpb24oYSxiKXtiLnI9dGhpcy5yKmEucixiLmc9dGhpcy5nKmEuZyxiLmI9dGhpcy5iKmEuYn0sYS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBhJiZ0aGlzLnI9PT1hLnImJnRoaXMuZz09PWEuZyYmdGhpcy5iPT09YS5ifSxhLnByb3RvdHlwZS5zY2FsZT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy5yKmIsdGhpcy5nKmIsdGhpcy5iKmIpfSxhLnByb3RvdHlwZS5zY2FsZVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5yPXRoaXMuciphLGIuZz10aGlzLmcqYSxiLmI9dGhpcy5iKmF9LGEucHJvdG90eXBlLmFkZD1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy5yK2Iucix0aGlzLmcrYi5nLHRoaXMuYitiLmIpfSxhLnByb3RvdHlwZS5hZGRUb1JlZj1mdW5jdGlvbihhLGIpe2Iucj10aGlzLnIrYS5yLGIuZz10aGlzLmcrYS5nLGIuYj10aGlzLmIrYS5ifSxhLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy5yLWIucix0aGlzLmctYi5nLHRoaXMuYi1iLmIpfSxhLnByb3RvdHlwZS5zdWJ0cmFjdFRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5yPXRoaXMuci1hLnIsYi5nPXRoaXMuZy1hLmcsYi5iPXRoaXMuYi1hLmJ9LGEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKHRoaXMucix0aGlzLmcsdGhpcy5iKX0sYS5wcm90b3R5cGUuY29weUZyb209ZnVuY3Rpb24oYSl7dGhpcy5yPWEucix0aGlzLmc9YS5nLHRoaXMuYj1hLmJ9LGEucHJvdG90eXBlLmNvcHlGcm9tRmxvYXRzPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnI9YSx0aGlzLmc9Yix0aGlzLmI9Y30sYS5Gcm9tQXJyYXk9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKGJbMF0sYlsxXSxiWzJdKX0sYS5Gcm9tSW50cz1mdW5jdGlvbihiLGMsZCl7cmV0dXJuIG5ldyBhKGIvMjU1LGMvMjU1LGQvMjU1KX0sYS5MZXJwPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1iLnIrKGMuci1iLnIpKmQsZj1iLmcrKGMuZy1iLmcpKmQsZz1iLmIrKGMuYi1iLmIpKmQ7cmV0dXJuIG5ldyBhKGUsZixnKX0sYS5SZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMSwwLDApfSxhLkdyZWVuPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDAsMSwwKX0sYS5CbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDAsMCwxKX0sYS5CbGFjaz1mdW5jdGlvbigpe3JldHVybiBuZXcgYSgwLDAsMCl9LGEuV2hpdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMSwxLDEpfSxhLlB1cnBsZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYSguNSwwLC41KX0sYS5NYWdlbnRhPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBhKDEsMCwxKX0sYS5ZZWxsb3c9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoMSwxLDApfSxhLkdyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoLjUsLjUsLjUpfSxhfSgpO2EuQ29sb3IzPWI7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQpe3RoaXMucj1hLHRoaXMuZz1iLHRoaXMuYj1jLHRoaXMuYT1kfXJldHVybiBiLnByb3RvdHlwZS5hZGRJblBsYWNlPWZ1bmN0aW9uKGEpe3RoaXMucis9YS5yLHRoaXMuZys9YS5nLHRoaXMuYis9YS5iLHRoaXMuYSs9YS5hfSxiLnByb3RvdHlwZS5hc0FycmF5PWZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIHRoaXMudG9BcnJheShhLDApLGF9LGIucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj0wKSxhW2JdPXRoaXMucixhW2IrMV09dGhpcy5nLGFbYisyXT10aGlzLmIsYVtiKzNdPXRoaXMuYX0sYi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLnIrYS5yLHRoaXMuZythLmcsdGhpcy5iK2EuYix0aGlzLmErYS5hKX0sYi5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMuci1hLnIsdGhpcy5nLWEuZyx0aGlzLmItYS5iLHRoaXMuYS1hLmEpfSxiLnByb3RvdHlwZS5zdWJ0cmFjdFRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5yPXRoaXMuci1hLnIsYi5nPXRoaXMuZy1hLmcsYi5iPXRoaXMuYi1hLmIsYi5hPXRoaXMuYS1hLmF9LGIucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYih0aGlzLnIqYSx0aGlzLmcqYSx0aGlzLmIqYSx0aGlzLmEqYSl9LGIucHJvdG90eXBlLnNjYWxlVG9SZWY9ZnVuY3Rpb24oYSxiKXtiLnI9dGhpcy5yKmEsYi5nPXRoaXMuZyphLGIuYj10aGlzLmIqYSxiLmE9dGhpcy5hKmF9LGIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJ7UjogXCIrdGhpcy5yK1wiIEc6XCIrdGhpcy5nK1wiIEI6XCIrdGhpcy5iK1wiIEE6XCIrdGhpcy5hK1wifVwifSxiLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYih0aGlzLnIsdGhpcy5nLHRoaXMuYix0aGlzLmEpfSxiLkxlcnA9ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPW5ldyBiKDAsMCwwLDApO3JldHVybiBhLkNvbG9yNC5MZXJwVG9SZWYoYyxkLGUsZiksZn0sYi5MZXJwVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCl7ZC5yPWEucisoYi5yLWEucikqYyxkLmc9YS5nKyhiLmctYS5nKSpjLGQuYj1hLmIrKGIuYi1hLmIpKmMsZC5hPWEuYSsoYi5hLWEuYSkqY30sYi5Gcm9tQXJyYXk9ZnVuY3Rpb24oYSxjKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9MCksbmV3IGIoYVtjXSxhW2MrMV0sYVtjKzJdLGFbYyszXSl9LGIuRnJvbUludHM9ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIG5ldyBiKGEvMjU1LGMvMjU1LGQvMjU1LGUvMjU1KX0sYn0oKTthLkNvbG9yND1jO3ZhciBkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3RoaXMueD1hLHRoaXMueT1ifXJldHVybiBhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwie1g6IFwiK3RoaXMueCtcIiBZOlwiK3RoaXMueStcIn1cIn0sYS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTApLGFbYl09dGhpcy54LGFbYisxXT10aGlzLnl9LGEucHJvdG90eXBlLmFzQXJyYXk9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy50b0FycmF5KGEsMCksYX0sYS5wcm90b3R5cGUuY29weUZyb209ZnVuY3Rpb24oYSl7dGhpcy54PWEueCx0aGlzLnk9YS55fSxhLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMueCtiLngsdGhpcy55K2IueSl9LGEucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLngtYi54LHRoaXMueS1iLnkpfSxhLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoLXRoaXMueCwtdGhpcy55KX0sYS5wcm90b3R5cGUuc2NhbGVJblBsYWNlPWZ1bmN0aW9uKGEpe3RoaXMueCo9YSx0aGlzLnkqPWF9LGEucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLngqYix0aGlzLnkqYil9LGEucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmdGhpcy54PT09YS54JiZ0aGlzLnk9PT1hLnl9LGEucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55KX0sYS5wcm90b3R5cGUubGVuZ3RoU3F1YXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnl9LGEucHJvdG90eXBlLm5vcm1hbGl6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMubGVuZ3RoKCk7aWYoMCE9PWEpe3ZhciBiPTEvYTt0aGlzLngqPWIsdGhpcy55Kj1ifX0sYS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEodGhpcy54LHRoaXMueSl9LGEuWmVybz1mdW5jdGlvbigpe3JldHVybiBuZXcgYSgwLDApfSxhLkZyb21BcnJheT1mdW5jdGlvbihiLGMpe3JldHVybiBjfHwoYz0wKSxuZXcgYShiW2NdLGJbYysxXSl9LGEuQ2F0bXVsbFJvbT1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPWYqZixoPWYqZyxpPS41KigyKmMueCsoLWIueCtkLngpKmYrKDIqYi54LTUqYy54KzQqZC54LWUueCkqZysoLWIueCszKmMueC0zKmQueCtlLngpKmgpLGo9LjUqKDIqYy55KygtYi55K2QueSkqZisoMipiLnktNSpjLnkrNCpkLnktZS55KSpnKygtYi55KzMqYy55LTMqZC55K2UueSkqaCk7cmV0dXJuIG5ldyBhKGksail9LGEuQ2xhbXA9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWIueDtlPWU+ZC54P2QueDplLGU9ZTxjLng/Yy54OmU7dmFyIGY9Yi55O3JldHVybiBmPWY+ZC55P2QueTpmLGY9ZjxjLnk/Yy55OmYsbmV3IGEoZSxmKX0sYS5IZXJtaXRlPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGc9ZipmLGg9ZipnLGk9MipoLTMqZysxLGo9LTIqaCszKmcsaz1oLTIqZytmLGw9aC1nLG09Yi54KmkrZC54KmorYy54KmsrZS54Kmwsbj1iLnkqaStkLnkqaitjLnkqaytlLnkqbDtyZXR1cm4gbmV3IGEobSxuKX0sYS5MZXJwPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1iLngrKGMueC1iLngpKmQsZj1iLnkrKGMueS1iLnkpKmQ7cmV0dXJuIG5ldyBhKGUsZil9LGEuRG90PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEueCpiLngrYS55KmIueX0sYS5Ob3JtYWxpemU9ZnVuY3Rpb24oYSl7dmFyIGI9YS5jbG9uZSgpO3JldHVybiBiLm5vcm1hbGl6ZSgpLGJ9LGEuTWluaW1pemU9ZnVuY3Rpb24oYixjKXt2YXIgZD1iLng8Yy54P2IueDpjLngsZT1iLnk8Yy55P2IueTpjLnk7cmV0dXJuIG5ldyBhKGQsZSl9LGEuTWF4aW1pemU9ZnVuY3Rpb24oYixjKXt2YXIgZD1iLng+Yy54P2IueDpjLngsZT1iLnk+Yy55P2IueTpjLnk7cmV0dXJuIG5ldyBhKGQsZSl9LGEuVHJhbnNmb3JtPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi54KmMubVswXStiLnkqYy5tWzRdLGU9Yi54KmMubVsxXStiLnkqYy5tWzVdO3JldHVybiBuZXcgYShkLGUpfSxhLkRpc3RhbmNlPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIE1hdGguc3FydChhLkRpc3RhbmNlU3F1YXJlZChiLGMpKX0sYS5EaXN0YW5jZVNxdWFyZWQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLngtYi54LGQ9YS55LWIueTtyZXR1cm4gYypjK2QqZH0sYX0oKTthLlZlY3RvcjI9ZDt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMpe3RoaXMueD1hLHRoaXMueT1iLHRoaXMuej1jfXJldHVybiBiLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwie1g6IFwiK3RoaXMueCtcIiBZOlwiK3RoaXMueStcIiBaOlwiK3RoaXMueitcIn1cIn0sYi5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLnRvQXJyYXkoYSwwKSxhfSxiLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9MCksYVtiXT10aGlzLngsYVtiKzFdPXRoaXMueSxhW2IrMl09dGhpcy56fSxiLnByb3RvdHlwZS5hZGRJblBsYWNlPWZ1bmN0aW9uKGEpe3RoaXMueCs9YS54LHRoaXMueSs9YS55LHRoaXMueis9YS56fSxiLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMueCthLngsdGhpcy55K2EueSx0aGlzLnorYS56KX0sYi5wcm90b3R5cGUuYWRkVG9SZWY9ZnVuY3Rpb24oYSxiKXtiLng9dGhpcy54K2EueCxiLnk9dGhpcy55K2EueSxiLno9dGhpcy56K2Euen0sYi5wcm90b3R5cGUuc3VidHJhY3RJblBsYWNlPWZ1bmN0aW9uKGEpe3RoaXMueC09YS54LHRoaXMueS09YS55LHRoaXMuei09YS56fSxiLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIodGhpcy54LWEueCx0aGlzLnktYS55LHRoaXMuei1hLnopfSxiLnByb3RvdHlwZS5zdWJ0cmFjdFRvUmVmPWZ1bmN0aW9uKGEsYil7Yi54PXRoaXMueC1hLngsYi55PXRoaXMueS1hLnksYi56PXRoaXMuei1hLnp9LGIucHJvdG90eXBlLnN1YnRyYWN0RnJvbUZsb2F0cz1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIG5ldyBiKHRoaXMueC1hLHRoaXMueS1jLHRoaXMuei1kKX0sYi5wcm90b3R5cGUuc3VidHJhY3RGcm9tRmxvYXRzVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCl7ZC54PXRoaXMueC1hLGQueT10aGlzLnktYixkLno9dGhpcy56LWN9LGIucHJvdG90eXBlLm5lZ2F0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYigtdGhpcy54LC10aGlzLnksLXRoaXMueil9LGIucHJvdG90eXBlLnNjYWxlSW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLngqPWEsdGhpcy55Kj1hLHRoaXMueio9YX0sYi5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMueCphLHRoaXMueSphLHRoaXMueiphKX0sYi5wcm90b3R5cGUuc2NhbGVUb1JlZj1mdW5jdGlvbihhLGIpe2IueD10aGlzLngqYSxiLnk9dGhpcy55KmEsYi56PXRoaXMueiphfSxiLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnRoaXMueD09PWEueCYmdGhpcy55PT09YS55JiZ0aGlzLno9PT1hLnp9LGIucHJvdG90eXBlLmVxdWFsc1dpdGhFcHNpbG9uPWZ1bmN0aW9uKGIpe3JldHVybiBNYXRoLmFicyh0aGlzLngtYi54KTxhLkVuZ2luZS5FcHNpbG9uJiZNYXRoLmFicyh0aGlzLnktYi55KTxhLkVuZ2luZS5FcHNpbG9uJiZNYXRoLmFicyh0aGlzLnotYi56KTxhLkVuZ2luZS5FcHNpbG9ufSxiLnByb3RvdHlwZS5lcXVhbHNUb0Zsb2F0cz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMueD09PWEmJnRoaXMueT09PWImJnRoaXMuej09PWN9LGIucHJvdG90eXBlLm11bHRpcGx5SW5QbGFjZT1mdW5jdGlvbihhKXt0aGlzLngqPWEueCx0aGlzLnkqPWEueSx0aGlzLnoqPWEuen0sYi5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMueCphLngsdGhpcy55KmEueSx0aGlzLnoqYS56KX0sYi5wcm90b3R5cGUubXVsdGlwbHlUb1JlZj1mdW5jdGlvbihhLGIpe2IueD10aGlzLngqYS54LGIueT10aGlzLnkqYS55LGIuej10aGlzLnoqYS56fSxiLnByb3RvdHlwZS5tdWx0aXBseUJ5RmxvYXRzPWZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gbmV3IGIodGhpcy54KmEsdGhpcy55KmMsdGhpcy56KmQpfSxiLnByb3RvdHlwZS5kaXZpZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiKHRoaXMueC9hLngsdGhpcy55L2EueSx0aGlzLnovYS56KX0sYi5wcm90b3R5cGUuZGl2aWRlVG9SZWY9ZnVuY3Rpb24oYSxiKXtiLng9dGhpcy54L2EueCxiLnk9dGhpcy55L2EueSxiLno9dGhpcy56L2Euen0sYi5wcm90b3R5cGUuTWluaW1pemVJblBsYWNlPWZ1bmN0aW9uKGEpe2EueDx0aGlzLngmJih0aGlzLng9YS54KSxhLnk8dGhpcy55JiYodGhpcy55PWEueSksYS56PHRoaXMueiYmKHRoaXMuej1hLnopfSxiLnByb3RvdHlwZS5NYXhpbWl6ZUluUGxhY2U9ZnVuY3Rpb24oYSl7YS54PnRoaXMueCYmKHRoaXMueD1hLngpLGEueT50aGlzLnkmJih0aGlzLnk9YS55KSxhLno+dGhpcy56JiYodGhpcy56PWEueil9LGIucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfSxiLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56fSxiLnByb3RvdHlwZS5ub3JtYWxpemU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxlbmd0aCgpO2lmKDAhPT1hKXt2YXIgYj0xL2E7dGhpcy54Kj1iLHRoaXMueSo9Yix0aGlzLnoqPWJ9fSxiLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYih0aGlzLngsdGhpcy55LHRoaXMueil9LGIucHJvdG90eXBlLmNvcHlGcm9tPWZ1bmN0aW9uKGEpe3RoaXMueD1hLngsdGhpcy55PWEueSx0aGlzLno9YS56fSxiLnByb3RvdHlwZS5jb3B5RnJvbUZsb2F0cz1mdW5jdGlvbihhLGIsYyl7dGhpcy54PWEsdGhpcy55PWIsdGhpcy56PWN9LGIuRnJvbUFycmF5PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGN8fChjPTApLG5ldyBiKGFbY10sYVtjKzFdLGFbYysyXSl9LGIuRnJvbUFycmF5VG9SZWY9ZnVuY3Rpb24oYSxiLGMpe2MueD1hW2JdLGMueT1hW2IrMV0sYy56PWFbYisyXX0sYi5Gcm9tRmxvYXRBcnJheVRvUmVmPWZ1bmN0aW9uKGEsYixjKXtjLng9YVtiXSxjLnk9YVtiKzFdLGMuej1hW2IrMl19LGIuRnJvbUZsb2F0c1RvUmVmPWZ1bmN0aW9uKGEsYixjLGQpe2QueD1hLGQueT1iLGQuej1jfSxiLlplcm89ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGIoMCwwLDApfSxiLlVwPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiKDAsMSwwKX0sYi5UcmFuc2Zvcm1Db29yZGluYXRlcz1mdW5jdGlvbihhLGMpe3ZhciBkPWIuWmVybygpO3JldHVybiBiLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYoYSxjLGQpLGR9LGIuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS54KmIubVswXSthLnkqYi5tWzRdK2EueipiLm1bOF0rYi5tWzEyXSxlPWEueCpiLm1bMV0rYS55KmIubVs1XSthLnoqYi5tWzldK2IubVsxM10sZj1hLngqYi5tWzJdK2EueSpiLm1bNl0rYS56KmIubVsxMF0rYi5tWzE0XSxnPWEueCpiLm1bM10rYS55KmIubVs3XSthLnoqYi5tWzExXStiLm1bMTVdO2MueD1kL2csYy55PWUvZyxjLno9Zi9nfSxiLlRyYW5zZm9ybUNvb3JkaW5hdGVzRnJvbUZsb2F0c1RvUmVmPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YSpkLm1bMF0rYipkLm1bNF0rYypkLm1bOF0rZC5tWzEyXSxnPWEqZC5tWzFdK2IqZC5tWzVdK2MqZC5tWzldK2QubVsxM10saD1hKmQubVsyXStiKmQubVs2XStjKmQubVsxMF0rZC5tWzE0XSxpPWEqZC5tWzNdK2IqZC5tWzddK2MqZC5tWzExXStkLm1bMTVdO2UueD1mL2ksZS55PWcvaSxlLno9aC9pfSxiLlRyYW5zZm9ybU5vcm1hbD1mdW5jdGlvbihhLGMpe3ZhciBkPWIuWmVybygpO3JldHVybiBiLlRyYW5zZm9ybU5vcm1hbFRvUmVmKGEsYyxkKSxkfSxiLlRyYW5zZm9ybU5vcm1hbFRvUmVmPWZ1bmN0aW9uKGEsYixjKXtjLng9YS54KmIubVswXSthLnkqYi5tWzRdK2EueipiLm1bOF0sYy55PWEueCpiLm1bMV0rYS55KmIubVs1XSthLnoqYi5tWzldLGMuej1hLngqYi5tWzJdK2EueSpiLm1bNl0rYS56KmIubVsxMF19LGIuVHJhbnNmb3JtTm9ybWFsRnJvbUZsb2F0c1RvUmVmPWZ1bmN0aW9uKGEsYixjLGQsZSl7ZS54PWEqZC5tWzBdK2IqZC5tWzRdK2MqZC5tWzhdLGUueT1hKmQubVsxXStiKmQubVs1XStjKmQubVs5XSxlLno9YSpkLm1bMl0rYipkLm1bNl0rYypkLm1bMTBdfSxiLkNhdG11bGxSb209ZnVuY3Rpb24oYSxjLGQsZSxmKXt2YXIgZz1mKmYsaD1mKmcsaT0uNSooMipjLngrKC1hLngrZC54KSpmKygyKmEueC01KmMueCs0KmQueC1lLngpKmcrKC1hLngrMypjLngtMypkLngrZS54KSpoKSxqPS41KigyKmMueSsoLWEueStkLnkpKmYrKDIqYS55LTUqYy55KzQqZC55LWUueSkqZysoLWEueSszKmMueS0zKmQueStlLnkpKmgpLGs9LjUqKDIqYy56KygtYS56K2QueikqZisoMiphLnotNSpjLnorNCpkLnotZS56KSpnKygtYS56KzMqYy56LTMqZC56K2UueikqaCk7cmV0dXJuIG5ldyBiKGksaixrKX0sYi5DbGFtcD1mdW5jdGlvbihhLGMsZCl7dmFyIGU9YS54O2U9ZT5kLng/ZC54OmUsZT1lPGMueD9jLng6ZTt2YXIgZj1hLnk7Zj1mPmQueT9kLnk6ZixmPWY8Yy55P2MueTpmO3ZhciBnPWEuejtyZXR1cm4gZz1nPmQuej9kLno6ZyxnPWc8Yy56P2MuejpnLG5ldyBiKGUsZixnKX0sYi5IZXJtaXRlPWZ1bmN0aW9uKGEsYyxkLGUsZil7dmFyIGc9ZipmLGg9ZipnLGk9MipoLTMqZysxLGo9LTIqaCszKmcsaz1oLTIqZytmLGw9aC1nLG09YS54KmkrZC54KmorYy54KmsrZS54Kmwsbj1hLnkqaStkLnkqaitjLnkqaytlLnkqbCxvPWEueippK2QueipqK2MueiprK2UueipsO3JldHVybiBuZXcgYihtLG4sbyl9LGIuTGVycD1mdW5jdGlvbihhLGMsZCl7dmFyIGU9YS54KyhjLngtYS54KSpkLGY9YS55KyhjLnktYS55KSpkLGc9YS56KyhjLnotYS56KSpkO3JldHVybiBuZXcgYihlLGYsZyl9LGIuRG90PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEueCpiLngrYS55KmIueSthLnoqYi56fSxiLkNyb3NzPWZ1bmN0aW9uKGEsYyl7dmFyIGQ9Yi5aZXJvKCk7cmV0dXJuIGIuQ3Jvc3NUb1JlZihhLGMsZCksZH0sYi5Dcm9zc1RvUmVmPWZ1bmN0aW9uKGEsYixjKXtjLng9YS55KmIuei1hLnoqYi55LGMueT1hLnoqYi54LWEueCpiLnosYy56PWEueCpiLnktYS55KmIueH0sYi5Ob3JtYWxpemU9ZnVuY3Rpb24oYSl7dmFyIGM9Yi5aZXJvKCk7cmV0dXJuIGIuTm9ybWFsaXplVG9SZWYoYSxjKSxjfSxiLk5vcm1hbGl6ZVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi5jb3B5RnJvbShhKSxiLm5vcm1hbGl6ZSgpfSxiLlByb2plY3Q9ZnVuY3Rpb24oYyxkLGUsZil7dmFyIGc9Zi53aWR0aCxoPWYuaGVpZ2h0LGk9Zi54LGo9Zi55LGs9YS5NYXRyaXguRnJvbVZhbHVlcyhnLzIsMCwwLDAsMCwtaC8yLDAsMCwwLDAsMSwwLGkrZy8yLGgvMitqLDAsMSksbD1kLm11bHRpcGx5KGUpLm11bHRpcGx5KGspO3JldHVybiBiLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGMsbCl9LGIuVW5wcm9qZWN0PWZ1bmN0aW9uKGIsYyxkLGUsZixnKXt2YXIgaD1lLm11bHRpcGx5KGYpLm11bHRpcGx5KGcpO2guaW52ZXJ0KCksYi54PWIueC9jKjItMSxiLnk9LShiLnkvZCoyLTEpO3ZhciBpPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhiLGgpLGo9Yi54KmgubVszXStiLnkqaC5tWzddK2IueipoLm1bMTFdK2gubVsxNV07cmV0dXJuIGEuVG9vbHMuV2l0aGluRXBzaWxvbihqLDEpJiYoaT1pLnNjYWxlKDEvaikpLGl9LGIuTWluaW1pemU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNsb25lKCk7cmV0dXJuIGMuTWluaW1pemVJblBsYWNlKGIpLGN9LGIuTWF4aW1pemU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNsb25lKCk7cmV0dXJuIGMuTWF4aW1pemVJblBsYWNlKGIpLGN9LGIuRGlzdGFuY2U9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gTWF0aC5zcXJ0KGIuRGlzdGFuY2VTcXVhcmVkKGEsYykpfSxiLkRpc3RhbmNlU3F1YXJlZD1mdW5jdGlvbihhLGIpe3ZhciBjPWEueC1iLngsZD1hLnktYi55LGU9YS56LWIuejtyZXR1cm4gYypjK2QqZCtlKmV9LGIuQ2VudGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5hZGQoYik7cmV0dXJuIGMuc2NhbGVJblBsYWNlKC41KSxjfSxifSgpO2EuVmVjdG9yMz1lO3ZhciBmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYSYmKGE9MCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGImJihiPTApLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjJiYoYz0wKSxcInVuZGVmaW5lZFwiPT10eXBlb2YgZCYmKGQ9MCksdGhpcy54PWEsdGhpcy55PWIsdGhpcy56PWMsdGhpcy53PWR9cmV0dXJuIGEucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJ7WDogXCIrdGhpcy54K1wiIFk6XCIrdGhpcy55K1wiIFo6XCIrdGhpcy56K1wiIFc6XCIrdGhpcy53K1wifVwifSxhLnByb3RvdHlwZS5hc0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMueCx0aGlzLnksdGhpcy56LHRoaXMud119LGEucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmdGhpcy54PT09YS54JiZ0aGlzLnk9PT1hLnkmJnRoaXMuej09PWEueiYmdGhpcy53PT09YS53fSxhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYSh0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLncpfSxhLnByb3RvdHlwZS5jb3B5RnJvbT1mdW5jdGlvbihhKXt0aGlzLng9YS54LHRoaXMueT1hLnksdGhpcy56PWEueix0aGlzLnc9YS53fSxhLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhKHRoaXMueCtiLngsdGhpcy55K2IueSx0aGlzLnorYi56LHRoaXMudytiLncpfSxhLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEodGhpcy54LWIueCx0aGlzLnktYi55LHRoaXMuei1iLnosdGhpcy53LWIudyl9LGEucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYSh0aGlzLngqYix0aGlzLnkqYix0aGlzLnoqYix0aGlzLncqYil9LGEucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhKDAsMCwwLDEpO3JldHVybiB0aGlzLm11bHRpcGx5VG9SZWYoYixjKSxjfSxhLnByb3RvdHlwZS5tdWx0aXBseVRvUmVmPWZ1bmN0aW9uKGEsYil7Yi54PXRoaXMueCphLncrdGhpcy55KmEuei10aGlzLnoqYS55K3RoaXMudyphLngsYi55PS10aGlzLngqYS56K3RoaXMueSphLncrdGhpcy56KmEueCt0aGlzLncqYS55LGIuej10aGlzLngqYS55LXRoaXMueSphLngrdGhpcy56KmEudyt0aGlzLncqYS56LGIudz0tdGhpcy54KmEueC10aGlzLnkqYS55LXRoaXMueiphLnordGhpcy53KmEud30sYS5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueit0aGlzLncqdGhpcy53KX0sYS5wcm90b3R5cGUubm9ybWFsaXplPWZ1bmN0aW9uKCl7dmFyIGE9MS90aGlzLmxlbmd0aCgpO3RoaXMueCo9YSx0aGlzLnkqPWEsdGhpcy56Kj1hLHRoaXMudyo9YX0sYS5wcm90b3R5cGUudG9FdWxlckFuZ2xlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMueCxiPXRoaXMueSxjPXRoaXMueixkPXRoaXMudyxmPWEqYSxnPWIqYixoPWMqYyxpPU1hdGguYXRhbjIoMiooYipkLWEqYyksMS0yKihnK2gpKSxqPU1hdGguYXNpbigyKihhKmIrYypkKSksaz1NYXRoLmF0YW4yKDIqKGEqZC1iKmMpLDEtMiooZitoKSksbD1hKmIrYypkO3JldHVybiBsPi40OTk/KGk9MipNYXRoLmF0YW4yKGEsZCksaz0wKTotLjQ5OT5sJiYoaT0tMipNYXRoLmF0YW4yKGEsZCksaz0wKSxuZXcgZShqLGksayl9LGEucHJvdG90eXBlLnRvUm90YXRpb25NYXRyaXg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54KnRoaXMueCxjPXRoaXMueSp0aGlzLnksZD10aGlzLnoqdGhpcy56LGU9dGhpcy54KnRoaXMueSxmPXRoaXMueip0aGlzLncsZz10aGlzLnoqdGhpcy54LGg9dGhpcy55KnRoaXMudyxpPXRoaXMueSp0aGlzLnosaj10aGlzLngqdGhpcy53O2EubVswXT0xLTIqKGMrZCksYS5tWzFdPTIqKGUrZiksYS5tWzJdPTIqKGctaCksYS5tWzNdPTAsYS5tWzRdPTIqKGUtZiksYS5tWzVdPTEtMiooZCtiKSxhLm1bNl09MiooaStqKSxhLm1bN109MCxhLm1bOF09MiooZytoKSxhLm1bOV09MiooaS1qKSxhLm1bMTBdPTEtMiooYytiKSxhLm1bMTFdPTAsYS5tWzEyXT0wLGEubVsxM109MCxhLm1bMTRdPTAsYS5tWzE1XT0xfSxhLnByb3RvdHlwZS5mcm9tUm90YXRpb25NYXRyaXg9ZnVuY3Rpb24oYSl7dmFyIGIsYz1hLm0sZD1jWzBdLGU9Y1s0XSxmPWNbOF0sZz1jWzFdLGg9Y1s1XSxpPWNbOV0saj1jWzJdLGs9Y1s2XSxsPWNbMTBdLG09ZCtoK2w7cmV0dXJuIG0+MD8oYj0uNS9NYXRoLnNxcnQobSsxKSx0aGlzLnc9LjI1L2IsdGhpcy54PShrLWkpKmIsdGhpcy55PShmLWopKmIsdm9pZCh0aGlzLno9KGctZSkqYikpOmQ+aCYmZD5sPyhiPTIqTWF0aC5zcXJ0KDErZC1oLWwpLHRoaXMudz0oay1pKS9iLHRoaXMueD0uMjUqYix0aGlzLnk9KGUrZykvYix2b2lkKHRoaXMuej0oZitqKS9iKSk6aD5sPyhiPTIqTWF0aC5zcXJ0KDEraC1kLWwpLHRoaXMudz0oZi1qKS9iLHRoaXMueD0oZStnKS9iLHRoaXMueT0uMjUqYix2b2lkKHRoaXMuej0oaStrKS9iKSk6KGI9MipNYXRoLnNxcnQoMStsLWQtaCksdGhpcy53PShnLWUpL2IsdGhpcy54PShmK2opL2IsdGhpcy55PShpK2spL2Isdm9pZCh0aGlzLno9LjI1KmIpKX0sYS5Sb3RhdGlvbkF4aXM9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYSxlPU1hdGguc2luKGMvMik7cmV0dXJuIGQudz1NYXRoLmNvcyhjLzIpLGQueD1iLngqZSxkLnk9Yi55KmUsZC56PWIueiplLGR9LGEuRnJvbUFycmF5PWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGN8fChjPTApLG5ldyBhKGJbY10sYltjKzFdLGJbYysyXSxiW2MrM10pfSxhLlJvdGF0aW9uWWF3UGl0Y2hSb2xsPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1uZXcgYTtyZXR1cm4gYS5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKGIsYyxkLGUpLGV9LGEuUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0uNSpjLGY9LjUqYixnPS41KmEsaD1NYXRoLnNpbihlKSxpPU1hdGguY29zKGUpLGo9TWF0aC5zaW4oZiksaz1NYXRoLmNvcyhmKSxsPU1hdGguc2luKGcpLG09TWF0aC5jb3MoZyk7ZC54PW0qaippK2wqaypoLGQueT1sKmsqaS1tKmoqaCxkLno9bSprKmgtbCpqKmksZC53PW0qayppK2wqaipofSxhLlNsZXJwPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmLGc9ZCxoPWIueCpjLngrYi55KmMueStiLnoqYy56K2IudypjLncsaT0hMTtpZigwPmgmJihpPSEwLGg9LWgpLGg+Ljk5OTk5OSlmPTEtZyxlPWk/LWc6ZztlbHNle3ZhciBqPU1hdGguYWNvcyhoKSxrPTEvTWF0aC5zaW4oaik7Zj1NYXRoLnNpbigoMS1nKSpqKSprLGU9aT8tTWF0aC5zaW4oZypqKSprOk1hdGguc2luKGcqaikqa31yZXR1cm4gbmV3IGEoZipiLngrZSpjLngsZipiLnkrZSpjLnksZipiLnorZSpjLnosZipiLncrZSpjLncpfSxhfSgpO2EuUXVhdGVybmlvbj1mO3ZhciBnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3RoaXMubT1uZXcgRmxvYXQzMkFycmF5KDE2KX1yZXR1cm4gYS5wcm90b3R5cGUuaXNJZGVudGl0eT1mdW5jdGlvbigpe3JldHVybiAxIT10aGlzLm1bMF18fDEhPXRoaXMubVs1XXx8MSE9dGhpcy5tWzEwXXx8MSE9dGhpcy5tWzE1XT8hMTowIT10aGlzLm1bMV18fDAhPXRoaXMubVsyXXx8MCE9dGhpcy5tWzNdfHwwIT10aGlzLm1bNF18fDAhPXRoaXMubVs2XXx8MCE9dGhpcy5tWzddfHwwIT10aGlzLm1bOF18fDAhPXRoaXMubVs5XXx8MCE9dGhpcy5tWzExXXx8MCE9dGhpcy5tWzEyXXx8MCE9dGhpcy5tWzEzXXx8MCE9dGhpcy5tWzE0XT8hMTohMH0sYS5wcm90b3R5cGUuZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm1bMTBdKnRoaXMubVsxNV0tdGhpcy5tWzExXSp0aGlzLm1bMTRdLGI9dGhpcy5tWzldKnRoaXMubVsxNV0tdGhpcy5tWzExXSp0aGlzLm1bMTNdLGM9dGhpcy5tWzldKnRoaXMubVsxNF0tdGhpcy5tWzEwXSp0aGlzLm1bMTNdLGQ9dGhpcy5tWzhdKnRoaXMubVsxNV0tdGhpcy5tWzExXSp0aGlzLm1bMTJdLGU9dGhpcy5tWzhdKnRoaXMubVsxNF0tdGhpcy5tWzEwXSp0aGlzLm1bMTJdLGY9dGhpcy5tWzhdKnRoaXMubVsxM10tdGhpcy5tWzldKnRoaXMubVsxMl07cmV0dXJuIHRoaXMubVswXSoodGhpcy5tWzVdKmEtdGhpcy5tWzZdKmIrdGhpcy5tWzddKmMpLXRoaXMubVsxXSoodGhpcy5tWzRdKmEtdGhpcy5tWzZdKmQrdGhpcy5tWzddKmUpK3RoaXMubVsyXSoodGhpcy5tWzRdKmItdGhpcy5tWzVdKmQrdGhpcy5tWzddKmYpLXRoaXMubVszXSoodGhpcy5tWzRdKmMtdGhpcy5tWzVdKmUrdGhpcy5tWzZdKmYpfSxhLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubX0sYS5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvQXJyYXkoKX0sYS5wcm90b3R5cGUuaW52ZXJ0PWZ1bmN0aW9uKCl7dGhpcy5pbnZlcnRUb1JlZih0aGlzKX0sYS5wcm90b3R5cGUuaW52ZXJ0VG9SZWY9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5tWzBdLGM9dGhpcy5tWzFdLGQ9dGhpcy5tWzJdLGU9dGhpcy5tWzNdLGY9dGhpcy5tWzRdLGc9dGhpcy5tWzVdLGg9dGhpcy5tWzZdLGk9dGhpcy5tWzddLGo9dGhpcy5tWzhdLGs9dGhpcy5tWzldLGw9dGhpcy5tWzEwXSxtPXRoaXMubVsxMV0sbj10aGlzLm1bMTJdLG89dGhpcy5tWzEzXSxwPXRoaXMubVsxNF0scT10aGlzLm1bMTVdLHI9bCpxLW0qcCxzPWsqcS1tKm8sdD1rKnAtbCpvLHU9aipxLW0qbix2PWoqcC1sKm4sdz1qKm8taypuLHg9ZypyLWgqcytpKnQseT0tKGYqci1oKnUraSp2KSx6PWYqcy1nKnUraSp3LEE9LShmKnQtZyp2K2gqdyksQj0xLyhiKngrYyp5K2QqeitlKkEpLEM9aCpxLWkqcCxEPWcqcS1pKm8sRT1nKnAtaCpvLEY9ZipxLWkqbixHPWYqcC1oKm4sSD1mKm8tZypuLEk9aCptLWkqbCxKPWcqbS1pKmssSz1nKmwtaCprLEw9ZiptLWkqaixNPWYqbC1oKmosTj1mKmstZypqO2EubVswXT14KkIsYS5tWzRdPXkqQixhLm1bOF09eipCLGEubVsxMl09QSpCLGEubVsxXT0tKGMqci1kKnMrZSp0KSpCLGEubVs1XT0oYipyLWQqdStlKnYpKkIsYS5tWzldPS0oYipzLWMqdStlKncpKkIsYS5tWzEzXT0oYip0LWMqditkKncpKkIsYS5tWzJdPShjKkMtZCpEK2UqRSkqQixhLm1bNl09LShiKkMtZCpGK2UqRykqQixhLm1bMTBdPShiKkQtYypGK2UqSCkqQixhLm1bMTRdPS0oYipFLWMqRytkKkgpKkIsYS5tWzNdPS0oYypJLWQqSitlKkspKkIsYS5tWzddPShiKkktZCpMK2UqTSkqQixhLm1bMTFdPS0oYipKLWMqTCtlKk4pKkIsYS5tWzE1XT0oYipLLWMqTStkKk4pKkJ9LGEucHJvdG90eXBlLnNldFRyYW5zbGF0aW9uPWZ1bmN0aW9uKGEpe3RoaXMubVsxMl09YS54LHRoaXMubVsxM109YS55LHRoaXMubVsxNF09YS56fSxhLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYTtyZXR1cm4gdGhpcy5tdWx0aXBseVRvUmVmKGIsYyksY30sYS5wcm90b3R5cGUuY29weUZyb209ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7MTY+YjtiKyspdGhpcy5tW2JdPWEubVtiXX0sYS5wcm90b3R5cGUuY29weVRvQXJyYXk9ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYiYmKGI9MCk7Zm9yKHZhciBjPTA7MTY+YztjKyspYVtiK2NdPXRoaXMubVtjXX0sYS5wcm90b3R5cGUubXVsdGlwbHlUb1JlZj1mdW5jdGlvbihhLGIpe3RoaXMubXVsdGlwbHlUb0FycmF5KGEsYi5tLDApfSxhLnByb3RvdHlwZS5tdWx0aXBseVRvQXJyYXk9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMubVswXSxlPXRoaXMubVsxXSxmPXRoaXMubVsyXSxnPXRoaXMubVszXSxoPXRoaXMubVs0XSxpPXRoaXMubVs1XSxqPXRoaXMubVs2XSxrPXRoaXMubVs3XSxsPXRoaXMubVs4XSxtPXRoaXMubVs5XSxuPXRoaXMubVsxMF0sbz10aGlzLm1bMTFdLHA9dGhpcy5tWzEyXSxxPXRoaXMubVsxM10scj10aGlzLm1bMTRdLHM9dGhpcy5tWzE1XSx0PWEubVswXSx1PWEubVsxXSx2PWEubVsyXSx3PWEubVszXSx4PWEubVs0XSx5PWEubVs1XSx6PWEubVs2XSxBPWEubVs3XSxCPWEubVs4XSxDPWEubVs5XSxEPWEubVsxMF0sRT1hLm1bMTFdLEY9YS5tWzEyXSxHPWEubVsxM10sSD1hLm1bMTRdLEk9YS5tWzE1XTtiW2NdPWQqdCtlKngrZipCK2cqRixiW2MrMV09ZCp1K2UqeStmKkMrZypHLGJbYysyXT1kKnYrZSp6K2YqRCtnKkgsYltjKzNdPWQqdytlKkErZipFK2cqSSxiW2MrNF09aCp0K2kqeCtqKkIraypGLGJbYys1XT1oKnUraSp5K2oqQytrKkcsYltjKzZdPWgqditpKnoraipEK2sqSCxiW2MrN109aCp3K2kqQStqKkUraypJLGJbYys4XT1sKnQrbSp4K24qQitvKkYsYltjKzldPWwqdSttKnkrbipDK28qRyxiW2MrMTBdPWwqdittKnorbipEK28qSCxiW2MrMTFdPWwqdyttKkErbipFK28qSSxiW2MrMTJdPXAqdCtxKngrcipCK3MqRixiW2MrMTNdPXAqdStxKnkrcipDK3MqRyxiW2MrMTRdPXAqditxKnorcipEK3MqSCxiW2MrMTVdPXAqdytxKkErcipFK3MqSX0sYS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGEpe3JldHVybiBhJiZ0aGlzLm1bMF09PT1hLm1bMF0mJnRoaXMubVsxXT09PWEubVsxXSYmdGhpcy5tWzJdPT09YS5tWzJdJiZ0aGlzLm1bM109PT1hLm1bM10mJnRoaXMubVs0XT09PWEubVs0XSYmdGhpcy5tWzVdPT09YS5tWzVdJiZ0aGlzLm1bNl09PT1hLm1bNl0mJnRoaXMubVs3XT09PWEubVs3XSYmdGhpcy5tWzhdPT09YS5tWzhdJiZ0aGlzLm1bOV09PT1hLm1bOV0mJnRoaXMubVsxMF09PT1hLm1bMTBdJiZ0aGlzLm1bMTFdPT09YS5tWzExXSYmdGhpcy5tWzEyXT09PWEubVsxMl0mJnRoaXMubVsxM109PT1hLm1bMTNdJiZ0aGlzLm1bMTRdPT09YS5tWzE0XSYmdGhpcy5tWzE1XT09PWEubVsxNV19LGEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIGEuRnJvbVZhbHVlcyh0aGlzLm1bMF0sdGhpcy5tWzFdLHRoaXMubVsyXSx0aGlzLm1bM10sdGhpcy5tWzRdLHRoaXMubVs1XSx0aGlzLm1bNl0sdGhpcy5tWzddLHRoaXMubVs4XSx0aGlzLm1bOV0sdGhpcy5tWzEwXSx0aGlzLm1bMTFdLHRoaXMubVsxMl0sdGhpcy5tWzEzXSx0aGlzLm1bMTRdLHRoaXMubVsxNV0pfSxhLkZyb21BcnJheT1mdW5jdGlvbihiLGMpe3ZhciBkPW5ldyBhO3JldHVybiBjfHwoYz0wKSxhLkZyb21BcnJheVRvUmVmKGIsYyxkKSxkfSxhLkZyb21BcnJheVRvUmVmPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MDsxNj5kO2QrKyljLm1bZF09YVtkK2JdfSxhLkZyb21WYWx1ZXNUb1JlZj1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSxqLGssbCxtLG4sbyxwLHEpe3EubVswXT1hLHEubVsxXT1iLHEubVsyXT1jLHEubVszXT1kLHEubVs0XT1lLHEubVs1XT1mLHEubVs2XT1nLHEubVs3XT1oLHEubVs4XT1pLHEubVs5XT1qLHEubVsxMF09ayxxLm1bMTFdPWwscS5tWzEyXT1tLHEubVsxM109bixxLm1bMTRdPW8scS5tWzE1XT1wfSxhLkZyb21WYWx1ZXM9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpLGosayxsLG0sbixvLHAscSl7dmFyIHI9bmV3IGE7cmV0dXJuIHIubVswXT1iLHIubVsxXT1jLHIubVsyXT1kLHIubVszXT1lLHIubVs0XT1mLHIubVs1XT1nLHIubVs2XT1oLHIubVs3XT1pLHIubVs4XT1qLHIubVs5XT1rLHIubVsxMF09bCxyLm1bMTFdPW0sci5tWzEyXT1uLHIubVsxM109byxyLm1bMTRdPXAsci5tWzE1XT1xLHJ9LGEuSWRlbnRpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gYS5Gcm9tVmFsdWVzKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpfSxhLklkZW50aXR5VG9SZWY9ZnVuY3Rpb24oYil7YS5Gcm9tVmFsdWVzVG9SZWYoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSxiKX0sYS5aZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIGEuRnJvbVZhbHVlcygwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwKX0sYS5Sb3RhdGlvblg9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGE7cmV0dXJuIGEuUm90YXRpb25YVG9SZWYoYixjKSxjfSxhLlJvdGF0aW9uWFRvUmVmPWZ1bmN0aW9uKGEsYil7dmFyIGM9TWF0aC5zaW4oYSksZD1NYXRoLmNvcyhhKTtiLm1bMF09MSxiLm1bMTVdPTEsYi5tWzVdPWQsYi5tWzEwXT1kLGIubVs5XT0tYyxiLm1bNl09YyxiLm1bMV09MCxiLm1bMl09MCxiLm1bM109MCxiLm1bNF09MCxiLm1bN109MCxiLm1bOF09MCxiLm1bMTFdPTAsYi5tWzEyXT0wLGIubVsxM109MCxiLm1bMTRdPTB9LGEuUm90YXRpb25ZPWZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhO3JldHVybiBhLlJvdGF0aW9uWVRvUmVmKGIsYyksY30sYS5Sb3RhdGlvbllUb1JlZj1mdW5jdGlvbihhLGIpe3ZhciBjPU1hdGguc2luKGEpLGQ9TWF0aC5jb3MoYSk7Yi5tWzVdPTEsYi5tWzE1XT0xLGIubVswXT1kLGIubVsyXT0tYyxiLm1bOF09YyxiLm1bMTBdPWQsYi5tWzFdPTAsYi5tWzNdPTAsYi5tWzRdPTAsYi5tWzZdPTAsYi5tWzddPTAsYi5tWzldPTAsYi5tWzExXT0wLGIubVsxMl09MCxiLm1bMTNdPTAsYi5tWzE0XT0wfSxhLlJvdGF0aW9uWj1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYTtyZXR1cm4gYS5Sb3RhdGlvblpUb1JlZihiLGMpLGN9LGEuUm90YXRpb25aVG9SZWY9ZnVuY3Rpb24oYSxiKXt2YXIgYz1NYXRoLnNpbihhKSxkPU1hdGguY29zKGEpO2IubVsxMF09MSxiLm1bMTVdPTEsYi5tWzBdPWQsYi5tWzFdPWMsYi5tWzRdPS1jLGIubVs1XT1kLGIubVsyXT0wLGIubVszXT0wLGIubVs2XT0wLGIubVs3XT0wLGIubVs4XT0wLGIubVs5XT0wLGIubVsxMV09MCxiLm1bMTJdPTAsYi5tWzEzXT0wLGIubVsxNF09MH0sYS5Sb3RhdGlvbkF4aXM9ZnVuY3Rpb24oYixjKXt2YXIgZD1NYXRoLnNpbigtYyksZT1NYXRoLmNvcygtYyksZj0xLWU7Yi5ub3JtYWxpemUoKTt2YXIgZz1hLlplcm8oKTtyZXR1cm4gZy5tWzBdPWIueCpiLngqZitlLGcubVsxXT1iLngqYi55KmYtYi56KmQsZy5tWzJdPWIueCpiLnoqZitiLnkqZCxnLm1bM109MCxnLm1bNF09Yi55KmIueCpmK2IueipkLGcubVs1XT1iLnkqYi55KmYrZSxnLm1bNl09Yi55KmIueipmLWIueCpkLGcubVs3XT0wLGcubVs4XT1iLnoqYi54KmYtYi55KmQsZy5tWzldPWIueipiLnkqZitiLngqZCxnLm1bMTBdPWIueipiLnoqZitlLGcubVsxMV09MCxnLm1bMTVdPTEsZ30sYS5Sb3RhdGlvbllhd1BpdGNoUm9sbD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IGE7cmV0dXJuIGEuUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZihiLGMsZCxlKSxlfSxhLlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCl7Zi5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKGEsYixjLHRoaXMuX3RlbXBRdWF0ZXJuaW9uKSx0aGlzLl90ZW1wUXVhdGVybmlvbi50b1JvdGF0aW9uTWF0cml4KGQpfSxhLlNjYWxpbmc9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuWmVybygpO3JldHVybiBhLlNjYWxpbmdUb1JlZihiLGMsZCxlKSxlfSxhLlNjYWxpbmdUb1JlZj1mdW5jdGlvbihhLGIsYyxkKXtkLm1bMF09YSxkLm1bMV09MCxkLm1bMl09MCxkLm1bM109MCxkLm1bNF09MCxkLm1bNV09YixkLm1bNl09MCxkLm1bN109MCxkLm1bOF09MCxkLm1bOV09MCxkLm1bMTBdPWMsZC5tWzExXT0wLGQubVsxMl09MCxkLm1bMTNdPTAsZC5tWzE0XT0wLGQubVsxNV09MX0sYS5UcmFuc2xhdGlvbj1mdW5jdGlvbihiLGMsZCl7dmFyIGU9YS5JZGVudGl0eSgpO3JldHVybiBhLlRyYW5zbGF0aW9uVG9SZWYoYixjLGQsZSksZX0sYS5UcmFuc2xhdGlvblRvUmVmPWZ1bmN0aW9uKGIsYyxkLGUpe2EuRnJvbVZhbHVlc1RvUmVmKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLGIsYyxkLDEsZSl9LGEuTG9va0F0TEg9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuWmVybygpO3JldHVybiBhLkxvb2tBdExIVG9SZWYoYixjLGQsZSksZX0sYS5Mb29rQXRMSFRvUmVmPWZ1bmN0aW9uKGIsYyxkLGYpe2Muc3VidHJhY3RUb1JlZihiLHRoaXMuX3pBeGlzKSx0aGlzLl96QXhpcy5ub3JtYWxpemUoKSxlLkNyb3NzVG9SZWYoZCx0aGlzLl96QXhpcyx0aGlzLl94QXhpcyksdGhpcy5feEF4aXMubm9ybWFsaXplKCksZS5Dcm9zc1RvUmVmKHRoaXMuX3pBeGlzLHRoaXMuX3hBeGlzLHRoaXMuX3lBeGlzKSx0aGlzLl95QXhpcy5ub3JtYWxpemUoKTt2YXIgZz0tZS5Eb3QodGhpcy5feEF4aXMsYiksaD0tZS5Eb3QodGhpcy5feUF4aXMsYiksaT0tZS5Eb3QodGhpcy5fekF4aXMsYik7cmV0dXJuIGEuRnJvbVZhbHVlc1RvUmVmKHRoaXMuX3hBeGlzLngsdGhpcy5feUF4aXMueCx0aGlzLl96QXhpcy54LDAsdGhpcy5feEF4aXMueSx0aGlzLl95QXhpcy55LHRoaXMuX3pBeGlzLnksMCx0aGlzLl94QXhpcy56LHRoaXMuX3lBeGlzLnosdGhpcy5fekF4aXMueiwwLGcsaCxpLDEsZil9LGEuT3J0aG9MSD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj0yL2IsZz0yL2MsaD0xLyhlLWQpLGk9ZC8oZC1lKTtyZXR1cm4gYS5Gcm9tVmFsdWVzKGYsMCwwLDAsMCxnLDAsMCwwLDAsaCwwLDAsMCxpLDEpfSxhLk9ydGhvT2ZmQ2VudGVyTEg9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe3ZhciBoPWEuWmVybygpO3JldHVybiBhLk9ydGhvT2ZmQ2VudGVyTEhUb1JlZihiLGMsZCxlLGYsZyxoKSxofSxhLk9ydGhvT2ZmQ2VudGVyTEhUb1JlZj1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXtnLm1bMF09Mi8oYi1hKSxnLm1bMV09Zy5tWzJdPWcubVszXT0wLGcubVs1XT0yLyhkLWMpLGcubVs0XT1nLm1bNl09Zy5tWzddPTAsZy5tWzEwXT0tMS8oZS1mKSxnLm1bOF09Zy5tWzldPWcubVsxMV09MCxnLm1bMTJdPShhK2IpLyhhLWIpLGcubVsxM109KGQrYykvKGMtZCksZy5tWzE0XT1lLyhlLWYpLGcubVsxNV09MX0sYS5QZXJzcGVjdGl2ZUxIPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWEuWmVybygpO3JldHVybiBmLm1bMF09MipkL2IsZi5tWzFdPWYubVsyXT1mLm1bM109MCxmLm1bNV09MipkL2MsZi5tWzRdPWYubVs2XT1mLm1bN109MCxmLm1bMTBdPS1lLyhkLWUpLGYubVs4XT1mLm1bOV09MCxmLm1bMTFdPTEsZi5tWzEyXT1mLm1bMTNdPWYubVsxNV09MCxmLm1bMTRdPWQqZS8oZC1lKSxmfSxhLlBlcnNwZWN0aXZlRm92TEg9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9YS5aZXJvKCk7cmV0dXJuIGEuUGVyc3BlY3RpdmVGb3ZMSFRvUmVmKGIsYyxkLGUsZiksZn0sYS5QZXJzcGVjdGl2ZUZvdkxIVG9SZWY9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj0xL01hdGgudGFuKC41KmEpO2UubVswXT1mL2IsZS5tWzFdPWUubVsyXT1lLm1bM109MCxlLm1bNV09ZixlLm1bNF09ZS5tWzZdPWUubVs3XT0wLGUubVs4XT1lLm1bOV09MCxlLm1bMTBdPS1kLyhjLWQpLGUubVsxMV09MSxlLm1bMTJdPWUubVsxM109ZS5tWzE1XT0wLGUubVsxNF09YypkLyhjLWQpfSxhLkdldEZpbmFsTWF0cml4PWZ1bmN0aW9uKGIsYyxkLGUsZixnKXt2YXIgaD1iLndpZHRoLGk9Yi5oZWlnaHQsaj1iLngsaz1iLnksbD1hLkZyb21WYWx1ZXMoaC8yLDAsMCwwLDAsLWkvMiwwLDAsMCwwLGctZiwwLGoraC8yLGkvMitrLGYsMSk7cmV0dXJuIGMubXVsdGlwbHkoZCkubXVsdGlwbHkoZSkubXVsdGlwbHkobCl9LGEuVHJhbnNwb3NlPWZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhO3JldHVybiBjLm1bMF09Yi5tWzBdLGMubVsxXT1iLm1bNF0sYy5tWzJdPWIubVs4XSxjLm1bM109Yi5tWzEyXSxjLm1bNF09Yi5tWzFdLGMubVs1XT1iLm1bNV0sYy5tWzZdPWIubVs5XSxjLm1bN109Yi5tWzEzXSxjLm1bOF09Yi5tWzJdLGMubVs5XT1iLm1bNl0sYy5tWzEwXT1iLm1bMTBdLGMubVsxMV09Yi5tWzE0XSxjLm1bMTJdPWIubVszXSxjLm1bMTNdPWIubVs3XSxjLm1bMTRdPWIubVsxMV0sYy5tWzE1XT1iLm1bMTVdLGN9LGEuUmVmbGVjdGlvbj1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYTtyZXR1cm4gYS5SZWZsZWN0aW9uVG9SZWYoYixjKSxjfSxhLlJlZmxlY3Rpb25Ub1JlZj1mdW5jdGlvbihhLGIpe2Eubm9ybWFsaXplKCk7dmFyIGM9YS5ub3JtYWwueCxkPWEubm9ybWFsLnksZT1hLm5vcm1hbC56LGY9LTIqYyxnPS0yKmQsaD0tMiplO2IubVswXT1mKmMrMSxiLm1bMV09ZypjLGIubVsyXT1oKmMsYi5tWzNdPTAsYi5tWzRdPWYqZCxiLm1bNV09ZypkKzEsYi5tWzZdPWgqZCxiLm1bN109MCxiLm1bOF09ZiplLGIubVs5XT1nKmUsYi5tWzEwXT1oKmUrMSxiLm1bMTFdPTAsYi5tWzEyXT1mKmEuZCxiLm1bMTNdPWcqYS5kLGIubVsxNF09aCphLmQsYi5tWzE1XT0xfSxhLl90ZW1wUXVhdGVybmlvbj1uZXcgZixhLl94QXhpcz1lLlplcm8oKSxhLl95QXhpcz1lLlplcm8oKSxhLl96QXhpcz1lLlplcm8oKSxhfSgpO2EuTWF0cml4PWc7dmFyIGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQpe3RoaXMubm9ybWFsPW5ldyBlKGEsYixjKSx0aGlzLmQ9ZH1yZXR1cm4gYi5wcm90b3R5cGUuYXNBcnJheT1mdW5jdGlvbigpe3JldHVyblt0aGlzLm5vcm1hbC54LHRoaXMubm9ybWFsLnksdGhpcy5ub3JtYWwueix0aGlzLmRdfSxiLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYih0aGlzLm5vcm1hbC54LHRoaXMubm9ybWFsLnksdGhpcy5ub3JtYWwueix0aGlzLmQpfSxiLnByb3RvdHlwZS5ub3JtYWxpemU9ZnVuY3Rpb24oKXt2YXIgYT1NYXRoLnNxcnQodGhpcy5ub3JtYWwueCp0aGlzLm5vcm1hbC54K3RoaXMubm9ybWFsLnkqdGhpcy5ub3JtYWwueSt0aGlzLm5vcm1hbC56KnRoaXMubm9ybWFsLnopLGI9MDswIT1hJiYoYj0xL2EpLHRoaXMubm9ybWFsLngqPWIsdGhpcy5ub3JtYWwueSo9Yix0aGlzLm5vcm1hbC56Kj1iLHRoaXMuZCo9Yn0sYi5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKGIpe3ZhciBjPWEuTWF0cml4LlRyYW5zcG9zZShiKSxkPXRoaXMubm9ybWFsLngsZT10aGlzLm5vcm1hbC55LGY9dGhpcy5ub3JtYWwueixnPXRoaXMuZCxoPWQqYy5tWzBdK2UqYy5tWzFdK2YqYy5tWzJdK2cqYy5tWzNdLGk9ZCpjLm1bNF0rZSpjLm1bNV0rZipjLm1bNl0rZypjLm1bN10saj1kKmMubVs4XStlKmMubVs5XStmKmMubVsxMF0rZypjLm1bMTFdLGs9ZCpjLm1bMTJdK2UqYy5tWzEzXStmKmMubVsxNF0rZypjLm1bMTVdO3JldHVybiBuZXcgYS5QbGFuZShoLGksaixrKX0sYi5wcm90b3R5cGUuZG90Q29vcmRpbmF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ub3JtYWwueCphLngrdGhpcy5ub3JtYWwueSphLnkrdGhpcy5ub3JtYWwueiphLnordGhpcy5kfSxiLnByb3RvdHlwZS5jb3B5RnJvbVBvaW50cz1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZT1iLngtYS54LGY9Yi55LWEueSxnPWIuei1hLnosaD1jLngtYS54LGk9Yy55LWEueSxqPWMuei1hLnosaz1mKmotZyppLGw9ZypoLWUqaixtPWUqaS1mKmgsbj1NYXRoLnNxcnQoayprK2wqbCttKm0pO2Q9MCE9bj8xL246MCx0aGlzLm5vcm1hbC54PWsqZCx0aGlzLm5vcm1hbC55PWwqZCx0aGlzLm5vcm1hbC56PW0qZCx0aGlzLmQ9LSh0aGlzLm5vcm1hbC54KmEueCt0aGlzLm5vcm1hbC55KmEueSt0aGlzLm5vcm1hbC56KmEueil9LGIucHJvdG90eXBlLmlzRnJvbnRGYWNpbmdUbz1mdW5jdGlvbihhLGIpe3ZhciBjPWUuRG90KHRoaXMubm9ybWFsLGEpO3JldHVybiBiPj1jfSxiLnByb3RvdHlwZS5zaWduZWREaXN0YW5jZVRvPWZ1bmN0aW9uKGEpe3JldHVybiBlLkRvdChhLHRoaXMubm9ybWFsKSt0aGlzLmR9LGIuRnJvbUFycmF5PWZ1bmN0aW9uKGIpe3JldHVybiBuZXcgYS5QbGFuZShiWzBdLGJbMV0sYlsyXSxiWzNdKX0sYi5Gcm9tUG9pbnRzPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1uZXcgYS5QbGFuZSgwLDAsMCwwKTtyZXR1cm4gZS5jb3B5RnJvbVBvaW50cyhiLGMsZCksZX0sYi5Gcm9tUG9zaXRpb25BbmROb3JtYWw9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYS5QbGFuZSgwLDAsMCwwKTtyZXR1cm4gYy5ub3JtYWxpemUoKSxkLm5vcm1hbD1jLGQuZD0tKGMueCpiLngrYy55KmIueStjLnoqYi56KSxkfSxiLlNpZ25lZERpc3RhbmNlVG9QbGFuZUZyb21Qb3NpdGlvbkFuZE5vcm1hbD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9LShiLngqYS54K2IueSphLnkrYi56KmEueik7cmV0dXJuIGUuRG90KGMsYikrZH0sYn0oKTthLlBsYW5lPWg7dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYixjLGQpe3RoaXMueD1hLHRoaXMueT1iLHRoaXMud2lkdGg9Yyx0aGlzLmhlaWdodD1kfXJldHVybiBhLnByb3RvdHlwZS50b0dsb2JhbD1mdW5jdGlvbihiKXt2YXIgYz1iLmdldFJlbmRlcldpZHRoKCksZD1iLmdldFJlbmRlckhlaWdodCgpO3JldHVybiBuZXcgYSh0aGlzLngqYyx0aGlzLnkqZCx0aGlzLndpZHRoKmMsdGhpcy5oZWlnaHQqZCl9LGF9KCk7YS5WaWV3cG9ydD1pO3ZhciBqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe31yZXR1cm4gYS5HZXRQbGFuZXM9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPVtdLGQ9MDs2PmQ7ZCsrKWMucHVzaChuZXcgaCgwLDAsMCwwKSk7cmV0dXJuIGEuR2V0UGxhbmVzVG9SZWYoYixjKSxjfSxhLkdldFBsYW5lc1RvUmVmPWZ1bmN0aW9uKGEsYil7YlswXS5ub3JtYWwueD1hLm1bM10rYS5tWzJdLGJbMF0ubm9ybWFsLnk9YS5tWzddK2EubVs2XSxiWzBdLm5vcm1hbC56PWEubVsxMF0rYS5tWzEwXSxiWzBdLmQ9YS5tWzE1XSthLm1bMTRdLGJbMF0ubm9ybWFsaXplKCksYlsxXS5ub3JtYWwueD1hLm1bM10tYS5tWzJdLGJbMV0ubm9ybWFsLnk9YS5tWzddLWEubVs2XSxiWzFdLm5vcm1hbC56PWEubVsxMV0tYS5tWzEwXSxiWzFdLmQ9YS5tWzE1XS1hLm1bMTRdLGJbMV0ubm9ybWFsaXplKCksYlsyXS5ub3JtYWwueD1hLm1bM10rYS5tWzBdLGJbMl0ubm9ybWFsLnk9YS5tWzddK2EubVs0XSxiWzJdLm5vcm1hbC56PWEubVsxMV0rYS5tWzhdLGJbMl0uZD1hLm1bMTVdK2EubVsxMl0sYlsyXS5ub3JtYWxpemUoKSxiWzNdLm5vcm1hbC54PWEubVszXS1hLm1bMF0sYlszXS5ub3JtYWwueT1hLm1bN10tYS5tWzRdLGJbM10ubm9ybWFsLno9YS5tWzExXS1hLm1bOF0sYlszXS5kPWEubVsxNV0tYS5tWzEyXSxiWzNdLm5vcm1hbGl6ZSgpLGJbNF0ubm9ybWFsLng9YS5tWzNdLWEubVsxXSxiWzRdLm5vcm1hbC55PWEubVs3XS1hLm1bNV0sYls0XS5ub3JtYWwuej1hLm1bMTFdLWEubVs5XSxiWzRdLmQ9YS5tWzE1XS1hLm1bMTNdLGJbNF0ubm9ybWFsaXplKCksYls1XS5ub3JtYWwueD1hLm1bM10rYS5tWzFdLGJbNV0ubm9ybWFsLnk9YS5tWzddK2EubVs1XSxiWzVdLm5vcm1hbC56PWEubVsxMV0rYS5tWzldLGJbNV0uZD1hLm1bMTVdK2EubVsxM10sYls1XS5ub3JtYWxpemUoKX0sYX0oKTthLkZydXN0dW09ajt2YXIgaz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiKXt0aGlzLm9yaWdpbj1hLHRoaXMuZGlyZWN0aW9uPWJ9cmV0dXJuIGIucHJvdG90eXBlLmludGVyc2VjdHNCb3hNaW5NYXg9ZnVuY3Rpb24oYSxiKXt2YXIgYz0wLGQ9TnVtYmVyLk1BWF9WQUxVRTtpZihNYXRoLmFicyh0aGlzLmRpcmVjdGlvbi54KTwxZS03KXtpZih0aGlzLm9yaWdpbi54PGEueHx8dGhpcy5vcmlnaW4ueD5iLngpcmV0dXJuITF9ZWxzZXt2YXIgZT0xL3RoaXMuZGlyZWN0aW9uLngsZj0oYS54LXRoaXMub3JpZ2luLngpKmUsZz0oYi54LXRoaXMub3JpZ2luLngpKmU7aWYoZj5nKXt2YXIgaD1mO2Y9ZyxnPWh9aWYoYz1NYXRoLm1heChmLGMpLGQ9TWF0aC5taW4oZyxkKSxjPmQpcmV0dXJuITF9aWYoTWF0aC5hYnModGhpcy5kaXJlY3Rpb24ueSk8MWUtNyl7aWYodGhpcy5vcmlnaW4ueTxhLnl8fHRoaXMub3JpZ2luLnk+Yi55KXJldHVybiExfWVsc2UgaWYoZT0xL3RoaXMuZGlyZWN0aW9uLnksZj0oYS55LXRoaXMub3JpZ2luLnkpKmUsZz0oYi55LXRoaXMub3JpZ2luLnkpKmUsZj5nJiYoaD1mLGY9ZyxnPWgpLGM9TWF0aC5tYXgoZixjKSxkPU1hdGgubWluKGcsZCksYz5kKXJldHVybiExO2lmKE1hdGguYWJzKHRoaXMuZGlyZWN0aW9uLnopPDFlLTcpe2lmKHRoaXMub3JpZ2luLno8YS56fHx0aGlzLm9yaWdpbi56PmIueilyZXR1cm4hMX1lbHNlIGlmKGU9MS90aGlzLmRpcmVjdGlvbi56LGY9KGEuei10aGlzLm9yaWdpbi56KSplLGc9KGIuei10aGlzLm9yaWdpbi56KSplLGY+ZyYmKGg9ZixmPWcsZz1oKSxjPU1hdGgubWF4KGYsYyksZD1NYXRoLm1pbihnLGQpLGM+ZClyZXR1cm4hMTtyZXR1cm4hMH0sYi5wcm90b3R5cGUuaW50ZXJzZWN0c0JveD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94TWluTWF4KGEubWluaW11bSxhLm1heGltdW0pfSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzU3BoZXJlPWZ1bmN0aW9uKGEpe3ZhciBiPWEuY2VudGVyLngtdGhpcy5vcmlnaW4ueCxjPWEuY2VudGVyLnktdGhpcy5vcmlnaW4ueSxkPWEuY2VudGVyLnotdGhpcy5vcmlnaW4ueixlPWIqYitjKmMrZCpkLGY9YS5yYWRpdXMqYS5yYWRpdXM7aWYoZj49ZSlyZXR1cm4hMDt2YXIgZz1iKnRoaXMuZGlyZWN0aW9uLngrYyp0aGlzLmRpcmVjdGlvbi55K2QqdGhpcy5kaXJlY3Rpb24uejtpZigwPmcpcmV0dXJuITE7dmFyIGg9ZS1nKmc7cmV0dXJuIGY+PWh9LGIucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZT1mdW5jdGlvbihiLGMsZCl7dGhpcy5fZWRnZTF8fCh0aGlzLl9lZGdlMT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2VkZ2UyPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fcHZlYz1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3R2ZWM9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9xdmVjPWEuVmVjdG9yMy5aZXJvKCkpLGMuc3VidHJhY3RUb1JlZihiLHRoaXMuX2VkZ2UxKSxkLnN1YnRyYWN0VG9SZWYoYix0aGlzLl9lZGdlMiksYS5WZWN0b3IzLkNyb3NzVG9SZWYodGhpcy5kaXJlY3Rpb24sdGhpcy5fZWRnZTIsdGhpcy5fcHZlYyk7dmFyIGY9ZS5Eb3QodGhpcy5fZWRnZTEsdGhpcy5fcHZlYyk7aWYoMD09PWYpcmV0dXJuIG51bGw7dmFyIGc9MS9mO3RoaXMub3JpZ2luLnN1YnRyYWN0VG9SZWYoYix0aGlzLl90dmVjKTt2YXIgaD1lLkRvdCh0aGlzLl90dmVjLHRoaXMuX3B2ZWMpKmc7aWYoMD5ofHxoPjEpcmV0dXJuIG51bGw7ZS5Dcm9zc1RvUmVmKHRoaXMuX3R2ZWMsdGhpcy5fZWRnZTEsdGhpcy5fcXZlYyk7dmFyIGk9ZS5Eb3QodGhpcy5kaXJlY3Rpb24sdGhpcy5fcXZlYykqZztyZXR1cm4gMD5pfHxoK2k+MT9udWxsOm5ldyBhLkludGVyc2VjdGlvbkluZm8oaCxpLGUuRG90KHRoaXMuX2VkZ2UyLHRoaXMuX3F2ZWMpKmcpfSxiLkNyZWF0ZU5ldz1mdW5jdGlvbihjLGQsZSxmLGcsaCxpKXt2YXIgaj1hLlZlY3RvcjMuVW5wcm9qZWN0KG5ldyBhLlZlY3RvcjMoYyxkLDApLGUsZixnLGgsaSksaz1hLlZlY3RvcjMuVW5wcm9qZWN0KG5ldyBhLlZlY3RvcjMoYyxkLDEpLGUsZixnLGgsaSksbD1rLnN1YnRyYWN0KGopO3JldHVybiBsLm5vcm1hbGl6ZSgpLG5ldyBiKGosbCl9LGIuVHJhbnNmb3JtPWZ1bmN0aW9uKGMsZCl7dmFyIGU9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGMub3JpZ2luLGQpLGY9YS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChjLmRpcmVjdGlvbixkKTtyZXR1cm4gbmV3IGIoZSxmKX0sYn0oKTthLlJheT1rLGZ1bmN0aW9uKGEpe2FbYS5MT0NBTD0wXT1cIkxPQ0FMXCIsYVthLldPUkxEPTFdPVwiV09STERcIn0oYS5TcGFjZXx8KGEuU3BhY2U9e30pKTt2YXIgbD0oYS5TcGFjZSxmdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt9cmV0dXJuIGIuWD1uZXcgYS5WZWN0b3IzKDEsMCwwKSxiLlk9bmV3IGEuVmVjdG9yMygwLDEsMCksYi5aPW5ldyBhLlZlY3RvcjMoMCwwLDEpLGJ9KCkpO2EuQXhpcz1sfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYixjPTYwLGQ9W10sZT02MCxmPTAsZz1mdW5jdGlvbihiLGMpe3JldHVybiBiP2IgaW5zdGFuY2VvZiBhLk1lc2g/bnVsbDpiIGluc3RhbmNlb2YgYS5TdWJNZXNoP2IuY2xvbmUoYyk6Yi5jbG9uZT9iLmNsb25lKCk6bnVsbDpudWxsfSxoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaCgpe31yZXR1cm4gaC5HZXRGaWxlbmFtZT1mdW5jdGlvbihhKXt2YXIgYj1hLmxhc3RJbmRleE9mKFwiL1wiKTtyZXR1cm4gMD5iP2E6YS5zdWJzdHJpbmcoYisxKX0saC5HZXRET01UZXh0Q29udGVudD1mdW5jdGlvbihhKXtmb3IodmFyIGI9XCJcIixjPWEuZmlyc3RDaGlsZDtjOykzPT1jLm5vZGVUeXBlJiYoYis9Yy50ZXh0Q29udGVudCksYz1jLm5leHRTaWJsaW5nO3JldHVybiBifSxoLlRvRGVncmVlcz1mdW5jdGlvbihhKXtyZXR1cm4gMTgwKmEvTWF0aC5QSX0saC5Ub1JhZGlhbnM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEqTWF0aC5QSS8xODB9LGguRXh0cmFjdE1pbkFuZE1heEluZGV4ZWQ9ZnVuY3Rpb24oYixjLGQsZSl7Zm9yKHZhciBmPW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpLGc9bmV3IGEuVmVjdG9yMygtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSksaD1kO2QrZT5oO2grKyl7dmFyIGk9bmV3IGEuVmVjdG9yMyhiWzMqY1toXV0sYlszKmNbaF0rMV0sYlszKmNbaF0rMl0pO2Y9YS5WZWN0b3IzLk1pbmltaXplKGksZiksZz1hLlZlY3RvcjMuTWF4aW1pemUoaSxnKX1yZXR1cm57bWluaW11bTpmLG1heGltdW06Z319LGguRXh0cmFjdE1pbkFuZE1heD1mdW5jdGlvbihiLGMsZCl7Zm9yKHZhciBlPW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpLGY9bmV3IGEuVmVjdG9yMygtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSksZz1jO2MrZD5nO2crKyl7dmFyIGg9bmV3IGEuVmVjdG9yMyhiWzMqZ10sYlszKmcrMV0sYlszKmcrMl0pO2U9YS5WZWN0b3IzLk1pbmltaXplKGgsZSksZj1hLlZlY3RvcjMuTWF4aW1pemUoaCxmKX1yZXR1cm57bWluaW11bTplLG1heGltdW06Zn19LGguTWFrZUFycmF5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9PT0hMHx8dm9pZCAwIT09YSYmbnVsbCE9YT9BcnJheS5pc0FycmF5KGEpP2E6W2FdOnZvaWQgMH0saC5HZXRQb2ludGVyUHJlZml4PWZ1bmN0aW9uKCl7dmFyIGE9XCJwb2ludGVyXCI7cmV0dXJuIG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZHx8KGE9XCJtb3VzZVwiKSxhfSxoLlF1ZXVlTmV3RnJhbWU9ZnVuY3Rpb24oYSl7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpOndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSk6d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpOndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZShhKTp3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZShhKTp3aW5kb3cuc2V0VGltZW91dChhLDE2KX0saC5SZXF1ZXN0RnVsbHNjcmVlbj1mdW5jdGlvbihhKXthLnJlcXVlc3RGdWxsc2NyZWVuP2EucmVxdWVzdEZ1bGxzY3JlZW4oKTphLm1zUmVxdWVzdEZ1bGxzY3JlZW4/YS5tc1JlcXVlc3RGdWxsc2NyZWVuKCk6YS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbj9hLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk6YS5tb3pSZXF1ZXN0RnVsbFNjcmVlbiYmYS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpfSxoLkV4aXRGdWxsc2NyZWVuPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4/ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTpkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuP2RvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTpkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuP2RvY3VtZW50LndlYmtpdENhbmNlbEZ1bGxTY3JlZW4oKTpkb2N1bWVudC5tc0NhbmNlbEZ1bGxTY3JlZW4mJmRvY3VtZW50Lm1zQ2FuY2VsRnVsbFNjcmVlbigpfSxoLkNsZWFuVXJsPWZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZSgvIy9nbSxcIiUyM1wiKX0saC5Mb2FkSW1hZ2U9ZnVuY3Rpb24oYixjLGQsZSl7Yj1oLkNsZWFuVXJsKGIpO3ZhciBmPW5ldyBJbWFnZTtmLmNyb3NzT3JpZ2luPVwiYW5vbnltb3VzXCIsZi5vbmxvYWQ9ZnVuY3Rpb24oKXtjKGYpfSxmLm9uZXJyb3I9ZnVuY3Rpb24oYSl7ZChmLGEpfTt2YXIgZz1mdW5jdGlvbigpe2Yuc3JjPWJ9LGk9ZnVuY3Rpb24oKXtlLmxvYWRJbWFnZUZyb21EQihiLGYpfTtpZihlJiZlLmVuYWJsZVRleHR1cmVzT2ZmbGluZSYmYS5EYXRhYmFzZS5pc1VBU3VwcG9ydGluZ0Jsb2JTdG9yYWdlKWUub3BlbkFzeW5jKGksZyk7ZWxzZSBpZigtMT09PWIuaW5kZXhPZihcImZpbGU6XCIpKWcoKTtlbHNlIHRyeXt2YXIgaixrPWIuc3Vic3RyaW5nKDUpO3RyeXtqPVVSTC5jcmVhdGVPYmplY3RVUkwoYS5GaWxlc0lucHV0LkZpbGVzVGV4dHVyZXNba10se29uZVRpbWVPbmx5OiEwfSl9Y2F0Y2gobCl7aj1VUkwuY3JlYXRlT2JqZWN0VVJMKGEuRmlsZXNJbnB1dC5GaWxlc1RleHR1cmVzW2tdKX1mLnNyYz1qfWNhdGNoKG0pe2guTG9nKFwiRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGxvYWQgdGV4dHVyZTogXCIrayksZi5zcmM9bnVsbH1yZXR1cm4gZn0saC5Mb2FkRmlsZT1mdW5jdGlvbihiLGMsZCxlLGYpe2I9aC5DbGVhblVybChiKTtcbnZhciBnPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0LGc9aC5CYXNlVXJsK2I7ZS5vcGVuKFwiR0VUXCIsZywhMCksZiYmKGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIiksZS5vbnByb2dyZXNzPWQsZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT1lLnJlYWR5U3RhdGUpe2lmKDIwMCE9ZS5zdGF0dXMmJiFhLlRvb2xzLlZhbGlkYXRlWEhSRGF0YShlLGY/NjoxKSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdGF0dXM6IFwiK2Uuc3RhdHVzK1wiIC0gVW5hYmxlIHRvIGxvYWQgXCIrZyk7YyhmP2UucmVzcG9uc2U6ZS5yZXNwb25zZVRleHQpfX0sZS5zZW5kKG51bGwpfSxpPWZ1bmN0aW9uKCl7ZS5sb2FkRmlsZUZyb21EQihiLGMsZCxnLGYpfTtpZigtMSE9PWIuaW5kZXhPZihcImZpbGU6XCIpKXt2YXIgaj1iLnN1YnN0cmluZyg1KTthLlRvb2xzLlJlYWRGaWxlKGEuRmlsZXNJbnB1dC5GaWxlc1RvTG9hZFtqXSxjLGQsITApfWVsc2UgZSYmZS5lbmFibGVTY2VuZU9mZmxpbmU/ZS5vcGVuQXN5bmMoaSxnKTpnKCl9LGguUmVhZEZpbGU9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IEZpbGVSZWFkZXI7ZS5vbmxvYWQ9ZnVuY3Rpb24oYSl7YihhLnRhcmdldC5yZXN1bHQpfSxlLm9ucHJvZ3Jlc3M9YyxkP2UucmVhZEFzQXJyYXlCdWZmZXIoYSk6ZS5yZWFkQXNUZXh0KGEpfSxoLkNoZWNrRXh0ZW5kcz1mdW5jdGlvbihhLGIsYyl7YS54PGIueCYmKGIueD1hLngpLGEueTxiLnkmJihiLnk9YS55KSxhLno8Yi56JiYoYi56PWEueiksYS54PmMueCYmKGMueD1hLngpLGEueT5jLnkmJihjLnk9YS55KSxhLno+Yy56JiYoYy56PWEueil9LGguV2l0aGluRXBzaWxvbj1mdW5jdGlvbihhLGIpe3ZhciBjPWEtYjtyZXR1cm4gYz49LTEuNDAxMjk4ZS00NSYmMS40MDEyOThlLTQ1Pj1jfSxoLkRlZXBDb3B5PWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZSBpbiBhKWlmKChcIl9cIiE9PWVbMF18fGQmJi0xIT09ZC5pbmRleE9mKGUpKSYmKCFjfHwtMT09PWMuaW5kZXhPZihlKSkpe3ZhciBmPWFbZV0saD10eXBlb2YgZjtpZihcImZ1bmN0aW9uXCIhPWgpaWYoXCJvYmplY3RcIj09aClpZihmIGluc3RhbmNlb2YgQXJyYXkpe2lmKGJbZV09W10sZi5sZW5ndGg+MClpZihcIm9iamVjdFwiPT10eXBlb2YgZlswXSlmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krKyl7dmFyIGo9ZyhmW2ldLGIpOy0xPT09YltlXS5pbmRleE9mKGopJiZiW2VdLnB1c2goail9ZWxzZSBiW2VdPWYuc2xpY2UoMCl9ZWxzZSBiW2VdPWcoZixiKTtlbHNlIGJbZV09Zn19LGguSXNFbXB0eT1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0saC5SZWdpc3RlclRvcFJvb3RFdmVudHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPWFbYl07d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYy5uYW1lLGMuaGFuZGxlciwhMSk7dHJ5e3dpbmRvdy5wYXJlbnQmJndpbmRvdy5wYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcihjLm5hbWUsYy5oYW5kbGVyLCExKX1jYXRjaChkKXt9fX0saC5VbnJlZ2lzdGVyVG9wUm9vdEV2ZW50cz1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihjLm5hbWUsYy5oYW5kbGVyKTt0cnl7d2luZG93LnBhcmVudCYmd2luZG93LnBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKGMubmFtZSxjLmhhbmRsZXIpfWNhdGNoKGQpe319fSxoLkdldEZwcz1mdW5jdGlvbigpe3JldHVybiBlfSxoLkdldERlbHRhVGltZT1mdW5jdGlvbigpe3JldHVybiBmfSxoLl9NZWFzdXJlRnBzPWZ1bmN0aW9uKCl7ZC5wdXNoKChuZXcgRGF0ZSkuZ2V0VGltZSgpKTt2YXIgYT1kLmxlbmd0aDtpZihhPj0yJiYoZj1kW2EtMV0tZFthLTJdKSxhPj1jKXthPmMmJihkLnNwbGljZSgwLDEpLGE9ZC5sZW5ndGgpO2Zvcih2YXIgYj0wLGc9MDthLTE+ZztnKyspYis9ZFtnKzFdLWRbZ107ZT0xZTMvKGIvKGEtMSkpfX0saC5DcmVhdGVTY3JlZW5zaG90PWZ1bmN0aW9uKGMsZCxlKXt2YXIgZixnLGk9ZC5nZXRTY2VuZSgpLGo9bnVsbDtpZihpLmFjdGl2ZUNhbWVyYSE9PWQmJihqPWkuYWN0aXZlQ2FtZXJhLGkuYWN0aXZlQ2FtZXJhPWQpLGUucHJlY2lzaW9uKWY9TWF0aC5yb3VuZChjLmdldFJlbmRlcldpZHRoKCkqZS5wcmVjaXNpb24pLGc9TWF0aC5yb3VuZChmL2MuZ2V0QXNwZWN0UmF0aW8oZCkpLGU9e3dpZHRoOmYsaGVpZ2h0Omd9O2Vsc2UgaWYoZS53aWR0aCYmZS5oZWlnaHQpZj1lLndpZHRoLGc9ZS5oZWlnaHQ7ZWxzZSBpZihlLndpZHRoJiYhZS5oZWlnaHQpZj1lLndpZHRoLGc9TWF0aC5yb3VuZChmL2MuZ2V0QXNwZWN0UmF0aW8oZCkpLGU9e3dpZHRoOmYsaGVpZ2h0Omd9O2Vsc2UgaWYoZS5oZWlnaHQmJiFlLndpZHRoKWc9ZS5oZWlnaHQsZj1NYXRoLnJvdW5kKGcqYy5nZXRBc3BlY3RSYXRpbyhkKSksZT17d2lkdGg6ZixoZWlnaHQ6Z307ZWxzZXtpZihpc05hTihlKSlyZXR1cm4gdm9pZCBoLkVycm9yKFwiSW52YWxpZCAnc2l6ZScgcGFyYW1ldGVyICFcIik7Zz1lLGY9ZX12YXIgaz1uZXcgYS5SZW5kZXJUYXJnZXRUZXh0dXJlKFwic2NyZWVuU2hvdFwiLGUsYy5zY2VuZXNbMF0sITEsITEpO2sucmVuZGVyTGlzdD1jLnNjZW5lc1swXS5tZXNoZXMsay5vbkFmdGVyUmVuZGVyPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTQqZixkPWcvMixlPWMucmVhZFBpeGVscygwLDAsZixnKSxoPTA7ZD5oO2grKylmb3IodmFyIGk9MDthPmk7aSsrKXt2YXIgaj1pK2gqYSxrPWctaC0xLGw9aStrKmEsbT1lW2pdO2Vbal09ZVtsXSxlW2xdPW19Ynx8KGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSksYi53aWR0aD1mLGIuaGVpZ2h0PWc7dmFyIG49Yi5nZXRDb250ZXh0KFwiMmRcIiksbz1uLmNyZWF0ZUltYWdlRGF0YShmLGcpO28uZGF0YS5zZXQoZSksbi5wdXRJbWFnZURhdGEobywwLDApO3ZhciBwPWIudG9EYXRhVVJMKCk7aWYoXCJkb3dubG9hZFwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpe3ZhciBxPXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtxLmhyZWY9cDt2YXIgcj1uZXcgRGF0ZSxzPXIuZ2V0RnVsbFllYXIoKStcIi9cIityLmdldE1vbnRoKCkrXCIvXCIrci5nZXREYXRlKCkrXCItXCIrci5nZXRIb3VycygpK1wiOlwiK3IuZ2V0TWludXRlcygpO3Euc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIixcInNjcmVlbnNob3QtXCIrcytcIi5wbmdcIiksd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocSkscS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe3EucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChxKX0pLHEuY2xpY2soKX1lbHNle3ZhciB0PXdpbmRvdy5vcGVuKFwiXCIpLHU9dC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO3Uuc3JjPXAsdC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHUpfX0say5yZW5kZXIoITApLGsuZGlzcG9zZSgpLGomJihpLmFjdGl2ZUNhbWVyYT1qKX0saC5WYWxpZGF0ZVhIUkRhdGE9ZnVuY3Rpb24oYixjKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9Nyk7dHJ5e2lmKDEmYyl7aWYoYi5yZXNwb25zZVRleHQmJmIucmVzcG9uc2VUZXh0Lmxlbmd0aD4wKXJldHVybiEwO2lmKDE9PT1jKXJldHVybiExfWlmKDImYyl7dmFyIGQ9YS5JbnRlcm5hbHMuVEdBVG9vbHMuR2V0VEdBSGVhZGVyKGIucmVzcG9uc2UpO2lmKGQud2lkdGgmJmQuaGVpZ2h0JiZkLndpZHRoPjAmJmQuaGVpZ2h0PjApcmV0dXJuITA7aWYoMj09PWMpcmV0dXJuITF9aWYoNCZjKXt2YXIgZT1uZXcgVWludDhBcnJheShiLnJlc3BvbnNlLDAsMyk7cmV0dXJuIDY4PT1lWzBdJiY2OD09ZVsxXSYmODM9PWVbMl0/ITA6ITF9fWNhdGNoKGYpe31yZXR1cm4hMX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJOb25lTG9nTGV2ZWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX05vbmVMb2dMZXZlbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIk1lc3NhZ2VMb2dMZXZlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fTWVzc2FnZUxvZ0xldmVsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiV2FybmluZ0xvZ0xldmVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9XYXJuaW5nTG9nTGV2ZWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJFcnJvckxvZ0xldmVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9FcnJvckxvZ0xldmVsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiQWxsTG9nTGV2ZWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX01lc3NhZ2VMb2dMZXZlbHxoLl9XYXJuaW5nTG9nTGV2ZWx8aC5fRXJyb3JMb2dMZXZlbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxoLl9Gb3JtYXRNZXNzYWdlPWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe3JldHVybiAxMD5hP1wiMFwiK2E6XCJcIithfSxjPW5ldyBEYXRlO3JldHVyblwiQkpTIC0gW1wiK2IoYy5nZXRIb3VycygpKStcIjpcIitiKGMuZ2V0TWludXRlcygpKStcIjpcIitiKGMuZ2V0U2Vjb25kcygpKStcIl06IFwiK2F9LGguX0xvZ0Rpc2FibGVkPWZ1bmN0aW9uKCl7fSxoLl9Mb2dFbmFibGVkPWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKGguX0Zvcm1hdE1lc3NhZ2UoYSkpfSxoLl9XYXJuRGlzYWJsZWQ9ZnVuY3Rpb24oKXt9LGguX1dhcm5FbmFibGVkPWZ1bmN0aW9uKGEpe2NvbnNvbGUud2FybihoLl9Gb3JtYXRNZXNzYWdlKGEpKX0saC5fRXJyb3JEaXNhYmxlZD1mdW5jdGlvbigpe30saC5fRXJyb3JFbmFibGVkPWZ1bmN0aW9uKGEpe2NvbnNvbGUuZXJyb3IoaC5fRm9ybWF0TWVzc2FnZShhKSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiTG9nTGV2ZWxzXCIse3NldDpmdW5jdGlvbihhKXtoLkxvZz0oYSZoLk1lc3NhZ2VMb2dMZXZlbCk9PT1oLk1lc3NhZ2VMb2dMZXZlbD9oLl9Mb2dFbmFibGVkOmguX0xvZ0Rpc2FibGVkLGguV2Fybj0oYSZoLldhcm5pbmdMb2dMZXZlbCk9PT1oLldhcm5pbmdMb2dMZXZlbD9oLl9XYXJuRW5hYmxlZDpoLl9XYXJuRGlzYWJsZWQsaC5FcnJvcj0oYSZoLkVycm9yTG9nTGV2ZWwpPT09aC5FcnJvckxvZ0xldmVsP2guX0Vycm9yRW5hYmxlZDpoLl9FcnJvckRpc2FibGVkfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGguQmFzZVVybD1cIlwiLGguX05vbmVMb2dMZXZlbD0wLGguX01lc3NhZ2VMb2dMZXZlbD0xLGguX1dhcm5pbmdMb2dMZXZlbD0yLGguX0Vycm9yTG9nTGV2ZWw9NCxoLkxvZz1oLl9Mb2dFbmFibGVkLGguV2Fybj1oLl9XYXJuRW5hYmxlZCxoLkVycm9yPWguX0Vycm9yRW5hYmxlZCxofSgpO2EuVG9vbHM9aH0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5jcmVhdGVTaGFkZXIoXCJ2ZXJ0ZXhcIj09PWM/YS5WRVJURVhfU0hBREVSOmEuRlJBR01FTlRfU0hBREVSKTtpZihhLnNoYWRlclNvdXJjZShlLChkP2QrXCJcXG5cIjpcIlwiKStiKSxhLmNvbXBpbGVTaGFkZXIoZSksIWEuZ2V0U2hhZGVyUGFyYW1ldGVyKGUsYS5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGEuZ2V0U2hhZGVySW5mb0xvZyhlKSk7cmV0dXJuIGV9LGM9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWQuTkVBUkVTVCxmPWQuTkVBUkVTVDtyZXR1cm4gYj09PWEuVGV4dHVyZS5CSUxJTkVBUl9TQU1QTElOR01PREU/KGU9ZC5MSU5FQVIsZj1jP2QuTElORUFSX01JUE1BUF9ORUFSRVNUOmQuTElORUFSKTpiPT09YS5UZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREU/KGU9ZC5MSU5FQVIsZj1jP2QuTElORUFSX01JUE1BUF9MSU5FQVI6ZC5MSU5FQVIpOmI9PT1hLlRleHR1cmUuTkVBUkVTVF9TQU1QTElOR01PREUmJihlPWQuTkVBUkVTVCxmPWM/ZC5ORUFSRVNUX01JUE1BUF9MSU5FQVI6ZC5ORUFSRVNUKSx7bWluOmYsbWFnOmV9fSxkPWZ1bmN0aW9uKGEsYil7dmFyIGM9MTtkbyBjKj0yO3doaWxlKGE+Yyk7cmV0dXJuIGM+YiYmKGM9YiksY30sZT1mdW5jdGlvbihiLGUsZixnLGgsaSxqLGssbCxtKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgbSYmKG09YS5UZXh0dXJlLlRSSUxJTkVBUl9TQU1QTElOR01PREUpO3ZhciBuPWYuZ2V0RW5naW5lKCksbz1kKGcsbi5nZXRDYXBzKCkubWF4VGV4dHVyZVNpemUpLHA9ZChoLG4uZ2V0Q2FwcygpLm1heFRleHR1cmVTaXplKTtlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxiKSxlLnBpeGVsU3RvcmVpKGUuVU5QQUNLX0ZMSVBfWV9XRUJHTCx2b2lkIDA9PT1pPzE6aT8xOjApLGwobyxwKTt2YXIgcT1jKG0sIWosZSk7ZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCxlLlRFWFRVUkVfTUFHX0ZJTFRFUixxLm1hZyksZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCxlLlRFWFRVUkVfTUlOX0ZJTFRFUixxLm1pbiksanx8a3x8ZS5nZW5lcmF0ZU1pcG1hcChlLlRFWFRVUkVfMkQpLGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLG4uX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sYi5fYmFzZVdpZHRoPWcsYi5fYmFzZUhlaWdodD1oLGIuX3dpZHRoPW8sYi5faGVpZ2h0PXAsYi5pc1JlYWR5PSEwLGYuX3JlbW92ZVBlbmRpbmdEYXRhKGIpfSxmPWZ1bmN0aW9uKGIsYyxkLGUsZyxoKXt2YXIgaSxqPWZ1bmN0aW9uKCl7ZC5wdXNoKGkpLGUuX3JlbW92ZVBlbmRpbmdEYXRhKGkpLGMhPWgubGVuZ3RoLTE/ZihiLGMrMSxkLGUsZyxoKTpnKGQpfSxrPWZ1bmN0aW9uKCl7ZS5fcmVtb3ZlUGVuZGluZ0RhdGEoaSl9O2k9YS5Ub29scy5Mb2FkSW1hZ2UoYitoW2NdLGosayxlLmRhdGFiYXNlKSxlLl9hZGRQZW5kaW5nRGF0YShpKX0sZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt9cmV0dXJuIGF9KCk7YS5FbmdpbmVDYXBhYmlsaXRpZXM9Zzt2YXIgaD1mdW5jdGlvbigpe2Z1bmN0aW9uIGgoYSxiLGMpe3ZhciBkPXRoaXM7dGhpcy5pc0Z1bGxzY3JlZW49ITEsdGhpcy5pc1BvaW50ZXJMb2NrPSExLHRoaXMuZm9yY2VXaXJlZnJhbWU9ITEsdGhpcy5jdWxsQmFja0ZhY2VzPSEwLHRoaXMucmVuZGVyRXZlbkluQmFja2dyb3VuZD0hMCx0aGlzLnNjZW5lcz1uZXcgQXJyYXksdGhpcy5fd2luZG93SXNCYWNrZ3JvdW5kPSExLHRoaXMuX3J1bm5pbmdMb29wPSExLHRoaXMuX2xvYWRlZFRleHR1cmVzQ2FjaGU9bmV3IEFycmF5LHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGU9bmV3IEFycmF5LHRoaXMuX2NvbXBpbGVkRWZmZWN0cz17fSx0aGlzLl9kZXB0aE1hc2s9ITEsdGhpcy5fcmVuZGVyaW5nQ2FudmFzPWEsdGhpcy5fY2FudmFzQ2xpZW50UmVjdD10aGlzLl9yZW5kZXJpbmdDYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksYz1jfHx7fSxjLmFudGlhbGlhcz1iO3RyeXt0aGlzLl9nbD1hLmdldENvbnRleHQoXCJ3ZWJnbFwiLGMpfHxhLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixjKX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBub3Qgc3VwcG9ydGVkXCIpfWlmKCF0aGlzLl9nbCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBub3Qgc3VwcG9ydGVkXCIpO3RoaXMuX29uQmx1cj1mdW5jdGlvbigpe2QuX3dpbmRvd0lzQmFja2dyb3VuZD0hMH0sdGhpcy5fb25Gb2N1cz1mdW5jdGlvbigpe2QuX3dpbmRvd0lzQmFja2dyb3VuZD0hMX0sd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fb25CbHVyKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fb25Gb2N1cyksdGhpcy5fd29ya2luZ0NhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuX3dvcmtpbmdDb250ZXh0PXRoaXMuX3dvcmtpbmdDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLHRoaXMuX2hhcmR3YXJlU2NhbGluZ0xldmVsPTEvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSx0aGlzLnJlc2l6ZSgpLHRoaXMuX2NhcHM9bmV3IGcsdGhpcy5fY2Fwcy5tYXhUZXh0dXJlc0ltYWdlVW5pdHM9dGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2dsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSx0aGlzLl9jYXBzLm1heFRleHR1cmVTaXplPXRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl9nbC5NQVhfVEVYVFVSRV9TSVpFKSx0aGlzLl9jYXBzLm1heEN1YmVtYXBUZXh0dXJlU2l6ZT10aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSksdGhpcy5fY2Fwcy5tYXhSZW5kZXJUZXh0dXJlU2l6ZT10aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fZ2wuTUFYX1JFTkRFUkJVRkZFUl9TSVpFKSx0aGlzLl9jYXBzLnN0YW5kYXJkRGVyaXZhdGl2ZXM9bnVsbCE9PXRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKSx0aGlzLl9jYXBzLnMzdGM9dGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIiksdGhpcy5fY2Fwcy50ZXh0dXJlRmxvYXQ9bnVsbCE9PXRoaXMuX2dsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpLHRoaXMuX2NhcHMudGV4dHVyZUFuaXNvdHJvcGljRmlsdGVyRXh0ZW5zaW9uPXRoaXMuX2dsLmdldEV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKXx8dGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKXx8dGhpcy5fZ2wuZ2V0RXh0ZW5zaW9uKFwiTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSx0aGlzLl9jYXBzLm1heEFuaXNvdHJvcHk9dGhpcy5fY2Fwcy50ZXh0dXJlQW5pc290cm9waWNGaWx0ZXJFeHRlbnNpb24/dGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX2NhcHMudGV4dHVyZUFuaXNvdHJvcGljRmlsdGVyRXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk6MCx0aGlzLl9jYXBzLmluc3RhbmNlZEFycmF5cz10aGlzLl9nbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpLHRoaXMuc2V0RGVwdGhCdWZmZXIoITApLHRoaXMuc2V0RGVwdGhGdW5jdGlvblRvTGVzc09yRXF1YWwoKSx0aGlzLnNldERlcHRoV3JpdGUoITApLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZT1mdW5jdGlvbigpe3ZvaWQgMCE9PWRvY3VtZW50LmZ1bGxzY3JlZW4/ZC5pc0Z1bGxzY3JlZW49ZG9jdW1lbnQuZnVsbHNjcmVlbjp2b2lkIDAhPT1kb2N1bWVudC5tb3pGdWxsU2NyZWVuP2QuaXNGdWxsc2NyZWVuPWRvY3VtZW50Lm1vekZ1bGxTY3JlZW46dm9pZCAwIT09ZG9jdW1lbnQud2Via2l0SXNGdWxsU2NyZWVuP2QuaXNGdWxsc2NyZWVuPWRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbjp2b2lkIDAhPT1kb2N1bWVudC5tc0lzRnVsbFNjcmVlbiYmKGQuaXNGdWxsc2NyZWVuPWRvY3VtZW50Lm1zSXNGdWxsU2NyZWVuKSxkLmlzRnVsbHNjcmVlbiYmZC5fcG9pbnRlckxvY2tSZXF1ZXN0ZWQmJihhLnJlcXVlc3RQb2ludGVyTG9jaz1hLnJlcXVlc3RQb2ludGVyTG9ja3x8YS5tc1JlcXVlc3RQb2ludGVyTG9ja3x8YS5tb3pSZXF1ZXN0UG9pbnRlckxvY2t8fGEud2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrLGEucmVxdWVzdFBvaW50ZXJMb2NrJiZhLnJlcXVlc3RQb2ludGVyTG9jaygpKX0sZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIix0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1zZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSwhMSksdGhpcy5fb25Qb2ludGVyTG9ja0NoYW5nZT1mdW5jdGlvbigpe2QuaXNQb2ludGVyTG9jaz1kb2N1bWVudC5tb3pQb2ludGVyTG9ja0VsZW1lbnQ9PT1hfHxkb2N1bWVudC53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQ9PT1hfHxkb2N1bWVudC5tc1BvaW50ZXJMb2NrRWxlbWVudD09PWF8fGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudD09PWF9LGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtc3BvaW50ZXJsb2NrY2hhbmdlXCIsdGhpcy5fb25Qb2ludGVyTG9ja0NoYW5nZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1venBvaW50ZXJsb2NrY2hhbmdlXCIsdGhpcy5fb25Qb2ludGVyTG9ja0NoYW5nZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdHBvaW50ZXJsb2NrY2hhbmdlXCIsdGhpcy5fb25Qb2ludGVyTG9ja0NoYW5nZSwhMSl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiQUxQSEFfRElTQUJMRVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fQUxQSEFfRElTQUJMRX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkFMUEhBX0FERFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fQUxQSEFfQUREfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFwiQUxQSEFfQ09NQklORVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5fQUxQSEFfQ09NQklORX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkRFTEFZTE9BRFNUQVRFX05PTkVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0RFTEFZTE9BRFNUQVRFX05PTkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJERUxBWUxPQURTVEFURV9MT0FERURcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0RFTEFZTE9BRFNUQVRFX0xPQURFRH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIkRFTEFZTE9BRFNUQVRFX0xPQURJTkdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0RFTEFZTE9BRFNUQVRFX0xPQURJTkd9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsXCJERUxBWUxPQURTVEFURV9OT1RMT0FERURcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX0RFTEFZTE9BRFNUQVRFX05PVExPQURFRH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcIlZlcnNpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCIxLjEzLjBcIn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxoLnByb3RvdHlwZS5nZXRBc3BlY3RSYXRpbz1mdW5jdGlvbihhKXt2YXIgYj1hLnZpZXdwb3J0O3JldHVybiB0aGlzLmdldFJlbmRlcldpZHRoKCkqYi53aWR0aC8odGhpcy5nZXRSZW5kZXJIZWlnaHQoKSpiLmhlaWdodCl9LGgucHJvdG90eXBlLmdldFJlbmRlcldpZHRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQ/dGhpcy5fY3VycmVudFJlbmRlclRhcmdldC5fd2lkdGg6dGhpcy5fcmVuZGVyaW5nQ2FudmFzLndpZHRofSxoLnByb3RvdHlwZS5nZXRSZW5kZXJIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudFJlbmRlclRhcmdldD90aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0Ll9oZWlnaHQ6dGhpcy5fcmVuZGVyaW5nQ2FudmFzLmhlaWdodH0saC5wcm90b3R5cGUuZ2V0UmVuZGVyaW5nQ2FudmFzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlcmluZ0NhbnZhc30saC5wcm90b3R5cGUuZ2V0UmVuZGVyaW5nQ2FudmFzQ2xpZW50UmVjdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJpbmdDYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9LGgucHJvdG90eXBlLnNldEhhcmR3YXJlU2NhbGluZ0xldmVsPWZ1bmN0aW9uKGEpe3RoaXMuX2hhcmR3YXJlU2NhbGluZ0xldmVsPWEsdGhpcy5yZXNpemUoKX0saC5wcm90b3R5cGUuZ2V0SGFyZHdhcmVTY2FsaW5nTGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFyZHdhcmVTY2FsaW5nTGV2ZWx9LGgucHJvdG90eXBlLmdldExvYWRlZFRleHR1cmVzQ2FjaGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZX0saC5wcm90b3R5cGUuZ2V0Q2Fwcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jYXBzfSxoLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9HcmVhdGVyPWZ1bmN0aW9uKCl7dGhpcy5fZ2wuZGVwdGhGdW5jKHRoaXMuX2dsLkdSRUFURVIpfSxoLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9HcmVhdGVyT3JFcXVhbD1mdW5jdGlvbigpe3RoaXMuX2dsLmRlcHRoRnVuYyh0aGlzLl9nbC5HRVFVQUwpfSxoLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzPWZ1bmN0aW9uKCl7dGhpcy5fZ2wuZGVwdGhGdW5jKHRoaXMuX2dsLkxFU1MpfSxoLnByb3RvdHlwZS5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzT3JFcXVhbD1mdW5jdGlvbigpe3RoaXMuX2dsLmRlcHRoRnVuYyh0aGlzLl9nbC5MRVFVQUwpfSxoLnByb3RvdHlwZS5zdG9wUmVuZGVyTG9vcD1mdW5jdGlvbigpe3RoaXMuX3JlbmRlckZ1bmN0aW9uPW51bGwsdGhpcy5fcnVubmluZ0xvb3A9ITF9LGgucHJvdG90eXBlLl9yZW5kZXJMb29wPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPSEwOyF0aGlzLnJlbmRlckV2ZW5JbkJhY2tncm91bmQmJnRoaXMuX3dpbmRvd0lzQmFja2dyb3VuZCYmKGM9ITEpLGMmJih0aGlzLmJlZ2luRnJhbWUoKSx0aGlzLl9yZW5kZXJGdW5jdGlvbiYmdGhpcy5fcmVuZGVyRnVuY3Rpb24oKSx0aGlzLmVuZEZyYW1lKCkpLHRoaXMuX3J1bm5pbmdMb29wJiZhLlRvb2xzLlF1ZXVlTmV3RnJhbWUoZnVuY3Rpb24oKXtiLl9yZW5kZXJMb29wKCl9KX0saC5wcm90b3R5cGUucnVuUmVuZGVyTG9vcD1mdW5jdGlvbihiKXt2YXIgYz10aGlzO3RoaXMuX3J1bm5pbmdMb29wPSEwLHRoaXMuX3JlbmRlckZ1bmN0aW9uPWIsYS5Ub29scy5RdWV1ZU5ld0ZyYW1lKGZ1bmN0aW9uKCl7Yy5fcmVuZGVyTG9vcCgpfSl9LGgucHJvdG90eXBlLnN3aXRjaEZ1bGxzY3JlZW49ZnVuY3Rpb24oYil7dGhpcy5pc0Z1bGxzY3JlZW4/YS5Ub29scy5FeGl0RnVsbHNjcmVlbigpOih0aGlzLl9wb2ludGVyTG9ja1JlcXVlc3RlZD1iLGEuVG9vbHMuUmVxdWVzdEZ1bGxzY3JlZW4odGhpcy5fcmVuZGVyaW5nQ2FudmFzKSl9LGgucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKGEsYixjKXt0aGlzLl9nbC5jbGVhckNvbG9yKGEucixhLmcsYS5iLHZvaWQgMCE9PWEuYT9hLmE6MSksdGhpcy5fZGVwdGhNYXNrJiZ0aGlzLl9nbC5jbGVhckRlcHRoKDEpO3ZhciBkPTA7YiYmKGR8PXRoaXMuX2dsLkNPTE9SX0JVRkZFUl9CSVQpLGMmJnRoaXMuX2RlcHRoTWFzayYmKGR8PXRoaXMuX2dsLkRFUFRIX0JVRkZFUl9CSVQpLHRoaXMuX2dsLmNsZWFyKGQpfSxoLnByb3RvdHlwZS5zZXRWaWV3cG9ydD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Ynx8dGhpcy5fcmVuZGVyaW5nQ2FudmFzLndpZHRoLGU9Y3x8dGhpcy5fcmVuZGVyaW5nQ2FudmFzLmhlaWdodCxmPWEueHx8MCxnPWEueXx8MDt0aGlzLl9jYWNoZWRWaWV3cG9ydD1hLHRoaXMuX2dsLnZpZXdwb3J0KGYqZCxnKmUsZCphLndpZHRoLGUqYS5oZWlnaHQpfSxoLnByb3RvdHlwZS5zZXREaXJlY3RWaWV3cG9ydD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9jYWNoZWRWaWV3cG9ydD1udWxsLHRoaXMuX2dsLnZpZXdwb3J0KGEsYixjLGQpfSxoLnByb3RvdHlwZS5iZWdpbkZyYW1lPWZ1bmN0aW9uKCl7YS5Ub29scy5fTWVhc3VyZUZwcygpfSxoLnByb3RvdHlwZS5lbmRGcmFtZT1mdW5jdGlvbigpe3RoaXMuZmx1c2hGcmFtZWJ1ZmZlcigpfSxoLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJpbmdDYW52YXMud2lkdGg9dGhpcy5fcmVuZGVyaW5nQ2FudmFzLmNsaWVudFdpZHRoL3RoaXMuX2hhcmR3YXJlU2NhbGluZ0xldmVsLHRoaXMuX3JlbmRlcmluZ0NhbnZhcy5oZWlnaHQ9dGhpcy5fcmVuZGVyaW5nQ2FudmFzLmNsaWVudEhlaWdodC90aGlzLl9oYXJkd2FyZVNjYWxpbmdMZXZlbCx0aGlzLl9jYW52YXNDbGllbnRSZWN0PXRoaXMuX3JlbmRlcmluZ0NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKX0saC5wcm90b3R5cGUuYmluZEZyYW1lYnVmZmVyPWZ1bmN0aW9uKGEpe3RoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQ9YTt2YXIgYj10aGlzLl9nbDtiLmJpbmRGcmFtZWJ1ZmZlcihiLkZSQU1FQlVGRkVSLGEuX2ZyYW1lYnVmZmVyKSx0aGlzLl9nbC52aWV3cG9ydCgwLDAsYS5fd2lkdGgsYS5faGVpZ2h0KSx0aGlzLndpcGVDYWNoZXMoKX0saC5wcm90b3R5cGUudW5CaW5kRnJhbWVidWZmZXI9ZnVuY3Rpb24oYSl7aWYodGhpcy5fY3VycmVudFJlbmRlclRhcmdldD1udWxsLGEuZ2VuZXJhdGVNaXBNYXBzKXt2YXIgYj10aGlzLl9nbDtiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCxhKSxiLmdlbmVyYXRlTWlwbWFwKGIuVEVYVFVSRV8yRCksYi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsbnVsbCl9dGhpcy5fZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2dsLkZSQU1FQlVGRkVSLG51bGwpfSxoLnByb3RvdHlwZS5mbHVzaEZyYW1lYnVmZmVyPWZ1bmN0aW9uKCl7dGhpcy5fZ2wuZmx1c2goKX0saC5wcm90b3R5cGUucmVzdG9yZURlZmF1bHRGcmFtZWJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuX2dsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9nbC5GUkFNRUJVRkZFUixudWxsKSx0aGlzLnNldFZpZXdwb3J0KHRoaXMuX2NhY2hlZFZpZXdwb3J0KSx0aGlzLndpcGVDYWNoZXMoKX0saC5wcm90b3R5cGUuX3Jlc2V0VmVydGV4QnVmZmVyQmluZGluZz1mdW5jdGlvbigpe3RoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLG51bGwpLHRoaXMuX2NhY2hlZFZlcnRleEJ1ZmZlcnM9bnVsbH0saC5wcm90b3R5cGUuY3JlYXRlVmVydGV4QnVmZmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO3JldHVybiB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixiKSx0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixuZXcgRmxvYXQzMkFycmF5KGEpLHRoaXMuX2dsLlNUQVRJQ19EUkFXKSx0aGlzLl9yZXNldFZlcnRleEJ1ZmZlckJpbmRpbmcoKSxiLnJlZmVyZW5jZXM9MSxifSxoLnByb3RvdHlwZS5jcmVhdGVEeW5hbWljVmVydGV4QnVmZmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO3JldHVybiB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixiKSx0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixhLHRoaXMuX2dsLkRZTkFNSUNfRFJBVyksdGhpcy5fcmVzZXRWZXJ0ZXhCdWZmZXJCaW5kaW5nKCksYi5yZWZlcmVuY2VzPTEsYn0saC5wcm90b3R5cGUudXBkYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcj1mdW5jdGlvbihhLGIpe3RoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLGEpLGIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/dGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsMCxiKTp0aGlzLl9nbC5idWZmZXJTdWJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwwLG5ldyBGbG9hdDMyQXJyYXkoYikpLHRoaXMuX3Jlc2V0VmVydGV4QnVmZmVyQmluZGluZygpfSxoLnByb3RvdHlwZS5fcmVzZXRJbmRleEJ1ZmZlckJpbmRpbmc9ZnVuY3Rpb24oKXt0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpLHRoaXMuX2NhY2hlZEluZGV4QnVmZmVyPW51bGx9LGgucHJvdG90eXBlLmNyZWF0ZUluZGV4QnVmZmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO3JldHVybiB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGIpLHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbmV3IFVpbnQxNkFycmF5KGEpLHRoaXMuX2dsLlNUQVRJQ19EUkFXKSx0aGlzLl9yZXNldEluZGV4QnVmZmVyQmluZGluZygpLGIucmVmZXJlbmNlcz0xLGJ9LGgucHJvdG90eXBlLmJpbmRCdWZmZXJzPWZ1bmN0aW9uKGEsYixjLGQsZSl7aWYodGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycyE9PWF8fHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnMhPT1lKXt0aGlzLl9jYWNoZWRWZXJ0ZXhCdWZmZXJzPWEsdGhpcy5fY2FjaGVkRWZmZWN0Rm9yVmVydGV4QnVmZmVycz1lLHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLGEpO2Zvcih2YXIgZj0wLGc9MDtnPGMubGVuZ3RoO2crKyl7dmFyIGg9ZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbihnKTtoPj0wJiZ0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGgsY1tnXSx0aGlzLl9nbC5GTE9BVCwhMSxkLGYpLGYrPTQqY1tnXX19dGhpcy5fY2FjaGVkSW5kZXhCdWZmZXIhPT1iJiYodGhpcy5fY2FjaGVkSW5kZXhCdWZmZXI9Yix0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGIpKX0saC5wcm90b3R5cGUuYmluZE11bHRpQnVmZmVycz1mdW5jdGlvbihhLGIsYyl7aWYodGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycyE9PWF8fHRoaXMuX2NhY2hlZEVmZmVjdEZvclZlcnRleEJ1ZmZlcnMhPT1jKXt0aGlzLl9jYWNoZWRWZXJ0ZXhCdWZmZXJzPWEsdGhpcy5fY2FjaGVkRWZmZWN0Rm9yVmVydGV4QnVmZmVycz1jO2Zvcih2YXIgZD1jLmdldEF0dHJpYnV0ZXNOYW1lcygpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9Yy5nZXRBdHRyaWJ1dGVMb2NhdGlvbihlKTtpZihmPj0wKXt2YXIgZz1hW2RbZV1dO2lmKCFnKWNvbnRpbnVlO3ZhciBoPWcuZ2V0U3RyaWRlU2l6ZSgpO3RoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLGcuZ2V0QnVmZmVyKCkpLHRoaXMuX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoZixoLHRoaXMuX2dsLkZMT0FULCExLDQqaCwwKX19fXRoaXMuX2NhY2hlZEluZGV4QnVmZmVyIT09YiYmKHRoaXMuX2NhY2hlZEluZGV4QnVmZmVyPWIsdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUixiKSl9LGgucHJvdG90eXBlLl9yZWxlYXNlQnVmZmVyPWZ1bmN0aW9uKGEpe3JldHVybiBhLnJlZmVyZW5jZXMtLSwwPT09YS5yZWZlcmVuY2VzPyh0aGlzLl9nbC5kZWxldGVCdWZmZXIoYSksITApOiExfSxoLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZXNCdWZmZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7cmV0dXJuIGIuY2FwYWNpdHk9YSx0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixiKSx0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUixhLHRoaXMuX2dsLkRZTkFNSUNfRFJBVyksYn0saC5wcm90b3R5cGUuZGVsZXRlSW5zdGFuY2VzQnVmZmVyPWZ1bmN0aW9uKGEpe3RoaXMuX2dsLmRlbGV0ZUJ1ZmZlcihhKX0saC5wcm90b3R5cGUudXBkYXRlQW5kQmluZEluc3RhbmNlc0J1ZmZlcj1mdW5jdGlvbihhLGIsYyl7dGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYSksdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9nbC5BUlJBWV9CVUZGRVIsMCxiKTtmb3IodmFyIGQ9MDs0PmQ7ZCsrKXt2YXIgZT1jW2RdO3RoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGUpLHRoaXMuX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoZSw0LHRoaXMuX2dsLkZMT0FULCExLDY0LDE2KmQpLHRoaXMuX2NhcHMuaW5zdGFuY2VkQXJyYXlzLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShlLDEpfX0saC5wcm90b3R5cGUudW5CaW5kSW5zdGFuY2VzQnVmZmVyPWZ1bmN0aW9uKGEsYil7dGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsYSk7Zm9yKHZhciBjPTA7ND5jO2MrKyl7dmFyIGQ9YltjXTt0aGlzLl9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoZCksdGhpcy5fY2Fwcy5pbnN0YW5jZWRBcnJheXMudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGQsMCl9fSxoLnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBkP3ZvaWQgdGhpcy5fY2Fwcy5pbnN0YW5jZWRBcnJheXMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoYT90aGlzLl9nbC5UUklBTkdMRVM6dGhpcy5fZ2wuTElORVMsYyx0aGlzLl9nbC5VTlNJR05FRF9TSE9SVCwyKmIsZCk6dm9pZCB0aGlzLl9nbC5kcmF3RWxlbWVudHMoYT90aGlzLl9nbC5UUklBTkdMRVM6dGhpcy5fZ2wuTElORVMsYyx0aGlzLl9nbC5VTlNJR05FRF9TSE9SVCwyKmIpfSxoLnByb3RvdHlwZS5fcmVsZWFzZUVmZmVjdD1mdW5jdGlvbihhKXt0aGlzLl9jb21waWxlZEVmZmVjdHNbYS5fa2V5XSYmKGRlbGV0ZSB0aGlzLl9jb21waWxlZEVmZmVjdHNbYS5fa2V5XSxhLmdldFByb2dyYW0oKSYmdGhpcy5fZ2wuZGVsZXRlUHJvZ3JhbShhLmdldFByb2dyYW0oKSkpfSxoLnByb3RvdHlwZS5jcmVhdGVFZmZlY3Q9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpKXt2YXIgaj1iLnZlcnRleEVsZW1lbnR8fGIudmVydGV4fHxiLGs9Yi5mcmFnbWVudEVsZW1lbnR8fGIuZnJhZ21lbnR8fGIsbD1qK1wiK1wiK2srXCJAXCIrZjtpZih0aGlzLl9jb21waWxlZEVmZmVjdHNbbF0pcmV0dXJuIHRoaXMuX2NvbXBpbGVkRWZmZWN0c1tsXTt2YXIgbT1uZXcgYS5FZmZlY3QoYixjLGQsZSx0aGlzLGYsZyxoLGkpO3JldHVybiBtLl9rZXk9bCx0aGlzLl9jb21waWxlZEVmZmVjdHNbbF09bSxtfSxoLnByb3RvdHlwZS5jcmVhdGVTaGFkZXJQcm9ncmFtPWZ1bmN0aW9uKGEsYyxkKXt2YXIgZT1iKHRoaXMuX2dsLGEsXCJ2ZXJ0ZXhcIixkKSxmPWIodGhpcy5fZ2wsYyxcImZyYWdtZW50XCIsZCksZz10aGlzLl9nbC5jcmVhdGVQcm9ncmFtKCk7dGhpcy5fZ2wuYXR0YWNoU2hhZGVyKGcsZSksdGhpcy5fZ2wuYXR0YWNoU2hhZGVyKGcsZiksdGhpcy5fZ2wubGlua1Byb2dyYW0oZyk7dmFyIGg9dGhpcy5fZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihnLHRoaXMuX2dsLkxJTktfU1RBVFVTKTtpZighaCl7dmFyIGk9dGhpcy5fZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coZyk7aWYoaSl0aHJvdyBuZXcgRXJyb3IoaSl9cmV0dXJuIHRoaXMuX2dsLmRlbGV0ZVNoYWRlcihlKSx0aGlzLl9nbC5kZWxldGVTaGFkZXIoZiksZ30saC5wcm90b3R5cGUuZ2V0VW5pZm9ybXM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMucHVzaCh0aGlzLl9nbC5nZXRVbmlmb3JtTG9jYXRpb24oYSxiW2RdKSk7cmV0dXJuIGN9LGgucHJvdG90eXBlLmdldEF0dHJpYnV0ZXM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8Yi5sZW5ndGg7ZCsrKXRyeXtjLnB1c2godGhpcy5fZ2wuZ2V0QXR0cmliTG9jYXRpb24oYSxiW2RdKSl9Y2F0Y2goZSl7Yy5wdXNoKC0xKX1yZXR1cm4gY30saC5wcm90b3R5cGUuZW5hYmxlRWZmZWN0PWZ1bmN0aW9uKGEpe2lmKGEmJmEuZ2V0QXR0cmlidXRlc0NvdW50KCkmJnRoaXMuX2N1cnJlbnRFZmZlY3QhPT1hKXt0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXM9dGhpcy5fdmVydGV4QXR0cmliQXJyYXlzfHxbXSx0aGlzLl9nbC51c2VQcm9ncmFtKGEuZ2V0UHJvZ3JhbSgpKTtmb3IodmFyIGIgaW4gdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzKWI+dGhpcy5fZ2wuVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEfHwhdGhpcy5fdmVydGV4QXR0cmliQXJyYXlzW2JdfHwodGhpcy5fdmVydGV4QXR0cmliQXJyYXlzW2JdPSExLHRoaXMuX2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShiKSk7Zm9yKHZhciBjPWEuZ2V0QXR0cmlidXRlc0NvdW50KCksZD0wO2M+ZDtkKyspe3ZhciBlPWEuZ2V0QXR0cmlidXRlTG9jYXRpb24oZCk7ZT49MCYmKHRoaXMuX3ZlcnRleEF0dHJpYkFycmF5c1tlXT0hMCx0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSl9dGhpcy5fY3VycmVudEVmZmVjdD1hfX0saC5wcm90b3R5cGUuc2V0QXJyYXk9ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLl9nbC51bmlmb3JtMWZ2KGEsYil9LGgucHJvdG90eXBlLnNldE1hdHJpY2VzPWZ1bmN0aW9uKGEsYil7YSYmdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDRmdihhLCExLGIpfSxoLnByb3RvdHlwZS5zZXRNYXRyaXg9ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLl9nbC51bmlmb3JtTWF0cml4NGZ2KGEsITEsYi50b0FycmF5KCkpfSxoLnByb3RvdHlwZS5zZXRGbG9hdD1mdW5jdGlvbihhLGIpe2EmJnRoaXMuX2dsLnVuaWZvcm0xZihhLGIpfSxoLnByb3RvdHlwZS5zZXRGbG9hdDI9ZnVuY3Rpb24oYSxiLGMpe2EmJnRoaXMuX2dsLnVuaWZvcm0yZihhLGIsYyl9LGgucHJvdG90eXBlLnNldEZsb2F0Mz1mdW5jdGlvbihhLGIsYyxkKXthJiZ0aGlzLl9nbC51bmlmb3JtM2YoYSxiLGMsZCl9LGgucHJvdG90eXBlLnNldEJvb2w9ZnVuY3Rpb24oYSxiKXthJiZ0aGlzLl9nbC51bmlmb3JtMWkoYSxiKX0saC5wcm90b3R5cGUuc2V0RmxvYXQ0PWZ1bmN0aW9uKGEsYixjLGQsZSl7YSYmdGhpcy5fZ2wudW5pZm9ybTRmKGEsYixjLGQsZSl9LGgucHJvdG90eXBlLnNldENvbG9yMz1mdW5jdGlvbihhLGIpe2EmJnRoaXMuX2dsLnVuaWZvcm0zZihhLGIucixiLmcsYi5iKX0saC5wcm90b3R5cGUuc2V0Q29sb3I0PWZ1bmN0aW9uKGEsYixjKXthJiZ0aGlzLl9nbC51bmlmb3JtNGYoYSxiLnIsYi5nLGIuYixjKX0saC5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSl7dGhpcy5fY3VsbGluZ1N0YXRlIT09YSYmKGE/KHRoaXMuX2dsLmN1bGxGYWNlKHRoaXMuY3VsbEJhY2tGYWNlcz90aGlzLl9nbC5CQUNLOnRoaXMuX2dsLkZST05UKSx0aGlzLl9nbC5lbmFibGUodGhpcy5fZ2wuQ1VMTF9GQUNFKSk6dGhpcy5fZ2wuZGlzYWJsZSh0aGlzLl9nbC5DVUxMX0ZBQ0UpLHRoaXMuX2N1bGxpbmdTdGF0ZT1hKX0saC5wcm90b3R5cGUuc2V0RGVwdGhCdWZmZXI9ZnVuY3Rpb24oYSl7YT90aGlzLl9nbC5lbmFibGUodGhpcy5fZ2wuREVQVEhfVEVTVCk6dGhpcy5fZ2wuZGlzYWJsZSh0aGlzLl9nbC5ERVBUSF9URVNUKX0saC5wcm90b3R5cGUuc2V0RGVwdGhXcml0ZT1mdW5jdGlvbihhKXt0aGlzLl9nbC5kZXB0aE1hc2soYSksdGhpcy5fZGVwdGhNYXNrPWF9LGgucHJvdG90eXBlLnNldENvbG9yV3JpdGU9ZnVuY3Rpb24oYSl7dGhpcy5fZ2wuY29sb3JNYXNrKGEsYSxhLGEpfSxoLnByb3RvdHlwZS5zZXRBbHBoYU1vZGU9ZnVuY3Rpb24oYil7c3dpdGNoKGIpe2Nhc2UgYS5FbmdpbmUuQUxQSEFfRElTQUJMRTp0aGlzLnNldERlcHRoV3JpdGUoITApLHRoaXMuX2dsLmRpc2FibGUodGhpcy5fZ2wuQkxFTkQpO2JyZWFrO2Nhc2UgYS5FbmdpbmUuQUxQSEFfQ09NQklORTp0aGlzLnNldERlcHRoV3JpdGUoITEpLHRoaXMuX2dsLmJsZW5kRnVuY1NlcGFyYXRlKHRoaXMuX2dsLlNSQ19BTFBIQSx0aGlzLl9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBLHRoaXMuX2dsLk9ORSx0aGlzLl9nbC5PTkUpLHRoaXMuX2dsLmVuYWJsZSh0aGlzLl9nbC5CTEVORCk7YnJlYWs7Y2FzZSBhLkVuZ2luZS5BTFBIQV9BREQ6dGhpcy5zZXREZXB0aFdyaXRlKCExKSx0aGlzLl9nbC5ibGVuZEZ1bmNTZXBhcmF0ZSh0aGlzLl9nbC5PTkUsdGhpcy5fZ2wuT05FLHRoaXMuX2dsLlpFUk8sdGhpcy5fZ2wuT05FKSx0aGlzLl9nbC5lbmFibGUodGhpcy5fZ2wuQkxFTkQpfX0saC5wcm90b3R5cGUuc2V0QWxwaGFUZXN0aW5nPWZ1bmN0aW9uKGEpe3RoaXMuX2FscGhhVGVzdD1hfSxoLnByb3RvdHlwZS5nZXRBbHBoYVRlc3Rpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWxwaGFUZXN0fSxoLnByb3RvdHlwZS53aXBlQ2FjaGVzPWZ1bmN0aW9uKCl7dGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZT1bXSx0aGlzLl9jdXJyZW50RWZmZWN0PW51bGwsdGhpcy5fY3VsbGluZ1N0YXRlPW51bGwsdGhpcy5fY2FjaGVkVmVydGV4QnVmZmVycz1udWxsLHRoaXMuX2NhY2hlZEluZGV4QnVmZmVyPW51bGwsdGhpcy5fY2FjaGVkRWZmZWN0Rm9yVmVydGV4QnVmZmVycz1udWxsfSxoLnByb3RvdHlwZS5zZXRTYW1wbGluZ01vZGU9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLl9nbDtkLmJpbmRUZXh0dXJlKGQuVEVYVFVSRV8yRCxiKTt2YXIgZT1kLk5FQVJFU1QsZj1kLk5FQVJFU1Q7Yz09PWEuVGV4dHVyZS5CSUxJTkVBUl9TQU1QTElOR01PREU/KGU9ZC5MSU5FQVIsZj1kLkxJTkVBUik6Yz09PWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFJiYoZT1kLkxJTkVBUixmPWQuTElORUFSX01JUE1BUF9MSU5FQVIpLGQudGV4UGFyYW1ldGVyaShkLlRFWFRVUkVfMkQsZC5URVhUVVJFX01BR19GSUxURVIsZSksZC50ZXhQYXJhbWV0ZXJpKGQuVEVYVFVSRV8yRCxkLlRFWFRVUkVfTUlOX0ZJTFRFUixmKSxkLmJpbmRUZXh0dXJlKGQuVEVYVFVSRV8yRCxudWxsKX0saC5wcm90b3R5cGUuY3JlYXRlVGV4dHVyZT1mdW5jdGlvbihiLGMsZCxmLGcpe3ZhciBoPXRoaXM7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGcmJihnPWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFKTt2YXIgaT10aGlzLl9nbC5jcmVhdGVUZXh0dXJlKCksaj1iLnN1YnN0cihiLmxlbmd0aC00LDQpLnRvTG93ZXJDYXNlKCksaz10aGlzLmdldENhcHMoKS5zM3RjJiZcIi5kZHNcIj09PWosbD1cIi50Z2FcIj09PWo7aWYoZi5fYWRkUGVuZGluZ0RhdGEoaSksaS51cmw9YixpLm5vTWlwbWFwPWMsaS5yZWZlcmVuY2VzPTEsdGhpcy5fbG9hZGVkVGV4dHVyZXNDYWNoZS5wdXNoKGkpLGwpYS5Ub29scy5Mb2FkRmlsZShiLGZ1bmN0aW9uKGIpe3ZhciBqPW5ldyBVaW50OEFycmF5KGIpLGs9YS5JbnRlcm5hbHMuVEdBVG9vbHMuR2V0VEdBSGVhZGVyKGopO2UoaSxoLl9nbCxmLGsud2lkdGgsay5oZWlnaHQsZCxjLCExLGZ1bmN0aW9uKCl7YS5JbnRlcm5hbHMuVEdBVG9vbHMuVXBsb2FkQ29udGVudChoLl9nbCxqKX0sZyl9LG51bGwsZi5kYXRhYmFzZSwhMCk7ZWxzZSBpZihrKWEuVG9vbHMuTG9hZEZpbGUoYixmdW5jdGlvbihqKXt2YXIgaz1hLkludGVybmFscy5ERFNUb29scy5HZXRERFNJbmZvKGopLGw9KGsuaXNSR0J8fGsuaXNMdW1pbmFuY2V8fGsubWlwbWFwQ291bnQ+MSkmJiFjJiZrLndpZHRoPj5rLm1pcG1hcENvdW50LTE9PTE7ZShpLGguX2dsLGYsay53aWR0aCxrLmhlaWdodCxkLCFsLGsuaXNGb3VyQ0MsZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcImxvYWRpbmcgXCIrYiksYS5JbnRlcm5hbHMuRERTVG9vbHMuVXBsb2FkRERTTGV2ZWxzKGguX2dsLGguZ2V0Q2FwcygpLnMzdGMsaixrLGwsMSl9LGcpfSxudWxsLGYuZGF0YWJhc2UsITApO2Vsc2V7dmFyIG09ZnVuY3Rpb24oYSl7ZShpLGguX2dsLGYsYS53aWR0aCxhLmhlaWdodCxkLGMsITEsZnVuY3Rpb24oYixjKXt2YXIgZD1hLndpZHRoPT1iJiZhLmhlaWdodD09YztkfHwoaC5fd29ya2luZ0NhbnZhcy53aWR0aD1iLGguX3dvcmtpbmdDYW52YXMuaGVpZ2h0PWMsaC5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGEsMCwwLGEud2lkdGgsYS5oZWlnaHQsMCwwLGIsYykpLGguX2dsLnRleEltYWdlMkQoaC5fZ2wuVEVYVFVSRV8yRCwwLGguX2dsLlJHQkEsaC5fZ2wuUkdCQSxoLl9nbC5VTlNJR05FRF9CWVRFLGQ/YTpoLl93b3JraW5nQ2FudmFzKX0sZyl9LG49ZnVuY3Rpb24oKXtmLl9yZW1vdmVQZW5kaW5nRGF0YShpKX07YS5Ub29scy5Mb2FkSW1hZ2UoYixtLG4sZi5kYXRhYmFzZSl9cmV0dXJuIGl9LGgucHJvdG90eXBlLmNyZWF0ZUR5bmFtaWNUZXh0dXJlPWZ1bmN0aW9uKGEsYixlLGYpe3ZhciBnPXRoaXMuX2dsLmNyZWF0ZVRleHR1cmUoKTthPWQoYSx0aGlzLl9jYXBzLm1heFRleHR1cmVTaXplKSxiPWQoYix0aGlzLl9jYXBzLm1heFRleHR1cmVTaXplKSx0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELGcpO3ZhciBoPWMoZixlLHRoaXMuX2dsKTtyZXR1cm4gdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELHRoaXMuX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUixoLm1hZyksdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELHRoaXMuX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUixoLm1pbiksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxudWxsKSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlPVtdLGcuX2Jhc2VXaWR0aD1hLGcuX2Jhc2VIZWlnaHQ9YixnLl93aWR0aD1hLGcuX2hlaWdodD1iLGcuaXNSZWFkeT0hMSxnLmdlbmVyYXRlTWlwTWFwcz1lLGcucmVmZXJlbmNlcz0xLHRoaXMuX2xvYWRlZFRleHR1cmVzQ2FjaGUucHVzaChnKSxnfSxoLnByb3RvdHlwZS51cGRhdGVEeW5hbWljVGV4dHVyZT1mdW5jdGlvbihhLGIsYyl7dGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxhKSx0aGlzLl9nbC5waXhlbFN0b3JlaSh0aGlzLl9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLGM/MTowKSx0aGlzLl9nbC50ZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsMCx0aGlzLl9nbC5SR0JBLHRoaXMuX2dsLlJHQkEsdGhpcy5fZ2wuVU5TSUdORURfQllURSxiKSxhLmdlbmVyYXRlTWlwTWFwcyYmdGhpcy5fZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5fZ2wuVEVYVFVSRV8yRCksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxudWxsKSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlPVtdLGEuaXNSZWFkeT0hMH0saC5wcm90b3R5cGUudXBkYXRlVmlkZW9UZXh0dXJlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELGEpLHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsYz8wOjEpLGIudmlkZW9XaWR0aCE9PWEuX3dpZHRofHxiLnZpZGVvSGVpZ2h0IT09YS5faGVpZ2h0PyhhLl93b3JraW5nQ2FudmFzfHwoYS5fd29ya2luZ0NhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGEuX3dvcmtpbmdDb250ZXh0PWEuX3dvcmtpbmdDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLGEuX3dvcmtpbmdDYW52YXMud2lkdGg9YS5fd2lkdGgsYS5fd29ya2luZ0NhbnZhcy5oZWlnaHQ9YS5faGVpZ2h0KSxhLl93b3JraW5nQ29udGV4dC5kcmF3SW1hZ2UoYiwwLDAsYi52aWRlb1dpZHRoLGIudmlkZW9IZWlnaHQsMCwwLGEuX3dpZHRoLGEuX2hlaWdodCksdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELDAsdGhpcy5fZ2wuUkdCQSx0aGlzLl9nbC5SR0JBLHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsYS5fd29ya2luZ0NhbnZhcykpOnRoaXMuX2dsLnRleEltYWdlMkQodGhpcy5fZ2wuVEVYVFVSRV8yRCwwLHRoaXMuX2dsLlJHQkEsdGhpcy5fZ2wuUkdCQSx0aGlzLl9nbC5VTlNJR05FRF9CWVRFLGIpLGEuZ2VuZXJhdGVNaXBNYXBzJiZ0aGlzLl9nbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLl9nbC5URVhUVVJFXzJEKSx0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELG51bGwpLHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sYS5pc1JlYWR5PSEwfSxoLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlPWZ1bmN0aW9uKGIsZCl7dmFyIGU9ITEsZj0hMCxnPWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFO3ZvaWQgMCE9PWQmJihlPXZvaWQgMD09PWQuZ2VuZXJhdGVNaXBNYXBzP2Q6ZC5nZW5lcmF0ZU1pcG1hcHMsZj12b2lkIDA9PT1kLmdlbmVyYXRlRGVwdGhCdWZmZXI/ITA6ZC5nZW5lcmF0ZURlcHRoQnVmZmVyLHZvaWQgMCE9PWQuc2FtcGxpbmdNb2RlJiYoZz1kLnNhbXBsaW5nTW9kZSkpO3ZhciBoPXRoaXMuX2dsLGk9aC5jcmVhdGVUZXh0dXJlKCk7aC5iaW5kVGV4dHVyZShoLlRFWFRVUkVfMkQsaSk7dmFyIGo9Yi53aWR0aHx8YixrPWIuaGVpZ2h0fHxiLGw9YyhnLGUsaCk7aC50ZXhQYXJhbWV0ZXJpKGguVEVYVFVSRV8yRCxoLlRFWFRVUkVfTUFHX0ZJTFRFUixsLm1hZyksaC50ZXhQYXJhbWV0ZXJpKGguVEVYVFVSRV8yRCxoLlRFWFRVUkVfTUlOX0ZJTFRFUixsLm1pbiksaC50ZXhQYXJhbWV0ZXJpKGguVEVYVFVSRV8yRCxoLlRFWFRVUkVfV1JBUF9TLGguQ0xBTVBfVE9fRURHRSksaC50ZXhQYXJhbWV0ZXJpKGguVEVYVFVSRV8yRCxoLlRFWFRVUkVfV1JBUF9ULGguQ0xBTVBfVE9fRURHRSksaC50ZXhJbWFnZTJEKGguVEVYVFVSRV8yRCwwLGguUkdCQSxqLGssMCxoLlJHQkEsaC5VTlNJR05FRF9CWVRFLG51bGwpO3ZhciBtO2YmJihtPWguY3JlYXRlUmVuZGVyYnVmZmVyKCksaC5iaW5kUmVuZGVyYnVmZmVyKGguUkVOREVSQlVGRkVSLG0pLGgucmVuZGVyYnVmZmVyU3RvcmFnZShoLlJFTkRFUkJVRkZFUixoLkRFUFRIX0NPTVBPTkVOVDE2LGosaykpO3ZhciBuPWguY3JlYXRlRnJhbWVidWZmZXIoKTtyZXR1cm4gaC5iaW5kRnJhbWVidWZmZXIoaC5GUkFNRUJVRkZFUixuKSxoLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGguRlJBTUVCVUZGRVIsaC5DT0xPUl9BVFRBQ0hNRU5UMCxoLlRFWFRVUkVfMkQsaSwwKSxmJiZoLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGguRlJBTUVCVUZGRVIsaC5ERVBUSF9BVFRBQ0hNRU5ULGguUkVOREVSQlVGRkVSLG0pLGguYmluZFRleHR1cmUoaC5URVhUVVJFXzJELG51bGwpLGguYmluZFJlbmRlcmJ1ZmZlcihoLlJFTkRFUkJVRkZFUixudWxsKSxoLmJpbmRGcmFtZWJ1ZmZlcihoLkZSQU1FQlVGRkVSLG51bGwpLGkuX2ZyYW1lYnVmZmVyPW4sZiYmKGkuX2RlcHRoQnVmZmVyPW0pLGkuX3dpZHRoPWosaS5faGVpZ2h0PWssaS5pc1JlYWR5PSEwLGkuZ2VuZXJhdGVNaXBNYXBzPWUsaS5yZWZlcmVuY2VzPTEsdGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZT1bXSx0aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlLnB1c2goaSksaX0saC5wcm90b3R5cGUuY3JlYXRlQ3ViZVRleHR1cmU9ZnVuY3Rpb24oYixjLGUsZyl7dmFyIGg9dGhpcyxpPXRoaXMuX2dsLGo9aS5jcmVhdGVUZXh0dXJlKCk7ai5pc0N1YmU9ITAsai51cmw9YixqLnJlZmVyZW5jZXM9MSx0aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlLnB1c2goaik7dmFyIGs9Yi5zdWJzdHIoYi5sZW5ndGgtNCw0KS50b0xvd2VyQ2FzZSgpLGw9dGhpcy5nZXRDYXBzKCkuczN0YyYmXCIuZGRzXCI9PT1rO3JldHVybiBsP2EuVG9vbHMuTG9hZEZpbGUoYixmdW5jdGlvbihiKXt2YXIgYz1hLkludGVybmFscy5ERFNUb29scy5HZXRERFNJbmZvKGIpLGQ9KGMuaXNSR0J8fGMuaXNMdW1pbmFuY2V8fGMubWlwbWFwQ291bnQ+MSkmJiFnO2kuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLGopLGkucGl4ZWxTdG9yZWkoaS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLDEpLGEuSW50ZXJuYWxzLkREU1Rvb2xzLlVwbG9hZEREU0xldmVscyhoLl9nbCxoLmdldENhcHMoKS5zM3RjLGIsYyxkLDYpLGd8fGMuaXNGb3VyQ0N8fDEhPWMubWlwbWFwQ291bnR8fGkuZ2VuZXJhdGVNaXBtYXAoaS5URVhUVVJFX0NVQkVfTUFQKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFX0NVQkVfTUFQLGkuVEVYVFVSRV9NQUdfRklMVEVSLGkuTElORUFSKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFX0NVQkVfTUFQLGkuVEVYVFVSRV9NSU5fRklMVEVSLGQ/aS5MSU5FQVJfTUlQTUFQX0xJTkVBUjppLkxJTkVBUiksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfV1JBUF9TLGkuQ0xBTVBfVE9fRURHRSksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfV1JBUF9ULGkuQ0xBTVBfVE9fRURHRSksaS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCksaC5fYWN0aXZlVGV4dHVyZXNDYWNoZT1bXSxqLl93aWR0aD1jLndpZHRoLGouX2hlaWdodD1jLmhlaWdodCxqLmlzUmVhZHk9ITB9KTpmKGIsMCxbXSxjLGZ1bmN0aW9uKGEpe3ZhciBiPWQoYVswXS53aWR0aCxoLl9jYXBzLm1heEN1YmVtYXBUZXh0dXJlU2l6ZSksYz1iO2guX3dvcmtpbmdDYW52YXMud2lkdGg9YixoLl93b3JraW5nQ2FudmFzLmhlaWdodD1jO3ZhciBlPVtpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxpLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWixpLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCxpLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxpLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfQ1VCRV9NQVAsaiksaS5waXhlbFN0b3JlaShpLlVOUEFDS19GTElQX1lfV0VCR0wsMCk7Zm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspaC5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGFbZl0sMCwwLGFbZl0ud2lkdGgsYVtmXS5oZWlnaHQsMCwwLGIsYyksaS50ZXhJbWFnZTJEKGVbZl0sMCxpLlJHQkEsaS5SR0JBLGkuVU5TSUdORURfQllURSxoLl93b3JraW5nQ2FudmFzKTtnfHxpLmdlbmVyYXRlTWlwbWFwKGkuVEVYVFVSRV9DVUJFX01BUCksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfTUFHX0ZJTFRFUixpLkxJTkVBUiksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV9DVUJFX01BUCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixnP2kuTElORUFSOmkuTElORUFSX01JUE1BUF9MSU5FQVIpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX1dSQVBfUyxpLkNMQU1QX1RPX0VER0UpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfQ1VCRV9NQVAsaS5URVhUVVJFX1dSQVBfVCxpLkNMQU1QX1RPX0VER0UpLGkuYmluZFRleHR1cmUoaS5URVhUVVJFX0NVQkVfTUFQLG51bGwpLGguX2FjdGl2ZVRleHR1cmVzQ2FjaGU9W10sai5fd2lkdGg9YixqLl9oZWlnaHQ9YyxqLmlzUmVhZHk9ITB9LGUpLGp9LGgucHJvdG90eXBlLl9yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9nbDthLl9mcmFtZWJ1ZmZlciYmYi5kZWxldGVGcmFtZWJ1ZmZlcihhLl9mcmFtZWJ1ZmZlciksYS5fZGVwdGhCdWZmZXImJmIuZGVsZXRlUmVuZGVyYnVmZmVyKGEuX2RlcHRoQnVmZmVyKSxiLmRlbGV0ZVRleHR1cmUoYSk7Zm9yKHZhciBjPTA7Yzx0aGlzLl9jYXBzLm1heFRleHR1cmVzSW1hZ2VVbml0cztjKyspdGhpcy5fZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLl9nbFtcIlRFWFRVUkVcIitjXSksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxudWxsKSx0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFX0NVQkVfTUFQLG51bGwpLHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGVbY109bnVsbDt2YXIgZD10aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlLmluZGV4T2YoYSk7LTEhPT1kJiZ0aGlzLl9sb2FkZWRUZXh0dXJlc0NhY2hlLnNwbGljZShkLDEpfSxoLnByb3RvdHlwZS5iaW5kU2FtcGxlcnM9ZnVuY3Rpb24oYSl7dGhpcy5fZ2wudXNlUHJvZ3JhbShhLmdldFByb2dyYW0oKSk7Zm9yKHZhciBiPWEuZ2V0U2FtcGxlcnMoKSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWEuZ2V0VW5pZm9ybShiW2NdKTt0aGlzLl9nbC51bmlmb3JtMWkoZCxjKX10aGlzLl9jdXJyZW50RWZmZWN0PW51bGx9LGgucHJvdG90eXBlLl9iaW5kVGV4dHVyZT1mdW5jdGlvbihhLGIpe3RoaXMuX2dsLmFjdGl2ZVRleHR1cmUodGhpcy5fZ2xbXCJURVhUVVJFXCIrYV0pLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsYiksdGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZVthXT1udWxsfSxoLnByb3RvdHlwZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzPWZ1bmN0aW9uKGEsYil7dGhpcy5fYmluZFRleHR1cmUoYSxiLl90ZXh0dXJlcy5kYXRhW2IuX2N1cnJlbnRSZW5kZXJUZXh0dXJlSW5kXSl9LGgucHJvdG90eXBlLnNldFRleHR1cmU9ZnVuY3Rpb24oYixjKXtpZighKDA+Yikpe2lmKCFjfHwhYy5pc1JlYWR5KCkpcmV0dXJuIHZvaWQobnVsbCE9dGhpcy5fYWN0aXZlVGV4dHVyZXNDYWNoZVtiXSYmKHRoaXMuX2dsLmFjdGl2ZVRleHR1cmUodGhpcy5fZ2xbXCJURVhUVVJFXCIrYl0pLHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsbnVsbCksdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCxudWxsKSx0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlW2JdPW51bGwpKTtpZihjIGluc3RhbmNlb2YgYS5WaWRlb1RleHR1cmUpYy51cGRhdGUoKSYmKHRoaXMuX2FjdGl2ZVRleHR1cmVzQ2FjaGVbYl09bnVsbCk7ZWxzZSBpZihjLmRlbGF5TG9hZFN0YXRlPT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQpcmV0dXJuIHZvaWQgYy5kZWxheUxvYWQoKTtpZih0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlW2JdIT1jKXt0aGlzLl9hY3RpdmVUZXh0dXJlc0NhY2hlW2JdPWM7dmFyIGQ9Yy5nZXRJbnRlcm5hbFRleHR1cmUoKTtpZih0aGlzLl9nbC5hY3RpdmVUZXh0dXJlKHRoaXMuX2dsW1wiVEVYVFVSRVwiK2JdKSxkLmlzQ3ViZSl7aWYodGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCxkKSxkLl9jYWNoZWRDb29yZGluYXRlc01vZGUhPT1jLmNvb3JkaW5hdGVzTW9kZSl7ZC5fY2FjaGVkQ29vcmRpbmF0ZXNNb2RlPWMuY29vcmRpbmF0ZXNNb2RlO3ZhciBlPWMuY29vcmRpbmF0ZXNNb2RlIT09YS5UZXh0dXJlLkNVQklDX01PREUmJmMuY29vcmRpbmF0ZXNNb2RlIT09YS5UZXh0dXJlLlNLWUJPWF9NT0RFP3RoaXMuX2dsLlJFUEVBVDp0aGlzLl9nbC5DTEFNUF9UT19FREdFO3RoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV9DVUJFX01BUCx0aGlzLl9nbC5URVhUVVJFX1dSQVBfUyxlKSx0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfQ1VCRV9NQVAsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsZSl9dGhpcy5fc2V0QW5pc290cm9waWNMZXZlbCh0aGlzLl9nbC5URVhUVVJFX0NVQkVfTUFQLGMpfWVsc2V7aWYodGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCxkKSxkLl9jYWNoZWRXcmFwVSE9PWMud3JhcFUpc3dpdGNoKGQuX2NhY2hlZFdyYXBVPWMud3JhcFUsYy53cmFwVSl7Y2FzZSBhLlRleHR1cmUuV1JBUF9BRERSRVNTTU9ERTp0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsdGhpcy5fZ2wuUkVQRUFUKTticmVhaztjYXNlIGEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERTp0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsdGhpcy5fZ2wuQ0xBTVBfVE9fRURHRSk7YnJlYWs7Y2FzZSBhLlRleHR1cmUuTUlSUk9SX0FERFJFU1NNT0RFOnRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX1dSQVBfUyx0aGlzLl9nbC5NSVJST1JFRF9SRVBFQVQpfWlmKGQuX2NhY2hlZFdyYXBWIT09Yy53cmFwVilzd2l0Y2goZC5fY2FjaGVkV3JhcFY9Yy53cmFwVixjLndyYXBWKXtjYXNlIGEuVGV4dHVyZS5XUkFQX0FERFJFU1NNT0RFOnRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCx0aGlzLl9nbC5SRVBFQVQpO2JyZWFrO2Nhc2UgYS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFOnRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCx0aGlzLl9nbC5URVhUVVJFX1dSQVBfVCx0aGlzLl9nbC5DTEFNUF9UT19FREdFKTticmVhaztjYXNlIGEuVGV4dHVyZS5NSVJST1JfQUREUkVTU01PREU6dGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9ULHRoaXMuX2dsLk1JUlJPUkVEX1JFUEVBVClcbn10aGlzLl9zZXRBbmlzb3Ryb3BpY0xldmVsKHRoaXMuX2dsLlRFWFRVUkVfMkQsYyl9fX19LGgucHJvdG90eXBlLl9zZXRBbmlzb3Ryb3BpY0xldmVsPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5fY2Fwcy50ZXh0dXJlQW5pc290cm9waWNGaWx0ZXJFeHRlbnNpb247YyYmYi5fY2FjaGVkQW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCE9PWIuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCYmKHRoaXMuX2dsLnRleFBhcmFtZXRlcmYoYSxjLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULE1hdGgubWluKGIuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCx0aGlzLl9jYXBzLm1heEFuaXNvdHJvcHkpKSxiLl9jYWNoZWRBbmlzb3Ryb3BpY0ZpbHRlcmluZ0xldmVsPWIuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbCl9LGgucHJvdG90eXBlLnJlYWRQaXhlbHM9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoZCpjKjQpO3JldHVybiB0aGlzLl9nbC5yZWFkUGl4ZWxzKDAsMCxjLGQsdGhpcy5fZ2wuUkdCQSx0aGlzLl9nbC5VTlNJR05FRF9CWVRFLGUpLGV9LGgucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodGhpcy5zdG9wUmVuZGVyTG9vcCgpO3RoaXMuc2NlbmVzLmxlbmd0aDspdGhpcy5zY2VuZXNbMF0uZGlzcG9zZSgpO2Zvcih2YXIgYSBpbiB0aGlzLl9jb21waWxlZEVmZmVjdHMpdGhpcy5fZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLl9jb21waWxlZEVmZmVjdHNbYV0uX3Byb2dyYW0pO2Zvcih2YXIgYiBpbiB0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXMpYj50aGlzLl9nbC5WRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUR8fCF0aGlzLl92ZXJ0ZXhBdHRyaWJBcnJheXNbYl18fHRoaXMuX2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShiKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLl9vbkJsdXIpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl9vbkZvY3VzKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIix0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibXNmdWxsc2NyZWVuY2hhbmdlXCIsdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxvY2tjaGFuZ2VcIix0aGlzLl9vblBvaW50ZXJMb2NrQ2hhbmdlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibXNwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3pwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRwb2ludGVybG9ja2NoYW5nZVwiLHRoaXMuX29uUG9pbnRlckxvY2tDaGFuZ2UpfSxoLmlzU3VwcG9ydGVkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksYj1hLmdldENvbnRleHQoXCJ3ZWJnbFwiKXx8YS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpO3JldHVybiBudWxsIT1iJiYhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHR9Y2F0Y2goYyl7cmV0dXJuITF9fSxoLl9BTFBIQV9ESVNBQkxFPTAsaC5fQUxQSEFfQUREPTEsaC5fQUxQSEFfQ09NQklORT0yLGguX0RFTEFZTE9BRFNUQVRFX05PTkU9MCxoLl9ERUxBWUxPQURTVEFURV9MT0FERUQ9MSxoLl9ERUxBWUxPQURTVEFURV9MT0FESU5HPTIsaC5fREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEPTQsaC5FcHNpbG9uPS4wMDEsaC5Db2xsaXNpb25zRXBzaWxvbj0uMDAxLGguU2hhZGVyc1JlcG9zaXRvcnk9XCJCYWJ5bG9uL1NoYWRlcnMvXCIsaH0oKTthLkVuZ2luZT1ofShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiKXt0aGlzLnN0YXRlPVwiXCIsdGhpcy5hbmltYXRpb25zPW5ldyBBcnJheSx0aGlzLl9jaGlsZHJlbkZsYWc9LTEsdGhpcy5faXNFbmFibGVkPSEwLHRoaXMuX2lzUmVhZHk9ITAsdGhpcy5fY3VycmVudFJlbmRlcklkPS0xLHRoaXMubmFtZT1hLHRoaXMuaWQ9YSx0aGlzLl9zY2VuZT1iLHRoaXMuX2luaXRDYWNoZSgpfXJldHVybiBiLnByb3RvdHlwZS5nZXRTY2VuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY2VuZX0sYi5wcm90b3R5cGUuZ2V0RW5naW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpfSxiLnByb3RvdHlwZS5nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiBhLk1hdHJpeC5JZGVudGl0eSgpfSxiLnByb3RvdHlwZS5faW5pdENhY2hlPWZ1bmN0aW9uKCl7dGhpcy5fY2FjaGU9e30sdGhpcy5fY2FjaGUucGFyZW50PXZvaWQgMH0sYi5wcm90b3R5cGUudXBkYXRlQ2FjaGU9ZnVuY3Rpb24oYSl7KGF8fCF0aGlzLmlzU3luY2hyb25pemVkKCkpJiYodGhpcy5fY2FjaGUucGFyZW50PXRoaXMucGFyZW50LHRoaXMuX3VwZGF0ZUNhY2hlKCkpfSxiLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGU9ZnVuY3Rpb24oKXt9LGIucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZD1mdW5jdGlvbigpe3JldHVybiEwfSxiLnByb3RvdHlwZS5pc1N5bmNocm9uaXplZFdpdGhQYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQuX2N1cnJlbnRSZW5kZXJJZDw9dGhpcy5fY3VycmVudFJlbmRlcklkOiEwfSxiLnByb3RvdHlwZS5pc1N5bmNocm9uaXplZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmhhc05ld1BhcmVudCgpO3JldHVybiBiPWJ8fCF0aGlzLmlzU3luY2hyb25pemVkV2l0aFBhcmVudCgpLGI9Ynx8IXRoaXMuX2lzU3luY2hyb25pemVkKCksYSYmdGhpcy51cGRhdGVDYWNoZSghMCksIWJ9LGIucHJvdG90eXBlLmhhc05ld1BhcmVudD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fY2FjaGUucGFyZW50PT09dGhpcy5wYXJlbnQ/ITE6KGEmJih0aGlzLl9jYWNoZS5wYXJlbnQ9dGhpcy5wYXJlbnQpLCEwKX0sYi5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1JlYWR5fSxiLnByb3RvdHlwZS5pc0VuYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNFbmFibGVkP3RoaXMucGFyZW50P3RoaXMucGFyZW50LmlzRW5hYmxlZCgpOiEwOiExfSxiLnByb3RvdHlwZS5zZXRFbmFibGVkPWZ1bmN0aW9uKGEpe3RoaXMuX2lzRW5hYmxlZD1hfSxiLnByb3RvdHlwZS5pc0Rlc2NlbmRhbnRPZj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQ9PT1hPyEwOnRoaXMucGFyZW50LmlzRGVzY2VuZGFudE9mKGEpOiExfSxiLnByb3RvdHlwZS5fZ2V0RGVzY2VuZGFudHM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXTtkLmlzRGVzY2VuZGFudE9mKHRoaXMpJiZiLnB1c2goZCl9fSxiLnByb3RvdHlwZS5nZXREZXNjZW5kYW50cz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLl9nZXREZXNjZW5kYW50cyh0aGlzLl9zY2VuZS5tZXNoZXMsYSksdGhpcy5fZ2V0RGVzY2VuZGFudHModGhpcy5fc2NlbmUubGlnaHRzLGEpLHRoaXMuX2dldERlc2NlbmRhbnRzKHRoaXMuX3NjZW5lLmNhbWVyYXMsYSksYX0sYi5wcm90b3R5cGUuX3NldFJlYWR5PWZ1bmN0aW9uKGEpe2lmKGEhPXRoaXMuX2lzUmVhZHkpe2lmKCFhKXJldHVybiB2b2lkKHRoaXMuX2lzUmVhZHk9ITEpO3RoaXMuX2lzUmVhZHk9ITAsdGhpcy5vblJlYWR5JiZ0aGlzLm9uUmVhZHkodGhpcyl9fSxifSgpO2EuTm9kZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLm1pbmltdW09Yix0aGlzLm1heGltdW09Yyx0aGlzLl90ZW1wUmFkaXVzVmVjdG9yPWEuVmVjdG9yMy5aZXJvKCk7dmFyIGQ9YS5WZWN0b3IzLkRpc3RhbmNlKGIsYyk7dGhpcy5jZW50ZXI9YS5WZWN0b3IzLkxlcnAoYixjLC41KSx0aGlzLnJhZGl1cz0uNSpkLHRoaXMuY2VudGVyV29ybGQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl91cGRhdGUoYS5NYXRyaXguSWRlbnRpdHkoKSl9cmV0dXJuIGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oYil7YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodGhpcy5jZW50ZXIsYix0aGlzLmNlbnRlcldvcmxkKSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsRnJvbUZsb2F0c1RvUmVmKDEsMSwxLGIsdGhpcy5fdGVtcFJhZGl1c1ZlY3RvciksdGhpcy5yYWRpdXNXb3JsZD1NYXRoLm1heChNYXRoLmFicyh0aGlzLl90ZW1wUmFkaXVzVmVjdG9yLngpLE1hdGguYWJzKHRoaXMuX3RlbXBSYWRpdXNWZWN0b3IueSksTWF0aC5hYnModGhpcy5fdGVtcFJhZGl1c1ZlY3Rvci56KSkqdGhpcy5yYWRpdXN9LGIucHJvdG90eXBlLmlzSW5GcnVzdHVtPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wOzY+YjtiKyspaWYoYVtiXS5kb3RDb29yZGluYXRlKHRoaXMuY2VudGVyV29ybGQpPD0tdGhpcy5yYWRpdXNXb3JsZClyZXR1cm4hMTtyZXR1cm4hMH0sYi5wcm90b3R5cGUuaW50ZXJzZWN0c1BvaW50PWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuY2VudGVyV29ybGQueC1iLngsZD10aGlzLmNlbnRlcldvcmxkLnktYi55LGU9dGhpcy5jZW50ZXJXb3JsZC56LWIueixmPU1hdGguc3FydChjKmMrZCpkK2UqZSk7cmV0dXJuIE1hdGguYWJzKHRoaXMucmFkaXVzV29ybGQtZik8YS5FbmdpbmUuRXBzaWxvbj8hMTohMH0sYi5JbnRlcnNlY3RzPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jZW50ZXJXb3JsZC54LWIuY2VudGVyV29ybGQueCxkPWEuY2VudGVyV29ybGQueS1iLmNlbnRlcldvcmxkLnksZT1hLmNlbnRlcldvcmxkLnotYi5jZW50ZXJXb3JsZC56LGY9TWF0aC5zcXJ0KGMqYytkKmQrZSplKTtyZXR1cm4gYS5yYWRpdXNXb3JsZCtiLnJhZGl1c1dvcmxkPGY/ITE6ITB9LGJ9KCk7YS5Cb3VuZGluZ1NwaGVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjKXt0aGlzLm1pbmltdW09Yix0aGlzLm1heGltdW09Yyx0aGlzLnZlY3RvcnM9bmV3IEFycmF5LHRoaXMudmVjdG9yc1dvcmxkPW5ldyBBcnJheSx0aGlzLnZlY3RvcnMucHVzaCh0aGlzLm1pbmltdW0uY2xvbmUoKSksdGhpcy52ZWN0b3JzLnB1c2godGhpcy5tYXhpbXVtLmNsb25lKCkpLHRoaXMudmVjdG9ycy5wdXNoKHRoaXMubWluaW11bS5jbG9uZSgpKSx0aGlzLnZlY3RvcnNbMl0ueD10aGlzLm1heGltdW0ueCx0aGlzLnZlY3RvcnMucHVzaCh0aGlzLm1pbmltdW0uY2xvbmUoKSksdGhpcy52ZWN0b3JzWzNdLnk9dGhpcy5tYXhpbXVtLnksdGhpcy52ZWN0b3JzLnB1c2godGhpcy5taW5pbXVtLmNsb25lKCkpLHRoaXMudmVjdG9yc1s0XS56PXRoaXMubWF4aW11bS56LHRoaXMudmVjdG9ycy5wdXNoKHRoaXMubWF4aW11bS5jbG9uZSgpKSx0aGlzLnZlY3RvcnNbNV0uej10aGlzLm1pbmltdW0ueix0aGlzLnZlY3RvcnMucHVzaCh0aGlzLm1heGltdW0uY2xvbmUoKSksdGhpcy52ZWN0b3JzWzZdLng9dGhpcy5taW5pbXVtLngsdGhpcy52ZWN0b3JzLnB1c2godGhpcy5tYXhpbXVtLmNsb25lKCkpLHRoaXMudmVjdG9yc1s3XS55PXRoaXMubWluaW11bS55LHRoaXMuY2VudGVyPXRoaXMubWF4aW11bS5hZGQodGhpcy5taW5pbXVtKS5zY2FsZSguNSksdGhpcy5leHRlbmRzPXRoaXMubWF4aW11bS5zdWJ0cmFjdCh0aGlzLm1pbmltdW0pLnNjYWxlKC41KSx0aGlzLmRpcmVjdGlvbnM9W2EuVmVjdG9yMy5aZXJvKCksYS5WZWN0b3IzLlplcm8oKSxhLlZlY3RvcjMuWmVybygpXTtmb3IodmFyIGQ9MDtkPHRoaXMudmVjdG9ycy5sZW5ndGg7ZCsrKXRoaXMudmVjdG9yc1dvcmxkW2RdPWEuVmVjdG9yMy5aZXJvKCk7dGhpcy5taW5pbXVtV29ybGQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLm1heGltdW1Xb3JsZD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3VwZGF0ZShhLk1hdHJpeC5JZGVudGl0eSgpKX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh9LGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oYil7YS5WZWN0b3IzLkZyb21GbG9hdHNUb1JlZihOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSx0aGlzLm1pbmltdW1Xb3JsZCksYS5WZWN0b3IzLkZyb21GbG9hdHNUb1JlZigtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSx0aGlzLm1heGltdW1Xb3JsZCk7Zm9yKHZhciBjPTA7Yzx0aGlzLnZlY3RvcnMubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy52ZWN0b3JzV29ybGRbY107YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodGhpcy52ZWN0b3JzW2NdLGIsZCksZC54PHRoaXMubWluaW11bVdvcmxkLngmJih0aGlzLm1pbmltdW1Xb3JsZC54PWQueCksZC55PHRoaXMubWluaW11bVdvcmxkLnkmJih0aGlzLm1pbmltdW1Xb3JsZC55PWQueSksZC56PHRoaXMubWluaW11bVdvcmxkLnomJih0aGlzLm1pbmltdW1Xb3JsZC56PWQueiksZC54PnRoaXMubWF4aW11bVdvcmxkLngmJih0aGlzLm1heGltdW1Xb3JsZC54PWQueCksZC55PnRoaXMubWF4aW11bVdvcmxkLnkmJih0aGlzLm1heGltdW1Xb3JsZC55PWQueSksZC56PnRoaXMubWF4aW11bVdvcmxkLnomJih0aGlzLm1heGltdW1Xb3JsZC56PWQueil9dGhpcy5tYXhpbXVtV29ybGQuYWRkVG9SZWYodGhpcy5taW5pbXVtV29ybGQsdGhpcy5jZW50ZXIpLHRoaXMuY2VudGVyLnNjYWxlSW5QbGFjZSguNSksYS5WZWN0b3IzLkZyb21GbG9hdEFycmF5VG9SZWYoYi5tLDAsdGhpcy5kaXJlY3Rpb25zWzBdKSxhLlZlY3RvcjMuRnJvbUZsb2F0QXJyYXlUb1JlZihiLm0sNCx0aGlzLmRpcmVjdGlvbnNbMV0pLGEuVmVjdG9yMy5Gcm9tRmxvYXRBcnJheVRvUmVmKGIubSw4LHRoaXMuZGlyZWN0aW9uc1syXSksdGhpcy5fd29ybGRNYXRyaXg9Yn0sYi5wcm90b3R5cGUuaXNJbkZydXN0dW09ZnVuY3Rpb24oYSl7cmV0dXJuIGIuSXNJbkZydXN0dW0odGhpcy52ZWN0b3JzV29ybGQsYSl9LGIucHJvdG90eXBlLmludGVyc2VjdHNQb2ludD1mdW5jdGlvbihiKXt2YXIgYz1hLkVuZ2luZS5FcHNpbG9uO3JldHVybiB0aGlzLm1heGltdW1Xb3JsZC54LWIueDxjfHxjPmIueC10aGlzLm1pbmltdW1Xb3JsZC54PyExOnRoaXMubWF4aW11bVdvcmxkLnktYi55PGN8fGM+Yi55LXRoaXMubWluaW11bVdvcmxkLnk/ITE6dGhpcy5tYXhpbXVtV29ybGQuei1iLno8Y3x8Yz5iLnotdGhpcy5taW5pbXVtV29ybGQuej8hMTohMH0sYi5wcm90b3R5cGUuaW50ZXJzZWN0c1NwaGVyZT1mdW5jdGlvbihhKXtyZXR1cm4gYi5JbnRlcnNlY3RzU3BoZXJlKHRoaXMubWluaW11bVdvcmxkLHRoaXMubWF4aW11bVdvcmxkLGEuY2VudGVyV29ybGQsYS5yYWRpdXNXb3JsZCl9LGIucHJvdG90eXBlLmludGVyc2VjdHNNaW5NYXg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tYXhpbXVtV29ybGQueDxhLnh8fHRoaXMubWluaW11bVdvcmxkLng+Yi54PyExOnRoaXMubWF4aW11bVdvcmxkLnk8YS55fHx0aGlzLm1pbmltdW1Xb3JsZC55PmIueT8hMTp0aGlzLm1heGltdW1Xb3JsZC56PGEuenx8dGhpcy5taW5pbXVtV29ybGQuej5iLno/ITE6ITB9LGIuSW50ZXJzZWN0cz1mdW5jdGlvbihhLGIpe3JldHVybiBhLm1heGltdW1Xb3JsZC54PGIubWluaW11bVdvcmxkLnh8fGEubWluaW11bVdvcmxkLng+Yi5tYXhpbXVtV29ybGQueD8hMTphLm1heGltdW1Xb3JsZC55PGIubWluaW11bVdvcmxkLnl8fGEubWluaW11bVdvcmxkLnk+Yi5tYXhpbXVtV29ybGQueT8hMTphLm1heGltdW1Xb3JsZC56PGIubWluaW11bVdvcmxkLnp8fGEubWluaW11bVdvcmxkLno+Yi5tYXhpbXVtV29ybGQuej8hMTohMH0sYi5JbnRlcnNlY3RzU3BoZXJlPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWEuVmVjdG9yMy5DbGFtcChkLGIsYyksZz1hLlZlY3RvcjMuRGlzdGFuY2VTcXVhcmVkKGQsZik7cmV0dXJuIGUqZT49Z30sYi5Jc0luRnJ1c3R1bT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wOzY+YztjKyspe2Zvcih2YXIgZD04LGU9MDs4PmUmJmJbY10uZG90Q29vcmRpbmF0ZShhW2VdKTwwO2UrKyktLWQ7aWYoMD09ZClyZXR1cm4hMX1yZXR1cm4hMH0sYn0oKTthLkJvdW5kaW5nQm94PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5WZWN0b3IzLkRvdChjLmNlbnRlcixiKSxlPU1hdGguYWJzKGEuVmVjdG9yMy5Eb3QoYy5kaXJlY3Rpb25zWzBdLGIpKSpjLmV4dGVuZHMueCxmPU1hdGguYWJzKGEuVmVjdG9yMy5Eb3QoYy5kaXJlY3Rpb25zWzFdLGIpKSpjLmV4dGVuZHMueSxnPU1hdGguYWJzKGEuVmVjdG9yMy5Eb3QoYy5kaXJlY3Rpb25zWzJdLGIpKSpjLmV4dGVuZHMueixoPWUrZitnO3JldHVybnttaW46ZC1oLG1heDpkK2h9fSxjPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiEoYT5kfHxjPmIpfSxkPWZ1bmN0aW9uKGEsZCxlKXt2YXIgZj1iKGEsZCksZz1iKGEsZSk7cmV0dXJuIGMoZi5taW4sZi5tYXgsZy5taW4sZy5tYXgpfSxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMpe3RoaXMubWluaW11bT1iLHRoaXMubWF4aW11bT1jLHRoaXMuYm91bmRpbmdCb3g9bmV3IGEuQm91bmRpbmdCb3goYixjKSx0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBhLkJvdW5kaW5nU3BoZXJlKGIsYyl9cmV0dXJuIGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy5ib3VuZGluZ0JveC5fdXBkYXRlKGEpLHRoaXMuYm91bmRpbmdTcGhlcmUuX3VwZGF0ZShhKX0sYi5wcm90b3R5cGUuaXNJbkZydXN0dW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYm91bmRpbmdTcGhlcmUuaXNJbkZydXN0dW0oYSk/dGhpcy5ib3VuZGluZ0JveC5pc0luRnJ1c3R1bShhKTohMX0sYi5wcm90b3R5cGUuX2NoZWNrQ29sbGlzaW9uPWZ1bmN0aW9uKGEpe3JldHVybiBhLl9jYW5Eb0NvbGxpc2lvbih0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcldvcmxkLHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzV29ybGQsdGhpcy5ib3VuZGluZ0JveC5taW5pbXVtV29ybGQsdGhpcy5ib3VuZGluZ0JveC5tYXhpbXVtV29ybGQpfSxiLnByb3RvdHlwZS5pbnRlcnNlY3RzUG9pbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyV29ybGQmJnRoaXMuYm91bmRpbmdTcGhlcmUuaW50ZXJzZWN0c1BvaW50KGEpJiZ0aGlzLmJvdW5kaW5nQm94LmludGVyc2VjdHNQb2ludChhKT8hMDohMX0sYi5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbihiLGMpe2lmKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcldvcmxkfHwhYi5ib3VuZGluZ1NwaGVyZS5jZW50ZXJXb3JsZClyZXR1cm4hMTtpZighYS5Cb3VuZGluZ1NwaGVyZS5JbnRlcnNlY3RzKHRoaXMuYm91bmRpbmdTcGhlcmUsYi5ib3VuZGluZ1NwaGVyZSkpcmV0dXJuITE7aWYoIWEuQm91bmRpbmdCb3guSW50ZXJzZWN0cyh0aGlzLmJvdW5kaW5nQm94LGIuYm91bmRpbmdCb3gpKXJldHVybiExO2lmKCFjKXJldHVybiEwO3ZhciBlPXRoaXMuYm91bmRpbmdCb3gsZj1iLmJvdW5kaW5nQm94O3JldHVybiBkKGUuZGlyZWN0aW9uc1swXSxlLGYpJiZkKGUuZGlyZWN0aW9uc1sxXSxlLGYpJiZkKGUuZGlyZWN0aW9uc1syXSxlLGYpJiZkKGYuZGlyZWN0aW9uc1swXSxlLGYpJiZkKGYuZGlyZWN0aW9uc1sxXSxlLGYpJiZkKGYuZGlyZWN0aW9uc1syXSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMF0sZi5kaXJlY3Rpb25zWzBdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMF0sZi5kaXJlY3Rpb25zWzFdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMF0sZi5kaXJlY3Rpb25zWzJdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMV0sZi5kaXJlY3Rpb25zWzBdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMV0sZi5kaXJlY3Rpb25zWzFdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMV0sZi5kaXJlY3Rpb25zWzJdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMl0sZi5kaXJlY3Rpb25zWzBdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMl0sZi5kaXJlY3Rpb25zWzFdKSxlLGYpJiZkKGEuVmVjdG9yMy5Dcm9zcyhlLmRpcmVjdGlvbnNbMl0sZi5kaXJlY3Rpb25zWzJdKSxlLGYpPyEwOiExfSxifSgpO2EuQm91bmRpbmdJbmZvPWV9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7Yi5jYWxsKHRoaXMsYyxkKSx0aGlzLmRpZmZ1c2U9bmV3IGEuQ29sb3IzKDEsMSwxKSx0aGlzLnNwZWN1bGFyPW5ldyBhLkNvbG9yMygxLDEsMSksdGhpcy5pbnRlbnNpdHk9MSx0aGlzLnJhbmdlPU51bWJlci5NQVhfVkFMVUUsdGhpcy5leGNsdWRlZE1lc2hlcz1uZXcgQXJyYXksdGhpcy5fZXhjbHVkZWRNZXNoZXNJZHM9bmV3IEFycmF5LGQubGlnaHRzLnB1c2godGhpcyl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLmdldFNoYWRvd0dlbmVyYXRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zaGFkb3dHZW5lcmF0b3J9LGMucHJvdG90eXBlLnRyYW5zZmVyVG9FZmZlY3Q9ZnVuY3Rpb24oKXt9LGMucHJvdG90eXBlLl9nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiBhLk1hdHJpeC5JZGVudGl0eSgpfSxjLnByb3RvdHlwZS5nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3RoaXMuX2N1cnJlbnRSZW5kZXJJZD10aGlzLmdldFNjZW5lKCkuZ2V0UmVuZGVySWQoKTt2YXIgYj10aGlzLl9nZXRXb3JsZE1hdHJpeCgpO3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXg/KHRoaXMuX3BhcmVudGVkV29ybGRNYXRyaXh8fCh0aGlzLl9wYXJlbnRlZFdvcmxkTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpLGIubXVsdGlwbHlUb1JlZih0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLHRoaXMuX3BhcmVudGVkV29ybGRNYXRyaXgpLHRoaXMuX3BhcmVudGVkV29ybGRNYXRyaXgpOmJ9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9zaGFkb3dHZW5lcmF0b3ImJih0aGlzLl9zaGFkb3dHZW5lcmF0b3IuZGlzcG9zZSgpLHRoaXMuX3NoYWRvd0dlbmVyYXRvcj1udWxsKTt2YXIgYT10aGlzLmdldFNjZW5lKCkubGlnaHRzLmluZGV4T2YodGhpcyk7dGhpcy5nZXRTY2VuZSgpLmxpZ2h0cy5zcGxpY2UoYSwxKX0sY30oYS5Ob2RlKTthLkxpZ2h0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkKXtiLmNhbGwodGhpcyxhLGQpLHRoaXMucG9zaXRpb249Y31yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUudHJhbnNmZXJUb0VmZmVjdD1mdW5jdGlvbihiLGMpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXg/KHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb258fCh0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCkpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMucG9zaXRpb24sdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKSx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uKSx2b2lkIGIuc2V0RmxvYXQ0KGMsdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbi54LHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb24ueSx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uLnosMCkpOnZvaWQgYi5zZXRGbG9hdDQoYyx0aGlzLnBvc2l0aW9uLngsdGhpcy5wb3NpdGlvbi55LHRoaXMucG9zaXRpb24ueiwwKX0sYy5wcm90b3R5cGUuZ2V0U2hhZG93R2VuZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGMucHJvdG90eXBlLl9nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl93b3JsZE1hdHJpeHx8KHRoaXMuX3dvcmxkTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpLGEuTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYodGhpcy5wb3NpdGlvbi54LHRoaXMucG9zaXRpb24ueSx0aGlzLnBvc2l0aW9uLnosdGhpcy5fd29ybGRNYXRyaXgpLHRoaXMuX3dvcmxkTWF0cml4fSxjfShhLkxpZ2h0KTthLlBvaW50TGlnaHQ9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcpe2IuY2FsbCh0aGlzLGEsZyksdGhpcy5wb3NpdGlvbj1jLHRoaXMuZGlyZWN0aW9uPWQsdGhpcy5hbmdsZT1lLHRoaXMuZXhwb25lbnQ9Zn1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuc2V0RGlyZWN0aW9uVG9UYXJnZXQ9ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMuZGlyZWN0aW9uPWEuVmVjdG9yMy5Ob3JtYWxpemUoYi5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKSksdGhpcy5kaXJlY3Rpb259LGMucHJvdG90eXBlLnRyYW5zZmVyVG9FZmZlY3Q9ZnVuY3Rpb24oYixjLGQpe3ZhciBlO2lmKHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCl7dGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb258fCh0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbj1hLlZlY3RvcjMuWmVybygpKSx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9ufHwodGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpKTt2YXIgZj10aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpO2EuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMucG9zaXRpb24sZix0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uKSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYodGhpcy5kaXJlY3Rpb24sZix0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbiksYi5zZXRGbG9hdDQoYyx0aGlzLl90cmFuc2Zvcm1lZFBvc2l0aW9uLngsdGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbi55LHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb24ueix0aGlzLmV4cG9uZW50KSxlPWEuVmVjdG9yMy5Ob3JtYWxpemUodGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24pfWVsc2UgYi5zZXRGbG9hdDQoYyx0aGlzLnBvc2l0aW9uLngsdGhpcy5wb3NpdGlvbi55LHRoaXMucG9zaXRpb24ueix0aGlzLmV4cG9uZW50KSxlPWEuVmVjdG9yMy5Ob3JtYWxpemUodGhpcy5kaXJlY3Rpb24pO2Iuc2V0RmxvYXQ0KGQsZS54LGUueSxlLnosTWF0aC5jb3MoLjUqdGhpcy5hbmdsZSkpfSxjLnByb3RvdHlwZS5fZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh8fCh0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSxhLk1hdHJpeC5UcmFuc2xhdGlvblRvUmVmKHRoaXMucG9zaXRpb24ueCx0aGlzLnBvc2l0aW9uLnksdGhpcy5wb3NpdGlvbi56LHRoaXMuX3dvcmxkTWF0cml4KSx0aGlzLl93b3JsZE1hdHJpeH0sY30oYS5MaWdodCk7YS5TcG90TGlnaHQ9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQpe2IuY2FsbCh0aGlzLGEsZCksdGhpcy5kaXJlY3Rpb249Yyx0aGlzLnBvc2l0aW9uPWMuc2NhbGUoLTEpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Ub1RhcmdldD1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5kaXJlY3Rpb249YS5WZWN0b3IzLk5vcm1hbGl6ZShiLnN1YnRyYWN0KHRoaXMucG9zaXRpb24pKSx0aGlzLmRpcmVjdGlvbn0sYy5wcm90b3R5cGUuX2NvbXB1dGVUcmFuc2Zvcm1lZFBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeD8odGhpcy5fdHJhbnNmb3JtZWRQb3NpdGlvbnx8KHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSksYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodGhpcy5wb3NpdGlvbix0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCgpLHRoaXMuX3RyYW5zZm9ybWVkUG9zaXRpb24pLCEwKTohMX0sYy5wcm90b3R5cGUudHJhbnNmZXJUb0VmZmVjdD1mdW5jdGlvbihiLGMpe3JldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXg/KHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9ufHwodGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKHRoaXMuZGlyZWN0aW9uLHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCksdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24pLHZvaWQgYi5zZXRGbG9hdDQoYyx0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbi54LHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uLnksdGhpcy5fdHJhbnNmb3JtZWREaXJlY3Rpb24ueiwxKSk6dm9pZCBiLnNldEZsb2F0NChjLHRoaXMuZGlyZWN0aW9uLngsdGhpcy5kaXJlY3Rpb24ueSx0aGlzLmRpcmVjdGlvbi56LDEpfSxjLnByb3RvdHlwZS5fZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ybGRNYXRyaXh8fCh0aGlzLl93b3JsZE1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpKSxhLk1hdHJpeC5UcmFuc2xhdGlvblRvUmVmKHRoaXMucG9zaXRpb24ueCx0aGlzLnBvc2l0aW9uLnksdGhpcy5wb3NpdGlvbi56LHRoaXMuX3dvcmxkTWF0cml4KSx0aGlzLl93b3JsZE1hdHJpeH0sY30oYS5MaWdodCk7YS5EaXJlY3Rpb25hbExpZ2h0PWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihjLGQpe3ZhciBlPXRoaXM7dGhpcy5maWx0ZXI9Yi5GSUxURVJfVkFSSUFOQ0VTSEFET1dNQVAsdGhpcy5fZGFya25lc3M9MCx0aGlzLl90cmFuc3BhcmVuY3lTaGFkb3c9ITEsdGhpcy5fdmlld01hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fcHJvamVjdGlvbk1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fdHJhbnNmb3JtTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl93b3JsZFZpZXdQcm9qZWN0aW9uPWEuTWF0cml4Llplcm8oKSx0aGlzLl9saWdodD1kLHRoaXMuX3NjZW5lPWQuZ2V0U2NlbmUoKSxkLl9zaGFkb3dHZW5lcmF0b3I9dGhpcyx0aGlzLl9zaGFkb3dNYXA9bmV3IGEuUmVuZGVyVGFyZ2V0VGV4dHVyZShkLm5hbWUrXCJfc2hhZG93TWFwXCIsYyx0aGlzLl9zY2VuZSwhMSksdGhpcy5fc2hhZG93TWFwLndyYXBVPWEuVGV4dHVyZS5DTEFNUF9BRERSRVNTTU9ERSx0aGlzLl9zaGFkb3dNYXAud3JhcFY9YS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFLHRoaXMuX3NoYWRvd01hcC5yZW5kZXJQYXJ0aWNsZXM9ITE7dmFyIGY9ZnVuY3Rpb24oYil7dmFyIGM9Yi5nZXRSZW5kZXJpbmdNZXNoKCksZD1lLl9zY2VuZSxmPWQuZ2V0RW5naW5lKCk7Zi5zZXRTdGF0ZShiLmdldE1hdGVyaWFsKCkuYmFja0ZhY2VDdWxsaW5nKTt2YXIgZz1jLl9nZXRJbnN0YW5jZXNSZW5kZXJMaXN0KGIuX2lkKTtpZighZy5tdXN0UmV0dXJuKXt2YXIgaD1udWxsIT09Zi5nZXRDYXBzKCkuaW5zdGFuY2VkQXJyYXlzJiZudWxsIT09Zy52aXNpYmxlSW5zdGFuY2VzO2lmKGUuaXNSZWFkeShiLGgpKXtmLmVuYWJsZUVmZmVjdChlLl9lZmZlY3QpLGMuX2JpbmQoYixlLl9lZmZlY3QsITEpO3ZhciBpPWIuZ2V0TWF0ZXJpYWwoKTtpZihlLl9lZmZlY3Quc2V0TWF0cml4KFwidmlld1Byb2plY3Rpb25cIixlLmdldFRyYW5zZm9ybU1hdHJpeCgpKSxpJiZpLm5lZWRBbHBoYVRlc3RpbmcoKSl7dmFyIGo9aS5nZXRBbHBoYVRlc3RUZXh0dXJlKCk7ZS5fZWZmZWN0LnNldFRleHR1cmUoXCJkaWZmdXNlU2FtcGxlclwiLGopLGUuX2VmZmVjdC5zZXRNYXRyaXgoXCJkaWZmdXNlTWF0cml4XCIsai5nZXRUZXh0dXJlTWF0cml4KCkpfXZhciBrPWMuc2tlbGV0b24mJmMuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpJiZjLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKTtpZihrJiZlLl9lZmZlY3Quc2V0TWF0cmljZXMoXCJtQm9uZXNcIixjLnNrZWxldG9uLmdldFRyYW5zZm9ybU1hdHJpY2VzKCkpLGgpYy5fcmVuZGVyV2l0aEluc3RhbmNlcyhiLCExLGcsZS5fZWZmZWN0LGYpO2Vsc2UgaWYoZy5yZW5kZXJTZWxmW2IuX2lkXSYmKGUuX2VmZmVjdC5zZXRNYXRyaXgoXCJ3b3JsZFwiLGMuZ2V0V29ybGRNYXRyaXgoKSksYy5fZHJhdyhiLCEwKSksZy52aXNpYmxlSW5zdGFuY2VzW2IuX2lkXSlmb3IodmFyIGw9MDtsPGcudmlzaWJsZUluc3RhbmNlc1tiLl9pZF0ubGVuZ3RoO2wrKyl7dmFyIG09Zy52aXNpYmxlSW5zdGFuY2VzW2IuX2lkXVtsXTtlLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRcIixtLmdldFdvcmxkTWF0cml4KCkpLGMuX2RyYXcoYiwhMCl9fWVsc2UgZS5fc2hhZG93TWFwLnJlc2V0UmVmcmVzaENvdW50ZXIoKX19O3RoaXMuX3NoYWRvd01hcC5jdXN0b21SZW5kZXJGdW5jdGlvbj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7Zm9yKGQ9MDtkPGEubGVuZ3RoO2QrKylmKGEuZGF0YVtkXSk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylmKGIuZGF0YVtkXSk7aWYoZS5fdHJhbnNwYXJlbmN5U2hhZG93KWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspZihjLmRhdGFbZF0pfX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJGSUxURVJfTk9ORVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fRklMVEVSX05PTkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJGSUxURVJfVkFSSUFOQ0VTSEFET1dNQVBcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0ZJTFRFUl9WQVJJQU5DRVNIQURPV01BUH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkZJTFRFUl9QT0lTU09OU0FNUExJTkdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0ZJTFRFUl9QT0lTU09OU0FNUExJTkd9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwidXNlVmFyaWFuY2VTaGFkb3dNYXBcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyPT09Yi5GSUxURVJfVkFSSUFOQ0VTSEFET1dNQVB9LHNldDpmdW5jdGlvbihhKXt0aGlzLmZpbHRlcj1hP2IuRklMVEVSX1ZBUklBTkNFU0hBRE9XTUFQOmIuRklMVEVSX05PTkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwidXNlUG9pc3NvblNhbXBsaW5nXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbHRlcj09PWIuRklMVEVSX1BPSVNTT05TQU1QTElOR30sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuZmlsdGVyPWE/Yi5GSUxURVJfUE9JU1NPTlNBTVBMSU5HOmIuRklMVEVSX05PTkV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbihiLGMpe3ZhciBkPVtdO3RoaXMudXNlVmFyaWFuY2VTaGFkb3dNYXAmJmQucHVzaChcIiNkZWZpbmUgVlNNXCIpO3ZhciBlPVthLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmRdLGY9Yi5nZXRNZXNoKCksZz1iLmdldE1hdGVyaWFsKCk7ZyYmZy5uZWVkQWxwaGFUZXN0aW5nKCkmJihkLnB1c2goXCIjZGVmaW5lIEFMUEhBVEVTVFwiKSxmLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVktpbmQpJiYoZS5wdXNoKGEuVmVydGV4QnVmZmVyLlVWS2luZCksZC5wdXNoKFwiI2RlZmluZSBVVjFcIikpLGYuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLlVWMktpbmQpJiYoZS5wdXNoKGEuVmVydGV4QnVmZmVyLlVWMktpbmQpLGQucHVzaChcIiNkZWZpbmUgVVYyXCIpKSksZi5za2VsZXRvbiYmZi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCkmJmYuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpJiYoZS5wdXNoKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpLGUucHVzaChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSxkLnB1c2goXCIjZGVmaW5lIEJPTkVTXCIpLGQucHVzaChcIiNkZWZpbmUgQm9uZXNQZXJNZXNoIFwiKyhmLnNrZWxldG9uLmJvbmVzLmxlbmd0aCsxKSkpLGMmJihkLnB1c2goXCIjZGVmaW5lIElOU1RBTkNFU1wiKSxlLnB1c2goXCJ3b3JsZDBcIiksZS5wdXNoKFwid29ybGQxXCIpLGUucHVzaChcIndvcmxkMlwiKSxlLnB1c2goXCJ3b3JsZDNcIikpO3ZhciBoPWQuam9pbihcIlxcblwiKTtyZXR1cm4gdGhpcy5fY2FjaGVkRGVmaW5lcyE9aCYmKHRoaXMuX2NhY2hlZERlZmluZXM9aCx0aGlzLl9lZmZlY3Q9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlRWZmZWN0KFwic2hhZG93TWFwXCIsZSxbXCJ3b3JsZFwiLFwibUJvbmVzXCIsXCJ2aWV3UHJvamVjdGlvblwiLFwiZGlmZnVzZU1hdHJpeFwiXSxbXCJkaWZmdXNlU2FtcGxlclwiXSxoKSksdGhpcy5fZWZmZWN0LmlzUmVhZHkoKX0sYi5wcm90b3R5cGUuZ2V0U2hhZG93TWFwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NoYWRvd01hcH0sYi5wcm90b3R5cGUuZ2V0TGlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGlnaHR9LGIucHJvdG90eXBlLmdldFRyYW5zZm9ybU1hdHJpeD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuX2xpZ2h0LnBvc2l0aW9uLGM9dGhpcy5fbGlnaHQuZGlyZWN0aW9uO2lmKHRoaXMuX2xpZ2h0Ll9jb21wdXRlVHJhbnNmb3JtZWRQb3NpdGlvbigpJiYoYj10aGlzLl9saWdodC5fdHJhbnNmb3JtZWRQb3NpdGlvbiksISh0aGlzLl9jYWNoZWRQb3NpdGlvbiYmdGhpcy5fY2FjaGVkRGlyZWN0aW9uJiZiLmVxdWFscyh0aGlzLl9jYWNoZWRQb3NpdGlvbikmJmMuZXF1YWxzKHRoaXMuX2NhY2hlZERpcmVjdGlvbikpKXt0aGlzLl9jYWNoZWRQb3NpdGlvbj1iLmNsb25lKCksdGhpcy5fY2FjaGVkRGlyZWN0aW9uPWMuY2xvbmUoKTt2YXIgZD10aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmE7YS5NYXRyaXguTG9va0F0TEhUb1JlZihiLHRoaXMuX2xpZ2h0LnBvc2l0aW9uLmFkZChjKSxhLlZlY3RvcjMuVXAoKSx0aGlzLl92aWV3TWF0cml4KSxhLk1hdHJpeC5QZXJzcGVjdGl2ZUZvdkxIVG9SZWYoTWF0aC5QSS8yLDEsZC5taW5aLGQubWF4Wix0aGlzLl9wcm9qZWN0aW9uTWF0cml4KSx0aGlzLl92aWV3TWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5fcHJvamVjdGlvbk1hdHJpeCx0aGlzLl90cmFuc2Zvcm1NYXRyaXgpfXJldHVybiB0aGlzLl90cmFuc2Zvcm1NYXRyaXh9LGIucHJvdG90eXBlLmdldERhcmtuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhcmtuZXNzfSxiLnByb3RvdHlwZS5zZXREYXJrbmVzcz1mdW5jdGlvbihhKXthPj0xP3RoaXMuX2RhcmtuZXNzPTE6MD49YSYmKHRoaXMuX2RhcmtuZXNzPTApLGVsc2V0aGlzLl9kYXJrbmVzcz1hfSxiLnByb3RvdHlwZS5zZXRUcmFuc3BhcmVuY3lTaGFkb3c9ZnVuY3Rpb24oYSl7dGhpcy5fdHJhbnNwYXJlbmN5U2hhZG93PWF9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9zaGFkb3dNYXAuZGlzcG9zZSgpfSxiLl9GSUxURVJfTk9ORT0wLGIuX0ZJTFRFUl9WQVJJQU5DRVNIQURPV01BUD0xLGIuX0ZJTFRFUl9QT0lTU09OU0FNUExJTkc9MixifSgpO2EuU2hhZG93R2VuZXJhdG9yPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlKXtiLmNhbGwodGhpcyxjLGUpLHRoaXMuZGlyZWN0aW9uPWQsdGhpcy5ncm91bmRDb2xvcj1uZXcgYS5Db2xvcjMoMCwwLDApfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Ub1RhcmdldD1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5kaXJlY3Rpb249YS5WZWN0b3IzLk5vcm1hbGl6ZShiLnN1YnRyYWN0KGEuVmVjdG9yMy5aZXJvKCkpKSx0aGlzLmRpcmVjdGlvbn0sYy5wcm90b3R5cGUuZ2V0U2hhZG93R2VuZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGMucHJvdG90eXBlLnRyYW5zZmVyVG9FZmZlY3Q9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuVmVjdG9yMy5Ob3JtYWxpemUodGhpcy5kaXJlY3Rpb24pO2Iuc2V0RmxvYXQ0KGMsZS54LGUueSxlLnosMCksYi5zZXRDb2xvcjMoZCx0aGlzLmdyb3VuZENvbG9yLnNjYWxlKHRoaXMuaW50ZW5zaXR5KSl9LGMucHJvdG90eXBlLl9nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl93b3JsZE1hdHJpeHx8KHRoaXMuX3dvcmxkTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpLHRoaXMuX3dvcmxkTWF0cml4fSxjfShhLkxpZ2h0KTthLkhlbWlzcGhlcmljTGlnaHQ9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGEueD5jLngrZD8hMTpjLngtZD5iLng/ITE6YS55PmMueStkPyExOmMueS1kPmIueT8hMTphLno+Yy56K2Q/ITE6Yy56LWQ+Yi56PyExOiEwfSxjPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWIqYi00KmEqYyxmPXtyb290OjAsZm91bmQ6ITF9O2lmKDA+ZSlyZXR1cm4gZjt2YXIgZz1NYXRoLnNxcnQoZSksaD0oLWItZykvKDIqYSksaT0oLWIrZykvKDIqYSk7aWYoaD5pKXt2YXIgaj1pO2k9aCxoPWp9cmV0dXJuIGg+MCYmZD5oPyhmLnJvb3Q9aCxmLmZvdW5kPSEwLGYpOmk+MCYmZD5pPyhmLnJvb3Q9aSxmLmZvdW5kPSEwLGYpOmZ9LGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7dGhpcy5yYWRpdXM9bmV3IGEuVmVjdG9yMygxLDEsMSksdGhpcy5yZXRyeT0wLHRoaXMuYmFzZVBvaW50V29ybGQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLnZlbG9jaXR5V29ybGQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLm5vcm1hbGl6ZWRWZWxvY2l0eT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NvbGxpc2lvblBvaW50PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fcGxhbmVJbnRlcnNlY3Rpb25Qb2ludD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3RlbXBWZWN0b3I9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90ZW1wVmVjdG9yMj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3RlbXBWZWN0b3IzPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdGVtcFZlY3RvcjQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9lZGdlPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fYmFzZVRvVmVydGV4PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fZGVzdGluYXRpb25Qb2ludD1hLlZlY3RvcjMuWmVybygpLHRoaXMuX3NsaWRlUGxhbmVOb3JtYWw9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9kaXNwbGFjZW1lbnRWZWN0b3I9YS5WZWN0b3IzLlplcm8oKX1yZXR1cm4gZC5wcm90b3R5cGUuX2luaXRpYWxpemU9ZnVuY3Rpb24oYixjLGQpe3RoaXMudmVsb2NpdHk9YyxhLlZlY3RvcjMuTm9ybWFsaXplVG9SZWYoYyx0aGlzLm5vcm1hbGl6ZWRWZWxvY2l0eSksdGhpcy5iYXNlUG9pbnQ9YixiLm11bHRpcGx5VG9SZWYodGhpcy5yYWRpdXMsdGhpcy5iYXNlUG9pbnRXb3JsZCksYy5tdWx0aXBseVRvUmVmKHRoaXMucmFkaXVzLHRoaXMudmVsb2NpdHlXb3JsZCksdGhpcy52ZWxvY2l0eVdvcmxkTGVuZ3RoPXRoaXMudmVsb2NpdHlXb3JsZC5sZW5ndGgoKSx0aGlzLmVwc2lsb249ZCx0aGlzLmNvbGxpc2lvbkZvdW5kPSExfSxkLnByb3RvdHlwZS5fY2hlY2tQb2ludEluVHJpYW5nbGU9ZnVuY3Rpb24oYixjLGQsZSxmKXtjLnN1YnRyYWN0VG9SZWYoYix0aGlzLl90ZW1wVmVjdG9yKSxkLnN1YnRyYWN0VG9SZWYoYix0aGlzLl90ZW1wVmVjdG9yMiksYS5WZWN0b3IzLkNyb3NzVG9SZWYodGhpcy5fdGVtcFZlY3Rvcix0aGlzLl90ZW1wVmVjdG9yMix0aGlzLl90ZW1wVmVjdG9yNCk7dmFyIGc9YS5WZWN0b3IzLkRvdCh0aGlzLl90ZW1wVmVjdG9yNCxmKTtyZXR1cm4gMD5nPyExOihlLnN1YnRyYWN0VG9SZWYoYix0aGlzLl90ZW1wVmVjdG9yMyksYS5WZWN0b3IzLkNyb3NzVG9SZWYodGhpcy5fdGVtcFZlY3RvcjIsdGhpcy5fdGVtcFZlY3RvcjMsdGhpcy5fdGVtcFZlY3RvcjQpLGc9YS5WZWN0b3IzLkRvdCh0aGlzLl90ZW1wVmVjdG9yNCxmKSwwPmc/ITE6KGEuVmVjdG9yMy5Dcm9zc1RvUmVmKHRoaXMuX3RlbXBWZWN0b3IzLHRoaXMuX3RlbXBWZWN0b3IsdGhpcy5fdGVtcFZlY3RvcjQpLGc9YS5WZWN0b3IzLkRvdCh0aGlzLl90ZW1wVmVjdG9yNCxmKSxnPj0wKSl9LGQucHJvdG90eXBlLl9jYW5Eb0NvbGxpc2lvbj1mdW5jdGlvbihjLGQsZSxmKXt2YXIgZz1hLlZlY3RvcjMuRGlzdGFuY2UodGhpcy5iYXNlUG9pbnRXb3JsZCxjKSxoPU1hdGgubWF4KHRoaXMucmFkaXVzLngsdGhpcy5yYWRpdXMueSx0aGlzLnJhZGl1cy56KTtyZXR1cm4gZz50aGlzLnZlbG9jaXR5V29ybGRMZW5ndGgraCtkPyExOmIoZSxmLHRoaXMuYmFzZVBvaW50V29ybGQsdGhpcy52ZWxvY2l0eVdvcmxkTGVuZ3RoK2gpPyEwOiExfSxkLnByb3RvdHlwZS5fdGVzdFRyaWFuZ2xlPWZ1bmN0aW9uKGIsZCxlLGYsZyl7dmFyIGgsaT0hMTtkLl90cmlhbmdsZVBsYW5lc3x8KGQuX3RyaWFuZ2xlUGxhbmVzPVtdKSxkLl90cmlhbmdsZVBsYW5lc1tiXXx8KGQuX3RyaWFuZ2xlUGxhbmVzW2JdPW5ldyBhLlBsYW5lKDAsMCwwLDApLGQuX3RyaWFuZ2xlUGxhbmVzW2JdLmNvcHlGcm9tUG9pbnRzKGUsZixnKSk7dmFyIGo9ZC5fdHJpYW5nbGVQbGFuZXNbYl07aWYoZC5nZXRNYXRlcmlhbCgpfHxqLmlzRnJvbnRGYWNpbmdUbyh0aGlzLm5vcm1hbGl6ZWRWZWxvY2l0eSwwKSl7dmFyIGs9ai5zaWduZWREaXN0YW5jZVRvKHRoaXMuYmFzZVBvaW50KSxsPWEuVmVjdG9yMy5Eb3Qoai5ub3JtYWwsdGhpcy52ZWxvY2l0eSk7aWYoMD09bCl7aWYoTWF0aC5hYnMoayk+PTEpcmV0dXJuO2k9ITAsaD0wfWVsc2V7aD0oLTEtaykvbDt2YXIgbT0oMS1rKS9sO2lmKGg+bSl7dmFyIG49bTttPWgsaD1ufWlmKGg+MXx8MD5tKXJldHVybjswPmgmJihoPTApLGg+MSYmKGg9MSl9dGhpcy5fY29sbGlzaW9uUG9pbnQuY29weUZyb21GbG9hdHMoMCwwLDApO3ZhciBvPSExLHA9MTtpZihpfHwodGhpcy5iYXNlUG9pbnQuc3VidHJhY3RUb1JlZihqLm5vcm1hbCx0aGlzLl9wbGFuZUludGVyc2VjdGlvblBvaW50KSx0aGlzLnZlbG9jaXR5LnNjYWxlVG9SZWYoaCx0aGlzLl90ZW1wVmVjdG9yKSx0aGlzLl9wbGFuZUludGVyc2VjdGlvblBvaW50LmFkZEluUGxhY2UodGhpcy5fdGVtcFZlY3RvciksdGhpcy5fY2hlY2tQb2ludEluVHJpYW5nbGUodGhpcy5fcGxhbmVJbnRlcnNlY3Rpb25Qb2ludCxlLGYsZyxqLm5vcm1hbCkmJihvPSEwLHA9aCx0aGlzLl9jb2xsaXNpb25Qb2ludC5jb3B5RnJvbSh0aGlzLl9wbGFuZUludGVyc2VjdGlvblBvaW50KSkpLCFvKXt2YXIgcT10aGlzLnZlbG9jaXR5Lmxlbmd0aFNxdWFyZWQoKSxyPXE7dGhpcy5iYXNlUG9pbnQuc3VidHJhY3RUb1JlZihlLHRoaXMuX3RlbXBWZWN0b3IpO3ZhciBzPTIqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX3RlbXBWZWN0b3IpLHQ9dGhpcy5fdGVtcFZlY3Rvci5sZW5ndGhTcXVhcmVkKCktMSx1PWMocixzLHQscCk7dS5mb3VuZCYmKHA9dS5yb290LG89ITAsdGhpcy5fY29sbGlzaW9uUG9pbnQuY29weUZyb20oZSkpLHRoaXMuYmFzZVBvaW50LnN1YnRyYWN0VG9SZWYoZix0aGlzLl90ZW1wVmVjdG9yKSxzPTIqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX3RlbXBWZWN0b3IpLHQ9dGhpcy5fdGVtcFZlY3Rvci5sZW5ndGhTcXVhcmVkKCktMSx1PWMocixzLHQscCksdS5mb3VuZCYmKHA9dS5yb290LG89ITAsdGhpcy5fY29sbGlzaW9uUG9pbnQuY29weUZyb20oZikpLHRoaXMuYmFzZVBvaW50LnN1YnRyYWN0VG9SZWYoZyx0aGlzLl90ZW1wVmVjdG9yKSxzPTIqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX3RlbXBWZWN0b3IpLHQ9dGhpcy5fdGVtcFZlY3Rvci5sZW5ndGhTcXVhcmVkKCktMSx1PWMocixzLHQscCksdS5mb3VuZCYmKHA9dS5yb290LG89ITAsdGhpcy5fY29sbGlzaW9uUG9pbnQuY29weUZyb20oZykpLGYuc3VidHJhY3RUb1JlZihlLHRoaXMuX2VkZ2UpLGUuc3VidHJhY3RUb1JlZih0aGlzLmJhc2VQb2ludCx0aGlzLl9iYXNlVG9WZXJ0ZXgpO3ZhciB2PXRoaXMuX2VkZ2UubGVuZ3RoU3F1YXJlZCgpLHc9YS5WZWN0b3IzLkRvdCh0aGlzLl9lZGdlLHRoaXMudmVsb2NpdHkpLHg9YS5WZWN0b3IzLkRvdCh0aGlzLl9lZGdlLHRoaXMuX2Jhc2VUb1ZlcnRleCk7aWYocj12Ki1xK3cqdyxzPTIqdiphLlZlY3RvcjMuRG90KHRoaXMudmVsb2NpdHksdGhpcy5fYmFzZVRvVmVydGV4KS0yKncqeCx0PXYqKDEtdGhpcy5fYmFzZVRvVmVydGV4Lmxlbmd0aFNxdWFyZWQoKSkreCp4LHU9YyhyLHMsdCxwKSx1LmZvdW5kKXt2YXIgeT0odyp1LnJvb3QteCkvdjt5Pj0wJiYxPj15JiYocD11LnJvb3Qsbz0hMCx0aGlzLl9lZGdlLnNjYWxlSW5QbGFjZSh5KSxlLmFkZFRvUmVmKHRoaXMuX2VkZ2UsdGhpcy5fY29sbGlzaW9uUG9pbnQpKX1nLnN1YnRyYWN0VG9SZWYoZix0aGlzLl9lZGdlKSxmLnN1YnRyYWN0VG9SZWYodGhpcy5iYXNlUG9pbnQsdGhpcy5fYmFzZVRvVmVydGV4KSx2PXRoaXMuX2VkZ2UubGVuZ3RoU3F1YXJlZCgpLHc9YS5WZWN0b3IzLkRvdCh0aGlzLl9lZGdlLHRoaXMudmVsb2NpdHkpLHg9YS5WZWN0b3IzLkRvdCh0aGlzLl9lZGdlLHRoaXMuX2Jhc2VUb1ZlcnRleCkscj12Ki1xK3cqdyxzPTIqdiphLlZlY3RvcjMuRG90KHRoaXMudmVsb2NpdHksdGhpcy5fYmFzZVRvVmVydGV4KS0yKncqeCx0PXYqKDEtdGhpcy5fYmFzZVRvVmVydGV4Lmxlbmd0aFNxdWFyZWQoKSkreCp4LHU9YyhyLHMsdCxwKSx1LmZvdW5kJiYoeT0odyp1LnJvb3QteCkvdix5Pj0wJiYxPj15JiYocD11LnJvb3Qsbz0hMCx0aGlzLl9lZGdlLnNjYWxlSW5QbGFjZSh5KSxmLmFkZFRvUmVmKHRoaXMuX2VkZ2UsdGhpcy5fY29sbGlzaW9uUG9pbnQpKSksZS5zdWJ0cmFjdFRvUmVmKGcsdGhpcy5fZWRnZSksZy5zdWJ0cmFjdFRvUmVmKHRoaXMuYmFzZVBvaW50LHRoaXMuX2Jhc2VUb1ZlcnRleCksdj10aGlzLl9lZGdlLmxlbmd0aFNxdWFyZWQoKSx3PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLnZlbG9jaXR5KSx4PWEuVmVjdG9yMy5Eb3QodGhpcy5fZWRnZSx0aGlzLl9iYXNlVG9WZXJ0ZXgpLHI9diotcSt3Kncscz0yKnYqYS5WZWN0b3IzLkRvdCh0aGlzLnZlbG9jaXR5LHRoaXMuX2Jhc2VUb1ZlcnRleCktMip3KngsdD12KigxLXRoaXMuX2Jhc2VUb1ZlcnRleC5sZW5ndGhTcXVhcmVkKCkpK3gqeCx1PWMocixzLHQscCksdS5mb3VuZCYmKHk9KHcqdS5yb290LXgpL3YseT49MCYmMT49eSYmKHA9dS5yb290LG89ITAsdGhpcy5fZWRnZS5zY2FsZUluUGxhY2UoeSksZy5hZGRUb1JlZih0aGlzLl9lZGdlLHRoaXMuX2NvbGxpc2lvblBvaW50KSkpfWlmKG8pe3ZhciB6PXAqdGhpcy52ZWxvY2l0eS5sZW5ndGgoKTsoIXRoaXMuY29sbGlzaW9uRm91bmR8fHo8dGhpcy5uZWFyZXN0RGlzdGFuY2UpJiYodGhpcy5pbnRlcnNlY3Rpb25Qb2ludD90aGlzLmludGVyc2VjdGlvblBvaW50LmNvcHlGcm9tKHRoaXMuX2NvbGxpc2lvblBvaW50KTp0aGlzLmludGVyc2VjdGlvblBvaW50PXRoaXMuX2NvbGxpc2lvblBvaW50LmNsb25lKCksdGhpcy5uZWFyZXN0RGlzdGFuY2U9eix0aGlzLmNvbGxpc2lvbkZvdW5kPSEwLHRoaXMuY29sbGlkZWRNZXNoPWQuZ2V0TWVzaCgpKX19fSxkLnByb3RvdHlwZS5fY29sbGlkZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7Zm9yKHZhciBnPWQ7ZT5nO2crPTMpe3ZhciBoPWJbY1tnXS1mXSxpPWJbY1tnKzFdLWZdLGo9YltjW2crMl0tZl07dGhpcy5fdGVzdFRyaWFuZ2xlKGcsYSxqLGksaCl9fSxkLnByb3RvdHlwZS5fZ2V0UmVzcG9uc2U9ZnVuY3Rpb24oYixjKXtiLmFkZFRvUmVmKGMsdGhpcy5fZGVzdGluYXRpb25Qb2ludCksYy5zY2FsZUluUGxhY2UodGhpcy5uZWFyZXN0RGlzdGFuY2UvYy5sZW5ndGgoKSksdGhpcy5iYXNlUG9pbnQuYWRkVG9SZWYoYyxiKSxiLnN1YnRyYWN0VG9SZWYodGhpcy5pbnRlcnNlY3Rpb25Qb2ludCx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsKSx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsLm5vcm1hbGl6ZSgpLHRoaXMuX3NsaWRlUGxhbmVOb3JtYWwuc2NhbGVUb1JlZih0aGlzLmVwc2lsb24sdGhpcy5fZGlzcGxhY2VtZW50VmVjdG9yKSxiLmFkZEluUGxhY2UodGhpcy5fZGlzcGxhY2VtZW50VmVjdG9yKSx0aGlzLmludGVyc2VjdGlvblBvaW50LmFkZEluUGxhY2UodGhpcy5fZGlzcGxhY2VtZW50VmVjdG9yKSx0aGlzLl9zbGlkZVBsYW5lTm9ybWFsLnNjYWxlSW5QbGFjZShhLlBsYW5lLlNpZ25lZERpc3RhbmNlVG9QbGFuZUZyb21Qb3NpdGlvbkFuZE5vcm1hbCh0aGlzLmludGVyc2VjdGlvblBvaW50LHRoaXMuX3NsaWRlUGxhbmVOb3JtYWwsdGhpcy5fZGVzdGluYXRpb25Qb2ludCkpLHRoaXMuX2Rlc3RpbmF0aW9uUG9pbnQuc3VidHJhY3RJblBsYWNlKHRoaXMuX3NsaWRlUGxhbmVOb3JtYWwpLHRoaXMuX2Rlc3RpbmF0aW9uUG9pbnQuc3VidHJhY3RUb1JlZih0aGlzLmludGVyc2VjdGlvblBvaW50LGMpfSxkfSgpO2EuQ29sbGlkZXI9ZH0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoZCxlLGYpe2IuY2FsbCh0aGlzLGQsZiksdGhpcy5wb3NpdGlvbj1lLHRoaXMudXBWZWN0b3I9YS5WZWN0b3IzLlVwKCksdGhpcy5vcnRob0xlZnQ9bnVsbCx0aGlzLm9ydGhvUmlnaHQ9bnVsbCx0aGlzLm9ydGhvQm90dG9tPW51bGwsdGhpcy5vcnRob1RvcD1udWxsLHRoaXMuZm92PS44LHRoaXMubWluWj0uMSx0aGlzLm1heFo9MWUzLHRoaXMuaW5lcnRpYT0uOSx0aGlzLm1vZGU9Yy5QRVJTUEVDVElWRV9DQU1FUkEsdGhpcy5pc0ludGVybWVkaWF0ZT0hMSx0aGlzLnZpZXdwb3J0PW5ldyBhLlZpZXdwb3J0KDAsMCwxLDEpLHRoaXMuc3ViQ2FtZXJhcz1bXSx0aGlzLmxheWVyTWFzaz00Mjk0OTY3Mjk1LHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuX3Bvc3RQcm9jZXNzZXM9bmV3IEFycmF5LHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXM9W10sZi5jYW1lcmFzLnB1c2godGhpcyksZi5hY3RpdmVDYW1lcmF8fChmLmFjdGl2ZUNhbWVyYT10aGlzKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX2luaXRDYWNoZT1mdW5jdGlvbigpe2IucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKSx0aGlzLl9jYWNoZS5wb3NpdGlvbj1uZXcgYS5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSx0aGlzLl9jYWNoZS51cFZlY3Rvcj1uZXcgYS5WZWN0b3IzKE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFKSx0aGlzLl9jYWNoZS5tb2RlPXZvaWQgMCx0aGlzLl9jYWNoZS5taW5aPXZvaWQgMCx0aGlzLl9jYWNoZS5tYXhaPXZvaWQgMCx0aGlzLl9jYWNoZS5mb3Y9dm9pZCAwLHRoaXMuX2NhY2hlLmFzcGVjdFJhdGlvPXZvaWQgMCx0aGlzLl9jYWNoZS5vcnRob0xlZnQ9dm9pZCAwLHRoaXMuX2NhY2hlLm9ydGhvUmlnaHQ9dm9pZCAwLHRoaXMuX2NhY2hlLm9ydGhvQm90dG9tPXZvaWQgMCx0aGlzLl9jYWNoZS5vcnRob1RvcD12b2lkIDAsdGhpcy5fY2FjaGUucmVuZGVyV2lkdGg9dm9pZCAwLHRoaXMuX2NhY2hlLnJlbmRlckhlaWdodD12b2lkIDB9LGMucHJvdG90eXBlLl91cGRhdGVDYWNoZT1mdW5jdGlvbihhKXthfHxiLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUuY2FsbCh0aGlzKTt2YXIgYz10aGlzLmdldEVuZ2luZSgpO3RoaXMuX2NhY2hlLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMucG9zaXRpb24pLHRoaXMuX2NhY2hlLnVwVmVjdG9yLmNvcHlGcm9tKHRoaXMudXBWZWN0b3IpLHRoaXMuX2NhY2hlLm1vZGU9dGhpcy5tb2RlLHRoaXMuX2NhY2hlLm1pblo9dGhpcy5taW5aLHRoaXMuX2NhY2hlLm1heFo9dGhpcy5tYXhaLHRoaXMuX2NhY2hlLmZvdj10aGlzLmZvdix0aGlzLl9jYWNoZS5hc3BlY3RSYXRpbz1jLmdldEFzcGVjdFJhdGlvKHRoaXMpLHRoaXMuX2NhY2hlLm9ydGhvTGVmdD10aGlzLm9ydGhvTGVmdCx0aGlzLl9jYWNoZS5vcnRob1JpZ2h0PXRoaXMub3J0aG9SaWdodCx0aGlzLl9jYWNoZS5vcnRob0JvdHRvbT10aGlzLm9ydGhvQm90dG9tLHRoaXMuX2NhY2hlLm9ydGhvVG9wPXRoaXMub3J0aG9Ub3AsdGhpcy5fY2FjaGUucmVuZGVyV2lkdGg9Yy5nZXRSZW5kZXJXaWR0aCgpLHRoaXMuX2NhY2hlLnJlbmRlckhlaWdodD1jLmdldFJlbmRlckhlaWdodCgpfSxjLnByb3RvdHlwZS5fdXBkYXRlRnJvbVNjZW5lPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVDYWNoZSgpLHRoaXMuX3VwZGF0ZSgpfSxjLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4KCkmJnRoaXMuX2lzU3luY2hyb25pemVkUHJvamVjdGlvbk1hdHJpeCgpfSxjLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIGIucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZC5jYWxsKHRoaXMpP3RoaXMuX2NhY2hlLnBvc2l0aW9uLmVxdWFscyh0aGlzLnBvc2l0aW9uKSYmdGhpcy5fY2FjaGUudXBWZWN0b3IuZXF1YWxzKHRoaXMudXBWZWN0b3IpJiZ0aGlzLmlzU3luY2hyb25pemVkV2l0aFBhcmVudCgpOiExfSxjLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRQcm9qZWN0aW9uTWF0cml4PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fY2FjaGUubW9kZT09PXRoaXMubW9kZSYmdGhpcy5fY2FjaGUubWluWj09PXRoaXMubWluWiYmdGhpcy5fY2FjaGUubWF4Wj09PXRoaXMubWF4WjtpZighYilyZXR1cm4hMTt2YXIgYz10aGlzLmdldEVuZ2luZSgpO3JldHVybiBiPXRoaXMubW9kZT09PWEuQ2FtZXJhLlBFUlNQRUNUSVZFX0NBTUVSQT90aGlzLl9jYWNoZS5mb3Y9PT10aGlzLmZvdiYmdGhpcy5fY2FjaGUuYXNwZWN0UmF0aW89PT1jLmdldEFzcGVjdFJhdGlvKHRoaXMpOnRoaXMuX2NhY2hlLm9ydGhvTGVmdD09PXRoaXMub3J0aG9MZWZ0JiZ0aGlzLl9jYWNoZS5vcnRob1JpZ2h0PT09dGhpcy5vcnRob1JpZ2h0JiZ0aGlzLl9jYWNoZS5vcnRob0JvdHRvbT09PXRoaXMub3J0aG9Cb3R0b20mJnRoaXMuX2NhY2hlLm9ydGhvVG9wPT09dGhpcy5vcnRob1RvcCYmdGhpcy5fY2FjaGUucmVuZGVyV2lkdGg9PT1jLmdldFJlbmRlcldpZHRoKCkmJnRoaXMuX2NhY2hlLnJlbmRlckhlaWdodD09PWMuZ2V0UmVuZGVySGVpZ2h0KCl9LGMucHJvdG90eXBlLmF0dGFjaENvbnRyb2w9ZnVuY3Rpb24oKXt9LGMucHJvdG90eXBlLmRldGFjaENvbnRyb2w9ZnVuY3Rpb24oKXt9LGMucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt9LGMucHJvdG90eXBlLmF0dGFjaFBvc3RQcm9jZXNzPWZ1bmN0aW9uKGIsYyl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPW51bGwpLCFiLmlzUmV1c2FibGUoKSYmdGhpcy5fcG9zdFByb2Nlc3Nlcy5pbmRleE9mKGIpPi0xKXJldHVybiBhLlRvb2xzLkVycm9yKFwiWW91J3JlIHRyeWluZyB0byByZXVzZSBhIHBvc3QgcHJvY2VzcyBub3QgZGVmaW5lZCBhcyByZXVzYWJsZS5cIiksMDtpZihudWxsPT1jfHwwPmMpcmV0dXJuIHRoaXMuX3Bvc3RQcm9jZXNzZXMucHVzaChiKSx0aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLnB1c2godGhpcy5fcG9zdFByb2Nlc3Nlcy5sZW5ndGgtMSksdGhpcy5fcG9zdFByb2Nlc3Nlcy5sZW5ndGgtMTt2YXIgZD0wO2lmKHRoaXMuX3Bvc3RQcm9jZXNzZXNbY10pe2Zvcih2YXIgZT10aGlzLl9wb3N0UHJvY2Vzc2VzLmxlbmd0aC0xLGY9ZTtmPj1jKzE7LS1mKXRoaXMuX3Bvc3RQcm9jZXNzZXNbZisxXT10aGlzLl9wb3N0UHJvY2Vzc2VzW2ZdO2Q9MX1mb3IoZj0wO2Y8dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5sZW5ndGg7KytmKWlmKCEodGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlc1tmXTxjKSl7ZT10aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLmxlbmd0aC0xO2Zvcih2YXIgZz1lO2c+PWY7LS1nKXRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbZysxXT10aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzW2ddK2Q7dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlc1tmXT1jO2JyZWFrfWR8fC0xIT10aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLmluZGV4T2YoYyl8fHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMucHVzaChjKTt2YXIgaD1jK2Q7cmV0dXJuIHRoaXMuX3Bvc3RQcm9jZXNzZXNbaF09YixofSxjLnByb3RvdHlwZS5kZXRhY2hQb3N0UHJvY2Vzcz1mdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBiJiYoYj1udWxsKTt2YXIgYz1bXTtpZihiKWZvcihiPWIgaW5zdGFuY2VvZiBBcnJheT9iOltiXSxmPTA7ZjxiLmxlbmd0aDtmKyspe3ZhciBkPXRoaXMuX3Bvc3RQcm9jZXNzZXNbYltmXV07ZD09PWE/KGRlbGV0ZSB0aGlzLl9wb3N0UHJvY2Vzc2VzW2JbZl1dLGc9dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5pbmRleE9mKGJbZl0pLHRoaXMuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXMuc3BsaWNlKGcsMSkpOmMucHVzaChmKVxufWVsc2UgZm9yKHZhciBlPXRoaXMuX3Bvc3RQcm9jZXNzZXMubGVuZ3RoLGY9MDtlPmY7ZisrKWlmKHRoaXMuX3Bvc3RQcm9jZXNzZXNbZl09PT1hKXtkZWxldGUgdGhpcy5fcG9zdFByb2Nlc3Nlc1tmXTt2YXIgZz10aGlzLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLmluZGV4T2YoZik7dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5zcGxpY2UoZywxKX1yZXR1cm4gY30sYy5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXt0aGlzLl93b3JsZE1hdHJpeHx8KHRoaXMuX3dvcmxkTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpO3ZhciBiPXRoaXMuZ2V0Vmlld01hdHJpeCgpO3JldHVybiBiLmludmVydFRvUmVmKHRoaXMuX3dvcmxkTWF0cml4KSx0aGlzLl93b3JsZE1hdHJpeH0sYy5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gYS5NYXRyaXguSWRlbnRpdHkoKX0sYy5wcm90b3R5cGUuZ2V0Vmlld01hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb21wdXRlZFZpZXdNYXRyaXg9dGhpcy5fY29tcHV0ZVZpZXdNYXRyaXgoKSx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgmJiF0aGlzLmlzU3luY2hyb25pemVkKCk/KHRoaXMuX3dvcmxkTWF0cml4fHwodGhpcy5fd29ybGRNYXRyaXg9YS5NYXRyaXguSWRlbnRpdHkoKSksdGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4LmludmVydFRvUmVmKHRoaXMuX3dvcmxkTWF0cml4KSx0aGlzLl93b3JsZE1hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCksdGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4KSx0aGlzLl9jb21wdXRlZFZpZXdNYXRyaXguaW52ZXJ0KCksdGhpcy5fY3VycmVudFJlbmRlcklkPXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpLHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeCk6dGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4fSxjLnByb3RvdHlwZS5fY29tcHV0ZVZpZXdNYXRyaXg9ZnVuY3Rpb24oYSl7cmV0dXJuIWEmJnRoaXMuX2lzU3luY2hyb25pemVkVmlld01hdHJpeCgpP3RoaXMuX2NvbXB1dGVkVmlld01hdHJpeDoodGhpcy5fY29tcHV0ZWRWaWV3TWF0cml4PXRoaXMuX2dldFZpZXdNYXRyaXgoKSx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXh8fCh0aGlzLl9jdXJyZW50UmVuZGVySWQ9dGhpcy5nZXRTY2VuZSgpLmdldFJlbmRlcklkKCkpLHRoaXMuX2NvbXB1dGVkVmlld01hdHJpeCl9LGMucHJvdG90eXBlLmdldFByb2plY3Rpb25NYXRyaXg9ZnVuY3Rpb24oYil7aWYoIWImJnRoaXMuX2lzU3luY2hyb25pemVkUHJvamVjdGlvbk1hdHJpeCgpKXJldHVybiB0aGlzLl9wcm9qZWN0aW9uTWF0cml4O3ZhciBjPXRoaXMuZ2V0RW5naW5lKCk7aWYodGhpcy5tb2RlPT09YS5DYW1lcmEuUEVSU1BFQ1RJVkVfQ0FNRVJBKXJldHVybiB0aGlzLm1pblo8PTAmJih0aGlzLm1pblo9LjEpLGEuTWF0cml4LlBlcnNwZWN0aXZlRm92TEhUb1JlZih0aGlzLmZvdixjLmdldEFzcGVjdFJhdGlvKHRoaXMpLHRoaXMubWluWix0aGlzLm1heFosdGhpcy5fcHJvamVjdGlvbk1hdHJpeCksdGhpcy5fcHJvamVjdGlvbk1hdHJpeDt2YXIgZD1jLmdldFJlbmRlcldpZHRoKCkvMixlPWMuZ2V0UmVuZGVySGVpZ2h0KCkvMjtyZXR1cm4gYS5NYXRyaXguT3J0aG9PZmZDZW50ZXJMSFRvUmVmKHRoaXMub3J0aG9MZWZ0fHwtZCx0aGlzLm9ydGhvUmlnaHR8fGQsdGhpcy5vcnRob0JvdHRvbXx8LWUsdGhpcy5vcnRob1RvcHx8ZSx0aGlzLm1pblosdGhpcy5tYXhaLHRoaXMuX3Byb2plY3Rpb25NYXRyaXgpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXh9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdldFNjZW5lKCkuY2FtZXJhcy5pbmRleE9mKHRoaXMpO3RoaXMuZ2V0U2NlbmUoKS5jYW1lcmFzLnNwbGljZShhLDEpO2Zvcih2YXIgYj0wO2I8dGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcy5sZW5ndGg7KytiKXRoaXMuX3Bvc3RQcm9jZXNzZXNbdGhpcy5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlc1tiXV0uZGlzcG9zZSh0aGlzKX0sYy5QRVJTUEVDVElWRV9DQU1FUkE9MCxjLk9SVEhPR1JBUEhJQ19DQU1FUkE9MSxjfShhLk5vZGUpO2EuQ2FtZXJhPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlKXtiLmNhbGwodGhpcyxjLGQsZSksdGhpcy5jYW1lcmFEaXJlY3Rpb249bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5jYW1lcmFSb3RhdGlvbj1uZXcgYS5WZWN0b3IyKDAsMCksdGhpcy5yb3RhdGlvbj1uZXcgYS5WZWN0b3IzKDAsMCwwKSx0aGlzLmVsbGlwc29pZD1uZXcgYS5WZWN0b3IzKC41LDEsLjUpLHRoaXMua2V5c1VwPVszOF0sdGhpcy5rZXlzRG93bj1bNDBdLHRoaXMua2V5c0xlZnQ9WzM3XSx0aGlzLmtleXNSaWdodD1bMzldLHRoaXMuc3BlZWQ9Mix0aGlzLmNoZWNrQ29sbGlzaW9ucz0hMSx0aGlzLmFwcGx5R3Jhdml0eT0hMSx0aGlzLm5vUm90YXRpb25Db25zdHJhaW50PSExLHRoaXMuYW5ndWxhclNlbnNpYmlsaXR5PTJlMyx0aGlzLmxvY2tlZFRhcmdldD1udWxsLHRoaXMuX2tleXM9W10sdGhpcy5fY29sbGlkZXI9bmV3IGEuQ29sbGlkZXIsdGhpcy5fbmVlZE1vdmVGb3JHcmF2aXR5PSEwLHRoaXMuX2N1cnJlbnRUYXJnZXQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl92aWV3TWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9jYW1NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX2NhbWVyYVRyYW5zZm9ybU1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3JlZmVyZW5jZVBvaW50PW5ldyBhLlZlY3RvcjMoMCwwLDEpLHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQ9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9vbGRQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2RpZmZQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX25ld1Bvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fbG9va0F0VGVtcD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fdGVtcE1hdHJpeD1hLk1hdHJpeC5aZXJvKCl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2tlZFRhcmdldD90aGlzLmxvY2tlZFRhcmdldC5wb3NpdGlvbnx8dGhpcy5sb2NrZWRUYXJnZXQ6bnVsbH0sYy5wcm90b3R5cGUuX2luaXRDYWNoZT1mdW5jdGlvbigpe2IucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKSx0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQ9bmV3IGEuVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksdGhpcy5fY2FjaGUucm90YXRpb249bmV3IGEuVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSl9LGMucHJvdG90eXBlLl91cGRhdGVDYWNoZT1mdW5jdGlvbihhKXthfHxiLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUuY2FsbCh0aGlzKTt2YXIgYz10aGlzLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbigpO2M/dGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0P3RoaXMuX2NhY2hlLmxvY2tlZFRhcmdldC5jb3B5RnJvbShjKTp0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQ9Yy5jbG9uZSgpOnRoaXMuX2NhY2hlLmxvY2tlZFRhcmdldD1udWxsLHRoaXMuX2NhY2hlLnJvdGF0aW9uLmNvcHlGcm9tKHRoaXMucm90YXRpb24pfSxjLnByb3RvdHlwZS5faXNTeW5jaHJvbml6ZWRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7aWYoIWIucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXguY2FsbCh0aGlzKSlyZXR1cm4hMTt2YXIgYT10aGlzLl9nZXRMb2NrZWRUYXJnZXRQb3NpdGlvbigpO3JldHVybih0aGlzLl9jYWNoZS5sb2NrZWRUYXJnZXQ/dGhpcy5fY2FjaGUubG9ja2VkVGFyZ2V0LmVxdWFscyhhKTohYSkmJnRoaXMuX2NhY2hlLnJvdGF0aW9uLmVxdWFscyh0aGlzLnJvdGF0aW9uKX0sYy5wcm90b3R5cGUuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BlZWQqKGEuVG9vbHMuR2V0RGVsdGFUaW1lKCkvKDEwKmEuVG9vbHMuR2V0RnBzKCkpKX0sYy5wcm90b3R5cGUuc2V0VGFyZ2V0PWZ1bmN0aW9uKGIpe3RoaXMudXBWZWN0b3Iubm9ybWFsaXplKCksYS5NYXRyaXguTG9va0F0TEhUb1JlZih0aGlzLnBvc2l0aW9uLGIsdGhpcy51cFZlY3Rvcix0aGlzLl9jYW1NYXRyaXgpLHRoaXMuX2NhbU1hdHJpeC5pbnZlcnQoKSx0aGlzLnJvdGF0aW9uLng9TWF0aC5hdGFuKHRoaXMuX2NhbU1hdHJpeC5tWzZdL3RoaXMuX2NhbU1hdHJpeC5tWzEwXSk7dmFyIGM9Yi5zdWJ0cmFjdCh0aGlzLnBvc2l0aW9uKTt0aGlzLnJvdGF0aW9uLnk9Yy54Pj0wPy1NYXRoLmF0YW4oYy56L2MueCkrTWF0aC5QSS8yOi1NYXRoLmF0YW4oYy56L2MueCktTWF0aC5QSS8yLHRoaXMucm90YXRpb24uej0tTWF0aC5hY29zKGEuVmVjdG9yMy5Eb3QobmV3IGEuVmVjdG9yMygwLDEsMCksdGhpcy51cFZlY3RvcikpLGlzTmFOKHRoaXMucm90YXRpb24ueCkmJih0aGlzLnJvdGF0aW9uLng9MCksaXNOYU4odGhpcy5yb3RhdGlvbi55KSYmKHRoaXMucm90YXRpb24ueT0wKSxpc05hTih0aGlzLnJvdGF0aW9uLnopJiYodGhpcy5yb3RhdGlvbi56PTApfSxjLnByb3RvdHlwZS5nZXRUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudFRhcmdldH0sYy5wcm90b3R5cGUuYXR0YWNoQ29udHJvbD1mdW5jdGlvbihiLGMpe3ZhciBkLGU9dGhpcyxmPXRoaXMuZ2V0RW5naW5lKCk7dGhpcy5fYXR0YWNoZWRFbGVtZW50fHwodGhpcy5fYXR0YWNoZWRFbGVtZW50PWIsdm9pZCAwPT09dGhpcy5fb25Nb3VzZURvd24mJih0aGlzLl9vbk1vdXNlRG93bj1mdW5jdGlvbihhKXtkPXt4OmEuY2xpZW50WCx5OmEuY2xpZW50WX0sY3x8YS5wcmV2ZW50RGVmYXVsdCgpfSx0aGlzLl9vbk1vdXNlVXA9ZnVuY3Rpb24oYSl7ZD1udWxsLGN8fGEucHJldmVudERlZmF1bHQoKX0sdGhpcy5fb25Nb3VzZU91dD1mdW5jdGlvbihhKXtkPW51bGwsZS5fa2V5cz1bXSxjfHxhLnByZXZlbnREZWZhdWx0KCl9LHRoaXMuX29uTW91c2VNb3ZlPWZ1bmN0aW9uKGEpe2lmKGR8fGYuaXNQb2ludGVyTG9jayl7dmFyIGIsZztmLmlzUG9pbnRlckxvY2s/KGI9YS5tb3ZlbWVudFh8fGEubW96TW92ZW1lbnRYfHxhLndlYmtpdE1vdmVtZW50WHx8YS5tc01vdmVtZW50WHx8MCxnPWEubW92ZW1lbnRZfHxhLm1vek1vdmVtZW50WXx8YS53ZWJraXRNb3ZlbWVudFl8fGEubXNNb3ZlbWVudFl8fDApOihiPWEuY2xpZW50WC1kLngsZz1hLmNsaWVudFktZC55KSxlLmNhbWVyYVJvdGF0aW9uLnkrPWIvZS5hbmd1bGFyU2Vuc2liaWxpdHksZS5jYW1lcmFSb3RhdGlvbi54Kz1nL2UuYW5ndWxhclNlbnNpYmlsaXR5LGQ9e3g6YS5jbGllbnRYLHk6YS5jbGllbnRZfSxjfHxhLnByZXZlbnREZWZhdWx0KCl9fSx0aGlzLl9vbktleURvd249ZnVuY3Rpb24oYSl7aWYoLTEhPT1lLmtleXNVcC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzRG93bi5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzTGVmdC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzUmlnaHQuaW5kZXhPZihhLmtleUNvZGUpKXt2YXIgYj1lLl9rZXlzLmluZGV4T2YoYS5rZXlDb2RlKTstMT09PWImJmUuX2tleXMucHVzaChhLmtleUNvZGUpLGN8fGEucHJldmVudERlZmF1bHQoKX19LHRoaXMuX29uS2V5VXA9ZnVuY3Rpb24oYSl7aWYoLTEhPT1lLmtleXNVcC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzRG93bi5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzTGVmdC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09ZS5rZXlzUmlnaHQuaW5kZXhPZihhLmtleUNvZGUpKXt2YXIgYj1lLl9rZXlzLmluZGV4T2YoYS5rZXlDb2RlKTtiPj0wJiZlLl9rZXlzLnNwbGljZShiLDEpLGN8fGEucHJldmVudERlZmF1bHQoKX19LHRoaXMuX29uTG9zdEZvY3VzPWZ1bmN0aW9uKCl7ZS5fa2V5cz1bXX0sdGhpcy5fcmVzZXQ9ZnVuY3Rpb24oKXtlLl9rZXlzPVtdLGQ9bnVsbCxlLmNhbWVyYURpcmVjdGlvbj1uZXcgYS5WZWN0b3IzKDAsMCwwKSxlLmNhbWVyYVJvdGF0aW9uPW5ldyBhLlZlY3RvcjIoMCwwKX0pLGIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLCExKSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fb25Nb3VzZVVwLCExKSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLHRoaXMuX29uTW91c2VPdXQsITEpLGIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLCExKSxhLlRvb2xzLlJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbe25hbWU6XCJrZXlkb3duXCIsaGFuZGxlcjp0aGlzLl9vbktleURvd259LHtuYW1lOlwia2V5dXBcIixoYW5kbGVyOnRoaXMuX29uS2V5VXB9LHtuYW1lOlwiYmx1clwiLGhhbmRsZXI6dGhpcy5fb25Mb3N0Rm9jdXN9XSkpfSxjLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKGIpe3RoaXMuX2F0dGFjaGVkRWxlbWVudD09YiYmKGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duKSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fb25Nb3VzZVVwKSxiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLHRoaXMuX29uTW91c2VPdXQpLGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlKSxhLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFt7bmFtZTpcImtleWRvd25cIixoYW5kbGVyOnRoaXMuX29uS2V5RG93bn0se25hbWU6XCJrZXl1cFwiLGhhbmRsZXI6dGhpcy5fb25LZXlVcH0se25hbWU6XCJibHVyXCIsaGFuZGxlcjp0aGlzLl9vbkxvc3RGb2N1c31dKSx0aGlzLl9hdHRhY2hlZEVsZW1lbnQ9bnVsbCx0aGlzLl9yZXNldCYmdGhpcy5fcmVzZXQoKSl9LGMucHJvdG90eXBlLl9jb2xsaWRlV2l0aFdvcmxkPWZ1bmN0aW9uKGIpe3ZhciBjO2M9dGhpcy5wYXJlbnQ/YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24sdGhpcy5wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKSk6dGhpcy5wb3NpdGlvbixjLnN1YnRyYWN0RnJvbUZsb2F0c1RvUmVmKDAsdGhpcy5lbGxpcHNvaWQueSwwLHRoaXMuX29sZFBvc2l0aW9uKSx0aGlzLl9jb2xsaWRlci5yYWRpdXM9dGhpcy5lbGxpcHNvaWQsdGhpcy5nZXRTY2VuZSgpLl9nZXROZXdQb3NpdGlvbih0aGlzLl9vbGRQb3NpdGlvbixiLHRoaXMuX2NvbGxpZGVyLDMsdGhpcy5fbmV3UG9zaXRpb24pLHRoaXMuX25ld1Bvc2l0aW9uLnN1YnRyYWN0VG9SZWYodGhpcy5fb2xkUG9zaXRpb24sdGhpcy5fZGlmZlBvc2l0aW9uKSx0aGlzLl9kaWZmUG9zaXRpb24ubGVuZ3RoKCk+YS5FbmdpbmUuQ29sbGlzaW9uc0Vwc2lsb24mJih0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5fZGlmZlBvc2l0aW9uKSx0aGlzLm9uQ29sbGlkZSYmdGhpcy5vbkNvbGxpZGUodGhpcy5fY29sbGlkZXIuY29sbGlkZWRNZXNoKSl9LGMucHJvdG90eXBlLl9jaGVja0lucHV0cz1mdW5jdGlvbigpe3RoaXMuX2xvY2FsRGlyZWN0aW9ufHwodGhpcy5fbG9jYWxEaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90cmFuc2Zvcm1lZERpcmVjdGlvbj1hLlZlY3RvcjMuWmVybygpKTtmb3IodmFyIGI9MDtiPHRoaXMuX2tleXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fa2V5c1tiXSxkPXRoaXMuX2NvbXB1dGVMb2NhbENhbWVyYVNwZWVkKCk7LTEhPT10aGlzLmtleXNMZWZ0LmluZGV4T2YoYyk/dGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoLWQsMCwwKTotMSE9PXRoaXMua2V5c1VwLmluZGV4T2YoYyk/dGhpcy5fbG9jYWxEaXJlY3Rpb24uY29weUZyb21GbG9hdHMoMCwwLGQpOi0xIT09dGhpcy5rZXlzUmlnaHQuaW5kZXhPZihjKT90aGlzLl9sb2NhbERpcmVjdGlvbi5jb3B5RnJvbUZsb2F0cyhkLDAsMCk6LTEhPT10aGlzLmtleXNEb3duLmluZGV4T2YoYykmJnRoaXMuX2xvY2FsRGlyZWN0aW9uLmNvcHlGcm9tRmxvYXRzKDAsMCwtZCksdGhpcy5nZXRWaWV3TWF0cml4KCkuaW52ZXJ0VG9SZWYodGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4KSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYodGhpcy5fbG9jYWxEaXJlY3Rpb24sdGhpcy5fY2FtZXJhVHJhbnNmb3JtTWF0cml4LHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKSx0aGlzLmNhbWVyYURpcmVjdGlvbi5hZGRJblBsYWNlKHRoaXMuX3RyYW5zZm9ybWVkRGlyZWN0aW9uKX19LGMucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLl9jaGVja0lucHV0cygpO3ZhciBiPXRoaXMuX25lZWRNb3ZlRm9yR3Jhdml0eXx8TWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueCk+MHx8TWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueSk+MHx8TWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueik+MCxjPU1hdGguYWJzKHRoaXMuY2FtZXJhUm90YXRpb24ueCk+MHx8TWF0aC5hYnModGhpcy5jYW1lcmFSb3RhdGlvbi55KT4wO2lmKGIpaWYodGhpcy5jaGVja0NvbGxpc2lvbnMmJnRoaXMuZ2V0U2NlbmUoKS5jb2xsaXNpb25zRW5hYmxlZCl7aWYodGhpcy5fY29sbGlkZVdpdGhXb3JsZCh0aGlzLmNhbWVyYURpcmVjdGlvbiksdGhpcy5hcHBseUdyYXZpdHkpe3ZhciBkPXRoaXMucG9zaXRpb247dGhpcy5fY29sbGlkZVdpdGhXb3JsZCh0aGlzLmdldFNjZW5lKCkuZ3Jhdml0eSksdGhpcy5fbmVlZE1vdmVGb3JHcmF2aXR5PTAhPWEuVmVjdG9yMy5EaXN0YW5jZVNxdWFyZWQoZCx0aGlzLnBvc2l0aW9uKX19ZWxzZSB0aGlzLnBvc2l0aW9uLmFkZEluUGxhY2UodGhpcy5jYW1lcmFEaXJlY3Rpb24pO2lmKGMmJih0aGlzLnJvdGF0aW9uLngrPXRoaXMuY2FtZXJhUm90YXRpb24ueCx0aGlzLnJvdGF0aW9uLnkrPXRoaXMuY2FtZXJhUm90YXRpb24ueSwhdGhpcy5ub1JvdGF0aW9uQ29uc3RyYWludCkpe3ZhciBlPU1hdGguUEkvMiouOTU7dGhpcy5yb3RhdGlvbi54PmUmJih0aGlzLnJvdGF0aW9uLng9ZSksdGhpcy5yb3RhdGlvbi54PC1lJiYodGhpcy5yb3RhdGlvbi54PS1lKX1iJiYoTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueCk8YS5FbmdpbmUuRXBzaWxvbiYmKHRoaXMuY2FtZXJhRGlyZWN0aW9uLng9MCksTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueSk8YS5FbmdpbmUuRXBzaWxvbiYmKHRoaXMuY2FtZXJhRGlyZWN0aW9uLnk9MCksTWF0aC5hYnModGhpcy5jYW1lcmFEaXJlY3Rpb24ueik8YS5FbmdpbmUuRXBzaWxvbiYmKHRoaXMuY2FtZXJhRGlyZWN0aW9uLno9MCksdGhpcy5jYW1lcmFEaXJlY3Rpb24uc2NhbGVJblBsYWNlKHRoaXMuaW5lcnRpYSkpLGMmJihNYXRoLmFicyh0aGlzLmNhbWVyYVJvdGF0aW9uLngpPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmNhbWVyYVJvdGF0aW9uLng9MCksTWF0aC5hYnModGhpcy5jYW1lcmFSb3RhdGlvbi55KTxhLkVuZ2luZS5FcHNpbG9uJiYodGhpcy5jYW1lcmFSb3RhdGlvbi55PTApLHRoaXMuY2FtZXJhUm90YXRpb24uc2NhbGVJblBsYWNlKHRoaXMuaW5lcnRpYSkpfSxjLnByb3RvdHlwZS5fZ2V0Vmlld01hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2tlZFRhcmdldD90aGlzLl9jdXJyZW50VGFyZ2V0LmNvcHlGcm9tKHRoaXMuX2dldExvY2tlZFRhcmdldFBvc2l0aW9uKCkpOigwIT10aGlzLnVwVmVjdG9yLnh8fDEhPXRoaXMudXBWZWN0b3IueXx8MCE9dGhpcy51cFZlY3Rvci56PyhhLk1hdHJpeC5Mb29rQXRMSFRvUmVmKGEuVmVjdG9yMy5aZXJvKCksdGhpcy5fcmVmZXJlbmNlUG9pbnQsdGhpcy51cFZlY3Rvcix0aGlzLl9sb29rQXRUZW1wKSxhLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsdGhpcy5yb3RhdGlvbi56LHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4KSx0aGlzLl9sb29rQXRUZW1wLm11bHRpcGx5VG9SZWYodGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgsdGhpcy5fdGVtcE1hdHJpeCksdGhpcy5fbG9va0F0VGVtcC5pbnZlcnQoKSx0aGlzLl90ZW1wTWF0cml4Lm11bHRpcGx5VG9SZWYodGhpcy5fbG9va0F0VGVtcCx0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCkpOmEuTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCx0aGlzLnJvdGF0aW9uLnosdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMuX3JlZmVyZW5jZVBvaW50LHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQpLHRoaXMucG9zaXRpb24uYWRkVG9SZWYodGhpcy5fdHJhbnNmb3JtZWRSZWZlcmVuY2VQb2ludCx0aGlzLl9jdXJyZW50VGFyZ2V0KSksYS5NYXRyaXguTG9va0F0TEhUb1JlZih0aGlzLnBvc2l0aW9uLHRoaXMuX2N1cnJlbnRUYXJnZXQsdGhpcy51cFZlY3Rvcix0aGlzLl92aWV3TWF0cml4KSx0aGlzLl92aWV3TWF0cml4fSxjfShhLkNhbWVyYSk7YS5GcmVlQ2FtZXJhPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkKXtiLmNhbGwodGhpcyxhLGMsZCksdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9wb2ludGVyQ291bnQ9MCx0aGlzLl9wb2ludGVyUHJlc3NlZD1bXSx0aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eT0yZTUsdGhpcy5tb3ZlU2Vuc2liaWxpdHk9NTAwfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKGIsYyl7dmFyIGQsZT10aGlzO3RoaXMuX2F0dGFjaGVkQ2FudmFzfHwodGhpcy5fYXR0YWNoZWRDYW52YXM9Yix2b2lkIDA9PT10aGlzLl9vblBvaW50ZXJEb3duJiYodGhpcy5fb25Qb2ludGVyRG93bj1mdW5jdGlvbihhKXtjfHxhLnByZXZlbnREZWZhdWx0KCksZS5fcG9pbnRlclByZXNzZWQucHVzaChhLnBvaW50ZXJJZCksMT09PWUuX3BvaW50ZXJQcmVzc2VkLmxlbmd0aCYmKGQ9e3g6YS5jbGllbnRYLHk6YS5jbGllbnRZfSl9LHRoaXMuX29uUG9pbnRlclVwPWZ1bmN0aW9uKGEpe2N8fGEucHJldmVudERlZmF1bHQoKTt2YXIgYj1lLl9wb2ludGVyUHJlc3NlZC5pbmRleE9mKGEucG9pbnRlcklkKTstMSE9PWImJihlLl9wb2ludGVyUHJlc3NlZC5zcGxpY2UoYiwxKSwwPT1iJiYoZD1udWxsLGUuX29mZnNldFg9bnVsbCxlLl9vZmZzZXRZPW51bGwpKX0sdGhpcy5fb25Qb2ludGVyTW92ZT1mdW5jdGlvbihhKXtpZihjfHxhLnByZXZlbnREZWZhdWx0KCksZCl7dmFyIGI9ZS5fcG9pbnRlclByZXNzZWQuaW5kZXhPZihhLnBvaW50ZXJJZCk7MD09YiYmKGUuX29mZnNldFg9YS5jbGllbnRYLWQueCxlLl9vZmZzZXRZPS0oYS5jbGllbnRZLWQueSkpfX0sdGhpcy5fb25Mb3N0Rm9jdXM9ZnVuY3Rpb24oKXtlLl9vZmZzZXRYPW51bGwsZS5fb2Zmc2V0WT1udWxsfSksYi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIix0aGlzLl9vblBvaW50ZXJEb3duKSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIix0aGlzLl9vblBvaW50ZXJVcCksYi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm91dFwiLHRoaXMuX29uUG9pbnRlclVwKSxiLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLHRoaXMuX29uUG9pbnRlck1vdmUpLGEuVG9vbHMuUmVnaXN0ZXJUb3BSb290RXZlbnRzKFt7bmFtZTpcImJsdXJcIixoYW5kbGVyOnRoaXMuX29uTG9zdEZvY3VzfV0pKX0sYy5wcm90b3R5cGUuZGV0YWNoQ29udHJvbD1mdW5jdGlvbihiKXt0aGlzLl9hdHRhY2hlZENhbnZhcz09YiYmKGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsdGhpcy5fb25Qb2ludGVyRG93biksYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsdGhpcy5fb25Qb2ludGVyVXApLGIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdXRcIix0aGlzLl9vblBvaW50ZXJVcCksYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIix0aGlzLl9vblBvaW50ZXJNb3ZlKSxhLlRvb2xzLlVucmVnaXN0ZXJUb3BSb290RXZlbnRzKFt7bmFtZTpcImJsdXJcIixoYW5kbGVyOnRoaXMuX29uTG9zdEZvY3VzfV0pLHRoaXMuX2F0dGFjaGVkQ2FudmFzPW51bGwpfSxjLnByb3RvdHlwZS5fY2hlY2tJbnB1dHM9ZnVuY3Rpb24oKXtpZih0aGlzLl9vZmZzZXRYKWlmKHRoaXMuY2FtZXJhUm90YXRpb24ueSs9dGhpcy5fb2Zmc2V0WC90aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eSx0aGlzLl9wb2ludGVyUHJlc3NlZC5sZW5ndGg+MSl0aGlzLmNhbWVyYVJvdGF0aW9uLngrPS10aGlzLl9vZmZzZXRZL3RoaXMuYW5ndWxhclNlbnNpYmlsaXR5O2Vsc2V7dmFyIGI9dGhpcy5fY29tcHV0ZUxvY2FsQ2FtZXJhU3BlZWQoKSxjPW5ldyBhLlZlY3RvcjMoMCwwLGIqdGhpcy5fb2Zmc2V0WS90aGlzLm1vdmVTZW5zaWJpbGl0eSk7YS5NYXRyaXguUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih0aGlzLnJvdGF0aW9uLnksdGhpcy5yb3RhdGlvbi54LDAsdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpLHRoaXMuY2FtZXJhRGlyZWN0aW9uLmFkZEluUGxhY2UoYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGMsdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpKX19LGN9KGEuRnJlZUNhbWVyYSk7YS5Ub3VjaENhbWVyYT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCl7dmFyIGU9dGhpcztiLmNhbGwodGhpcyxhLGMsZCksdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9vcmllbnRhdGlvbkdhbW1hPTAsdGhpcy5fb3JpZW50YXRpb25CZXRhPTAsdGhpcy5faW5pdGlhbE9yaWVudGF0aW9uR2FtbWE9MCx0aGlzLl9pbml0aWFsT3JpZW50YXRpb25CZXRhPTAsdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHk9MWU0LHRoaXMubW92ZVNlbnNpYmlsaXR5PTUwLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsZnVuY3Rpb24oKXtlLl9pbml0aWFsT3JpZW50YXRpb25HYW1tYT1udWxsfSwhMSl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLmF0dGFjaENvbnRyb2w9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt0aGlzLl9hdHRhY2hlZENhbnZhc3x8KHRoaXMuX2F0dGFjaGVkQ2FudmFzPWEsdGhpcy5fb3JpZW50YXRpb25DaGFuZ2VkfHwodGhpcy5fb3JpZW50YXRpb25DaGFuZ2VkPWZ1bmN0aW9uKGEpe2IuX2luaXRpYWxPcmllbnRhdGlvbkdhbW1hfHwoYi5faW5pdGlhbE9yaWVudGF0aW9uR2FtbWE9YS5nYW1tYSxiLl9pbml0aWFsT3JpZW50YXRpb25CZXRhPWEuYmV0YSksYi5fb3JpZW50YXRpb25HYW1tYT1hLmdhbW1hLGIuX29yaWVudGF0aW9uQmV0YT1hLmJldGEsYi5fb2Zmc2V0WT1iLl9pbml0aWFsT3JpZW50YXRpb25CZXRhLWIuX29yaWVudGF0aW9uQmV0YSxiLl9vZmZzZXRYPWIuX2luaXRpYWxPcmllbnRhdGlvbkdhbW1hLWIuX29yaWVudGF0aW9uR2FtbWF9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5fb3JpZW50YXRpb25DaGFuZ2VkKSl9LGMucHJvdG90eXBlLmRldGFjaENvbnRyb2w9ZnVuY3Rpb24oYSl7dGhpcy5fYXR0YWNoZWRDYW52YXM9PWEmJih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5fb3JpZW50YXRpb25DaGFuZ2VkKSx0aGlzLl9hdHRhY2hlZENhbnZhcz1udWxsLHRoaXMuX29yaWVudGF0aW9uR2FtbWE9MCx0aGlzLl9vcmllbnRhdGlvbkJldGE9MCx0aGlzLl9pbml0aWFsT3JpZW50YXRpb25HYW1tYT0wLHRoaXMuX2luaXRpYWxPcmllbnRhdGlvbkJldGE9MCl9LGMucHJvdG90eXBlLl9jaGVja0lucHV0cz1mdW5jdGlvbigpe2lmKHRoaXMuX29mZnNldFgpe3RoaXMuY2FtZXJhUm90YXRpb24ueS09dGhpcy5fb2Zmc2V0WC90aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eTt2YXIgYj10aGlzLl9jb21wdXRlTG9jYWxDYW1lcmFTcGVlZCgpLGM9bmV3IGEuVmVjdG9yMygwLDAsYip0aGlzLl9vZmZzZXRZL3RoaXMubW92ZVNlbnNpYmlsaXR5KTthLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMucm90YXRpb24ueSx0aGlzLnJvdGF0aW9uLngsMCx0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCksdGhpcy5jYW1lcmFEaXJlY3Rpb24uYWRkSW5QbGFjZShhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXMoYyx0aGlzLl9jYW1lcmFSb3RhdGlvbk1hdHJpeCkpfX0sY30oYS5GcmVlQ2FtZXJhKTthLkRldmljZU9yaWVudGF0aW9uQ2FtZXJhPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1hLlRvb2xzLkdldFBvaW50ZXJQcmVmaXgoKSxjPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoYixkLGUsZixnLGgpe2MuY2FsbCh0aGlzLGIsYS5WZWN0b3IzLlplcm8oKSxoKSx0aGlzLmFscGhhPWQsdGhpcy5iZXRhPWUsdGhpcy5yYWRpdXM9Zix0aGlzLnRhcmdldD1nLHRoaXMuaW5lcnRpYWxBbHBoYU9mZnNldD0wLHRoaXMuaW5lcnRpYWxCZXRhT2Zmc2V0PTAsdGhpcy5pbmVydGlhbFJhZGl1c09mZnNldD0wLHRoaXMubG93ZXJBbHBoYUxpbWl0PW51bGwsdGhpcy51cHBlckFscGhhTGltaXQ9bnVsbCx0aGlzLmxvd2VyQmV0YUxpbWl0PS4wMSx0aGlzLnVwcGVyQmV0YUxpbWl0PU1hdGguUEksdGhpcy5sb3dlclJhZGl1c0xpbWl0PW51bGwsdGhpcy51cHBlclJhZGl1c0xpbWl0PW51bGwsdGhpcy5hbmd1bGFyU2Vuc2liaWxpdHk9MWUzLHRoaXMud2hlZWxQcmVjaXNpb249Myx0aGlzLmtleXNVcD1bMzhdLHRoaXMua2V5c0Rvd249WzQwXSx0aGlzLmtleXNMZWZ0PVszN10sdGhpcy5rZXlzUmlnaHQ9WzM5XSx0aGlzLnpvb21PbkZhY3Rvcj0xLHRoaXMuX2tleXM9W10sdGhpcy5fdmlld01hdHJpeD1uZXcgYS5NYXRyaXgsdGhpcy5jaGVja0NvbGxpc2lvbnM9ITEsdGhpcy5jb2xsaXNpb25SYWRpdXM9bmV3IGEuVmVjdG9yMyguNSwuNSwuNSksdGhpcy5fY29sbGlkZXI9bmV3IGEuQ29sbGlkZXIsdGhpcy5fcHJldmlvdXNQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NvbGxpc2lvblZlbG9jaXR5PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fbmV3UG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLmdldFZpZXdNYXRyaXgoKX1yZXR1cm4gX19leHRlbmRzKGQsYyksZC5wcm90b3R5cGUuX2dldFRhcmdldFBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFyZ2V0LnBvc2l0aW9ufHx0aGlzLnRhcmdldH0sZC5wcm90b3R5cGUuX2luaXRDYWNoZT1mdW5jdGlvbigpe2MucHJvdG90eXBlLl9pbml0Q2FjaGUuY2FsbCh0aGlzKSx0aGlzLl9jYWNoZS50YXJnZXQ9bmV3IGEuVmVjdG9yMyhOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUsTnVtYmVyLk1BWF9WQUxVRSksdGhpcy5fY2FjaGUuYWxwaGE9dm9pZCAwLHRoaXMuX2NhY2hlLmJldGE9dm9pZCAwLHRoaXMuX2NhY2hlLnJhZGl1cz12b2lkIDB9LGQucHJvdG90eXBlLl91cGRhdGVDYWNoZT1mdW5jdGlvbihhKXthfHxjLnByb3RvdHlwZS5fdXBkYXRlQ2FjaGUuY2FsbCh0aGlzKSx0aGlzLl9jYWNoZS50YXJnZXQuY29weUZyb20odGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKSksdGhpcy5fY2FjaGUuYWxwaGE9dGhpcy5hbHBoYSx0aGlzLl9jYWNoZS5iZXRhPXRoaXMuYmV0YSx0aGlzLl9jYWNoZS5yYWRpdXM9dGhpcy5yYWRpdXN9LGQucHJvdG90eXBlLl9pc1N5bmNocm9uaXplZFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkVmlld01hdHJpeC5jYWxsKHRoaXMpP3RoaXMuX2NhY2hlLnRhcmdldC5lcXVhbHModGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKSkmJnRoaXMuX2NhY2hlLmFscGhhPT09dGhpcy5hbHBoYSYmdGhpcy5fY2FjaGUuYmV0YT09PXRoaXMuYmV0YSYmdGhpcy5fY2FjaGUucmFkaXVzPT09dGhpcy5yYWRpdXM6ITF9LGQucHJvdG90eXBlLmF0dGFjaENvbnRyb2w9ZnVuY3Rpb24oYyxkKXt2YXIgZSxmLGc9dGhpcztpZighdGhpcy5fYXR0YWNoZWRFbGVtZW50KXt0aGlzLl9hdHRhY2hlZEVsZW1lbnQ9Yzt2YXIgaD10aGlzLmdldEVuZ2luZSgpO3ZvaWQgMD09PXRoaXMuX29uUG9pbnRlckRvd24mJih0aGlzLl9vblBvaW50ZXJEb3duPWZ1bmN0aW9uKGEpe2Z8fChmPWEucG9pbnRlcklkLGU9e3g6YS5jbGllbnRYLHk6YS5jbGllbnRZfSxkfHxhLnByZXZlbnREZWZhdWx0KCkpfSx0aGlzLl9vblBvaW50ZXJVcD1mdW5jdGlvbihhKXtlPW51bGwsZj1udWxsLGR8fGEucHJldmVudERlZmF1bHQoKX0sdGhpcy5fb25Qb2ludGVyTW92ZT1mdW5jdGlvbihhKXtpZihlJiZmPT09YS5wb2ludGVySWQpe3ZhciBiPWEuY2xpZW50WC1lLngsYz1hLmNsaWVudFktZS55O2cuaW5lcnRpYWxBbHBoYU9mZnNldC09Yi9nLmFuZ3VsYXJTZW5zaWJpbGl0eSxnLmluZXJ0aWFsQmV0YU9mZnNldC09Yy9nLmFuZ3VsYXJTZW5zaWJpbGl0eSxlPXt4OmEuY2xpZW50WCx5OmEuY2xpZW50WX0sZHx8YS5wcmV2ZW50RGVmYXVsdCgpfX0sdGhpcy5fb25Nb3VzZU1vdmU9ZnVuY3Rpb24oYSl7aWYoaC5pc1BvaW50ZXJMb2NrKXt2YXIgYj1hLm1vdmVtZW50WHx8YS5tb3pNb3ZlbWVudFh8fGEud2Via2l0TW92ZW1lbnRYfHxhLm1zTW92ZW1lbnRYfHwwLGM9YS5tb3ZlbWVudFl8fGEubW96TW92ZW1lbnRZfHxhLndlYmtpdE1vdmVtZW50WXx8YS5tc01vdmVtZW50WXx8MDtnLmluZXJ0aWFsQWxwaGFPZmZzZXQtPWIvZy5hbmd1bGFyU2Vuc2liaWxpdHksZy5pbmVydGlhbEJldGFPZmZzZXQtPWMvZy5hbmd1bGFyU2Vuc2liaWxpdHksZHx8YS5wcmV2ZW50RGVmYXVsdCgpfX0sdGhpcy5fd2hlZWw9ZnVuY3Rpb24oYSl7dmFyIGI9MDthLndoZWVsRGVsdGE/Yj1hLndoZWVsRGVsdGEvKDQwKmcud2hlZWxQcmVjaXNpb24pOmEuZGV0YWlsJiYoYj0tYS5kZXRhaWwvZy53aGVlbFByZWNpc2lvbiksYiYmKGcuaW5lcnRpYWxSYWRpdXNPZmZzZXQrPWIpLGEucHJldmVudERlZmF1bHQmJihkfHxhLnByZXZlbnREZWZhdWx0KCkpfSx0aGlzLl9vbktleURvd249ZnVuY3Rpb24oYSl7aWYoLTEhPT1nLmtleXNVcC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzRG93bi5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzTGVmdC5pbmRleE9mKGEua2V5Q29kZSl8fC0xIT09Zy5rZXlzUmlnaHQuaW5kZXhPZihhLmtleUNvZGUpKXt2YXIgYj1nLl9rZXlzLmluZGV4T2YoYS5rZXlDb2RlKTstMT09PWImJmcuX2tleXMucHVzaChhLmtleUNvZGUpLGEucHJldmVudERlZmF1bHQmJihkfHxhLnByZXZlbnREZWZhdWx0KCkpfX0sdGhpcy5fb25LZXlVcD1mdW5jdGlvbihhKXtpZigtMSE9PWcua2V5c1VwLmluZGV4T2YoYS5rZXlDb2RlKXx8LTEhPT1nLmtleXNEb3duLmluZGV4T2YoYS5rZXlDb2RlKXx8LTEhPT1nLmtleXNMZWZ0LmluZGV4T2YoYS5rZXlDb2RlKXx8LTEhPT1nLmtleXNSaWdodC5pbmRleE9mKGEua2V5Q29kZSkpe3ZhciBiPWcuX2tleXMuaW5kZXhPZihhLmtleUNvZGUpO2I+PTAmJmcuX2tleXMuc3BsaWNlKGIsMSksYS5wcmV2ZW50RGVmYXVsdCYmKGR8fGEucHJldmVudERlZmF1bHQoKSl9fSx0aGlzLl9vbkxvc3RGb2N1cz1mdW5jdGlvbigpe2cuX2tleXM9W10sZj1udWxsfSx0aGlzLl9vbkdlc3R1cmVTdGFydD1mdW5jdGlvbihhKXt2b2lkIDAhPT13aW5kb3cuTVNHZXN0dXJlJiYoZy5fTVNHZXN0dXJlSGFuZGxlcnx8KGcuX01TR2VzdHVyZUhhbmRsZXI9bmV3IE1TR2VzdHVyZSxnLl9NU0dlc3R1cmVIYW5kbGVyLnRhcmdldD1jKSxnLl9NU0dlc3R1cmVIYW5kbGVyLmFkZFBvaW50ZXIoYS5wb2ludGVySWQpKX0sdGhpcy5fb25HZXN0dXJlPWZ1bmN0aW9uKGEpe2cucmFkaXVzKj1hLnNjYWxlLGEucHJldmVudERlZmF1bHQmJihkfHwoYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCkpKX0sdGhpcy5fcmVzZXQ9ZnVuY3Rpb24oKXtnLl9rZXlzPVtdLGcuaW5lcnRpYWxBbHBoYU9mZnNldD0wLGcuaW5lcnRpYWxCZXRhT2Zmc2V0PTAsZy5pbmVydGlhbFJhZGl1c09mZnNldD0wLGU9bnVsbCxmPW51bGx9KSxjLmFkZEV2ZW50TGlzdGVuZXIoYitcImRvd25cIix0aGlzLl9vblBvaW50ZXJEb3duLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoYitcInVwXCIsdGhpcy5fb25Qb2ludGVyVXAsITEpLGMuYWRkRXZlbnRMaXN0ZW5lcihiK1wib3V0XCIsdGhpcy5fb25Qb2ludGVyVXAsITEpLGMuYWRkRXZlbnRMaXN0ZW5lcihiK1wibW92ZVwiLHRoaXMuX29uUG9pbnRlck1vdmUsITEpLGMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsdGhpcy5fb25HZXN0dXJlU3RhcnQsITEpLGMuYWRkRXZlbnRMaXN0ZW5lcihcIk1TR2VzdHVyZUNoYW5nZVwiLHRoaXMuX29uR2VzdHVyZSwhMSksYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLHRoaXMuX3doZWVsLCExKSxjLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Nb3VzZVNjcm9sbFwiLHRoaXMuX3doZWVsLCExKSxhLlRvb2xzLlJlZ2lzdGVyVG9wUm9vdEV2ZW50cyhbe25hbWU6XCJrZXlkb3duXCIsaGFuZGxlcjp0aGlzLl9vbktleURvd259LHtuYW1lOlwia2V5dXBcIixoYW5kbGVyOnRoaXMuX29uS2V5VXB9LHtuYW1lOlwiYmx1clwiLGhhbmRsZXI6dGhpcy5fb25Mb3N0Rm9jdXN9XSl9fSxkLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKGMpe3RoaXMuX2F0dGFjaGVkRWxlbWVudD09YyYmKGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1wiZG93blwiLHRoaXMuX29uUG9pbnRlckRvd24pLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1widXBcIix0aGlzLl9vblBvaW50ZXJVcCksYy5yZW1vdmVFdmVudExpc3RlbmVyKGIrXCJvdXRcIix0aGlzLl9vblBvaW50ZXJVcCksYy5yZW1vdmVFdmVudExpc3RlbmVyKGIrXCJtb3ZlXCIsdGhpcy5fb25Qb2ludGVyTW92ZSksYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUpLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIix0aGlzLl9vbkdlc3R1cmVTdGFydCksYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNHZXN0dXJlQ2hhbmdlXCIsdGhpcy5fb25HZXN0dXJlKSxjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXdoZWVsXCIsdGhpcy5fd2hlZWwpLGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU1vdXNlU2Nyb2xsXCIsdGhpcy5fd2hlZWwpLGEuVG9vbHMuVW5yZWdpc3RlclRvcFJvb3RFdmVudHMoW3tuYW1lOlwia2V5ZG93blwiLGhhbmRsZXI6dGhpcy5fb25LZXlEb3dufSx7bmFtZTpcImtleXVwXCIsaGFuZGxlcjp0aGlzLl9vbktleVVwfSx7bmFtZTpcImJsdXJcIixoYW5kbGVyOnRoaXMuX29uTG9zdEZvY3VzfV0pLHRoaXMuX01TR2VzdHVyZUhhbmRsZXI9bnVsbCx0aGlzLl9hdHRhY2hlZEVsZW1lbnQ9bnVsbCx0aGlzLl9yZXNldCYmdGhpcy5fcmVzZXQoKSl9LGQucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGI9MDtiPHRoaXMuX2tleXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fa2V5c1tiXTstMSE9PXRoaXMua2V5c0xlZnQuaW5kZXhPZihjKT90aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQtPS4wMTotMSE9PXRoaXMua2V5c1VwLmluZGV4T2YoYyk/dGhpcy5pbmVydGlhbEJldGFPZmZzZXQtPS4wMTotMSE9PXRoaXMua2V5c1JpZ2h0LmluZGV4T2YoYyk/dGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0Kz0uMDE6LTEhPT10aGlzLmtleXNEb3duLmluZGV4T2YoYykmJih0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCs9LjAxKX0oMCE9dGhpcy5pbmVydGlhbEFscGhhT2Zmc2V0fHwwIT10aGlzLmluZXJ0aWFsQmV0YU9mZnNldHx8MCE9dGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCkmJih0aGlzLmFscGhhKz10aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQsdGhpcy5iZXRhKz10aGlzLmluZXJ0aWFsQmV0YU9mZnNldCx0aGlzLnJhZGl1cy09dGhpcy5pbmVydGlhbFJhZGl1c09mZnNldCx0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQqPXRoaXMuaW5lcnRpYSx0aGlzLmluZXJ0aWFsQmV0YU9mZnNldCo9dGhpcy5pbmVydGlhLHRoaXMuaW5lcnRpYWxSYWRpdXNPZmZzZXQqPXRoaXMuaW5lcnRpYSxNYXRoLmFicyh0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQpPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmluZXJ0aWFsQWxwaGFPZmZzZXQ9MCksTWF0aC5hYnModGhpcy5pbmVydGlhbEJldGFPZmZzZXQpPGEuRW5naW5lLkVwc2lsb24mJih0aGlzLmluZXJ0aWFsQmV0YU9mZnNldD0wKSxNYXRoLmFicyh0aGlzLmluZXJ0aWFsUmFkaXVzT2Zmc2V0KTxhLkVuZ2luZS5FcHNpbG9uJiYodGhpcy5pbmVydGlhbFJhZGl1c09mZnNldD0wKSksdGhpcy5sb3dlckFscGhhTGltaXQmJnRoaXMuYWxwaGE8dGhpcy5sb3dlckFscGhhTGltaXQmJih0aGlzLmFscGhhPXRoaXMubG93ZXJBbHBoYUxpbWl0KSx0aGlzLnVwcGVyQWxwaGFMaW1pdCYmdGhpcy5hbHBoYT50aGlzLnVwcGVyQWxwaGFMaW1pdCYmKHRoaXMuYWxwaGE9dGhpcy51cHBlckFscGhhTGltaXQpLHRoaXMubG93ZXJCZXRhTGltaXQmJnRoaXMuYmV0YTx0aGlzLmxvd2VyQmV0YUxpbWl0JiYodGhpcy5iZXRhPXRoaXMubG93ZXJCZXRhTGltaXQpLHRoaXMudXBwZXJCZXRhTGltaXQmJnRoaXMuYmV0YT50aGlzLnVwcGVyQmV0YUxpbWl0JiYodGhpcy5iZXRhPXRoaXMudXBwZXJCZXRhTGltaXQpLHRoaXMubG93ZXJSYWRpdXNMaW1pdCYmdGhpcy5yYWRpdXM8dGhpcy5sb3dlclJhZGl1c0xpbWl0JiYodGhpcy5yYWRpdXM9dGhpcy5sb3dlclJhZGl1c0xpbWl0KSx0aGlzLnVwcGVyUmFkaXVzTGltaXQmJnRoaXMucmFkaXVzPnRoaXMudXBwZXJSYWRpdXNMaW1pdCYmKHRoaXMucmFkaXVzPXRoaXMudXBwZXJSYWRpdXNMaW1pdCl9LGQucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPWEuc3VidHJhY3QodGhpcy5fZ2V0VGFyZ2V0UG9zaXRpb24oKSk7dGhpcy5yYWRpdXM9Yi5sZW5ndGgoKSx0aGlzLmFscGhhPU1hdGguYWNvcyhiLngvTWF0aC5zcXJ0KE1hdGgucG93KGIueCwyKStNYXRoLnBvdyhiLnosMikpKSxiLno8MCYmKHRoaXMuYWxwaGE9MipNYXRoLlBJLXRoaXMuYWxwaGEpLHRoaXMuYmV0YT1NYXRoLmFjb3MoYi55L3RoaXMucmFkaXVzKX0sZC5wcm90b3R5cGUuX2dldFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXt2YXIgYj1NYXRoLmNvcyh0aGlzLmFscGhhKSxjPU1hdGguc2luKHRoaXMuYWxwaGEpLGQ9TWF0aC5jb3ModGhpcy5iZXRhKSxlPU1hdGguc2luKHRoaXMuYmV0YSksZj10aGlzLl9nZXRUYXJnZXRQb3NpdGlvbigpO3JldHVybiBmLmFkZFRvUmVmKG5ldyBhLlZlY3RvcjModGhpcy5yYWRpdXMqYiplLHRoaXMucmFkaXVzKmQsdGhpcy5yYWRpdXMqYyplKSx0aGlzLnBvc2l0aW9uKSx0aGlzLmNoZWNrQ29sbGlzaW9ucyYmKHRoaXMuX2NvbGxpZGVyLnJhZGl1cz10aGlzLmNvbGxpc2lvblJhZGl1cyx0aGlzLnBvc2l0aW9uLnN1YnRyYWN0VG9SZWYodGhpcy5fcHJldmlvdXNQb3NpdGlvbix0aGlzLl9jb2xsaXNpb25WZWxvY2l0eSksdGhpcy5nZXRTY2VuZSgpLl9nZXROZXdQb3NpdGlvbih0aGlzLl9wcmV2aW91c1Bvc2l0aW9uLHRoaXMuX2NvbGxpc2lvblZlbG9jaXR5LHRoaXMuX2NvbGxpZGVyLDMsdGhpcy5fbmV3UG9zaXRpb24pLHRoaXMuX25ld1Bvc2l0aW9uLmVxdWFsc1dpdGhFcHNpbG9uKHRoaXMucG9zaXRpb24pfHwodGhpcy5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLl9wcmV2aW91c1Bvc2l0aW9uKSx0aGlzLmFscGhhPXRoaXMuX3ByZXZpb3VzQWxwaGEsdGhpcy5iZXRhPXRoaXMuX3ByZXZpb3VzQmV0YSx0aGlzLnJhZGl1cz10aGlzLl9wcmV2aW91c1JhZGl1cyx0aGlzLm9uQ29sbGlkZSYmdGhpcy5vbkNvbGxpZGUodGhpcy5fY29sbGlkZXIuY29sbGlkZWRNZXNoKSkpLGEuTWF0cml4Lkxvb2tBdExIVG9SZWYodGhpcy5wb3NpdGlvbixmLHRoaXMudXBWZWN0b3IsdGhpcy5fdmlld01hdHJpeCksdGhpcy5fcHJldmlvdXNBbHBoYT10aGlzLmFscGhhLHRoaXMuX3ByZXZpb3VzQmV0YT10aGlzLmJldGEsdGhpcy5fcHJldmlvdXNSYWRpdXM9dGhpcy5yYWRpdXMsdGhpcy5fcHJldmlvdXNQb3NpdGlvbi5jb3B5RnJvbSh0aGlzLnBvc2l0aW9uKSx0aGlzLl92aWV3TWF0cml4fSxkLnByb3RvdHlwZS56b29tT249ZnVuY3Rpb24oYil7Yj1ifHx0aGlzLmdldFNjZW5lKCkubWVzaGVzO3ZhciBjPWEuTWVzaC5NaW5NYXgoYiksZD1hLlZlY3RvcjMuRGlzdGFuY2UoYy5taW4sYy5tYXgpO3RoaXMucmFkaXVzPWQqdGhpcy56b29tT25GYWN0b3IsdGhpcy5mb2N1c09uKHttaW46Yy5taW4sbWF4OmMubWF4LGRpc3RhbmNlOmR9KX0sZC5wcm90b3R5cGUuZm9jdXNPbj1mdW5jdGlvbihiKXt2YXIgYyxkO3ZvaWQgMD09PWIubWluPyhjPWJ8fHRoaXMuZ2V0U2NlbmUoKS5tZXNoZXMsYz1hLk1lc2guTWluTWF4KGMpLGQ9YS5WZWN0b3IzLkRpc3RhbmNlKGMubWluLGMubWF4KSk6KGM9YixkPWIuZGlzdGFuY2UpLHRoaXMudGFyZ2V0PWEuTWVzaC5DZW50ZXIoYyksdGhpcy5tYXhaPTIqZH0sZH0oYS5DYW1lcmEpO2EuQXJjUm90YXRlQ2FtZXJhPWN9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiKXt0aGlzLmF1dG9DbGVhcj0hMCx0aGlzLmNsZWFyQ29sb3I9bmV3IGEuQ29sb3IzKC4yLC4yLC4zKSx0aGlzLmFtYmllbnRDb2xvcj1uZXcgYS5Db2xvcjMoMCwwLDApLHRoaXMuZm9yY2VXaXJlZnJhbWU9ITEsdGhpcy5jYW1lcmFUb1VzZUZvclBvaW50ZXJzPW51bGwsdGhpcy5mb2dNb2RlPWEuU2NlbmUuRk9HTU9ERV9OT05FLHRoaXMuZm9nQ29sb3I9bmV3IGEuQ29sb3IzKC4yLC4yLC4zKSx0aGlzLmZvZ0RlbnNpdHk9LjEsdGhpcy5mb2dTdGFydD0wLHRoaXMuZm9nRW5kPTFlMyx0aGlzLmxpZ2h0c0VuYWJsZWQ9ITAsdGhpcy5saWdodHM9bmV3IEFycmF5LHRoaXMuY2FtZXJhcz1uZXcgQXJyYXksdGhpcy5hY3RpdmVDYW1lcmFzPW5ldyBBcnJheSx0aGlzLm1lc2hlcz1uZXcgQXJyYXksdGhpcy5fZ2VvbWV0cmllcz1uZXcgQXJyYXksdGhpcy5tYXRlcmlhbHM9bmV3IEFycmF5LHRoaXMubXVsdGlNYXRlcmlhbHM9bmV3IEFycmF5LHRoaXMuZGVmYXVsdE1hdGVyaWFsPW5ldyBhLlN0YW5kYXJkTWF0ZXJpYWwoXCJkZWZhdWx0IG1hdGVyaWFsXCIsdGhpcyksdGhpcy50ZXh0dXJlc0VuYWJsZWQ9ITAsdGhpcy50ZXh0dXJlcz1uZXcgQXJyYXksdGhpcy5wYXJ0aWNsZXNFbmFibGVkPSEwLHRoaXMucGFydGljbGVTeXN0ZW1zPW5ldyBBcnJheSx0aGlzLnNwcml0ZU1hbmFnZXJzPW5ldyBBcnJheSx0aGlzLmxheWVycz1uZXcgQXJyYXksdGhpcy5za2VsZXRvbnM9bmV3IEFycmF5LHRoaXMubGVuc0ZsYXJlU3lzdGVtcz1uZXcgQXJyYXksdGhpcy5jb2xsaXNpb25zRW5hYmxlZD0hMCx0aGlzLmdyYXZpdHk9bmV3IGEuVmVjdG9yMygwLC05LDApLHRoaXMucG9zdFByb2Nlc3Nlc0VuYWJsZWQ9ITAsdGhpcy5yZW5kZXJUYXJnZXRzRW5hYmxlZD0hMCx0aGlzLmN1c3RvbVJlbmRlclRhcmdldHM9bmV3IEFycmF5LHRoaXMuaW1wb3J0ZWRNZXNoZXNGaWxlcz1uZXcgQXJyYXksdGhpcy5fYWN0aW9uTWFuYWdlcnM9bmV3IEFycmF5LHRoaXMuX21lc2hlc0ZvckludGVyc2VjdGlvbnM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX3RvdGFsVmVydGljZXM9MCx0aGlzLl9hY3RpdmVWZXJ0aWNlcz0wLHRoaXMuX2FjdGl2ZVBhcnRpY2xlcz0wLHRoaXMuX2xhc3RGcmFtZUR1cmF0aW9uPTAsdGhpcy5fZXZhbHVhdGVBY3RpdmVNZXNoZXNEdXJhdGlvbj0wLHRoaXMuX3JlbmRlclRhcmdldHNEdXJhdGlvbj0wLHRoaXMuX3BhcnRpY2xlc0R1cmF0aW9uPTAsdGhpcy5fcmVuZGVyRHVyYXRpb249MCx0aGlzLl9zcHJpdGVzRHVyYXRpb249MCx0aGlzLl9hbmltYXRpb25SYXRpbz0wLHRoaXMuX3JlbmRlcklkPTAsdGhpcy5fZXhlY3V0ZVdoZW5SZWFkeVRpbWVvdXRJZD0tMSx0aGlzLl90b0JlRGlzcG9zZWQ9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX29uUmVhZHlDYWxsYmFja3M9bmV3IEFycmF5LHRoaXMuX3BlbmRpbmdEYXRhPVtdLHRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzPW5ldyBBcnJheSx0aGlzLl9hY3RpdmVNZXNoZXM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX3Byb2Nlc3NlZE1hdGVyaWFscz1uZXcgYS5TbWFydEFycmF5KDI1NiksdGhpcy5fcmVuZGVyVGFyZ2V0cz1uZXcgYS5TbWFydEFycmF5KDI1NiksdGhpcy5fYWN0aXZlUGFydGljbGVTeXN0ZW1zPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl9hY3RpdmVTa2VsZXRvbnM9bmV3IGEuU21hcnRBcnJheSgzMiksdGhpcy5fYWN0aXZlQW5pbWF0YWJsZXM9bmV3IEFycmF5LHRoaXMuX3RyYW5zZm9ybU1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fc2NhbGVkUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9zY2FsZWRWZWxvY2l0eT1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2VuZ2luZT1iLGIuc2NlbmVzLnB1c2godGhpcyksdGhpcy5fcmVuZGVyaW5nTWFuYWdlcj1uZXcgYS5SZW5kZXJpbmdNYW5hZ2VyKHRoaXMpLHRoaXMucG9zdFByb2Nlc3NNYW5hZ2VyPW5ldyBhLlBvc3RQcm9jZXNzTWFuYWdlcih0aGlzKSx0aGlzLnBvc3RQcm9jZXNzUmVuZGVyUGlwZWxpbmVNYW5hZ2VyPW5ldyBhLlBvc3RQcm9jZXNzUmVuZGVyUGlwZWxpbmVNYW5hZ2VyLHRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXI9bmV3IGEuQm91bmRpbmdCb3hSZW5kZXJlcih0aGlzKSx0aGlzLmF0dGFjaENvbnRyb2woKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwibWVzaFVuZGVyUG9pbnRlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWVzaFVuZGVyUG9pbnRlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJwb2ludGVyWFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcG9pbnRlclh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwicG9pbnRlcllcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvaW50ZXJZfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLmdldEJvdW5kaW5nQm94UmVuZGVyZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRpbmdCb3hSZW5kZXJlcn0sYi5wcm90b3R5cGUuZ2V0RW5naW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuZ2luZX0sYi5wcm90b3R5cGUuZ2V0VG90YWxWZXJ0aWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90b3RhbFZlcnRpY2VzfSxiLnByb3RvdHlwZS5nZXRBY3RpdmVWZXJ0aWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hY3RpdmVWZXJ0aWNlc30sYi5wcm90b3R5cGUuZ2V0QWN0aXZlUGFydGljbGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FjdGl2ZVBhcnRpY2xlc30sYi5wcm90b3R5cGUuZ2V0TGFzdEZyYW1lRHVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGFzdEZyYW1lRHVyYXRpb259LGIucHJvdG90eXBlLmdldEV2YWx1YXRlQWN0aXZlTWVzaGVzRHVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXZhbHVhdGVBY3RpdmVNZXNoZXNEdXJhdGlvbn0sYi5wcm90b3R5cGUuZ2V0QWN0aXZlTWVzaGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FjdGl2ZU1lc2hlc30sYi5wcm90b3R5cGUuZ2V0UmVuZGVyVGFyZ2V0c0R1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldHNEdXJhdGlvbn0sYi5wcm90b3R5cGUuZ2V0UmVuZGVyRHVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyRHVyYXRpb259LGIucHJvdG90eXBlLmdldFBhcnRpY2xlc0R1cmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhcnRpY2xlc0R1cmF0aW9ufSxiLnByb3RvdHlwZS5nZXRTcHJpdGVzRHVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ByaXRlc0R1cmF0aW9ufSxiLnByb3RvdHlwZS5nZXRBbmltYXRpb25SYXRpbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbmltYXRpb25SYXRpb30sYi5wcm90b3R5cGUuZ2V0UmVuZGVySWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVySWR9LGIucHJvdG90eXBlLl91cGRhdGVQb2ludGVyUG9zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhc0NsaWVudFJlY3QoKTt0aGlzLl9wb2ludGVyWD1hLmNsaWVudFgtYi5sZWZ0LHRoaXMuX3BvaW50ZXJZPWEuY2xpZW50WS1iLnRvcCx0aGlzLmNhbWVyYVRvVXNlRm9yUG9pbnRlcnMmJih0aGlzLl9wb2ludGVyWD10aGlzLl9wb2ludGVyWC10aGlzLmNhbWVyYVRvVXNlRm9yUG9pbnRlcnMudmlld3BvcnQueCp0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyV2lkdGgoKSx0aGlzLl9wb2ludGVyWT10aGlzLl9wb2ludGVyWS10aGlzLmNhbWVyYVRvVXNlRm9yUG9pbnRlcnMudmlld3BvcnQueSp0aGlzLl9lbmdpbmUuZ2V0UmVuZGVySGVpZ2h0KCkpfSxiLnByb3RvdHlwZS5hdHRhY2hDb250cm9sPWZ1bmN0aW9uKCl7dmFyIGI9dGhpczt0aGlzLl9vblBvaW50ZXJNb3ZlPWZ1bmN0aW9uKGEpe3ZhciBjPWIuX2VuZ2luZS5nZXRSZW5kZXJpbmdDYW52YXMoKTtiLl91cGRhdGVQb2ludGVyUG9zaXRpb24oYSk7dmFyIGQ9Yi5waWNrKGIuX3BvaW50ZXJYLGIuX3BvaW50ZXJZLGZ1bmN0aW9uKGEpe3JldHVybiBhLmlzUGlja2FibGUmJmEuaXNWaXNpYmxlJiZhLmlzUmVhZHkoKSYmYS5hY3Rpb25NYW5hZ2VyJiZhLmFjdGlvbk1hbmFnZXIuaGFzUG9pbnRlclRyaWdnZXJzfSwhMSxiLmNhbWVyYVRvVXNlRm9yUG9pbnRlcnMpO2QuaGl0PyhiLnNldFBvaW50ZXJPdmVyTWVzaChkLnBpY2tlZE1lc2gpLGMuc3R5bGUuY3Vyc29yPVwicG9pbnRlclwiLGIuX21lc2hVbmRlclBvaW50ZXI9ZC5waWNrZWRNZXNoKTooYi5zZXRQb2ludGVyT3Zlck1lc2gobnVsbCksYy5zdHlsZS5jdXJzb3I9XCJcIixiLl9tZXNoVW5kZXJQb2ludGVyPW51bGwpfSx0aGlzLl9vblBvaW50ZXJEb3duPWZ1bmN0aW9uKGMpe3ZhciBkPW51bGw7Yi5vblBvaW50ZXJEb3dufHwoZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5pc1BpY2thYmxlJiZhLmlzVmlzaWJsZSYmYS5pc1JlYWR5KCkmJmEuYWN0aW9uTWFuYWdlciYmYS5hY3Rpb25NYW5hZ2VyLmhhc1BpY2tUcmlnZ2Vyc30pLGIuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihjKTt2YXIgZT1iLnBpY2soYi5fcG9pbnRlclgsYi5fcG9pbnRlclksZCwhMSxiLmNhbWVyYVRvVXNlRm9yUG9pbnRlcnMpO2lmKGUuaGl0JiZlLnBpY2tlZE1lc2guYWN0aW9uTWFuYWdlcil7c3dpdGNoKGMuYnV0dG9uKXtjYXNlIDA6ZS5waWNrZWRNZXNoLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uTGVmdFBpY2tUcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3KGUucGlja2VkTWVzaCkpO2JyZWFrO2Nhc2UgMTplLnBpY2tlZE1lc2guYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25DZW50ZXJQaWNrVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyhlLnBpY2tlZE1lc2gpKTticmVhaztjYXNlIDI6ZS5waWNrZWRNZXNoLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uUmlnaHRQaWNrVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyhlLnBpY2tlZE1lc2gpKX1lLnBpY2tlZE1lc2guYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25QaWNrVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyhlLnBpY2tlZE1lc2gpKX1iLm9uUG9pbnRlckRvd24mJmIub25Qb2ludGVyRG93bihjLGUpfSx0aGlzLl9vbktleURvd249ZnVuY3Rpb24oYyl7Yi5hY3Rpb25NYW5hZ2VyJiZiLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uS2V5RG93blRyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXdGcm9tU2NlbmUoYixjKSl9LHRoaXMuX29uS2V5VXA9ZnVuY3Rpb24oYyl7Yi5hY3Rpb25NYW5hZ2VyJiZiLmFjdGlvbk1hbmFnZXIucHJvY2Vzc1RyaWdnZXIoYS5BY3Rpb25NYW5hZ2VyLk9uS2V5VXBUcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3RnJvbVNjZW5lKGIsYykpfTt2YXIgYz1hLlRvb2xzLkdldFBvaW50ZXJQcmVmaXgoKTt0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCkuYWRkRXZlbnRMaXN0ZW5lcihjK1wibW92ZVwiLHRoaXMuX29uUG9pbnRlck1vdmUsITEpLHRoaXMuX2VuZ2luZS5nZXRSZW5kZXJpbmdDYW52YXMoKS5hZGRFdmVudExpc3RlbmVyKGMrXCJkb3duXCIsdGhpcy5fb25Qb2ludGVyRG93biwhMSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duLCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5fb25LZXlVcCwhMSl9LGIucHJvdG90eXBlLmRldGFjaENvbnRyb2w9ZnVuY3Rpb24oKXt2YXIgYj1hLlRvb2xzLkdldFBvaW50ZXJQcmVmaXgoKTt0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihiK1wibW92ZVwiLHRoaXMuX29uUG9pbnRlck1vdmUpLHRoaXMuX2VuZ2luZS5nZXRSZW5kZXJpbmdDYW52YXMoKS5yZW1vdmVFdmVudExpc3RlbmVyKGIrXCJkb3duXCIsdGhpcy5fb25Qb2ludGVyRG93biksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5fb25LZXlVcCl9LGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXtpZih0aGlzLl9wZW5kaW5nRGF0YS5sZW5ndGg+MClyZXR1cm4hMTtmb3IodmFyIGI9MDtiPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fZ2VvbWV0cmllc1tiXTtpZihjLmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORylyZXR1cm4hMX1mb3IoYj0wO2I8dGhpcy5tZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGQ9dGhpcy5tZXNoZXNbYl07aWYoIWQuaXNSZWFkeSgpKXJldHVybiExO3ZhciBlPWQubWF0ZXJpYWw7aWYoZSYmIWUuaXNSZWFkeShkKSlyZXR1cm4hMX1yZXR1cm4hMH0sYi5wcm90b3R5cGUucmVnaXN0ZXJCZWZvcmVSZW5kZXI9ZnVuY3Rpb24oYSl7dGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3MucHVzaChhKX0sYi5wcm90b3R5cGUudW5yZWdpc3RlckJlZm9yZVJlbmRlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcy5pbmRleE9mKGEpO2I+LTEmJnRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLnNwbGljZShiLDEpfSxiLnByb3RvdHlwZS5fYWRkUGVuZGluZ0RhdGE9ZnVuY3Rpb24oYSl7dGhpcy5fcGVuZGluZ0RhdGEucHVzaChhKX0sYi5wcm90b3R5cGUuX3JlbW92ZVBlbmRpbmdEYXRhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX3BlbmRpbmdEYXRhLmluZGV4T2YoYSk7LTEhPT1iJiZ0aGlzLl9wZW5kaW5nRGF0YS5zcGxpY2UoYiwxKX0sYi5wcm90b3R5cGUuZ2V0V2FpdGluZ0l0ZW1zQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGVuZGluZ0RhdGEubGVuZ3RofSxiLnByb3RvdHlwZS5leGVjdXRlV2hlblJlYWR5PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5fb25SZWFkeUNhbGxiYWNrcy5wdXNoKGEpLC0xPT09dGhpcy5fZXhlY3V0ZVdoZW5SZWFkeVRpbWVvdXRJZCYmKHRoaXMuX2V4ZWN1dGVXaGVuUmVhZHlUaW1lb3V0SWQ9c2V0VGltZW91dChmdW5jdGlvbigpe2IuX2NoZWNrSXNSZWFkeSgpfSwxNTApKX0sYi5wcm90b3R5cGUuX2NoZWNrSXNSZWFkeT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuaXNSZWFkeSgpPyh0aGlzLl9vblJlYWR5Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oYSl7YSgpfSksdGhpcy5fb25SZWFkeUNhbGxiYWNrcz1bXSx2b2lkKHRoaXMuX2V4ZWN1dGVXaGVuUmVhZHlUaW1lb3V0SWQ9LTEpKTp2b2lkKHRoaXMuX2V4ZWN1dGVXaGVuUmVhZHlUaW1lb3V0SWQ9c2V0VGltZW91dChmdW5jdGlvbigpe2EuX2NoZWNrSXNSZWFkeSgpfSwxNTApKX0sYi5wcm90b3R5cGUuYmVnaW5BbmltYXRpb249ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCl7aWYodm9pZCAwPT09ZiYmKGY9MSksdGhpcy5zdG9wQW5pbWF0aW9uKGIpLGh8fChoPW5ldyBhLkFuaW1hdGFibGUodGhpcyxiLGMsZCxlLGYsZykpLGIuYW5pbWF0aW9ucyYmaC5hcHBlbmRBbmltYXRpb25zKGIsYi5hbmltYXRpb25zKSxiLmdldEFuaW1hdGFibGVzKWZvcih2YXIgaT1iLmdldEFuaW1hdGFibGVzKCksaj0wO2o8aS5sZW5ndGg7aisrKXRoaXMuYmVnaW5BbmltYXRpb24oaVtqXSxjLGQsZSxmLGcsaCk7cmV0dXJuIGh9LGIucHJvdG90eXBlLmJlZ2luRGlyZWN0QW5pbWF0aW9uPWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgpe3ZvaWQgMD09PWcmJihnPTEpO3ZhciBpPW5ldyBhLkFuaW1hdGFibGUodGhpcyxiLGQsZSxmLGcsaCxjKTtyZXR1cm4gaX0sYi5wcm90b3R5cGUuZ2V0QW5pbWF0YWJsZUJ5VGFyZ2V0PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fYWN0aXZlQW5pbWF0YWJsZXMubGVuZ3RoO2IrKylpZih0aGlzLl9hY3RpdmVBbmltYXRhYmxlc1tiXS50YXJnZXQ9PT1hKXJldHVybiB0aGlzLl9hY3RpdmVBbmltYXRhYmxlc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldEFuaW1hdGFibGVCeVRhcmdldChhKTtiJiZiLnN0b3AoKX0sYi5wcm90b3R5cGUuX2FuaW1hdGU9ZnVuY3Rpb24oKXt0aGlzLl9hbmltYXRpb25TdGFydERhdGV8fCh0aGlzLl9hbmltYXRpb25TdGFydERhdGU9KG5ldyBEYXRlKS5nZXRUaW1lKCkpO2Zvcih2YXIgYT0obmV3IERhdGUpLmdldFRpbWUoKSxiPWEtdGhpcy5fYW5pbWF0aW9uU3RhcnREYXRlLGM9MDtjPHRoaXMuX2FjdGl2ZUFuaW1hdGFibGVzLmxlbmd0aDtjKyspdGhpcy5fYWN0aXZlQW5pbWF0YWJsZXNbY10uX2FuaW1hdGUoYil8fCh0aGlzLl9hY3RpdmVBbmltYXRhYmxlcy5zcGxpY2UoYywxKSxjLS0pXG59LGIucHJvdG90eXBlLmdldFZpZXdNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmlld01hdHJpeH0sYi5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbk1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9qZWN0aW9uTWF0cml4fSxiLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1NYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHJhbnNmb3JtTWF0cml4fSxiLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm1NYXRyaXg9ZnVuY3Rpb24oYSxiKXt0aGlzLl92aWV3TWF0cml4PWEsdGhpcy5fcHJvamVjdGlvbk1hdHJpeD1iLHRoaXMuX3ZpZXdNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9wcm9qZWN0aW9uTWF0cml4LHRoaXMuX3RyYW5zZm9ybU1hdHJpeCl9LGIucHJvdG90eXBlLnNldEFjdGl2ZUNhbWVyYUJ5SUQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDYW1lcmFCeUlEKGEpO3JldHVybiBiPyh0aGlzLmFjdGl2ZUNhbWVyYT1iLGIpOm51bGx9LGIucHJvdG90eXBlLnNldEFjdGl2ZUNhbWVyYUJ5TmFtZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdldENhbWVyYUJ5TmFtZShhKTtyZXR1cm4gYj8odGhpcy5hY3RpdmVDYW1lcmE9YixiKTpudWxsfSxiLnByb3RvdHlwZS5nZXRNYXRlcmlhbEJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLm1hdGVyaWFscy5sZW5ndGg7YisrKWlmKHRoaXMubWF0ZXJpYWxzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5tYXRlcmlhbHNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldE1hdGVyaWFsQnlOYW1lPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5tYXRlcmlhbHMubGVuZ3RoO2IrKylpZih0aGlzLm1hdGVyaWFsc1tiXS5uYW1lPT09YSlyZXR1cm4gdGhpcy5tYXRlcmlhbHNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldENhbWVyYUJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmNhbWVyYXMubGVuZ3RoO2IrKylpZih0aGlzLmNhbWVyYXNbYl0uaWQ9PT1hKXJldHVybiB0aGlzLmNhbWVyYXNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldENhbWVyYUJ5TmFtZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuY2FtZXJhcy5sZW5ndGg7YisrKWlmKHRoaXMuY2FtZXJhc1tiXS5uYW1lPT09YSlyZXR1cm4gdGhpcy5jYW1lcmFzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRMaWdodEJ5TmFtZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMubGlnaHRzLmxlbmd0aDtiKyspaWYodGhpcy5saWdodHNbYl0ubmFtZT09PWEpcmV0dXJuIHRoaXMubGlnaHRzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRMaWdodEJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmxpZ2h0cy5sZW5ndGg7YisrKWlmKHRoaXMubGlnaHRzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5saWdodHNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldEdlb21ldHJ5QnlJRD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2IrKylpZih0aGlzLl9nZW9tZXRyaWVzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUucHVzaEdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIWImJnRoaXMuZ2V0R2VvbWV0cnlCeUlEKGEuaWQpPyExOih0aGlzLl9nZW9tZXRyaWVzLnB1c2goYSksITApfSxiLnByb3RvdHlwZS5nZXRHZW9tZXRyaWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJpZXN9LGIucHJvdG90eXBlLmdldE1lc2hCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5tZXNoZXMubGVuZ3RoO2IrKylpZih0aGlzLm1lc2hlc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubWVzaGVzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRMYXN0TWVzaEJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMubWVzaGVzLmxlbmd0aC0xO2I+PTA7Yi0tKWlmKHRoaXMubWVzaGVzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5tZXNoZXNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldExhc3RFbnRyeUJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMubWVzaGVzLmxlbmd0aC0xO2I+PTA7Yi0tKWlmKHRoaXMubWVzaGVzW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5tZXNoZXNbYl07Zm9yKGI9dGhpcy5jYW1lcmFzLmxlbmd0aC0xO2I+PTA7Yi0tKWlmKHRoaXMuY2FtZXJhc1tiXS5pZD09PWEpcmV0dXJuIHRoaXMuY2FtZXJhc1tiXTtmb3IoYj10aGlzLmxpZ2h0cy5sZW5ndGgtMTtiPj0wO2ItLSlpZih0aGlzLmxpZ2h0c1tiXS5pZD09PWEpcmV0dXJuIHRoaXMubGlnaHRzW2JdO3JldHVybiBudWxsfSxiLnByb3RvdHlwZS5nZXRNZXNoQnlOYW1lPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5tZXNoZXMubGVuZ3RoO2IrKylpZih0aGlzLm1lc2hlc1tiXS5uYW1lPT09YSlyZXR1cm4gdGhpcy5tZXNoZXNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldExhc3RTa2VsZXRvbkJ5SUQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuc2tlbGV0b25zLmxlbmd0aC0xO2I+PTA7Yi0tKWlmKHRoaXMuc2tlbGV0b25zW2JdLmlkPT09YSlyZXR1cm4gdGhpcy5za2VsZXRvbnNbYl07cmV0dXJuIG51bGx9LGIucHJvdG90eXBlLmdldFNrZWxldG9uQnlJZD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuc2tlbGV0b25zLmxlbmd0aDtiKyspaWYodGhpcy5za2VsZXRvbnNbYl0uaWQ9PT1hKXJldHVybiB0aGlzLnNrZWxldG9uc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0U2tlbGV0b25CeU5hbWU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLnNrZWxldG9ucy5sZW5ndGg7YisrKWlmKHRoaXMuc2tlbGV0b25zW2JdLm5hbWU9PT1hKXJldHVybiB0aGlzLnNrZWxldG9uc1tiXTtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuaXNBY3RpdmVNZXNoPWZ1bmN0aW9uKGEpe3JldHVybi0xIT09dGhpcy5fYWN0aXZlTWVzaGVzLmluZGV4T2YoYSl9LGIucHJvdG90eXBlLl9ldmFsdWF0ZVN1Yk1lc2g9ZnVuY3Rpb24oYSxiKXtpZigxPT1iLnN1Yk1lc2hlcy5sZW5ndGh8fGEuaXNJbkZydXN0dW0odGhpcy5fZnJ1c3R1bVBsYW5lcykpe3ZhciBjPWEuZ2V0TWF0ZXJpYWwoKTtiLnNob3dTdWJNZXNoZXNCb3VuZGluZ0JveCYmdGhpcy5fYm91bmRpbmdCb3hSZW5kZXJlci5yZW5kZXJMaXN0LnB1c2goYS5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveCksYyYmKGMuZ2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMmJi0xPT09dGhpcy5fcHJvY2Vzc2VkTWF0ZXJpYWxzLmluZGV4T2YoYykmJih0aGlzLl9wcm9jZXNzZWRNYXRlcmlhbHMucHVzaChjKSx0aGlzLl9yZW5kZXJUYXJnZXRzLmNvbmNhdChjLmdldFJlbmRlclRhcmdldFRleHR1cmVzKCkpKSx0aGlzLl9hY3RpdmVWZXJ0aWNlcys9YS52ZXJ0aWNlc0NvdW50LHRoaXMuX3JlbmRlcmluZ01hbmFnZXIuZGlzcGF0Y2goYSkpfX0sYi5wcm90b3R5cGUuX2V2YWx1YXRlQWN0aXZlTWVzaGVzPWZ1bmN0aW9uKCl7dGhpcy5fYWN0aXZlTWVzaGVzLnJlc2V0KCksdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZXNldCgpLHRoaXMuX3Byb2Nlc3NlZE1hdGVyaWFscy5yZXNldCgpLHRoaXMuX2FjdGl2ZVBhcnRpY2xlU3lzdGVtcy5yZXNldCgpLHRoaXMuX2FjdGl2ZVNrZWxldG9ucy5yZXNldCgpLHRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXIucmVzZXQoKSx0aGlzLl9mcnVzdHVtUGxhbmVzP2EuRnJ1c3R1bS5HZXRQbGFuZXNUb1JlZih0aGlzLl90cmFuc2Zvcm1NYXRyaXgsdGhpcy5fZnJ1c3R1bVBsYW5lcyk6dGhpcy5fZnJ1c3R1bVBsYW5lcz1hLkZydXN0dW0uR2V0UGxhbmVzKHRoaXMuX3RyYW5zZm9ybU1hdHJpeCk7dmFyIGIsYztpZih0aGlzLl9zZWxlY3Rpb25PY3RyZWUpe3ZhciBkPXRoaXMuX3NlbGVjdGlvbk9jdHJlZS5zZWxlY3QodGhpcy5fZnJ1c3R1bVBsYW5lcyk7Yj1kLmRhdGEsYz1kLmxlbmd0aH1lbHNlIGM9dGhpcy5tZXNoZXMubGVuZ3RoLGI9dGhpcy5tZXNoZXM7Zm9yKHZhciBlPTA7Yz5lO2UrKyl7dmFyIGY9YltlXTt0aGlzLl90b3RhbFZlcnRpY2VzKz1mLmdldFRvdGFsVmVydGljZXMoKSxmLmlzUmVhZHkoKSYmKGYuY29tcHV0ZVdvcmxkTWF0cml4KCksZi5fcHJlQWN0aXZhdGUoKSxmLmFjdGlvbk1hbmFnZXImJmYuYWN0aW9uTWFuYWdlci5oYXNTcGVjaWZpY1RyaWdnZXJzKFthLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FbnRlclRyaWdnZXIsYS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRXhpdFRyaWdnZXJdKSYmdGhpcy5fbWVzaGVzRm9ySW50ZXJzZWN0aW9ucy5wdXNoTm9EdXBsaWNhdGUoZiksZi5pc0VuYWJsZWQoKSYmZi5pc1Zpc2libGUmJmYudmlzaWJpbGl0eT4wJiYwIT0oZi5sYXllck1hc2smdGhpcy5hY3RpdmVDYW1lcmEubGF5ZXJNYXNrKSYmZi5pc0luRnJ1c3R1bSh0aGlzLl9mcnVzdHVtUGxhbmVzKSYmKHRoaXMuX2FjdGl2ZU1lc2hlcy5wdXNoKGYpLGYuX2FjdGl2YXRlKHRoaXMuX3JlbmRlcklkKSx0aGlzLl9hY3RpdmVNZXNoKGYpKSl9dmFyIGc9KG5ldyBEYXRlKS5nZXRUaW1lKCk7aWYodGhpcy5wYXJ0aWNsZXNFbmFibGVkKWZvcih2YXIgaD0wO2g8dGhpcy5wYXJ0aWNsZVN5c3RlbXMubGVuZ3RoO2grKyl7dmFyIGk9dGhpcy5wYXJ0aWNsZVN5c3RlbXNbaF07aS5pc1N0YXJ0ZWQoKSYmKCFpLmVtaXR0ZXIucG9zaXRpb258fGkuZW1pdHRlciYmaS5lbWl0dGVyLmlzRW5hYmxlZCgpKSYmKHRoaXMuX2FjdGl2ZVBhcnRpY2xlU3lzdGVtcy5wdXNoKGkpLGkuYW5pbWF0ZSgpKX10aGlzLl9wYXJ0aWNsZXNEdXJhdGlvbis9KG5ldyBEYXRlKS5nZXRUaW1lKCktZ30sYi5wcm90b3R5cGUuX2FjdGl2ZU1lc2g9ZnVuY3Rpb24oYSl7aWYoYS5za2VsZXRvbiYmdGhpcy5fYWN0aXZlU2tlbGV0b25zLnB1c2hOb0R1cGxpY2F0ZShhLnNrZWxldG9uKSxhLnNob3dCb3VuZGluZ0JveCYmdGhpcy5fYm91bmRpbmdCb3hSZW5kZXJlci5yZW5kZXJMaXN0LnB1c2goYS5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveCksYS5zdWJNZXNoZXMpe3ZhciBiLGM7aWYoYS5fc3VibWVzaGVzT2N0cmVlJiZhLnVzZU9jdHJlZUZvclJlbmRlcmluZ1NlbGVjdGlvbil7dmFyIGQ9YS5fc3VibWVzaGVzT2N0cmVlLnNlbGVjdCh0aGlzLl9mcnVzdHVtUGxhbmVzKTtiPWQubGVuZ3RoLGM9ZC5kYXRhfWVsc2UgYz1hLnN1Yk1lc2hlcyxiPWMubGVuZ3RoO2Zvcih2YXIgZT0wO2I+ZTtlKyspe3ZhciBmPWNbZV07dGhpcy5fZXZhbHVhdGVTdWJNZXNoKGYsYSl9fX0sYi5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtTWF0cml4PWZ1bmN0aW9uKGEpe3RoaXMuc2V0VHJhbnNmb3JtTWF0cml4KHRoaXMuYWN0aXZlQ2FtZXJhLmdldFZpZXdNYXRyaXgoKSx0aGlzLmFjdGl2ZUNhbWVyYS5nZXRQcm9qZWN0aW9uTWF0cml4KGEpKX0sYi5wcm90b3R5cGUuX3JlbmRlckZvckNhbWVyYT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9lbmdpbmU7aWYodGhpcy5hY3RpdmVDYW1lcmE9YSwhdGhpcy5hY3RpdmVDYW1lcmEpdGhyb3cgbmV3IEVycm9yKFwiQWN0aXZlIGNhbWVyYSBub3Qgc2V0XCIpO2Iuc2V0Vmlld3BvcnQodGhpcy5hY3RpdmVDYW1lcmEudmlld3BvcnQpLHRoaXMuX3JlbmRlcklkKyssdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKSx0aGlzLmJlZm9yZUNhbWVyYVJlbmRlciYmdGhpcy5iZWZvcmVDYW1lcmFSZW5kZXIodGhpcy5hY3RpdmVDYW1lcmEpO3ZhciBjPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuX2V2YWx1YXRlQWN0aXZlTWVzaGVzKCksdGhpcy5fZXZhbHVhdGVBY3RpdmVNZXNoZXNEdXJhdGlvbis9KG5ldyBEYXRlKS5nZXRUaW1lKCktYztmb3IodmFyIGQ9MDtkPHRoaXMuX2FjdGl2ZVNrZWxldG9ucy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLl9hY3RpdmVTa2VsZXRvbnMuZGF0YVtkXTtlLnByZXBhcmUoKX1mb3IodmFyIGY9MDtmPHRoaXMuY3VzdG9tUmVuZGVyVGFyZ2V0cy5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmN1c3RvbVJlbmRlclRhcmdldHNbZl07dGhpcy5fcmVuZGVyVGFyZ2V0cy5wdXNoKGcpfXZhciBoPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2lmKHRoaXMucmVuZGVyVGFyZ2V0c0VuYWJsZWQpe2Zvcih2YXIgaT0wO2k8dGhpcy5fcmVuZGVyVGFyZ2V0cy5sZW5ndGg7aSsrKWc9dGhpcy5fcmVuZGVyVGFyZ2V0cy5kYXRhW2ldLGcuX3Nob3VsZFJlbmRlcigpJiYodGhpcy5fcmVuZGVySWQrKyxnLnJlbmRlcigpKTt0aGlzLl9yZW5kZXJJZCsrfXRoaXMuX3JlbmRlclRhcmdldHMubGVuZ3RoPjAmJmIucmVzdG9yZURlZmF1bHRGcmFtZWJ1ZmZlcigpLHRoaXMuX3JlbmRlclRhcmdldHNEdXJhdGlvbj0obmV3IERhdGUpLmdldFRpbWUoKS1oLHRoaXMucG9zdFByb2Nlc3NNYW5hZ2VyLl9wcmVwYXJlRnJhbWUoKTt2YXIgaj0obmV3IERhdGUpLmdldFRpbWUoKTtpZih0aGlzLmxheWVycy5sZW5ndGgpe2Iuc2V0RGVwdGhCdWZmZXIoITEpO3ZhciBrLGw7Zm9yKGs9MDtrPHRoaXMubGF5ZXJzLmxlbmd0aDtrKyspbD10aGlzLmxheWVyc1trXSxsLmlzQmFja2dyb3VuZCYmbC5yZW5kZXIoKTtiLnNldERlcHRoQnVmZmVyKCEwKX10aGlzLl9yZW5kZXJpbmdNYW5hZ2VyLnJlbmRlcihudWxsLG51bGwsITAsITApLHRoaXMuX2JvdW5kaW5nQm94UmVuZGVyZXIucmVuZGVyKCk7Zm9yKHZhciBtPTA7bTx0aGlzLmxlbnNGbGFyZVN5c3RlbXMubGVuZ3RoO20rKyl0aGlzLmxlbnNGbGFyZVN5c3RlbXNbbV0ucmVuZGVyKCk7aWYodGhpcy5sYXllcnMubGVuZ3RoKXtmb3IoYi5zZXREZXB0aEJ1ZmZlcighMSksaz0wO2s8dGhpcy5sYXllcnMubGVuZ3RoO2srKylsPXRoaXMubGF5ZXJzW2tdLGwuaXNCYWNrZ3JvdW5kfHxsLnJlbmRlcigpO2Iuc2V0RGVwdGhCdWZmZXIoITApfXRoaXMuX3JlbmRlckR1cmF0aW9uKz0obmV3IERhdGUpLmdldFRpbWUoKS1qLHRoaXMucG9zdFByb2Nlc3NNYW5hZ2VyLl9maW5hbGl6ZUZyYW1lKGEuaXNJbnRlcm1lZGlhdGUpLHRoaXMuYWN0aXZlQ2FtZXJhLl91cGRhdGVGcm9tU2NlbmUoKSx0aGlzLl9yZW5kZXJUYXJnZXRzLnJlc2V0KCksdGhpcy5hZnRlckNhbWVyYVJlbmRlciYmdGhpcy5hZnRlckNhbWVyYVJlbmRlcih0aGlzLmFjdGl2ZUNhbWVyYSl9LGIucHJvdG90eXBlLl9wcm9jZXNzU3ViQ2FtZXJhcz1mdW5jdGlvbihhKXtpZigwPT1hLnN1YkNhbWVyYXMubGVuZ3RoKXJldHVybiB2b2lkIHRoaXMuX3JlbmRlckZvckNhbWVyYShhKTtmb3IodmFyIGI9MDtiPGEuc3ViQ2FtZXJhcy5sZW5ndGg7YisrKXRoaXMuX3JlbmRlckZvckNhbWVyYShhLnN1YkNhbWVyYXNbYl0pO3RoaXMuYWN0aXZlQ2FtZXJhPWEsdGhpcy5zZXRUcmFuc2Zvcm1NYXRyaXgodGhpcy5hY3RpdmVDYW1lcmEuZ2V0Vmlld01hdHJpeCgpLHRoaXMuYWN0aXZlQ2FtZXJhLmdldFByb2plY3Rpb25NYXRyaXgoKSksdGhpcy5hY3RpdmVDYW1lcmEuX3VwZGF0ZUZyb21TY2VuZSgpfSxiLnByb3RvdHlwZS5fY2hlY2tJbnRlcnNlY3Rpb25zPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPTA7Yjx0aGlzLl9tZXNoZXNGb3JJbnRlcnNlY3Rpb25zLmxlbmd0aDtiKyspZm9yKHZhciBjPXRoaXMuX21lc2hlc0ZvckludGVyc2VjdGlvbnMuZGF0YVtiXSxkPTA7ZDxjLmFjdGlvbk1hbmFnZXIuYWN0aW9ucy5sZW5ndGg7ZCsrKXt2YXIgZT1jLmFjdGlvbk1hbmFnZXIuYWN0aW9uc1tkXTtpZihlLnRyaWdnZXI9PWEuQWN0aW9uTWFuYWdlci5PbkludGVyc2VjdGlvbkVudGVyVHJpZ2dlcnx8ZS50cmlnZ2VyPT1hLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlcil7dmFyIGY9ZS5nZXRUcmlnZ2VyUGFyYW1ldGVyKCksZz1mLmludGVyc2VjdHNNZXNoKGMsITEpLGg9Yy5faW50ZXJzZWN0aW9uc0luUHJvZ3Jlc3MuaW5kZXhPZihmKTtpZihnJiYtMT09PWgmJmUudHJpZ2dlcj09YS5BY3Rpb25NYW5hZ2VyLk9uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyKWMuYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FbnRlclRyaWdnZXIsYS5BY3Rpb25FdmVudC5DcmVhdGVOZXcoYykpLGMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzLnB1c2goZik7ZWxzZSBpZighZyYmaD4tMSYmZS50cmlnZ2VyPT1hLkFjdGlvbk1hbmFnZXIuT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlcil7Yy5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PbkludGVyc2VjdGlvbkV4aXRUcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3KGMpKTt2YXIgaT1jLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcy5pbmRleE9mKGYpO2k+LTEmJmMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzLnNwbGljZShpLDEpfX19fSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLl9wYXJ0aWNsZXNEdXJhdGlvbj0wLHRoaXMuX3Nwcml0ZXNEdXJhdGlvbj0wLHRoaXMuX2FjdGl2ZVBhcnRpY2xlcz0wLHRoaXMuX3JlbmRlckR1cmF0aW9uPTAsdGhpcy5fZXZhbHVhdGVBY3RpdmVNZXNoZXNEdXJhdGlvbj0wLHRoaXMuX3RvdGFsVmVydGljZXM9MCx0aGlzLl9hY3RpdmVWZXJ0aWNlcz0wLHRoaXMuX21lc2hlc0ZvckludGVyc2VjdGlvbnMucmVzZXQoKSx0aGlzLmFjdGlvbk1hbmFnZXImJnRoaXMuYWN0aW9uTWFuYWdlci5wcm9jZXNzVHJpZ2dlcihhLkFjdGlvbk1hbmFnZXIuT25FdmVyeUZyYW1lVHJpZ2dlcixudWxsKSx0aGlzLmJlZm9yZVJlbmRlciYmdGhpcy5iZWZvcmVSZW5kZXIoKTtmb3IodmFyIGQ9MDtkPHRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLmxlbmd0aDtkKyspdGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3NbZF0oKTt2YXIgZT1NYXRoLm1heChiLk1pbkRlbHRhVGltZSxNYXRoLm1pbihhLlRvb2xzLkdldERlbHRhVGltZSgpLGIuTWF4RGVsdGFUaW1lKSk7dGhpcy5fYW5pbWF0aW9uUmF0aW89LjA2KmUsdGhpcy5fYW5pbWF0ZSgpLHRoaXMuX3BoeXNpY3NFbmdpbmUmJnRoaXMuX3BoeXNpY3NFbmdpbmUuX3J1bk9uZVN0ZXAoZS8xZTMpLHRoaXMuX2VuZ2luZS5jbGVhcih0aGlzLmNsZWFyQ29sb3IsdGhpcy5hdXRvQ2xlYXJ8fHRoaXMuZm9yY2VXaXJlZnJhbWUsITApO2Zvcih2YXIgZj0wO2Y8dGhpcy5saWdodHMubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5saWdodHNbZl0saD1nLmdldFNoYWRvd0dlbmVyYXRvcigpO2cuaXNFbmFibGVkKCkmJmgmJi0xIT09aC5nZXRTaGFkb3dNYXAoKS5nZXRTY2VuZSgpLnRleHR1cmVzLmluZGV4T2YoaC5nZXRTaGFkb3dNYXAoKSkmJnRoaXMuX3JlbmRlclRhcmdldHMucHVzaChoLmdldFNoYWRvd01hcCgpKX1pZih0aGlzLnBvc3RQcm9jZXNzUmVuZGVyUGlwZWxpbmVNYW5hZ2VyLnVwZGF0ZSgpLHRoaXMuYWN0aXZlQ2FtZXJhcy5sZW5ndGg+MClmb3IodmFyIGk9dGhpcy5fcmVuZGVySWQsaj0wO2o8dGhpcy5hY3RpdmVDYW1lcmFzLmxlbmd0aDtqKyspdGhpcy5fcmVuZGVySWQ9aSx0aGlzLl9wcm9jZXNzU3ViQ2FtZXJhcyh0aGlzLmFjdGl2ZUNhbWVyYXNbal0pO2Vsc2UgdGhpcy5fcHJvY2Vzc1N1YkNhbWVyYXModGhpcy5hY3RpdmVDYW1lcmEpO3RoaXMuX2NoZWNrSW50ZXJzZWN0aW9ucygpLHRoaXMuYWZ0ZXJSZW5kZXImJnRoaXMuYWZ0ZXJSZW5kZXIoKTtmb3IodmFyIGs9MDtrPHRoaXMuX3RvQmVEaXNwb3NlZC5sZW5ndGg7aysrKXRoaXMuX3RvQmVEaXNwb3NlZC5kYXRhW2tdLmRpc3Bvc2UoKSx0aGlzLl90b0JlRGlzcG9zZWRba109bnVsbDt0aGlzLl90b0JlRGlzcG9zZWQucmVzZXQoKSx0aGlzLl9sYXN0RnJhbWVEdXJhdGlvbj0obmV3IERhdGUpLmdldFRpbWUoKS1jfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5iZWZvcmVSZW5kZXI9bnVsbCx0aGlzLmFmdGVyUmVuZGVyPW51bGwsdGhpcy5za2VsZXRvbnM9W10sdGhpcy5fYm91bmRpbmdCb3hSZW5kZXJlci5kaXNwb3NlKCksdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCksdGhpcy5kZXRhY2hDb250cm9sKCk7dmFyIGEsYj10aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCk7Zm9yKGE9MDthPHRoaXMuY2FtZXJhcy5sZW5ndGg7YSsrKXRoaXMuY2FtZXJhc1thXS5kZXRhY2hDb250cm9sKGIpO2Zvcig7dGhpcy5saWdodHMubGVuZ3RoOyl0aGlzLmxpZ2h0c1swXS5kaXNwb3NlKCk7Zm9yKDt0aGlzLm1lc2hlcy5sZW5ndGg7KXRoaXMubWVzaGVzWzBdLmRpc3Bvc2UoITApO2Zvcig7dGhpcy5jYW1lcmFzLmxlbmd0aDspdGhpcy5jYW1lcmFzWzBdLmRpc3Bvc2UoKTtmb3IoO3RoaXMubWF0ZXJpYWxzLmxlbmd0aDspdGhpcy5tYXRlcmlhbHNbMF0uZGlzcG9zZSgpO2Zvcig7dGhpcy5wYXJ0aWNsZVN5c3RlbXMubGVuZ3RoOyl0aGlzLnBhcnRpY2xlU3lzdGVtc1swXS5kaXNwb3NlKCk7Zm9yKDt0aGlzLnNwcml0ZU1hbmFnZXJzLmxlbmd0aDspdGhpcy5zcHJpdGVNYW5hZ2Vyc1swXS5kaXNwb3NlKCk7Zm9yKDt0aGlzLmxheWVycy5sZW5ndGg7KXRoaXMubGF5ZXJzWzBdLmRpc3Bvc2UoKTtmb3IoO3RoaXMudGV4dHVyZXMubGVuZ3RoOyl0aGlzLnRleHR1cmVzWzBdLmRpc3Bvc2UoKTt0aGlzLnBvc3RQcm9jZXNzTWFuYWdlci5kaXNwb3NlKCksdGhpcy5fcGh5c2ljc0VuZ2luZSYmdGhpcy5kaXNhYmxlUGh5c2ljc0VuZ2luZSgpLGE9dGhpcy5fZW5naW5lLnNjZW5lcy5pbmRleE9mKHRoaXMpLHRoaXMuX2VuZ2luZS5zY2VuZXMuc3BsaWNlKGEsMSksdGhpcy5fZW5naW5lLndpcGVDYWNoZXMoKX0sYi5wcm90b3R5cGUuX2dldE5ld1Bvc2l0aW9uPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZiYmKGY9bnVsbCksYS5kaXZpZGVUb1JlZihjLnJhZGl1cyx0aGlzLl9zY2FsZWRQb3NpdGlvbiksYi5kaXZpZGVUb1JlZihjLnJhZGl1cyx0aGlzLl9zY2FsZWRWZWxvY2l0eSksYy5yZXRyeT0wLGMuaW5pdGlhbFZlbG9jaXR5PXRoaXMuX3NjYWxlZFZlbG9jaXR5LGMuaW5pdGlhbFBvc2l0aW9uPXRoaXMuX3NjYWxlZFBvc2l0aW9uLHRoaXMuX2NvbGxpZGVXaXRoV29ybGQodGhpcy5fc2NhbGVkUG9zaXRpb24sdGhpcy5fc2NhbGVkVmVsb2NpdHksYyxkLGUsZiksZS5tdWx0aXBseUluUGxhY2UoYy5yYWRpdXMpfSxiLnByb3RvdHlwZS5fY29sbGlkZVdpdGhXb3JsZD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGcmJihnPW51bGwpO3ZhciBoPTEwKmEuRW5naW5lLkNvbGxpc2lvbnNFcHNpbG9uO2lmKGQucmV0cnk+PWUpcmV0dXJuIHZvaWQgZi5jb3B5RnJvbShiKTtkLl9pbml0aWFsaXplKGIsYyxoKTtmb3IodmFyIGk9MDtpPHRoaXMubWVzaGVzLmxlbmd0aDtpKyspe3ZhciBqPXRoaXMubWVzaGVzW2ldO2ouaXNFbmFibGVkKCkmJmouY2hlY2tDb2xsaXNpb25zJiZqLnN1Yk1lc2hlcyYmaiE9PWcmJmouX2NoZWNrQ29sbGlzaW9uKGQpfXJldHVybiBkLmNvbGxpc2lvbkZvdW5kPygoMCE9Yy54fHwwIT1jLnl8fDAhPWMueikmJmQuX2dldFJlc3BvbnNlKGIsYyksYy5sZW5ndGgoKTw9aD92b2lkIGYuY29weUZyb20oYik6KGQucmV0cnkrKyx2b2lkIHRoaXMuX2NvbGxpZGVXaXRoV29ybGQoYixjLGQsZSxmLGcpKSk6dm9pZCBiLmFkZFRvUmVmKGMsZil9LGIucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlU2VsZWN0aW9uT2N0cmVlPWZ1bmN0aW9uKGIsYyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGImJihiPTY0KSxcInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9MiksdGhpcy5fc2VsZWN0aW9uT2N0cmVlfHwodGhpcy5fc2VsZWN0aW9uT2N0cmVlPW5ldyBhLk9jdHJlZShhLk9jdHJlZS5DcmVhdGlvbkZ1bmNGb3JNZXNoZXMsYixjKSk7Zm9yKHZhciBkPW5ldyBhLlZlY3RvcjMoTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpLGU9bmV3IGEuVmVjdG9yMygtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSwtTnVtYmVyLk1BWF9WQUxVRSksZj0wO2Y8dGhpcy5tZXNoZXMubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5tZXNoZXNbZl07Zy5jb21wdXRlV29ybGRNYXRyaXgoITApO3ZhciBoPWcuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gubWluaW11bVdvcmxkLGk9Zy5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveC5tYXhpbXVtV29ybGQ7YS5Ub29scy5DaGVja0V4dGVuZHMoaCxkLGUpLGEuVG9vbHMuQ2hlY2tFeHRlbmRzKGksZCxlKX1yZXR1cm4gdGhpcy5fc2VsZWN0aW9uT2N0cmVlLnVwZGF0ZShkLGUsdGhpcy5tZXNoZXMpLHRoaXMuX3NlbGVjdGlvbk9jdHJlZX0sYi5wcm90b3R5cGUuY3JlYXRlUGlja2luZ1JheT1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj10aGlzLl9lbmdpbmU7aWYoIWUpe2lmKCF0aGlzLmFjdGl2ZUNhbWVyYSl0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmUgY2FtZXJhIG5vdCBzZXRcIik7ZT10aGlzLmFjdGl2ZUNhbWVyYX12YXIgZz1lLnZpZXdwb3J0LGg9Zy50b0dsb2JhbChmKTtyZXR1cm4gYj1iL3RoaXMuX2VuZ2luZS5nZXRIYXJkd2FyZVNjYWxpbmdMZXZlbCgpLWgueCxjPWMvdGhpcy5fZW5naW5lLmdldEhhcmR3YXJlU2NhbGluZ0xldmVsKCktKHRoaXMuX2VuZ2luZS5nZXRSZW5kZXJIZWlnaHQoKS1oLnktaC5oZWlnaHQpLGEuUmF5LkNyZWF0ZU5ldyhiL3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLGMvd2luZG93LmRldmljZVBpeGVsUmF0aW8saC53aWR0aCxoLmhlaWdodCxkP2Q6YS5NYXRyaXguSWRlbnRpdHkoKSxlLmdldFZpZXdNYXRyaXgoKSxlLmdldFByb2plY3Rpb25NYXRyaXgoKSl9LGIucHJvdG90eXBlLl9pbnRlcm5hbFBpY2s9ZnVuY3Rpb24oYixjLGQpe2Zvcih2YXIgZT1udWxsLGY9MDtmPHRoaXMubWVzaGVzLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMubWVzaGVzW2ZdO2lmKGMpe2lmKCFjKGcpKWNvbnRpbnVlfWVsc2UgaWYoIWcuaXNFbmFibGVkKCl8fCFnLmlzVmlzaWJsZXx8IWcuaXNQaWNrYWJsZSljb250aW51ZTt2YXIgaD1nLmdldFdvcmxkTWF0cml4KCksaT1iKGgpLGo9Zy5pbnRlcnNlY3RzKGksZCk7aWYoaiYmai5oaXQmJihkfHxudWxsPT1lfHwhKGouZGlzdGFuY2U+PWUuZGlzdGFuY2UpKSYmKGU9aixkKSlicmVha31yZXR1cm4gZXx8bmV3IGEuUGlja2luZ0luZm99LGIucHJvdG90eXBlLnBpY2s9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzO3JldHVybiB0aGlzLl9pbnRlcm5hbFBpY2soZnVuY3Rpb24oYyl7cmV0dXJuIGYuY3JlYXRlUGlja2luZ1JheShhLGIsYyxlKX0sYyxkKX0sYi5wcm90b3R5cGUucGlja1dpdGhSYXk9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMuX2ludGVybmFsUGljayhmdW5jdGlvbihjKXtyZXR1cm4gZS5fcGlja1dpdGhSYXlJbnZlcnNlTWF0cml4fHwoZS5fcGlja1dpdGhSYXlJbnZlcnNlTWF0cml4PWEuTWF0cml4LklkZW50aXR5KCkpLGMuaW52ZXJ0VG9SZWYoZS5fcGlja1dpdGhSYXlJbnZlcnNlTWF0cml4KSxhLlJheS5UcmFuc2Zvcm0oYixlLl9waWNrV2l0aFJheUludmVyc2VNYXRyaXgpfSxjLGQpfSxiLnByb3RvdHlwZS5zZXRQb2ludGVyT3Zlck1lc2g9ZnVuY3Rpb24oYil7dGhpcy5fcG9pbnRlck92ZXJNZXNoIT09YiYmKHRoaXMuX3BvaW50ZXJPdmVyTWVzaCYmdGhpcy5fcG9pbnRlck92ZXJNZXNoLmFjdGlvbk1hbmFnZXImJnRoaXMuX3BvaW50ZXJPdmVyTWVzaC5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PblBvaW50ZXJPdXRUcmlnZ2VyLGEuQWN0aW9uRXZlbnQuQ3JlYXRlTmV3KHRoaXMuX3BvaW50ZXJPdmVyTWVzaCkpLHRoaXMuX3BvaW50ZXJPdmVyTWVzaD1iLHRoaXMuX3BvaW50ZXJPdmVyTWVzaCYmdGhpcy5fcG9pbnRlck92ZXJNZXNoLmFjdGlvbk1hbmFnZXImJnRoaXMuX3BvaW50ZXJPdmVyTWVzaC5hY3Rpb25NYW5hZ2VyLnByb2Nlc3NUcmlnZ2VyKGEuQWN0aW9uTWFuYWdlci5PblBvaW50ZXJPdmVyVHJpZ2dlcixhLkFjdGlvbkV2ZW50LkNyZWF0ZU5ldyh0aGlzLl9wb2ludGVyT3Zlck1lc2gpKSl9LGIucHJvdG90eXBlLmdldFBvaW50ZXJPdmVyTWVzaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyT3Zlck1lc2h9LGIucHJvdG90eXBlLmdldFBoeXNpY3NFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGh5c2ljc0VuZ2luZX0sYi5wcm90b3R5cGUuZW5hYmxlUGh5c2ljcz1mdW5jdGlvbihiLGMpe3JldHVybiB0aGlzLl9waHlzaWNzRW5naW5lPyEwOih0aGlzLl9waHlzaWNzRW5naW5lPW5ldyBhLlBoeXNpY3NFbmdpbmUoYyksdGhpcy5fcGh5c2ljc0VuZ2luZS5pc1N1cHBvcnRlZCgpPyh0aGlzLl9waHlzaWNzRW5naW5lLl9pbml0aWFsaXplKGIpLCEwKToodGhpcy5fcGh5c2ljc0VuZ2luZT1udWxsLCExKSl9LGIucHJvdG90eXBlLmRpc2FibGVQaHlzaWNzRW5naW5lPWZ1bmN0aW9uKCl7dGhpcy5fcGh5c2ljc0VuZ2luZSYmKHRoaXMuX3BoeXNpY3NFbmdpbmUuZGlzcG9zZSgpLHRoaXMuX3BoeXNpY3NFbmdpbmU9dm9pZCAwKX0sYi5wcm90b3R5cGUuaXNQaHlzaWNzRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLl9waHlzaWNzRW5naW5lfSxiLnByb3RvdHlwZS5zZXRHcmF2aXR5PWZ1bmN0aW9uKGEpe3RoaXMuX3BoeXNpY3NFbmdpbmUmJnRoaXMuX3BoeXNpY3NFbmdpbmUuX3NldEdyYXZpdHkoYSl9LGIucHJvdG90eXBlLmNyZWF0ZUNvbXBvdW5kSW1wb3N0b3I9ZnVuY3Rpb24oYSxiKXtpZihhLnBhcnRzJiYoYj1hLGE9YS5wYXJ0cyksIXRoaXMuX3BoeXNpY3NFbmdpbmUpcmV0dXJuIG51bGw7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY10ubWVzaDtkLl9waHlzaWNJbXBvc3Rvcj1hW2NdLmltcG9zdG9yLGQuX3BoeXNpY3NNYXNzPWIubWFzcy9hLmxlbmd0aCxkLl9waHlzaWNzRnJpY3Rpb249Yi5mcmljdGlvbixkLl9waHlzaWNSZXN0aXR1dGlvbj1iLnJlc3RpdHV0aW9ufXJldHVybiB0aGlzLl9waHlzaWNzRW5naW5lLl9yZWdpc3Rlck1lc2hlc0FzQ29tcG91bmQoYSxiKX0sYi5wcm90b3R5cGUuZGVsZXRlQ29tcG91bmRJbXBvc3Rvcj1mdW5jdGlvbihiKXtmb3IodmFyIGM9MDtjPGIucGFydHMubGVuZ3RoO2MrKyl7dmFyIGQ9Yi5wYXJ0c1tjXS5tZXNoO2QuX3BoeXNpY0ltcG9zdG9yPWEuUGh5c2ljc0VuZ2luZS5Ob0ltcG9zdG9yLHRoaXMuX3BoeXNpY3NFbmdpbmUuX3VucmVnaXN0ZXJNZXNoKGQpfX0sYi5wcm90b3R5cGUuX2dldEJ5VGFncz1mdW5jdGlvbihiLGMpe2lmKHZvaWQgMD09PWMpcmV0dXJuIGI7dmFyIGQ9W107Zm9yKHZhciBlIGluIGIpe3ZhciBmPWJbZV07YS5UYWdzLk1hdGNoZXNRdWVyeShmLGMpJiZkLnB1c2goZil9cmV0dXJuIGR9LGIucHJvdG90eXBlLmdldE1lc2hlc0J5VGFncz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fZ2V0QnlUYWdzKHRoaXMubWVzaGVzLGEpfSxiLnByb3RvdHlwZS5nZXRDYW1lcmFzQnlUYWdzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9nZXRCeVRhZ3ModGhpcy5jYW1lcmFzLGEpfSxiLnByb3RvdHlwZS5nZXRMaWdodHNCeVRhZ3M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2dldEJ5VGFncyh0aGlzLmxpZ2h0cyxhKX0sYi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxCeVRhZ3M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2dldEJ5VGFncyh0aGlzLm1hdGVyaWFscyxhKS5jb25jYXQodGhpcy5fZ2V0QnlUYWdzKHRoaXMubXVsdGlNYXRlcmlhbHMsYSkpfSxiLkZPR01PREVfTk9ORT0wLGIuRk9HTU9ERV9FWFA9MSxiLkZPR01PREVfRVhQMj0yLGIuRk9HTU9ERV9MSU5FQVI9MyxiLk1pbkRlbHRhVGltZT0xLGIuTWF4RGVsdGFUaW1lPTFlMyxifSgpO2EuU2NlbmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGMsZCxlLGYsZyl7c3dpdGNoKHRoaXMuX2VuZ2luZT1jIGluc3RhbmNlb2YgYS5NZXNoP2MuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKTpjLHRoaXMuX3VwZGF0YWJsZT1mLHRoaXMuX2RhdGE9ZCxnfHx0aGlzLmNyZWF0ZSgpLHRoaXMuX2tpbmQ9ZSxlKXtjYXNlIGIuUG9zaXRpb25LaW5kOnRoaXMuX3N0cmlkZVNpemU9MzticmVhaztjYXNlIGIuTm9ybWFsS2luZDp0aGlzLl9zdHJpZGVTaXplPTM7YnJlYWs7Y2FzZSBiLlVWS2luZDp0aGlzLl9zdHJpZGVTaXplPTI7YnJlYWs7Y2FzZSBiLlVWMktpbmQ6dGhpcy5fc3RyaWRlU2l6ZT0yO2JyZWFrO2Nhc2UgYi5Db2xvcktpbmQ6dGhpcy5fc3RyaWRlU2l6ZT0zO2JyZWFrO2Nhc2UgYi5NYXRyaWNlc0luZGljZXNLaW5kOnRoaXMuX3N0cmlkZVNpemU9NDticmVhaztjYXNlIGIuTWF0cmljZXNXZWlnaHRzS2luZDp0aGlzLl9zdHJpZGVTaXplPTR9fXJldHVybiBiLnByb3RvdHlwZS5pc1VwZGF0YWJsZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91cGRhdGFibGV9LGIucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGF0YX0sYi5wcm90b3R5cGUuZ2V0QnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1ZmZlcn0sYi5wcm90b3R5cGUuZ2V0U3RyaWRlU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdHJpZGVTaXplfSxiLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oYSl7KGF8fCF0aGlzLl9idWZmZXIpJiYoYT1hfHx0aGlzLl9kYXRhLHRoaXMuX2J1ZmZlcnx8KHRoaXMuX2J1ZmZlcj10aGlzLl91cGRhdGFibGU/dGhpcy5fZW5naW5lLmNyZWF0ZUR5bmFtaWNWZXJ0ZXhCdWZmZXIoNCphLmxlbmd0aCk6dGhpcy5fZW5naW5lLmNyZWF0ZVZlcnRleEJ1ZmZlcihhKSksdGhpcy5fdXBkYXRhYmxlJiYodGhpcy5fZW5naW5lLnVwZGF0ZUR5bmFtaWNWZXJ0ZXhCdWZmZXIodGhpcy5fYnVmZmVyLGEpLHRoaXMuX2RhdGE9YSkpfSxiLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy5jcmVhdGUoYSl9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9idWZmZXImJnRoaXMuX2VuZ2luZS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9idWZmZXIpJiYodGhpcy5fYnVmZmVyPW51bGwpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIlBvc2l0aW9uS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fUG9zaXRpb25LaW5kfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiTm9ybWFsS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fTm9ybWFsS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIlVWS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fVVZLaW5kfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiVVYyS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fVVYyS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkNvbG9yS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fQ29sb3JLaW5kfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiTWF0cmljZXNJbmRpY2VzS2luZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fTWF0cmljZXNJbmRpY2VzS2luZH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk1hdHJpY2VzV2VpZ2h0c0tpbmRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX01hdHJpY2VzV2VpZ2h0c0tpbmR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5fUG9zaXRpb25LaW5kPVwicG9zaXRpb25cIixiLl9Ob3JtYWxLaW5kPVwibm9ybWFsXCIsYi5fVVZLaW5kPVwidXZcIixiLl9VVjJLaW5kPVwidXYyXCIsYi5fQ29sb3JLaW5kPVwiY29sb3JcIixiLl9NYXRyaWNlc0luZGljZXNLaW5kPVwibWF0cmljZXNJbmRpY2VzXCIsYi5fTWF0cmljZXNXZWlnaHRzS2luZD1cIm1hdHJpY2VzV2VpZ2h0c1wiLGJ9KCk7YS5WZXJ0ZXhCdWZmZXI9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXtiLmNhbGwodGhpcyxjLGQpLHRoaXMucG9zaXRpb249bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5yb3RhdGlvbj1uZXcgYS5WZWN0b3IzKDAsMCwwKSx0aGlzLnNjYWxpbmc9bmV3IGEuVmVjdG9yMygxLDEsMSksdGhpcy5iaWxsYm9hcmRNb2RlPWEuQWJzdHJhY3RNZXNoLkJJTExCT0FSRE1PREVfTk9ORSx0aGlzLnZpc2liaWxpdHk9MSx0aGlzLmluZmluaXRlRGlzdGFuY2U9ITEsdGhpcy5pc1Zpc2libGU9ITAsdGhpcy5pc1BpY2thYmxlPSEwLHRoaXMuc2hvd0JvdW5kaW5nQm94PSExLHRoaXMuc2hvd1N1Yk1lc2hlc0JvdW5kaW5nQm94PSExLHRoaXMub25EaXNwb3NlPW51bGwsdGhpcy5jaGVja0NvbGxpc2lvbnM9ITEsdGhpcy5yZW5kZXJpbmdHcm91cElkPTAsdGhpcy5yZWNlaXZlU2hhZG93cz0hMSx0aGlzLnVzZU9jdHJlZUZvclJlbmRlcmluZ1NlbGVjdGlvbj0hMCx0aGlzLnVzZU9jdHJlZUZvclBpY2tpbmc9ITAsdGhpcy51c2VPY3RyZWVGb3JDb2xsaXNpb25zPSEwLHRoaXMubGF5ZXJNYXNrPTQyOTQ5NjcyOTUsdGhpcy5fcGh5c2ljSW1wb3N0b3I9YS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3IsdGhpcy5lbGxpcHNvaWQ9bmV3IGEuVmVjdG9yMyguNSwxLC41KSx0aGlzLmVsbGlwc29pZE9mZnNldD1uZXcgYS5WZWN0b3IzKDAsMCwwKSx0aGlzLl9jb2xsaWRlcj1uZXcgYS5Db2xsaWRlcix0aGlzLl9vbGRQb3NpdGlvbkZvckNvbGxpc2lvbnM9bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5fZGlmZlBvc2l0aW9uRm9yQ29sbGlzaW9ucz1uZXcgYS5WZWN0b3IzKDAsMCwwKSx0aGlzLl9uZXdQb3NpdGlvbkZvckNvbGxpc2lvbnM9bmV3IGEuVmVjdG9yMygwLDAsMCksdGhpcy5fbG9jYWxTY2FsaW5nPWEuTWF0cml4Llplcm8oKSx0aGlzLl9sb2NhbFJvdGF0aW9uPWEuTWF0cml4Llplcm8oKSx0aGlzLl9sb2NhbFRyYW5zbGF0aW9uPWEuTWF0cml4Llplcm8oKSx0aGlzLl9sb2NhbEJpbGxib2FyZD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmc9YS5NYXRyaXguWmVybygpLHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nUm90YXRpb249YS5NYXRyaXguWmVybygpLHRoaXMuX2xvY2FsV29ybGQ9YS5NYXRyaXguWmVybygpLHRoaXMuX3dvcmxkTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9yb3RhdGVZQnlQST1hLk1hdHJpeC5Sb3RhdGlvblkoTWF0aC5QSSksdGhpcy5fYWJzb2x1dGVQb3NpdGlvbj1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NvbGxpc2lvbnNUcmFuc2Zvcm1NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX2NvbGxpc2lvbnNTY2FsaW5nTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9pc0RpcnR5PSExLHRoaXMuX3Bpdm90TWF0cml4PWEuTWF0cml4LklkZW50aXR5KCksdGhpcy5faXNEaXNwb3NlZD0hMSx0aGlzLl9yZW5kZXJJZD0wLHRoaXMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzPW5ldyBBcnJheSxkLm1lc2hlcy5wdXNoKHRoaXMpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxcIkJJTExCT0FSRE1PREVfTk9ORVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5fQklMTEJPQVJETU9ERV9OT05FfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwiQklMTEJPQVJETU9ERV9YXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLl9CSUxMQk9BUkRNT0RFX1h9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJCSUxMQk9BUkRNT0RFX1lcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuX0JJTExCT0FSRE1PREVfWX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxcIkJJTExCT0FSRE1PREVfWlwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5fQklMTEJPQVJETU9ERV9afSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwiQklMTEJPQVJETU9ERV9BTExcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuX0JJTExCT0FSRE1PREVfQUxMfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sYy5wcm90b3R5cGUuZ2V0SW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiBudWxsfSxjLnByb3RvdHlwZS5nZXRWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYy5wcm90b3R5cGUuaXNWZXJ0aWNlc0RhdGFQcmVzZW50PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGMucHJvdG90eXBlLmdldEJvdW5kaW5nSW5mbz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib3VuZGluZ0luZm98fHRoaXMuX3VwZGF0ZUJvdW5kaW5nSW5mbygpLHRoaXMuX2JvdW5kaW5nSW5mb30sYy5wcm90b3R5cGUuX3ByZUFjdGl2YXRlPWZ1bmN0aW9uKCl7fSxjLnByb3RvdHlwZS5fYWN0aXZhdGU9ZnVuY3Rpb24oYSl7dGhpcy5fcmVuZGVySWQ9YX0sYy5wcm90b3R5cGUuZ2V0V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudFJlbmRlcklkIT09dGhpcy5nZXRTY2VuZSgpLmdldFJlbmRlcklkKCkmJnRoaXMuY29tcHV0ZVdvcmxkTWF0cml4KCksdGhpcy5fd29ybGRNYXRyaXh9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcIndvcmxkTWF0cml4RnJvbUNhY2hlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93b3JsZE1hdHJpeH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJhYnNvbHV0ZVBvc2l0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9hYnNvbHV0ZVBvc2l0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5yb3RhdGlvblF1YXRlcm5pb258fCh0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj1hLlF1YXRlcm5pb24uUm90YXRpb25ZYXdQaXRjaFJvbGwodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCx0aGlzLnJvdGF0aW9uLnopLHRoaXMucm90YXRpb249YS5WZWN0b3IzLlplcm8oKSksZCYmMCE9ZCl7aWYodGhpcy5wYXJlbnQpe3ZhciBlPXRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCkuY2xvbmUoKTtlLmludmVydCgpLGI9YS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChiLGUpfWY9YS5RdWF0ZXJuaW9uLlJvdGF0aW9uQXhpcyhiLGMpLHRoaXMucm90YXRpb25RdWF0ZXJuaW9uPWYubXVsdGlwbHkodGhpcy5yb3RhdGlvblF1YXRlcm5pb24pfWVsc2V7dmFyIGY9YS5RdWF0ZXJuaW9uLlJvdGF0aW9uQXhpcyhiLGMpO3RoaXMucm90YXRpb25RdWF0ZXJuaW9uPXRoaXMucm90YXRpb25RdWF0ZXJuaW9uLm11bHRpcGx5KGYpfX0sYy5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hLnNjYWxlKGIpO2lmKGMmJjAhPWMpdGhpcy5zZXRBYnNvbHV0ZVBvc2l0aW9uKHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLmFkZChkKSk7ZWxzZXt2YXIgZT10aGlzLmdldFBvc2l0aW9uRXhwcmVzc2VkSW5Mb2NhbFNwYWNlKCkuYWRkKGQpO3RoaXMuc2V0UG9zaXRpb25XaXRoTG9jYWxWZWN0b3IoZSl9fSxjLnByb3RvdHlwZS5nZXRBYnNvbHV0ZVBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVdvcmxkTWF0cml4KCksdGhpcy5fYWJzb2x1dGVQb3NpdGlvbn0sYy5wcm90b3R5cGUuc2V0QWJzb2x1dGVQb3NpdGlvbj1mdW5jdGlvbihiKXtpZihiKXt2YXIgYyxkLGU7aWYodm9pZCAwPT09Yi54KXtpZihhcmd1bWVudHMubGVuZ3RoPDMpcmV0dXJuO2M9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLGU9YXJndW1lbnRzWzJdfWVsc2UgYz1iLngsZD1iLnksZT1iLno7aWYodGhpcy5wYXJlbnQpe3ZhciBmPXRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCkuY2xvbmUoKTtmLmludmVydCgpO3ZhciBnPW5ldyBhLlZlY3RvcjMoYyxkLGUpO3RoaXMucG9zaXRpb249YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGcsZil9ZWxzZSB0aGlzLnBvc2l0aW9uLng9Yyx0aGlzLnBvc2l0aW9uLnk9ZCx0aGlzLnBvc2l0aW9uLno9ZX19LGMucHJvdG90eXBlLnNldFBpdm90TWF0cml4PWZ1bmN0aW9uKGEpe3RoaXMuX3Bpdm90TWF0cml4PWEsdGhpcy5fY2FjaGUucGl2b3RNYXRyaXhVcGRhdGVkPSEwfSxjLnByb3RvdHlwZS5nZXRQaXZvdE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9waXZvdE1hdHJpeH0sYy5wcm90b3R5cGUuX2lzU3luY2hyb25pemVkPWZ1bmN0aW9uKCl7aWYodGhpcy5faXNEaXJ0eSlyZXR1cm4hMTtpZih0aGlzLmJpbGxib2FyZE1vZGUhPT1jLkJJTExCT0FSRE1PREVfTk9ORSlyZXR1cm4hMTtpZih0aGlzLl9jYWNoZS5waXZvdE1hdHJpeFVwZGF0ZWQpcmV0dXJuITE7aWYodGhpcy5pbmZpbml0ZURpc3RhbmNlKXJldHVybiExO2lmKCF0aGlzLl9jYWNoZS5wb3NpdGlvbi5lcXVhbHModGhpcy5wb3NpdGlvbikpcmV0dXJuITE7aWYodGhpcy5yb3RhdGlvblF1YXRlcm5pb24pe2lmKCF0aGlzLl9jYWNoZS5yb3RhdGlvblF1YXRlcm5pb24uZXF1YWxzKHRoaXMucm90YXRpb25RdWF0ZXJuaW9uKSlyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLl9jYWNoZS5yb3RhdGlvbi5lcXVhbHModGhpcy5yb3RhdGlvbikpcmV0dXJuITE7cmV0dXJuIHRoaXMuX2NhY2hlLnNjYWxpbmcuZXF1YWxzKHRoaXMuc2NhbGluZyk/ITA6ITF9LGMucHJvdG90eXBlLl9pbml0Q2FjaGU9ZnVuY3Rpb24oKXtiLnByb3RvdHlwZS5faW5pdENhY2hlLmNhbGwodGhpcyksdGhpcy5fY2FjaGUubG9jYWxNYXRyaXhVcGRhdGVkPSExLHRoaXMuX2NhY2hlLnBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fY2FjaGUuc2NhbGluZz1hLlZlY3RvcjMuWmVybygpLHRoaXMuX2NhY2hlLnJvdGF0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fY2FjaGUucm90YXRpb25RdWF0ZXJuaW9uPW5ldyBhLlF1YXRlcm5pb24oMCwwLDAsMCl9LGMucHJvdG90eXBlLm1hcmtBc0RpcnR5PWZ1bmN0aW9uKGEpe1wicm90YXRpb25cIj09PWEmJih0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj1udWxsKSx0aGlzLl9jdXJyZW50UmVuZGVySWQ9TnVtYmVyLk1BWF9WQUxVRSx0aGlzLl9pc0RpcnR5PSEwfSxjLnByb3RvdHlwZS5fdXBkYXRlQm91bmRpbmdJbmZvPWZ1bmN0aW9uKCl7aWYodGhpcy5fYm91bmRpbmdJbmZvPXRoaXMuX2JvdW5kaW5nSW5mb3x8bmV3IGEuQm91bmRpbmdJbmZvKHRoaXMuYWJzb2x1dGVQb3NpdGlvbix0aGlzLmFic29sdXRlUG9zaXRpb24pLHRoaXMuX2JvdW5kaW5nSW5mby5fdXBkYXRlKHRoaXMud29ybGRNYXRyaXhGcm9tQ2FjaGUpLHRoaXMuc3ViTWVzaGVzKWZvcih2YXIgYj0wO2I8dGhpcy5zdWJNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5zdWJNZXNoZXNbYl07Yy51cGRhdGVCb3VuZGluZ0luZm8odGhpcy53b3JsZE1hdHJpeEZyb21DYWNoZSl9fSxjLnByb3RvdHlwZS5jb21wdXRlV29ybGRNYXRyaXg9ZnVuY3Rpb24oYil7aWYoIWImJih0aGlzLl9jdXJyZW50UmVuZGVySWQ9PXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpfHx0aGlzLmlzU3luY2hyb25pemVkKCEwKSkpcmV0dXJuIHRoaXMuX3dvcmxkTWF0cml4O2lmKHRoaXMuX2NhY2hlLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMucG9zaXRpb24pLHRoaXMuX2NhY2hlLnNjYWxpbmcuY29weUZyb20odGhpcy5zY2FsaW5nKSx0aGlzLl9jYWNoZS5waXZvdE1hdHJpeFVwZGF0ZWQ9ITEsdGhpcy5fY3VycmVudFJlbmRlcklkPXRoaXMuZ2V0U2NlbmUoKS5nZXRSZW5kZXJJZCgpLHRoaXMuX2lzRGlydHk9ITEsYS5NYXRyaXguU2NhbGluZ1RvUmVmKHRoaXMuc2NhbGluZy54LHRoaXMuc2NhbGluZy55LHRoaXMuc2NhbGluZy56LHRoaXMuX2xvY2FsU2NhbGluZyksdGhpcy5yb3RhdGlvblF1YXRlcm5pb24/KHRoaXMucm90YXRpb25RdWF0ZXJuaW9uLnRvUm90YXRpb25NYXRyaXgodGhpcy5fbG9jYWxSb3RhdGlvbiksdGhpcy5fY2FjaGUucm90YXRpb25RdWF0ZXJuaW9uLmNvcHlGcm9tKHRoaXMucm90YXRpb25RdWF0ZXJuaW9uKSk6KGEuTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCx0aGlzLnJvdGF0aW9uLnosdGhpcy5fbG9jYWxSb3RhdGlvbiksdGhpcy5fY2FjaGUucm90YXRpb24uY29weUZyb20odGhpcy5yb3RhdGlvbikpLHRoaXMuaW5maW5pdGVEaXN0YW5jZSYmIXRoaXMucGFyZW50KXt2YXIgZD10aGlzLmdldFNjZW5lKCkuYWN0aXZlQ2FtZXJhLGU9ZC5nZXRXb3JsZE1hdHJpeCgpLGY9bmV3IGEuVmVjdG9yMyhlLm1bMTJdLGUubVsxM10sZS5tWzE0XSk7YS5NYXRyaXguVHJhbnNsYXRpb25Ub1JlZih0aGlzLnBvc2l0aW9uLngrZi54LHRoaXMucG9zaXRpb24ueStmLnksdGhpcy5wb3NpdGlvbi56K2Yueix0aGlzLl9sb2NhbFRyYW5zbGF0aW9uKX1lbHNlIGEuTWF0cml4LlRyYW5zbGF0aW9uVG9SZWYodGhpcy5wb3NpdGlvbi54LHRoaXMucG9zaXRpb24ueSx0aGlzLnBvc2l0aW9uLnosdGhpcy5fbG9jYWxUcmFuc2xhdGlvbik7aWYodGhpcy5fcGl2b3RNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9sb2NhbFNjYWxpbmcsdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmcpLHRoaXMuX2xvY2FsUGl2b3RTY2FsaW5nLm11bHRpcGx5VG9SZWYodGhpcy5fbG9jYWxSb3RhdGlvbix0aGlzLl9sb2NhbFBpdm90U2NhbGluZ1JvdGF0aW9uKSx0aGlzLmJpbGxib2FyZE1vZGUhPT1jLkJJTExCT0FSRE1PREVfTk9ORSl7dmFyIGc9dGhpcy5wb3NpdGlvbi5jbG9uZSgpLGg9dGhpcy5nZXRTY2VuZSgpLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbi5jbG9uZSgpO3RoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5wb3NpdGlvbiYmKGcuYWRkSW5QbGFjZSh0aGlzLnBhcmVudC5wb3NpdGlvbiksYS5NYXRyaXguVHJhbnNsYXRpb25Ub1JlZihnLngsZy55LGcueix0aGlzLl9sb2NhbFRyYW5zbGF0aW9uKSksKHRoaXMuYmlsbGJvYXJkTW9kZSZjLkJJTExCT0FSRE1PREVfQUxMKT09PWMuQklMTEJPQVJETU9ERV9BTEw/aD10aGlzLmdldFNjZW5lKCkuYWN0aXZlQ2FtZXJhLnBvc2l0aW9uOih0aGlzLmJpbGxib2FyZE1vZGUmYS5BYnN0cmFjdE1lc2guQklMTEJPQVJETU9ERV9YJiYoaC54PWcueCthLkVuZ2luZS5FcHNpbG9uKSx0aGlzLmJpbGxib2FyZE1vZGUmYS5BYnN0cmFjdE1lc2guQklMTEJPQVJETU9ERV9ZJiYoaC55PWcueSsuMDAxKSx0aGlzLmJpbGxib2FyZE1vZGUmYS5BYnN0cmFjdE1lc2guQklMTEJPQVJETU9ERV9aJiYoaC56PWcueisuMDAxKSksYS5NYXRyaXguTG9va0F0TEhUb1JlZihnLGgsYS5WZWN0b3IzLlVwKCksdGhpcy5fbG9jYWxCaWxsYm9hcmQpLHRoaXMuX2xvY2FsQmlsbGJvYXJkLm1bMTJdPXRoaXMuX2xvY2FsQmlsbGJvYXJkLm1bMTNdPXRoaXMuX2xvY2FsQmlsbGJvYXJkLm1bMTRdPTAsdGhpcy5fbG9jYWxCaWxsYm9hcmQuaW52ZXJ0KCksdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmdSb3RhdGlvbi5tdWx0aXBseVRvUmVmKHRoaXMuX2xvY2FsQmlsbGJvYXJkLHRoaXMuX2xvY2FsV29ybGQpLHRoaXMuX3JvdGF0ZVlCeVBJLm11bHRpcGx5VG9SZWYodGhpcy5fbG9jYWxXb3JsZCx0aGlzLl9sb2NhbFBpdm90U2NhbGluZ1JvdGF0aW9uKX1yZXR1cm4gdGhpcy5fbG9jYWxQaXZvdFNjYWxpbmdSb3RhdGlvbi5tdWx0aXBseVRvUmVmKHRoaXMuX2xvY2FsVHJhbnNsYXRpb24sdGhpcy5fbG9jYWxXb3JsZCksdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4JiZ0aGlzLmJpbGxib2FyZE1vZGU9PT1hLkFic3RyYWN0TWVzaC5CSUxMQk9BUkRNT0RFX05PTkU/dGhpcy5fbG9jYWxXb3JsZC5tdWx0aXBseVRvUmVmKHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KCksdGhpcy5fd29ybGRNYXRyaXgpOnRoaXMuX3dvcmxkTWF0cml4LmNvcHlGcm9tKHRoaXMuX2xvY2FsV29ybGQpLHRoaXMuX3VwZGF0ZUJvdW5kaW5nSW5mbygpLHRoaXMuX2Fic29sdXRlUG9zaXRpb24uY29weUZyb21GbG9hdHModGhpcy5fd29ybGRNYXRyaXgubVsxMl0sdGhpcy5fd29ybGRNYXRyaXgubVsxM10sdGhpcy5fd29ybGRNYXRyaXgubVsxNF0pLHRoaXMuX3dvcmxkTWF0cml4fSxjLnByb3RvdHlwZS5zZXRQb3NpdGlvbldpdGhMb2NhbFZlY3Rvcj1mdW5jdGlvbihiKXt0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCgpLHRoaXMucG9zaXRpb249YS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChiLHRoaXMuX2xvY2FsV29ybGQpfSxjLnByb3RvdHlwZS5nZXRQb3NpdGlvbkV4cHJlc3NlZEluTG9jYWxTcGFjZT1mdW5jdGlvbigpe3RoaXMuY29tcHV0ZVdvcmxkTWF0cml4KCk7dmFyIGI9dGhpcy5fbG9jYWxXb3JsZC5jbG9uZSgpO3JldHVybiBiLmludmVydCgpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWwodGhpcy5wb3NpdGlvbixiKX0sYy5wcm90b3R5cGUubG9jYWxseVRyYW5zbGF0ZT1mdW5jdGlvbihiKXt0aGlzLmNvbXB1dGVXb3JsZE1hdHJpeCgpLHRoaXMucG9zaXRpb249YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGIsdGhpcy5fbG9jYWxXb3JsZCl9LGMucHJvdG90eXBlLmxvb2tBdD1mdW5jdGlvbihiLGMsZCxlKXtjPWN8fDAsZD1kfHwwLGU9ZXx8MDt2YXIgZj1iLnN1YnRyYWN0KHRoaXMucG9zaXRpb24pLGc9LU1hdGguYXRhbjIoZi56LGYueCktTWF0aC5QSS8yLGg9TWF0aC5zcXJ0KGYueCpmLngrZi56KmYueiksaT1NYXRoLmF0YW4yKGYueSxoKTt0aGlzLnJvdGF0aW9uUXVhdGVybmlvbj1hLlF1YXRlcm5pb24uUm90YXRpb25ZYXdQaXRjaFJvbGwoZytjLGkrZCxlKX0sYy5wcm90b3R5cGUuaXNJbkZydXN0dW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mby5pc0luRnJ1c3R1bShhKT8hMDohMX0sYy5wcm90b3R5cGUuaW50ZXJzZWN0c01lc2g9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fYm91bmRpbmdJbmZvJiZhLl9ib3VuZGluZ0luZm8/dGhpcy5fYm91bmRpbmdJbmZvLmludGVyc2VjdHMoYS5fYm91bmRpbmdJbmZvLGIpOiExfSxjLnByb3RvdHlwZS5pbnRlcnNlY3RzUG9pbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mbz90aGlzLl9ib3VuZGluZ0luZm8uaW50ZXJzZWN0c1BvaW50KGEpOiExfSxjLnByb3RvdHlwZS5zZXRQaHlzaWNzU3RhdGU9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmdldFNjZW5lKCkuZ2V0UGh5c2ljc0VuZ2luZSgpO2lmKGQpe2lmKGIuaW1wb3N0b3ImJihjPWIsYj1iLmltcG9zdG9yKSxiPWJ8fGEuUGh5c2ljc0VuZ2luZS5Ob0ltcG9zdG9yLGI9PT1hLlBoeXNpY3NFbmdpbmUuTm9JbXBvc3RvcilyZXR1cm4gdm9pZCBkLl91bnJlZ2lzdGVyTWVzaCh0aGlzKTtjLm1hc3M9Yy5tYXNzfHwwLGMuZnJpY3Rpb249Yy5mcmljdGlvbnx8LjIsYy5yZXN0aXR1dGlvbj1jLnJlc3RpdHV0aW9ufHwuOSx0aGlzLl9waHlzaWNJbXBvc3Rvcj1iLHRoaXMuX3BoeXNpY3NNYXNzPWMubWFzcyx0aGlzLl9waHlzaWNzRnJpY3Rpb249Yy5mcmljdGlvbix0aGlzLl9waHlzaWNSZXN0aXR1dGlvbj1jLnJlc3RpdHV0aW9uLGQuX3JlZ2lzdGVyTWVzaCh0aGlzLGIsYyl9fSxjLnByb3RvdHlwZS5nZXRQaHlzaWNzSW1wb3N0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGh5c2ljSW1wb3N0b3I/dGhpcy5fcGh5c2ljSW1wb3N0b3I6YS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3J9LGMucHJvdG90eXBlLmdldFBoeXNpY3NNYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BoeXNpY3NNYXNzP3RoaXMuX3BoeXNpY3NNYXNzOjB9LGMucHJvdG90eXBlLmdldFBoeXNpY3NGcmljdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9waHlzaWNzRnJpY3Rpb24/dGhpcy5fcGh5c2ljc0ZyaWN0aW9uOjB9LGMucHJvdG90eXBlLmdldFBoeXNpY3NSZXN0aXR1dGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9waHlzaWNSZXN0aXR1dGlvbj90aGlzLl9waHlzaWNSZXN0aXR1dGlvbjowfSxjLnByb3RvdHlwZS5hcHBseUltcHVsc2U9ZnVuY3Rpb24oYSxiKXt0aGlzLl9waHlzaWNJbXBvc3RvciYmdGhpcy5nZXRTY2VuZSgpLmdldFBoeXNpY3NFbmdpbmUoKS5fYXBwbHlJbXB1bHNlKHRoaXMsYSxiKX0sYy5wcm90b3R5cGUuc2V0UGh5c2ljc0xpbmtXaXRoPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuX3BoeXNpY0ltcG9zdG9yJiZ0aGlzLmdldFNjZW5lKCkuZ2V0UGh5c2ljc0VuZ2luZSgpLl9jcmVhdGVMaW5rKHRoaXMsYSxiLGMsZCl9LGMucHJvdG90eXBlLnVwZGF0ZVBoeXNpY3NCb2R5UG9zaXRpb249ZnVuY3Rpb24oKXt0aGlzLl9waHlzaWNJbXBvc3RvciYmdGhpcy5nZXRTY2VuZSgpLmdldFBoeXNpY3NFbmdpbmUoKS5fdXBkYXRlQm9keVBvc2l0aW9uKHRoaXMpfSxjLnByb3RvdHlwZS5tb3ZlV2l0aENvbGxpc2lvbnM9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7Yy5zdWJ0cmFjdEZyb21GbG9hdHNUb1JlZigwLHRoaXMuZWxsaXBzb2lkLnksMCx0aGlzLl9vbGRQb3NpdGlvbkZvckNvbGxpc2lvbnMpLHRoaXMuX29sZFBvc2l0aW9uRm9yQ29sbGlzaW9ucy5hZGRJblBsYWNlKHRoaXMuZWxsaXBzb2lkT2Zmc2V0KSx0aGlzLl9jb2xsaWRlci5yYWRpdXM9dGhpcy5lbGxpcHNvaWQsdGhpcy5nZXRTY2VuZSgpLl9nZXROZXdQb3NpdGlvbih0aGlzLl9vbGRQb3NpdGlvbkZvckNvbGxpc2lvbnMsYix0aGlzLl9jb2xsaWRlciwzLHRoaXMuX25ld1Bvc2l0aW9uRm9yQ29sbGlzaW9ucyx0aGlzKSx0aGlzLl9uZXdQb3NpdGlvbkZvckNvbGxpc2lvbnMuc3VidHJhY3RUb1JlZih0aGlzLl9vbGRQb3NpdGlvbkZvckNvbGxpc2lvbnMsdGhpcy5fZGlmZlBvc2l0aW9uRm9yQ29sbGlzaW9ucyksdGhpcy5fZGlmZlBvc2l0aW9uRm9yQ29sbGlzaW9ucy5sZW5ndGgoKT5hLkVuZ2luZS5Db2xsaXNpb25zRXBzaWxvbiYmdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHRoaXMuX2RpZmZQb3NpdGlvbkZvckNvbGxpc2lvbnMpfSxjLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVN1Ym1lc2hlc09jdHJlZT1mdW5jdGlvbihiLGMpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBiJiYoYj02NCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTIpLHRoaXMuX3N1Ym1lc2hlc09jdHJlZXx8KHRoaXMuX3N1Ym1lc2hlc09jdHJlZT1uZXcgYS5PY3RyZWUoYS5PY3RyZWUuQ3JlYXRpb25GdW5jRm9yU3ViTWVzaGVzLGIsYykpLHRoaXMuY29tcHV0ZVdvcmxkTWF0cml4KCEwKTt2YXIgZD10aGlzLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94O3JldHVybiB0aGlzLl9zdWJtZXNoZXNPY3RyZWUudXBkYXRlKGQubWluaW11bVdvcmxkLGQubWF4aW11bVdvcmxkLHRoaXMuc3ViTWVzaGVzKSx0aGlzLl9zdWJtZXNoZXNPY3RyZWV9LGMucHJvdG90eXBlLl9jb2xsaWRlRm9yU3ViTWVzaD1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5fZ2VuZXJhdGVQb2ludHNBcnJheSgpLCFiLl9sYXN0Q29sbGlkZXJXb3JsZFZlcnRpY2VzfHwhYi5fbGFzdENvbGxpZGVyVHJhbnNmb3JtTWF0cml4LmVxdWFscyhjKSl7Yi5fbGFzdENvbGxpZGVyVHJhbnNmb3JtTWF0cml4PWMuY2xvbmUoKSxiLl9sYXN0Q29sbGlkZXJXb3JsZFZlcnRpY2VzPVtdLGIuX3RyaWFuZ2xlUGxhbmVzPVtdO2Zvcih2YXIgZT1iLnZlcnRpY2VzU3RhcnQsZj1iLnZlcnRpY2VzU3RhcnQrYi52ZXJ0aWNlc0NvdW50LGc9ZTtmPmc7ZysrKWIuX2xhc3RDb2xsaWRlcldvcmxkVmVydGljZXMucHVzaChhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXModGhpcy5fcG9zaXRpb25zW2ddLGMpKX1kLl9jb2xsaWRlKGIsYi5fbGFzdENvbGxpZGVyV29ybGRWZXJ0aWNlcyx0aGlzLmdldEluZGljZXMoKSxiLmluZGV4U3RhcnQsYi5pbmRleFN0YXJ0K2IuaW5kZXhDb3VudCxiLnZlcnRpY2VzU3RhcnQpfSxjLnByb3RvdHlwZS5fcHJvY2Vzc0NvbGxpc2lvbnNGb3JTdWJNZXNoZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2lmKHRoaXMuX3N1Ym1lc2hlc09jdHJlZSYmdGhpcy51c2VPY3RyZWVGb3JDb2xsaXNpb25zKXt2YXIgZT1hLnZlbG9jaXR5V29ybGRMZW5ndGgrTWF0aC5tYXgoYS5yYWRpdXMueCxhLnJhZGl1cy55LGEucmFkaXVzLnopLGY9dGhpcy5fc3VibWVzaGVzT2N0cmVlLmludGVyc2VjdHMoYS5iYXNlUG9pbnRXb3JsZCxlKTtkPWYubGVuZ3RoLGM9Zi5kYXRhfWVsc2UgYz10aGlzLnN1Yk1lc2hlcyxkPWMubGVuZ3RoO2Zvcih2YXIgZz0wO2Q+ZztnKyspe3ZhciBoPWNbZ107ZD4xJiYhaC5fY2hlY2tDb2xsaXNpb24oYSl8fHRoaXMuX2NvbGxpZGVGb3JTdWJNZXNoKGgsYixhKX19LGMucHJvdG90eXBlLl9jaGVja0NvbGxpc2lvbj1mdW5jdGlvbihiKXt0aGlzLl9ib3VuZGluZ0luZm8uX2NoZWNrQ29sbGlzaW9uKGIpJiYoYS5NYXRyaXguU2NhbGluZ1RvUmVmKDEvYi5yYWRpdXMueCwxL2IucmFkaXVzLnksMS9iLnJhZGl1cy56LHRoaXMuX2NvbGxpc2lvbnNTY2FsaW5nTWF0cml4KSx0aGlzLndvcmxkTWF0cml4RnJvbUNhY2hlLm11bHRpcGx5VG9SZWYodGhpcy5fY29sbGlzaW9uc1NjYWxpbmdNYXRyaXgsdGhpcy5fY29sbGlzaW9uc1RyYW5zZm9ybU1hdHJpeCksdGhpcy5fcHJvY2Vzc0NvbGxpc2lvbnNGb3JTdWJNZXNoZXMoYix0aGlzLl9jb2xsaXNpb25zVHJhbnNmb3JtTWF0cml4KSl9LGMucHJvdG90eXBlLl9nZW5lcmF0ZVBvaW50c0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGMucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYS5QaWNraW5nSW5mbztpZighKHRoaXMuc3ViTWVzaGVzJiZ0aGlzLl9ib3VuZGluZ0luZm8mJmIuaW50ZXJzZWN0c1NwaGVyZSh0aGlzLl9ib3VuZGluZ0luZm8uYm91bmRpbmdTcGhlcmUpJiZiLmludGVyc2VjdHNCb3godGhpcy5fYm91bmRpbmdJbmZvLmJvdW5kaW5nQm94KSkpcmV0dXJuIGQ7aWYoIXRoaXMuX2dlbmVyYXRlUG9pbnRzQXJyYXkoKSlyZXR1cm4gZDt2YXIgZSxmLGc9bnVsbDtpZih0aGlzLl9zdWJtZXNoZXNPY3RyZWUmJnRoaXMudXNlT2N0cmVlRm9yUGlja2luZyl7dmFyIGg9YS5SYXkuVHJhbnNmb3JtKGIsdGhpcy5nZXRXb3JsZE1hdHJpeCgpKSxpPXRoaXMuX3N1Ym1lc2hlc09jdHJlZS5pbnRlcnNlY3RzUmF5KGgpO2Y9aS5sZW5ndGgsZT1pLmRhdGF9ZWxzZSBlPXRoaXMuc3ViTWVzaGVzLGY9ZS5sZW5ndGg7Zm9yKHZhciBqPTA7Zj5qO2orKyl7dmFyIGs9ZVtqXTtpZighKGY+MSl8fGsuY2FuSW50ZXJzZWN0cyhiKSl7dmFyIGw9ay5pbnRlcnNlY3RzKGIsdGhpcy5fcG9zaXRpb25zLHRoaXMuZ2V0SW5kaWNlcygpLGMpO2lmKGwmJihjfHwhZ3x8bC5kaXN0YW5jZTxnLmRpc3RhbmNlKSYmKGc9bCxjKSlicmVha319aWYoZyl7dmFyIG09dGhpcy5nZXRXb3JsZE1hdHJpeCgpLG49YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGIub3JpZ2luLG0pLG89Yi5kaXJlY3Rpb24uY2xvbmUoKTtvLm5vcm1hbGl6ZSgpLG89by5zY2FsZShnLmRpc3RhbmNlKTt2YXIgcD1hLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsKG8sbSkscT1uLmFkZChwKTtyZXR1cm4gZC5oaXQ9ITAsZC5kaXN0YW5jZT1hLlZlY3RvcjMuRGlzdGFuY2UobixxKSxkLnBpY2tlZFBvaW50PXEsZC5waWNrZWRNZXNoPXRoaXMsZC5idT1nLmJ1LGQuYnY9Zy5idixkLmZhY2VJZD1nLmZhY2VJZCxkfXJldHVybiBkfSxjLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxjLnByb3RvdHlwZS5yZWxlYXNlU3ViTWVzaGVzPWZ1bmN0aW9uKCl7aWYodGhpcy5zdWJNZXNoZXMpZm9yKDt0aGlzLnN1Yk1lc2hlcy5sZW5ndGg7KXRoaXMuc3ViTWVzaGVzWzBdLmRpc3Bvc2UoKTtcbmVsc2UgdGhpcy5zdWJNZXNoZXM9bmV3IEFycmF5fSxjLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGIpe2Zvcih0aGlzLmdldFBoeXNpY3NJbXBvc3RvcigpIT1hLlBoeXNpY3NFbmdpbmUuTm9JbXBvc3RvciYmdGhpcy5zZXRQaHlzaWNzU3RhdGUoYS5QaHlzaWNzRW5naW5lLk5vSW1wb3N0b3IpLGU9MDtlPHRoaXMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzLmxlbmd0aDtlKyspe3ZhciBjPXRoaXMuX2ludGVyc2VjdGlvbnNJblByb2dyZXNzW2VdLGQ9Yy5faW50ZXJzZWN0aW9uc0luUHJvZ3Jlc3MuaW5kZXhPZih0aGlzKTtjLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcy5zcGxpY2UoZCwxKX10aGlzLl9pbnRlcnNlY3Rpb25zSW5Qcm9ncmVzcz1bXSx0aGlzLnJlbGVhc2VTdWJNZXNoZXMoKTt2YXIgZT10aGlzLmdldFNjZW5lKCkubWVzaGVzLmluZGV4T2YodGhpcyk7aWYodGhpcy5nZXRTY2VuZSgpLm1lc2hlcy5zcGxpY2UoZSwxKSxiKWZvcihlPTA7ZTx0aGlzLmdldFNjZW5lKCkubWVzaGVzLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMuZ2V0U2NlbmUoKS5tZXNoZXNbZV07Zi5wYXJlbnQ9PT10aGlzJiYoZi5wYXJlbnQ9bnVsbCxmLmNvbXB1dGVXb3JsZE1hdHJpeCghMCkpfWVsc2V7Zm9yKGU9MDtlPHRoaXMuZ2V0U2NlbmUoKS5wYXJ0aWNsZVN5c3RlbXMubGVuZ3RoO2UrKyl0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zW2VdLmVtaXR0ZXI9PXRoaXMmJih0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zW2VdLmRpc3Bvc2UoKSxlLS0pO3ZhciBnPXRoaXMuZ2V0U2NlbmUoKS5tZXNoZXMuc2xpY2UoMCk7Zm9yKGU9MDtlPGcubGVuZ3RoO2UrKylnW2VdLnBhcmVudD09dGhpcyYmZ1tlXS5kaXNwb3NlKCl9dGhpcy5faXNEaXNwb3NlZD0hMCx0aGlzLm9uRGlzcG9zZSYmdGhpcy5vbkRpc3Bvc2UoKX0sYy5fQklMTEJPQVJETU9ERV9OT05FPTAsYy5fQklMTEJPQVJETU9ERV9YPTEsYy5fQklMTEJPQVJETU9ERV9ZPTIsYy5fQklMTEJPQVJETU9ERV9aPTQsYy5fQklMTEJPQVJETU9ERV9BTEw9NyxjfShhLk5vZGUpO2EuQWJzdHJhY3RNZXNoPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLm11c3RSZXR1cm49ITEsdGhpcy52aXNpYmxlSW5zdGFuY2VzPW5ldyBBcnJheSx0aGlzLnJlbmRlclNlbGY9bmV3IEFycmF5fXJldHVybiBhfSgpO2EuX0luc3RhbmNlc0JhdGNoPWI7dmFyIGM9ZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZChkLGUpe2MuY2FsbCh0aGlzLGQsZSksdGhpcy5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT05FLHRoaXMuaW5zdGFuY2VzPW5ldyBBcnJheSx0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcz1uZXcgQXJyYXksdGhpcy5fb25BZnRlclJlbmRlckNhbGxiYWNrcz1uZXcgQXJyYXksdGhpcy5fdmlzaWJsZUluc3RhbmNlcz17fSx0aGlzLl9yZW5kZXJJZEZvckluc3RhbmNlcz1uZXcgQXJyYXksdGhpcy5fYmF0Y2hDYWNoZT1uZXcgYix0aGlzLl9pbnN0YW5jZXNCdWZmZXJTaXplPTIwNDh9cmV0dXJuIF9fZXh0ZW5kcyhkLGMpLGQucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkuZ2V0VG90YWxWZXJ0aWNlcygpOjB9LGQucHJvdG90eXBlLmdldFZlcnRpY2VzRGF0YT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkuZ2V0VmVydGljZXNEYXRhKGEpOm51bGx9LGQucHJvdG90eXBlLmdldFZlcnRleEJ1ZmZlcj1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkuZ2V0VmVydGV4QnVmZmVyKGEpOnZvaWQgMH0sZC5wcm90b3R5cGUuaXNWZXJ0aWNlc0RhdGFQcmVzZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9nZW9tZXRyeT90aGlzLl9nZW9tZXRyeS5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYSk6dGhpcy5fZGVsYXlJbmZvPy0xIT09dGhpcy5fZGVsYXlJbmZvLmluZGV4T2YoYSk6ITF9LGQucHJvdG90eXBlLmdldFZlcnRpY2VzRGF0YUtpbmRzPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2dlb21ldHJ5KXt2YXIgYT1bXTtpZih0aGlzLl9kZWxheUluZm8pZm9yKHZhciBiIGluIHRoaXMuX2RlbGF5SW5mbylhLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIHRoaXMuX2dlb21ldHJ5LmdldFZlcnRpY2VzRGF0YUtpbmRzKCl9LGQucHJvdG90eXBlLmdldFRvdGFsSW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9nZW9tZXRyeT90aGlzLl9nZW9tZXRyeS5nZXRUb3RhbEluZGljZXMoKTowfSxkLnByb3RvdHlwZS5nZXRJbmRpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2dlb21ldHJ5P3RoaXMuX2dlb21ldHJ5LmdldEluZGljZXMoKTpbXX0sZC5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORz8hMTpjLnByb3RvdHlwZS5pc1JlYWR5LmNhbGwodGhpcyl9LGQucHJvdG90eXBlLmlzRGlzcG9zZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNEaXNwb3NlZH0sZC5wcm90b3R5cGUuX3ByZUFjdGl2YXRlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRTY2VuZSgpLmdldFJlbmRlcklkKCk7dGhpcy5fcHJlQWN0aXZhdGVJZCE9YSYmKHRoaXMuX3ByZUFjdGl2YXRlSWQ9YSx0aGlzLl92aXNpYmxlSW5zdGFuY2VzPW51bGwpfSxkLnByb3RvdHlwZS5fcmVnaXN0ZXJJbnN0YW5jZUZvclJlbmRlcklkPWZ1bmN0aW9uKGEsYil7dGhpcy5fdmlzaWJsZUluc3RhbmNlc3x8KHRoaXMuX3Zpc2libGVJbnN0YW5jZXM9e30sdGhpcy5fdmlzaWJsZUluc3RhbmNlcy5kZWZhdWx0UmVuZGVySWQ9Yix0aGlzLl92aXNpYmxlSW5zdGFuY2VzLnNlbGZEZWZhdWx0UmVuZGVySWQ9dGhpcy5fcmVuZGVySWQpLHRoaXMuX3Zpc2libGVJbnN0YW5jZXNbYl18fCh0aGlzLl92aXNpYmxlSW5zdGFuY2VzW2JdPW5ldyBBcnJheSksdGhpcy5fdmlzaWJsZUluc3RhbmNlc1tiXS5wdXNoKGEpfSxkLnByb3RvdHlwZS5yZWZyZXNoQm91bmRpbmdJbmZvPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKTtpZihiKXt2YXIgYz1hLlRvb2xzLkV4dHJhY3RNaW5BbmRNYXgoYiwwLHRoaXMuZ2V0VG90YWxWZXJ0aWNlcygpKTt0aGlzLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGMubWluaW11bSxjLm1heGltdW0pfWlmKHRoaXMuc3ViTWVzaGVzKWZvcih2YXIgZD0wO2Q8dGhpcy5zdWJNZXNoZXMubGVuZ3RoO2QrKyl0aGlzLnN1Yk1lc2hlc1tkXS5yZWZyZXNoQm91bmRpbmdJbmZvKCk7dGhpcy5fdXBkYXRlQm91bmRpbmdJbmZvKCl9LGQucHJvdG90eXBlLl9jcmVhdGVHbG9iYWxTdWJNZXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5nZXRUb3RhbFZlcnRpY2VzKCk7cmV0dXJuIGImJnRoaXMuZ2V0SW5kaWNlcygpPyh0aGlzLnJlbGVhc2VTdWJNZXNoZXMoKSxuZXcgYS5TdWJNZXNoKDAsMCxiLDAsdGhpcy5nZXRUb3RhbEluZGljZXMoKSx0aGlzKSk6bnVsbH0sZC5wcm90b3R5cGUuc3ViZGl2aWRlPWZ1bmN0aW9uKGIpe2lmKCEoMT5iKSl7Zm9yKHZhciBjPXRoaXMuZ2V0VG90YWxJbmRpY2VzKCksZD1jL2J8MCxlPTA7ZCUzIT0wOylkKys7dGhpcy5yZWxlYXNlU3ViTWVzaGVzKCk7Zm9yKHZhciBmPTA7Yj5mJiYhKGU+PWMpO2YrKylhLlN1Yk1lc2guQ3JlYXRlRnJvbUluZGljZXMoMCxlLE1hdGgubWluKGQsYy1lKSx0aGlzKSxlKz1kO3RoaXMuc3luY2hyb25pemVJbnN0YW5jZXMoKX19LGQucHJvdG90eXBlLnNldFZlcnRpY2VzRGF0YT1mdW5jdGlvbihiLGMsZCl7aWYoYiBpbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1jO2M9YixiPWUsYS5Ub29scy5XYXJuKFwiRGVwcmVjYXRlZCB1c2FnZSBvZiBzZXRWZXJ0aWNlc0RhdGEgZGV0ZWN0ZWQgKHNpbmNlIHYxLjEyKS4gQ3VycmVudCBzaWduYXR1cmUgaXMgc2V0VmVydGljZXNEYXRhKGtpbmQsIGRhdGEsIHVwZGF0YWJsZSkuXCIpfWlmKHRoaXMuX2dlb21ldHJ5KXRoaXMuX2dlb21ldHJ5LnNldFZlcnRpY2VzRGF0YShiLGMsZCk7ZWxzZXt2YXIgZj1uZXcgYS5WZXJ0ZXhEYXRhO2Yuc2V0KGMsYik7dmFyIGc9dGhpcy5nZXRTY2VuZSgpO25ldyBhLkdlb21ldHJ5KGEuR2VvbWV0cnkuUmFuZG9tSWQoKSxnLGYsZCx0aGlzKX19LGQucHJvdG90eXBlLnVwZGF0ZVZlcnRpY2VzRGF0YT1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9nZW9tZXRyeSYmKGQ/KHRoaXMubWFrZUdlb21ldHJ5VW5pcXVlKCksdGhpcy51cGRhdGVWZXJ0aWNlc0RhdGEoYSxiLGMsITEpKTp0aGlzLl9nZW9tZXRyeS51cGRhdGVWZXJ0aWNlc0RhdGEoYSxiLGMpKX0sZC5wcm90b3R5cGUubWFrZUdlb21ldHJ5VW5pcXVlPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbWV0cnkpe3ZhciBiPXRoaXMuX2dlb21ldHJ5LmNvcHkoYS5HZW9tZXRyeS5SYW5kb21JZCgpKTtiLmFwcGx5VG9NZXNoKHRoaXMpfX0sZC5wcm90b3R5cGUuc2V0SW5kaWNlcz1mdW5jdGlvbihiKXtpZih0aGlzLl9nZW9tZXRyeSl0aGlzLl9nZW9tZXRyeS5zZXRJbmRpY2VzKGIpO2Vsc2V7dmFyIGM9bmV3IGEuVmVydGV4RGF0YTtjLmluZGljZXM9Yjt2YXIgZD10aGlzLmdldFNjZW5lKCk7bmV3IGEuR2VvbWV0cnkoYS5HZW9tZXRyeS5SYW5kb21JZCgpLGQsYywhMSx0aGlzKX19LGQucHJvdG90eXBlLl9iaW5kPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCksZT10aGlzLl9nZW9tZXRyeS5nZXRJbmRleEJ1ZmZlcigpO2MmJihlPWEuZ2V0TGluZXNJbmRleEJ1ZmZlcih0aGlzLmdldEluZGljZXMoKSxkKSksZC5iaW5kTXVsdGlCdWZmZXJzKHRoaXMuX2dlb21ldHJ5LmdldFZlcnRleEJ1ZmZlcnMoKSxlLGIpfSxkLnByb3RvdHlwZS5fZHJhdz1mdW5jdGlvbihhLGIsYyl7aWYodGhpcy5fZ2VvbWV0cnkmJnRoaXMuX2dlb21ldHJ5LmdldFZlcnRleEJ1ZmZlcnMoKSYmdGhpcy5fZ2VvbWV0cnkuZ2V0SW5kZXhCdWZmZXIoKSl7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpO2QuZHJhdyhiLGI/YS5pbmRleFN0YXJ0OjAsYj9hLmluZGV4Q291bnQ6YS5saW5lc0luZGV4Q291bnQsYyl9fSxkLnByb3RvdHlwZS5yZWdpc3RlckJlZm9yZVJlbmRlcj1mdW5jdGlvbihhKXt0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrcy5wdXNoKGEpfSxkLnByb3RvdHlwZS51bnJlZ2lzdGVyQmVmb3JlUmVuZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX29uQmVmb3JlUmVuZGVyQ2FsbGJhY2tzLmluZGV4T2YoYSk7Yj4tMSYmdGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3Muc3BsaWNlKGIsMSl9LGQucHJvdG90eXBlLnJlZ2lzdGVyQWZ0ZXJSZW5kZXI9ZnVuY3Rpb24oYSl7dGhpcy5fb25BZnRlclJlbmRlckNhbGxiYWNrcy5wdXNoKGEpfSxkLnByb3RvdHlwZS51bnJlZ2lzdGVyQWZ0ZXJSZW5kZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5fb25BZnRlclJlbmRlckNhbGxiYWNrcy5pbmRleE9mKGEpO2I+LTEmJnRoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3Muc3BsaWNlKGIsMSl9LGQucHJvdG90eXBlLl9nZXRJbnN0YW5jZXNSZW5kZXJMaXN0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0U2NlbmUoKTtpZih0aGlzLl9iYXRjaENhY2hlLm11c3RSZXR1cm49ITEsdGhpcy5fYmF0Y2hDYWNoZS5yZW5kZXJTZWxmW2FdPXRoaXMuaXNFbmFibGVkKCkmJnRoaXMuaXNWaXNpYmxlLHRoaXMuX2JhdGNoQ2FjaGUudmlzaWJsZUluc3RhbmNlc1thXT1udWxsLHRoaXMuX3Zpc2libGVJbnN0YW5jZXMpe3ZhciBjPWIuZ2V0UmVuZGVySWQoKTt0aGlzLl9iYXRjaENhY2hlLnZpc2libGVJbnN0YW5jZXNbYV09dGhpcy5fdmlzaWJsZUluc3RhbmNlc1tjXTt2YXIgZD10aGlzLl9yZW5kZXJJZDtpZighdGhpcy5fYmF0Y2hDYWNoZS52aXNpYmxlSW5zdGFuY2VzW2FdJiZ0aGlzLl92aXNpYmxlSW5zdGFuY2VzLmRlZmF1bHRSZW5kZXJJZCYmKHRoaXMuX2JhdGNoQ2FjaGUudmlzaWJsZUluc3RhbmNlc1thXT10aGlzLl92aXNpYmxlSW5zdGFuY2VzW3RoaXMuX3Zpc2libGVJbnN0YW5jZXMuZGVmYXVsdFJlbmRlcklkXSxjPXRoaXMuX3Zpc2libGVJbnN0YW5jZXMuZGVmYXVsdFJlbmRlcklkLGQ9dGhpcy5fdmlzaWJsZUluc3RhbmNlcy5zZWxmRGVmYXVsdFJlbmRlcklkKSx0aGlzLl9iYXRjaENhY2hlLnZpc2libGVJbnN0YW5jZXNbYV0mJnRoaXMuX2JhdGNoQ2FjaGUudmlzaWJsZUluc3RhbmNlc1thXS5sZW5ndGgpe2lmKHRoaXMuX3JlbmRlcklkRm9ySW5zdGFuY2VzW2FdPT09YylyZXR1cm4gdGhpcy5fYmF0Y2hDYWNoZS5tdXN0UmV0dXJuPSEwLHRoaXMuX2JhdGNoQ2FjaGU7YyE9PWQmJih0aGlzLl9iYXRjaENhY2hlLnJlbmRlclNlbGZbYV09ITEpfXRoaXMuX3JlbmRlcklkRm9ySW5zdGFuY2VzW2FdPWN9cmV0dXJuIHRoaXMuX2JhdGNoQ2FjaGV9LGQucHJvdG90eXBlLl9yZW5kZXJXaXRoSW5zdGFuY2VzPWZ1bmN0aW9uKGEsYixjLGQsZSl7Zm9yKHZhciBmPXRoaXMuaW5zdGFuY2VzLmxlbmd0aCsxLGc9MTYqZio0O3RoaXMuX2luc3RhbmNlc0J1ZmZlclNpemU8ZzspdGhpcy5faW5zdGFuY2VzQnVmZmVyU2l6ZSo9MjsoIXRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNCdWZmZXJ8fHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNCdWZmZXIuY2FwYWNpdHk8dGhpcy5faW5zdGFuY2VzQnVmZmVyU2l6ZSkmJih0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyJiZlLmRlbGV0ZUluc3RhbmNlc0J1ZmZlcih0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyKSx0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyPWUuY3JlYXRlSW5zdGFuY2VzQnVmZmVyKHRoaXMuX2luc3RhbmNlc0J1ZmZlclNpemUpLHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNBcnJheT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuX2luc3RhbmNlc0J1ZmZlclNpemUvNCkpO3ZhciBoPTAsaT0wLGo9dGhpcy5nZXRXb3JsZE1hdHJpeCgpO2MucmVuZGVyU2VsZlthLl9pZF0mJihqLmNvcHlUb0FycmF5KHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNBcnJheSxoKSxoKz0xNixpKyspO3ZhciBrPWMudmlzaWJsZUluc3RhbmNlc1thLl9pZF07aWYoaylmb3IodmFyIGw9MDtsPGsubGVuZ3RoO2wrKyl7dmFyIG09a1tsXTttLmdldFdvcmxkTWF0cml4KCkuY29weVRvQXJyYXkodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0FycmF5LGgpLGgrPTE2LGkrK312YXIgbj1kLmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lKFwid29ybGQwXCIpLG89ZC5nZXRBdHRyaWJ1dGVMb2NhdGlvbkJ5TmFtZShcIndvcmxkMVwiKSxwPWQuZ2V0QXR0cmlidXRlTG9jYXRpb25CeU5hbWUoXCJ3b3JsZDJcIikscT1kLmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lKFwid29ybGQzXCIpLHI9W24sbyxwLHFdO2UudXBkYXRlQW5kQmluZEluc3RhbmNlc0J1ZmZlcih0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyLHRoaXMuX3dvcmxkTWF0cmljZXNJbnN0YW5jZXNBcnJheSxyKSx0aGlzLl9kcmF3KGEsIWIsaSksZS51bkJpbmRJbnN0YW5jZXNCdWZmZXIodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlcixyKX0sZC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0U2NlbmUoKSxjPXRoaXMuX2dldEluc3RhbmNlc1JlbmRlckxpc3QoYS5faWQpO2lmKCFjLm11c3RSZXR1cm4mJnRoaXMuX2dlb21ldHJ5JiZ0aGlzLl9nZW9tZXRyeS5nZXRWZXJ0ZXhCdWZmZXJzKCkmJnRoaXMuX2dlb21ldHJ5LmdldEluZGV4QnVmZmVyKCkpe2Zvcih2YXIgZD0wO2Q8dGhpcy5fb25CZWZvcmVSZW5kZXJDYWxsYmFja3MubGVuZ3RoO2QrKyl0aGlzLl9vbkJlZm9yZVJlbmRlckNhbGxiYWNrc1tkXSgpO3ZhciBlPWIuZ2V0RW5naW5lKCksZj1udWxsIT09ZS5nZXRDYXBzKCkuaW5zdGFuY2VkQXJyYXlzJiZudWxsIT09Yy52aXNpYmxlSW5zdGFuY2VzW2EuX2lkXSxnPWEuZ2V0TWF0ZXJpYWwoKTtpZihnJiZnLmlzUmVhZHkodGhpcyxmKSl7Zy5fcHJlQmluZCgpO3ZhciBoPWcuZ2V0RWZmZWN0KCksaT1lLmZvcmNlV2lyZWZyYW1lfHxnLndpcmVmcmFtZTt0aGlzLl9iaW5kKGEsaCxpKTt2YXIgaj10aGlzLmdldFdvcmxkTWF0cml4KCk7aWYoZy5iaW5kKGosdGhpcyksZil0aGlzLl9yZW5kZXJXaXRoSW5zdGFuY2VzKGEsaSxjLGgsZSk7ZWxzZSBpZihjLnJlbmRlclNlbGZbYS5faWRdJiZ0aGlzLl9kcmF3KGEsIWkpLGMudmlzaWJsZUluc3RhbmNlc1thLl9pZF0pZm9yKHZhciBrPTA7azxjLnZpc2libGVJbnN0YW5jZXNbYS5faWRdLmxlbmd0aDtrKyspe3ZhciBsPWMudmlzaWJsZUluc3RhbmNlc1thLl9pZF1ba107aj1sLmdldFdvcmxkTWF0cml4KCksZy5iaW5kT25seVdvcmxkTWF0cml4KGopLHRoaXMuX2RyYXcoYSwhaSl9Zm9yKGcudW5iaW5kKCksZD0wO2Q8dGhpcy5fb25BZnRlclJlbmRlckNhbGxiYWNrcy5sZW5ndGg7ZCsrKXRoaXMuX29uQWZ0ZXJSZW5kZXJDYWxsYmFja3NbZF0oKX19fSxkLnByb3RvdHlwZS5nZXRFbWl0dGVkUGFydGljbGVTeXN0ZW1zPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5ldyBBcnJheSxiPTA7Yjx0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuZ2V0U2NlbmUoKS5wYXJ0aWNsZVN5c3RlbXNbYl07Yy5lbWl0dGVyPT09dGhpcyYmYS5wdXNoKGMpfXJldHVybiBhfSxkLnByb3RvdHlwZS5nZXRIaWVyYXJjaHlFbWl0dGVkUGFydGljbGVTeXN0ZW1zPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IEFycmF5LGI9dGhpcy5nZXREZXNjZW5kYW50cygpO2IucHVzaCh0aGlzKTtmb3IodmFyIGM9MDtjPHRoaXMuZ2V0U2NlbmUoKS5wYXJ0aWNsZVN5c3RlbXMubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLnBhcnRpY2xlU3lzdGVtc1tjXTstMSE9PWIuaW5kZXhPZihkLmVtaXR0ZXIpJiZhLnB1c2goZCl9cmV0dXJuIGF9LGQucHJvdG90eXBlLmdldENoaWxkcmVuPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9MDtiPHRoaXMuZ2V0U2NlbmUoKS5tZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5nZXRTY2VuZSgpLm1lc2hlc1tiXTtjLnBhcmVudD09dGhpcyYmYS5wdXNoKGMpfXJldHVybiBhfSxkLnByb3RvdHlwZS5fY2hlY2tEZWxheVN0YXRlPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPXRoaXMsZD10aGlzLmdldFNjZW5lKCk7dGhpcy5fZ2VvbWV0cnk/dGhpcy5fZ2VvbWV0cnkubG9hZChkKTpjLmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEJiYoYy5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FESU5HLGQuX2FkZFBlbmRpbmdEYXRhKGMpLGEuVG9vbHMuTG9hZEZpbGUodGhpcy5kZWxheUxvYWRpbmdGaWxlLGZ1bmN0aW9uKGMpe2IuX2RlbGF5TG9hZGluZ0Z1bmN0aW9uKEpTT04ucGFyc2UoYyksYiksYi5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FERUQsZC5fcmVtb3ZlUGVuZGluZ0RhdGEoYil9LGZ1bmN0aW9uKCl7fSxkLmRhdGFiYXNlKSl9LGQucHJvdG90eXBlLmlzSW5GcnVzdHVtPWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BRElORz8hMTpjLnByb3RvdHlwZS5pc0luRnJ1c3R1bS5jYWxsKHRoaXMsYik/KHRoaXMuX2NoZWNrRGVsYXlTdGF0ZSgpLCEwKTohMX0sZC5wcm90b3R5cGUuc2V0TWF0ZXJpYWxCeUlEPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmdldFNjZW5lKCkubWF0ZXJpYWxzLGM9MDtjPGIubGVuZ3RoO2MrKylpZihiW2NdLmlkPT1hKXJldHVybiB2b2lkKHRoaXMubWF0ZXJpYWw9YltjXSk7dmFyIGQ9dGhpcy5nZXRTY2VuZSgpLm11bHRpTWF0ZXJpYWxzO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspaWYoZFtjXS5pZD09YSlyZXR1cm4gdm9pZCh0aGlzLm1hdGVyaWFsPWRbY10pfSxkLnByb3RvdHlwZS5nZXRBbmltYXRhYmxlcz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLm1hdGVyaWFsJiZhLnB1c2godGhpcy5tYXRlcmlhbCksYX0sZC5wcm90b3R5cGUuYmFrZVRyYW5zZm9ybUludG9WZXJ0aWNlcz1mdW5jdGlvbihiKXtpZih0aGlzLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpKXt0aGlzLl9yZXNldFBvaW50c0FycmF5Q2FjaGUoKTtmb3IodmFyIGM9dGhpcy5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSxkPVtdLGU9MDtlPGMubGVuZ3RoO2UrPTMpYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGEuVmVjdG9yMy5Gcm9tQXJyYXkoYyxlKSxiKS50b0FycmF5KGQsZSk7aWYodGhpcy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kLGQsdGhpcy5nZXRWZXJ0ZXhCdWZmZXIoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKS5pc1VwZGF0YWJsZSgpKSx0aGlzLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kKSl7Zm9yKGM9dGhpcy5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCksZT0wO2U8Yy5sZW5ndGg7ZSs9MylhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsKGEuVmVjdG9yMy5Gcm9tQXJyYXkoYyxlKSxiKS50b0FycmF5KGQsZSk7dGhpcy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCxkLHRoaXMuZ2V0VmVydGV4QnVmZmVyKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpLmlzVXBkYXRhYmxlKCkpfX19LGQucHJvdG90eXBlLl9yZXNldFBvaW50c0FycmF5Q2FjaGU9ZnVuY3Rpb24oKXt0aGlzLl9wb3NpdGlvbnM9bnVsbH0sZC5wcm90b3R5cGUuX2dlbmVyYXRlUG9pbnRzQXJyYXk9ZnVuY3Rpb24oKXtpZih0aGlzLl9wb3NpdGlvbnMpcmV0dXJuITA7dGhpcy5fcG9zaXRpb25zPVtdO3ZhciBiPXRoaXMuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCk7aWYoIWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKz0zKXRoaXMuX3Bvc2l0aW9ucy5wdXNoKGEuVmVjdG9yMy5Gcm9tQXJyYXkoYixjKSk7cmV0dXJuITB9LGQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1uZXcgYS5NZXNoKGIsdGhpcy5nZXRTY2VuZSgpKTtpZih0aGlzLl9nZW9tZXRyeS5hcHBseVRvTWVzaChlKSxhLlRvb2xzLkRlZXBDb3B5KHRoaXMsZSxbXCJuYW1lXCIsXCJtYXRlcmlhbFwiLFwic2tlbGV0b25cIl0sW10pLGUubWF0ZXJpYWw9dGhpcy5tYXRlcmlhbCxjJiYoZS5wYXJlbnQ9YyksIWQpZm9yKHZhciBmPTA7Zjx0aGlzLmdldFNjZW5lKCkubWVzaGVzLmxlbmd0aDtmKyspe3ZhciBnPXRoaXMuZ2V0U2NlbmUoKS5tZXNoZXNbZl07Zy5wYXJlbnQ9PXRoaXMmJmcuY2xvbmUoZy5uYW1lLGUpfWZvcihmPTA7Zjx0aGlzLmdldFNjZW5lKCkucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtmKyspe3ZhciBoPXRoaXMuZ2V0U2NlbmUoKS5wYXJ0aWNsZVN5c3RlbXNbZl07aC5lbWl0dGVyPT10aGlzJiZoLmNsb25lKGgubmFtZSxlKX1yZXR1cm4gZS5jb21wdXRlV29ybGRNYXRyaXgoITApLGV9LGQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7Zm9yKHRoaXMuX2dlb21ldHJ5JiZ0aGlzLl9nZW9tZXRyeS5yZWxlYXNlRm9yTWVzaCh0aGlzLCEwKSx0aGlzLl93b3JsZE1hdHJpY2VzSW5zdGFuY2VzQnVmZmVyJiYodGhpcy5nZXRFbmdpbmUoKS5kZWxldGVJbnN0YW5jZXNCdWZmZXIodGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlciksdGhpcy5fd29ybGRNYXRyaWNlc0luc3RhbmNlc0J1ZmZlcj1udWxsKTt0aGlzLmluc3RhbmNlcy5sZW5ndGg7KXRoaXMuaW5zdGFuY2VzWzBdLmRpc3Bvc2UoKTtjLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyxhKX0sZC5wcm90b3R5cGUuY29udmVydFRvRmxhdFNoYWRlZE1lc2g9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5nZXRWZXJ0aWNlc0RhdGFLaW5kcygpLGM9W10sZD1bXSxlPVtdLGY9ITEsZz0wO2c8Yi5sZW5ndGg7ZysrKXt2YXIgaD1iW2ddLGk9dGhpcy5nZXRWZXJ0ZXhCdWZmZXIoaCk7aCE9PWEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQ/KGNbaF09aSxkW2hdPWNbaF0uZ2V0RGF0YSgpLGVbaF09W10pOihmPWkuaXNVcGRhdGFibGUoKSxiLnNwbGljZShnLDEpLGctLSl9dmFyIGo9dGhpcy5zdWJNZXNoZXMuc2xpY2UoMCksaz10aGlzLmdldEluZGljZXMoKSxsPXRoaXMuZ2V0VG90YWxJbmRpY2VzKCk7Zm9yKHI9MDtsPnI7cisrKXt2YXIgbT1rW3JdO2ZvcihnPTA7ZzxiLmxlbmd0aDtnKyspe2g9YltnXTtmb3IodmFyIG49Y1toXS5nZXRTdHJpZGVTaXplKCksbz0wO24+bztvKyspZVtoXS5wdXNoKGRbaF1bbSpuK29dKX19Zm9yKHZhciBwPVtdLHE9ZVthLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmRdLHI9MDtsPnI7cis9Myl7a1tyXT1yLGtbcisxXT1yKzEsa1tyKzJdPXIrMjtmb3IodmFyIHM9YS5WZWN0b3IzLkZyb21BcnJheShxLDMqciksdD1hLlZlY3RvcjMuRnJvbUFycmF5KHEsMyoocisxKSksdT1hLlZlY3RvcjMuRnJvbUFycmF5KHEsMyoocisyKSksdj1zLnN1YnRyYWN0KHQpLHc9dS5zdWJ0cmFjdCh0KSx4PWEuVmVjdG9yMy5Ob3JtYWxpemUoYS5WZWN0b3IzLkNyb3NzKHYsdykpLHk9MDszPnk7eSsrKXAucHVzaCh4LngpLHAucHVzaCh4LnkpLHAucHVzaCh4LnopfWZvcih0aGlzLnNldEluZGljZXMoayksdGhpcy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCxwLGYpLGc9MDtnPGIubGVuZ3RoO2crKyloPWJbZ10sdGhpcy5zZXRWZXJ0aWNlc0RhdGEoaCxlW2hdLGNbaF0uaXNVcGRhdGFibGUoKSk7dGhpcy5yZWxlYXNlU3ViTWVzaGVzKCk7Zm9yKHZhciB6PTA7ejxqLmxlbmd0aDt6Kyspe3ZhciBBPWpbel07bmV3IGEuU3ViTWVzaChBLm1hdGVyaWFsSW5kZXgsQS5pbmRleFN0YXJ0LEEuaW5kZXhDb3VudCxBLmluZGV4U3RhcnQsQS5pbmRleENvdW50LHRoaXMpfXRoaXMuc3luY2hyb25pemVJbnN0YW5jZXMoKX0sZC5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2U9ZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBhLkluc3RhbmNlZE1lc2goYix0aGlzKX0sZC5wcm90b3R5cGUuc3luY2hyb25pemVJbnN0YW5jZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuaW5zdGFuY2VzLmxlbmd0aDthKyspe3ZhciBiPXRoaXMuaW5zdGFuY2VzW2FdO2IuX3N5bmNTdWJNZXNoZXMoKX19LGQuQ3JlYXRlQm94PWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPW5ldyBhLk1lc2goYixkKSxnPWEuVmVydGV4RGF0YS5DcmVhdGVCb3goYyk7cmV0dXJuIGcuYXBwbHlUb01lc2goZixlKSxmfSxkLkNyZWF0ZVNwaGVyZT1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPW5ldyBhLk1lc2goYixlKSxoPWEuVmVydGV4RGF0YS5DcmVhdGVTcGhlcmUoYyxkKTtyZXR1cm4gaC5hcHBseVRvTWVzaChnLGYpLGd9LGQuQ3JlYXRlQ3lsaW5kZXI9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpKXt2b2lkIDAhPT1oJiZoIGluc3RhbmNlb2YgYS5TY2VuZXx8KHZvaWQgMCE9PWgmJihpPWgpLGg9ZyxnPTEpO3ZhciBqPW5ldyBhLk1lc2goYixoKSxrPWEuVmVydGV4RGF0YS5DcmVhdGVDeWxpbmRlcihjLGQsZSxmLGcpO3JldHVybiBrLmFwcGx5VG9NZXNoKGosaSksan0sZC5DcmVhdGVUb3J1cz1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dmFyIGg9bmV3IGEuTWVzaChiLGYpLGk9YS5WZXJ0ZXhEYXRhLkNyZWF0ZVRvcnVzKGMsZCxlKTtyZXR1cm4gaS5hcHBseVRvTWVzaChoLGcpLGh9LGQuQ3JlYXRlVG9ydXNLbm90PWZ1bmN0aW9uKGIsYyxkLGUsZixnLGgsaSxqKXt2YXIgaz1uZXcgYS5NZXNoKGIsaSksbD1hLlZlcnRleERhdGEuQ3JlYXRlVG9ydXNLbm90KGMsZCxlLGYsZyxoKTtyZXR1cm4gbC5hcHBseVRvTWVzaChrLGopLGt9LGQuQ3JlYXRlTGluZXM9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9bmV3IGEuTGluZXNNZXNoKGIsZCxlKSxnPWEuVmVydGV4RGF0YS5DcmVhdGVMaW5lcyhjKTtyZXR1cm4gZy5hcHBseVRvTWVzaChmLGUpLGZ9LGQuQ3JlYXRlUGxhbmU9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9bmV3IGEuTWVzaChiLGQpLGc9YS5WZXJ0ZXhEYXRhLkNyZWF0ZVBsYW5lKGMpO3JldHVybiBnLmFwcGx5VG9NZXNoKGYsZSksZn0sZC5DcmVhdGVHcm91bmQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe3ZhciBoPW5ldyBhLkdyb3VuZE1lc2goYixmKTtoLl9zZXRSZWFkeSghMSksaC5fc3ViZGl2aXNpb25zPWU7dmFyIGk9YS5WZXJ0ZXhEYXRhLkNyZWF0ZUdyb3VuZChjLGQsZSk7cmV0dXJuIGkuYXBwbHlUb01lc2goaCxnKSxoLl9zZXRSZWFkeSghMCksaH0sZC5DcmVhdGVUaWxlZEdyb3VuZD1mdW5jdGlvbihiLGMsZCxlLGYsZyxoLGksail7dmFyIGs9bmV3IGEuTWVzaChiLGkpLGw9YS5WZXJ0ZXhEYXRhLkNyZWF0ZVRpbGVkR3JvdW5kKGMsZCxlLGYsZyxoKTtyZXR1cm4gbC5hcHBseVRvTWVzaChrLGopLGt9LGQuQ3JlYXRlR3JvdW5kRnJvbUhlaWdodE1hcD1mdW5jdGlvbihiLGMsZCxlLGYsZyxoLGksail7dmFyIGs9bmV3IGEuR3JvdW5kTWVzaChiLGkpO2suX3N1YmRpdmlzaW9ucz1mLGsuX3NldFJlYWR5KCExKTt2YXIgbD1mdW5jdGlvbihiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGk9Yy5nZXRDb250ZXh0KFwiMmRcIiksbD1iLndpZHRoLG09Yi5oZWlnaHQ7Yy53aWR0aD1sLGMuaGVpZ2h0PW0saS5kcmF3SW1hZ2UoYiwwLDApO3ZhciBuPWkuZ2V0SW1hZ2VEYXRhKDAsMCxsLG0pLmRhdGEsbz1hLlZlcnRleERhdGEuQ3JlYXRlR3JvdW5kRnJvbUhlaWdodE1hcChkLGUsZixnLGgsbixsLG0pO28uYXBwbHlUb01lc2goayxqKSxrLl9zZXRSZWFkeSghMCl9O3JldHVybiBhLlRvb2xzLkxvYWRJbWFnZShjLGwsZnVuY3Rpb24oKXt9LGkuZGF0YWJhc2UpLGt9LGQuTWluTWF4PWZ1bmN0aW9uKGEpe3ZhciBiPW51bGwsYz1udWxsO2Zvcih2YXIgZCBpbiBhKXt2YXIgZT1hW2RdLGY9ZS5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveDtiPyhiLk1pbmltaXplSW5QbGFjZShmLm1pbmltdW1Xb3JsZCksYy5NYXhpbWl6ZUluUGxhY2UoZi5tYXhpbXVtV29ybGQpKTooYj1mLm1pbmltdW1Xb3JsZCxjPWYubWF4aW11bVdvcmxkKX1yZXR1cm57bWluOmIsbWF4OmN9fSxkLkNlbnRlcj1mdW5jdGlvbihiKXt2YXIgYz12b2lkIDAhPT1iLm1pbj9iOmEuTWVzaC5NaW5NYXgoYik7cmV0dXJuIGEuVmVjdG9yMy5DZW50ZXIoYy5taW4sYy5tYXgpfSxkfShhLkFic3RyYWN0TWVzaCk7YS5NZXNoPWN9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7Yi5jYWxsKHRoaXMsYyxkKSx0aGlzLmdlbmVyYXRlT2N0cmVlPSExLHRoaXMuX3dvcmxkSW52ZXJzZT1uZXcgYS5NYXRyaXh9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInN1YmRpdmlzaW9uc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ViZGl2aXNpb25zfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLm9wdGltaXplPWZ1bmN0aW9uKCl7dGhpcy5zdWJkaXZpZGUodGhpcy5fc3ViZGl2aXNpb25zKSx0aGlzLmNyZWF0ZU9yVXBkYXRlU3VibWVzaGVzT2N0cmVlKDMyKX0sYy5wcm90b3R5cGUuZ2V0SGVpZ2h0QXRDb29yZGluYXRlcz1mdW5jdGlvbihiLGMpe3ZhciBkPW5ldyBhLlJheShuZXcgYS5WZWN0b3IzKGIsdGhpcy5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveC5tYXhpbXVtV29ybGQueSsxLGMpLG5ldyBhLlZlY3RvcjMoMCwtMSwwKSk7dGhpcy5nZXRXb3JsZE1hdHJpeCgpLmludmVydFRvUmVmKHRoaXMuX3dvcmxkSW52ZXJzZSksZD1hLlJheS5UcmFuc2Zvcm0oZCx0aGlzLl93b3JsZEludmVyc2UpO3ZhciBlPXRoaXMuaW50ZXJzZWN0cyhkKTtyZXR1cm4gZS5oaXQ/ZS5waWNrZWRQb2ludC55OjB9LGN9KGEuTWVzaCk7YS5Hcm91bmRNZXNoPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyl7Yi5jYWxsKHRoaXMsYSxjLmdldFNjZW5lKCkpLGMuaW5zdGFuY2VzLnB1c2godGhpcyksdGhpcy5fc291cmNlTWVzaD1jLHRoaXMucG9zaXRpb24uY29weUZyb20oYy5wb3NpdGlvbiksdGhpcy5yb3RhdGlvbi5jb3B5RnJvbShjLnJvdGF0aW9uKSx0aGlzLnNjYWxpbmcuY29weUZyb20oYy5zY2FsaW5nKSxjLnJvdGF0aW9uUXVhdGVybmlvbiYmKHRoaXMucm90YXRpb25RdWF0ZXJuaW9uPWMucm90YXRpb25RdWF0ZXJuaW9uLmNsb25lKCkpLHRoaXMuaW5maW5pdGVEaXN0YW5jZT1jLmluZmluaXRlRGlzdGFuY2UsdGhpcy5zZXRQaXZvdE1hdHJpeChjLmdldFBpdm90TWF0cml4KCkpLHRoaXMucmVmcmVzaEJvdW5kaW5nSW5mbygpLHRoaXMuX3N5bmNTdWJNZXNoZXMoKX1yZXR1cm4gX19leHRlbmRzKGMsYiksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwicmVjZWl2ZVNoYWRvd3NcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2gucmVjZWl2ZVNoYWRvd3N9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwibWF0ZXJpYWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2gubWF0ZXJpYWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwidmlzaWJpbGl0eVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC52aXNpYmlsaXR5fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInNrZWxldG9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLnNrZWxldG9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5nZXRUb3RhbFZlcnRpY2VzKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInNvdXJjZU1lc2hcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2h9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYy5wcm90b3R5cGUuZ2V0VmVydGljZXNEYXRhPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLmdldFZlcnRpY2VzRGF0YShhKX0sYy5wcm90b3R5cGUuaXNWZXJ0aWNlc0RhdGFQcmVzZW50PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLmlzVmVydGljZXNEYXRhUHJlc2VudChhKX0sYy5wcm90b3R5cGUuZ2V0SW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VyY2VNZXNoLmdldEluZGljZXMoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwiX3Bvc2l0aW9uc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlTWVzaC5fcG9zaXRpb25zfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGMucHJvdG90eXBlLnJlZnJlc2hCb3VuZGluZ0luZm89ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl9zb3VyY2VNZXNoLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpO2lmKGIpe3ZhciBjPWEuVG9vbHMuRXh0cmFjdE1pbkFuZE1heChiLDAsdGhpcy5fc291cmNlTWVzaC5nZXRUb3RhbFZlcnRpY2VzKCkpO3RoaXMuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oYy5taW5pbXVtLGMubWF4aW11bSl9dGhpcy5fdXBkYXRlQm91bmRpbmdJbmZvKCl9LGMucHJvdG90eXBlLl9wcmVBY3RpdmF0ZT1mdW5jdGlvbigpe3RoaXMuc291cmNlTWVzaC5fcHJlQWN0aXZhdGUoKX0sYy5wcm90b3R5cGUuX2FjdGl2YXRlPWZ1bmN0aW9uKGEpe3RoaXMuc291cmNlTWVzaC5fcmVnaXN0ZXJJbnN0YW5jZUZvclJlbmRlcklkKHRoaXMsYSl9LGMucHJvdG90eXBlLl9zeW5jU3ViTWVzaGVzPWZ1bmN0aW9uKCl7dGhpcy5yZWxlYXNlU3ViTWVzaGVzKCk7Zm9yKHZhciBhPTA7YTx0aGlzLl9zb3VyY2VNZXNoLnN1Yk1lc2hlcy5sZW5ndGg7YSsrKXRoaXMuX3NvdXJjZU1lc2guc3ViTWVzaGVzW2FdLmNsb25lKHRoaXMsdGhpcy5fc291cmNlTWVzaCl9LGMucHJvdG90eXBlLl9nZW5lcmF0ZVBvaW50c0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZU1lc2guX2dlbmVyYXRlUG9pbnRzQXJyYXkoKX0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXMuX3NvdXJjZU1lc2guY3JlYXRlSW5zdGFuY2UoYik7aWYoYS5Ub29scy5EZWVwQ29weSh0aGlzLGUsW1wibmFtZVwiXSxbXSksdGhpcy5yZWZyZXNoQm91bmRpbmdJbmZvKCksYyYmKGUucGFyZW50PWMpLCFkKWZvcih2YXIgZj0wO2Y8dGhpcy5nZXRTY2VuZSgpLm1lc2hlcy5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLmdldFNjZW5lKCkubWVzaGVzW2ZdO2cucGFyZW50PT10aGlzJiZnLmNsb25lKGcubmFtZSxlKX1yZXR1cm4gZS5jb21wdXRlV29ybGRNYXRyaXgoITApLGV9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5fc291cmNlTWVzaC5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTt0aGlzLl9zb3VyY2VNZXNoLmluc3RhbmNlcy5zcGxpY2UoYywxKSxiLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyxhKX0sY30oYS5BYnN0cmFjdE1lc2gpO2EuSW5zdGFuY2VkTWVzaD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMsZCxlLGYsZyxoKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgaCYmKGg9ITApLHRoaXMubWF0ZXJpYWxJbmRleD1hLHRoaXMudmVydGljZXNTdGFydD1iLHRoaXMudmVydGljZXNDb3VudD1jLHRoaXMuaW5kZXhTdGFydD1kLHRoaXMuaW5kZXhDb3VudD1lLHRoaXMuX3JlbmRlcklkPTAsdGhpcy5fbWVzaD1mLHRoaXMuX3JlbmRlcmluZ01lc2g9Z3x8ZixmLnN1Yk1lc2hlcy5wdXNoKHRoaXMpLHRoaXMuX2lkPWYuc3ViTWVzaGVzLmxlbmd0aC0xLGgmJnRoaXMucmVmcmVzaEJvdW5kaW5nSW5mbygpfXJldHVybiBiLnByb3RvdHlwZS5nZXRCb3VuZGluZ0luZm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRpbmdJbmZvfSxiLnByb3RvdHlwZS5nZXRNZXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21lc2h9LGIucHJvdG90eXBlLmdldFJlbmRlcmluZ01lc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyaW5nTWVzaH0sYi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWw9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl9yZW5kZXJpbmdNZXNoLm1hdGVyaWFsO2lmKGImJmIgaW5zdGFuY2VvZiBhLk11bHRpTWF0ZXJpYWwpe3ZhciBjPWI7cmV0dXJuIGMuZ2V0U3ViTWF0ZXJpYWwodGhpcy5tYXRlcmlhbEluZGV4KX1yZXR1cm4gYj9iOnRoaXMuX21lc2guZ2V0U2NlbmUoKS5kZWZhdWx0TWF0ZXJpYWx9LGIucHJvdG90eXBlLnJlZnJlc2hCb3VuZGluZ0luZm89ZnVuY3Rpb24oKXt2YXIgYj10aGlzLl9yZW5kZXJpbmdNZXNoLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpO2lmKCFiKXJldHVybiB2b2lkKHRoaXMuX2JvdW5kaW5nSW5mbz10aGlzLl9tZXNoLl9ib3VuZGluZ0luZm8pO3ZhciBjLGQ9dGhpcy5fcmVuZGVyaW5nTWVzaC5nZXRJbmRpY2VzKCk7Yz0wPT09dGhpcy5pbmRleFN0YXJ0JiZ0aGlzLmluZGV4Q291bnQ9PT1kLmxlbmd0aD9hLlRvb2xzLkV4dHJhY3RNaW5BbmRNYXgoYix0aGlzLnZlcnRpY2VzU3RhcnQsdGhpcy52ZXJ0aWNlc0NvdW50KTphLlRvb2xzLkV4dHJhY3RNaW5BbmRNYXhJbmRleGVkKGIsZCx0aGlzLmluZGV4U3RhcnQsdGhpcy5pbmRleENvdW50KSx0aGlzLl9ib3VuZGluZ0luZm89bmV3IGEuQm91bmRpbmdJbmZvKGMubWluaW11bSxjLm1heGltdW0pfSxiLnByb3RvdHlwZS5fY2hlY2tDb2xsaXNpb249ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2JvdW5kaW5nSW5mby5fY2hlY2tDb2xsaXNpb24oYSl9LGIucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nSW5mbz1mdW5jdGlvbihhKXt0aGlzLl9ib3VuZGluZ0luZm98fHRoaXMucmVmcmVzaEJvdW5kaW5nSW5mbygpLHRoaXMuX2JvdW5kaW5nSW5mby5fdXBkYXRlKGEpfSxiLnByb3RvdHlwZS5pc0luRnJ1c3R1bT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fYm91bmRpbmdJbmZvLmlzSW5GcnVzdHVtKGEpfSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJpbmdNZXNoLnJlbmRlcih0aGlzKX0sYi5wcm90b3R5cGUuZ2V0TGluZXNJbmRleEJ1ZmZlcj1mdW5jdGlvbihhLGIpe2lmKCF0aGlzLl9saW5lc0luZGV4QnVmZmVyKXtmb3IodmFyIGM9W10sZD10aGlzLmluZGV4U3RhcnQ7ZDx0aGlzLmluZGV4U3RhcnQrdGhpcy5pbmRleENvdW50O2QrPTMpYy5wdXNoKGFbZF0sYVtkKzFdLGFbZCsxXSxhW2QrMl0sYVtkKzJdLGFbZF0pO3RoaXMuX2xpbmVzSW5kZXhCdWZmZXI9Yi5jcmVhdGVJbmRleEJ1ZmZlcihjKSx0aGlzLmxpbmVzSW5kZXhDb3VudD1jLmxlbmd0aH1yZXR1cm4gdGhpcy5fbGluZXNJbmRleEJ1ZmZlcn0sYi5wcm90b3R5cGUuY2FuSW50ZXJzZWN0cz1mdW5jdGlvbihhKXtyZXR1cm4gYS5pbnRlcnNlY3RzQm94KHRoaXMuX2JvdW5kaW5nSW5mby5ib3VuZGluZ0JveCl9LGIucHJvdG90eXBlLmludGVyc2VjdHM9ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlPW51bGwsZj10aGlzLmluZGV4U3RhcnQ7Zjx0aGlzLmluZGV4U3RhcnQrdGhpcy5pbmRleENvdW50O2YrPTMpe3ZhciBnPWJbY1tmXV0saD1iW2NbZisxXV0saT1iW2NbZisyXV0saj1hLmludGVyc2VjdHNUcmlhbmdsZShnLGgsaSk7aWYoaiYmKGR8fCFlfHxqLmRpc3RhbmNlPGUuZGlzdGFuY2UpJiYoZT1qLGUuZmFjZUlkPWYvMyxkKSlicmVha31yZXR1cm4gZX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYyxkKXt2YXIgZT1uZXcgYih0aGlzLm1hdGVyaWFsSW5kZXgsdGhpcy52ZXJ0aWNlc1N0YXJ0LHRoaXMudmVydGljZXNDb3VudCx0aGlzLmluZGV4U3RhcnQsdGhpcy5pbmRleENvdW50LGMsZCwhMSk7cmV0dXJuIGUuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8odGhpcy5fYm91bmRpbmdJbmZvLm1pbmltdW0sdGhpcy5fYm91bmRpbmdJbmZvLm1heGltdW0pLGV9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9saW5lc0luZGV4QnVmZmVyJiYodGhpcy5fbWVzaC5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2xpbmVzSW5kZXhCdWZmZXIpLHRoaXMuX2xpbmVzSW5kZXhCdWZmZXI9bnVsbCk7dmFyIGE9dGhpcy5fbWVzaC5zdWJNZXNoZXMuaW5kZXhPZih0aGlzKTt0aGlzLl9tZXNoLnN1Yk1lc2hlcy5zcGxpY2UoYSwxKX0sYi5DcmVhdGVGcm9tSW5kaWNlcz1mdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPU51bWJlci5NQVhfVkFMVUUsaD0tTnVtYmVyLk1BWF9WQUxVRTtmPWZ8fGU7Zm9yKHZhciBpPWYuZ2V0SW5kaWNlcygpLGo9YztjK2Q+ajtqKyspe3ZhciBrPWlbal07Zz5rJiYoZz1rKSxrPmgmJihoPWspfXJldHVybiBuZXcgYS5TdWJNZXNoKGIsZyxoLWcrMSxjLGQsZSxmKX0sYn0oKTthLlN1Yk1lc2g9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3RoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9ORSx0aGlzLmhhc0FscGhhPSExLHRoaXMuZ2V0QWxwaGFGcm9tUkdCPSExLHRoaXMubGV2ZWw9MSx0aGlzLmlzQ3ViZT0hMSx0aGlzLmlzUmVuZGVyVGFyZ2V0PSExLHRoaXMuYW5pbWF0aW9ucz1uZXcgQXJyYXksdGhpcy5jb29yZGluYXRlc0luZGV4PTAsdGhpcy5jb29yZGluYXRlc01vZGU9YS5UZXh0dXJlLkVYUExJQ0lUX01PREUsdGhpcy53cmFwVT1hLlRleHR1cmUuV1JBUF9BRERSRVNTTU9ERSx0aGlzLndyYXBWPWEuVGV4dHVyZS5XUkFQX0FERFJFU1NNT0RFLHRoaXMuYW5pc290cm9waWNGaWx0ZXJpbmdMZXZlbD00LHRoaXMuX3NjZW5lPWIsdGhpcy5fc2NlbmUudGV4dHVyZXMucHVzaCh0aGlzKX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0U2NlbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NlbmV9LGIucHJvdG90eXBlLmdldFRleHR1cmVNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZ2V0SW50ZXJuYWxUZXh0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RleHR1cmV9LGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PVExPQURFRD8hMDp0aGlzLl90ZXh0dXJlP3RoaXMuX3RleHR1cmUuaXNSZWFkeTohMX0sYi5wcm90b3R5cGUuZ2V0U2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlLl93aWR0aD97d2lkdGg6dGhpcy5fdGV4dHVyZS5fd2lkdGgsaGVpZ2h0OnRoaXMuX3RleHR1cmUuX2hlaWdodH06dGhpcy5fdGV4dHVyZS5fc2l6ZT97d2lkdGg6dGhpcy5fdGV4dHVyZS5fc2l6ZSxoZWlnaHQ6dGhpcy5fdGV4dHVyZS5fc2l6ZX06e3dpZHRoOjAsaGVpZ2h0OjB9fSxiLnByb3RvdHlwZS5nZXRCYXNlU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUmVhZHkoKT90aGlzLl90ZXh0dXJlLl9zaXplP3t3aWR0aDp0aGlzLl90ZXh0dXJlLl9zaXplLGhlaWdodDp0aGlzLl90ZXh0dXJlLl9zaXplfTp7d2lkdGg6dGhpcy5fdGV4dHVyZS5fYmFzZVdpZHRoLGhlaWdodDp0aGlzLl90ZXh0dXJlLl9iYXNlSGVpZ2h0fTp7d2lkdGg6MCxoZWlnaHQ6MH19LGIucHJvdG90eXBlLl9nZXRGcm9tQ2FjaGU9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuZ2V0TG9hZGVkVGV4dHVyZXNDYWNoZSgpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihlLnVybD09PWEmJmUubm9NaXBtYXA9PT1iKXJldHVybiBlLnJlZmVyZW5jZXMrKyxlfXJldHVybiBudWxsfSxiLnByb3RvdHlwZS5kZWxheUxvYWQ9ZnVuY3Rpb24oKXt9LGIucHJvdG90eXBlLnJlbGVhc2VJbnRlcm5hbFRleHR1cmU9ZnVuY3Rpb24oKXtpZih0aGlzLl90ZXh0dXJlKXt2YXIgYT10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5nZXRMb2FkZWRUZXh0dXJlc0NhY2hlKCk7aWYodGhpcy5fdGV4dHVyZS5yZWZlcmVuY2VzLS0sMD09dGhpcy5fdGV4dHVyZS5yZWZlcmVuY2VzKXt2YXIgYj1hLmluZGV4T2YodGhpcy5fdGV4dHVyZSk7YS5zcGxpY2UoYiwxKSx0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZVRleHR1cmUodGhpcy5fdGV4dHVyZSksZGVsZXRlIHRoaXMuX3RleHR1cmV9fX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX3NjZW5lLnRleHR1cmVzLmluZGV4T2YodGhpcyk7YT49MCYmdGhpcy5fc2NlbmUudGV4dHVyZXMuc3BsaWNlKGEsMSksdm9pZCAwIT09dGhpcy5fdGV4dHVyZSYmKHRoaXMucmVsZWFzZUludGVybmFsVGV4dHVyZSgpLHRoaXMub25EaXNwb3NlJiZ0aGlzLm9uRGlzcG9zZSgpKX0sYn0oKTthLkJhc2VUZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMpe3RoaXMuaW5kZXg9Yix0aGlzLl9vcGFxdWVTdWJNZXNoZXM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzPW5ldyBhLlNtYXJ0QXJyYXkoMjU2KSx0aGlzLl9hbHBoYVRlc3RTdWJNZXNoZXM9bmV3IGEuU21hcnRBcnJheSgyNTYpLHRoaXMuX3NjZW5lPWN9cmV0dXJuIGIucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihiLGMpe2lmKGIpcmV0dXJuIGIodGhpcy5fb3BhcXVlU3ViTWVzaGVzLHRoaXMuX2FscGhhVGVzdFN1Yk1lc2hlcyx0aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcyxjKSwhMDtpZigwPT09dGhpcy5fb3BhcXVlU3ViTWVzaGVzLmxlbmd0aCYmMD09PXRoaXMuX2FscGhhVGVzdFN1Yk1lc2hlcy5sZW5ndGgmJjA9PT10aGlzLl90cmFuc3BhcmVudFN1Yk1lc2hlcy5sZW5ndGgpcmV0dXJuITE7dmFyIGQsZSxmPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2ZvcihkPTA7ZDx0aGlzLl9vcGFxdWVTdWJNZXNoZXMubGVuZ3RoO2QrKyllPXRoaXMuX29wYXF1ZVN1Yk1lc2hlcy5kYXRhW2RdLHRoaXMuX2FjdGl2ZVZlcnRpY2VzKz1lLnZlcnRpY2VzQ291bnQsZS5yZW5kZXIoKTtmb3IoZi5zZXRBbHBoYVRlc3RpbmcoITApLGQ9MDtkPHRoaXMuX2FscGhhVGVzdFN1Yk1lc2hlcy5sZW5ndGg7ZCsrKWU9dGhpcy5fYWxwaGFUZXN0U3ViTWVzaGVzLmRhdGFbZF0sdGhpcy5fYWN0aXZlVmVydGljZXMrPWUudmVydGljZXNDb3VudCxlLnJlbmRlcigpO2lmKGYuc2V0QWxwaGFUZXN0aW5nKCExKSxjJiZjKCksdGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMubGVuZ3RoKXtmb3IoZD0wO2Q8dGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMubGVuZ3RoO2QrKyllPXRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLmRhdGFbZF0sZS5fZGlzdGFuY2VUb0NhbWVyYT1lLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nU3BoZXJlLmNlbnRlcldvcmxkLnN1YnRyYWN0KHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbikubGVuZ3RoKCk7dmFyIGc9dGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMuZGF0YS5zbGljZSgwLHRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLmxlbmd0aCk7Zm9yKGcuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLl9kaXN0YW5jZVRvQ2FtZXJhPGIuX2Rpc3RhbmNlVG9DYW1lcmE/MTphLl9kaXN0YW5jZVRvQ2FtZXJhPmIuX2Rpc3RhbmNlVG9DYW1lcmE/LTE6MH0pLGYuc2V0QWxwaGFNb2RlKGEuRW5naW5lLkFMUEhBX0NPTUJJTkUpLGQ9MDtkPGcubGVuZ3RoO2QrKyllPWdbZF0sdGhpcy5fYWN0aXZlVmVydGljZXMrPWUudmVydGljZXNDb3VudCxlLnJlbmRlcigpO2Yuc2V0QWxwaGFNb2RlKGEuRW5naW5lLkFMUEhBX0RJU0FCTEUpfXJldHVybiEwfSxiLnByb3RvdHlwZS5wcmVwYXJlPWZ1bmN0aW9uKCl7dGhpcy5fb3BhcXVlU3ViTWVzaGVzLnJlc2V0KCksdGhpcy5fdHJhbnNwYXJlbnRTdWJNZXNoZXMucmVzZXQoKSx0aGlzLl9hbHBoYVRlc3RTdWJNZXNoZXMucmVzZXQoKX0sYi5wcm90b3R5cGUuZGlzcGF0Y2g9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRNYXRlcmlhbCgpLGM9YS5nZXRNZXNoKCk7Yi5uZWVkQWxwaGFCbGVuZGluZygpfHxjLnZpc2liaWxpdHk8MT8oYi5hbHBoYT4wfHxjLnZpc2liaWxpdHk8MSkmJnRoaXMuX3RyYW5zcGFyZW50U3ViTWVzaGVzLnB1c2goYSk6Yi5uZWVkQWxwaGFUZXN0aW5nKCk/dGhpcy5fYWxwaGFUZXN0U3ViTWVzaGVzLnB1c2goYSk6dGhpcy5fb3BhcXVlU3ViTWVzaGVzLnB1c2goYSl9LGJ9KCk7YS5SZW5kZXJpbmdHcm91cD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7dGhpcy5fcmVuZGVyaW5nR3JvdXBzPW5ldyBBcnJheSx0aGlzLl9zY2VuZT1hfXJldHVybiBiLnByb3RvdHlwZS5fcmVuZGVyUGFydGljbGVzPWZ1bmN0aW9uKGEsYil7aWYoMCE9PXRoaXMuX3NjZW5lLl9hY3RpdmVQYXJ0aWNsZVN5c3RlbXMubGVuZ3RoKXtmb3IodmFyIGM9KG5ldyBEYXRlKS5nZXRUaW1lKCksZD0wO2Q8dGhpcy5fc2NlbmUuX2FjdGl2ZVBhcnRpY2xlU3lzdGVtcy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLl9zY2VuZS5fYWN0aXZlUGFydGljbGVTeXN0ZW1zLmRhdGFbZF07ZS5yZW5kZXJpbmdHcm91cElkPT09YSYmKHRoaXMuX2NsZWFyRGVwdGhCdWZmZXIoKSxlLmVtaXR0ZXIucG9zaXRpb24mJmImJi0xPT09Yi5pbmRleE9mKGUuZW1pdHRlcil8fCh0aGlzLl9zY2VuZS5fYWN0aXZlUGFydGljbGVzKz1lLnJlbmRlcigpKSl9dGhpcy5fc2NlbmUuX3BhcnRpY2xlc0R1cmF0aW9uKz0obmV3IERhdGUpLmdldFRpbWUoKS1jfX0sYi5wcm90b3R5cGUuX3JlbmRlclNwcml0ZXM9ZnVuY3Rpb24oYSl7aWYoMCE9PXRoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzLmxlbmd0aCl7Zm9yKHZhciBiPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGM9MDtjPHRoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzLmxlbmd0aDtjKyspe3ZhciBkPXRoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzW2NdO2QucmVuZGVyaW5nR3JvdXBJZD09PWEmJih0aGlzLl9jbGVhckRlcHRoQnVmZmVyKCksZC5yZW5kZXIoKSl9dGhpcy5fc2NlbmUuX3Nwcml0ZXNEdXJhdGlvbis9KG5ldyBEYXRlKS5nZXRUaW1lKCktYn19LGIucHJvdG90eXBlLl9jbGVhckRlcHRoQnVmZmVyPWZ1bmN0aW9uKCl7dGhpcy5fZGVwdGhCdWZmZXJBbHJlYWR5Q2xlYW5lZHx8KHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmNsZWFyKDAsITEsITApLHRoaXMuX2RlcHRoQnVmZmVyQWxyZWFkeUNsZWFuZWQ9ITApfSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYixjLGQsZSl7Zm9yKHZhciBmPXRoaXMsZz0wO2c8YS5SZW5kZXJpbmdNYW5hZ2VyLk1BWF9SRU5ERVJJTkdHUk9VUFM7ZysrKXt0aGlzLl9kZXB0aEJ1ZmZlckFscmVhZHlDbGVhbmVkPSExO3ZhciBoPXRoaXMuX3JlbmRlcmluZ0dyb3Vwc1tnXTtoPyh0aGlzLl9jbGVhckRlcHRoQnVmZmVyKCksaC5yZW5kZXIoYixmdW5jdGlvbigpe2UmJmYuX3JlbmRlclNwcml0ZXMoZyl9KXx8dGhpcy5fcmVuZGVyaW5nR3JvdXBzLnNwbGljZShnLDEpKTplJiZ0aGlzLl9yZW5kZXJTcHJpdGVzKGcpLGQmJnRoaXMuX3JlbmRlclBhcnRpY2xlcyhnLGMpfX0sYi5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGEgaW4gdGhpcy5fcmVuZGVyaW5nR3JvdXBzKXt2YXIgYj10aGlzLl9yZW5kZXJpbmdHcm91cHNbYV07Yi5wcmVwYXJlKCl9fSxiLnByb3RvdHlwZS5kaXNwYXRjaD1mdW5jdGlvbihiKXt2YXIgYz1iLmdldE1lc2goKSxkPWMucmVuZGVyaW5nR3JvdXBJZHx8MDt0aGlzLl9yZW5kZXJpbmdHcm91cHNbZF18fCh0aGlzLl9yZW5kZXJpbmdHcm91cHNbZF09bmV3IGEuUmVuZGVyaW5nR3JvdXAoZCx0aGlzLl9zY2VuZSkpLHRoaXMuX3JlbmRlcmluZ0dyb3Vwc1tkXS5kaXNwYXRjaChiKX0sYi5NQVhfUkVOREVSSU5HR1JPVVBTPTQsYn0oKTthLlJlbmRlcmluZ01hbmFnZXI9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoZCxlLGYsZyxoKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgaCYmKGg9Yy5UUklMSU5FQVJfU0FNUExJTkdNT0RFKSxiLmNhbGwodGhpcyxlKSx0aGlzLnVPZmZzZXQ9MCx0aGlzLnZPZmZzZXQ9MCx0aGlzLnVTY2FsZT0xLHRoaXMudlNjYWxlPTEsdGhpcy51QW5nPTAsdGhpcy52QW5nPTAsdGhpcy53QW5nPTAsdGhpcy5uYW1lPWQsdGhpcy51cmw9ZCx0aGlzLl9ub01pcG1hcD1mLHRoaXMuX2ludmVydFk9Zyx0aGlzLl9zYW1wbGluZ01vZGU9aCxkJiYodGhpcy5fdGV4dHVyZT10aGlzLl9nZXRGcm9tQ2FjaGUoZCxmKSx0aGlzLl90ZXh0dXJlfHwoZS51c2VEZWxheWVkVGV4dHVyZUxvYWRpbmc/dGhpcy5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQ6dGhpcy5fdGV4dHVyZT1lLmdldEVuZ2luZSgpLmNyZWF0ZVRleHR1cmUoZCxmLGcsZSx0aGlzLl9zYW1wbGluZ01vZGUpKSl9cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLmRlbGF5TG9hZD1mdW5jdGlvbigpe3RoaXMuZGVsYXlMb2FkU3RhdGU9PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PVExPQURFRCYmKHRoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BREVELHRoaXMuX3RleHR1cmU9dGhpcy5fZ2V0RnJvbUNhY2hlKHRoaXMudXJsLHRoaXMuX25vTWlwbWFwKSx0aGlzLl90ZXh0dXJlfHwodGhpcy5fdGV4dHVyZT10aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCkuY3JlYXRlVGV4dHVyZSh0aGlzLnVybCx0aGlzLl9ub01pcG1hcCx0aGlzLl9pbnZlcnRZLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9zYW1wbGluZ01vZGUpKSl9LGMucHJvdG90eXBlLl9wcmVwYXJlUm93Rm9yVGV4dHVyZUdlbmVyYXRpb249ZnVuY3Rpb24oYixjLGQsZSl7Yi09dGhpcy51T2Zmc2V0Ky41LGMtPXRoaXMudk9mZnNldCsuNSxkLT0uNSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNGcm9tRmxvYXRzVG9SZWYoYixjLGQsdGhpcy5fcm93R2VuZXJhdGlvbk1hdHJpeCxlKSxlLngqPXRoaXMudVNjYWxlLGUueSo9dGhpcy52U2NhbGUsZS54Kz0uNSxlLnkrPS41LGUueis9LjV9LGMucHJvdG90eXBlLmdldFRleHR1cmVNYXRyaXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51T2Zmc2V0PT09dGhpcy5fY2FjaGVkVU9mZnNldCYmdGhpcy52T2Zmc2V0PT09dGhpcy5fY2FjaGVkVk9mZnNldCYmdGhpcy51U2NhbGU9PT10aGlzLl9jYWNoZWRVU2NhbGUmJnRoaXMudlNjYWxlPT09dGhpcy5fY2FjaGVkVlNjYWxlJiZ0aGlzLnVBbmc9PT10aGlzLl9jYWNoZWRVQW5nJiZ0aGlzLnZBbmc9PT10aGlzLl9jYWNoZWRWQW5nJiZ0aGlzLndBbmc9PT10aGlzLl9jYWNoZWRXQW5nP3RoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXg6KHRoaXMuX2NhY2hlZFVPZmZzZXQ9dGhpcy51T2Zmc2V0LHRoaXMuX2NhY2hlZFZPZmZzZXQ9dGhpcy52T2Zmc2V0LHRoaXMuX2NhY2hlZFVTY2FsZT10aGlzLnVTY2FsZSx0aGlzLl9jYWNoZWRWU2NhbGU9dGhpcy52U2NhbGUsdGhpcy5fY2FjaGVkVUFuZz10aGlzLnVBbmcsdGhpcy5fY2FjaGVkVkFuZz10aGlzLnZBbmcsdGhpcy5fY2FjaGVkV0FuZz10aGlzLndBbmcsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeHx8KHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX3Jvd0dlbmVyYXRpb25NYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuX3QwPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fdDE9YS5WZWN0b3IzLlplcm8oKSx0aGlzLl90Mj1hLlZlY3RvcjMuWmVybygpKSxhLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHRoaXMudkFuZyx0aGlzLnVBbmcsdGhpcy53QW5nLHRoaXMuX3Jvd0dlbmVyYXRpb25NYXRyaXgpLHRoaXMuX3ByZXBhcmVSb3dGb3JUZXh0dXJlR2VuZXJhdGlvbigwLDAsMCx0aGlzLl90MCksdGhpcy5fcHJlcGFyZVJvd0ZvclRleHR1cmVHZW5lcmF0aW9uKDEsMCwwLHRoaXMuX3QxKSx0aGlzLl9wcmVwYXJlUm93Rm9yVGV4dHVyZUdlbmVyYXRpb24oMCwxLDAsdGhpcy5fdDIpLHRoaXMuX3QxLnN1YnRyYWN0SW5QbGFjZSh0aGlzLl90MCksdGhpcy5fdDIuc3VidHJhY3RJblBsYWNlKHRoaXMuX3QwKSxhLk1hdHJpeC5JZGVudGl0eVRvUmVmKHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpLHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVswXT10aGlzLl90MS54LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsxXT10aGlzLl90MS55LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsyXT10aGlzLl90MS56LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVs0XT10aGlzLl90Mi54LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVs1XT10aGlzLl90Mi55LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVs2XT10aGlzLl90Mi56LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVs4XT10aGlzLl90MC54LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVs5XT10aGlzLl90MC55LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgubVsxMF09dGhpcy5fdDAueix0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KX0sYy5wcm90b3R5cGUuZ2V0UmVmbGVjdGlvblRleHR1cmVNYXRyaXg9ZnVuY3Rpb24oKXtpZih0aGlzLnVPZmZzZXQ9PT10aGlzLl9jYWNoZWRVT2Zmc2V0JiZ0aGlzLnZPZmZzZXQ9PT10aGlzLl9jYWNoZWRWT2Zmc2V0JiZ0aGlzLnVTY2FsZT09PXRoaXMuX2NhY2hlZFVTY2FsZSYmdGhpcy52U2NhbGU9PT10aGlzLl9jYWNoZWRWU2NhbGUmJnRoaXMuY29vcmRpbmF0ZXNNb2RlPT09dGhpcy5fY2FjaGVkQ29vcmRpbmF0ZXNNb2RlKXJldHVybiB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4O3N3aXRjaCh0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4fHwodGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeD1hLk1hdHJpeC5aZXJvKCksdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXg9YS5NYXRyaXguWmVybygpKSx0aGlzLmNvb3JkaW5hdGVzTW9kZSl7Y2FzZSBhLlRleHR1cmUuU1BIRVJJQ0FMX01PREU6YS5NYXRyaXguSWRlbnRpdHlUb1JlZih0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4KSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzBdPS0uNSp0aGlzLnVTY2FsZSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzVdPS0uNSp0aGlzLnZTY2FsZSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzEyXT0uNSt0aGlzLnVPZmZzZXQsdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFsxM109LjUrdGhpcy52T2Zmc2V0O2JyZWFrO2Nhc2UgYS5UZXh0dXJlLlBMQU5BUl9NT0RFOmEuTWF0cml4LklkZW50aXR5VG9SZWYodGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeCksdGhpcy5fY2FjaGVkVGV4dHVyZU1hdHJpeFswXT10aGlzLnVTY2FsZSx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzVdPXRoaXMudlNjYWxlLHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXhbMTJdPXRoaXMudU9mZnNldCx0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4WzEzXT10aGlzLnZPZmZzZXQ7YnJlYWs7Y2FzZSBhLlRleHR1cmUuUFJPSkVDVElPTl9NT0RFOmEuTWF0cml4LklkZW50aXR5VG9SZWYodGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgpLHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4Lm1bMF09LjUsdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgubVs1XT0tLjUsdGhpcy5fcHJvamVjdGlvbk1vZGVNYXRyaXgubVsxMF09MCx0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeC5tWzEyXT0uNSx0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeC5tWzEzXT0uNSx0aGlzLl9wcm9qZWN0aW9uTW9kZU1hdHJpeC5tWzE0XT0xLHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4Lm1bMTVdPTEsdGhpcy5nZXRTY2VuZSgpLmdldFByb2plY3Rpb25NYXRyaXgoKS5tdWx0aXBseVRvUmVmKHRoaXMuX3Byb2plY3Rpb25Nb2RlTWF0cml4LHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpO1xuYnJlYWs7ZGVmYXVsdDphLk1hdHJpeC5JZGVudGl0eVRvUmVmKHRoaXMuX2NhY2hlZFRleHR1cmVNYXRyaXgpfXJldHVybiB0aGlzLl9jYWNoZWRUZXh0dXJlTWF0cml4fSxjLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBiPW5ldyBhLlRleHR1cmUodGhpcy5fdGV4dHVyZS51cmwsdGhpcy5nZXRTY2VuZSgpLHRoaXMuX25vTWlwbWFwLHRoaXMuX2ludmVydFkpO3JldHVybiBiLmhhc0FscGhhPXRoaXMuaGFzQWxwaGEsYi5sZXZlbD10aGlzLmxldmVsLGIud3JhcFU9dGhpcy53cmFwVSxiLndyYXBWPXRoaXMud3JhcFYsYi5jb29yZGluYXRlc0luZGV4PXRoaXMuY29vcmRpbmF0ZXNJbmRleCxiLmNvb3JkaW5hdGVzTW9kZT10aGlzLmNvb3JkaW5hdGVzTW9kZSxiLnVPZmZzZXQ9dGhpcy51T2Zmc2V0LGIudk9mZnNldD10aGlzLnZPZmZzZXQsYi51U2NhbGU9dGhpcy51U2NhbGUsYi52U2NhbGU9dGhpcy52U2NhbGUsYi51QW5nPXRoaXMudUFuZyxiLnZBbmc9dGhpcy52QW5nLGIud0FuZz10aGlzLndBbmcsYn0sYy5ORUFSRVNUX1NBTVBMSU5HTU9ERT0xLGMuQklMSU5FQVJfU0FNUExJTkdNT0RFPTIsYy5UUklMSU5FQVJfU0FNUExJTkdNT0RFPTMsYy5FWFBMSUNJVF9NT0RFPTAsYy5TUEhFUklDQUxfTU9ERT0xLGMuUExBTkFSX01PREU9MixjLkNVQklDX01PREU9MyxjLlBST0pFQ1RJT05fTU9ERT00LGMuU0tZQk9YX01PREU9NSxjLkNMQU1QX0FERFJFU1NNT0RFPTAsYy5XUkFQX0FERFJFU1NNT0RFPTEsYy5NSVJST1JfQUREUkVTU01PREU9MixjfShhLkJhc2VUZXh0dXJlKTthLlRleHR1cmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUsZil7Yi5jYWxsKHRoaXMsZCksdGhpcy5jb29yZGluYXRlc01vZGU9YS5UZXh0dXJlLkNVQklDX01PREUsdGhpcy5uYW1lPWMsdGhpcy51cmw9Yyx0aGlzLl9ub01pcG1hcD1mLHRoaXMuaGFzQWxwaGE9ITEsdGhpcy5fdGV4dHVyZT10aGlzLl9nZXRGcm9tQ2FjaGUoYyxmKSxlfHwoZT1bXCJfcHguanBnXCIsXCJfcHkuanBnXCIsXCJfcHouanBnXCIsXCJfbnguanBnXCIsXCJfbnkuanBnXCIsXCJfbnouanBnXCJdKSx0aGlzLl9leHRlbnNpb25zPWUsdGhpcy5fdGV4dHVyZXx8KGQudXNlRGVsYXllZFRleHR1cmVMb2FkaW5nP3RoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9UTE9BREVEOnRoaXMuX3RleHR1cmU9ZC5nZXRFbmdpbmUoKS5jcmVhdGVDdWJlVGV4dHVyZShjLGQsZSxmKSksdGhpcy5pc0N1YmU9ITAsdGhpcy5fdGV4dHVyZU1hdHJpeD1hLk1hdHJpeC5JZGVudGl0eSgpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBiPW5ldyBhLkN1YmVUZXh0dXJlKHRoaXMudXJsLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9leHRlbnNpb25zLHRoaXMuX25vTWlwbWFwKTtyZXR1cm4gYi5sZXZlbD10aGlzLmxldmVsLGIud3JhcFU9dGhpcy53cmFwVSxiLndyYXBWPXRoaXMud3JhcFYsYi5jb29yZGluYXRlc0luZGV4PXRoaXMuY29vcmRpbmF0ZXNJbmRleCxiLmNvb3JkaW5hdGVzTW9kZT10aGlzLmNvb3JkaW5hdGVzTW9kZSxifSxjLnByb3RvdHlwZS5kZWxheUxvYWQ9ZnVuY3Rpb24oKXt0aGlzLmRlbGF5TG9hZFN0YXRlPT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQmJih0aGlzLmRlbGF5TG9hZFN0YXRlPWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURFRCx0aGlzLl90ZXh0dXJlPXRoaXMuX2dldEZyb21DYWNoZSh0aGlzLnVybCx0aGlzLl9ub01pcG1hcCksdGhpcy5fdGV4dHVyZXx8KHRoaXMuX3RleHR1cmU9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLmNyZWF0ZUN1YmVUZXh0dXJlKHRoaXMudXJsLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9leHRlbnNpb25zKSkpfSxjLnByb3RvdHlwZS5nZXRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90ZXh0dXJlTWF0cml4fSxjfShhLkJhc2VUZXh0dXJlKTthLkN1YmVUZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYsZyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGcmJihnPSEwKSxiLmNhbGwodGhpcyxudWxsLGUsIWYpLHRoaXMucmVuZGVyTGlzdD1uZXcgQXJyYXksdGhpcy5yZW5kZXJQYXJ0aWNsZXM9ITAsdGhpcy5yZW5kZXJTcHJpdGVzPSExLHRoaXMuY29vcmRpbmF0ZXNNb2RlPWEuVGV4dHVyZS5QUk9KRUNUSU9OX01PREUsdGhpcy5fY3VycmVudFJlZnJlc2hJZD0tMSx0aGlzLl9yZWZyZXNoUmF0ZT0xLHRoaXMubmFtZT1jLHRoaXMuaXNSZW5kZXJUYXJnZXQ9ITAsdGhpcy5fc2l6ZT1kLHRoaXMuX2dlbmVyYXRlTWlwTWFwcz1mLHRoaXMuX2RvTm90Q2hhbmdlQXNwZWN0UmF0aW89Zyx0aGlzLl90ZXh0dXJlPWUuZ2V0RW5naW5lKCkuY3JlYXRlUmVuZGVyVGFyZ2V0VGV4dHVyZShkLGYpLHRoaXMuX3JlbmRlcmluZ01hbmFnZXI9bmV3IGEuUmVuZGVyaW5nTWFuYWdlcihlKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUucmVzZXRSZWZyZXNoQ291bnRlcj1mdW5jdGlvbigpe3RoaXMuX2N1cnJlbnRSZWZyZXNoSWQ9LTF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLnByb3RvdHlwZSxcInJlZnJlc2hSYXRlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWZyZXNoUmF0ZX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX3JlZnJlc2hSYXRlPWEsdGhpcy5yZXNldFJlZnJlc2hDb3VudGVyKCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYy5wcm90b3R5cGUuX3Nob3VsZFJlbmRlcj1mdW5jdGlvbigpe3JldHVybi0xPT09dGhpcy5fY3VycmVudFJlZnJlc2hJZD8odGhpcy5fY3VycmVudFJlZnJlc2hJZD0xLCEwKTp0aGlzLnJlZnJlc2hSYXRlPT10aGlzLl9jdXJyZW50UmVmcmVzaElkPyh0aGlzLl9jdXJyZW50UmVmcmVzaElkPTEsITApOih0aGlzLl9jdXJyZW50UmVmcmVzaElkKyssITEpfSxjLnByb3RvdHlwZS5nZXRSZW5kZXJTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemV9LGMucHJvdG90eXBlLnJlc2l6ZT1mdW5jdGlvbihhLGIpe3RoaXMucmVsZWFzZUludGVybmFsVGV4dHVyZSgpLHRoaXMuX3RleHR1cmU9dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLmNyZWF0ZVJlbmRlclRhcmdldFRleHR1cmUoYSxiKX0sYy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZ2V0U2NlbmUoKSxjPWIuZ2V0RW5naW5lKCk7aWYodGhpcy5fd2FpdGluZ1JlbmRlckxpc3Qpe3RoaXMucmVuZGVyTGlzdD1bXTtmb3IodmFyIGQ9MDtkPHRoaXMuX3dhaXRpbmdSZW5kZXJMaXN0Lmxlbmd0aDtkKyspe3ZhciBlPXRoaXMuX3dhaXRpbmdSZW5kZXJMaXN0W2RdO3RoaXMucmVuZGVyTGlzdC5wdXNoKGIuZ2V0TWVzaEJ5SUQoZSkpfWRlbGV0ZSB0aGlzLl93YWl0aW5nUmVuZGVyTGlzdH1pZih0aGlzLnJlbmRlckxpc3QmJjAhPXRoaXMucmVuZGVyTGlzdC5sZW5ndGgpe2EmJmIucG9zdFByb2Nlc3NNYW5hZ2VyLl9wcmVwYXJlRnJhbWUodGhpcy5fdGV4dHVyZSl8fGMuYmluZEZyYW1lYnVmZmVyKHRoaXMuX3RleHR1cmUpLGMuY2xlYXIoYi5jbGVhckNvbG9yLCEwLCEwKSx0aGlzLl9yZW5kZXJpbmdNYW5hZ2VyLnJlc2V0KCk7Zm9yKHZhciBmPTA7Zjx0aGlzLnJlbmRlckxpc3QubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5yZW5kZXJMaXN0W2ZdO2lmKGcpe2lmKCFnLmlzUmVhZHkoKXx8Zy5tYXRlcmlhbCYmIWcubWF0ZXJpYWwuaXNSZWFkeSgpKXt0aGlzLnJlc2V0UmVmcmVzaENvdW50ZXIoKTtjb250aW51ZX1pZihnLmlzRW5hYmxlZCgpJiZnLmlzVmlzaWJsZSYmZy5zdWJNZXNoZXMmJjAhPShnLmxheWVyTWFzayZiLmFjdGl2ZUNhbWVyYS5sYXllck1hc2spKXtnLl9hY3RpdmF0ZShiLmdldFJlbmRlcklkKCkpO2Zvcih2YXIgaD0wO2g8Zy5zdWJNZXNoZXMubGVuZ3RoO2grKyl7dmFyIGk9Zy5zdWJNZXNoZXNbaF07Yi5fYWN0aXZlVmVydGljZXMrPWkudmVydGljZXNDb3VudCx0aGlzLl9yZW5kZXJpbmdNYW5hZ2VyLmRpc3BhdGNoKGkpfX19fXRoaXMuX2RvTm90Q2hhbmdlQXNwZWN0UmF0aW98fGIudXBkYXRlVHJhbnNmb3JtTWF0cml4KCEwKSx0aGlzLm9uQmVmb3JlUmVuZGVyJiZ0aGlzLm9uQmVmb3JlUmVuZGVyKCksdGhpcy5fcmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodGhpcy5jdXN0b21SZW5kZXJGdW5jdGlvbix0aGlzLnJlbmRlckxpc3QsdGhpcy5yZW5kZXJQYXJ0aWNsZXMsdGhpcy5yZW5kZXJTcHJpdGVzKSxhJiZiLnBvc3RQcm9jZXNzTWFuYWdlci5fZmluYWxpemVGcmFtZSghMSx0aGlzLl90ZXh0dXJlKSx0aGlzLm9uQWZ0ZXJSZW5kZXImJnRoaXMub25BZnRlclJlbmRlcigpLGMudW5CaW5kRnJhbWVidWZmZXIodGhpcy5fdGV4dHVyZSksdGhpcy5fZG9Ob3RDaGFuZ2VBc3BlY3RSYXRpb3x8Yi51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoITApfX0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmdldFNpemUoKSxjPW5ldyBhLlJlbmRlclRhcmdldFRleHR1cmUodGhpcy5uYW1lLGIud2lkdGgsdGhpcy5nZXRTY2VuZSgpLHRoaXMuX2dlbmVyYXRlTWlwTWFwcyk7cmV0dXJuIGMuaGFzQWxwaGE9dGhpcy5oYXNBbHBoYSxjLmxldmVsPXRoaXMubGV2ZWwsYy5jb29yZGluYXRlc01vZGU9dGhpcy5jb29yZGluYXRlc01vZGUsYy5yZW5kZXJMaXN0PXRoaXMucmVuZGVyTGlzdC5zbGljZSgwKSxjfSxjfShhLlRleHR1cmUpO2EuUmVuZGVyVGFyZ2V0VGV4dHVyZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmKXt2YXIgZz10aGlzO2IuY2FsbCh0aGlzLGMsZCxlLGYsITApLHRoaXMubWlycm9yUGxhbmU9bmV3IGEuUGxhbmUoMCwxLDAsMSksdGhpcy5fdHJhbnNmb3JtTWF0cml4PWEuTWF0cml4Llplcm8oKSx0aGlzLl9taXJyb3JNYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMub25CZWZvcmVSZW5kZXI9ZnVuY3Rpb24oKXthLk1hdHJpeC5SZWZsZWN0aW9uVG9SZWYoZy5taXJyb3JQbGFuZSxnLl9taXJyb3JNYXRyaXgpLGcuX3NhdmVkVmlld01hdHJpeD1lLmdldFZpZXdNYXRyaXgoKSxnLl9taXJyb3JNYXRyaXgubXVsdGlwbHlUb1JlZihnLl9zYXZlZFZpZXdNYXRyaXgsZy5fdHJhbnNmb3JtTWF0cml4KSxlLnNldFRyYW5zZm9ybU1hdHJpeChnLl90cmFuc2Zvcm1NYXRyaXgsZS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLGUuY2xpcFBsYW5lPWcubWlycm9yUGxhbmUsZS5nZXRFbmdpbmUoKS5jdWxsQmFja0ZhY2VzPSExfSx0aGlzLm9uQWZ0ZXJSZW5kZXI9ZnVuY3Rpb24oKXtlLnNldFRyYW5zZm9ybU1hdHJpeChnLl9zYXZlZFZpZXdNYXRyaXgsZS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLGUuZ2V0RW5naW5lKCkuY3VsbEJhY2tGYWNlcz0hMCxkZWxldGUgZS5jbGlwUGxhbmV9fXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZ2V0U2l6ZSgpLGM9bmV3IGEuTWlycm9yVGV4dHVyZSh0aGlzLm5hbWUsYi53aWR0aCx0aGlzLmdldFNjZW5lKCksdGhpcy5fZ2VuZXJhdGVNaXBNYXBzKTtyZXR1cm4gYy5oYXNBbHBoYT10aGlzLmhhc0FscGhhLGMubGV2ZWw9dGhpcy5sZXZlbCxjLm1pcnJvclBsYW5lPXRoaXMubWlycm9yUGxhbmUuY2xvbmUoKSxjLnJlbmRlckxpc3Q9dGhpcy5yZW5kZXJMaXN0LnNsaWNlKDApLGN9LGN9KGEuUmVuZGVyVGFyZ2V0VGV4dHVyZSk7YS5NaXJyb3JUZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYsZyl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGcmJihnPWEuVGV4dHVyZS5UUklMSU5FQVJfU0FNUExJTkdNT0RFKSxiLmNhbGwodGhpcyxudWxsLGUsIWYpLHRoaXMubmFtZT1jLHRoaXMud3JhcFU9YS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFLHRoaXMud3JhcFY9YS5UZXh0dXJlLkNMQU1QX0FERFJFU1NNT0RFLHRoaXMuX2dlbmVyYXRlTWlwTWFwcz1mLGQuZ2V0Q29udGV4dD8odGhpcy5fY2FudmFzPWQsdGhpcy5fdGV4dHVyZT1lLmdldEVuZ2luZSgpLmNyZWF0ZUR5bmFtaWNUZXh0dXJlKGQud2lkdGgsZC5oZWlnaHQsZixnKSk6KHRoaXMuX2NhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuX3RleHR1cmU9ZC53aWR0aD9lLmdldEVuZ2luZSgpLmNyZWF0ZUR5bmFtaWNUZXh0dXJlKGQud2lkdGgsZC5oZWlnaHQsZixnKTplLmdldEVuZ2luZSgpLmNyZWF0ZUR5bmFtaWNUZXh0dXJlKGQsZCxmLGcpKTt2YXIgaD10aGlzLmdldFNpemUoKTt0aGlzLl9jYW52YXMud2lkdGg9aC53aWR0aCx0aGlzLl9jYW52YXMuaGVpZ2h0PWguaGVpZ2h0LHRoaXMuX2NvbnRleHQ9dGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuZ2V0Q29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250ZXh0fSxjLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy5nZXRTY2VuZSgpLmdldEVuZ2luZSgpLnVwZGF0ZUR5bmFtaWNUZXh0dXJlKHRoaXMuX3RleHR1cmUsdGhpcy5fY2FudmFzLHZvaWQgMD09PWE/ITA6YSl9LGMucHJvdG90eXBlLmRyYXdUZXh0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBoPXRoaXMuZ2V0U2l6ZSgpO2lmKGYmJih0aGlzLl9jb250ZXh0LmZpbGxTdHlsZT1mLHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoMCwwLGgud2lkdGgsaC5oZWlnaHQpKSx0aGlzLl9jb250ZXh0LmZvbnQ9ZCxudWxsPT09Yil7dmFyIGk9dGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChhKTtiPShoLndpZHRoLWkud2lkdGgpLzJ9dGhpcy5fY29udGV4dC5maWxsU3R5bGU9ZSx0aGlzLl9jb250ZXh0LmZpbGxUZXh0KGEsYixjKSx0aGlzLnVwZGF0ZShnKX0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmdldFNpemUoKSxjPW5ldyBhLkR5bmFtaWNUZXh0dXJlKHRoaXMubmFtZSxiLndpZHRoLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLl9nZW5lcmF0ZU1pcE1hcHMpO3JldHVybiBjLmhhc0FscGhhPXRoaXMuaGFzQWxwaGEsYy5sZXZlbD10aGlzLmxldmVsLGMud3JhcFU9dGhpcy53cmFwVSxjLndyYXBWPXRoaXMud3JhcFYsY30sY30oYS5UZXh0dXJlKTthLkR5bmFtaWNUZXh0dXJlPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYsZyxoLGkpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBpJiYoaT1hLlRleHR1cmUuVFJJTElORUFSX1NBTVBMSU5HTU9ERSk7dmFyIGo9dGhpcztiLmNhbGwodGhpcyxudWxsLGYsIWcsaCksdGhpcy5fYXV0b0xhdW5jaD0hMCx0aGlzLm5hbWU9Yyx0aGlzLndyYXBVPWEuVGV4dHVyZS5XUkFQX0FERFJFU1NNT0RFLHRoaXMud3JhcFY9YS5UZXh0dXJlLldSQVBfQUREUkVTU01PREU7dmFyIGs9ZS53aWR0aHx8ZSxsPWUuaGVpZ2h0fHxlO3RoaXMuX3RleHR1cmU9Zi5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVGV4dHVyZShrLGwsZyxpKTt2YXIgbT10aGlzLmdldFNpemUoKTt0aGlzLnZpZGVvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSx0aGlzLnZpZGVvLndpZHRoPW0ud2lkdGgsdGhpcy52aWRlby5oZWlnaHQ9bS5oZWlnaHQsdGhpcy52aWRlby5hdXRvcGxheT0hMSx0aGlzLnZpZGVvLmxvb3A9ITAsdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIixmdW5jdGlvbigpe2ouX3RleHR1cmUmJihqLl90ZXh0dXJlLmlzUmVhZHk9ITApfSksZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7Yi5zcmM9YSxqLnZpZGVvLmFwcGVuZENoaWxkKGIpfSksdGhpcy5fbGFzdFVwZGF0ZT0obmV3IERhdGUpLmdldFRpbWUoKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYXV0b0xhdW5jaCYmKHRoaXMuX2F1dG9MYXVuY2g9ITEsdGhpcy52aWRlby5wbGF5KCkpO3ZhciBhPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3JldHVybiBhLXRoaXMuX2xhc3RVcGRhdGU8MTU/ITE6KHRoaXMuX2xhc3RVcGRhdGU9YSx0aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCkudXBkYXRlVmlkZW9UZXh0dXJlKHRoaXMuX3RleHR1cmUsdGhpcy52aWRlbyx0aGlzLl9pbnZlcnRZKSwhMCl9LGN9KGEuVGV4dHVyZSk7YS5WaWRlb1RleHR1cmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmLGcsaCxpKXt2YXIgaj10aGlzO3RoaXMuX2lzUmVhZHk9ITEsdGhpcy5fY29tcGlsYXRpb25FcnJvcj1cIlwiLHRoaXMuX3ZhbHVlQ2FjaGU9W10sdGhpcy5fZW5naW5lPWUsdGhpcy5uYW1lPWEsdGhpcy5kZWZpbmVzPWYsdGhpcy5fdW5pZm9ybXNOYW1lcz1jLmNvbmNhdChkKSx0aGlzLl9zYW1wbGVycz1kLHRoaXMuX2F0dHJpYnV0ZXNOYW1lcz1iLHRoaXMub25FcnJvcj1pLHRoaXMub25Db21waWxlZD1oO3ZhciBrLGw7az1hLnZlcnRleEVsZW1lbnQ/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYS52ZXJ0ZXhFbGVtZW50KTphLnZlcnRleHx8YSxsPWEuZnJhZ21lbnRFbGVtZW50P2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEuZnJhZ21lbnRFbGVtZW50KTphLmZyYWdtZW50fHxhLHRoaXMuX2xvYWRWZXJ0ZXhTaGFkZXIoayxmdW5jdGlvbihhKXtqLl9sb2FkRnJhZ21lbnRTaGFkZXIobCxmdW5jdGlvbihjKXtqLl9wcmVwYXJlRWZmZWN0KGEsYyxiLGYsZyl9KX0pfXJldHVybiBiLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUmVhZHl9LGIucHJvdG90eXBlLmdldFByb2dyYW09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvZ3JhbX0sYi5wcm90b3R5cGUuZ2V0QXR0cmlidXRlc05hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNOYW1lc30sYi5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb249ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbYV19LGIucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uQnlOYW1lPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2F0dHJpYnV0ZXNOYW1lcy5pbmRleE9mKGEpO3JldHVybiB0aGlzLl9hdHRyaWJ1dGVzW2JdfSxiLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5sZW5ndGh9LGIucHJvdG90eXBlLmdldFVuaWZvcm1JbmRleD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fdW5pZm9ybXNOYW1lcy5pbmRleE9mKGEpfSxiLnByb3RvdHlwZS5nZXRVbmlmb3JtPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl91bmlmb3Jtc1t0aGlzLl91bmlmb3Jtc05hbWVzLmluZGV4T2YoYSldfSxiLnByb3RvdHlwZS5nZXRTYW1wbGVycz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zYW1wbGVyc30sYi5wcm90b3R5cGUuZ2V0Q29tcGlsYXRpb25FcnJvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb21waWxhdGlvbkVycm9yfSxiLnByb3RvdHlwZS5fbG9hZFZlcnRleFNoYWRlcj1mdW5jdGlvbihiLGMpe2lmKGIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7dmFyIGQ9YS5Ub29scy5HZXRET01UZXh0Q29udGVudChiKTtyZXR1cm4gdm9pZCBjKGQpfWlmKGEuRWZmZWN0LlNoYWRlcnNTdG9yZVtiK1wiVmVydGV4U2hhZGVyXCJdKXJldHVybiB2b2lkIGMoYS5FZmZlY3QuU2hhZGVyc1N0b3JlW2IrXCJWZXJ0ZXhTaGFkZXJcIl0pO3ZhciBlO2U9XCIuXCI9PT1iWzBdP2I6YS5FbmdpbmUuU2hhZGVyc1JlcG9zaXRvcnkrYixhLlRvb2xzLkxvYWRGaWxlKGUrXCIudmVydGV4LmZ4XCIsYyl9LGIucHJvdG90eXBlLl9sb2FkRnJhZ21lbnRTaGFkZXI9ZnVuY3Rpb24oYixjKXtpZihiIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3ZhciBkPWEuVG9vbHMuR2V0RE9NVGV4dENvbnRlbnQoYik7cmV0dXJuIHZvaWQgYyhkKX1pZihhLkVmZmVjdC5TaGFkZXJzU3RvcmVbYitcIlBpeGVsU2hhZGVyXCJdKXJldHVybiB2b2lkIGMoYS5FZmZlY3QuU2hhZGVyc1N0b3JlW2IrXCJQaXhlbFNoYWRlclwiXSk7dmFyIGU7ZT1cIi5cIj09PWJbMF0/YjphLkVuZ2luZS5TaGFkZXJzUmVwb3NpdG9yeStiLGEuVG9vbHMuTG9hZEZpbGUoZStcIi5mcmFnbWVudC5meFwiLGMpfSxiLnByb3RvdHlwZS5fcHJlcGFyZUVmZmVjdD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dHJ5e3ZhciBoPXRoaXMuX2VuZ2luZTt0aGlzLl9wcm9ncmFtPWguY3JlYXRlU2hhZGVyUHJvZ3JhbShiLGMsZSksdGhpcy5fdW5pZm9ybXM9aC5nZXRVbmlmb3Jtcyh0aGlzLl9wcm9ncmFtLHRoaXMuX3VuaWZvcm1zTmFtZXMpLHRoaXMuX2F0dHJpYnV0ZXM9aC5nZXRBdHRyaWJ1dGVzKHRoaXMuX3Byb2dyYW0sZCk7Zm9yKHZhciBpPTA7aTx0aGlzLl9zYW1wbGVycy5sZW5ndGg7aSsrKXt2YXIgaj10aGlzLmdldFVuaWZvcm0odGhpcy5fc2FtcGxlcnNbaV0pO251bGw9PWomJih0aGlzLl9zYW1wbGVycy5zcGxpY2UoaSwxKSxpLS0pfWguYmluZFNhbXBsZXJzKHRoaXMpLHRoaXMuX2lzUmVhZHk9ITAsdGhpcy5vbkNvbXBpbGVkJiZ0aGlzLm9uQ29tcGlsZWQodGhpcyl9Y2F0Y2goayl7aWYoIWcmJmYpe2ZvcihpPTA7aTxmLmxlbmd0aDtpKyspZT1lLnJlcGxhY2UoZltpXSxcIlwiKTt0aGlzLl9wcmVwYXJlRWZmZWN0KGIsYyxkLGUsZiwhMCl9ZWxzZSBhLlRvb2xzLkVycm9yKFwiVW5hYmxlIHRvIGNvbXBpbGUgZWZmZWN0OiBcIit0aGlzLm5hbWUpLGEuVG9vbHMuRXJyb3IoXCJEZWZpbmVzOiBcIitlKSxhLlRvb2xzLkVycm9yKFwiT3B0aW9uYWwgZGVmaW5lczogXCIrZiksYS5Ub29scy5FcnJvcihcIkVycm9yOiBcIitrLm1lc3NhZ2UpLHRoaXMuX2NvbXBpbGF0aW9uRXJyb3I9ay5tZXNzYWdlLHRoaXMub25FcnJvciYmdGhpcy5vbkVycm9yKHRoaXMsdGhpcy5fY29tcGlsYXRpb25FcnJvcil9fSxiLnByb3RvdHlwZS5fYmluZFRleHR1cmU9ZnVuY3Rpb24oYSxiKXt0aGlzLl9lbmdpbmUuX2JpbmRUZXh0dXJlKHRoaXMuX3NhbXBsZXJzLmluZGV4T2YoYSksYil9LGIucHJvdG90eXBlLnNldFRleHR1cmU9ZnVuY3Rpb24oYSxiKXt0aGlzLl9lbmdpbmUuc2V0VGV4dHVyZSh0aGlzLl9zYW1wbGVycy5pbmRleE9mKGEpLGIpfSxiLnByb3RvdHlwZS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzPWZ1bmN0aW9uKGEsYil7dGhpcy5fZW5naW5lLnNldFRleHR1cmVGcm9tUG9zdFByb2Nlc3ModGhpcy5fc2FtcGxlcnMuaW5kZXhPZihhKSxiKX0sYi5wcm90b3R5cGUuX2NhY2hlRmxvYXQyPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXT8odGhpcy5fdmFsdWVDYWNoZVthXVswXT1iLHZvaWQodGhpcy5fdmFsdWVDYWNoZVthXVsxXT1jKSk6dm9pZCh0aGlzLl92YWx1ZUNhY2hlW2FdPVtiLGNdKX0sYi5wcm90b3R5cGUuX2NhY2hlRmxvYXQzPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdPyh0aGlzLl92YWx1ZUNhY2hlW2FdWzBdPWIsdGhpcy5fdmFsdWVDYWNoZVthXVsxXT1jLHZvaWQodGhpcy5fdmFsdWVDYWNoZVthXVsyXT1kKSk6dm9pZCh0aGlzLl92YWx1ZUNhY2hlW2FdPVtiLGMsZF0pfSxiLnByb3RvdHlwZS5fY2FjaGVGbG9hdDQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXT8odGhpcy5fdmFsdWVDYWNoZVthXVswXT1iLHRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09Yyx0aGlzLl92YWx1ZUNhY2hlW2FdWzJdPWQsdm9pZCh0aGlzLl92YWx1ZUNhY2hlW2FdWzNdPWUpKTp2b2lkKHRoaXMuX3ZhbHVlQ2FjaGVbYV09W2IsYyxkLGVdKX0sYi5wcm90b3R5cGUuc2V0QXJyYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fZW5naW5lLnNldEFycmF5KHRoaXMuZ2V0VW5pZm9ybShhKSxiKSx0aGlzfSxiLnByb3RvdHlwZS5zZXRNYXRyaWNlcz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9lbmdpbmUuc2V0TWF0cmljZXModGhpcy5nZXRVbmlmb3JtKGEpLGIpLHRoaXN9LGIucHJvdG90eXBlLnNldE1hdHJpeD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9lbmdpbmUuc2V0TWF0cml4KHRoaXMuZ2V0VW5pZm9ybShhKSxiKSx0aGlzfSxiLnByb3RvdHlwZS5zZXRGbG9hdD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdPT09Yj90aGlzOih0aGlzLl92YWx1ZUNhY2hlW2FdPWIsdGhpcy5fZW5naW5lLnNldEZsb2F0KHRoaXMuZ2V0VW5pZm9ybShhKSxiKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0Qm9vbD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdPT09Yj90aGlzOih0aGlzLl92YWx1ZUNhY2hlW2FdPWIsdGhpcy5fZW5naW5lLnNldEJvb2wodGhpcy5nZXRVbmlmb3JtKGEpLGI/MTowKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0VmVjdG9yMj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzBdPT1iLngmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09PWIueT90aGlzOih0aGlzLl9jYWNoZUZsb2F0MihhLGIueCxiLnkpLHRoaXMuX2VuZ2luZS5zZXRGbG9hdDIodGhpcy5nZXRVbmlmb3JtKGEpLGIueCxiLnkpLHRoaXMpfSxiLnByb3RvdHlwZS5zZXRGbG9hdDI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLl92YWx1ZUNhY2hlW2FdJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzBdPT1iJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPT1jP3RoaXM6KHRoaXMuX2NhY2hlRmxvYXQyKGEsYixjKSx0aGlzLl9lbmdpbmUuc2V0RmxvYXQyKHRoaXMuZ2V0VW5pZm9ybShhKSxiLGMpLHRoaXMpfSxiLnByb3RvdHlwZS5zZXRWZWN0b3IzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0mJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09PWIueCYmdGhpcy5fdmFsdWVDYWNoZVthXVsxXT09Yi55JiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzJdPT1iLno/dGhpczoodGhpcy5fY2FjaGVGbG9hdDMoYSxiLngsYi55LGIueiksdGhpcy5fZW5naW5lLnNldEZsb2F0Myh0aGlzLmdldFVuaWZvcm0oYSksYi54LGIueSxiLnopLHRoaXMpfSxiLnByb3RvdHlwZS5zZXRGbG9hdDM9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuX3ZhbHVlQ2FjaGVbYV0mJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMF09PWImJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMV09PWMmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMl09PWQ/dGhpczoodGhpcy5fY2FjaGVGbG9hdDMoYSxiLGMsZCksdGhpcy5fZW5naW5lLnNldEZsb2F0Myh0aGlzLmdldFVuaWZvcm0oYSksYixjLGQpLHRoaXMpfSxiLnByb3RvdHlwZS5zZXRGbG9hdDQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXVswXT09YiYmdGhpcy5fdmFsdWVDYWNoZVthXVsxXT09YyYmdGhpcy5fdmFsdWVDYWNoZVthXVsyXT09ZCYmdGhpcy5fdmFsdWVDYWNoZVthXVszXT09ZT90aGlzOih0aGlzLl9jYWNoZUZsb2F0NChhLGIsYyxkLGUpLHRoaXMuX2VuZ2luZS5zZXRGbG9hdDQodGhpcy5nZXRVbmlmb3JtKGEpLGIsYyxkLGUpLHRoaXMpfSxiLnByb3RvdHlwZS5zZXRDb2xvcjM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXVswXT09Yi5yJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPT1iLmcmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMl09PWIuYj90aGlzOih0aGlzLl9jYWNoZUZsb2F0MyhhLGIucixiLmcsYi5iKSx0aGlzLl9lbmdpbmUuc2V0Q29sb3IzKHRoaXMuZ2V0VW5pZm9ybShhKSxiKSx0aGlzKX0sYi5wcm90b3R5cGUuc2V0Q29sb3I0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5fdmFsdWVDYWNoZVthXSYmdGhpcy5fdmFsdWVDYWNoZVthXVswXT09Yi5yJiZ0aGlzLl92YWx1ZUNhY2hlW2FdWzFdPT1iLmcmJnRoaXMuX3ZhbHVlQ2FjaGVbYV1bMl09PWIuYiYmdGhpcy5fdmFsdWVDYWNoZVthXVszXT09Yz90aGlzOih0aGlzLl9jYWNoZUZsb2F0NChhLGIucixiLmcsYi5iLGMpLHRoaXMuX2VuZ2luZS5zZXRDb2xvcjQodGhpcy5nZXRVbmlmb3JtKGEpLGIsYyksdGhpcyl9LGIuU2hhZGVyc1N0b3JlPXthbmFnbHlwaFBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGxlZnRTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBsZWZ0RnJhZyA9IHRleHR1cmUyRChsZWZ0U2FtcGxlciwgdlVWKTtcXG4gICAgbGVmdEZyYWcgPSB2ZWM0KDEuMCwgbGVmdEZyYWcuZywgbGVmdEZyYWcuYiwgMS4wKTtcXG5cXG5cdHZlYzQgcmlnaHRGcmFnID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYpO1xcbiAgICByaWdodEZyYWcgPSB2ZWM0KHJpZ2h0RnJhZy5yLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyaWdodEZyYWcucmdiICogbGVmdEZyYWcucmdiLCAxLjApO1xcbn1cIixibGFja0FuZFdoaXRlUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpIFxcbntcXG5cdGZsb2F0IGx1bWluYW5jZSA9IGRvdCh0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVikucmdiLCB2ZWMzKDAuMywgMC41OSwgMC4xMSkpO1xcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChsdW1pbmFuY2UsIGx1bWluYW5jZSwgbHVtaW5hbmNlLCAxLjApO1xcbn1cIixibHVyUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxuXFxuLy8gUGFyYW1ldGVyc1xcbnVuaWZvcm0gdmVjMiBzY3JlZW5TaXplO1xcbnVuaWZvcm0gdmVjMiBkaXJlY3Rpb247XFxudW5pZm9ybSBmbG9hdCBibHVyV2lkdGg7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcblx0ZmxvYXQgd2VpZ2h0c1s3XTtcXG5cdHdlaWdodHNbMF0gPSAwLjA1O1xcblx0d2VpZ2h0c1sxXSA9IDAuMTtcXG5cdHdlaWdodHNbMl0gPSAwLjI7XFxuXHR3ZWlnaHRzWzNdID0gMC4zO1xcblx0d2VpZ2h0c1s0XSA9IDAuMjtcXG5cdHdlaWdodHNbNV0gPSAwLjE7XFxuXHR3ZWlnaHRzWzZdID0gMC4wNTtcXG5cXG5cdHZlYzIgdGV4ZWxTaXplID0gdmVjMigxLjAgLyBzY3JlZW5TaXplLngsIDEuMCAvIHNjcmVlblNpemUueSk7XFxuXHR2ZWMyIHRleGVsU3RlcCA9IHRleGVsU2l6ZSAqIGRpcmVjdGlvbiAqIGJsdXJXaWR0aDtcXG5cdHZlYzIgc3RhcnQgPSB2VVYgLSAzLjAgKiB0ZXhlbFN0ZXA7XFxuXFxuXHR2ZWM0IGJhc2VDb2xvciA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xcblx0dmVjMiB0ZXhlbE9mZnNldCA9IHZlYzIoMC4sIDAuKTtcXG5cXG5cdGZvciAoaW50IGkgPSAwOyBpIDwgNzsgaSsrKVxcblx0e1xcblx0XHRiYXNlQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCBzdGFydCArIHRleGVsT2Zmc2V0KSAqIHdlaWdodHNbaV07XFxuXHRcdHRleGVsT2Zmc2V0ICs9IHRleGVsU3RlcDtcXG5cdH1cXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvcjtcXG59XCIsY29sb3JQaXhlbFNoYWRlcjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4pO1xcbn1cIixjb2xvclZlcnRleFNoYWRlcjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5cXG4vLyBVbmlmb3Jtc1xcbnVuaWZvcm0gbWF0NCB3b3JsZFZpZXdQcm9qZWN0aW9uO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXHRnbF9Qb3NpdGlvbiA9IHdvcmxkVmlld1Byb2plY3Rpb24gKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbn1cIixjb252b2x1dGlvblBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjMiBzY3JlZW5TaXplO1xcbnVuaWZvcm0gZmxvYXQga2VybmVsWzldO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG5cdHZlYzIgb25lUGl4ZWwgPSB2ZWMyKDEuMCwgMS4wKSAvIHNjcmVlblNpemU7XFxuXHR2ZWM0IGNvbG9yU3VtID1cXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoLTEsIC0xKSkgKiBrZXJuZWxbMF0gK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIG9uZVBpeGVsICogdmVjMigwLCAtMSkpICoga2VybmVsWzFdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMSwgLTEpKSAqIGtlcm5lbFsyXSArXFxuXHRcdHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWICsgb25lUGl4ZWwgKiB2ZWMyKC0xLCAwKSkgKiBrZXJuZWxbM10gK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIG9uZVBpeGVsICogdmVjMigwLCAwKSkgKiBrZXJuZWxbNF0gK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIG9uZVBpeGVsICogdmVjMigxLCAwKSkgKiBrZXJuZWxbNV0gK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIG9uZVBpeGVsICogdmVjMigtMSwgMSkpICoga2VybmVsWzZdICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMCwgMSkpICoga2VybmVsWzddICtcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBvbmVQaXhlbCAqIHZlYzIoMSwgMSkpICoga2VybmVsWzhdO1xcblxcblx0ZmxvYXQga2VybmVsV2VpZ2h0ID1cXG5cdFx0a2VybmVsWzBdICtcXG5cdFx0a2VybmVsWzFdICtcXG5cdFx0a2VybmVsWzJdICtcXG5cdFx0a2VybmVsWzNdICtcXG5cdFx0a2VybmVsWzRdICtcXG5cdFx0a2VybmVsWzVdICtcXG5cdFx0a2VybmVsWzZdICtcXG5cdFx0a2VybmVsWzddICtcXG5cdFx0a2VybmVsWzhdO1xcblxcblx0aWYgKGtlcm5lbFdlaWdodCA8PSAwLjApIHtcXG5cdFx0a2VybmVsV2VpZ2h0ID0gMS4wO1xcblx0fVxcblxcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNCgoY29sb3JTdW0gLyBrZXJuZWxXZWlnaHQpLnJnYiwgMSk7XFxufVwiLGRlZmF1bHRQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbiNkZWZpbmUgTUFQX0VYUExJQ0lUXHQwLlxcbiNkZWZpbmUgTUFQX1NQSEVSSUNBTFx0MS5cXG4jZGVmaW5lIE1BUF9QTEFOQVJcdFx0Mi5cXG4jZGVmaW5lIE1BUF9DVUJJQ1x0XHQzLlxcbiNkZWZpbmUgTUFQX1BST0pFQ1RJT05cdDQuXFxuI2RlZmluZSBNQVBfU0tZQk9YXHRcdDUuXFxuXFxuLy8gQ29uc3RhbnRzXFxudW5pZm9ybSB2ZWMzIHZFeWVQb3NpdGlvbjtcXG51bmlmb3JtIHZlYzMgdkFtYmllbnRDb2xvcjtcXG51bmlmb3JtIHZlYzQgdkRpZmZ1c2VDb2xvcjtcXG51bmlmb3JtIHZlYzQgdlNwZWN1bGFyQ29sb3I7XFxudW5pZm9ybSB2ZWMzIHZFbWlzc2l2ZUNvbG9yO1xcblxcbi8vIElucHV0XFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvblc7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWxXO1xcblxcbiNpZmRlZiBWRVJURVhDT0xPUlxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuLy8gTGlnaHRzXFxuI2lmZGVmIExJR0hUMFxcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMDtcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTA7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMDtcXG4jaWZkZWYgU0hBRE9XMFxcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIwO1xcbnVuaWZvcm0gZmxvYXQgZGFya25lc3MwO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQwXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjA7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDBcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMDtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQxXFxudW5pZm9ybSB2ZWM0IHZMaWdodERhdGExO1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaWZmdXNlMTtcXG51bmlmb3JtIHZlYzMgdkxpZ2h0U3BlY3VsYXIxO1xcbiNpZmRlZiBTSEFET1cxXFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDE7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcjE7XFxudW5pZm9ybSBmbG9hdCBkYXJrbmVzczE7XFxuI2VuZGlmXFxuI2lmZGVmIFNQT1RMSUdIVDFcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlyZWN0aW9uMTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMVxcbnVuaWZvcm0gdmVjMyB2TGlnaHRHcm91bmQxO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDJcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTI7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UyO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjI7XFxuI2lmZGVmIFNIQURPVzJcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MjtcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMjtcXG51bmlmb3JtIGZsb2F0IGRhcmtuZXNzMjtcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUMlxcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24yO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQyXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDI7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUM1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMztcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTM7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMztcXG4jaWZkZWYgU0hBRE9XM1xcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIzO1xcbnVuaWZvcm0gZmxvYXQgZGFya25lc3MzO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQzXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjM7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDNcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMztcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbiNpZmRlZiBESUZGVVNFXFxudmFyeWluZyB2ZWMyIHZEaWZmdXNlVVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZEaWZmdXNlSW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFNQklFTlRcXG52YXJ5aW5nIHZlYzIgdkFtYmllbnRVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCBhbWJpZW50U2FtcGxlcjtcXG51bmlmb3JtIHZlYzIgdkFtYmllbnRJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVx0XFxudmFyeWluZyB2ZWMyIHZPcGFjaXR5VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgb3BhY2l0eVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZPcGFjaXR5SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEVNSVNTSVZFXFxudmFyeWluZyB2ZWMyIHZFbWlzc2l2ZVVWO1xcbnVuaWZvcm0gdmVjMiB2RW1pc3NpdmVJbmZvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZVNhbXBsZXI7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNQRUNVTEFSXFxudmFyeWluZyB2ZWMyIHZTcGVjdWxhclVWO1xcbnVuaWZvcm0gdmVjMiB2U3BlY3VsYXJJbmZvcztcXG51bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhclNhbXBsZXI7XFxuI2VuZGlmXFxuXFxuLy8gUmVmbGVjdGlvblxcbiNpZmRlZiBSRUZMRUNUSU9OXFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvblVWVztcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHJlZmxlY3Rpb25DdWJlU2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCByZWZsZWN0aW9uMkRTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMyB2UmVmbGVjdGlvbkluZm9zO1xcbnVuaWZvcm0gbWF0NCByZWZsZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB2aWV3O1xcblxcbnZlYzMgY29tcHV0ZVJlZmxlY3Rpb25Db29yZHMoZmxvYXQgbW9kZSwgdmVjNCB3b3JsZFBvcywgdmVjMyB3b3JsZE5vcm1hbClcXG57XFxuXHRpZiAobW9kZSA9PSBNQVBfU1BIRVJJQ0FMKVxcblx0e1xcblx0XHR2ZWMzIGNvb3JkcyA9IHZlYzModmlldyAqIHZlYzQod29ybGROb3JtYWwsIDAuMCkpO1xcblxcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogdmVjNChjb29yZHMsIDEuMCkpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfUExBTkFSKVxcblx0e1xcblx0XHR2ZWMzIHZpZXdEaXIgPSB3b3JsZFBvcy54eXogLSB2RXllUG9zaXRpb247XFxuXHRcdHZlYzMgY29vcmRzID0gbm9ybWFsaXplKHJlZmxlY3Qodmlld0Rpciwgd29ybGROb3JtYWwpKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAxKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9DVUJJQylcXG5cdHtcXG5cdFx0dmVjMyB2aWV3RGlyID0gd29ybGRQb3MueHl6IC0gdkV5ZVBvc2l0aW9uO1xcblx0XHR2ZWMzIGNvb3JkcyA9IHJlZmxlY3Qodmlld0Rpciwgd29ybGROb3JtYWwpO1xcblxcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogdmVjNChjb29yZHMsIDApKTtcXG5cdH1cXG5cdGVsc2UgaWYgKG1vZGUgPT0gTUFQX1BST0pFQ1RJT04pXFxuXHR7XFxuXHRcdHJldHVybiB2ZWMzKHJlZmxlY3Rpb25NYXRyaXggKiAodmlldyAqIHdvcmxkUG9zKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9TS1lCT1gpXFxuXHR7XFxuXHRcdHJldHVybiB2UG9zaXRpb25VVlc7XFxuXHR9XFxuXFxuXHRyZXR1cm4gdmVjMygwLCAwLCAwKTtcXG59XFxuI2VuZGlmXFxuXFxuLy8gU2hhZG93c1xcbiNpZmRlZiBTSEFET1dTXFxuXFxuZmxvYXQgdW5wYWNrKHZlYzQgY29sb3IpXFxue1xcblx0Y29uc3QgdmVjNCBiaXRTaGlmdCA9IHZlYzQoMS4gLyAoMjU1LiAqIDI1NS4gKiAyNTUuKSwgMS4gLyAoMjU1LiAqIDI1NS4pLCAxLiAvIDI1NS4sIDEuKTtcXG5cdHJldHVybiBkb3QoY29sb3IsIGJpdFNoaWZ0KTtcXG59XFxuXFxuZmxvYXQgdW5wYWNrSGFsZih2ZWMyIGNvbG9yKVxcbntcXG5cdHJldHVybiBjb2xvci54ICsgKGNvbG9yLnkgLyAyNTUuMCk7XFxufVxcblxcbmZsb2F0IGNvbXB1dGVTaGFkb3codmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyLCBmbG9hdCBkYXJrbmVzcylcXG57XFxuXHR2ZWMzIGRlcHRoID0gdlBvc2l0aW9uRnJvbUxpZ2h0Lnh5eiAvIHZQb3NpdGlvbkZyb21MaWdodC53O1xcblx0dmVjMiB1diA9IDAuNSAqIGRlcHRoLnh5ICsgdmVjMigwLjUsIDAuNSk7XFxuXFxuXHRpZiAodXYueCA8IDAuIHx8IHV2LnggPiAxLjAgfHwgdXYueSA8IDAuIHx8IHV2LnkgPiAxLjApXFxuXHR7XFxuXHRcdHJldHVybiAxLjA7XFxuXHR9XFxuXFxuXHRmbG9hdCBzaGFkb3cgPSB1bnBhY2sodGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsIHV2KSk7XFxuXFxuXHRpZiAoZGVwdGgueiA+IHNoYWRvdylcXG5cdHtcXG5cdFx0cmV0dXJuIGRhcmtuZXNzO1xcblx0fVxcblx0cmV0dXJuIDEuO1xcbn1cXG5cXG5mbG9hdCBjb21wdXRlU2hhZG93V2l0aFBDRih2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCwgc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIpXFxue1xcblx0dmVjMyBkZXB0aCA9IHZQb3NpdGlvbkZyb21MaWdodC54eXogLyB2UG9zaXRpb25Gcm9tTGlnaHQudztcXG5cdHZlYzIgdXYgPSAwLjUgKiBkZXB0aC54eSArIHZlYzIoMC41LCAwLjUpO1xcblxcblx0aWYgKHV2LnggPCAwLiB8fCB1di54ID4gMS4wIHx8IHV2LnkgPCAwLiB8fCB1di55ID4gMS4wKVxcblx0e1xcblx0XHRyZXR1cm4gMS4wO1xcblx0fVxcblxcblx0ZmxvYXQgdmlzaWJpbGl0eSA9IDEuO1xcblxcblx0dmVjMiBwb2lzc29uRGlza1s0XTtcXG5cdHBvaXNzb25EaXNrWzBdID0gdmVjMigtMC45NDIwMTYyNCwgLTAuMzk5MDYyMTYpO1xcblx0cG9pc3NvbkRpc2tbMV0gPSB2ZWMyKDAuOTQ1NTg2MDksIC0wLjc2ODkwNzI1KTtcXG5cdHBvaXNzb25EaXNrWzJdID0gdmVjMigtMC4wOTQxODQxMDEsIC0wLjkyOTM4ODcwKTtcXG5cdHBvaXNzb25EaXNrWzNdID0gdmVjMigwLjM0NDk1OTM4LCAwLjI5Mzg3NzYwKTtcXG5cXG5cdC8vIFBvaXNzb24gU2FtcGxpbmdcXG5cdGZvciAoaW50IGkgPSAwOyBpPDQ7IGkrKyl7XFxuXHRcdGlmICh1bnBhY2sodGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsIHV2ICsgcG9pc3NvbkRpc2tbaV0gLyAxNTAwLjApKSAgPCAgZGVwdGgueil7XFxuXHRcdFx0dmlzaWJpbGl0eSAtPSAwLjI7XFxuXHRcdH1cXG5cdH1cXG5cdHJldHVybiB2aXNpYmlsaXR5O1xcbn1cXG5cXG4vLyBUaGFua3MgdG8gaHR0cDovL2Rldm1hc3Rlci5uZXQvXFxuZmxvYXQgQ2hlYnljaGV2SW5lcXVhbGl0eSh2ZWMyIG1vbWVudHMsIGZsb2F0IHQpXFxue1xcblx0aWYgKHQgPD0gbW9tZW50cy54KVxcblx0e1xcblx0XHRyZXR1cm4gMS4wO1xcblx0fVxcblxcblx0ZmxvYXQgdmFyaWFuY2UgPSBtb21lbnRzLnkgLSAobW9tZW50cy54ICogbW9tZW50cy54KTtcXG5cdHZhcmlhbmNlID0gbWF4KHZhcmlhbmNlLCAwLik7XFxuXFxuXHRmbG9hdCBkID0gdCAtIG1vbWVudHMueDtcXG5cdHJldHVybiB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGQgKiBkKTtcXG59XFxuXFxuZmxvYXQgY29tcHV0ZVNoYWRvd1dpdGhWU00odmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQsIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyKVxcbntcXG5cdHZlYzMgZGVwdGggPSB2UG9zaXRpb25Gcm9tTGlnaHQueHl6IC8gdlBvc2l0aW9uRnJvbUxpZ2h0Lnc7XFxuXHR2ZWMyIHV2ID0gMC41ICogZGVwdGgueHkgKyB2ZWMyKDAuNSwgMC41KTtcXG5cXG5cdGlmICh1di54IDwgMC4gfHwgdXYueCA+IDEuMCB8fCB1di55IDwgMC4gfHwgdXYueSA+IDEuMClcXG5cdHtcXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cXG5cdHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQoc2hhZG93U2FtcGxlciwgdXYpO1xcblxcblx0dmVjMiBtb21lbnRzID0gdmVjMih1bnBhY2tIYWxmKHRleGVsLnh5KSwgdW5wYWNrSGFsZih0ZXhlbC56dykpO1xcblx0cmV0dXJuIGNsYW1wKDEuMyAtIENoZWJ5Y2hldkluZXF1YWxpdHkobW9tZW50cywgZGVwdGgueiksIDAuLCAxLjApO1xcbn1cXG4jZW5kaWZcXG5cXG4vLyBCdW1wXFxuI2lmZGVmIEJVTVBcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbnZhcnlpbmcgdmVjMiB2QnVtcFVWO1xcbnVuaWZvcm0gdmVjMiB2QnVtcEluZm9zO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBTYW1wbGVyO1xcblxcbi8vIFRoYW5rcyB0byBodHRwOi8vd3d3LnRoZXRlbnRocGxhbmV0LmRlL2FyY2hpdmVzLzExODBcXG5tYXQzIGNvdGFuZ2VudF9mcmFtZSh2ZWMzIG5vcm1hbCwgdmVjMyBwLCB2ZWMyIHV2KVxcbntcXG5cdC8vIGdldCBlZGdlIHZlY3RvcnMgb2YgdGhlIHBpeGVsIHRyaWFuZ2xlXFxuXHR2ZWMzIGRwMSA9IGRGZHgocCk7XFxuXHR2ZWMzIGRwMiA9IGRGZHkocCk7XFxuXHR2ZWMyIGR1djEgPSBkRmR4KHV2KTtcXG5cdHZlYzIgZHV2MiA9IGRGZHkodXYpO1xcblxcblx0Ly8gc29sdmUgdGhlIGxpbmVhciBzeXN0ZW1cXG5cdHZlYzMgZHAycGVycCA9IGNyb3NzKGRwMiwgbm9ybWFsKTtcXG5cdHZlYzMgZHAxcGVycCA9IGNyb3NzKG5vcm1hbCwgZHAxKTtcXG5cdHZlYzMgdGFuZ2VudCA9IGRwMnBlcnAgKiBkdXYxLnggKyBkcDFwZXJwICogZHV2Mi54O1xcblx0dmVjMyBiaW5vcm1hbCA9IGRwMnBlcnAgKiBkdXYxLnkgKyBkcDFwZXJwICogZHV2Mi55O1xcblxcblx0Ly8gY29uc3RydWN0IGEgc2NhbGUtaW52YXJpYW50IGZyYW1lIFxcblx0ZmxvYXQgaW52bWF4ID0gaW52ZXJzZXNxcnQobWF4KGRvdCh0YW5nZW50LCB0YW5nZW50KSwgZG90KGJpbm9ybWFsLCBiaW5vcm1hbCkpKTtcXG5cdHJldHVybiBtYXQzKHRhbmdlbnQgKiBpbnZtYXgsIGJpbm9ybWFsICogaW52bWF4LCBub3JtYWwpO1xcbn1cXG5cXG52ZWMzIHBlcnR1cmJOb3JtYWwodmVjMyB2aWV3RGlyKVxcbntcXG5cdHZlYzMgbWFwID0gdGV4dHVyZTJEKGJ1bXBTYW1wbGVyLCB2QnVtcFVWKS54eXogKiB2QnVtcEluZm9zLnk7XFxuXHRtYXAgPSBtYXAgKiAyNTUuIC8gMTI3LiAtIDEyOC4gLyAxMjcuO1xcblx0bWF0MyBUQk4gPSBjb3RhbmdlbnRfZnJhbWUodk5vcm1hbFcsIC12aWV3RGlyLCB2QnVtcFVWKTtcXG5cdHJldHVybiBub3JtYWxpemUoVEJOICogbWFwKTtcXG59XFxuI2VuZGlmXFxuXFxuI2lmZGVmIENMSVBQTEFORVxcbnZhcnlpbmcgZmxvYXQgZkNsaXBEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG4vLyBGb2dcXG4jaWZkZWYgRk9HXFxuXFxuI2RlZmluZSBGT0dNT0RFX05PTkUgICAgMC5cXG4jZGVmaW5lIEZPR01PREVfRVhQICAgICAxLlxcbiNkZWZpbmUgRk9HTU9ERV9FWFAyICAgIDIuXFxuI2RlZmluZSBGT0dNT0RFX0xJTkVBUiAgMy5cXG4jZGVmaW5lIEUgMi43MTgyOFxcblxcbnVuaWZvcm0gdmVjNCB2Rm9nSW5mb3M7XFxudW5pZm9ybSB2ZWMzIHZGb2dDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IGZGb2dEaXN0YW5jZTtcXG5cXG5mbG9hdCBDYWxjRm9nRmFjdG9yKClcXG57XFxuXHRmbG9hdCBmb2dDb2VmZiA9IDEuMDtcXG5cdGZsb2F0IGZvZ1N0YXJ0ID0gdkZvZ0luZm9zLnk7XFxuXHRmbG9hdCBmb2dFbmQgPSB2Rm9nSW5mb3MuejtcXG5cdGZsb2F0IGZvZ0RlbnNpdHkgPSB2Rm9nSW5mb3MudztcXG5cXG5cdGlmIChGT0dNT0RFX0xJTkVBUiA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAoZm9nRW5kIC0gZkZvZ0Rpc3RhbmNlKSAvIChmb2dFbmQgLSBmb2dTdGFydCk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUCA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAxLjAgLyBwb3coRSwgZkZvZ0Rpc3RhbmNlICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUDIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5KTtcXG5cdH1cXG5cXG5cdHJldHVybiBjbGFtcChmb2dDb2VmZiwgMC4wLCAxLjApO1xcbn1cXG4jZW5kaWZcXG5cXG4vLyBMaWdodCBDb21wdXRpbmdcXG5zdHJ1Y3QgbGlnaHRpbmdJbmZvXFxue1xcblx0dmVjMyBkaWZmdXNlO1xcblx0dmVjMyBzcGVjdWxhcjtcXG59O1xcblxcbmxpZ2h0aW5nSW5mbyBjb21wdXRlTGlnaHRpbmcodmVjMyB2aWV3RGlyZWN0aW9uVywgdmVjMyB2Tm9ybWFsLCB2ZWM0IGxpZ2h0RGF0YSwgdmVjMyBkaWZmdXNlQ29sb3IsIHZlYzMgc3BlY3VsYXJDb2xvciwgZmxvYXQgcmFuZ2UpIHtcXG5cdGxpZ2h0aW5nSW5mbyByZXN1bHQ7XFxuXFxuXHR2ZWMzIGxpZ2h0VmVjdG9yVztcXG5cdGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblx0aWYgKGxpZ2h0RGF0YS53ID09IDAuKVxcblx0e1xcblx0XHR2ZWMzIGRpcmVjdGlvbiA9IGxpZ2h0RGF0YS54eXogLSB2UG9zaXRpb25XO1xcblxcblx0XHRhdHRlbnVhdGlvbiA9IG1heCgwLiwgMS4wIC0gbGVuZ3RoKGRpcmVjdGlvbikgLyByYW5nZSk7XFxuXHRcdGxpZ2h0VmVjdG9yVyA9IG5vcm1hbGl6ZShkaXJlY3Rpb24pO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHRsaWdodFZlY3RvclcgPSBub3JtYWxpemUoLWxpZ2h0RGF0YS54eXopO1xcblx0fVxcblxcblx0Ly8gZGlmZnVzZVxcblx0ZmxvYXQgbmRsID0gbWF4KDAuLCBkb3Qodk5vcm1hbCwgbGlnaHRWZWN0b3JXKSk7XFxuXFxuXHQvLyBTcGVjdWxhclxcblx0dmVjMyBhbmdsZVcgPSBub3JtYWxpemUodmlld0RpcmVjdGlvblcgKyBsaWdodFZlY3RvclcpO1xcblx0ZmxvYXQgc3BlY0NvbXAgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCBhbmdsZVcpKTtcXG5cdHNwZWNDb21wID0gcG93KHNwZWNDb21wLCBtYXgoMS4sIHZTcGVjdWxhckNvbG9yLmEpKTtcXG5cXG5cdHJlc3VsdC5kaWZmdXNlID0gbmRsICogZGlmZnVzZUNvbG9yICogYXR0ZW51YXRpb247XFxuXHRyZXN1bHQuc3BlY3VsYXIgPSBzcGVjQ29tcCAqIHNwZWN1bGFyQ29sb3IgKiBhdHRlbnVhdGlvbjtcXG5cXG5cdHJldHVybiByZXN1bHQ7XFxufVxcblxcbmxpZ2h0aW5nSW5mbyBjb21wdXRlU3BvdExpZ2h0aW5nKHZlYzMgdmlld0RpcmVjdGlvblcsIHZlYzMgdk5vcm1hbCwgdmVjNCBsaWdodERhdGEsIHZlYzQgbGlnaHREaXJlY3Rpb24sIHZlYzMgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsIGZsb2F0IHJhbmdlKSB7XFxuXHRsaWdodGluZ0luZm8gcmVzdWx0O1xcblxcblx0dmVjMyBkaXJlY3Rpb24gPSBsaWdodERhdGEueHl6IC0gdlBvc2l0aW9uVztcXG5cdHZlYzMgbGlnaHRWZWN0b3JXID0gbm9ybWFsaXplKGRpcmVjdGlvbik7XFxuXHRmbG9hdCBhdHRlbnVhdGlvbiA9IG1heCgwLiwgMS4wIC0gbGVuZ3RoKGRpcmVjdGlvbikgLyByYW5nZSk7XFxuXFxuXHQvLyBkaWZmdXNlXFxuXHRmbG9hdCBjb3NBbmdsZSA9IG1heCgwLiwgZG90KC1saWdodERpcmVjdGlvbi54eXosIGxpZ2h0VmVjdG9yVykpO1xcblx0ZmxvYXQgc3BvdEF0dGVuID0gMC4wO1xcblxcblx0aWYgKGNvc0FuZ2xlID49IGxpZ2h0RGlyZWN0aW9uLncpXFxuXHR7XFxuXHRcdGNvc0FuZ2xlID0gbWF4KDAuLCBwb3coY29zQW5nbGUsIGxpZ2h0RGF0YS53KSk7XFxuXHRcdHNwb3RBdHRlbiA9IG1heCgwLiwgKGNvc0FuZ2xlIC0gbGlnaHREaXJlY3Rpb24udykgLyAoMS4gLSBjb3NBbmdsZSkpO1xcblxcblx0XHQvLyBEaWZmdXNlXFxuXHRcdGZsb2F0IG5kbCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIC1saWdodERpcmVjdGlvbi54eXopKTtcXG5cXG5cdFx0Ly8gU3BlY3VsYXJcXG5cdFx0dmVjMyBhbmdsZVcgPSBub3JtYWxpemUodmlld0RpcmVjdGlvblcgLSBsaWdodERpcmVjdGlvbi54eXopO1xcblx0XHRmbG9hdCBzcGVjQ29tcCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGFuZ2xlVykpO1xcblx0XHRzcGVjQ29tcCA9IHBvdyhzcGVjQ29tcCwgdlNwZWN1bGFyQ29sb3IuYSk7XFxuXFxuXHRcdHJlc3VsdC5kaWZmdXNlID0gbmRsICogc3BvdEF0dGVuICogZGlmZnVzZUNvbG9yICogYXR0ZW51YXRpb247XFxuXHRcdHJlc3VsdC5zcGVjdWxhciA9IHNwZWNDb21wICogc3BlY3VsYXJDb2xvciAqIHNwb3RBdHRlbiAqIGF0dGVudWF0aW9uO1xcblxcblx0XHRyZXR1cm4gcmVzdWx0O1xcblx0fVxcblxcblx0cmVzdWx0LmRpZmZ1c2UgPSB2ZWMzKDAuKTtcXG5cdHJlc3VsdC5zcGVjdWxhciA9IHZlYzMoMC4pO1xcblxcblx0cmV0dXJuIHJlc3VsdDtcXG59XFxuXFxubGlnaHRpbmdJbmZvIGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZlYzMgdmlld0RpcmVjdGlvblcsIHZlYzMgdk5vcm1hbCwgdmVjNCBsaWdodERhdGEsIHZlYzMgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsIHZlYzMgZ3JvdW5kQ29sb3IpIHtcXG5cdGxpZ2h0aW5nSW5mbyByZXN1bHQ7XFxuXFxuXHQvLyBEaWZmdXNlXFxuXHRmbG9hdCBuZGwgPSBkb3Qodk5vcm1hbCwgbGlnaHREYXRhLnh5eikgKiAwLjUgKyAwLjU7XFxuXFxuXHQvLyBTcGVjdWxhclxcblx0dmVjMyBhbmdsZVcgPSBub3JtYWxpemUodmlld0RpcmVjdGlvblcgKyBsaWdodERhdGEueHl6KTtcXG5cdGZsb2F0IHNwZWNDb21wID0gbWF4KDAuLCBkb3Qodk5vcm1hbCwgYW5nbGVXKSk7XFxuXHRzcGVjQ29tcCA9IHBvdyhzcGVjQ29tcCwgdlNwZWN1bGFyQ29sb3IuYSk7XFxuXFxuXHRyZXN1bHQuZGlmZnVzZSA9IG1peChncm91bmRDb2xvciwgZGlmZnVzZUNvbG9yLCBuZGwpO1xcblx0cmVzdWx0LnNwZWN1bGFyID0gc3BlY0NvbXAgKiBzcGVjdWxhckNvbG9yO1xcblxcblx0cmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdC8vIENsaXAgcGxhbmVcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHRpZiAoZkNsaXBEaXN0YW5jZSA+IDAuMClcXG5cdFx0ZGlzY2FyZDtcXG4jZW5kaWZcXG5cXG5cdHZlYzMgdmlld0RpcmVjdGlvblcgPSBub3JtYWxpemUodkV5ZVBvc2l0aW9uIC0gdlBvc2l0aW9uVyk7XFxuXFxuXHQvLyBCYXNlIGNvbG9yXFxuXHR2ZWM0IGJhc2VDb2xvciA9IHZlYzQoMS4sIDEuLCAxLiwgMS4pO1xcblx0dmVjMyBkaWZmdXNlQ29sb3IgPSB2RGlmZnVzZUNvbG9yLnJnYjtcXG5cXG5cdC8vIEFscGhhXFxuXHRmbG9hdCBhbHBoYSA9IHZEaWZmdXNlQ29sb3IuYTtcXG5cXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5cdGRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIERJRkZVU0VcXG5cdGJhc2VDb2xvciA9IHRleHR1cmUyRChkaWZmdXNlU2FtcGxlciwgdkRpZmZ1c2VVVik7XFxuXFxuI2lmZGVmIEFMUEhBVEVTVFxcblx0aWYgKGJhc2VDb2xvci5hIDwgMC40KVxcblx0XHRkaXNjYXJkO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTFBIQUZST01ESUZGVVNFXFxuXHRhbHBoYSAqPSBiYXNlQ29sb3IuYTtcXG4jZW5kaWZcXG5cXG5cdGJhc2VDb2xvci5yZ2IgKj0gdkRpZmZ1c2VJbmZvcy55O1xcbiNlbmRpZlxcblxcblx0Ly8gQnVtcFxcblx0dmVjMyBub3JtYWxXID0gbm9ybWFsaXplKHZOb3JtYWxXKTtcXG5cXG4jaWZkZWYgQlVNUFxcblx0bm9ybWFsVyA9IHBlcnR1cmJOb3JtYWwodmlld0RpcmVjdGlvblcpO1xcbiNlbmRpZlxcblxcblx0Ly8gQW1iaWVudCBjb2xvclxcblx0dmVjMyBiYXNlQW1iaWVudENvbG9yID0gdmVjMygxLiwgMS4sIDEuKTtcXG5cXG4jaWZkZWYgQU1CSUVOVFxcblx0YmFzZUFtYmllbnRDb2xvciA9IHRleHR1cmUyRChhbWJpZW50U2FtcGxlciwgdkFtYmllbnRVVikucmdiICogdkFtYmllbnRJbmZvcy55O1xcbiNlbmRpZlxcblxcblx0Ly8gTGlnaHRpbmdcXG5cdHZlYzMgZGlmZnVzZUJhc2UgPSB2ZWMzKDAuLCAwLiwgMC4pO1xcblx0dmVjMyBzcGVjdWxhckJhc2UgPSB2ZWMzKDAuLCAwLiwgMC4pO1xcblx0ZmxvYXQgc2hhZG93ID0gMS47XFxuXFxuI2lmZGVmIExJR0hUMFxcbiNpZmRlZiBTUE9UTElHSFQwXFxuXHRsaWdodGluZ0luZm8gaW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaXJlY3Rpb24wLCB2TGlnaHREaWZmdXNlMC5yZ2IsIHZMaWdodFNwZWN1bGFyMCwgdkxpZ2h0RGlmZnVzZTAuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDBcXG5cdGxpZ2h0aW5nSW5mbyBpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaWZmdXNlMC5yZ2IsIHZMaWdodFNwZWN1bGFyMCwgdkxpZ2h0R3JvdW5kMCk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQwXFxuXHRsaWdodGluZ0luZm8gaW5mbyA9IGNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTAsIHZMaWdodERpZmZ1c2UwLnJnYiwgdkxpZ2h0U3BlY3VsYXIwLCB2TGlnaHREaWZmdXNlMC5hKTtcXG4jZW5kaWZcXG4jaWZkZWYgU0hBRE9XMFxcbiNpZmRlZiBTSEFET1dWU00wXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFZTTSh2UG9zaXRpb25Gcm9tTGlnaHQwLCBzaGFkb3dTYW1wbGVyMCk7XFxuI2Vsc2VcXG5cdCNpZmRlZiBTSEFET1dQQ0YwXFxuXHRcdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoUENGKHZQb3NpdGlvbkZyb21MaWdodDAsIHNoYWRvd1NhbXBsZXIwKTtcXG5cdCNlbHNlXFxuXHRcdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3codlBvc2l0aW9uRnJvbUxpZ2h0MCwgc2hhZG93U2FtcGxlcjAsIGRhcmtuZXNzMCk7XFxuXHQjZW5kaWZcXG4jZW5kaWZcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvLmRpZmZ1c2UgKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mby5zcGVjdWxhciAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQxXFxuI2lmZGVmIFNQT1RMSUdIVDFcXG5cdGluZm8gPSBjb21wdXRlU3BvdExpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlyZWN0aW9uMSwgdkxpZ2h0RGlmZnVzZTEucmdiLCB2TGlnaHRTcGVjdWxhcjEsIHZMaWdodERpZmZ1c2UxLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQxXFxuXHRpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGExLCB2TGlnaHREaWZmdXNlMS5yZ2IsIHZMaWdodFNwZWN1bGFyMSwgdkxpZ2h0R3JvdW5kMSk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQxXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlmZnVzZTEucmdiLCB2TGlnaHRTcGVjdWxhcjEsIHZMaWdodERpZmZ1c2UxLmEpO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1cxXFxuI2lmZGVmIFNIQURPV1ZTTTFcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDEsIHNoYWRvd1NhbXBsZXIxKTtcXG4jZWxzZVxcblx0I2lmZGVmIFNIQURPV1BDRjFcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhQQ0YodlBvc2l0aW9uRnJvbUxpZ2h0MSwgc2hhZG93U2FtcGxlcjEpO1xcblx0I2Vsc2VcXG5cdFx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQxLCBzaGFkb3dTYW1wbGVyMSwgZGFya25lc3MxKTtcXG5cdCNlbmRpZlxcbiNlbmRpZlxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm8uZGlmZnVzZSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvLnNwZWN1bGFyICogc2hhZG93O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDJcXG4jaWZkZWYgU1BPVExJR0hUMlxcblx0aW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaXJlY3Rpb24yLCB2TGlnaHREaWZmdXNlMi5yZ2IsIHZMaWdodFNwZWN1bGFyMiwgdkxpZ2h0RGlmZnVzZTIuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDJcXG5cdGluZm8gPSBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTIsIHZMaWdodERpZmZ1c2UyLnJnYiwgdkxpZ2h0U3BlY3VsYXIyLCB2TGlnaHRHcm91bmQyKTtcXG4jZW5kaWZcXG4jaWZkZWYgUE9JTlRESVJMSUdIVDJcXG5cdGluZm8gPSBjb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaWZmdXNlMi5yZ2IsIHZMaWdodFNwZWN1bGFyMiwgdkxpZ2h0RGlmZnVzZTIuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzJcXG4jaWZkZWYgU0hBRE9XVlNNMlxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0Miwgc2hhZG93U2FtcGxlcjIpO1xcbiNlbHNlXFxuXHQjaWZkZWYgU0hBRE9XUENGMlxcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFBDRih2UG9zaXRpb25Gcm9tTGlnaHQyLCBzaGFkb3dTYW1wbGVyMik7XFxuXHQjZWxzZVxcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDIsIHNoYWRvd1NhbXBsZXIyLCBkYXJrbmVzczIpO1xcblx0I2VuZGlmXHRcXG4jZW5kaWZcdFxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm8uZGlmZnVzZSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvLnNwZWN1bGFyICogc2hhZG93O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDNcXG4jaWZkZWYgU1BPVExJR0hUM1xcblx0aW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEzLCB2TGlnaHREaXJlY3Rpb24zLCB2TGlnaHREaWZmdXNlMy5yZ2IsIHZMaWdodFNwZWN1bGFyMywgdkxpZ2h0RGlmZnVzZTMuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDNcXG5cdGluZm8gPSBjb21wdXRlSGVtaXNwaGVyaWNMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTMsIHZMaWdodERpZmZ1c2UzLnJnYiwgdkxpZ2h0U3BlY3VsYXIzLCB2TGlnaHRHcm91bmQzKTtcXG4jZW5kaWZcXG4jaWZkZWYgUE9JTlRESVJMSUdIVDNcXG5cdGluZm8gPSBjb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEzLCB2TGlnaHREaWZmdXNlMy5yZ2IsIHZMaWdodFNwZWN1bGFyMywgdkxpZ2h0RGlmZnVzZTMuYSk7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzNcXG4jaWZkZWYgU0hBRE9XVlNNM1xcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0Mywgc2hhZG93U2FtcGxlcjMpO1xcbiNlbHNlXFxuXHQjaWZkZWYgU0hBRE9XUENGM1xcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFBDRih2UG9zaXRpb25Gcm9tTGlnaHQzLCBzaGFkb3dTYW1wbGVyMyk7XFxuXHQjZWxzZVxcblx0XHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDMsIHNoYWRvd1NhbXBsZXIzLCBkYXJrbmVzczMpO1xcblx0I2VuZGlmXHRcXG4jZW5kaWZcdFxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm8uZGlmZnVzZSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvLnNwZWN1bGFyICogc2hhZG93O1xcbiNlbmRpZlxcblxcblx0Ly8gUmVmbGVjdGlvblxcblx0dmVjMyByZWZsZWN0aW9uQ29sb3IgPSB2ZWMzKDAuLCAwLiwgMC4pO1xcblxcbiNpZmRlZiBSRUZMRUNUSU9OXFxuXHR2ZWMzIHZSZWZsZWN0aW9uVVZXID0gY29tcHV0ZVJlZmxlY3Rpb25Db29yZHModlJlZmxlY3Rpb25JbmZvcy54LCB2ZWM0KHZQb3NpdGlvblcsIDEuMCksIG5vcm1hbFcpO1xcblxcblx0aWYgKHZSZWZsZWN0aW9uSW5mb3MueiAhPSAwLjApXFxuXHR7XFxuXHRcdHJlZmxlY3Rpb25Db2xvciA9IHRleHR1cmVDdWJlKHJlZmxlY3Rpb25DdWJlU2FtcGxlciwgdlJlZmxlY3Rpb25VVlcpLnJnYiAqIHZSZWZsZWN0aW9uSW5mb3MueSAqIHNoYWRvdztcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dmVjMiBjb29yZHMgPSB2UmVmbGVjdGlvblVWVy54eTtcXG5cXG5cdFx0aWYgKHZSZWZsZWN0aW9uSW5mb3MueCA9PSBNQVBfUFJPSkVDVElPTilcXG5cdFx0e1xcblx0XHRcdGNvb3JkcyAvPSB2UmVmbGVjdGlvblVWVy56O1xcblx0XHR9XFxuXFxuXHRcdGNvb3Jkcy55ID0gMS4wIC0gY29vcmRzLnk7XFxuXFxuXHRcdHJlZmxlY3Rpb25Db2xvciA9IHRleHR1cmUyRChyZWZsZWN0aW9uMkRTYW1wbGVyLCBjb29yZHMpLnJnYiAqIHZSZWZsZWN0aW9uSW5mb3MueSAqIHNoYWRvdztcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVxcblx0dmVjNCBvcGFjaXR5TWFwID0gdGV4dHVyZTJEKG9wYWNpdHlTYW1wbGVyLCB2T3BhY2l0eVVWKTtcXG5cXG4jaWZkZWYgT1BBQ0lUWVJHQlxcblx0b3BhY2l0eU1hcC5yZ2IgPSBvcGFjaXR5TWFwLnJnYiAqIHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG5cdGFscGhhICo9IChvcGFjaXR5TWFwLnggKyBvcGFjaXR5TWFwLnkgKyBvcGFjaXR5TWFwLnopKiB2T3BhY2l0eUluZm9zLnk7XFxuI2Vsc2VcXG5cdGFscGhhICo9IG9wYWNpdHlNYXAuYSAqIHZPcGFjaXR5SW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cXG4jZW5kaWZcXG5cXG5cdC8vIEVtaXNzaXZlXFxuXHR2ZWMzIGVtaXNzaXZlQ29sb3IgPSB2RW1pc3NpdmVDb2xvcjtcXG4jaWZkZWYgRU1JU1NJVkVcXG5cdGVtaXNzaXZlQ29sb3IgKz0gdGV4dHVyZTJEKGVtaXNzaXZlU2FtcGxlciwgdkVtaXNzaXZlVVYpLnJnYiAqIHZFbWlzc2l2ZUluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBTcGVjdWxhciBtYXBcXG5cdHZlYzMgc3BlY3VsYXJDb2xvciA9IHZTcGVjdWxhckNvbG9yLnJnYjtcXG4jaWZkZWYgU1BFQ1VMQVJcXG5cdHNwZWN1bGFyQ29sb3IgPSB0ZXh0dXJlMkQoc3BlY3VsYXJTYW1wbGVyLCB2U3BlY3VsYXJVVikucmdiICogdlNwZWN1bGFySW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cdC8vIENvbXBvc2l0aW9uXFxuXHR2ZWMzIGZpbmFsRGlmZnVzZSA9IGNsYW1wKGRpZmZ1c2VCYXNlICogZGlmZnVzZUNvbG9yICsgZW1pc3NpdmVDb2xvciArIHZBbWJpZW50Q29sb3IsIDAuMCwgMS4wKSAqIGJhc2VDb2xvci5yZ2I7XFxuXHR2ZWMzIGZpbmFsU3BlY3VsYXIgPSBzcGVjdWxhckJhc2UgKiBzcGVjdWxhckNvbG9yO1xcblxcblx0dmVjNCBjb2xvciA9IHZlYzQoZmluYWxEaWZmdXNlICogYmFzZUFtYmllbnRDb2xvciArIGZpbmFsU3BlY3VsYXIgKyByZWZsZWN0aW9uQ29sb3IsIGFscGhhKTtcXG5cXG4jaWZkZWYgRk9HXFxuXHRmbG9hdCBmb2cgPSBDYWxjRm9nRmFjdG9yKCk7XFxuXHRjb2xvci5yZ2IgPSBmb2cgKiBjb2xvci5yZ2IgKyAoMS4wIC0gZm9nKSAqIHZGb2dDb2xvcjtcXG4jZW5kaWZcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIixkZWZhdWx0VmVydGV4U2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gQXR0cmlidXRlc1xcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG4jaWZkZWYgVVYxXFxuYXR0cmlidXRlIHZlYzIgdXY7XFxuI2VuZGlmXFxuI2lmZGVmIFVWMlxcbmF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG4jZW5kaWZcXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5hdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG4jZW5kaWZcXG4jaWZkZWYgQk9ORVNcXG5hdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc0luZGljZXM7XFxuYXR0cmlidXRlIHZlYzQgbWF0cmljZXNXZWlnaHRzO1xcbiNlbmRpZlxcblxcbi8vIFVuaWZvcm1zXFxuXFxuI2lmZGVmIElOU1RBTkNFU1xcbmF0dHJpYnV0ZSB2ZWM0IHdvcmxkMDtcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDE7XFxuYXR0cmlidXRlIHZlYzQgd29ybGQyO1xcbmF0dHJpYnV0ZSB2ZWM0IHdvcmxkMztcXG4jZWxzZVxcbnVuaWZvcm0gbWF0NCB3b3JsZDtcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdmlldztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2plY3Rpb247XFxuXFxuI2lmZGVmIERJRkZVU0VcXG52YXJ5aW5nIHZlYzIgdkRpZmZ1c2VVVjtcXG51bmlmb3JtIG1hdDQgZGlmZnVzZU1hdHJpeDtcXG51bmlmb3JtIHZlYzIgdkRpZmZ1c2VJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQU1CSUVOVFxcbnZhcnlpbmcgdmVjMiB2QW1iaWVudFVWO1xcbnVuaWZvcm0gbWF0NCBhbWJpZW50TWF0cml4O1xcbnVuaWZvcm0gdmVjMiB2QW1iaWVudEluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBPUEFDSVRZXFxudmFyeWluZyB2ZWMyIHZPcGFjaXR5VVY7XFxudW5pZm9ybSBtYXQ0IG9wYWNpdHlNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHZPcGFjaXR5SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEVNSVNTSVZFXFxudmFyeWluZyB2ZWMyIHZFbWlzc2l2ZVVWO1xcbnVuaWZvcm0gdmVjMiB2RW1pc3NpdmVJbmZvcztcXG51bmlmb3JtIG1hdDQgZW1pc3NpdmVNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNQRUNVTEFSXFxudmFyeWluZyB2ZWMyIHZTcGVjdWxhclVWO1xcbnVuaWZvcm0gdmVjMiB2U3BlY3VsYXJJbmZvcztcXG51bmlmb3JtIG1hdDQgc3BlY3VsYXJNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJVTVBcXG52YXJ5aW5nIHZlYzIgdkJ1bXBVVjtcXG51bmlmb3JtIHZlYzIgdkJ1bXBJbmZvcztcXG51bmlmb3JtIG1hdDQgYnVtcE1hdHJpeDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQk9ORVNcXG51bmlmb3JtIG1hdDQgbUJvbmVzW0JvbmVzUGVyTWVzaF07XFxuI2VuZGlmXFxuXFxuLy8gT3V0cHV0XFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvblc7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWxXO1xcblxcbiNpZmRlZiBWRVJURVhDT0xPUlxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIENMSVBQTEFORVxcbnVuaWZvcm0gdmVjNCB2Q2xpcFBsYW5lO1xcbnZhcnlpbmcgZmxvYXQgZkNsaXBEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRk9HXFxudmFyeWluZyBmbG9hdCBmRm9nRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNIQURPV1NcXG4jaWZkZWYgTElHSFQwXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MDtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MDtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQxXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MTtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MTtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQyXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MjtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MjtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQzXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MztcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MztcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb25VVlc7XFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdG1hdDQgZmluYWxXb3JsZDtcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcblx0dlBvc2l0aW9uVVZXID0gcG9zaXRpb247XFxuI2VuZGlmIFxcblxcbiNpZmRlZiBCT05FU1xcblx0bWF0NCBtMCA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLngpXSAqIG1hdHJpY2VzV2VpZ2h0cy54O1xcblx0bWF0NCBtMSA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnkpXSAqIG1hdHJpY2VzV2VpZ2h0cy55O1xcblx0bWF0NCBtMiA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnopXSAqIG1hdHJpY2VzV2VpZ2h0cy56O1xcblxcbiNpZmRlZiBCT05FUzRcXG5cdG1hdDQgbTMgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy53KV0gKiBtYXRyaWNlc1dlaWdodHMudztcXG5cdGZpbmFsV29ybGQgPSB3b3JsZCAqIChtMCArIG0xICsgbTIgKyBtMyk7XFxuI2Vsc2VcXG5cdGZpbmFsV29ybGQgPSB3b3JsZCAqIChtMCArIG0xICsgbTIpO1xcbiNlbmRpZiBcXG5cXG4jZWxzZVxcbiNpZmRlZiBJTlNUQU5DRVNcXG5cdGZpbmFsV29ybGQgPSBtYXQ0KHdvcmxkMCwgd29ybGQxLCB3b3JsZDIsIHdvcmxkMyk7XFxuI2Vsc2VcXG5cdGZpbmFsV29ybGQgPSB3b3JsZDtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cdGdsX1Bvc2l0aW9uID0gdmlld1Byb2plY3Rpb24gKiBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXG5cdHZlYzQgd29ybGRQb3MgPSBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cdHZQb3NpdGlvblcgPSB2ZWMzKHdvcmxkUG9zKTtcXG5cdHZOb3JtYWxXID0gbm9ybWFsaXplKHZlYzMoZmluYWxXb3JsZCAqIHZlYzQobm9ybWFsLCAwLjApKSk7XFxuXFxuXHQvLyBUZXh0dXJlIGNvb3JkaW5hdGVzXFxuI2lmbmRlZiBVVjFcXG5cdHZlYzIgdXYgPSB2ZWMyKDAuLCAwLik7XFxuI2VuZGlmXFxuI2lmbmRlZiBVVjJcXG5cdHZlYzIgdXYyID0gdmVjMigwLiwgMC4pO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBESUZGVVNFXFxuXHRpZiAodkRpZmZ1c2VJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2RGlmZnVzZVVWID0gdmVjMihkaWZmdXNlTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkRpZmZ1c2VVViA9IHZlYzIoZGlmZnVzZU1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBBTUJJRU5UXFxuXHRpZiAodkFtYmllbnRJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2QW1iaWVudFVWID0gdmVjMihhbWJpZW50TWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkFtYmllbnRVViA9IHZlYzIoYW1iaWVudE1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBPUEFDSVRZXFxuXHRpZiAodk9wYWNpdHlJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2T3BhY2l0eVVWID0gdmVjMihvcGFjaXR5TWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dk9wYWNpdHlVViA9IHZlYzIob3BhY2l0eU1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBFTUlTU0lWRVxcblx0aWYgKHZFbWlzc2l2ZUluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZFbWlzc2l2ZVVWID0gdmVjMihlbWlzc2l2ZU1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZFbWlzc2l2ZVVWID0gdmVjMihlbWlzc2l2ZU1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBTUEVDVUxBUlxcblx0aWYgKHZTcGVjdWxhckluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZTcGVjdWxhclVWID0gdmVjMihzcGVjdWxhck1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZTcGVjdWxhclVWID0gdmVjMihzcGVjdWxhck1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcbiNpZmRlZiBCVU1QXFxuXHRpZiAodkJ1bXBJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2QnVtcFVWID0gdmVjMihidW1wTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dkJ1bXBVViA9IHZlYzIoYnVtcE1hdHJpeCAqIHZlYzQodXYyLCAxLjAsIDAuMCkpO1xcblx0fVxcbiNlbmRpZlxcblxcblx0Ly8gQ2xpcCBwbGFuZVxcbiNpZmRlZiBDTElQUExBTkVcXG5cdGZDbGlwRGlzdGFuY2UgPSBkb3Qod29ybGRQb3MsIHZDbGlwUGxhbmUpO1xcbiNlbmRpZlxcblxcblx0Ly8gRm9nXFxuI2lmZGVmIEZPR1xcblx0ZkZvZ0Rpc3RhbmNlID0gKHZpZXcgKiB3b3JsZFBvcykuejtcXG4jZW5kaWZcXG5cXG5cdC8vIFNoYWRvd3NcXG4jaWZkZWYgU0hBRE9XU1xcbiNpZmRlZiBMSUdIVDBcXG5cdHZQb3NpdGlvbkZyb21MaWdodDAgPSBsaWdodE1hdHJpeDAgKiB3b3JsZFBvcztcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQxXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQxID0gbGlnaHRNYXRyaXgxICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMlxcblx0dlBvc2l0aW9uRnJvbUxpZ2h0MiA9IGxpZ2h0TWF0cml4MiAqIHdvcmxkUG9zO1xcbiNlbmRpZlxcbiNpZmRlZiBMSUdIVDNcXG5cdHZQb3NpdGlvbkZyb21MaWdodDMgPSBsaWdodE1hdHJpeDMgKiB3b3JsZFBvcztcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG5cdC8vIFZlcnRleCBjb2xvclxcbiNpZmRlZiBWRVJURVhDT0xPUlxcblx0dkNvbG9yID0gY29sb3I7XFxuI2VuZGlmXFxufVwiLGRpc3BsYXlQYXNzUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgcGFzc1NhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQocGFzc1NhbXBsZXIsIHZVVik7XFxufVwiLGZpbHRlclBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbnVuaWZvcm0gbWF0NCBrZXJuZWxNYXRyaXg7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcblx0dmVjMyBiYXNlQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVikucmdiO1xcblx0dmVjMyB1cGRhdGVkQ29sb3IgPSAoa2VybmVsTWF0cml4ICogdmVjNChiYXNlQ29sb3IsIDEuMCkpLnJnYjtcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQodXBkYXRlZENvbG9yLCAxLjApO1xcbn1cIixmeGFhUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvMTI4LjApXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wLzguMClcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXG5cXG52b2lkIG1haW4oKXtcXG5cdHZlYzIgbG9jYWxUZXhlbFNpemUgPSB0ZXhlbFNpemU7XFxuXHR2ZWM0IHJnYk5XID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCAodlVWICsgdmVjMigtMS4wLCAtMS4wKSAqIGxvY2FsVGV4ZWxTaXplKSk7XFxuXHR2ZWM0IHJnYk5FID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCAodlVWICsgdmVjMigxLjAsIC0xLjApICogbG9jYWxUZXhlbFNpemUpKTtcXG5cdHZlYzQgcmdiU1cgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsICh2VVYgKyB2ZWMyKC0xLjAsIDEuMCkgKiBsb2NhbFRleGVsU2l6ZSkpO1xcblx0dmVjNCByZ2JTRSA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgKHZVViArIHZlYzIoMS4wLCAxLjApICogbG9jYWxUZXhlbFNpemUpKTtcXG5cdHZlYzQgcmdiTSA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWKTtcXG5cdHZlYzQgbHVtYSA9IHZlYzQoMC4yOTksIDAuNTg3LCAwLjExNCwgMS4wKTtcXG5cdGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuXHRmbG9hdCBsdW1hTkUgPSBkb3QocmdiTkUsIGx1bWEpO1xcblx0ZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG5cdGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuXHRmbG9hdCBsdW1hTSA9IGRvdChyZ2JNLCBsdW1hKTtcXG5cdGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuXHRmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xcblxcblx0dmVjMiBkaXIgPSB2ZWMyKC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSksICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKSk7XFxuXFxuXHRmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoXFxuXHRcdChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICogKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLFxcblx0XHRGWEFBX1JFRFVDRV9NSU4pO1xcblxcblx0ZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuXHRkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSxcXG5cdFx0bWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcXG5cdFx0ZGlyICogcmNwRGlyTWluKSkgKiBsb2NhbFRleGVsU2l6ZTtcXG5cXG5cdHZlYzQgcmdiQSA9IDAuNSAqIChcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkgK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKSk7XFxuXFxuXHR2ZWM0IHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqIChcXG5cdFx0dGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgKyBkaXIgKiAgLTAuNSkgK1xcblx0XHR0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVViArIGRpciAqIDAuNSkpO1xcblx0ZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XFxuXHRpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpIHtcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gcmdiQTtcXG5cdH1cXG5cdGVsc2Uge1xcblx0XHRnbF9GcmFnQ29sb3IgPSByZ2JCO1xcblx0fVxcbn1cIixsYXllclBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyO1xcblxcbi8vIENvbG9yXFxudW5pZm9ybSB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXHR2ZWM0IGJhc2VDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWKTtcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvciAqIGNvbG9yO1xcbn1cIixsYXllclZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXG4vLyBVbmlmb3Jtc1xcbnVuaWZvcm0gbWF0NCB0ZXh0dXJlTWF0cml4O1xcblxcbi8vIE91dHB1dFxcbnZhcnlpbmcgdmVjMiB2VVY7XFxuXFxuY29uc3QgdmVjMiBtYWRkID0gdmVjMigwLjUsIDAuNSk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcdFxcblxcblx0dlVWID0gdmVjMih0ZXh0dXJlTWF0cml4ICogdmVjNChwb3NpdGlvbiAqIG1hZGQgKyBtYWRkLCAxLjAsIDAuMCkpO1xcblx0Z2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XFxufVwiLGxlZ2FjeWRlZmF1bHRQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbiNkZWZpbmUgTUFQX1BST0pFQ1RJT05cdDQuXFxuXFxuLy8gQ29uc3RhbnRzXFxudW5pZm9ybSB2ZWMzIHZFeWVQb3NpdGlvbjtcXG51bmlmb3JtIHZlYzMgdkFtYmllbnRDb2xvcjtcXG51bmlmb3JtIHZlYzQgdkRpZmZ1c2VDb2xvcjtcXG51bmlmb3JtIHZlYzQgdlNwZWN1bGFyQ29sb3I7XFxudW5pZm9ybSB2ZWMzIHZFbWlzc2l2ZUNvbG9yO1xcblxcbi8vIElucHV0XFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvblc7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWxXO1xcblxcbiNpZmRlZiBWRVJURVhDT0xPUlxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuLy8gTGlnaHRzXFxuI2lmZGVmIExJR0hUMFxcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMDtcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTA7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMDtcXG4jaWZkZWYgU0hBRE9XMFxcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIwO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQwXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjA7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDBcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMDtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTElHSFQxXFxudW5pZm9ybSB2ZWM0IHZMaWdodERhdGExO1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREaWZmdXNlMTtcXG51bmlmb3JtIHZlYzMgdkxpZ2h0U3BlY3VsYXIxO1xcbiNpZmRlZiBTSEFET1cxXFxudmFyeWluZyB2ZWM0IHZQb3NpdGlvbkZyb21MaWdodDE7XFxudW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcjE7XFxuI2VuZGlmXFxuI2lmZGVmIFNQT1RMSUdIVDFcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlyZWN0aW9uMTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMVxcbnVuaWZvcm0gdmVjMyB2TGlnaHRHcm91bmQxO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDJcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGF0YTI7XFxudW5pZm9ybSB2ZWM0IHZMaWdodERpZmZ1c2UyO1xcbnVuaWZvcm0gdmVjMyB2TGlnaHRTcGVjdWxhcjI7XFxuI2lmZGVmIFNIQURPVzJcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MjtcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dTYW1wbGVyMjtcXG4jZW5kaWZcXG4jaWZkZWYgU1BPVExJR0hUMlxcbnVuaWZvcm0gdmVjNCB2TGlnaHREaXJlY3Rpb24yO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQyXFxudW5pZm9ybSB2ZWMzIHZMaWdodEdyb3VuZDI7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUM1xcbnVuaWZvcm0gdmVjNCB2TGlnaHREYXRhMztcXG51bmlmb3JtIHZlYzQgdkxpZ2h0RGlmZnVzZTM7XFxudW5pZm9ybSB2ZWMzIHZMaWdodFNwZWN1bGFyMztcXG4jaWZkZWYgU0hBRE9XM1xcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb25Gcm9tTGlnaHQzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIzO1xcbiNlbmRpZlxcbiNpZmRlZiBTUE9UTElHSFQzXFxudW5pZm9ybSB2ZWM0IHZMaWdodERpcmVjdGlvbjM7XFxuI2VuZGlmXFxuI2lmZGVmIEhFTUlMSUdIVDNcXG51bmlmb3JtIHZlYzMgdkxpZ2h0R3JvdW5kMztcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbiNpZmRlZiBESUZGVVNFXFxudmFyeWluZyB2ZWMyIHZEaWZmdXNlVVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZEaWZmdXNlSW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFNQklFTlRcXG52YXJ5aW5nIHZlYzIgdkFtYmllbnRVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCBhbWJpZW50U2FtcGxlcjtcXG51bmlmb3JtIHZlYzIgdkFtYmllbnRJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVx0XFxudmFyeWluZyB2ZWMyIHZPcGFjaXR5VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgb3BhY2l0eVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIHZPcGFjaXR5SW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG52YXJ5aW5nIHZlYzMgdlJlZmxlY3Rpb25VVlc7XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSByZWZsZWN0aW9uQ3ViZVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgcmVmbGVjdGlvbjJEU2FtcGxlcjtcXG51bmlmb3JtIHZlYzMgdlJlZmxlY3Rpb25JbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRU1JU1NJVkVcXG52YXJ5aW5nIHZlYzIgdkVtaXNzaXZlVVY7XFxudW5pZm9ybSB2ZWMyIHZFbWlzc2l2ZUluZm9zO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlU2FtcGxlcjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgU1BFQ1VMQVJcXG52YXJ5aW5nIHZlYzIgdlNwZWN1bGFyVVY7XFxudW5pZm9ybSB2ZWMyIHZTcGVjdWxhckluZm9zO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyU2FtcGxlcjtcXG4jZW5kaWZcXG5cXG4vLyBTaGFkb3dzXFxuI2lmZGVmIFNIQURPV1NcXG5cXG5mbG9hdCB1bnBhY2sodmVjNCBjb2xvcilcXG57XFxuXHRjb25zdCB2ZWM0IGJpdFNoaWZ0ID0gdmVjNCgxLiAvICgyNTUuICogMjU1LiAqIDI1NS4pLCAxLiAvICgyNTUuICogMjU1LiksIDEuIC8gMjU1LiwgMS4pO1xcblx0cmV0dXJuIGRvdChjb2xvciwgYml0U2hpZnQpO1xcbn1cXG5cXG5mbG9hdCB1bnBhY2tIYWxmKHZlYzIgY29sb3IpXFxue1xcblx0cmV0dXJuIGNvbG9yLnggKyAoY29sb3IueSAvIDI1NS4wKTtcXG59XFxuXFxuZmxvYXQgY29tcHV0ZVNoYWRvdyh2ZWM0IHZQb3NpdGlvbkZyb21MaWdodCwgc2FtcGxlcjJEIHNoYWRvd1NhbXBsZXIpXFxue1xcblx0dmVjMyBkZXB0aCA9IHZQb3NpdGlvbkZyb21MaWdodC54eXogLyB2UG9zaXRpb25Gcm9tTGlnaHQudztcXG5cdHZlYzIgdXYgPSAwLjUgKiBkZXB0aC54eSArIHZlYzIoMC41LCAwLjUpO1xcblxcblx0aWYgKHV2LnggPCAwLiB8fCB1di54ID4gMS4wIHx8IHV2LnkgPCAwLiB8fCB1di55ID4gMS4wKVxcblx0e1xcblx0XHRyZXR1cm4gMS4wO1xcblx0fVxcblxcblx0ZmxvYXQgc2hhZG93ID0gdW5wYWNrKHRleHR1cmUyRChzaGFkb3dTYW1wbGVyLCB1dikpO1xcblxcblx0aWYgKGRlcHRoLnogPiBzaGFkb3cpXFxuXHR7XFxuXHRcdHJldHVybiAwLjtcXG5cdH1cXG5cdHJldHVybiAxLjtcXG59XFxuXFxuLy8gVGhhbmtzIHRvIGh0dHA6Ly9kZXZtYXN0ZXIubmV0L1xcbmZsb2F0IENoZWJ5Y2hldkluZXF1YWxpdHkodmVjMiBtb21lbnRzLCBmbG9hdCB0KVxcbntcXG5cdGlmICh0IDw9IG1vbWVudHMueClcXG5cdHtcXG5cdFx0cmV0dXJuIDEuMDtcXG5cdH1cXG5cXG5cdGZsb2F0IHZhcmlhbmNlID0gbW9tZW50cy55IC0gKG1vbWVudHMueCAqIG1vbWVudHMueCk7XFxuXHR2YXJpYW5jZSA9IG1heCh2YXJpYW5jZSwgMC4pO1xcblxcblx0ZmxvYXQgZCA9IHQgLSBtb21lbnRzLng7XFxuXHRyZXR1cm4gdmFyaWFuY2UgLyAodmFyaWFuY2UgKyBkICogZCk7XFxufVxcblxcbmZsb2F0IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0LCBzYW1wbGVyMkQgc2hhZG93U2FtcGxlcilcXG57XFxuXHR2ZWMzIGRlcHRoID0gdlBvc2l0aW9uRnJvbUxpZ2h0Lnh5eiAvIHZQb3NpdGlvbkZyb21MaWdodC53O1xcblx0dmVjMiB1diA9IDAuNSAqIGRlcHRoLnh5ICsgdmVjMigwLjUsIDAuNSk7XFxuXFxuXHRpZiAodXYueCA8IDAuIHx8IHV2LnggPiAxLjAgfHwgdXYueSA8IDAuIHx8IHV2LnkgPiAxLjApXFxuXHR7XFxuXHRcdHJldHVybiAxLjA7XFxuXHR9XFxuXFxuXHR2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHNoYWRvd1NhbXBsZXIsIHV2KTtcXG5cXG5cdHZlYzIgbW9tZW50cyA9IHZlYzIodW5wYWNrSGFsZih0ZXhlbC54eSksIHVucGFja0hhbGYodGV4ZWwuencpKTtcXG5cdHJldHVybiBjbGFtcCgxLjMgLSBDaGVieWNoZXZJbmVxdWFsaXR5KG1vbWVudHMsIGRlcHRoLnopLCAwLiwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXFxuI2lmZGVmIENMSVBQTEFORVxcbnZhcnlpbmcgZmxvYXQgZkNsaXBEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG4vLyBGb2dcXG4jaWZkZWYgRk9HXFxuXFxuI2RlZmluZSBGT0dNT0RFX05PTkUgICAgMC5cXG4jZGVmaW5lIEZPR01PREVfRVhQICAgICAxLlxcbiNkZWZpbmUgRk9HTU9ERV9FWFAyICAgIDIuXFxuI2RlZmluZSBGT0dNT0RFX0xJTkVBUiAgMy5cXG4jZGVmaW5lIEUgMi43MTgyOFxcblxcbnVuaWZvcm0gdmVjNCB2Rm9nSW5mb3M7XFxudW5pZm9ybSB2ZWMzIHZGb2dDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IGZGb2dEaXN0YW5jZTtcXG5cXG5mbG9hdCBDYWxjRm9nRmFjdG9yKClcXG57XFxuXHRmbG9hdCBmb2dDb2VmZiA9IDEuMDtcXG5cdGZsb2F0IGZvZ1N0YXJ0ID0gdkZvZ0luZm9zLnk7XFxuXHRmbG9hdCBmb2dFbmQgPSB2Rm9nSW5mb3MuejtcXG5cdGZsb2F0IGZvZ0RlbnNpdHkgPSB2Rm9nSW5mb3MudztcXG5cXG5cdGlmIChGT0dNT0RFX0xJTkVBUiA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAoZm9nRW5kIC0gZkZvZ0Rpc3RhbmNlKSAvIChmb2dFbmQgLSBmb2dTdGFydCk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUCA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAxLjAgLyBwb3coRSwgZkZvZ0Rpc3RhbmNlICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUDIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5KTtcXG5cdH1cXG5cXG5cdHJldHVybiBjbGFtcChmb2dDb2VmZiwgMC4wLCAxLjApO1xcbn1cXG4jZW5kaWZcXG5cXG4vLyBMaWdodCBDb21wdXRpbmdcXG5tYXQzIGNvbXB1dGVMaWdodGluZyh2ZWMzIHZpZXdEaXJlY3Rpb25XLCB2ZWMzIHZOb3JtYWwsIHZlYzQgbGlnaHREYXRhLCB2ZWM0IGRpZmZ1c2VDb2xvciwgdmVjMyBzcGVjdWxhckNvbG9yKSB7XFxuXHRtYXQzIHJlc3VsdDtcXG5cXG5cdHZlYzMgbGlnaHRWZWN0b3JXO1xcblx0aWYgKGxpZ2h0RGF0YS53ID09IDAuKVxcblx0e1xcblx0XHRsaWdodFZlY3RvclcgPSBub3JtYWxpemUobGlnaHREYXRhLnh5eiAtIHZQb3NpdGlvblcpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHRsaWdodFZlY3RvclcgPSBub3JtYWxpemUoLWxpZ2h0RGF0YS54eXopO1xcblx0fVxcblxcblx0Ly8gZGlmZnVzZVxcblx0ZmxvYXQgbmRsID0gbWF4KDAuLCBkb3Qodk5vcm1hbCwgbGlnaHRWZWN0b3JXKSk7XFxuXFxuXHQvLyBTcGVjdWxhclxcblx0dmVjMyBhbmdsZVcgPSBub3JtYWxpemUodmlld0RpcmVjdGlvblcgKyBsaWdodFZlY3RvclcpO1xcblx0ZmxvYXQgc3BlY0NvbXAgPSBtYXgoMC4sIGRvdCh2Tm9ybWFsLCBhbmdsZVcpKTtcXG5cdHNwZWNDb21wID0gbWF4KDAuLCBwb3coc3BlY0NvbXAsIG1heCgxLjAsIHZTcGVjdWxhckNvbG9yLmEpKSk7XFxuXFxuXHRyZXN1bHRbMF0gPSBuZGwgKiBkaWZmdXNlQ29sb3IucmdiO1xcblx0cmVzdWx0WzFdID0gc3BlY0NvbXAgKiBzcGVjdWxhckNvbG9yO1xcblx0cmVzdWx0WzJdID0gdmVjMygwLik7XFxuXFxuXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5tYXQzIGNvbXB1dGVTcG90TGlnaHRpbmcodmVjMyB2aWV3RGlyZWN0aW9uVywgdmVjMyB2Tm9ybWFsLCB2ZWM0IGxpZ2h0RGF0YSwgdmVjNCBsaWdodERpcmVjdGlvbiwgdmVjNCBkaWZmdXNlQ29sb3IsIHZlYzMgc3BlY3VsYXJDb2xvcikge1xcblx0bWF0MyByZXN1bHQ7XFxuXFxuXHR2ZWMzIGxpZ2h0VmVjdG9yVyA9IG5vcm1hbGl6ZShsaWdodERhdGEueHl6IC0gdlBvc2l0aW9uVyk7XFxuXFxuXHQvLyBkaWZmdXNlXFxuXHRmbG9hdCBjb3NBbmdsZSA9IG1heCgwLiwgZG90KC1saWdodERpcmVjdGlvbi54eXosIGxpZ2h0VmVjdG9yVykpO1xcblx0ZmxvYXQgc3BvdEF0dGVuID0gMC4wO1xcblxcblx0aWYgKGNvc0FuZ2xlID49IGxpZ2h0RGlyZWN0aW9uLncpXFxuXHR7XFxuXHRcdGNvc0FuZ2xlID0gbWF4KDAuLCBwb3coY29zQW5nbGUsIGxpZ2h0RGF0YS53KSk7XFxuXHRcdHNwb3RBdHRlbiA9IG1heCgwLiwgKGNvc0FuZ2xlIC0gbGlnaHREaXJlY3Rpb24udykgLyAoMS4gLSBjb3NBbmdsZSkpO1xcblxcblx0XHQvLyBEaWZmdXNlXFxuXHRcdGZsb2F0IG5kbCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIC1saWdodERpcmVjdGlvbi54eXopKTtcXG5cXG5cdFx0Ly8gU3BlY3VsYXJcXG5cdFx0dmVjMyBhbmdsZVcgPSBub3JtYWxpemUodmlld0RpcmVjdGlvblcgLSBsaWdodERpcmVjdGlvbi54eXopO1xcblx0XHRmbG9hdCBzcGVjQ29tcCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGFuZ2xlVykpO1xcblx0XHRzcGVjQ29tcCA9IHBvdyhzcGVjQ29tcCwgdlNwZWN1bGFyQ29sb3IuYSk7XFxuXFxuXHRcdHJlc3VsdFswXSA9IG5kbCAqIHNwb3RBdHRlbiAqIGRpZmZ1c2VDb2xvci5yZ2I7XFxuXHRcdHJlc3VsdFsxXSA9IHNwZWNDb21wICogc3BlY3VsYXJDb2xvciAqIHNwb3RBdHRlbjtcXG5cdFx0cmVzdWx0WzJdID0gdmVjMygwLik7XFxuXFxuXHRcdHJldHVybiByZXN1bHQ7XFxuXHR9XFxuXFxuXHRyZXN1bHRbMF0gPSB2ZWMzKDAuKTtcXG5cdHJlc3VsdFsxXSA9IHZlYzMoMC4pO1xcblx0cmVzdWx0WzJdID0gdmVjMygwLik7XFxuXFxuXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5tYXQzIGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZlYzMgdmlld0RpcmVjdGlvblcsIHZlYzMgdk5vcm1hbCwgdmVjNCBsaWdodERhdGEsIHZlYzQgZGlmZnVzZUNvbG9yLCB2ZWMzIHNwZWN1bGFyQ29sb3IsIHZlYzMgZ3JvdW5kQ29sb3IpIHtcXG5cdG1hdDMgcmVzdWx0O1xcblxcblx0Ly8gRGlmZnVzZVxcblx0ZmxvYXQgbmRsID0gZG90KHZOb3JtYWwsIGxpZ2h0RGF0YS54eXopICogMC41ICsgMC41O1xcblxcblx0Ly8gU3BlY3VsYXJcXG5cdHZlYzMgYW5nbGVXID0gbm9ybWFsaXplKHZpZXdEaXJlY3Rpb25XICsgbGlnaHREYXRhLnh5eik7XFxuXHRmbG9hdCBzcGVjQ29tcCA9IG1heCgwLiwgZG90KHZOb3JtYWwsIGFuZ2xlVykpO1xcblx0c3BlY0NvbXAgPSBwb3coc3BlY0NvbXAsIHZTcGVjdWxhckNvbG9yLmEpO1xcblxcblx0cmVzdWx0WzBdID0gbWl4KGdyb3VuZENvbG9yLCBkaWZmdXNlQ29sb3IucmdiLCBuZGwpO1xcblx0cmVzdWx0WzFdID0gc3BlY0NvbXAgKiBzcGVjdWxhckNvbG9yO1xcblx0cmVzdWx0WzJdID0gdmVjMygwLik7XFxuXFxuXHRyZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0Ly8gQ2xpcCBwbGFuZVxcbiNpZmRlZiBDTElQUExBTkVcXG5cdGlmIChmQ2xpcERpc3RhbmNlID4gMC4wKVxcblx0XHRkaXNjYXJkO1xcbiNlbmRpZlxcblxcblx0dmVjMyB2aWV3RGlyZWN0aW9uVyA9IG5vcm1hbGl6ZSh2RXllUG9zaXRpb24gLSB2UG9zaXRpb25XKTtcXG5cXG5cdC8vIEJhc2UgY29sb3JcXG5cdHZlYzQgYmFzZUNvbG9yID0gdmVjNCgxLiwgMS4sIDEuLCAxLik7XFxuXHR2ZWMzIGRpZmZ1c2VDb2xvciA9IHZEaWZmdXNlQ29sb3IucmdiO1xcblxcbiNpZmRlZiBWRVJURVhDT0xPUlxcblx0ZGlmZnVzZUNvbG9yICo9IHZDb2xvcjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRElGRlVTRVxcblx0YmFzZUNvbG9yID0gdGV4dHVyZTJEKGRpZmZ1c2VTYW1wbGVyLCB2RGlmZnVzZVVWKTtcXG5cXG4jaWZkZWYgQUxQSEFURVNUXFxuXHRpZiAoYmFzZUNvbG9yLmEgPCAwLjQpXFxuXHRcdGRpc2NhcmQ7XFxuI2VuZGlmXFxuXFxuXHRiYXNlQ29sb3IucmdiICo9IHZEaWZmdXNlSW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cdC8vIEJ1bXBcXG5cdHZlYzMgbm9ybWFsVyA9IG5vcm1hbGl6ZSh2Tm9ybWFsVyk7XFxuXFxuXHQvLyBBbWJpZW50IGNvbG9yXFxuXHR2ZWMzIGJhc2VBbWJpZW50Q29sb3IgPSB2ZWMzKDEuLCAxLiwgMS4pO1xcblxcbiNpZmRlZiBBTUJJRU5UXFxuXHRiYXNlQW1iaWVudENvbG9yID0gdGV4dHVyZTJEKGFtYmllbnRTYW1wbGVyLCB2QW1iaWVudFVWKS5yZ2IgKiB2QW1iaWVudEluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBMaWdodGluZ1xcblx0dmVjMyBkaWZmdXNlQmFzZSA9IHZlYzMoMC4sIDAuLCAwLik7XFxuXHR2ZWMzIHNwZWN1bGFyQmFzZSA9IHZlYzMoMC4sIDAuLCAwLik7XFxuXHRmbG9hdCBzaGFkb3cgPSAxLjtcXG5cXG4jaWZkZWYgTElHSFQwXFxuI2lmZGVmIFNQT1RMSUdIVDBcXG5cdG1hdDMgaW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaXJlY3Rpb24wLCB2TGlnaHREaWZmdXNlMCwgdkxpZ2h0U3BlY3VsYXIwKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMFxcblx0bWF0MyBpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEwLCB2TGlnaHREaWZmdXNlMCwgdkxpZ2h0U3BlY3VsYXIwLCB2TGlnaHRHcm91bmQwKTtcXG4jZW5kaWZcXG4jaWZkZWYgUE9JTlRESVJMSUdIVDBcXG5cdG1hdDMgaW5mbyA9IGNvbXB1dGVMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTAsIHZMaWdodERpZmZ1c2UwLCB2TGlnaHRTcGVjdWxhcjApO1xcbiNlbmRpZlxcbiNpZmRlZiBTSEFET1cwXFxuI2lmZGVmIFNIQURPV1ZTTTBcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3dXaXRoVlNNKHZQb3NpdGlvbkZyb21MaWdodDAsIHNoYWRvd1NhbXBsZXIwKTtcXG4jZWxzZVxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvdyh2UG9zaXRpb25Gcm9tTGlnaHQwLCBzaGFkb3dTYW1wbGVyMCk7XFxuI2VuZGlmXFxuI2Vsc2VcXG5cdHNoYWRvdyA9IDEuO1xcbiNlbmRpZlxcblx0ZGlmZnVzZUJhc2UgKz0gaW5mb1swXSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvWzFdICogc2hhZG93O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDFcXG4jaWZkZWYgU1BPVExJR0hUMVxcblx0aW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGExLCB2TGlnaHREaXJlY3Rpb24xLCB2TGlnaHREaWZmdXNlMSwgdkxpZ2h0U3BlY3VsYXIxKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUMVxcblx0aW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlmZnVzZTEsIHZMaWdodFNwZWN1bGFyMSwgdkxpZ2h0R3JvdW5kMSk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQxXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMSwgdkxpZ2h0RGlmZnVzZTEsIHZMaWdodFNwZWN1bGFyMSk7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzFcXG4jaWZkZWYgU0hBRE9XVlNNMVxcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0MSwgc2hhZG93U2FtcGxlcjEpO1xcbiNlbHNlXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDEsIHNoYWRvd1NhbXBsZXIxKTtcXG4jZW5kaWZcXG4jZWxzZVxcblx0c2hhZG93ID0gMS47XFxuI2VuZGlmXFxuXHRkaWZmdXNlQmFzZSArPSBpbmZvWzBdICogc2hhZG93O1xcblx0c3BlY3VsYXJCYXNlICs9IGluZm9bMV0gKiBzaGFkb3c7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIExJR0hUMlxcbiNpZmRlZiBTUE9UTElHSFQyXFxuXHRpbmZvID0gY29tcHV0ZVNwb3RMaWdodGluZyh2aWV3RGlyZWN0aW9uVywgbm9ybWFsVywgdkxpZ2h0RGF0YTIsIHZMaWdodERpcmVjdGlvbjIsIHZMaWdodERpZmZ1c2UyLCB2TGlnaHRTcGVjdWxhcjIpO1xcbiNlbmRpZlxcbiNpZmRlZiBIRU1JTElHSFQyXFxuXHRpbmZvID0gY29tcHV0ZUhlbWlzcGhlcmljTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaWZmdXNlMiwgdkxpZ2h0U3BlY3VsYXIyLCB2TGlnaHRHcm91bmQyKTtcXG4jZW5kaWZcXG4jaWZkZWYgUE9JTlRESVJMSUdIVDJcXG5cdGluZm8gPSBjb21wdXRlTGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEyLCB2TGlnaHREaWZmdXNlMiwgdkxpZ2h0U3BlY3VsYXIyKTtcXG4jZW5kaWZcXG4jaWZkZWYgU0hBRE9XMlxcbiNpZmRlZiBTSEFET1dWU00yXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93V2l0aFZTTSh2UG9zaXRpb25Gcm9tTGlnaHQyLCBzaGFkb3dTYW1wbGVyMik7XFxuI2Vsc2VcXG5cdHNoYWRvdyA9IGNvbXB1dGVTaGFkb3codlBvc2l0aW9uRnJvbUxpZ2h0Miwgc2hhZG93U2FtcGxlcjIpO1xcbiNlbmRpZlx0XFxuI2Vsc2VcXG5cdHNoYWRvdyA9IDEuO1xcbiNlbmRpZlxcblx0ZGlmZnVzZUJhc2UgKz0gaW5mb1swXSAqIHNoYWRvdztcXG5cdHNwZWN1bGFyQmFzZSArPSBpbmZvWzFdICogc2hhZG93O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBMSUdIVDNcXG4jaWZkZWYgU1BPVExJR0hUM1xcblx0aW5mbyA9IGNvbXB1dGVTcG90TGlnaHRpbmcodmlld0RpcmVjdGlvblcsIG5vcm1hbFcsIHZMaWdodERhdGEzLCB2TGlnaHREaXJlY3Rpb24zLCB2TGlnaHREaWZmdXNlMywgdkxpZ2h0U3BlY3VsYXIzKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEVNSUxJR0hUM1xcblx0aW5mbyA9IGNvbXB1dGVIZW1pc3BoZXJpY0xpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMywgdkxpZ2h0RGlmZnVzZTMsIHZMaWdodFNwZWN1bGFyMywgdkxpZ2h0R3JvdW5kMyk7XFxuI2VuZGlmXFxuI2lmZGVmIFBPSU5URElSTElHSFQzXFxuXHRpbmZvID0gY29tcHV0ZUxpZ2h0aW5nKHZpZXdEaXJlY3Rpb25XLCBub3JtYWxXLCB2TGlnaHREYXRhMywgdkxpZ2h0RGlmZnVzZTMsIHZMaWdodFNwZWN1bGFyMyk7XFxuI2VuZGlmXFxuI2lmZGVmIFNIQURPVzNcXG4jaWZkZWYgU0hBRE9XVlNNM1xcblx0c2hhZG93ID0gY29tcHV0ZVNoYWRvd1dpdGhWU00odlBvc2l0aW9uRnJvbUxpZ2h0Mywgc2hhZG93U2FtcGxlcjMpO1xcbiNlbHNlXFxuXHRzaGFkb3cgPSBjb21wdXRlU2hhZG93KHZQb3NpdGlvbkZyb21MaWdodDMsIHNoYWRvd1NhbXBsZXIzKTtcXG4jZW5kaWZcdFxcbiNlbHNlXFxuXHRzaGFkb3cgPSAxLjtcXG4jZW5kaWZcXG5cdGRpZmZ1c2VCYXNlICs9IGluZm9bMF0gKiBzaGFkb3c7XFxuXHRzcGVjdWxhckJhc2UgKz0gaW5mb1sxXSAqIHNoYWRvdztcXG4jZW5kaWZcXG5cXG5cdC8vIFJlZmxlY3Rpb25cXG5cdHZlYzMgcmVmbGVjdGlvbkNvbG9yID0gdmVjMygwLiwgMC4sIDAuKTtcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcblx0aWYgKHZSZWZsZWN0aW9uSW5mb3MueiAhPSAwLjApXFxuXHR7XFxuXHRcdHJlZmxlY3Rpb25Db2xvciA9IHRleHR1cmVDdWJlKHJlZmxlY3Rpb25DdWJlU2FtcGxlciwgdlJlZmxlY3Rpb25VVlcpLnJnYiAqIHZSZWZsZWN0aW9uSW5mb3MueTtcXG5cdH1cXG5cdGVsc2VcXG5cdHtcXG5cdFx0dmVjMiBjb29yZHMgPSB2UmVmbGVjdGlvblVWVy54eTtcXG5cXG5cdFx0aWYgKHZSZWZsZWN0aW9uSW5mb3MueCA9PSBNQVBfUFJPSkVDVElPTilcXG5cdFx0e1xcblx0XHRcdGNvb3JkcyAvPSB2UmVmbGVjdGlvblVWVy56O1xcblx0XHR9XFxuXFxuXHRcdGNvb3Jkcy55ID0gMS4wIC0gY29vcmRzLnk7XFxuXFxuXHRcdHJlZmxlY3Rpb25Db2xvciA9IHRleHR1cmUyRChyZWZsZWN0aW9uMkRTYW1wbGVyLCBjb29yZHMpLnJnYiAqIHZSZWZsZWN0aW9uSW5mb3MueTtcXG5cdH1cXG4jZW5kaWZcXG5cXG5cdC8vIEFscGhhXFxuXHRmbG9hdCBhbHBoYSA9IHZEaWZmdXNlQ29sb3IuYTtcXG5cXG4jaWZkZWYgT1BBQ0lUWVxcblx0dmVjNCBvcGFjaXR5TWFwID0gdGV4dHVyZTJEKG9wYWNpdHlTYW1wbGVyLCB2T3BhY2l0eVVWKTtcXG4jaWZkZWYgT1BBQ0lUWVJHQlxcblx0b3BhY2l0eU1hcC5yZ2IgPSBvcGFjaXR5TWFwLnJnYiAqIHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG5cdGFscGhhICo9IChvcGFjaXR5TWFwLnggKyBvcGFjaXR5TWFwLnkgKyBvcGFjaXR5TWFwLnopKiB2T3BhY2l0eUluZm9zLnk7XFxuI2Vsc2VcXG5cdGFscGhhICo9IG9wYWNpdHlNYXAuYSAqIHZPcGFjaXR5SW5mb3MueTtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG5cdC8vIEVtaXNzaXZlXFxuXHR2ZWMzIGVtaXNzaXZlQ29sb3IgPSB2RW1pc3NpdmVDb2xvcjtcXG4jaWZkZWYgRU1JU1NJVkVcXG5cdGVtaXNzaXZlQ29sb3IgKz0gdGV4dHVyZTJEKGVtaXNzaXZlU2FtcGxlciwgdkVtaXNzaXZlVVYpLnJnYiAqIHZFbWlzc2l2ZUluZm9zLnk7XFxuI2VuZGlmXFxuXFxuXHQvLyBTcGVjdWxhciBtYXBcXG5cdHZlYzMgc3BlY3VsYXJDb2xvciA9IHZTcGVjdWxhckNvbG9yLnJnYjtcXG4jaWZkZWYgU1BFQ1VMQVJcXG5cdHNwZWN1bGFyQ29sb3IgPSB0ZXh0dXJlMkQoc3BlY3VsYXJTYW1wbGVyLCB2U3BlY3VsYXJVVikucmdiICogdlNwZWN1bGFySW5mb3MueTtcXG4jZW5kaWZcXG5cXG5cdC8vIENvbXBvc2l0aW9uXFxuXHR2ZWMzIGZpbmFsRGlmZnVzZSA9IGNsYW1wKGRpZmZ1c2VCYXNlICogZGlmZnVzZUNvbG9yICsgZW1pc3NpdmVDb2xvciArIHZBbWJpZW50Q29sb3IsIDAuMCwgMS4wKSAqIGJhc2VDb2xvci5yZ2I7XFxuXHR2ZWMzIGZpbmFsU3BlY3VsYXIgPSBzcGVjdWxhckJhc2UgKiBzcGVjdWxhckNvbG9yO1xcblxcblx0dmVjNCBjb2xvciA9IHZlYzQoZmluYWxEaWZmdXNlICogYmFzZUFtYmllbnRDb2xvciArIGZpbmFsU3BlY3VsYXIgKyByZWZsZWN0aW9uQ29sb3IsIGFscGhhKTtcXG5cXG4jaWZkZWYgRk9HXFxuXHRmbG9hdCBmb2cgPSBDYWxjRm9nRmFjdG9yKCk7XFxuXHRjb2xvci5yZ2IgPSBmb2cgKiBjb2xvci5yZ2IgKyAoMS4wIC0gZm9nKSAqIHZGb2dDb2xvcjtcXG4jZW5kaWZcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIixsZWdhY3lkZWZhdWx0VmVydGV4U2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuI2RlZmluZSBNQVBfRVhQTElDSVRcdDAuXFxuI2RlZmluZSBNQVBfU1BIRVJJQ0FMXHQxLlxcbiNkZWZpbmUgTUFQX1BMQU5BUlx0XHQyLlxcbiNkZWZpbmUgTUFQX0NVQklDXHRcdDMuXFxuI2RlZmluZSBNQVBfUFJPSkVDVElPTlx0NC5cXG4jZGVmaW5lIE1BUF9TS1lCT1hcdFx0NS5cXG5cXG4vLyBBdHRyaWJ1dGVzXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzMgbm9ybWFsO1xcbiNpZmRlZiBVVjFcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG4jZW5kaWZcXG4jaWZkZWYgVVYyXFxuYXR0cmlidXRlIHZlYzIgdXYyO1xcbiNlbmRpZlxcbiNpZmRlZiBWRVJURVhDT0xPUlxcbmF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBCT05FU1xcbmF0dHJpYnV0ZSB2ZWM0IG1hdHJpY2VzSW5kaWNlcztcXG5hdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc1dlaWdodHM7XFxuI2VuZGlmXFxuXFxuLy8gVW5pZm9ybXNcXG51bmlmb3JtIG1hdDQgd29ybGQ7XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qZWN0aW9uO1xcblxcbiNpZmRlZiBESUZGVVNFXFxudmFyeWluZyB2ZWMyIHZEaWZmdXNlVVY7XFxudW5pZm9ybSBtYXQ0IGRpZmZ1c2VNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHZEaWZmdXNlSW5mb3M7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFNQklFTlRcXG52YXJ5aW5nIHZlYzIgdkFtYmllbnRVVjtcXG51bmlmb3JtIG1hdDQgYW1iaWVudE1hdHJpeDtcXG51bmlmb3JtIHZlYzIgdkFtYmllbnRJbmZvcztcXG4jZW5kaWZcXG5cXG4jaWZkZWYgT1BBQ0lUWVxcbnZhcnlpbmcgdmVjMiB2T3BhY2l0eVVWO1xcbnVuaWZvcm0gbWF0NCBvcGFjaXR5TWF0cml4O1xcbnVuaWZvcm0gdmVjMiB2T3BhY2l0eUluZm9zO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBSRUZMRUNUSU9OXFxudW5pZm9ybSB2ZWMzIHZFeWVQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdlJlZmxlY3Rpb25VVlc7XFxudW5pZm9ybSB2ZWMzIHZSZWZsZWN0aW9uSW5mb3M7XFxudW5pZm9ybSBtYXQ0IHJlZmxlY3Rpb25NYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEVNSVNTSVZFXFxudmFyeWluZyB2ZWMyIHZFbWlzc2l2ZVVWO1xcbnVuaWZvcm0gdmVjMiB2RW1pc3NpdmVJbmZvcztcXG51bmlmb3JtIG1hdDQgZW1pc3NpdmVNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNQRUNVTEFSXFxudmFyeWluZyB2ZWMyIHZTcGVjdWxhclVWO1xcbnVuaWZvcm0gdmVjMiB2U3BlY3VsYXJJbmZvcztcXG51bmlmb3JtIG1hdDQgc3BlY3VsYXJNYXRyaXg7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJVTVBcXG52YXJ5aW5nIHZlYzIgdkJ1bXBVVjtcXG51bmlmb3JtIHZlYzIgdkJ1bXBJbmZvcztcXG51bmlmb3JtIG1hdDQgYnVtcE1hdHJpeDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQk9ORVNcXG51bmlmb3JtIG1hdDQgbUJvbmVzW0JvbmVzUGVyTWVzaF07XFxuI2VuZGlmXFxuXFxuLy8gT3V0cHV0XFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvblc7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWxXO1xcblxcbiNpZmRlZiBWRVJURVhDT0xPUlxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIENMSVBQTEFORVxcbnVuaWZvcm0gdmVjNCB2Q2xpcFBsYW5lO1xcbnZhcnlpbmcgZmxvYXQgZkNsaXBEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRk9HXFxudmFyeWluZyBmbG9hdCBmRm9nRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFNIQURPV1NcXG4jaWZkZWYgTElHSFQwXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MDtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MDtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQxXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MTtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MTtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQyXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MjtcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MjtcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQzXFxudW5pZm9ybSBtYXQ0IGxpZ2h0TWF0cml4MztcXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uRnJvbUxpZ2h0MztcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgUkVGTEVDVElPTlxcbnZlYzMgY29tcHV0ZVJlZmxlY3Rpb25Db29yZHMoZmxvYXQgbW9kZSwgdmVjNCB3b3JsZFBvcywgdmVjMyB3b3JsZE5vcm1hbClcXG57XFxuXHRpZiAobW9kZSA9PSBNQVBfU1BIRVJJQ0FMKVxcblx0e1xcblx0XHR2ZWMzIGNvb3JkcyA9IHZlYzModmlldyAqIHZlYzQod29ybGROb3JtYWwsIDAuMCkpO1xcblxcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogdmVjNChjb29yZHMsIDEuMCkpO1xcblx0fVxcblx0ZWxzZSBpZiAobW9kZSA9PSBNQVBfUExBTkFSKVxcblx0e1xcblx0XHR2ZWMzIHZpZXdEaXIgPSB3b3JsZFBvcy54eXogLSB2RXllUG9zaXRpb247XFxuXHRcdHZlYzMgY29vcmRzID0gbm9ybWFsaXplKHJlZmxlY3Qodmlld0Rpciwgd29ybGROb3JtYWwpKTtcXG5cXG5cdFx0cmV0dXJuIHZlYzMocmVmbGVjdGlvbk1hdHJpeCAqIHZlYzQoY29vcmRzLCAxKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9DVUJJQylcXG5cdHtcXG5cdFx0dmVjMyB2aWV3RGlyID0gd29ybGRQb3MueHl6IC0gdkV5ZVBvc2l0aW9uO1xcblx0XHR2ZWMzIGNvb3JkcyA9IHJlZmxlY3Qodmlld0Rpciwgd29ybGROb3JtYWwpO1xcblxcblx0XHRyZXR1cm4gdmVjMyhyZWZsZWN0aW9uTWF0cml4ICogdmVjNChjb29yZHMsIDApKTtcXG5cdH1cXG5cdGVsc2UgaWYgKG1vZGUgPT0gTUFQX1BST0pFQ1RJT04pXFxuXHR7XFxuXHRcdHJldHVybiB2ZWMzKHJlZmxlY3Rpb25NYXRyaXggKiAodmlldyAqIHdvcmxkUG9zKSk7XFxuXHR9XFxuXHRlbHNlIGlmIChtb2RlID09IE1BUF9TS1lCT1gpXFxuXHR7XFxuXHRcdHJldHVybiBwb3NpdGlvbjtcXG5cdH1cXG5cXG5cdHJldHVybiB2ZWMzKDAsIDAsIDApO1xcbn1cXG4jZW5kaWZcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0bWF0NCBmaW5hbFdvcmxkO1xcblxcbiNpZmRlZiBCT05FU1xcblx0bWF0NCBtMCA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLngpXSAqIG1hdHJpY2VzV2VpZ2h0cy54O1xcblx0bWF0NCBtMSA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnkpXSAqIG1hdHJpY2VzV2VpZ2h0cy55O1xcblx0bWF0NCBtMiA9IG1Cb25lc1tpbnQobWF0cmljZXNJbmRpY2VzLnopXSAqIG1hdHJpY2VzV2VpZ2h0cy56O1xcblxcbiNpZmRlZiBCT05FUzRcXG5cdG1hdDQgbTMgPSBtQm9uZXNbaW50KG1hdHJpY2VzSW5kaWNlcy53KV0gKiBtYXRyaWNlc1dlaWdodHMudztcXG5cdGZpbmFsV29ybGQgPSB3b3JsZCAqIChtMCArIG0xICsgbTIgKyBtMyk7XFxuI2Vsc2VcXG5cdGZpbmFsV29ybGQgPSB3b3JsZCAqIChtMCArIG0xICsgbTIpO1xcbiNlbmRpZiBcXG5cXG4jZWxzZVxcblx0ZmluYWxXb3JsZCA9IHdvcmxkO1xcbiNlbmRpZlxcblxcblx0Z2xfUG9zaXRpb24gPSB2aWV3UHJvamVjdGlvbiAqIGZpbmFsV29ybGQgKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcblx0dmVjNCB3b3JsZFBvcyA9IGZpbmFsV29ybGQgKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblx0dlBvc2l0aW9uVyA9IHZlYzMod29ybGRQb3MpO1xcblx0dk5vcm1hbFcgPSBub3JtYWxpemUodmVjMyhmaW5hbFdvcmxkICogdmVjNChub3JtYWwsIDAuMCkpKTtcXG5cXG5cdC8vIFRleHR1cmUgY29vcmRpbmF0ZXNcXG4jaWZuZGVmIFVWMVxcblx0dmVjMiB1diA9IHZlYzIoMC4sIDAuKTtcXG4jZW5kaWZcXG4jaWZuZGVmIFVWMlxcblx0dmVjMiB1djIgPSB2ZWMyKDAuLCAwLik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIERJRkZVU0VcXG5cdGlmICh2RGlmZnVzZUluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZEaWZmdXNlVVYgPSB2ZWMyKGRpZmZ1c2VNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2RGlmZnVzZVVWID0gdmVjMihkaWZmdXNlTWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFNQklFTlRcXG5cdGlmICh2QW1iaWVudEluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZBbWJpZW50VVYgPSB2ZWMyKGFtYmllbnRNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2QW1iaWVudFVWID0gdmVjMihhbWJpZW50TWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE9QQUNJVFlcXG5cdGlmICh2T3BhY2l0eUluZm9zLnggPT0gMC4pXFxuXHR7XFxuXHRcdHZPcGFjaXR5VVYgPSB2ZWMyKG9wYWNpdHlNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2T3BhY2l0eVVWID0gdmVjMihvcGFjaXR5TWF0cml4ICogdmVjNCh1djIsIDEuMCwgMC4wKSk7XFxuXHR9XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFJFRkxFQ1RJT05cXG5cdHZSZWZsZWN0aW9uVVZXID0gY29tcHV0ZVJlZmxlY3Rpb25Db29yZHModlJlZmxlY3Rpb25JbmZvcy54LCB2ZWM0KHZQb3NpdGlvblcsIDEuMCksIHZOb3JtYWxXKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgRU1JU1NJVkVcXG5cdGlmICh2RW1pc3NpdmVJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2RW1pc3NpdmVVViA9IHZlYzIoZW1pc3NpdmVNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2RW1pc3NpdmVVViA9IHZlYzIoZW1pc3NpdmVNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgU1BFQ1VMQVJcXG5cdGlmICh2U3BlY3VsYXJJbmZvcy54ID09IDAuKVxcblx0e1xcblx0XHR2U3BlY3VsYXJVViA9IHZlYzIoc3BlY3VsYXJNYXRyaXggKiB2ZWM0KHV2LCAxLjAsIDAuMCkpO1xcblx0fVxcblx0ZWxzZVxcblx0e1xcblx0XHR2U3BlY3VsYXJVViA9IHZlYzIoc3BlY3VsYXJNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG4jaWZkZWYgQlVNUFxcblx0aWYgKHZCdW1wSW5mb3MueCA9PSAwLilcXG5cdHtcXG5cdFx0dkJ1bXBVViA9IHZlYzIoYnVtcE1hdHJpeCAqIHZlYzQodXYsIDEuMCwgMC4wKSk7XFxuXHR9XFxuXHRlbHNlXFxuXHR7XFxuXHRcdHZCdW1wVVYgPSB2ZWMyKGJ1bXBNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG5cdH1cXG4jZW5kaWZcXG5cXG5cdC8vIENsaXAgcGxhbmVcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHRmQ2xpcERpc3RhbmNlID0gZG90KHdvcmxkUG9zLCB2Q2xpcFBsYW5lKTtcXG4jZW5kaWZcXG5cXG5cdC8vIEZvZ1xcbiNpZmRlZiBGT0dcXG5cdGZGb2dEaXN0YW5jZSA9ICh2aWV3ICogd29ybGRQb3MpLno7XFxuI2VuZGlmXFxuXFxuXHQvLyBTaGFkb3dzXFxuI2lmZGVmIFNIQURPV1NcXG4jaWZkZWYgTElHSFQwXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQwID0gbGlnaHRNYXRyaXgwICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2lmZGVmIExJR0hUMVxcblx0dlBvc2l0aW9uRnJvbUxpZ2h0MSA9IGxpZ2h0TWF0cml4MSAqIHdvcmxkUG9zO1xcbiNlbmRpZlxcbiNpZmRlZiBMSUdIVDJcXG5cdHZQb3NpdGlvbkZyb21MaWdodDIgPSBsaWdodE1hdHJpeDIgKiB3b3JsZFBvcztcXG4jZW5kaWZcXG4jaWZkZWYgTElHSFQzXFxuXHR2UG9zaXRpb25Gcm9tTGlnaHQzID0gbGlnaHRNYXRyaXgzICogd29ybGRQb3M7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuXHQvLyBWZXJ0ZXggY29sb3JcXG4jaWZkZWYgVkVSVEVYQ09MT1JcXG5cdHZDb2xvciA9IGNvbG9yO1xcbiNlbmRpZlxcbn1cIixsZW5zRmxhcmVQaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG5cXG4vLyBDb2xvclxcbnVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblx0dmVjNCBiYXNlQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHZVVik7XFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBiYXNlQ29sb3IgKiBjb2xvcjtcXG59XCIsbGVuc0ZsYXJlVmVydGV4U2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gQXR0cmlidXRlc1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcbi8vIFVuaWZvcm1zXFxudW5pZm9ybSBtYXQ0IHZpZXdwb3J0TWF0cml4O1xcblxcbi8vIE91dHB1dFxcbnZhcnlpbmcgdmVjMiB2VVY7XFxuXFxuY29uc3QgdmVjMiBtYWRkID0gdmVjMigwLjUsIDAuNSk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcdFxcblxcblx0dlVWID0gcG9zaXRpb24gKiBtYWRkICsgbWFkZDtcXG5cdGdsX1Bvc2l0aW9uID0gdmlld3BvcnRNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XFxufVwiLG9jdWx1c0Rpc3RvcnRpb25Db3JyZWN0aW9uUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMyIExlbnNDZW50ZXI7XFxudW5pZm9ybSB2ZWMyIFNjYWxlO1xcbnVuaWZvcm0gdmVjMiBTY2FsZUluO1xcbnVuaWZvcm0gdmVjNCBIbWRXYXJwUGFyYW07XFxuXFxudmVjMiBIbWRXYXJwKHZlYzIgaW4wMSkge1xcblxcblx0dmVjMiB0aGV0YSA9IChpbjAxIC0gTGVuc0NlbnRlcikgKiBTY2FsZUluOyAvLyBTY2FsZXMgdG8gWy0xLCAxXVxcblx0ZmxvYXQgclNxID0gdGhldGEueCAqIHRoZXRhLnggKyB0aGV0YS55ICogdGhldGEueTtcXG5cdHZlYzIgcnZlY3RvciA9IHRoZXRhICogKEhtZFdhcnBQYXJhbS54ICsgSG1kV2FycFBhcmFtLnkgKiByU3EgKyBIbWRXYXJwUGFyYW0ueiAqIHJTcSAqIHJTcSArIEhtZFdhcnBQYXJhbS53ICogclNxICogclNxICogclNxKTtcXG5cdHJldHVybiBMZW5zQ2VudGVyICsgU2NhbGUgKiBydmVjdG9yO1xcbn1cXG5cXG5cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuXHR2ZWMyIHRjID0gSG1kV2FycCh2VVYpO1xcblx0aWYgKHRjLnggPDAuMCB8fCB0Yy54PjEuMCB8fCB0Yy55PDAuMCB8fCB0Yy55PjEuMClcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcblx0ZWxzZXtcXG5cdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXh0dXJlMkQodGV4dHVyZVNhbXBsZXIsIHRjKS5yZ2IsIDEuMCk7XFxuXHR9XFxufVwiLHBhcnRpY2xlc1BpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gU2FtcGxlcnNcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudW5pZm9ybSB2ZWM0IHRleHR1cmVNYXNrO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VTYW1wbGVyO1xcblxcbiNpZmRlZiBDTElQUExBTkVcXG52YXJ5aW5nIGZsb2F0IGZDbGlwRGlzdGFuY2U7XFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHRpZiAoZkNsaXBEaXN0YW5jZSA+IDAuMClcXG5cdFx0ZGlzY2FyZDtcXG4jZW5kaWZcXG5cdHZlYzQgYmFzZUNvbG9yID0gdGV4dHVyZTJEKGRpZmZ1c2VTYW1wbGVyLCB2VVYpO1xcblxcblx0Z2xfRnJhZ0NvbG9yID0gKGJhc2VDb2xvciAqIHRleHR1cmVNYXNrICsgKHZlYzQoMS4sIDEuLCAxLiwgMS4pIC0gdGV4dHVyZU1hc2spKSAqIHZDb2xvcjtcXG59XCIscGFydGljbGVzVmVydGV4U2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxuLy8gQXR0cmlidXRlc1xcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0IG9wdGlvbnM7XFxuXFxuLy8gVW5pZm9ybXNcXG51bmlmb3JtIG1hdDQgdmlldztcXG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbjtcXG5cXG4vLyBPdXRwdXRcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuI2lmZGVmIENMSVBQTEFORVxcbnVuaWZvcm0gdmVjNCB2Q2xpcFBsYW5lO1xcbnVuaWZvcm0gbWF0NCBpbnZWaWV3O1xcbnZhcnlpbmcgZmxvYXQgZkNsaXBEaXN0YW5jZTtcXG4jZW5kaWZcXG5cXG52b2lkIG1haW4odm9pZCkge1x0XFxuXHR2ZWMzIHZpZXdQb3MgPSAodmlldyAqIHZlYzQocG9zaXRpb24sIDEuMCkpLnh5ejsgXFxuXHR2ZWMzIGNvcm5lclBvcztcXG5cdGZsb2F0IHNpemUgPSBvcHRpb25zLnk7XFxuXHRmbG9hdCBhbmdsZSA9IG9wdGlvbnMueDtcXG5cdHZlYzIgb2Zmc2V0ID0gb3B0aW9ucy56dztcXG5cXG5cdGNvcm5lclBvcyA9IHZlYzMob2Zmc2V0LnggLSAwLjUsIG9mZnNldC55ICAtIDAuNSwgMC4pICogc2l6ZTtcXG5cXG5cdC8vIFJvdGF0ZVxcblx0dmVjMyByb3RhdGVkQ29ybmVyO1xcblx0cm90YXRlZENvcm5lci54ID0gY29ybmVyUG9zLnggKiBjb3MoYW5nbGUpIC0gY29ybmVyUG9zLnkgKiBzaW4oYW5nbGUpO1xcblx0cm90YXRlZENvcm5lci55ID0gY29ybmVyUG9zLnggKiBzaW4oYW5nbGUpICsgY29ybmVyUG9zLnkgKiBjb3MoYW5nbGUpO1xcblx0cm90YXRlZENvcm5lci56ID0gMC47XFxuXFxuXHQvLyBQb3NpdGlvblxcblx0dmlld1BvcyArPSByb3RhdGVkQ29ybmVyO1xcblx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogdmVjNCh2aWV3UG9zLCAxLjApOyAgIFxcblx0XFxuXHR2Q29sb3IgPSBjb2xvcjtcXG5cdHZVViA9IG9mZnNldDtcXG5cXG5cdC8vIENsaXAgcGxhbmVcXG4jaWZkZWYgQ0xJUFBMQU5FXFxuXHR2ZWM0IHdvcmxkUG9zID0gaW52VmlldyAqIHZlYzQodmlld1BvcywgMS4wKTtcXG5cdGZDbGlwRGlzdGFuY2UgPSBkb3Qod29ybGRQb3MsIHZDbGlwUGxhbmUpO1xcbiNlbmRpZlxcbn1cIixwYXNzUGl4ZWxTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBTYW1wbGVyc1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpIFxcbntcXG5cdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlU2FtcGxlciwgdlVWKTtcXG59XCIscG9zdHByb2Nlc3NWZXJ0ZXhTaGFkZXI6XCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4vLyBBdHRyaWJ1dGVzXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxuLy8gT3V0cHV0XFxudmFyeWluZyB2ZWMyIHZVVjtcXG5cXG5jb25zdCB2ZWMyIG1hZGQgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG52b2lkIG1haW4odm9pZCkge1x0XFxuXFxuXHR2VVYgPSBwb3NpdGlvbiAqIG1hZGQgKyBtYWRkO1xcblx0Z2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjAsIDEuMCk7XFxufVwiLHJlZnJhY3Rpb25QaXhlbFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCByZWZyYWN0aW9uU2FtcGxlcjtcXG5cXG4vLyBQYXJhbWV0ZXJzXFxudW5pZm9ybSB2ZWMzIGJhc2VDb2xvcjtcXG51bmlmb3JtIGZsb2F0IGRlcHRoO1xcbnVuaWZvcm0gZmxvYXQgY29sb3JMZXZlbDtcXG5cXG52b2lkIG1haW4oKSB7XFxuXHRmbG9hdCByZWYgPSAxLjAgLSB0ZXh0dXJlMkQocmVmcmFjdGlvblNhbXBsZXIsIHZVVikucjtcXG5cXG5cdHZlYzIgdXYgPSB2VVYgLSB2ZWMyKDAuNSk7XFxuXHR2ZWMyIG9mZnNldCA9IHV2ICogZGVwdGggKiByZWY7XFxuXHR2ZWMzIHNvdXJjZUNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmVTYW1wbGVyLCB2VVYgLSBvZmZzZXQpLnJnYjtcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoc291cmNlQ29sb3IgKyBzb3VyY2VDb2xvciAqIHJlZiAqIGNvbG9yTGV2ZWwsIDEuMCk7XFxufVwiLHNoYWRvd01hcFBpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmVjNCBwYWNrKGZsb2F0IGRlcHRoKVxcbntcXG5cdGNvbnN0IHZlYzQgYml0T2Zmc2V0ID0gdmVjNCgyNTUuICogMjU1LiAqIDI1NS4sIDI1NS4gKiAyNTUuLCAyNTUuLCAxLik7XFxuXHRjb25zdCB2ZWM0IGJpdE1hc2sgPSB2ZWM0KDAuLCAxLiAvIDI1NS4sIDEuIC8gMjU1LiwgMS4gLyAyNTUuKTtcXG5cdFxcblx0dmVjNCBjb21wID0gbW9kKGRlcHRoICogYml0T2Zmc2V0ICogdmVjNCgyNTQuKSwgdmVjNCgyNTUuKSkgLyB2ZWM0KDI1NC4pO1xcblx0Y29tcCAtPSBjb21wLnh4eXogKiBiaXRNYXNrO1xcblx0XFxuXHRyZXR1cm4gY29tcDtcXG59XFxuXFxuLy8gVGhhbmtzIHRvIGh0dHA6Ly9kZXZtYXN0ZXIubmV0L1xcbnZlYzIgcGFja0hhbGYoZmxvYXQgZGVwdGgpIFxcbnsgXFxuXHRjb25zdCB2ZWMyIGJpdE9mZnNldCA9IHZlYzIoMS4wIC8gMjU1LiwgMC4pO1xcblx0dmVjMiBjb2xvciA9IHZlYzIoZGVwdGgsIGZyYWN0KGRlcHRoICogMjU1LikpO1xcblxcblx0cmV0dXJuIGNvbG9yIC0gKGNvbG9yLnl5ICogYml0T2Zmc2V0KTtcXG59XFxuXFxuI2lmbmRlZiBWU01cXG52YXJ5aW5nIHZlYzQgdlBvc2l0aW9uO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTFBIQVRFU1RcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VTYW1wbGVyO1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4jaWZkZWYgQUxQSEFURVNUXFxuXHRpZiAodGV4dHVyZTJEKGRpZmZ1c2VTYW1wbGVyLCB2VVYpLmEgPCAwLjQpXFxuXHRcdGRpc2NhcmQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFZTTVxcblx0ZmxvYXQgbW9tZW50MSA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXHRmbG9hdCBtb21lbnQyID0gbW9tZW50MSAqIG1vbWVudDE7XFxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHBhY2tIYWxmKG1vbWVudDEpLCBwYWNrSGFsZihtb21lbnQyKSk7XFxuI2Vsc2VcXG5cdGdsX0ZyYWdDb2xvciA9IHBhY2sodlBvc2l0aW9uLnogLyB2UG9zaXRpb24udyk7XFxuI2VuZGlmXFxufVwiLHNoYWRvd01hcFZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZVxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbiNpZmRlZiBCT05FU1xcbmF0dHJpYnV0ZSB2ZWM0IG1hdHJpY2VzSW5kaWNlcztcXG5hdHRyaWJ1dGUgdmVjNCBtYXRyaWNlc1dlaWdodHM7XFxuI2VuZGlmXFxuXFxuLy8gVW5pZm9ybVxcbiNpZmRlZiBJTlNUQU5DRVNcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDA7XFxuYXR0cmlidXRlIHZlYzQgd29ybGQxO1xcbmF0dHJpYnV0ZSB2ZWM0IHdvcmxkMjtcXG5hdHRyaWJ1dGUgdmVjNCB3b3JsZDM7XFxuI2Vsc2VcXG51bmlmb3JtIG1hdDQgd29ybGQ7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qZWN0aW9uO1xcbiNpZmRlZiBCT05FU1xcbnVuaWZvcm0gbWF0NCBtQm9uZXNbQm9uZXNQZXJNZXNoXTtcXG4jZW5kaWZcXG5cXG4jaWZuZGVmIFZTTVxcbnZhcnlpbmcgdmVjNCB2UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEFMUEhBVEVTVFxcbnZhcnlpbmcgdmVjMiB2VVY7XFxudW5pZm9ybSBtYXQ0IGRpZmZ1c2VNYXRyaXg7XFxuI2lmZGVmIFVWMVxcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVVjJcXG5hdHRyaWJ1dGUgdmVjMiB1djI7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiNpZmRlZiBJTlNUQU5DRVNcXG5cdG1hdDQgZmluYWxXb3JsZCA9IG1hdDQod29ybGQwLCB3b3JsZDEsIHdvcmxkMiwgd29ybGQzKTtcXG4jZWxzZVxcblx0bWF0NCBmaW5hbFdvcmxkID0gd29ybGQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEJPTkVTXFxuXHRtYXQ0IG0wID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMueCldICogbWF0cmljZXNXZWlnaHRzLng7XFxuXHRtYXQ0IG0xID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMueSldICogbWF0cmljZXNXZWlnaHRzLnk7XFxuXHRtYXQ0IG0yID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMueildICogbWF0cmljZXNXZWlnaHRzLno7XFxuXHRtYXQ0IG0zID0gbUJvbmVzW2ludChtYXRyaWNlc0luZGljZXMudyldICogbWF0cmljZXNXZWlnaHRzLnc7XFxuXHRmaW5hbFdvcmxkID0gZmluYWxXb3JsZCAqIChtMCArIG0xICsgbTIgKyBtMyk7XFxuXHRnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qZWN0aW9uICogZmluYWxXb3JsZCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuI2Vsc2VcXG4jaWZuZGVmIFZTTVxcblx0dlBvc2l0aW9uID0gdmlld1Byb2plY3Rpb24gKiBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4jZW5kaWZcXG5cdGdsX1Bvc2l0aW9uID0gdmlld1Byb2plY3Rpb24gKiBmaW5hbFdvcmxkICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQUxQSEFURVNUXFxuI2lmZGVmIFVWMVxcblx0dlVWID0gdmVjMihkaWZmdXNlTWF0cml4ICogdmVjNCh1diwgMS4wLCAwLjApKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVYyXFxuXHR2VVYgPSB2ZWMyKGRpZmZ1c2VNYXRyaXggKiB2ZWM0KHV2MiwgMS4wLCAwLjApKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG59XCIsc3ByaXRlc1BpeGVsU2hhZGVyOlwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBib29sIGFscGhhVGVzdDtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbi8vIFNhbXBsZXJzXFxudmFyeWluZyB2ZWMyIHZVVjtcXG51bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlU2FtcGxlcjtcXG5cXG4vLyBGb2dcXG4jaWZkZWYgRk9HXFxuXFxuI2RlZmluZSBGT0dNT0RFX05PTkUgICAgMC5cXG4jZGVmaW5lIEZPR01PREVfRVhQICAgICAxLlxcbiNkZWZpbmUgRk9HTU9ERV9FWFAyICAgIDIuXFxuI2RlZmluZSBGT0dNT0RFX0xJTkVBUiAgMy5cXG4jZGVmaW5lIEUgMi43MTgyOFxcblxcbnVuaWZvcm0gdmVjNCB2Rm9nSW5mb3M7XFxudW5pZm9ybSB2ZWMzIHZGb2dDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IGZGb2dEaXN0YW5jZTtcXG5cXG5mbG9hdCBDYWxjRm9nRmFjdG9yKClcXG57XFxuXHRmbG9hdCBmb2dDb2VmZiA9IDEuMDtcXG5cdGZsb2F0IGZvZ1N0YXJ0ID0gdkZvZ0luZm9zLnk7XFxuXHRmbG9hdCBmb2dFbmQgPSB2Rm9nSW5mb3MuejtcXG5cdGZsb2F0IGZvZ0RlbnNpdHkgPSB2Rm9nSW5mb3MudztcXG5cXG5cdGlmIChGT0dNT0RFX0xJTkVBUiA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAoZm9nRW5kIC0gZkZvZ0Rpc3RhbmNlKSAvIChmb2dFbmQgLSBmb2dTdGFydCk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUCA9PSB2Rm9nSW5mb3MueClcXG5cdHtcXG5cdFx0Zm9nQ29lZmYgPSAxLjAgLyBwb3coRSwgZkZvZ0Rpc3RhbmNlICogZm9nRGVuc2l0eSk7XFxuXHR9XFxuXHRlbHNlIGlmIChGT0dNT0RFX0VYUDIgPT0gdkZvZ0luZm9zLngpXFxuXHR7XFxuXHRcdGZvZ0NvZWZmID0gMS4wIC8gcG93KEUsIGZGb2dEaXN0YW5jZSAqIGZGb2dEaXN0YW5jZSAqIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5KTtcXG5cdH1cXG5cXG5cdHJldHVybiBtaW4oMS4sIG1heCgwLiwgZm9nQ29lZmYpKTtcXG59XFxuI2VuZGlmXFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cdHZlYzQgYmFzZUNvbG9yID0gdGV4dHVyZTJEKGRpZmZ1c2VTYW1wbGVyLCB2VVYpO1xcblxcblx0aWYgKGFscGhhVGVzdCkgXFxuXHR7XFxuXHRcdGlmIChiYXNlQ29sb3IuYSA8IDAuOTUpXFxuXHRcdFx0ZGlzY2FyZDtcXG5cdH1cXG5cXG5cdGJhc2VDb2xvciAqPSB2Q29sb3I7XFxuXFxuI2lmZGVmIEZPR1xcblx0ZmxvYXQgZm9nID0gQ2FsY0ZvZ0ZhY3RvcigpO1xcblx0YmFzZUNvbG9yLnJnYiA9IGZvZyAqIGJhc2VDb2xvci5yZ2IgKyAoMS4wIC0gZm9nKSAqIHZGb2dDb2xvcjtcXG4jZW5kaWZcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGJhc2VDb2xvcjtcXG59XCIsc3ByaXRlc1ZlcnRleFNoYWRlcjpcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbi8vIEF0dHJpYnV0ZXNcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBvcHRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGNlbGxJbmZvO1xcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcblxcbi8vIFVuaWZvcm1zXFxudW5pZm9ybSB2ZWMyIHRleHR1cmVJbmZvcztcXG51bmlmb3JtIG1hdDQgdmlldztcXG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbjtcXG5cXG4vLyBPdXRwdXRcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxuI2lmZGVmIEZPR1xcbnZhcnlpbmcgZmxvYXQgZkZvZ0Rpc3RhbmNlO1xcbiNlbmRpZlxcblxcbnZvaWQgbWFpbih2b2lkKSB7XHRcXG5cdHZlYzMgdmlld1BvcyA9ICh2aWV3ICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6OyBcXG5cdHZlYzMgY29ybmVyUG9zO1xcblx0XFxuXHRmbG9hdCBhbmdsZSA9IG9wdGlvbnMueDtcXG5cdGZsb2F0IHNpemUgPSBvcHRpb25zLnk7XFxuXHR2ZWMyIG9mZnNldCA9IG9wdGlvbnMuenc7XFxuXHR2ZWMyIHV2U2NhbGUgPSB0ZXh0dXJlSW5mb3MueHk7XFxuXFxuXHRjb3JuZXJQb3MgPSB2ZWMzKG9mZnNldC54IC0gMC41LCBvZmZzZXQueSAgLSAwLjUsIDAuKSAqIHNpemU7XFxuXFxuXHQvLyBSb3RhdGVcXG5cdHZlYzMgcm90YXRlZENvcm5lcjtcXG5cdHJvdGF0ZWRDb3JuZXIueCA9IGNvcm5lclBvcy54ICogY29zKGFuZ2xlKSAtIGNvcm5lclBvcy55ICogc2luKGFuZ2xlKTtcXG5cdHJvdGF0ZWRDb3JuZXIueSA9IGNvcm5lclBvcy54ICogc2luKGFuZ2xlKSArIGNvcm5lclBvcy55ICogY29zKGFuZ2xlKTtcXG5cdHJvdGF0ZWRDb3JuZXIueiA9IDAuO1xcblxcblx0Ly8gUG9zaXRpb25cXG5cdHZpZXdQb3MgKz0gcm90YXRlZENvcm5lcjtcXG5cdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZlYzQodmlld1BvcywgMS4wKTsgICBcXG5cXG5cdC8vIENvbG9yXFxuXHR2Q29sb3IgPSBjb2xvcjtcXG5cdFxcblx0Ly8gVGV4dHVyZVxcblx0dmVjMiB1dk9mZnNldCA9IHZlYzIoYWJzKG9mZnNldC54IC0gY2VsbEluZm8ueCksIDEuMCAtIGFicyhvZmZzZXQueSAtIGNlbGxJbmZvLnkpKTtcXG5cXG5cdHZVViA9ICh1dk9mZnNldCArIGNlbGxJbmZvLnp3KSAqIHV2U2NhbGU7XFxuXFxuXHQvLyBGb2dcXG4jaWZkZWYgRk9HXFxuXHRmRm9nRGlzdGFuY2UgPSB2aWV3UG9zLno7XFxuI2VuZGlmXFxufVwifSxiXG59KCk7YS5FZmZlY3Q9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYixjKXt0aGlzLm5hbWU9YSx0aGlzLmNoZWNrUmVhZHlPbkV2ZXJ5Q2FsbD0hMCx0aGlzLmNoZWNrUmVhZHlPbmx5T25jZT0hMSx0aGlzLnN0YXRlPVwiXCIsdGhpcy5hbHBoYT0xLHRoaXMud2lyZWZyYW1lPSExLHRoaXMuYmFja0ZhY2VDdWxsaW5nPSEwLHRoaXMuX3dhc1ByZXZpb3VzbHlSZWFkeT0hMSx0aGlzLmlkPWEsdGhpcy5fc2NlbmU9YixjfHxiLm1hdGVyaWFscy5wdXNoKHRoaXMpfXJldHVybiBhLnByb3RvdHlwZS5pc1JlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGEucHJvdG90eXBlLmdldEVmZmVjdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lZmZlY3R9LGEucHJvdG90eXBlLmdldFNjZW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjZW5lfSxhLnByb3RvdHlwZS5uZWVkQWxwaGFCbGVuZGluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFscGhhPDF9LGEucHJvdG90eXBlLm5lZWRBbHBoYVRlc3Rpbmc9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sYS5wcm90b3R5cGUuZ2V0QWxwaGFUZXN0VGV4dHVyZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxhLnByb3RvdHlwZS50cmFja0NyZWF0aW9uPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5fcHJlQmluZD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2EuZW5hYmxlRWZmZWN0KHRoaXMuX2VmZmVjdCksYS5zZXRTdGF0ZSh0aGlzLmJhY2tGYWNlQ3VsbGluZyl9LGEucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLmJpbmRPbmx5V29ybGRNYXRyaXg9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLnVuYmluZD1mdW5jdGlvbigpe30sYS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9zY2VuZS5tYXRlcmlhbHMuaW5kZXhPZih0aGlzKTt0aGlzLl9zY2VuZS5tYXRlcmlhbHMuc3BsaWNlKGIsMSksYSYmdGhpcy5fZWZmZWN0JiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VFZmZlY3QodGhpcy5fZWZmZWN0KSx0aGlzLl9lZmZlY3Q9bnVsbCksdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCl9LGF9KCk7YS5NYXRlcmlhbD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9NCxjPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoYixkKXt2YXIgZT10aGlzO2MuY2FsbCh0aGlzLGIsZCksdGhpcy5hbWJpZW50Q29sb3I9bmV3IGEuQ29sb3IzKDAsMCwwKSx0aGlzLmRpZmZ1c2VDb2xvcj1uZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMuc3BlY3VsYXJDb2xvcj1uZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMuc3BlY3VsYXJQb3dlcj02NCx0aGlzLmVtaXNzaXZlQ29sb3I9bmV3IGEuQ29sb3IzKDAsMCwwKSx0aGlzLnVzZUFscGhhRnJvbURpZmZ1c2VUZXh0dXJlPSExLHRoaXMuX2NhY2hlZERlZmluZXM9bnVsbCx0aGlzLl9yZW5kZXJUYXJnZXRzPW5ldyBhLlNtYXJ0QXJyYXkoMTYpLHRoaXMuX3dvcmxkVmlld1Byb2plY3Rpb25NYXRyaXg9YS5NYXRyaXguWmVybygpLHRoaXMuX2dsb2JhbEFtYmllbnRDb2xvcj1uZXcgYS5Db2xvcjMoMCwwLDApLHRoaXMuX2Jhc2VDb2xvcj1uZXcgYS5Db2xvcjMsdGhpcy5fc2NhbGVkRGlmZnVzZT1uZXcgYS5Db2xvcjMsdGhpcy5fc2NhbGVkU3BlY3VsYXI9bmV3IGEuQ29sb3IzLHRoaXMuZ2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gZS5fcmVuZGVyVGFyZ2V0cy5yZXNldCgpLGUucmVmbGVjdGlvblRleHR1cmUmJmUucmVmbGVjdGlvblRleHR1cmUuaXNSZW5kZXJUYXJnZXQmJmUuX3JlbmRlclRhcmdldHMucHVzaChlLnJlZmxlY3Rpb25UZXh0dXJlKSxlLl9yZW5kZXJUYXJnZXRzfX1yZXR1cm4gX19leHRlbmRzKGQsYyksZC5wcm90b3R5cGUubmVlZEFscGhhQmxlbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbHBoYTwxfHxudWxsIT10aGlzLm9wYWNpdHlUZXh0dXJlfHx0aGlzLl9zaG91bGRVc2VBbHBoYUZyb21EaWZmdXNlVGV4dHVyZSgpfSxkLnByb3RvdHlwZS5uZWVkQWxwaGFUZXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZGlmZnVzZVRleHR1cmUmJnRoaXMuZGlmZnVzZVRleHR1cmUuaGFzQWxwaGEmJiF0aGlzLmRpZmZ1c2VUZXh0dXJlLmdldEFscGhhRnJvbVJHQn0sZC5wcm90b3R5cGUuX3Nob3VsZFVzZUFscGhhRnJvbURpZmZ1c2VUZXh0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZGlmZnVzZVRleHR1cmUmJnRoaXMuZGlmZnVzZVRleHR1cmUuaGFzQWxwaGEmJnRoaXMudXNlQWxwaGFGcm9tRGlmZnVzZVRleHR1cmV9LGQucHJvdG90eXBlLmdldEFscGhhVGVzdFRleHR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaWZmdXNlVGV4dHVyZX0sZC5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbihjLGQpe2lmKHRoaXMuY2hlY2tSZWFkeU9ubHlPbmNlJiZ0aGlzLl93YXNQcmV2aW91c2x5UmVhZHkpcmV0dXJuITA7dmFyIGU9dGhpcy5nZXRTY2VuZSgpO2lmKCF0aGlzLmNoZWNrUmVhZHlPbkV2ZXJ5Q2FsbCYmdGhpcy5fcmVuZGVySWQ9PT1lLmdldFJlbmRlcklkKCkpcmV0dXJuITA7dmFyIGY9ZS5nZXRFbmdpbmUoKSxnPVtdLGg9bmV3IEFycmF5O2lmKGUudGV4dHVyZXNFbmFibGVkKXtpZih0aGlzLmRpZmZ1c2VUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuRGlmZnVzZVRleHR1cmVFbmFibGVkKXtpZighdGhpcy5kaWZmdXNlVGV4dHVyZS5pc1JlYWR5KCkpcmV0dXJuITE7Zy5wdXNoKFwiI2RlZmluZSBESUZGVVNFXCIpfWlmKHRoaXMuYW1iaWVudFRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5BbWJpZW50VGV4dHVyZUVuYWJsZWQpe2lmKCF0aGlzLmFtYmllbnRUZXh0dXJlLmlzUmVhZHkoKSlyZXR1cm4hMTtnLnB1c2goXCIjZGVmaW5lIEFNQklFTlRcIil9aWYodGhpcy5vcGFjaXR5VGV4dHVyZSYmYS5TdGFuZGFyZE1hdGVyaWFsLk9wYWNpdHlUZXh0dXJlRW5hYmxlZCl7aWYoIXRoaXMub3BhY2l0eVRleHR1cmUuaXNSZWFkeSgpKXJldHVybiExO2cucHVzaChcIiNkZWZpbmUgT1BBQ0lUWVwiKSx0aGlzLm9wYWNpdHlUZXh0dXJlLmdldEFscGhhRnJvbVJHQiYmZy5wdXNoKFwiI2RlZmluZSBPUEFDSVRZUkdCXCIpfWlmKHRoaXMucmVmbGVjdGlvblRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5SZWZsZWN0aW9uVGV4dHVyZUVuYWJsZWQpe2lmKCF0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmlzUmVhZHkoKSlyZXR1cm4hMTtnLnB1c2goXCIjZGVmaW5lIFJFRkxFQ1RJT05cIil9aWYodGhpcy5lbWlzc2l2ZVRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5FbWlzc2l2ZVRleHR1cmVFbmFibGVkKXtpZighdGhpcy5lbWlzc2l2ZVRleHR1cmUuaXNSZWFkeSgpKXJldHVybiExO2cucHVzaChcIiNkZWZpbmUgRU1JU1NJVkVcIil9aWYodGhpcy5zcGVjdWxhclRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5TcGVjdWxhclRleHR1cmVFbmFibGVkKXtpZighdGhpcy5zcGVjdWxhclRleHR1cmUuaXNSZWFkeSgpKXJldHVybiExO2cucHVzaChcIiNkZWZpbmUgU1BFQ1VMQVJcIiksaC5wdXNoKGdbZy5sZW5ndGgtMV0pfX1pZihlLmdldEVuZ2luZSgpLmdldENhcHMoKS5zdGFuZGFyZERlcml2YXRpdmVzJiZ0aGlzLmJ1bXBUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuQnVtcFRleHR1cmVFbmFibGVkKXtpZighdGhpcy5idW1wVGV4dHVyZS5pc1JlYWR5KCkpcmV0dXJuITE7Zy5wdXNoKFwiI2RlZmluZSBCVU1QXCIpLGgucHVzaChnW2cubGVuZ3RoLTFdKX1lLmNsaXBQbGFuZSYmZy5wdXNoKFwiI2RlZmluZSBDTElQUExBTkVcIiksZi5nZXRBbHBoYVRlc3RpbmcoKSYmZy5wdXNoKFwiI2RlZmluZSBBTFBIQVRFU1RcIiksdGhpcy5fc2hvdWxkVXNlQWxwaGFGcm9tRGlmZnVzZVRleHR1cmUoKSYmZy5wdXNoKFwiI2RlZmluZSBBTFBIQUZST01ESUZGVVNFXCIpLGUuZm9nTW9kZSE9PWEuU2NlbmUuRk9HTU9ERV9OT05FJiYoZy5wdXNoKFwiI2RlZmluZSBGT0dcIiksaC5wdXNoKGdbZy5sZW5ndGgtMV0pKTt2YXIgaT0hMSxqPTA7aWYoZS5saWdodHNFbmFibGVkKWZvcih2YXIgaz0wO2s8ZS5saWdodHMubGVuZ3RoO2srKyl7dmFyIGw9ZS5saWdodHNba107aWYobC5pc0VuYWJsZWQoKSl7aWYobC5fZXhjbHVkZWRNZXNoZXNJZHMubGVuZ3RoPjApe2Zvcih2YXIgbT0wO208bC5fZXhjbHVkZWRNZXNoZXNJZHMubGVuZ3RoO20rKyl7dmFyIG49ZS5nZXRNZXNoQnlJRChsLl9leGNsdWRlZE1lc2hlc0lkc1ttXSk7biYmbC5leGNsdWRlZE1lc2hlcy5wdXNoKG4pfWwuX2V4Y2x1ZGVkTWVzaGVzSWRzPVtdfWlmKCFjfHwtMT09PWwuZXhjbHVkZWRNZXNoZXMuaW5kZXhPZihjKSl7Zy5wdXNoKFwiI2RlZmluZSBMSUdIVFwiK2opLGo+MCYmaC5wdXNoKGdbZy5sZW5ndGgtMV0pO3ZhciBvO289bCBpbnN0YW5jZW9mIGEuU3BvdExpZ2h0P1wiI2RlZmluZSBTUE9UTElHSFRcIitqOmwgaW5zdGFuY2VvZiBhLkhlbWlzcGhlcmljTGlnaHQ/XCIjZGVmaW5lIEhFTUlMSUdIVFwiK2o6XCIjZGVmaW5lIFBPSU5URElSTElHSFRcIitqLGcucHVzaChvKSxqPjAmJmgucHVzaChnW2cubGVuZ3RoLTFdKTt2YXIgcD1sLmdldFNoYWRvd0dlbmVyYXRvcigpO2lmKGMmJmMucmVjZWl2ZVNoYWRvd3MmJnAmJihnLnB1c2goXCIjZGVmaW5lIFNIQURPV1wiK2opLGo+MCYmaC5wdXNoKGdbZy5sZW5ndGgtMV0pLGl8fChnLnB1c2goXCIjZGVmaW5lIFNIQURPV1NcIiksaT0hMCkscC51c2VWYXJpYW5jZVNoYWRvd01hcCYmKGcucHVzaChcIiNkZWZpbmUgU0hBRE9XVlNNXCIraiksaj4wJiZoLnB1c2goZ1tnLmxlbmd0aC0xXSkpLHAudXNlUG9pc3NvblNhbXBsaW5nJiYoZy5wdXNoKFwiI2RlZmluZSBTSEFET1dQQ0ZcIitqKSxqPjAmJmgucHVzaChnW2cubGVuZ3RoLTFdKSkpLGorKyxqPT1iKWJyZWFrfX19dmFyIHE9W2EuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCxhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kXTtjJiYoYy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSYmKHEucHVzaChhLlZlcnRleEJ1ZmZlci5VVktpbmQpLGcucHVzaChcIiNkZWZpbmUgVVYxXCIpKSxjLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSYmKHEucHVzaChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSxnLnB1c2goXCIjZGVmaW5lIFVWMlwiKSksYy5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSYmKHEucHVzaChhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpLGcucHVzaChcIiNkZWZpbmUgVkVSVEVYQ09MT1JcIikpLGMuc2tlbGV0b24mJmMuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpJiZjLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSYmKHEucHVzaChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSxxLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCksZy5wdXNoKFwiI2RlZmluZSBCT05FU1wiKSxnLnB1c2goXCIjZGVmaW5lIEJvbmVzUGVyTWVzaCBcIisoYy5za2VsZXRvbi5ib25lcy5sZW5ndGgrMSkpLGcucHVzaChcIiNkZWZpbmUgQk9ORVM0XCIpLGgucHVzaChnW2cubGVuZ3RoLTFdKSksZCYmKGcucHVzaChcIiNkZWZpbmUgSU5TVEFOQ0VTXCIpLHEucHVzaChcIndvcmxkMFwiKSxxLnB1c2goXCJ3b3JsZDFcIikscS5wdXNoKFwid29ybGQyXCIpLHEucHVzaChcIndvcmxkM1wiKSkpO3ZhciByPWcuam9pbihcIlxcblwiKTtpZih0aGlzLl9jYWNoZWREZWZpbmVzIT1yKXt0aGlzLl9jYWNoZWREZWZpbmVzPXI7dmFyIHM9XCJkZWZhdWx0XCI7ZS5nZXRFbmdpbmUoKS5nZXRDYXBzKCkuc3RhbmRhcmREZXJpdmF0aXZlc3x8KHM9XCJsZWdhY3lkZWZhdWx0XCIpLHRoaXMuX2VmZmVjdD1lLmdldEVuZ2luZSgpLmNyZWF0ZUVmZmVjdChzLHEsW1wid29ybGRcIixcInZpZXdcIixcInZpZXdQcm9qZWN0aW9uXCIsXCJ2RXllUG9zaXRpb25cIixcInZMaWdodHNUeXBlXCIsXCJ2QW1iaWVudENvbG9yXCIsXCJ2RGlmZnVzZUNvbG9yXCIsXCJ2U3BlY3VsYXJDb2xvclwiLFwidkVtaXNzaXZlQ29sb3JcIixcInZMaWdodERhdGEwXCIsXCJ2TGlnaHREaWZmdXNlMFwiLFwidkxpZ2h0U3BlY3VsYXIwXCIsXCJ2TGlnaHREaXJlY3Rpb24wXCIsXCJ2TGlnaHRHcm91bmQwXCIsXCJsaWdodE1hdHJpeDBcIixcInZMaWdodERhdGExXCIsXCJ2TGlnaHREaWZmdXNlMVwiLFwidkxpZ2h0U3BlY3VsYXIxXCIsXCJ2TGlnaHREaXJlY3Rpb24xXCIsXCJ2TGlnaHRHcm91bmQxXCIsXCJsaWdodE1hdHJpeDFcIixcInZMaWdodERhdGEyXCIsXCJ2TGlnaHREaWZmdXNlMlwiLFwidkxpZ2h0U3BlY3VsYXIyXCIsXCJ2TGlnaHREaXJlY3Rpb24yXCIsXCJ2TGlnaHRHcm91bmQyXCIsXCJsaWdodE1hdHJpeDJcIixcInZMaWdodERhdGEzXCIsXCJ2TGlnaHREaWZmdXNlM1wiLFwidkxpZ2h0U3BlY3VsYXIzXCIsXCJ2TGlnaHREaXJlY3Rpb24zXCIsXCJ2TGlnaHRHcm91bmQzXCIsXCJsaWdodE1hdHJpeDNcIixcInZGb2dJbmZvc1wiLFwidkZvZ0NvbG9yXCIsXCJ2RGlmZnVzZUluZm9zXCIsXCJ2QW1iaWVudEluZm9zXCIsXCJ2T3BhY2l0eUluZm9zXCIsXCJ2UmVmbGVjdGlvbkluZm9zXCIsXCJ2RW1pc3NpdmVJbmZvc1wiLFwidlNwZWN1bGFySW5mb3NcIixcInZCdW1wSW5mb3NcIixcIm1Cb25lc1wiLFwidkNsaXBQbGFuZVwiLFwiZGlmZnVzZU1hdHJpeFwiLFwiYW1iaWVudE1hdHJpeFwiLFwib3BhY2l0eU1hdHJpeFwiLFwicmVmbGVjdGlvbk1hdHJpeFwiLFwiZW1pc3NpdmVNYXRyaXhcIixcInNwZWN1bGFyTWF0cml4XCIsXCJidW1wTWF0cml4XCIsXCJkYXJrbmVzczBcIixcImRhcmtuZXNzMVwiLFwiZGFya25lc3MyXCIsXCJkYXJrbmVzczNcIl0sW1wiZGlmZnVzZVNhbXBsZXJcIixcImFtYmllbnRTYW1wbGVyXCIsXCJvcGFjaXR5U2FtcGxlclwiLFwicmVmbGVjdGlvbkN1YmVTYW1wbGVyXCIsXCJyZWZsZWN0aW9uMkRTYW1wbGVyXCIsXCJlbWlzc2l2ZVNhbXBsZXJcIixcInNwZWN1bGFyU2FtcGxlclwiLFwiYnVtcFNhbXBsZXJcIixcInNoYWRvd1NhbXBsZXIwXCIsXCJzaGFkb3dTYW1wbGVyMVwiLFwic2hhZG93U2FtcGxlcjJcIixcInNoYWRvd1NhbXBsZXIzXCJdLHIsaCx0aGlzLm9uQ29tcGlsZWQsdGhpcy5vbkVycm9yKX1yZXR1cm4gdGhpcy5fZWZmZWN0LmlzUmVhZHkoKT8odGhpcy5fcmVuZGVySWQ9ZS5nZXRSZW5kZXJJZCgpLHRoaXMuX3dhc1ByZXZpb3VzbHlSZWFkeT0hMCwhMCk6ITF9LGQucHJvdG90eXBlLnVuYmluZD1mdW5jdGlvbigpe3RoaXMucmVmbGVjdGlvblRleHR1cmUmJnRoaXMucmVmbGVjdGlvblRleHR1cmUuaXNSZW5kZXJUYXJnZXQmJnRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwicmVmbGVjdGlvbjJEU2FtcGxlclwiLG51bGwpfSxkLnByb3RvdHlwZS5iaW5kT25seVdvcmxkTWF0cml4PWZ1bmN0aW9uKGEpe3RoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJ3b3JsZFwiLGEpfSxkLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKGMsZCl7dmFyIGU9dGhpcy5nZXRTY2VuZSgpO2lmKHRoaXMuX2Jhc2VDb2xvci5jb3B5RnJvbSh0aGlzLmRpZmZ1c2VDb2xvciksdGhpcy5iaW5kT25seVdvcmxkTWF0cml4KGMpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJ2aWV3UHJvamVjdGlvblwiLGUuZ2V0VHJhbnNmb3JtTWF0cml4KCkpLGQuc2tlbGV0b24mJmQuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpJiZkLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSYmdGhpcy5fZWZmZWN0LnNldE1hdHJpY2VzKFwibUJvbmVzXCIsZC5za2VsZXRvbi5nZXRUcmFuc2Zvcm1NYXRyaWNlcygpKSx0aGlzLmRpZmZ1c2VUZXh0dXJlJiZhLlN0YW5kYXJkTWF0ZXJpYWwuRGlmZnVzZVRleHR1cmVFbmFibGVkJiYodGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJkaWZmdXNlU2FtcGxlclwiLHRoaXMuZGlmZnVzZVRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdDIoXCJ2RGlmZnVzZUluZm9zXCIsdGhpcy5kaWZmdXNlVGV4dHVyZS5jb29yZGluYXRlc0luZGV4LHRoaXMuZGlmZnVzZVRleHR1cmUubGV2ZWwpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJkaWZmdXNlTWF0cml4XCIsdGhpcy5kaWZmdXNlVGV4dHVyZS5nZXRUZXh0dXJlTWF0cml4KCkpLHRoaXMuX2Jhc2VDb2xvci5jb3B5RnJvbUZsb2F0cygxLDEsMSkpLHRoaXMuYW1iaWVudFRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5BbWJpZW50VGV4dHVyZUVuYWJsZWQmJih0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcImFtYmllbnRTYW1wbGVyXCIsdGhpcy5hbWJpZW50VGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MihcInZBbWJpZW50SW5mb3NcIix0aGlzLmFtYmllbnRUZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXgsdGhpcy5hbWJpZW50VGV4dHVyZS5sZXZlbCksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcImFtYmllbnRNYXRyaXhcIix0aGlzLmFtYmllbnRUZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSkpLHRoaXMub3BhY2l0eVRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5PcGFjaXR5VGV4dHVyZUVuYWJsZWQmJih0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcIm9wYWNpdHlTYW1wbGVyXCIsdGhpcy5vcGFjaXR5VGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MihcInZPcGFjaXR5SW5mb3NcIix0aGlzLm9wYWNpdHlUZXh0dXJlLmNvb3JkaW5hdGVzSW5kZXgsdGhpcy5vcGFjaXR5VGV4dHVyZS5sZXZlbCksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcIm9wYWNpdHlNYXRyaXhcIix0aGlzLm9wYWNpdHlUZXh0dXJlLmdldFRleHR1cmVNYXRyaXgoKSkpLHRoaXMucmVmbGVjdGlvblRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5SZWZsZWN0aW9uVGV4dHVyZUVuYWJsZWQmJih0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmlzQ3ViZT90aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcInJlZmxlY3Rpb25DdWJlU2FtcGxlclwiLHRoaXMucmVmbGVjdGlvblRleHR1cmUpOnRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwicmVmbGVjdGlvbjJEU2FtcGxlclwiLHRoaXMucmVmbGVjdGlvblRleHR1cmUpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJyZWZsZWN0aW9uTWF0cml4XCIsdGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5nZXRSZWZsZWN0aW9uVGV4dHVyZU1hdHJpeCgpKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQzKFwidlJlZmxlY3Rpb25JbmZvc1wiLHRoaXMucmVmbGVjdGlvblRleHR1cmUuY29vcmRpbmF0ZXNNb2RlLHRoaXMucmVmbGVjdGlvblRleHR1cmUubGV2ZWwsdGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5pc0N1YmU/MTowKSksdGhpcy5lbWlzc2l2ZVRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5FbWlzc2l2ZVRleHR1cmVFbmFibGVkJiYodGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJlbWlzc2l2ZVNhbXBsZXJcIix0aGlzLmVtaXNzaXZlVGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MihcInZFbWlzc2l2ZUluZm9zXCIsdGhpcy5lbWlzc2l2ZVRleHR1cmUuY29vcmRpbmF0ZXNJbmRleCx0aGlzLmVtaXNzaXZlVGV4dHVyZS5sZXZlbCksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcImVtaXNzaXZlTWF0cml4XCIsdGhpcy5lbWlzc2l2ZVRleHR1cmUuZ2V0VGV4dHVyZU1hdHJpeCgpKSksdGhpcy5zcGVjdWxhclRleHR1cmUmJmEuU3RhbmRhcmRNYXRlcmlhbC5TcGVjdWxhclRleHR1cmVFbmFibGVkJiYodGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJzcGVjdWxhclNhbXBsZXJcIix0aGlzLnNwZWN1bGFyVGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldEZsb2F0MihcInZTcGVjdWxhckluZm9zXCIsdGhpcy5zcGVjdWxhclRleHR1cmUuY29vcmRpbmF0ZXNJbmRleCx0aGlzLnNwZWN1bGFyVGV4dHVyZS5sZXZlbCksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcInNwZWN1bGFyTWF0cml4XCIsdGhpcy5zcGVjdWxhclRleHR1cmUuZ2V0VGV4dHVyZU1hdHJpeCgpKSksdGhpcy5idW1wVGV4dHVyZSYmZS5nZXRFbmdpbmUoKS5nZXRDYXBzKCkuc3RhbmRhcmREZXJpdmF0aXZlcyYmYS5TdGFuZGFyZE1hdGVyaWFsLkJ1bXBUZXh0dXJlRW5hYmxlZCYmKHRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKFwiYnVtcFNhbXBsZXJcIix0aGlzLmJ1bXBUZXh0dXJlKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQyKFwidkJ1bXBJbmZvc1wiLHRoaXMuYnVtcFRleHR1cmUuY29vcmRpbmF0ZXNJbmRleCx0aGlzLmJ1bXBUZXh0dXJlLmxldmVsKSx0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwiYnVtcE1hdHJpeFwiLHRoaXMuYnVtcFRleHR1cmUuZ2V0VGV4dHVyZU1hdHJpeCgpKSksZS5hbWJpZW50Q29sb3IubXVsdGlwbHlUb1JlZih0aGlzLmFtYmllbnRDb2xvcix0aGlzLl9nbG9iYWxBbWJpZW50Q29sb3IpLHRoaXMuX2VmZmVjdC5zZXRWZWN0b3IzKFwidkV5ZVBvc2l0aW9uXCIsZS5hY3RpdmVDYW1lcmEucG9zaXRpb24pLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjMoXCJ2QW1iaWVudENvbG9yXCIsdGhpcy5fZ2xvYmFsQW1iaWVudENvbG9yKSx0aGlzLl9lZmZlY3Quc2V0Q29sb3I0KFwidkRpZmZ1c2VDb2xvclwiLHRoaXMuX2Jhc2VDb2xvcix0aGlzLmFscGhhKmQudmlzaWJpbGl0eSksdGhpcy5fZWZmZWN0LnNldENvbG9yNChcInZTcGVjdWxhckNvbG9yXCIsdGhpcy5zcGVjdWxhckNvbG9yLHRoaXMuc3BlY3VsYXJQb3dlciksdGhpcy5fZWZmZWN0LnNldENvbG9yMyhcInZFbWlzc2l2ZUNvbG9yXCIsdGhpcy5lbWlzc2l2ZUNvbG9yKSxlLmxpZ2h0c0VuYWJsZWQpZm9yKHZhciBmPTAsZz0wO2c8ZS5saWdodHMubGVuZ3RoO2crKyl7dmFyIGg9ZS5saWdodHNbZ107aWYoaC5pc0VuYWJsZWQoKSYmKCFkfHwtMT09PWguZXhjbHVkZWRNZXNoZXMuaW5kZXhPZihkKSkpe2ggaW5zdGFuY2VvZiBhLlBvaW50TGlnaHQ/aC50cmFuc2ZlclRvRWZmZWN0KHRoaXMuX2VmZmVjdCxcInZMaWdodERhdGFcIitmKTpoIGluc3RhbmNlb2YgYS5EaXJlY3Rpb25hbExpZ2h0P2gudHJhbnNmZXJUb0VmZmVjdCh0aGlzLl9lZmZlY3QsXCJ2TGlnaHREYXRhXCIrZik6aCBpbnN0YW5jZW9mIGEuU3BvdExpZ2h0P2gudHJhbnNmZXJUb0VmZmVjdCh0aGlzLl9lZmZlY3QsXCJ2TGlnaHREYXRhXCIrZixcInZMaWdodERpcmVjdGlvblwiK2YpOmggaW5zdGFuY2VvZiBhLkhlbWlzcGhlcmljTGlnaHQmJmgudHJhbnNmZXJUb0VmZmVjdCh0aGlzLl9lZmZlY3QsXCJ2TGlnaHREYXRhXCIrZixcInZMaWdodEdyb3VuZFwiK2YpLGguZGlmZnVzZS5zY2FsZVRvUmVmKGguaW50ZW5zaXR5LHRoaXMuX3NjYWxlZERpZmZ1c2UpLGguc3BlY3VsYXIuc2NhbGVUb1JlZihoLmludGVuc2l0eSx0aGlzLl9zY2FsZWRTcGVjdWxhciksdGhpcy5fZWZmZWN0LnNldENvbG9yNChcInZMaWdodERpZmZ1c2VcIitmLHRoaXMuX3NjYWxlZERpZmZ1c2UsaC5yYW5nZSksdGhpcy5fZWZmZWN0LnNldENvbG9yMyhcInZMaWdodFNwZWN1bGFyXCIrZix0aGlzLl9zY2FsZWRTcGVjdWxhcik7dmFyIGk9aC5nZXRTaGFkb3dHZW5lcmF0b3IoKTtpZihkLnJlY2VpdmVTaGFkb3dzJiZpJiYodGhpcy5fZWZmZWN0LnNldE1hdHJpeChcImxpZ2h0TWF0cml4XCIrZixpLmdldFRyYW5zZm9ybU1hdHJpeCgpKSx0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcInNoYWRvd1NhbXBsZXJcIitmLGkuZ2V0U2hhZG93TWFwKCkpLHRoaXMuX2VmZmVjdC5zZXRGbG9hdChcImRhcmtuZXNzXCIrZixpLmdldERhcmtuZXNzKCkpKSxmKyssZj09YilicmVha319aWYoZS5jbGlwUGxhbmUpe3ZhciBqPWUuY2xpcFBsYW5lO3RoaXMuX2VmZmVjdC5zZXRGbG9hdDQoXCJ2Q2xpcFBsYW5lXCIsai5ub3JtYWwueCxqLm5vcm1hbC55LGoubm9ybWFsLnosai5kKX0oZS5mb2dNb2RlIT09YS5TY2VuZS5GT0dNT0RFX05PTkV8fHRoaXMucmVmbGVjdGlvblRleHR1cmUpJiZ0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwidmlld1wiLGUuZ2V0Vmlld01hdHJpeCgpKSxlLmZvZ01vZGUhPT1hLlNjZW5lLkZPR01PREVfTk9ORSYmKHRoaXMuX2VmZmVjdC5zZXRGbG9hdDQoXCJ2Rm9nSW5mb3NcIixlLmZvZ01vZGUsZS5mb2dTdGFydCxlLmZvZ0VuZCxlLmZvZ0RlbnNpdHkpLHRoaXMuX2VmZmVjdC5zZXRDb2xvcjMoXCJ2Rm9nQ29sb3JcIixlLmZvZ0NvbG9yKSl9LGQucHJvdG90eXBlLmdldEFuaW1hdGFibGVzPWZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIHRoaXMuZGlmZnVzZVRleHR1cmUmJnRoaXMuZGlmZnVzZVRleHR1cmUuYW5pbWF0aW9ucyYmdGhpcy5kaWZmdXNlVGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5kaWZmdXNlVGV4dHVyZSksdGhpcy5hbWJpZW50VGV4dHVyZSYmdGhpcy5hbWJpZW50VGV4dHVyZS5hbmltYXRpb25zJiZ0aGlzLmFtYmllbnRUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoPjAmJmEucHVzaCh0aGlzLmFtYmllbnRUZXh0dXJlKSx0aGlzLm9wYWNpdHlUZXh0dXJlJiZ0aGlzLm9wYWNpdHlUZXh0dXJlLmFuaW1hdGlvbnMmJnRoaXMub3BhY2l0eVRleHR1cmUuYW5pbWF0aW9ucy5sZW5ndGg+MCYmYS5wdXNoKHRoaXMub3BhY2l0eVRleHR1cmUpLHRoaXMucmVmbGVjdGlvblRleHR1cmUmJnRoaXMucmVmbGVjdGlvblRleHR1cmUuYW5pbWF0aW9ucyYmdGhpcy5yZWZsZWN0aW9uVGV4dHVyZS5hbmltYXRpb25zLmxlbmd0aD4wJiZhLnB1c2godGhpcy5yZWZsZWN0aW9uVGV4dHVyZSksdGhpcy5lbWlzc2l2ZVRleHR1cmUmJnRoaXMuZW1pc3NpdmVUZXh0dXJlLmFuaW1hdGlvbnMmJnRoaXMuZW1pc3NpdmVUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoPjAmJmEucHVzaCh0aGlzLmVtaXNzaXZlVGV4dHVyZSksdGhpcy5zcGVjdWxhclRleHR1cmUmJnRoaXMuc3BlY3VsYXJUZXh0dXJlLmFuaW1hdGlvbnMmJnRoaXMuc3BlY3VsYXJUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoPjAmJmEucHVzaCh0aGlzLnNwZWN1bGFyVGV4dHVyZSksdGhpcy5idW1wVGV4dHVyZSYmdGhpcy5idW1wVGV4dHVyZS5hbmltYXRpb25zJiZ0aGlzLmJ1bXBUZXh0dXJlLmFuaW1hdGlvbnMubGVuZ3RoPjAmJmEucHVzaCh0aGlzLmJ1bXBUZXh0dXJlKSxhfSxkLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe3RoaXMuZGlmZnVzZVRleHR1cmUmJnRoaXMuZGlmZnVzZVRleHR1cmUuZGlzcG9zZSgpLHRoaXMuYW1iaWVudFRleHR1cmUmJnRoaXMuYW1iaWVudFRleHR1cmUuZGlzcG9zZSgpLHRoaXMub3BhY2l0eVRleHR1cmUmJnRoaXMub3BhY2l0eVRleHR1cmUuZGlzcG9zZSgpLHRoaXMucmVmbGVjdGlvblRleHR1cmUmJnRoaXMucmVmbGVjdGlvblRleHR1cmUuZGlzcG9zZSgpLHRoaXMuZW1pc3NpdmVUZXh0dXJlJiZ0aGlzLmVtaXNzaXZlVGV4dHVyZS5kaXNwb3NlKCksdGhpcy5zcGVjdWxhclRleHR1cmUmJnRoaXMuc3BlY3VsYXJUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLmJ1bXBUZXh0dXJlJiZ0aGlzLmJ1bXBUZXh0dXJlLmRpc3Bvc2UoKSxjLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyxhKX0sZC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYil7dmFyIGM9bmV3IGEuU3RhbmRhcmRNYXRlcmlhbChiLHRoaXMuZ2V0U2NlbmUoKSk7cmV0dXJuIGMuY2hlY2tSZWFkeU9uRXZlcnlDYWxsPXRoaXMuY2hlY2tSZWFkeU9uRXZlcnlDYWxsLGMuYWxwaGE9dGhpcy5hbHBoYSxjLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZSxjLmJhY2tGYWNlQ3VsbGluZz10aGlzLmJhY2tGYWNlQ3VsbGluZyx0aGlzLmRpZmZ1c2VUZXh0dXJlJiZ0aGlzLmRpZmZ1c2VUZXh0dXJlLmNsb25lJiYoYy5kaWZmdXNlVGV4dHVyZT10aGlzLmRpZmZ1c2VUZXh0dXJlLmNsb25lKCkpLHRoaXMuYW1iaWVudFRleHR1cmUmJnRoaXMuYW1iaWVudFRleHR1cmUuY2xvbmUmJihjLmFtYmllbnRUZXh0dXJlPXRoaXMuYW1iaWVudFRleHR1cmUuY2xvbmUoKSksdGhpcy5vcGFjaXR5VGV4dHVyZSYmdGhpcy5vcGFjaXR5VGV4dHVyZS5jbG9uZSYmKGMub3BhY2l0eVRleHR1cmU9dGhpcy5vcGFjaXR5VGV4dHVyZS5jbG9uZSgpKSx0aGlzLnJlZmxlY3Rpb25UZXh0dXJlJiZ0aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmNsb25lJiYoYy5yZWZsZWN0aW9uVGV4dHVyZT10aGlzLnJlZmxlY3Rpb25UZXh0dXJlLmNsb25lKCkpLHRoaXMuZW1pc3NpdmVUZXh0dXJlJiZ0aGlzLmVtaXNzaXZlVGV4dHVyZS5jbG9uZSYmKGMuZW1pc3NpdmVUZXh0dXJlPXRoaXMuZW1pc3NpdmVUZXh0dXJlLmNsb25lKCkpLHRoaXMuc3BlY3VsYXJUZXh0dXJlJiZ0aGlzLnNwZWN1bGFyVGV4dHVyZS5jbG9uZSYmKGMuc3BlY3VsYXJUZXh0dXJlPXRoaXMuc3BlY3VsYXJUZXh0dXJlLmNsb25lKCkpLHRoaXMuYnVtcFRleHR1cmUmJnRoaXMuYnVtcFRleHR1cmUuY2xvbmUmJihjLmJ1bXBUZXh0dXJlPXRoaXMuYnVtcFRleHR1cmUuY2xvbmUoKSksYy5hbWJpZW50Q29sb3I9dGhpcy5hbWJpZW50Q29sb3IuY2xvbmUoKSxjLmRpZmZ1c2VDb2xvcj10aGlzLmRpZmZ1c2VDb2xvci5jbG9uZSgpLGMuc3BlY3VsYXJDb2xvcj10aGlzLnNwZWN1bGFyQ29sb3IuY2xvbmUoKSxjLnNwZWN1bGFyUG93ZXI9dGhpcy5zcGVjdWxhclBvd2VyLGMuZW1pc3NpdmVDb2xvcj10aGlzLmVtaXNzaXZlQ29sb3IuY2xvbmUoKSxjfSxkLkRpZmZ1c2VUZXh0dXJlRW5hYmxlZD0hMCxkLkFtYmllbnRUZXh0dXJlRW5hYmxlZD0hMCxkLk9wYWNpdHlUZXh0dXJlRW5hYmxlZD0hMCxkLlJlZmxlY3Rpb25UZXh0dXJlRW5hYmxlZD0hMCxkLkVtaXNzaXZlVGV4dHVyZUVuYWJsZWQ9ITAsZC5TcGVjdWxhclRleHR1cmVFbmFibGVkPSEwLGQuQnVtcFRleHR1cmVFbmFibGVkPSEwLGR9KGEuTWF0ZXJpYWwpO2EuU3RhbmRhcmRNYXRlcmlhbD1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMpe2EuY2FsbCh0aGlzLGIsYywhMCksdGhpcy5zdWJNYXRlcmlhbHM9bmV3IEFycmF5LGMubXVsdGlNYXRlcmlhbHMucHVzaCh0aGlzKX1yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuZ2V0U3ViTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7cmV0dXJuIDA+YXx8YT49dGhpcy5zdWJNYXRlcmlhbHMubGVuZ3RoP3RoaXMuZ2V0U2NlbmUoKS5kZWZhdWx0TWF0ZXJpYWw6dGhpcy5zdWJNYXRlcmlhbHNbYV19LGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLnN1Yk1hdGVyaWFscy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLnN1Yk1hdGVyaWFsc1tiXTtpZihjJiYhdGhpcy5zdWJNYXRlcmlhbHNbYl0uaXNSZWFkeShhKSlyZXR1cm4hMX1yZXR1cm4hMH0sYn0oYS5NYXRlcmlhbCk7YS5NdWx0aU1hdGVyaWFsPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMpe3RoaXMuaWRiRmFjdG9yeT13aW5kb3cuaW5kZXhlZERCfHx3aW5kb3cubW96SW5kZXhlZERCfHx3aW5kb3cud2Via2l0SW5kZXhlZERCfHx3aW5kb3cubXNJbmRleGVkREIsdGhpcy5jYWxsYmFja01hbmlmZXN0Q2hlY2tlZD1jLHRoaXMuY3VycmVudFNjZW5lVXJsPWEuRGF0YWJhc2UuUmV0dXJuRnVsbFVybExvY2F0aW9uKGIpLHRoaXMuZGI9bnVsbCx0aGlzLmVuYWJsZVNjZW5lT2ZmbGluZT0hMSx0aGlzLmVuYWJsZVRleHR1cmVzT2ZmbGluZT0hMSx0aGlzLm1hbmlmZXN0VmVyc2lvbkZvdW5kPTAsdGhpcy5tdXN0VXBkYXRlUmVzc291cmNlcz0hMSx0aGlzLmhhc1JlYWNoZWRRdW90YT0hMSx0aGlzLmNoZWNrTWFuaWZlc3RGaWxlKCl9cmV0dXJuIGIucHJvdG90eXBlLmNoZWNrTWFuaWZlc3RGaWxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe2EuVG9vbHMuTG9nKFwiVmFsaWQgbWFuaWZlc3QgZmlsZSBub3QgZm91bmQuIFNjZW5lICYgdGV4dHVyZXMgd2lsbCBiZSBsb2FkZWQgZGlyZWN0bHkgZnJvbSB0aGUgd2ViIHNlcnZlci5cIiksZC5lbmFibGVTY2VuZU9mZmxpbmU9ITEsZC5lbmFibGVUZXh0dXJlc09mZmxpbmU9ITEsZC5jYWxsYmFja01hbmlmZXN0Q2hlY2tlZCghMSl9dmFyIGM9dGhpcyxkPXRoaXMsZT10aGlzLmN1cnJlbnRTY2VuZVVybCtcIi5tYW5pZmVzdFwiLGY9bmV3IFhNTEh0dHBSZXF1ZXN0LGc9ZSsobnVsbD09ZS5tYXRjaCgvXFw/Lyk/XCI/XCI6XCImXCIpKyhuZXcgRGF0ZSkuZ2V0VGltZSgpO2Yub3BlbihcIkdFVFwiLGcsITApLGYuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe2lmKDIwMD09PWYuc3RhdHVzfHxhLlRvb2xzLlZhbGlkYXRlWEhSRGF0YShmLDEpKXRyeXt2YXIgZD1KU09OLnBhcnNlKGYucmVzcG9uc2UpO2MuZW5hYmxlU2NlbmVPZmZsaW5lPWQuZW5hYmxlU2NlbmVPZmZsaW5lLGMuZW5hYmxlVGV4dHVyZXNPZmZsaW5lPWQuZW5hYmxlVGV4dHVyZXNPZmZsaW5lLGQudmVyc2lvbiYmIWlzTmFOKHBhcnNlSW50KGQudmVyc2lvbikpJiYoYy5tYW5pZmVzdFZlcnNpb25Gb3VuZD1kLnZlcnNpb24pLGMuY2FsbGJhY2tNYW5pZmVzdENoZWNrZWQmJmMuY2FsbGJhY2tNYW5pZmVzdENoZWNrZWQoITApfWNhdGNoKGUpe2IoKX1lbHNlIGIoKX0sITEpLGYuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXtiKCl9LCExKTt0cnl7Zi5zZW5kKCl9Y2F0Y2goaCl7YS5Ub29scy5FcnJvcihcIkVycm9yIG9uIFhIUiBzZW5kIHJlcXVlc3QuXCIpLGQuY2FsbGJhY2tNYW5pZmVzdENoZWNrZWQoITEpfX0sYi5wcm90b3R5cGUub3BlbkFzeW5jPWZ1bmN0aW9uKGIsYyl7ZnVuY3Rpb24gZCgpe2YuaXNTdXBwb3J0ZWQ9ITEsYyYmYygpfXZhciBlPXRoaXMsZj10aGlzO2lmKHRoaXMuaWRiRmFjdG9yeSYmKHRoaXMuZW5hYmxlU2NlbmVPZmZsaW5lfHx0aGlzLmVuYWJsZVRleHR1cmVzT2ZmbGluZSkpaWYodGhpcy5kYiliJiZiKCk7ZWxzZXt0aGlzLmhhc1JlYWNoZWRRdW90YT0hMSx0aGlzLmlzU3VwcG9ydGVkPSEwO3ZhciBnPXRoaXMuaWRiRmFjdG9yeS5vcGVuKFwiYmFieWxvbmpzXCIsMSk7Zy5vbmVycm9yPWZ1bmN0aW9uKCl7ZCgpfSxnLm9uYmxvY2tlZD1mdW5jdGlvbigpe2EuVG9vbHMuRXJyb3IoXCJJREIgcmVxdWVzdCBibG9ja2VkLiBQbGVhc2UgcmVsb2FkIHRoZSBwYWdlLlwiKSxkKCl9LGcub25zdWNjZXNzPWZ1bmN0aW9uKCl7ZS5kYj1nLnJlc3VsdCxiKCl9LGcub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKGIpe2UuZGI9Yi50YXJnZXQucmVzdWx0O3RyeXtiLm9sZFZlcnNpb24+MCYmKGUuZGIuZGVsZXRlT2JqZWN0U3RvcmUoXCJzY2VuZXNcIiksZS5kYi5kZWxldGVPYmplY3RTdG9yZShcInZlcnNpb25zXCIpLGUuZGIuZGVsZXRlT2JqZWN0U3RvcmUoXCJ0ZXh0dXJlc1wiKSk7e2UuZGIuY3JlYXRlT2JqZWN0U3RvcmUoXCJzY2VuZXNcIix7a2V5UGF0aDpcInNjZW5lVXJsXCJ9KSxlLmRiLmNyZWF0ZU9iamVjdFN0b3JlKFwidmVyc2lvbnNcIix7a2V5UGF0aDpcInNjZW5lVXJsXCJ9KSxlLmRiLmNyZWF0ZU9iamVjdFN0b3JlKFwidGV4dHVyZXNcIix7a2V5UGF0aDpcInRleHR1cmVVcmxcIn0pfX1jYXRjaChjKXthLlRvb2xzLkVycm9yKFwiRXJyb3Igd2hpbGUgY3JlYXRpbmcgb2JqZWN0IHN0b3Jlcy4gRXhjZXB0aW9uOiBcIitjLm1lc3NhZ2UpLGQoKX19fWVsc2UgdGhpcy5pc1N1cHBvcnRlZD0hMSxjJiZjKCl9LGIucHJvdG90eXBlLmxvYWRJbWFnZUZyb21EQj1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMsZT1hLkRhdGFiYXNlLlJldHVybkZ1bGxVcmxMb2NhdGlvbihiKSxmPWZ1bmN0aW9uKCl7ZC5oYXNSZWFjaGVkUXVvdGF8fG51bGw9PT1kLmRiP2Muc3JjPWI6ZC5fc2F2ZUltYWdlSW50b0RCQXN5bmMoZSxjKX07dGhpcy5tdXN0VXBkYXRlUmVzc291cmNlcz9mKCk6dGhpcy5fbG9hZEltYWdlRnJvbURCQXN5bmMoZSxjLGYpfSxiLnByb3RvdHlwZS5fbG9hZEltYWdlRnJvbURCQXN5bmM9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMuaXNTdXBwb3J0ZWQmJm51bGwhPT10aGlzLmRiKXt2YXIgZSxmPXRoaXMuZGIudHJhbnNhY3Rpb24oW1widGV4dHVyZXNcIl0pO2Yub25hYm9ydD1mdW5jdGlvbigpe2Muc3JjPWJ9LGYub25jb21wbGV0ZT1mdW5jdGlvbigpe3ZhciBmO2lmKGUpe3ZhciBnPXdpbmRvdy5VUkx8fHdpbmRvdy53ZWJraXRVUkw7Zj1nLmNyZWF0ZU9iamVjdFVSTChlLmRhdGEse29uZVRpbWVPbmx5OiEwfSksYy5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGxvYWRpbmcgaW1hZ2UgZnJvbSBibG9iIFVSTDogXCIrZitcIiBzd2l0Y2hpbmcgYmFjayB0byB3ZWIgdXJsOiBcIitiKSxjLnNyYz1ifSxjLnNyYz1mfWVsc2UgZCgpfTt2YXIgZz1mLm9iamVjdFN0b3JlKFwidGV4dHVyZXNcIikuZ2V0KGIpO2cub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2U9YS50YXJnZXQucmVzdWx0fSxnLm9uZXJyb3I9ZnVuY3Rpb24oKXthLlRvb2xzLkVycm9yKFwiRXJyb3IgbG9hZGluZyB0ZXh0dXJlIFwiK2IrXCIgZnJvbSBEQi5cIiksYy5zcmM9Yn19ZWxzZSBhLlRvb2xzLkVycm9yKFwiRXJyb3I6IEluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBCYWJ5bG9uSlMgRGF0YWJhc2UgaXMgbm90IG9wZW4uXCIpLGMuc3JjPWJ9LGIucHJvdG90eXBlLl9zYXZlSW1hZ2VJbnRvREJBc3luYz1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXM7aWYodGhpcy5pc1N1cHBvcnRlZCl7dmFyIGU9ZnVuY3Rpb24oKXt2YXIgYTtpZihmKXt2YXIgYj13aW5kb3cuVVJMfHx3aW5kb3cud2Via2l0VVJMO3RyeXthPWIuY3JlYXRlT2JqZWN0VVJMKGYse29uZVRpbWVPbmx5OiEwfSl9Y2F0Y2goZCl7YT1iLmNyZWF0ZU9iamVjdFVSTChmKX19Yy5zcmM9YX07aWYoYS5EYXRhYmFzZS5pc1VBU3VwcG9ydGluZ0Jsb2JTdG9yYWdlKXt2YXIgZixnPW5ldyBYTUxIdHRwUmVxdWVzdDtnLm9wZW4oXCJHRVRcIixiLCEwKSxnLnJlc3BvbnNlVHlwZT1cImJsb2JcIixnLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oKXtpZigyMDA9PT1nLnN0YXR1cyl7Zj1nLnJlc3BvbnNlO3ZhciBoPWQuZGIudHJhbnNhY3Rpb24oW1widGV4dHVyZXNcIl0sXCJyZWFkd3JpdGVcIik7aC5vbmFib3J0PWZ1bmN0aW9uKGEpe3RyeXtcIlF1b3RhRXhjZWVkZWRFcnJvclwiPT09YS5zcmNFbGVtZW50LmVycm9yLm5hbWUmJih0aGlzLmhhc1JlYWNoZWRRdW90YT0hMCl9Y2F0Y2goYil7fWUoKX0saC5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7ZSgpfTt2YXIgaT17dGV4dHVyZVVybDpiLGRhdGE6Zn07dHJ5e3ZhciBqPWgub2JqZWN0U3RvcmUoXCJ0ZXh0dXJlc1wiKS5wdXQoaSk7ai5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt9LGoub25lcnJvcj1mdW5jdGlvbigpe2UoKX19Y2F0Y2goayl7MjU9PT1rLmNvZGUmJihhLkRhdGFiYXNlLmlzVUFTdXBwb3J0aW5nQmxvYlN0b3JhZ2U9ITEpLGMuc3JjPWJ9fWVsc2UgYy5zcmM9Yn0sITEpLGcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZnVuY3Rpb24oKXthLlRvb2xzLkVycm9yKFwiRXJyb3IgaW4gWEhSIHJlcXVlc3QgaW4gQkFCWUxPTi5EYXRhYmFzZS5cIiksYy5zcmM9Yn0sITEpLGcuc2VuZCgpfWVsc2UgYy5zcmM9Yn1lbHNlIGEuVG9vbHMuRXJyb3IoXCJFcnJvcjogSW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyIG9yIEJhYnlsb25KUyBEYXRhYmFzZSBpcyBub3Qgb3Blbi5cIiksYy5zcmM9Yn0sYi5wcm90b3R5cGUuX2NoZWNrVmVyc2lvbkZyb21EQj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1mdW5jdGlvbigpe2MuX3NhdmVWZXJzaW9uSW50b0RCQXN5bmMoYSxiKX07dGhpcy5fbG9hZFZlcnNpb25Gcm9tREJBc3luYyhhLGIsZCl9LGIucHJvdG90eXBlLl9sb2FkVmVyc2lvbkZyb21EQkFzeW5jPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzO2lmKHRoaXMuaXNTdXBwb3J0ZWQpe3ZhciBmO3RyeXt2YXIgZz10aGlzLmRiLnRyYW5zYWN0aW9uKFtcInZlcnNpb25zXCJdKTtnLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtmP2UubWFuaWZlc3RWZXJzaW9uRm91bmQ+Zi5kYXRhPyhlLm11c3RVcGRhdGVSZXNzb3VyY2VzPSEwLGQoKSk6YyhmLmRhdGEpOihlLm11c3RVcGRhdGVSZXNzb3VyY2VzPSEwLGQoKSl9LGcub25hYm9ydD1mdW5jdGlvbigpe2MoLTEpfTt2YXIgaD1nLm9iamVjdFN0b3JlKFwidmVyc2lvbnNcIikuZ2V0KGIpO2gub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2Y9YS50YXJnZXQucmVzdWx0fSxoLm9uZXJyb3I9ZnVuY3Rpb24oKXthLlRvb2xzLkVycm9yKFwiRXJyb3IgbG9hZGluZyB2ZXJzaW9uIGZvciBzY2VuZSBcIitiK1wiIGZyb20gREIuXCIpLGMoLTEpfX1jYXRjaChpKXthLlRvb2xzLkVycm9yKFwiRXJyb3Igd2hpbGUgYWNjZXNzaW5nICd2ZXJzaW9ucycgb2JqZWN0IHN0b3JlIChSRUFEIE9QKS4gRXhjZXB0aW9uOiBcIitpLm1lc3NhZ2UpLGMoLTEpfX1lbHNlIGEuVG9vbHMuRXJyb3IoXCJFcnJvcjogSW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyIG9yIEJhYnlsb25KUyBEYXRhYmFzZSBpcyBub3Qgb3Blbi5cIiksYygtMSl9LGIucHJvdG90eXBlLl9zYXZlVmVyc2lvbkludG9EQkFzeW5jPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcztpZih0aGlzLmlzU3VwcG9ydGVkJiYhdGhpcy5oYXNSZWFjaGVkUXVvdGEpdHJ5e3ZhciBlPXRoaXMuZGIudHJhbnNhY3Rpb24oW1widmVyc2lvbnNcIl0sXCJyZWFkd3JpdGVcIik7ZS5vbmFib3J0PWZ1bmN0aW9uKGEpe3RyeXtcIlF1b3RhRXhjZWVkZWRFcnJvclwiPT09YS5zcmNFbGVtZW50LmVycm9yLm5hbWUmJihkLmhhc1JlYWNoZWRRdW90YT0hMCl9Y2F0Y2goYil7fWMoLTEpfSxlLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtjKGQubWFuaWZlc3RWZXJzaW9uRm91bmQpfTt2YXIgZj17c2NlbmVVcmw6YixkYXRhOnRoaXMubWFuaWZlc3RWZXJzaW9uRm91bmR9LGc9ZS5vYmplY3RTdG9yZShcInZlcnNpb25zXCIpLnB1dChmKTtnLm9uc3VjY2Vzcz1mdW5jdGlvbigpe30sZy5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGluIERCIGFkZCB2ZXJzaW9uIHJlcXVlc3QgaW4gQkFCWUxPTi5EYXRhYmFzZS5cIil9fWNhdGNoKGgpe2EuVG9vbHMuRXJyb3IoXCJFcnJvciB3aGlsZSBhY2Nlc3NpbmcgJ3ZlcnNpb25zJyBvYmplY3Qgc3RvcmUgKFdSSVRFIE9QKS4gRXhjZXB0aW9uOiBcIitoLm1lc3NhZ2UpLGMoLTEpfWVsc2UgYygtMSl9LGIucHJvdG90eXBlLmxvYWRGaWxlRnJvbURCPWZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGc9dGhpcyxoPWEuRGF0YWJhc2UuUmV0dXJuRnVsbFVybExvY2F0aW9uKGIpLGk9ZnVuY3Rpb24oKXtnLl9zYXZlRmlsZUludG9EQkFzeW5jKGgsYyxkKX07dGhpcy5fY2hlY2tWZXJzaW9uRnJvbURCKGgsZnVuY3Rpb24oYSl7LTEhPT1hP2cubXVzdFVwZGF0ZVJlc3NvdXJjZXM/Zy5fc2F2ZUZpbGVJbnRvREJBc3luYyhoLGMsZCxmKTpnLl9sb2FkRmlsZUZyb21EQkFzeW5jKGgsYyxpLGYpOmUoKX0pfSxiLnByb3RvdHlwZS5fbG9hZEZpbGVGcm9tREJBc3luYz1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5pc1N1cHBvcnRlZCl7dmFyIGU7ZT0tMSE9PWIuaW5kZXhPZihcIi5iYWJ5bG9uXCIpP1wic2NlbmVzXCI6XCJ0ZXh0dXJlc1wiO3ZhciBmLGc9dGhpcy5kYi50cmFuc2FjdGlvbihbZV0pO2cub25jb21wbGV0ZT1mdW5jdGlvbigpe2Y/YyhmLmRhdGEpOmQoKX0sZy5vbmFib3J0PWZ1bmN0aW9uKCl7ZCgpfTt2YXIgaD1nLm9iamVjdFN0b3JlKGUpLmdldChiKTtoLm9uc3VjY2Vzcz1mdW5jdGlvbihhKXtmPWEudGFyZ2V0LnJlc3VsdH0saC5vbmVycm9yPWZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcIkVycm9yIGxvYWRpbmcgZmlsZSBcIitiK1wiIGZyb20gREIuXCIpLGQoKX19ZWxzZSBhLlRvb2xzLkVycm9yKFwiRXJyb3I6IEluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlciBvciBCYWJ5bG9uSlMgRGF0YWJhc2UgaXMgbm90IG9wZW4uXCIpLGMoKX0sYi5wcm90b3R5cGUuX3NhdmVGaWxlSW50b0RCQXN5bmM9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9dGhpcztpZih0aGlzLmlzU3VwcG9ydGVkKXt2YXIgZztnPS0xIT09Yi5pbmRleE9mKFwiLmJhYnlsb25cIik/XCJzY2VuZXNcIjpcInRleHR1cmVzXCI7dmFyIGgsaT1uZXcgWE1MSHR0cFJlcXVlc3Q7aS5vcGVuKFwiR0VUXCIsYiwhMCksZSYmKGkucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIiksaS5vbnByb2dyZXNzPWQsaS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7aWYoMjAwPT09aS5zdGF0dXN8fGEuVG9vbHMuVmFsaWRhdGVYSFJEYXRhKGksZT82OjEpKWlmKGg9ZT9pLnJlc3BvbnNlOmkucmVzcG9uc2VUZXh0LGYuaGFzUmVhY2hlZFF1b3RhKWMoaCk7ZWxzZXt2YXIgZD1mLmRiLnRyYW5zYWN0aW9uKFtnXSxcInJlYWR3cml0ZVwiKTtkLm9uYWJvcnQ9ZnVuY3Rpb24oYSl7dHJ5e1wiUXVvdGFFeGNlZWRlZEVycm9yXCI9PT1hLnNyY0VsZW1lbnQuZXJyb3IubmFtZSYmKHRoaXMuaGFzUmVhY2hlZFF1b3RhPSEwKX1jYXRjaChiKXt9YyhoKX0sZC5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7YyhoKX07dmFyIGo7aj1cInNjZW5lc1wiPT09Zz97c2NlbmVVcmw6YixkYXRhOmgsdmVyc2lvbjpmLm1hbmlmZXN0VmVyc2lvbkZvdW5kfTp7dGV4dHVyZVVybDpiLGRhdGE6aH07dHJ5e3ZhciBrPWQub2JqZWN0U3RvcmUoZykucHV0KGopO2sub25zdWNjZXNzPWZ1bmN0aW9uKCl7fSxrLm9uZXJyb3I9ZnVuY3Rpb24oKXthLlRvb2xzLkVycm9yKFwiRXJyb3IgaW4gREIgYWRkIGZpbGUgcmVxdWVzdCBpbiBCQUJZTE9OLkRhdGFiYXNlLlwiKX19Y2F0Y2gobCl7YyhoKX19ZWxzZSBjKCl9LCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKCl7YS5Ub29scy5FcnJvcihcImVycm9yIG9uIFhIUiByZXF1ZXN0LlwiKSxjKCl9LCExKSxpLnNlbmQoKX1lbHNlIGEuVG9vbHMuRXJyb3IoXCJFcnJvcjogSW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyIG9yIEJhYnlsb25KUyBEYXRhYmFzZSBpcyBub3Qgb3Blbi5cIiksYygpfSxiLmlzVUFTdXBwb3J0aW5nQmxvYlN0b3JhZ2U9ITAsYi5wYXJzZVVSTD1mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtiLmhyZWY9YTt2YXIgYz1hLnN1YnN0cmluZyhhLmxhc3RJbmRleE9mKFwiL1wiKSsxLGEubGVuZ3RoKSxkPWEuc3Vic3RyaW5nKDAsYS5pbmRleE9mKGMsMCkpO3JldHVybiBkfSxiLlJldHVybkZ1bGxVcmxMb2NhdGlvbj1mdW5jdGlvbihiKXtyZXR1cm4tMT09PWIuaW5kZXhPZihcImh0dHA6L1wiKT9hLkRhdGFiYXNlLnBhcnNlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKStiOmJ9LGJ9KCk7YS5EYXRhYmFzZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcpe3RoaXMubmFtZT1iLHRoaXMuY2VsbFNpemU9ZSx0aGlzLnNwcml0ZXM9bmV3IEFycmF5LHRoaXMucmVuZGVyaW5nR3JvdXBJZD0wLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uPVszLDQsNCw0XSx0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplPTYwLHRoaXMuX2NhcGFjaXR5PWQsdGhpcy5fc3ByaXRlVGV4dHVyZT1uZXcgYS5UZXh0dXJlKGMsZiwhMCwhMSksdGhpcy5fc3ByaXRlVGV4dHVyZS53cmFwVT1hLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREUsdGhpcy5fc3ByaXRlVGV4dHVyZS53cmFwVj1hLlRleHR1cmUuQ0xBTVBfQUREUkVTU01PREUsdGhpcy5fZXBzaWxvbj12b2lkIDA9PT1nPy4wMTpnLHRoaXMuX3NjZW5lPWYsdGhpcy5fc2NlbmUuc3ByaXRlTWFuYWdlcnMucHVzaCh0aGlzKSx0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbj1bMyw0LDQsNF0sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZT02MCx0aGlzLl92ZXJ0ZXhCdWZmZXI9Zi5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVmVydGV4QnVmZmVyKGQqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSo0KTtmb3IodmFyIGg9W10saT0wLGo9MDtkPmo7aisrKWgucHVzaChpKSxoLnB1c2goaSsxKSxoLnB1c2goaSsyKSxoLnB1c2goaSksaC5wdXNoKGkrMiksaC5wdXNoKGkrMyksaSs9NDt0aGlzLl9pbmRleEJ1ZmZlcj1mLmdldEVuZ2luZSgpLmNyZWF0ZUluZGV4QnVmZmVyKGgpLHRoaXMuX3ZlcnRpY2VzPW5ldyBGbG9hdDMyQXJyYXkoZCp0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplKSx0aGlzLl9lZmZlY3RCYXNlPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmNyZWF0ZUVmZmVjdChcInNwcml0ZXNcIixbXCJwb3NpdGlvblwiLFwib3B0aW9uc1wiLFwiY2VsbEluZm9cIixcImNvbG9yXCJdLFtcInZpZXdcIixcInByb2plY3Rpb25cIixcInRleHR1cmVJbmZvc1wiLFwiYWxwaGFUZXN0XCJdLFtcImRpZmZ1c2VTYW1wbGVyXCJdLFwiXCIpLHRoaXMuX2VmZmVjdEZvZz10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5jcmVhdGVFZmZlY3QoXCJzcHJpdGVzXCIsW1wicG9zaXRpb25cIixcIm9wdGlvbnNcIixcImNlbGxJbmZvXCIsXCJjb2xvclwiXSxbXCJ2aWV3XCIsXCJwcm9qZWN0aW9uXCIsXCJ0ZXh0dXJlSW5mb3NcIixcImFscGhhVGVzdFwiLFwidkZvZ0luZm9zXCIsXCJ2Rm9nQ29sb3JcIl0sW1wiZGlmZnVzZVNhbXBsZXJcIl0sXCIjZGVmaW5lIEZPR1wiKX1yZXR1cm4gYi5wcm90b3R5cGUuX2FwcGVuZFNwcml0ZVZlcnRleD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPTE1KmE7MD09Yz9jPXRoaXMuX2Vwc2lsb246MT09YyYmKGM9MS10aGlzLl9lcHNpbG9uKSwwPT1kP2Q9dGhpcy5fZXBzaWxvbjoxPT1kJiYoZD0xLXRoaXMuX2Vwc2lsb24pLHRoaXMuX3ZlcnRpY2VzW2ZdPWIucG9zaXRpb24ueCx0aGlzLl92ZXJ0aWNlc1tmKzFdPWIucG9zaXRpb24ueSx0aGlzLl92ZXJ0aWNlc1tmKzJdPWIucG9zaXRpb24ueix0aGlzLl92ZXJ0aWNlc1tmKzNdPWIuYW5nbGUsdGhpcy5fdmVydGljZXNbZis0XT1iLnNpemUsdGhpcy5fdmVydGljZXNbZis1XT1jLHRoaXMuX3ZlcnRpY2VzW2YrNl09ZCx0aGlzLl92ZXJ0aWNlc1tmKzddPWIuaW52ZXJ0VT8xOjAsdGhpcy5fdmVydGljZXNbZis4XT1iLmludmVydFY/MTowO3ZhciBnPWIuY2VsbEluZGV4L2U+PjA7dGhpcy5fdmVydGljZXNbZis5XT1iLmNlbGxJbmRleC1nKmUsdGhpcy5fdmVydGljZXNbZisxMF09Zyx0aGlzLl92ZXJ0aWNlc1tmKzExXT1iLmNvbG9yLnIsdGhpcy5fdmVydGljZXNbZisxMl09Yi5jb2xvci5nLHRoaXMuX3ZlcnRpY2VzW2YrMTNdPWIuY29sb3IuYix0aGlzLl92ZXJ0aWNlc1tmKzE0XT1iLmNvbG9yLmF9LGIucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMuX2VmZmVjdEJhc2UuaXNSZWFkeSgpJiZ0aGlzLl9lZmZlY3RGb2cuaXNSZWFkeSgpJiZ0aGlzLl9zcHJpdGVUZXh0dXJlJiZ0aGlzLl9zcHJpdGVUZXh0dXJlLmlzUmVhZHkoKSl7Zm9yKHZhciBiPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLGM9dGhpcy5fc3ByaXRlVGV4dHVyZS5nZXRCYXNlU2l6ZSgpLGQ9YS5Ub29scy5HZXREZWx0YVRpbWUoKSxlPU1hdGgubWluKHRoaXMuX2NhcGFjaXR5LHRoaXMuc3ByaXRlcy5sZW5ndGgpLGY9Yy53aWR0aC90aGlzLmNlbGxTaXplLGc9MCxoPTA7ZT5oO2grKyl7dmFyIGk9dGhpcy5zcHJpdGVzW2hdO2kmJihpLl9hbmltYXRlKGQpLHRoaXMuX2FwcGVuZFNwcml0ZVZlcnRleChnKyssaSwwLDAsZiksdGhpcy5fYXBwZW5kU3ByaXRlVmVydGV4KGcrKyxpLDEsMCxmKSx0aGlzLl9hcHBlbmRTcHJpdGVWZXJ0ZXgoZysrLGksMSwxLGYpLHRoaXMuX2FwcGVuZFNwcml0ZVZlcnRleChnKyssaSwwLDEsZikpfWIudXBkYXRlRHluYW1pY1ZlcnRleEJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIsdGhpcy5fdmVydGljZXMsZSp0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplKTt2YXIgaj10aGlzLl9lZmZlY3RCYXNlO3RoaXMuX3NjZW5lLmZvZ01vZGUhPT1hLlNjZW5lLkZPR01PREVfTk9ORSYmKGo9dGhpcy5fZWZmZWN0Rm9nKSxiLmVuYWJsZUVmZmVjdChqKTt2YXIgaz10aGlzLl9zY2VuZS5nZXRWaWV3TWF0cml4KCk7ai5zZXRUZXh0dXJlKFwiZGlmZnVzZVNhbXBsZXJcIix0aGlzLl9zcHJpdGVUZXh0dXJlKSxqLnNldE1hdHJpeChcInZpZXdcIixrKSxqLnNldE1hdHJpeChcInByb2plY3Rpb25cIix0aGlzLl9zY2VuZS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLGouc2V0RmxvYXQyKFwidGV4dHVyZUluZm9zXCIsdGhpcy5jZWxsU2l6ZS9jLndpZHRoLHRoaXMuY2VsbFNpemUvYy5oZWlnaHQpLHRoaXMuX3NjZW5lLmZvZ01vZGUhPT1hLlNjZW5lLkZPR01PREVfTk9ORSYmKGouc2V0RmxvYXQ0KFwidkZvZ0luZm9zXCIsdGhpcy5fc2NlbmUuZm9nTW9kZSx0aGlzLl9zY2VuZS5mb2dTdGFydCx0aGlzLl9zY2VuZS5mb2dFbmQsdGhpcy5fc2NlbmUuZm9nRGVuc2l0eSksai5zZXRDb2xvcjMoXCJ2Rm9nQ29sb3JcIix0aGlzLl9zY2VuZS5mb2dDb2xvcikpLGIuYmluZEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX2luZGV4QnVmZmVyLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uLHRoaXMuX3ZlcnRleFN0cmlkZVNpemUsaiksai5zZXRCb29sKFwiYWxwaGFUZXN0XCIsITApLGIuc2V0Q29sb3JXcml0ZSghMSksYi5kcmF3KCEwLDAsNiplKSxiLnNldENvbG9yV3JpdGUoITApLGouc2V0Qm9vbChcImFscGhhVGVzdFwiLCExKSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9DT01CSU5FKSxiLmRyYXcoITAsMCw2KmUpLGIuc2V0QWxwaGFNb2RlKGEuRW5naW5lLkFMUEhBX0RJU0FCTEUpfX0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuX3ZlcnRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX3ZlcnRleEJ1ZmZlciksdGhpcy5fdmVydGV4QnVmZmVyPW51bGwpLHRoaXMuX2luZGV4QnVmZmVyJiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpLHRoaXMuX2luZGV4QnVmZmVyPW51bGwpLHRoaXMuX3Nwcml0ZVRleHR1cmUmJih0aGlzLl9zcHJpdGVUZXh0dXJlLmRpc3Bvc2UoKSx0aGlzLl9zcHJpdGVUZXh0dXJlPW51bGwpO3ZhciBhPXRoaXMuX3NjZW5lLnNwcml0ZU1hbmFnZXJzLmluZGV4T2YodGhpcyk7dGhpcy5fc2NlbmUuc3ByaXRlTWFuYWdlcnMuc3BsaWNlKGEsMSksdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCl9LGJ9KCk7YS5TcHJpdGVNYW5hZ2VyPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMpe3RoaXMubmFtZT1iLHRoaXMuY29sb3I9bmV3IGEuQ29sb3I0KDEsMSwxLDEpLHRoaXMuc2l6ZT0xLHRoaXMuYW5nbGU9MCx0aGlzLmNlbGxJbmRleD0wLHRoaXMuaW52ZXJ0VT0wLHRoaXMuaW52ZXJ0Vj0wLHRoaXMuYW5pbWF0aW9ucz1uZXcgQXJyYXksdGhpcy5fYW5pbWF0aW9uU3RhcnRlZD0hMSx0aGlzLl9sb29wQW5pbWF0aW9uPSExLHRoaXMuX2Zyb21JbmRleD0wLHRoaXMuX3RvSW5kZXg9MCx0aGlzLl9kZWxheT0wLHRoaXMuX2RpcmVjdGlvbj0xLHRoaXMuX2ZyYW1lQ291bnQ9MCx0aGlzLl90aW1lPTAsdGhpcy5fbWFuYWdlcj1jLHRoaXMuX21hbmFnZXIuc3ByaXRlcy5wdXNoKHRoaXMpLHRoaXMucG9zaXRpb249YS5WZWN0b3IzLlplcm8oKX1yZXR1cm4gYi5wcm90b3R5cGUucGxheUFuaW1hdGlvbj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9mcm9tSW5kZXg9YSx0aGlzLl90b0luZGV4PWIsdGhpcy5fbG9vcEFuaW1hdGlvbj1jLHRoaXMuX2RlbGF5PWQsdGhpcy5fYW5pbWF0aW9uU3RhcnRlZD0hMCx0aGlzLl9kaXJlY3Rpb249Yj5hPzE6LTEsdGhpcy5jZWxsSW5kZXg9YSx0aGlzLl90aW1lPTB9LGIucHJvdG90eXBlLnN0b3BBbmltYXRpb249ZnVuY3Rpb24oKXt0aGlzLl9hbmltYXRpb25TdGFydGVkPSExfSxiLnByb3RvdHlwZS5fYW5pbWF0ZT1mdW5jdGlvbihhKXt0aGlzLl9hbmltYXRpb25TdGFydGVkJiYodGhpcy5fdGltZSs9YSx0aGlzLl90aW1lPnRoaXMuX2RlbGF5JiYodGhpcy5fdGltZT10aGlzLl90aW1lJXRoaXMuX2RlbGF5LHRoaXMuY2VsbEluZGV4Kz10aGlzLl9kaXJlY3Rpb24sdGhpcy5jZWxsSW5kZXg9PXRoaXMuX3RvSW5kZXgmJih0aGlzLl9sb29wQW5pbWF0aW9uP3RoaXMuY2VsbEluZGV4PXRoaXMuX2Zyb21JbmRleDoodGhpcy5fYW5pbWF0aW9uU3RhcnRlZD0hMSx0aGlzLmRpc3Bvc2VXaGVuRmluaXNoZWRBbmltYXRpbmcmJnRoaXMuZGlzcG9zZSgpKSkpKX0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5fbWFuYWdlci5zcHJpdGVzLmxlbmd0aDthKyspdGhpcy5fbWFuYWdlci5zcHJpdGVzW2FdPT10aGlzJiZ0aGlzLl9tYW5hZ2VyLnNwcml0ZXMuc3BsaWNlKGEsMSl9LGJ9KCk7YS5TcHJpdGU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGUsZil7dGhpcy5uYW1lPWIsdGhpcy5fdmVydGV4RGVjbGFyYXRpb249WzJdLHRoaXMuX3ZlcnRleFN0cmlkZVNpemU9OCx0aGlzLnRleHR1cmU9Yz9uZXcgYS5UZXh0dXJlKGMsZCwhMCk6bnVsbCx0aGlzLmlzQmFja2dyb3VuZD12b2lkIDA9PT1lPyEwOmUsdGhpcy5jb2xvcj12b2lkIDA9PT1mP25ldyBhLkNvbG9yNCgxLDEsMSwxKTpmLHRoaXMuX3NjZW5lPWQsdGhpcy5fc2NlbmUubGF5ZXJzLnB1c2godGhpcyk7dmFyIGc9W107Zy5wdXNoKDEsMSksZy5wdXNoKC0xLDEpLGcucHVzaCgtMSwtMSksZy5wdXNoKDEsLTEpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1kLmdldEVuZ2luZSgpLmNyZWF0ZVZlcnRleEJ1ZmZlcihnKTt2YXIgaD1bXTtoLnB1c2goMCksaC5wdXNoKDEpLGgucHVzaCgyKSxoLnB1c2goMCksaC5wdXNoKDIpLGgucHVzaCgzKSx0aGlzLl9pbmRleEJ1ZmZlcj1kLmdldEVuZ2luZSgpLmNyZWF0ZUluZGV4QnVmZmVyKGgpLHRoaXMuX2VmZmVjdD10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5jcmVhdGVFZmZlY3QoXCJsYXllclwiLFtcInBvc2l0aW9uXCJdLFtcInRleHR1cmVNYXRyaXhcIixcImNvbG9yXCJdLFtcInRleHR1cmVTYW1wbGVyXCJdLFwiXCIpfXJldHVybiBiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtpZih0aGlzLl9lZmZlY3QuaXNSZWFkeSgpJiZ0aGlzLnRleHR1cmUmJnRoaXMudGV4dHVyZS5pc1JlYWR5KCkpe3ZhciBiPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2IuZW5hYmxlRWZmZWN0KHRoaXMuX2VmZmVjdCksYi5zZXRTdGF0ZSghMSksdGhpcy5fZWZmZWN0LnNldFRleHR1cmUoXCJ0ZXh0dXJlU2FtcGxlclwiLHRoaXMudGV4dHVyZSksdGhpcy5fZWZmZWN0LnNldE1hdHJpeChcInRleHR1cmVNYXRyaXhcIix0aGlzLnRleHR1cmUuZ2V0VGV4dHVyZU1hdHJpeCgpKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQ0KFwiY29sb3JcIix0aGlzLmNvbG9yLnIsdGhpcy5jb2xvci5nLHRoaXMuY29sb3IuYix0aGlzLmNvbG9yLmEpLGIuYmluZEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX2luZGV4QnVmZmVyLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uLHRoaXMuX3ZlcnRleFN0cmlkZVNpemUsdGhpcy5fZWZmZWN0KSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9DT01CSU5FKSxiLmRyYXcoITAsMCw2KSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9ESVNBQkxFKX19LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1udWxsKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKSx0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKSx0aGlzLnRleHR1cmUmJih0aGlzLnRleHR1cmUuZGlzcG9zZSgpLHRoaXMudGV4dHVyZT1udWxsKTt2YXIgYT10aGlzLl9zY2VuZS5sYXllcnMuaW5kZXhPZih0aGlzKTt0aGlzLl9zY2VuZS5sYXllcnMuc3BsaWNlKGEsMSksdGhpcy5vbkRpc3Bvc2UmJnRoaXMub25EaXNwb3NlKCl9LGJ9KCk7YS5MYXllcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt0aGlzLnBvc2l0aW9uPWEuVmVjdG9yMy5aZXJvKCksdGhpcy5kaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLmNvbG9yPW5ldyBhLkNvbG9yNCgwLDAsMCwwKSx0aGlzLmNvbG9yU3RlcD1uZXcgYS5Db2xvcjQoMCwwLDAsMCksdGhpcy5saWZlVGltZT0xLHRoaXMuYWdlPTAsdGhpcy5zaXplPTAsdGhpcy5hbmdsZT0wLHRoaXMuYW5ndWxhclNwZWVkPTB9cmV0dXJuIGJ9KCk7YS5QYXJ0aWNsZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhLGIpe2lmKGE9PWIpcmV0dXJuIGE7dmFyIGM9TWF0aC5yYW5kb20oKTtyZXR1cm4gYyooYi1hKSthfSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYyhjLGQsZSxmKXt2YXIgZz10aGlzO3RoaXMubmFtZT1jLHRoaXMuZnJhZ21lbnRFbGVtZW50PWYsdGhpcy5yZW5kZXJpbmdHcm91cElkPTAsdGhpcy5lbWl0dGVyPW51bGwsdGhpcy5lbWl0UmF0ZT0xMCx0aGlzLm1hbnVhbEVtaXRDb3VudD0tMSx0aGlzLnVwZGF0ZVNwZWVkPS4wMSx0aGlzLnRhcmdldFN0b3BEdXJhdGlvbj0wLHRoaXMuZGlzcG9zZU9uU3RvcD0hMSx0aGlzLm1pbkVtaXRQb3dlcj0xLHRoaXMubWF4RW1pdFBvd2VyPTEsdGhpcy5taW5MaWZlVGltZT0xLHRoaXMubWF4TGlmZVRpbWU9MSx0aGlzLm1pblNpemU9MSx0aGlzLm1heFNpemU9MSx0aGlzLm1pbkFuZ3VsYXJTcGVlZD0wLHRoaXMubWF4QW5ndWxhclNwZWVkPTAsdGhpcy5ibGVuZE1vZGU9YS5QYXJ0aWNsZVN5c3RlbS5CTEVORE1PREVfT05FT05FLHRoaXMuZm9yY2VEZXB0aFdyaXRlPSExLHRoaXMuZ3Jhdml0eT1hLlZlY3RvcjMuWmVybygpLHRoaXMuZGlyZWN0aW9uMT1uZXcgYS5WZWN0b3IzKDAsMSwwKSx0aGlzLmRpcmVjdGlvbjI9bmV3IGEuVmVjdG9yMygwLDEsMCksdGhpcy5taW5FbWl0Qm94PW5ldyBhLlZlY3RvcjMoLS41LC0uNSwtLjUpLHRoaXMubWF4RW1pdEJveD1uZXcgYS5WZWN0b3IzKC41LC41LC41KSx0aGlzLmNvbG9yMT1uZXcgYS5Db2xvcjQoMSwxLDEsMSksdGhpcy5jb2xvcjI9bmV3IGEuQ29sb3I0KDEsMSwxLDEpLHRoaXMuY29sb3JEZWFkPW5ldyBhLkNvbG9yNCgwLDAsMCwxKSx0aGlzLnRleHR1cmVNYXNrPW5ldyBhLkNvbG9yNCgxLDEsMSwxKSx0aGlzLnBhcnRpY2xlcz1uZXcgQXJyYXksdGhpcy5fdmVydGV4RGVjbGFyYXRpb249WzMsNCw0XSx0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplPTQ0LHRoaXMuX3N0b2NrUGFydGljbGVzPW5ldyBBcnJheSx0aGlzLl9uZXdQYXJ0c0V4Y2Vzcz0wLHRoaXMuX3NjYWxlZENvbG9yU3RlcD1uZXcgYS5Db2xvcjQoMCwwLDAsMCksdGhpcy5fY29sb3JEaWZmPW5ldyBhLkNvbG9yNCgwLDAsMCwwKSx0aGlzLl9zY2FsZWREaXJlY3Rpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9zY2FsZWRHcmF2aXR5PWEuVmVjdG9yMy5aZXJvKCksdGhpcy5fY3VycmVudFJlbmRlcklkPS0xLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fc3RvcHBlZD0hMSx0aGlzLl9hY3R1YWxGcmFtZT0wLHRoaXMuaWQ9Yyx0aGlzLl9jYXBhY2l0eT1kLHRoaXMuX3NjZW5lPWUsZS5wYXJ0aWNsZVN5c3RlbXMucHVzaCh0aGlzKSx0aGlzLl92ZXJ0ZXhCdWZmZXI9ZS5nZXRFbmdpbmUoKS5jcmVhdGVEeW5hbWljVmVydGV4QnVmZmVyKGQqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSo0KTtmb3IodmFyIGg9W10saT0wLGo9MDtkPmo7aisrKWgucHVzaChpKSxoLnB1c2goaSsxKSxoLnB1c2goaSsyKSxoLnB1c2goaSksaC5wdXNoKGkrMiksaC5wdXNoKGkrMyksaSs9NDt0aGlzLl9pbmRleEJ1ZmZlcj1lLmdldEVuZ2luZSgpLmNyZWF0ZUluZGV4QnVmZmVyKGgpLHRoaXMuX3ZlcnRpY2VzPW5ldyBGbG9hdDMyQXJyYXkoZCp0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplKSx0aGlzLnN0YXJ0RGlyZWN0aW9uRnVuY3Rpb249ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPWIoZy5kaXJlY3Rpb24xLngsZy5kaXJlY3Rpb24yLngpLGg9YihnLmRpcmVjdGlvbjEueSxnLmRpcmVjdGlvbjIueSksaT1iKGcuZGlyZWN0aW9uMS56LGcuZGlyZWN0aW9uMi56KTtcbmEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxGcm9tRmxvYXRzVG9SZWYoZipjLGgqYyxpKmMsZCxlKX0sdGhpcy5zdGFydFBvc2l0aW9uRnVuY3Rpb249ZnVuY3Rpb24oYyxkKXt2YXIgZT1iKGcubWluRW1pdEJveC54LGcubWF4RW1pdEJveC54KSxmPWIoZy5taW5FbWl0Qm94LnksZy5tYXhFbWl0Qm94LnkpLGg9YihnLm1pbkVtaXRCb3gueixnLm1heEVtaXRCb3gueik7YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzRnJvbUZsb2F0c1RvUmVmKGUsZixoLGMsZCl9fXJldHVybiBjLnByb3RvdHlwZS5nZXRDYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jYXBhY2l0eX0sYy5wcm90b3R5cGUuaXNBbGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbGl2ZX0sYy5wcm90b3R5cGUuaXNTdGFydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9LGMucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl9zdG9wcGVkPSExLHRoaXMuX2FjdHVhbEZyYW1lPTB9LGMucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt0aGlzLl9zdG9wcGVkPSEwfSxjLnByb3RvdHlwZS5fYXBwZW5kUGFydGljbGVWZXJ0ZXg9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9MTEqYTt0aGlzLl92ZXJ0aWNlc1tlXT1iLnBvc2l0aW9uLngsdGhpcy5fdmVydGljZXNbZSsxXT1iLnBvc2l0aW9uLnksdGhpcy5fdmVydGljZXNbZSsyXT1iLnBvc2l0aW9uLnosdGhpcy5fdmVydGljZXNbZSszXT1iLmNvbG9yLnIsdGhpcy5fdmVydGljZXNbZSs0XT1iLmNvbG9yLmcsdGhpcy5fdmVydGljZXNbZSs1XT1iLmNvbG9yLmIsdGhpcy5fdmVydGljZXNbZSs2XT1iLmNvbG9yLmEsdGhpcy5fdmVydGljZXNbZSs3XT1iLmFuZ2xlLHRoaXMuX3ZlcnRpY2VzW2UrOF09Yi5zaXplLHRoaXMuX3ZlcnRpY2VzW2UrOV09Yyx0aGlzLl92ZXJ0aWNlc1tlKzEwXT1kfSxjLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGMpe3RoaXMuX2FsaXZlPXRoaXMucGFydGljbGVzLmxlbmd0aD4wO2Zvcih2YXIgZD0wO2Q8dGhpcy5wYXJ0aWNsZXMubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5wYXJ0aWNsZXNbZF07ZS5hZ2UrPXRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLGUuYWdlPj1lLmxpZmVUaW1lPyh0aGlzLl9zdG9ja1BhcnRpY2xlcy5wdXNoKHRoaXMucGFydGljbGVzLnNwbGljZShkLDEpWzBdKSxkLS0pOihlLmNvbG9yU3RlcC5zY2FsZVRvUmVmKHRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLHRoaXMuX3NjYWxlZENvbG9yU3RlcCksZS5jb2xvci5hZGRJblBsYWNlKHRoaXMuX3NjYWxlZENvbG9yU3RlcCksZS5jb2xvci5hPDAmJihlLmNvbG9yLmE9MCksZS5hbmdsZSs9ZS5hbmd1bGFyU3BlZWQqdGhpcy5fc2NhbGVkVXBkYXRlU3BlZWQsZS5kaXJlY3Rpb24uc2NhbGVUb1JlZih0aGlzLl9zY2FsZWRVcGRhdGVTcGVlZCx0aGlzLl9zY2FsZWREaXJlY3Rpb24pLGUucG9zaXRpb24uYWRkSW5QbGFjZSh0aGlzLl9zY2FsZWREaXJlY3Rpb24pLHRoaXMuZ3Jhdml0eS5zY2FsZVRvUmVmKHRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLHRoaXMuX3NjYWxlZEdyYXZpdHkpLGUuZGlyZWN0aW9uLmFkZEluUGxhY2UodGhpcy5fc2NhbGVkR3Jhdml0eSkpfXZhciBmO2ZvcihmPXRoaXMuZW1pdHRlci5wb3NpdGlvbj90aGlzLmVtaXR0ZXIuZ2V0V29ybGRNYXRyaXgoKTphLk1hdHJpeC5UcmFuc2xhdGlvbih0aGlzLmVtaXR0ZXIueCx0aGlzLmVtaXR0ZXIueSx0aGlzLmVtaXR0ZXIueiksZD0wO2M+ZCYmdGhpcy5wYXJ0aWNsZXMubGVuZ3RoIT10aGlzLl9jYXBhY2l0eTtkKyspezAhPT10aGlzLl9zdG9ja1BhcnRpY2xlcy5sZW5ndGg/KGU9dGhpcy5fc3RvY2tQYXJ0aWNsZXMucG9wKCksZS5hZ2U9MCk6ZT1uZXcgYS5QYXJ0aWNsZSx0aGlzLnBhcnRpY2xlcy5wdXNoKGUpO3ZhciBnPWIodGhpcy5taW5FbWl0UG93ZXIsdGhpcy5tYXhFbWl0UG93ZXIpO3RoaXMuc3RhcnREaXJlY3Rpb25GdW5jdGlvbihnLGYsZS5kaXJlY3Rpb24pLGUubGlmZVRpbWU9Yih0aGlzLm1pbkxpZmVUaW1lLHRoaXMubWF4TGlmZVRpbWUpLGUuc2l6ZT1iKHRoaXMubWluU2l6ZSx0aGlzLm1heFNpemUpLGUuYW5ndWxhclNwZWVkPWIodGhpcy5taW5Bbmd1bGFyU3BlZWQsdGhpcy5tYXhBbmd1bGFyU3BlZWQpLHRoaXMuc3RhcnRQb3NpdGlvbkZ1bmN0aW9uKGYsZS5wb3NpdGlvbik7dmFyIGg9YigwLDEpO2EuQ29sb3I0LkxlcnBUb1JlZih0aGlzLmNvbG9yMSx0aGlzLmNvbG9yMixoLGUuY29sb3IpLHRoaXMuY29sb3JEZWFkLnN1YnRyYWN0VG9SZWYoZS5jb2xvcix0aGlzLl9jb2xvckRpZmYpLHRoaXMuX2NvbG9yRGlmZi5zY2FsZVRvUmVmKDEvZS5saWZlVGltZSxlLmNvbG9yU3RlcCl9fSxjLnByb3RvdHlwZS5fZ2V0RWZmZWN0PWZ1bmN0aW9uKCl7dmFyIGE9W107dGhpcy5fc2NlbmUuY2xpcFBsYW5lJiZhLnB1c2goXCIjZGVmaW5lIENMSVBQTEFORVwiKTt2YXIgYj1hLmpvaW4oXCJcXG5cIik7aWYodGhpcy5fY2FjaGVkRGVmaW5lcyE9Yil7dGhpcy5fY2FjaGVkRGVmaW5lcz1iO3ZhciBjO2M9dGhpcy5mcmFnbWVudEVsZW1lbnQ/e3ZlcnRleDpcInBhcnRpY2xlc1wiLGZyYWdtZW50RWxlbWVudDp0aGlzLmZyYWdtZW50RWxlbWVudH06XCJwYXJ0aWNsZXNcIix0aGlzLl9lZmZlY3Q9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuY3JlYXRlRWZmZWN0KGMsW1wicG9zaXRpb25cIixcImNvbG9yXCIsXCJvcHRpb25zXCJdLFtcImludlZpZXdcIixcInZpZXdcIixcInByb2plY3Rpb25cIixcInZDbGlwUGxhbmVcIixcInRleHR1cmVNYXNrXCJdLFtcImRpZmZ1c2VTYW1wbGVyXCJdLGIpfXJldHVybiB0aGlzLl9lZmZlY3R9LGMucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oKXtpZih0aGlzLl9zdGFydGVkKXt2YXIgYT10aGlzLl9nZXRFZmZlY3QoKTtpZih0aGlzLmVtaXR0ZXImJmEuaXNSZWFkeSgpJiZ0aGlzLnBhcnRpY2xlVGV4dHVyZSYmdGhpcy5wYXJ0aWNsZVRleHR1cmUuaXNSZWFkeSgpJiZ0aGlzLl9jdXJyZW50UmVuZGVySWQhPT10aGlzLl9zY2VuZS5nZXRSZW5kZXJJZCgpKXt0aGlzLl9jdXJyZW50UmVuZGVySWQ9dGhpcy5fc2NlbmUuZ2V0UmVuZGVySWQoKSx0aGlzLl9zY2FsZWRVcGRhdGVTcGVlZD10aGlzLnVwZGF0ZVNwZWVkKnRoaXMuX3NjZW5lLmdldEFuaW1hdGlvblJhdGlvKCk7dmFyIGI7dGhpcy5tYW51YWxFbWl0Q291bnQ+LTE/KGI9dGhpcy5tYW51YWxFbWl0Q291bnQsdGhpcy5tYW51YWxFbWl0Q291bnQ9MCk6Yj10aGlzLmVtaXRSYXRlO3ZhciBjPWIqdGhpcy5fc2NhbGVkVXBkYXRlU3BlZWQ+PjA7dGhpcy5fbmV3UGFydHNFeGNlc3MrPWIqdGhpcy5fc2NhbGVkVXBkYXRlU3BlZWQtYyx0aGlzLl9uZXdQYXJ0c0V4Y2Vzcz4xJiYoYys9dGhpcy5fbmV3UGFydHNFeGNlc3M+PjAsdGhpcy5fbmV3UGFydHNFeGNlc3MtPXRoaXMuX25ld1BhcnRzRXhjZXNzPj4wKSx0aGlzLl9hbGl2ZT0hMSx0aGlzLl9zdG9wcGVkP2M9MDoodGhpcy5fYWN0dWFsRnJhbWUrPXRoaXMuX3NjYWxlZFVwZGF0ZVNwZWVkLHRoaXMudGFyZ2V0U3RvcER1cmF0aW9uJiZ0aGlzLl9hY3R1YWxGcmFtZT49dGhpcy50YXJnZXRTdG9wRHVyYXRpb24mJnRoaXMuc3RvcCgpKSx0aGlzLl91cGRhdGUoYyksdGhpcy5fc3RvcHBlZCYmKHRoaXMuX2FsaXZlfHwodGhpcy5fc3RhcnRlZD0hMSx0aGlzLmRpc3Bvc2VPblN0b3AmJnRoaXMuX3NjZW5lLl90b0JlRGlzcG9zZWQucHVzaCh0aGlzKSkpO2Zvcih2YXIgZD0wLGU9MDtlPHRoaXMucGFydGljbGVzLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMucGFydGljbGVzW2VdO3RoaXMuX2FwcGVuZFBhcnRpY2xlVmVydGV4KGQrKyxmLDAsMCksdGhpcy5fYXBwZW5kUGFydGljbGVWZXJ0ZXgoZCsrLGYsMSwwKSx0aGlzLl9hcHBlbmRQYXJ0aWNsZVZlcnRleChkKyssZiwxLDEpLHRoaXMuX2FwcGVuZFBhcnRpY2xlVmVydGV4KGQrKyxmLDAsMSl9dmFyIGc9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7Zy51cGRhdGVEeW5hbWljVmVydGV4QnVmZmVyKHRoaXMuX3ZlcnRleEJ1ZmZlcix0aGlzLl92ZXJ0aWNlcyx0aGlzLnBhcnRpY2xlcy5sZW5ndGgqdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSl9fX0sYy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fZ2V0RWZmZWN0KCk7aWYoISh0aGlzLmVtaXR0ZXImJmIuaXNSZWFkeSgpJiZ0aGlzLnBhcnRpY2xlVGV4dHVyZSYmdGhpcy5wYXJ0aWNsZVRleHR1cmUuaXNSZWFkeSgpJiZ0aGlzLnBhcnRpY2xlcy5sZW5ndGgpKXJldHVybiAwO3ZhciBjPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpO2MuZW5hYmxlRWZmZWN0KGIpO3ZhciBkPXRoaXMuX3NjZW5lLmdldFZpZXdNYXRyaXgoKTtpZihiLnNldFRleHR1cmUoXCJkaWZmdXNlU2FtcGxlclwiLHRoaXMucGFydGljbGVUZXh0dXJlKSxiLnNldE1hdHJpeChcInZpZXdcIixkKSxiLnNldE1hdHJpeChcInByb2plY3Rpb25cIix0aGlzLl9zY2VuZS5nZXRQcm9qZWN0aW9uTWF0cml4KCkpLGIuc2V0RmxvYXQ0KFwidGV4dHVyZU1hc2tcIix0aGlzLnRleHR1cmVNYXNrLnIsdGhpcy50ZXh0dXJlTWFzay5nLHRoaXMudGV4dHVyZU1hc2suYix0aGlzLnRleHR1cmVNYXNrLmEpLHRoaXMuX3NjZW5lLmNsaXBQbGFuZSl7dmFyIGU9dGhpcy5fc2NlbmUuY2xpcFBsYW5lLGY9ZC5jbG9uZSgpO2YuaW52ZXJ0KCksYi5zZXRNYXRyaXgoXCJpbnZWaWV3XCIsZiksYi5zZXRGbG9hdDQoXCJ2Q2xpcFBsYW5lXCIsZS5ub3JtYWwueCxlLm5vcm1hbC55LGUubm9ybWFsLnosZS5kKX1yZXR1cm4gYy5iaW5kQnVmZmVycyh0aGlzLl92ZXJ0ZXhCdWZmZXIsdGhpcy5faW5kZXhCdWZmZXIsdGhpcy5fdmVydGV4RGVjbGFyYXRpb24sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSxiKSxjLnNldEFscGhhTW9kZSh0aGlzLmJsZW5kTW9kZT09PWEuUGFydGljbGVTeXN0ZW0uQkxFTkRNT0RFX09ORU9ORT9hLkVuZ2luZS5BTFBIQV9BREQ6YS5FbmdpbmUuQUxQSEFfQ09NQklORSksdGhpcy5mb3JjZURlcHRoV3JpdGUmJmMuc2V0RGVwdGhXcml0ZSghMCksYy5kcmF3KCEwLDAsNip0aGlzLnBhcnRpY2xlcy5sZW5ndGgpLGMuc2V0QWxwaGFNb2RlKGEuRW5naW5lLkFMUEhBX0RJU0FCTEUpLHRoaXMucGFydGljbGVzLmxlbmd0aH0sYy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuX3ZlcnRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX3ZlcnRleEJ1ZmZlciksdGhpcy5fdmVydGV4QnVmZmVyPW51bGwpLHRoaXMuX2luZGV4QnVmZmVyJiYodGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkuX3JlbGVhc2VCdWZmZXIodGhpcy5faW5kZXhCdWZmZXIpLHRoaXMuX2luZGV4QnVmZmVyPW51bGwpLHRoaXMucGFydGljbGVUZXh0dXJlJiYodGhpcy5wYXJ0aWNsZVRleHR1cmUuZGlzcG9zZSgpLHRoaXMucGFydGljbGVUZXh0dXJlPW51bGwpO3ZhciBhPXRoaXMuX3NjZW5lLnBhcnRpY2xlU3lzdGVtcy5pbmRleE9mKHRoaXMpO3RoaXMuX3NjZW5lLnBhcnRpY2xlU3lzdGVtcy5zcGxpY2UoYSwxKSx0aGlzLm9uRGlzcG9zZSYmdGhpcy5vbkRpc3Bvc2UoKX0sYy5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYS5QYXJ0aWNsZVN5c3RlbShiLHRoaXMuX2NhcGFjaXR5LHRoaXMuX3NjZW5lKTtyZXR1cm4gYS5Ub29scy5EZWVwQ29weSh0aGlzLGQsW1wicGFydGljbGVzXCJdLFtcIl92ZXJ0ZXhEZWNsYXJhdGlvblwiLFwiX3ZlcnRleFN0cmlkZVNpemVcIl0pLHZvaWQgMD09PWMmJihjPXRoaXMuZW1pdHRlciksZC5lbWl0dGVyPWMsdGhpcy5wYXJ0aWNsZVRleHR1cmUmJihkLnBhcnRpY2xlVGV4dHVyZT1uZXcgYS5UZXh0dXJlKHRoaXMucGFydGljbGVUZXh0dXJlLnVybCx0aGlzLl9zY2VuZSkpLGQuc3RhcnQoKSxkfSxjLkJMRU5ETU9ERV9PTkVPTkU9MCxjLkJMRU5ETU9ERV9TVEFOREFSRD0xLGN9KCk7YS5QYXJ0aWNsZVN5c3RlbT1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxjLGQsZSxmKXt0aGlzLm5hbWU9YSx0aGlzLnRhcmdldFByb3BlcnR5PWMsdGhpcy5mcmFtZVBlclNlY29uZD1kLHRoaXMuZGF0YVR5cGU9ZSx0aGlzLmxvb3BNb2RlPWYsdGhpcy5fb2Zmc2V0c0NhY2hlPXt9LHRoaXMuX2hpZ2hMaW1pdHNDYWNoZT17fSx0aGlzLl9zdG9wcGVkPSExLHRoaXMudGFyZ2V0UHJvcGVydHlQYXRoPWMuc3BsaXQoXCIuXCIpLHRoaXMuZGF0YVR5cGU9ZSx0aGlzLmxvb3BNb2RlPXZvaWQgMD09PWY/Yi5BTklNQVRJT05MT09QTU9ERV9DWUNMRTpmfXJldHVybiBiLnByb3RvdHlwZS5pc1N0b3BwZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RvcHBlZH0sYi5wcm90b3R5cGUuZ2V0S2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9rZXlzfSxiLnByb3RvdHlwZS5mbG9hdEludGVycG9sYXRlRnVuY3Rpb249ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhKyhiLWEpKmN9LGIucHJvdG90eXBlLnF1YXRlcm5pb25JbnRlcnBvbGF0ZUZ1bmN0aW9uPWZ1bmN0aW9uKGIsYyxkKXtyZXR1cm4gYS5RdWF0ZXJuaW9uLlNsZXJwKGIsYyxkKX0sYi5wcm90b3R5cGUudmVjdG9yM0ludGVycG9sYXRlRnVuY3Rpb249ZnVuY3Rpb24oYixjLGQpe3JldHVybiBhLlZlY3RvcjMuTGVycChiLGMsZCl9LGIucHJvdG90eXBlLmNvbG9yM0ludGVycG9sYXRlRnVuY3Rpb249ZnVuY3Rpb24oYixjLGQpe3JldHVybiBhLkNvbG9yMy5MZXJwKGIsYyxkKX0sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgYih0aGlzLm5hbWUsdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGguam9pbihcIi5cIiksdGhpcy5mcmFtZVBlclNlY29uZCx0aGlzLmRhdGFUeXBlLHRoaXMubG9vcE1vZGUpO3JldHVybiBhLnNldEtleXModGhpcy5fa2V5cyksYX0sYi5wcm90b3R5cGUuc2V0S2V5cz1mdW5jdGlvbihhKXt0aGlzLl9rZXlzPWEuc2xpY2UoMCksdGhpcy5fb2Zmc2V0c0NhY2hlPXt9LHRoaXMuX2hpZ2hMaW1pdHNDYWNoZT17fX0sYi5wcm90b3R5cGUuX2ludGVycG9sYXRlPWZ1bmN0aW9uKGEsYyxkLGUsZil7aWYoZD09PWIuQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQmJmM+MClyZXR1cm4gZi5jbG9uZT9mLmNsb25lKCk6Zjt0aGlzLmN1cnJlbnRGcmFtZT1hO2Zvcih2YXIgZz0wO2c8dGhpcy5fa2V5cy5sZW5ndGg7ZysrKWlmKHRoaXMuX2tleXNbZysxXS5mcmFtZT49YSl7dmFyIGg9dGhpcy5fa2V5c1tnXS52YWx1ZSxpPXRoaXMuX2tleXNbZysxXS52YWx1ZSxqPShhLXRoaXMuX2tleXNbZ10uZnJhbWUpLyh0aGlzLl9rZXlzW2crMV0uZnJhbWUtdGhpcy5fa2V5c1tnXS5mcmFtZSk7c3dpdGNoKHRoaXMuZGF0YVR5cGUpe2Nhc2UgYi5BTklNQVRJT05UWVBFX0ZMT0FUOnN3aXRjaChkKXtjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU6Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UOnJldHVybiB0aGlzLmZsb2F0SW50ZXJwb2xhdGVGdW5jdGlvbihoLGksaik7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFOnJldHVybiBlKmMrdGhpcy5mbG9hdEludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopfWJyZWFrO2Nhc2UgYi5BTklNQVRJT05UWVBFX1FVQVRFUk5JT046dmFyIGs9bnVsbDtzd2l0Y2goZCl7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFOmNhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVDprPXRoaXMucXVhdGVybmlvbkludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopO2JyZWFrO2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRTprPXRoaXMucXVhdGVybmlvbkludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopLmFkZChlLnNjYWxlKGMpKX1yZXR1cm4gaztjYXNlIGIuQU5JTUFUSU9OVFlQRV9WRUNUT1IzOnN3aXRjaChkKXtjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU6Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UOnJldHVybiB0aGlzLnZlY3RvcjNJbnRlcnBvbGF0ZUZ1bmN0aW9uKGgsaSxqKTtjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfUkVMQVRJVkU6cmV0dXJuIHRoaXMudmVjdG9yM0ludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopLmFkZChlLnNjYWxlKGMpKX1jYXNlIGIuQU5JTUFUSU9OVFlQRV9DT0xPUjM6c3dpdGNoKGQpe2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DWUNMRTpjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQ6cmV0dXJuIHRoaXMuY29sb3IzSW50ZXJwb2xhdGVGdW5jdGlvbihoLGksaik7Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFOnJldHVybiB0aGlzLmNvbG9yM0ludGVycG9sYXRlRnVuY3Rpb24oaCxpLGopLmFkZChlLnNjYWxlKGMpKX1jYXNlIGIuQU5JTUFUSU9OVFlQRV9NQVRSSVg6c3dpdGNoKGQpe2Nhc2UgYi5BTklNQVRJT05MT09QTU9ERV9DWUNMRTpjYXNlIGIuQU5JTUFUSU9OTE9PUE1PREVfQ09OU1RBTlQ6Y2FzZSBiLkFOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFOnJldHVybiBofX1icmVha31yZXR1cm4gdGhpcy5fa2V5c1t0aGlzLl9rZXlzLmxlbmd0aC0xXS52YWx1ZX0sYi5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihhLGMsZCxlLGYpe2lmKCF0aGlzLnRhcmdldFByb3BlcnR5UGF0aHx8dGhpcy50YXJnZXRQcm9wZXJ0eVBhdGgubGVuZ3RoPDEpcmV0dXJuIHRoaXMuX3N0b3BwZWQ9ITAsITE7dmFyIGc9ITA7aWYoMCE9dGhpcy5fa2V5c1swXS5mcmFtZSl7dmFyIGg9e2ZyYW1lOjAsdmFsdWU6dGhpcy5fa2V5c1swXS52YWx1ZX07dGhpcy5fa2V5cy5zcGxpY2UoMCwwLGgpfShjPHRoaXMuX2tleXNbMF0uZnJhbWV8fGM+dGhpcy5fa2V5c1t0aGlzLl9rZXlzLmxlbmd0aC0xXS5mcmFtZSkmJihjPXRoaXMuX2tleXNbMF0uZnJhbWUpLChkPHRoaXMuX2tleXNbMF0uZnJhbWV8fGQ+dGhpcy5fa2V5c1t0aGlzLl9rZXlzLmxlbmd0aC0xXS5mcmFtZSkmJihkPXRoaXMuX2tleXNbdGhpcy5fa2V5cy5sZW5ndGgtMV0uZnJhbWUpO3ZhciBpPWQtYyxqPWEqdGhpcy5mcmFtZVBlclNlY29uZCpmLzFlMztpZihqPmkmJiFlKWs9MCxnPSExLGw9dGhpcy5fa2V5c1t0aGlzLl9rZXlzLmxlbmd0aC0xXS52YWx1ZTtlbHNle3ZhciBrPTAsbD0wO2lmKHRoaXMubG9vcE1vZGUhPWIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEUpe3ZhciBtPWQudG9TdHJpbmcoKStjLnRvU3RyaW5nKCk7aWYoIXRoaXMuX29mZnNldHNDYWNoZVttXSl7dmFyIG49dGhpcy5faW50ZXJwb2xhdGUoYywwLGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEUpLG89dGhpcy5faW50ZXJwb2xhdGUoZCwwLGIuQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEUpO3N3aXRjaCh0aGlzLmRhdGFUeXBlKXtjYXNlIGIuQU5JTUFUSU9OVFlQRV9GTE9BVDp0aGlzLl9vZmZzZXRzQ2FjaGVbbV09by1uO2JyZWFrO2Nhc2UgYi5BTklNQVRJT05UWVBFX1FVQVRFUk5JT046dGhpcy5fb2Zmc2V0c0NhY2hlW21dPW8uc3VidHJhY3Qobik7YnJlYWs7Y2FzZSBiLkFOSU1BVElPTlRZUEVfVkVDVE9SMzp0aGlzLl9vZmZzZXRzQ2FjaGVbbV09by5zdWJ0cmFjdChuKTtjYXNlIGIuQU5JTUFUSU9OVFlQRV9DT0xPUjM6dGhpcy5fb2Zmc2V0c0NhY2hlW21dPW8uc3VidHJhY3Qobil9dGhpcy5faGlnaExpbWl0c0NhY2hlW21dPW99bD10aGlzLl9oaWdoTGltaXRzQ2FjaGVbbV0saz10aGlzLl9vZmZzZXRzQ2FjaGVbbV19fXZhciBwPWovaT4+MCxxPWc/YytqJWk6ZCxyPXRoaXMuX2ludGVycG9sYXRlKHEscCx0aGlzLmxvb3BNb2RlLGssbCk7aWYodGhpcy50YXJnZXRQcm9wZXJ0eVBhdGgubGVuZ3RoPjEpe2Zvcih2YXIgcz10aGlzLl90YXJnZXRbdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGhbMF1dLHQ9MTt0PHRoaXMudGFyZ2V0UHJvcGVydHlQYXRoLmxlbmd0aC0xO3QrKylzPXNbdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGhbdF1dO3NbdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGhbdGhpcy50YXJnZXRQcm9wZXJ0eVBhdGgubGVuZ3RoLTFdXT1yfWVsc2UgdGhpcy5fdGFyZ2V0W3RoaXMudGFyZ2V0UHJvcGVydHlQYXRoWzBdXT1yO3JldHVybiB0aGlzLl90YXJnZXQubWFya0FzRGlydHkmJnRoaXMuX3RhcmdldC5tYXJrQXNEaXJ0eSh0aGlzLnRhcmdldFByb3BlcnR5KSxnfHwodGhpcy5fc3RvcHBlZD0hMCksZ30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05UWVBFX0ZMT0FUXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05UWVBFX0ZMT0FUfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiQU5JTUFUSU9OVFlQRV9WRUNUT1IzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05UWVBFX1ZFQ1RPUjN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJBTklNQVRJT05UWVBFX1FVQVRFUk5JT05cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0FOSU1BVElPTlRZUEVfUVVBVEVSTklPTn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTlRZUEVfTUFUUklYXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05UWVBFX01BVFJJWH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTlRZUEVfQ09MT1IzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05UWVBFX0NPTE9SM30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05MT09QTU9ERV9SRUxBVElWRX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTkxPT1BNT0RFX0NZQ0xFXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05MT09QTU9ERV9DWUNMRX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIkFOSU1BVElPTkxPT1BNT0RFX0NPTlNUQU5UXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLl9BTklNQVRJT05UWVBFX0ZMT0FUPTAsYi5fQU5JTUFUSU9OVFlQRV9WRUNUT1IzPTEsYi5fQU5JTUFUSU9OVFlQRV9RVUFURVJOSU9OPTIsYi5fQU5JTUFUSU9OVFlQRV9NQVRSSVg9MyxiLl9BTklNQVRJT05UWVBFX0NPTE9SMz00LGIuX0FOSU1BVElPTkxPT1BNT0RFX1JFTEFUSVZFPTAsYi5fQU5JTUFUSU9OTE9PUE1PREVfQ1lDTEU9MSxiLl9BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVD0yLGJ9KCk7YS5BbmltYXRpb249Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYixjLGQsZSxmLGcsaCl7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGMmJihjPTApLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkJiYoZD0xMDApLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlJiYoZT0hMSksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGYmJihmPTEpLHRoaXMudGFyZ2V0PWIsdGhpcy5mcm9tRnJhbWU9Yyx0aGlzLnRvRnJhbWU9ZCx0aGlzLmxvb3BBbmltYXRpb249ZSx0aGlzLnNwZWVkUmF0aW89Zix0aGlzLm9uQW5pbWF0aW9uRW5kPWcsdGhpcy5fYW5pbWF0aW9ucz1uZXcgQXJyYXksdGhpcy5fcGF1c2VkPSExLHRoaXMuYW5pbWF0aW9uU3RhcnRlZD0hMSxoJiZ0aGlzLmFwcGVuZEFuaW1hdGlvbnMoYixoKSx0aGlzLl9zY2VuZT1hLGEuX2FjdGl2ZUFuaW1hdGFibGVzLnB1c2godGhpcyl9cmV0dXJuIGEucHJvdG90eXBlLmFwcGVuZEFuaW1hdGlvbnM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YltjXTtkLl90YXJnZXQ9YSx0aGlzLl9hbmltYXRpb25zLnB1c2goZCl9fSxhLnByb3RvdHlwZS5nZXRBbmltYXRpb25CeVRhcmdldFByb3BlcnR5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLl9hbmltYXRpb25zLGM9MDtjPGIubGVuZ3RoO2MrKylpZihiW2NdLnRhcmdldFByb3BlcnR5PT09YSlyZXR1cm4gYltjXTtyZXR1cm4gbnVsbH0sYS5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLl9wYXVzZWQ9ITB9LGEucHJvdG90eXBlLnJlc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLl9wYXVzZWQ9ITF9LGEucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9zY2VuZS5fYWN0aXZlQW5pbWF0YWJsZXMuaW5kZXhPZih0aGlzKTthPi0xJiZ0aGlzLl9zY2VuZS5fYWN0aXZlQW5pbWF0YWJsZXMuc3BsaWNlKGEsMSksdGhpcy5vbkFuaW1hdGlvbkVuZCYmdGhpcy5vbkFuaW1hdGlvbkVuZCgpfSxhLnByb3RvdHlwZS5fYW5pbWF0ZT1mdW5jdGlvbihhKXtpZih0aGlzLl9wYXVzZWQpcmV0dXJuITA7dGhpcy5fbG9jYWxEZWxheU9mZnNldHx8KHRoaXMuX2xvY2FsRGVsYXlPZmZzZXQ9YSk7Zm9yKHZhciBiPSExLGM9dGhpcy5fYW5pbWF0aW9ucyxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1lLmFuaW1hdGUoYS10aGlzLl9sb2NhbERlbGF5T2Zmc2V0LHRoaXMuZnJvbUZyYW1lLHRoaXMudG9GcmFtZSx0aGlzLmxvb3BBbmltYXRpb24sdGhpcy5zcGVlZFJhdGlvKTtiPWJ8fGZ9cmV0dXJuIWImJnRoaXMub25BbmltYXRpb25FbmQmJnRoaXMub25BbmltYXRpb25FbmQoKSxifSxhfSgpO2EuQW5pbWF0YWJsZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBkJiYoZD0yKSx0aGlzLm1heERlcHRoPWQsdGhpcy5keW5hbWljQ29udGVudD1uZXcgQXJyYXksdGhpcy5fbWF4QmxvY2tDYXBhY2l0eT1jfHw2NCx0aGlzLl9zZWxlY3Rpb25Db250ZW50PW5ldyBhLlNtYXJ0QXJyYXkoMTAyNCksdGhpcy5fY3JlYXRpb25GdW5jPWJ9cmV0dXJuIGIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhLGMsZCl7Yi5fQ3JlYXRlQmxvY2tzKGEsYyxkLHRoaXMuX21heEJsb2NrQ2FwYWNpdHksMCx0aGlzLm1heERlcHRoLHRoaXMsdGhpcy5fY3JlYXRpb25GdW5jKX0sYi5wcm90b3R5cGUuYWRkTWVzaD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuYmxvY2tzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYmxvY2tzW2JdO2MuYWRkRW50cnkoYSl9fSxiLnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24oYSxiKXt0aGlzLl9zZWxlY3Rpb25Db250ZW50LnJlc2V0KCk7Zm9yKHZhciBjPTA7Yzx0aGlzLmJsb2Nrcy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmJsb2Nrc1tjXTtkLnNlbGVjdChhLHRoaXMuX3NlbGVjdGlvbkNvbnRlbnQsYil9cmV0dXJuIGI/dGhpcy5fc2VsZWN0aW9uQ29udGVudC5jb25jYXQodGhpcy5keW5hbWljQ29udGVudCk6dGhpcy5fc2VsZWN0aW9uQ29udGVudC5jb25jYXRXaXRoTm9EdXBsaWNhdGUodGhpcy5keW5hbWljQ29udGVudCksdGhpcy5fc2VsZWN0aW9uQ29udGVudH0sYi5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbihhLGIsYyl7dGhpcy5fc2VsZWN0aW9uQ29udGVudC5yZXNldCgpO2Zvcih2YXIgZD0wO2Q8dGhpcy5ibG9ja3MubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5ibG9ja3NbZF07ZS5pbnRlcnNlY3RzKGEsYix0aGlzLl9zZWxlY3Rpb25Db250ZW50LGMpfXJldHVybiBjP3RoaXMuX3NlbGVjdGlvbkNvbnRlbnQuY29uY2F0KHRoaXMuZHluYW1pY0NvbnRlbnQpOnRoaXMuX3NlbGVjdGlvbkNvbnRlbnQuY29uY2F0V2l0aE5vRHVwbGljYXRlKHRoaXMuZHluYW1pY0NvbnRlbnQpLHRoaXMuX3NlbGVjdGlvbkNvbnRlbnR9LGIucHJvdG90eXBlLmludGVyc2VjdHNSYXk9ZnVuY3Rpb24oYSl7dGhpcy5fc2VsZWN0aW9uQ29udGVudC5yZXNldCgpO2Zvcih2YXIgYj0wO2I8dGhpcy5ibG9ja3MubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5ibG9ja3NbYl07Yy5pbnRlcnNlY3RzUmF5KGEsdGhpcy5fc2VsZWN0aW9uQ29udGVudCl9cmV0dXJuIHRoaXMuX3NlbGVjdGlvbkNvbnRlbnQuY29uY2F0V2l0aE5vRHVwbGljYXRlKHRoaXMuZHluYW1pY0NvbnRlbnQpLHRoaXMuX3NlbGVjdGlvbkNvbnRlbnR9LGIuX0NyZWF0ZUJsb2Nrcz1mdW5jdGlvbihiLGMsZCxlLGYsZyxoLGkpe2guYmxvY2tzPW5ldyBBcnJheTtmb3IodmFyIGo9bmV3IGEuVmVjdG9yMygoYy54LWIueCkvMiwoYy55LWIueSkvMiwoYy56LWIueikvMiksaz0wOzI+aztrKyspZm9yKHZhciBsPTA7Mj5sO2wrKylmb3IodmFyIG09MDsyPm07bSsrKXt2YXIgbj1iLmFkZChqLm11bHRpcGx5QnlGbG9hdHMoayxsLG0pKSxvPWIuYWRkKGoubXVsdGlwbHlCeUZsb2F0cyhrKzEsbCsxLG0rMSkpLHA9bmV3IGEuT2N0cmVlQmxvY2sobixvLGUsZisxLGcsaSk7cC5hZGRFbnRyaWVzKGQpLGguYmxvY2tzLnB1c2gocCl9fSxiLkNyZWF0aW9uRnVuY0Zvck1lc2hlcz1mdW5jdGlvbihhLGIpe2EuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3guaW50ZXJzZWN0c01pbk1heChiLm1pblBvaW50LGIubWF4UG9pbnQpJiZiLmVudHJpZXMucHVzaChhKX0sYi5DcmVhdGlvbkZ1bmNGb3JTdWJNZXNoZXM9ZnVuY3Rpb24oYSxiKXthLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94LmludGVyc2VjdHNNaW5NYXgoYi5taW5Qb2ludCxiLm1heFBvaW50KSYmYi5lbnRyaWVzLnB1c2goYSl9LGJ9KCk7YS5PY3RyZWU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmKXt0aGlzLmVudHJpZXM9bmV3IEFycmF5LHRoaXMuX2JvdW5kaW5nVmVjdG9ycz1uZXcgQXJyYXksdGhpcy5fY2FwYWNpdHk9Yyx0aGlzLl9kZXB0aD1kLHRoaXMuX21heERlcHRoPWUsdGhpcy5fY3JlYXRpb25GdW5jPWYsdGhpcy5fbWluUG9pbnQ9YSx0aGlzLl9tYXhQb2ludD1iLHRoaXMuX2JvdW5kaW5nVmVjdG9ycy5wdXNoKGEuY2xvbmUoKSksdGhpcy5fYm91bmRpbmdWZWN0b3JzLnB1c2goYi5jbG9uZSgpKSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChhLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1syXS54PWIueCx0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChhLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1szXS55PWIueSx0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChhLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1s0XS56PWIueix0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChiLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1s1XS56PWEueix0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChiLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1s2XS54PWEueCx0aGlzLl9ib3VuZGluZ1ZlY3RvcnMucHVzaChiLmNsb25lKCkpLHRoaXMuX2JvdW5kaW5nVmVjdG9yc1s3XS55PWEueX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiY2FwYWNpdHlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NhcGFjaXR5fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcIm1pblBvaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9taW5Qb2ludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJtYXhQb2ludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF4UG9pbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUuYWRkRW50cnk9ZnVuY3Rpb24oYSl7aWYodGhpcy5ibG9ja3MpZm9yKHZhciBiPTA7Yjx0aGlzLmJsb2Nrcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmJsb2Nrc1tiXTtjLmFkZEVudHJ5KGEpfWVsc2UgdGhpcy5fY3JlYXRpb25GdW5jKGEsdGhpcyksdGhpcy5lbnRyaWVzLmxlbmd0aD50aGlzLmNhcGFjaXR5JiZ0aGlzLl9kZXB0aDx0aGlzLl9tYXhEZXB0aCYmdGhpcy5jcmVhdGVJbm5lckJsb2NrcygpfSxiLnByb3RvdHlwZS5hZGRFbnRyaWVzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO3RoaXMuYWRkRW50cnkoYyl9fSxiLnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24oYixjLGQpe2lmKGEuQm91bmRpbmdCb3guSXNJbkZydXN0dW0odGhpcy5fYm91bmRpbmdWZWN0b3JzLGIpKXtpZih0aGlzLmJsb2Nrcyl7Zm9yKHZhciBlPTA7ZTx0aGlzLmJsb2Nrcy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLmJsb2Nrc1tlXTtmLnNlbGVjdChiLGMsZCl9cmV0dXJufWQ/Yy5jb25jYXQodGhpcy5lbnRyaWVzKTpjLmNvbmNhdFdpdGhOb0R1cGxpY2F0ZSh0aGlzLmVudHJpZXMpfX0sYi5wcm90b3R5cGUuaW50ZXJzZWN0cz1mdW5jdGlvbihiLGMsZCxlKXtpZihhLkJvdW5kaW5nQm94LkludGVyc2VjdHNTcGhlcmUodGhpcy5fbWluUG9pbnQsdGhpcy5fbWF4UG9pbnQsYixjKSl7aWYodGhpcy5ibG9ja3Mpe2Zvcih2YXIgZj0wO2Y8dGhpcy5ibG9ja3MubGVuZ3RoO2YrKyl7dmFyIGc9dGhpcy5ibG9ja3NbZl07Zy5pbnRlcnNlY3RzKGIsYyxkLGUpfXJldHVybn1lP2QuY29uY2F0KHRoaXMuZW50cmllcyk6ZC5jb25jYXRXaXRoTm9EdXBsaWNhdGUodGhpcy5lbnRyaWVzKX19LGIucHJvdG90eXBlLmludGVyc2VjdHNSYXk9ZnVuY3Rpb24oYSxiKXtpZihhLmludGVyc2VjdHNCb3hNaW5NYXgodGhpcy5fbWluUG9pbnQsdGhpcy5fbWF4UG9pbnQpKXtpZih0aGlzLmJsb2Nrcyl7Zm9yKHZhciBjPTA7Yzx0aGlzLmJsb2Nrcy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmJsb2Nrc1tjXTtkLmludGVyc2VjdHNSYXkoYSxiKX1yZXR1cm59Yi5jb25jYXRXaXRoTm9EdXBsaWNhdGUodGhpcy5lbnRyaWVzKX19LGIucHJvdG90eXBlLmNyZWF0ZUlubmVyQmxvY2tzPWZ1bmN0aW9uKCl7YS5PY3RyZWUuX0NyZWF0ZUJsb2Nrcyh0aGlzLl9taW5Qb2ludCx0aGlzLl9tYXhQb2ludCx0aGlzLmVudHJpZXMsdGhpcy5fY2FwYWNpdHksdGhpcy5fZGVwdGgsdGhpcy5fbWF4RGVwdGgsdGhpcyx0aGlzLl9jcmVhdGlvbkZ1bmMpfSxifSgpO2EuT2N0cmVlQmxvY2s9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGUpe3RoaXMubmFtZT1iLHRoaXMuY2hpbGRyZW49bmV3IEFycmF5LHRoaXMuYW5pbWF0aW9ucz1uZXcgQXJyYXksdGhpcy5fd29ybGRUcmFuc2Zvcm09bmV3IGEuTWF0cml4LHRoaXMuX2Fic29sdXRlVHJhbnNmb3JtPW5ldyBhLk1hdHJpeCx0aGlzLl9pbnZlcnRlZEFic29sdXRlVHJhbnNmb3JtPW5ldyBhLk1hdHJpeCx0aGlzLl9za2VsZXRvbj1jLHRoaXMuX21hdHJpeD1lLHRoaXMuX2Jhc2VNYXRyaXg9ZSxjLmJvbmVzLnB1c2godGhpcyksZD8odGhpcy5fcGFyZW50PWQsZC5jaGlsZHJlbi5wdXNoKHRoaXMpKTp0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl91cGRhdGVEaWZmZXJlbmNlTWF0cml4KCl9cmV0dXJuIGIucHJvdG90eXBlLmdldFBhcmVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXJlbnR9LGIucHJvdG90eXBlLmdldExvY2FsTWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeH0sYi5wcm90b3R5cGUuZ2V0QmFzZU1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9iYXNlTWF0cml4fSxiLnByb3RvdHlwZS5nZXRXb3JsZE1hdHJpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl93b3JsZFRyYW5zZm9ybX0sYi5wcm90b3R5cGUuZ2V0SW52ZXJ0ZWRBYnNvbHV0ZVRyYW5zZm9ybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnZlcnRlZEFic29sdXRlVHJhbnNmb3JtfSxiLnByb3RvdHlwZS5nZXRBYnNvbHV0ZU1hdHJpeD1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLl9tYXRyaXguY2xvbmUoKSxiPXRoaXMuX3BhcmVudDtiOylhPWEubXVsdGlwbHkoYi5nZXRMb2NhbE1hdHJpeCgpKSxiPWIuZ2V0UGFyZW50KCk7cmV0dXJuIGF9LGIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeD1mdW5jdGlvbihhKXt0aGlzLl9tYXRyaXg9YSx0aGlzLl9za2VsZXRvbi5fbWFya0FzRGlydHkoKSx0aGlzLl91cGRhdGVEaWZmZXJlbmNlTWF0cml4KCl9LGIucHJvdG90eXBlLl91cGRhdGVEaWZmZXJlbmNlTWF0cml4PWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50P3RoaXMuX21hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX3BhcmVudC5fYWJzb2x1dGVUcmFuc2Zvcm0sdGhpcy5fYWJzb2x1dGVUcmFuc2Zvcm0pOnRoaXMuX2Fic29sdXRlVHJhbnNmb3JtLmNvcHlGcm9tKHRoaXMuX21hdHJpeCksdGhpcy5fYWJzb2x1dGVUcmFuc2Zvcm0uaW52ZXJ0VG9SZWYodGhpcy5faW52ZXJ0ZWRBYnNvbHV0ZVRyYW5zZm9ybSk7Zm9yKHZhciBhPTA7YTx0aGlzLmNoaWxkcmVuLmxlbmd0aDthKyspdGhpcy5jaGlsZHJlblthXS5fdXBkYXRlRGlmZmVyZW5jZU1hdHJpeCgpfSxiLnByb3RvdHlwZS5tYXJrQXNEaXJ0eT1mdW5jdGlvbigpe3RoaXMuX3NrZWxldG9uLl9tYXJrQXNEaXJ0eSgpfSxifSgpO2EuQm9uZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQpe3RoaXMubmFtZT1iLHRoaXMuaWQ9Yyx0aGlzLmJvbmVzPW5ldyBBcnJheSx0aGlzLl9pc0RpcnR5PSEwLHRoaXMuX2lkZW50aXR5PWEuTWF0cml4LklkZW50aXR5KCksdGhpcy5ib25lcz1bXSx0aGlzLl9zY2VuZT1kLGQuc2tlbGV0b25zLnB1c2godGhpcyl9cmV0dXJuIGIucHJvdG90eXBlLmdldFRyYW5zZm9ybU1hdHJpY2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybU1hdHJpY2VzfSxiLnByb3RvdHlwZS5fbWFya0FzRGlydHk9ZnVuY3Rpb24oKXt0aGlzLl9pc0RpcnR5PSEwfSxiLnByb3RvdHlwZS5wcmVwYXJlPWZ1bmN0aW9uKCl7aWYodGhpcy5faXNEaXJ0eSl7dGhpcy5fdHJhbnNmb3JtTWF0cmljZXMmJnRoaXMuX3RyYW5zZm9ybU1hdHJpY2VzLmxlbmd0aD09PTE2Kih0aGlzLmJvbmVzLmxlbmd0aCsxKXx8KHRoaXMuX3RyYW5zZm9ybU1hdHJpY2VzPW5ldyBGbG9hdDMyQXJyYXkoMTYqKHRoaXMuYm9uZXMubGVuZ3RoKzEpKSk7Zm9yKHZhciBhPTA7YTx0aGlzLmJvbmVzLmxlbmd0aDthKyspe3ZhciBiPXRoaXMuYm9uZXNbYV0sYz1iLmdldFBhcmVudCgpO2M/Yi5nZXRMb2NhbE1hdHJpeCgpLm11bHRpcGx5VG9SZWYoYy5nZXRXb3JsZE1hdHJpeCgpLGIuZ2V0V29ybGRNYXRyaXgoKSk6Yi5nZXRXb3JsZE1hdHJpeCgpLmNvcHlGcm9tKGIuZ2V0TG9jYWxNYXRyaXgoKSksYi5nZXRJbnZlcnRlZEFic29sdXRlVHJhbnNmb3JtKCkubXVsdGlwbHlUb0FycmF5KGIuZ2V0V29ybGRNYXRyaXgoKSx0aGlzLl90cmFuc2Zvcm1NYXRyaWNlcywxNiphKX10aGlzLl9pZGVudGl0eS5jb3B5VG9BcnJheSh0aGlzLl90cmFuc2Zvcm1NYXRyaWNlcywxNip0aGlzLmJvbmVzLmxlbmd0aCksdGhpcy5faXNEaXJ0eT0hMX19LGIucHJvdG90eXBlLmdldEFuaW1hdGFibGVzPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2FuaW1hdGFibGVzfHx0aGlzLl9hbmltYXRhYmxlcy5sZW5ndGghPXRoaXMuYm9uZXMubGVuZ3RoKXt0aGlzLl9hbmltYXRhYmxlcz1bXTtmb3IodmFyIGE9MDthPHRoaXMuYm9uZXMubGVuZ3RoO2ErKyl0aGlzLl9hbmltYXRhYmxlcy5wdXNoKHRoaXMuYm9uZXNbYV0pfXJldHVybiB0aGlzLl9hbmltYXRhYmxlc30sYi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYixjKXtmb3IodmFyIGQ9bmV3IGEuU2tlbGV0b24oYixjfHxiLHRoaXMuX3NjZW5lKSxlPTA7ZTx0aGlzLmJvbmVzLmxlbmd0aDtlKyspe3ZhciBmPXRoaXMuYm9uZXNbZV0sZz1udWxsO2lmKGYuZ2V0UGFyZW50KCkpe3ZhciBoPXRoaXMuYm9uZXMuaW5kZXhPZihmLmdldFBhcmVudCgpKTtnPWQuYm9uZXNbaF19dmFyIGk9bmV3IGEuQm9uZShmLm5hbWUsZCxnLGYuZ2V0QmFzZU1hdHJpeCgpKTthLlRvb2xzLkRlZXBDb3B5KGYuYW5pbWF0aW9ucyxpLmFuaW1hdGlvbnMpfXJldHVybiBkfSxifSgpO2EuU2tlbGV0b249Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnLGgsaSxqKXt0aGlzLm5hbWU9Yix0aGlzLndpZHRoPS0xLHRoaXMuaGVpZ2h0PS0xLHRoaXMuX3JldXNhYmxlPSExLHRoaXMuX3RleHR1cmVzPW5ldyBhLlNtYXJ0QXJyYXkoMiksdGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQ9MCxudWxsIT1nPyh0aGlzLl9jYW1lcmE9Zyx0aGlzLl9zY2VuZT1nLmdldFNjZW5lKCksZy5hdHRhY2hQb3N0UHJvY2Vzcyh0aGlzKSx0aGlzLl9lbmdpbmU9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCkpOnRoaXMuX2VuZ2luZT1pLHRoaXMuX3JlbmRlclJhdGlvPWYsdGhpcy5yZW5kZXJUYXJnZXRTYW1wbGluZ01vZGU9aD9oOmEuVGV4dHVyZS5ORUFSRVNUX1NBTVBMSU5HTU9ERSx0aGlzLl9yZXVzYWJsZT1qfHwhMSxlPWV8fFtdLGUucHVzaChcInRleHR1cmVTYW1wbGVyXCIpLHRoaXMuX2VmZmVjdD10aGlzLl9lbmdpbmUuY3JlYXRlRWZmZWN0KHt2ZXJ0ZXg6XCJwb3N0cHJvY2Vzc1wiLGZyYWdtZW50OmN9LFtcInBvc2l0aW9uXCJdLGR8fFtdLGUsXCJcIil9cmV0dXJuIGIucHJvdG90eXBlLmlzUmV1c2FibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmV1c2FibGV9LGIucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGEsYil7YT1hfHx0aGlzLl9jYW1lcmE7dmFyIGM9YS5nZXRTY2VuZSgpLGQ9KGI/Yi5fd2lkdGg6dGhpcy5fZW5naW5lLmdldFJlbmRlcmluZ0NhbnZhcygpLndpZHRoKSp0aGlzLl9yZW5kZXJSYXRpbyxlPShiP2IuX2hlaWdodDp0aGlzLl9lbmdpbmUuZ2V0UmVuZGVyaW5nQ2FudmFzKCkuaGVpZ2h0KSp0aGlzLl9yZW5kZXJSYXRpbztpZih0aGlzLndpZHRoIT09ZHx8dGhpcy5oZWlnaHQhPT1lKXtpZih0aGlzLl90ZXh0dXJlcy5sZW5ndGg+MCl7Zm9yKHZhciBmPTA7Zjx0aGlzLl90ZXh0dXJlcy5sZW5ndGg7ZisrKXRoaXMuX2VuZ2luZS5fcmVsZWFzZVRleHR1cmUodGhpcy5fdGV4dHVyZXMuZGF0YVtmXSk7dGhpcy5fdGV4dHVyZXMucmVzZXQoKX10aGlzLndpZHRoPWQsdGhpcy5oZWlnaHQ9ZSx0aGlzLl90ZXh0dXJlcy5wdXNoKHRoaXMuX2VuZ2luZS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKHt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH0se2dlbmVyYXRlTWlwTWFwczohMSxnZW5lcmF0ZURlcHRoQnVmZmVyOmEuX3Bvc3RQcm9jZXNzZXMuaW5kZXhPZih0aGlzKT09PWEuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbMF0sc2FtcGxpbmdNb2RlOnRoaXMucmVuZGVyVGFyZ2V0U2FtcGxpbmdNb2RlfSkpLHRoaXMuX3JldXNhYmxlJiZ0aGlzLl90ZXh0dXJlcy5wdXNoKHRoaXMuX2VuZ2luZS5jcmVhdGVSZW5kZXJUYXJnZXRUZXh0dXJlKHt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH0se2dlbmVyYXRlTWlwTWFwczohMSxnZW5lcmF0ZURlcHRoQnVmZmVyOmEuX3Bvc3RQcm9jZXNzZXMuaW5kZXhPZih0aGlzKT09PWEuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbMF0sc2FtcGxpbmdNb2RlOnRoaXMucmVuZGVyVGFyZ2V0U2FtcGxpbmdNb2RlfSkpLHRoaXMub25TaXplQ2hhbmdlZCYmdGhpcy5vblNpemVDaGFuZ2VkKCl9dGhpcy5fZW5naW5lLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl90ZXh0dXJlcy5kYXRhW3RoaXMuX2N1cnJlbnRSZW5kZXJUZXh0dXJlSW5kXSksdGhpcy5vbkFjdGl2YXRlJiZ0aGlzLm9uQWN0aXZhdGUoYSksdGhpcy5fZW5naW5lLmNsZWFyKGMuY2xlYXJDb2xvcixjLmF1dG9DbGVhcnx8Yy5mb3JjZVdpcmVmcmFtZSwhMCksdGhpcy5fcmV1c2FibGUmJih0aGlzLl9jdXJyZW50UmVuZGVyVGV4dHVyZUluZD0odGhpcy5fY3VycmVudFJlbmRlclRleHR1cmVJbmQrMSklMil9LGIucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VmZmVjdC5pc1JlYWR5KCk/KHRoaXMuX2VuZ2luZS5lbmFibGVFZmZlY3QodGhpcy5fZWZmZWN0KSx0aGlzLl9lbmdpbmUuc2V0U3RhdGUoITEpLHRoaXMuX2VuZ2luZS5zZXRBbHBoYU1vZGUoYS5FbmdpbmUuQUxQSEFfRElTQUJMRSksdGhpcy5fZW5naW5lLnNldERlcHRoQnVmZmVyKCExKSx0aGlzLl9lbmdpbmUuc2V0RGVwdGhXcml0ZSghMSksdGhpcy5fZWZmZWN0Ll9iaW5kVGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsdGhpcy5fdGV4dHVyZXMuZGF0YVt0aGlzLl9jdXJyZW50UmVuZGVyVGV4dHVyZUluZF0pLHRoaXMub25BcHBseSYmdGhpcy5vbkFwcGx5KHRoaXMuX2VmZmVjdCksdGhpcy5fZWZmZWN0KTpudWxsfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKGEpe2lmKGE9YXx8dGhpcy5fY2FtZXJhLHRoaXMuX3RleHR1cmVzLmxlbmd0aD4wKXtmb3IodmFyIGI9MDtiPHRoaXMuX3RleHR1cmVzLmxlbmd0aDtiKyspdGhpcy5fZW5naW5lLl9yZWxlYXNlVGV4dHVyZSh0aGlzLl90ZXh0dXJlcy5kYXRhW2JdKTt0aGlzLl90ZXh0dXJlcy5yZXNldCgpfWEuZGV0YWNoUG9zdFByb2Nlc3ModGhpcyk7dmFyIGM9YS5fcG9zdFByb2Nlc3Nlcy5pbmRleE9mKHRoaXMpO2M9PT1hLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzWzBdJiZhLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzLmxlbmd0aD4wJiYodGhpcy5fY2FtZXJhLl9wb3N0UHJvY2Vzc2VzW2EuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbMF1dLndpZHRoPS0xKX0sYn0oKTthLlBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzLl92ZXJ0ZXhEZWNsYXJhdGlvbj1bMl0sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZT04LHRoaXMuX3NjZW5lPWE7dmFyIGI9W107Yi5wdXNoKDEsMSksYi5wdXNoKC0xLDEpLGIucHVzaCgtMSwtMSksYi5wdXNoKDEsLTEpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1hLmdldEVuZ2luZSgpLmNyZWF0ZVZlcnRleEJ1ZmZlcihiKTt2YXIgYz1bXTtjLnB1c2goMCksYy5wdXNoKDEpLGMucHVzaCgyKSxjLnB1c2goMCksYy5wdXNoKDIpLGMucHVzaCgzKSx0aGlzLl9pbmRleEJ1ZmZlcj1hLmdldEVuZ2luZSgpLmNyZWF0ZUluZGV4QnVmZmVyKGMpfXJldHVybiBhLnByb3RvdHlwZS5fcHJlcGFyZUZyYW1lPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5fcG9zdFByb2Nlc3NlcyxjPXRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5fcG9zdFByb2Nlc3Nlc1Rha2VuSW5kaWNlcztyZXR1cm4gMCE9PWMubGVuZ3RoJiZ0aGlzLl9zY2VuZS5wb3N0UHJvY2Vzc2VzRW5hYmxlZD8oYlt0aGlzLl9zY2VuZS5hY3RpdmVDYW1lcmEuX3Bvc3RQcm9jZXNzZXNUYWtlbkluZGljZXNbMF1dLmFjdGl2YXRlKHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYSxhKSwhMCk6ITF9LGEucHJvdG90eXBlLl9maW5hbGl6ZUZyYW1lPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLl9wb3N0UHJvY2Vzc2VzLGQ9dGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhLl9wb3N0UHJvY2Vzc2VzVGFrZW5JbmRpY2VzO2lmKDAhPT1kLmxlbmd0aCYmdGhpcy5fc2NlbmUucG9zdFByb2Nlc3Nlc0VuYWJsZWQpe2Zvcih2YXIgZT10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKSxmPTA7ZjxkLmxlbmd0aCYmKGY8ZC5sZW5ndGgtMT9jW2RbZisxXV0uYWN0aXZhdGUodGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhKTpiP2UuYmluZEZyYW1lYnVmZmVyKGIpOmUucmVzdG9yZURlZmF1bHRGcmFtZWJ1ZmZlcigpLCFhKTtmKyspe3ZhciBnPWNbZFtmXV0uYXBwbHkoKTtnJiYoZS5iaW5kQnVmZmVycyh0aGlzLl92ZXJ0ZXhCdWZmZXIsdGhpcy5faW5kZXhCdWZmZXIsdGhpcy5fdmVydGV4RGVjbGFyYXRpb24sdGhpcy5fdmVydGV4U3RyaWRlU2l6ZSxnKSxlLmRyYXcoITAsMCw2KSl9ZS5zZXREZXB0aEJ1ZmZlcighMCksZS5zZXREZXB0aFdyaXRlKCEwKX19LGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl92ZXJ0ZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1udWxsKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKSx0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKX0sYX0oKTthLlBvc3RQcm9jZXNzTWFuYWdlcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7YS5jYWxsKHRoaXMsYixcInBhc3NcIixudWxsLG51bGwsYyxkLGUsZixnKX1yZXR1cm4gX19leHRlbmRzKGIsYSksYn0oYS5Qb3N0UHJvY2Vzcyk7YS5QYXNzUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUsZixnLGgsaSxqKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgaCYmKGg9YS5UZXh0dXJlLkJJTElORUFSX1NBTVBMSU5HTU9ERSk7dmFyIGs9dGhpcztiLmNhbGwodGhpcyxjLFwiYmx1clwiLFtcInNjcmVlblNpemVcIixcImRpcmVjdGlvblwiLFwiYmx1cldpZHRoXCJdLG51bGwsZixnLGgsaSxqKSx0aGlzLmRpcmVjdGlvbj1kLHRoaXMuYmx1cldpZHRoPWUsdGhpcy5vbkFwcGx5PWZ1bmN0aW9uKGEpe2Euc2V0RmxvYXQyKFwic2NyZWVuU2l6ZVwiLGsud2lkdGgsay5oZWlnaHQpLGEuc2V0VmVjdG9yMihcImRpcmVjdGlvblwiLGsuZGlyZWN0aW9uKSxhLnNldEZsb2F0KFwiYmx1cldpZHRoXCIsay5ibHVyV2lkdGgpfX1yZXR1cm4gX19leHRlbmRzKGMsYiksY30oYS5Qb3N0UHJvY2Vzcyk7YS5CbHVyUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpczthLmNhbGwodGhpcyxiLFwiZmlsdGVyXCIsW1wia2VybmVsTWF0cml4XCJdLG51bGwsZCxlLGYsZyxoKSx0aGlzLmtlcm5lbE1hdHJpeD1jLHRoaXMub25BcHBseT1mdW5jdGlvbihhKXthLnNldE1hdHJpeChcImtlcm5lbE1hdHJpeFwiLGkua2VybmVsTWF0cml4KX19cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGJ9KGEuUG9zdFByb2Nlc3MpO2EuRmlsdGVyUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUsZixnLGgsaSxqLGssbCl7dmFyIG09dGhpcztiLmNhbGwodGhpcyxjLFwicmVmcmFjdGlvblwiLFtcImJhc2VDb2xvclwiLFwiZGVwdGhcIixcImNvbG9yTGV2ZWxcIl0sW1wicmVmcmFjdGlvblNhbXBsZXJcIl0saCxpLGosayxsKSx0aGlzLmNvbG9yPWUsdGhpcy5kZXB0aD1mLHRoaXMuY29sb3JMZXZlbD1nLHRoaXMub25BY3RpdmF0ZT1mdW5jdGlvbihiKXttLl9yZWZSZXh0dXJlPW0uX3JlZlJleHR1cmV8fG5ldyBhLlRleHR1cmUoZCxiLmdldFNjZW5lKCkpfSx0aGlzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRDb2xvcjMoXCJiYXNlQ29sb3JcIixtLmNvbG9yKSxhLnNldEZsb2F0KFwiZGVwdGhcIixtLmRlcHRoKSxhLnNldEZsb2F0KFwiY29sb3JMZXZlbFwiLG0uY29sb3JMZXZlbCksYS5zZXRUZXh0dXJlKFwicmVmcmFjdGlvblNhbXBsZXJcIixtLl9yZWZSZXh0dXJlKX19cmV0dXJuIF9fZXh0ZW5kcyhjLGIpLGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7dGhpcy5fcmVmUmV4dHVyZSYmdGhpcy5fcmVmUmV4dHVyZS5kaXNwb3NlKCksYi5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsYSl9LGN9KGEuUG9zdFByb2Nlc3MpO2EuUmVmcmFjdGlvblBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnKXthLmNhbGwodGhpcyxiLFwiYmxhY2tBbmRXaGl0ZVwiLG51bGwsbnVsbCxjLGQsZSxmLGcpfXJldHVybiBfX2V4dGVuZHMoYixhKSxifShhLlBvc3RQcm9jZXNzKTthLkJsYWNrQW5kV2hpdGVQb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyxoKXt2YXIgaT10aGlzO2EuY2FsbCh0aGlzLGIsXCJjb252b2x1dGlvblwiLFtcImtlcm5lbFwiLFwic2NyZWVuU2l6ZVwiXSxudWxsLGQsZSxmLGcsaCksdGhpcy5rZXJuZWw9Yyx0aGlzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRGbG9hdDIoXCJzY3JlZW5TaXplXCIsaS53aWR0aCxpLmhlaWdodCksYS5zZXRBcnJheShcImtlcm5lbFwiLGkua2VybmVsKX19cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIuRWRnZURldGVjdDBLZXJuZWw9WzEsMCwtMSwwLDAsMCwtMSwwLDFdLGIuRWRnZURldGVjdDFLZXJuZWw9WzAsMSwwLDEsLTQsMSwwLDEsMF0sYi5FZGdlRGV0ZWN0Mktlcm5lbD1bLTEsLTEsLTEsLTEsOCwtMSwtMSwtMSwtMV0sYi5TaGFycGVuS2VybmVsPVswLC0xLDAsLTEsNSwtMSwwLC0xLDBdLGIuRW1ib3NzS2VybmVsPVstMiwtMSwwLC0xLDEsMSwwLDEsMl0sYi5HYXVzc2lhbktlcm5lbD1bMCwxLDAsMSwxLDEsMCwxLDBdLGJ9KGEuUG9zdFByb2Nlc3MpO2EuQ29udm9sdXRpb25Qb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7dmFyIGg9dGhpczthLmNhbGwodGhpcyxiLFwiZnhhYVwiLFtcInRleGVsU2l6ZVwiXSxudWxsLGMsZCxlLGYsZyksdGhpcy5vblNpemVDaGFuZ2VkPWZ1bmN0aW9uKCl7aC50ZXhlbFdpZHRoPTEvaC53aWR0aCxoLnRleGVsSGVpZ2h0PTEvaC5oZWlnaHR9LHRoaXMub25BcHBseT1mdW5jdGlvbihhKXthLnNldEZsb2F0MihcInRleGVsU2l6ZVwiLGgudGV4ZWxXaWR0aCxoLnRleGVsSGVpZ2h0KX19cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGJ9KGEuUG9zdFByb2Nlc3MpO2EuRnhhYVBvc3RQcm9jZXNzPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlLGYpe3RoaXMuc2l6ZT1iLHRoaXMucG9zaXRpb249Yyx0aGlzLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLnRleHR1cmUmJnRoaXMudGV4dHVyZS5kaXNwb3NlKCk7dmFyIGE9dGhpcy5fc3lzdGVtLmxlbnNGbGFyZXMuaW5kZXhPZih0aGlzKTt0aGlzLl9zeXN0ZW0ubGVuc0ZsYXJlcy5zcGxpY2UoYSwxKX0sdGhpcy5jb2xvcj1kfHxuZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMudGV4dHVyZT1lP25ldyBhLlRleHR1cmUoZSxmLmdldFNjZW5lKCksITApOm51bGwsdGhpcy5fc3lzdGVtPWYsZi5sZW5zRmxhcmVzLnB1c2godGhpcyl9cmV0dXJuIGJ9KCk7YS5MZW5zRmxhcmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYixjKXt0aGlzLm5hbWU9YSx0aGlzLmxlbnNGbGFyZXM9bmV3IEFycmF5LHRoaXMuYm9yZGVyTGltaXQ9MzAwLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uPVsyXSx0aGlzLl92ZXJ0ZXhTdHJpZGVTaXplPTgsdGhpcy5faXNFbmFibGVkPSEwLHRoaXMuX3NjZW5lPWMsdGhpcy5fZW1pdHRlcj1iLGMubGVuc0ZsYXJlU3lzdGVtcy5wdXNoKHRoaXMpLHRoaXMubWVzaGVzU2VsZWN0aW9uUHJlZGljYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBhLm1hdGVyaWFsJiZhLmlzVmlzaWJsZSYmYS5pc0VuYWJsZWQoKSYmYS5jaGVja0NvbGxpc2lvbnMmJjAhPShhLmxheWVyTWFzayZjLmFjdGl2ZUNhbWVyYS5sYXllck1hc2spfTt2YXIgZD1bXTtkLnB1c2goMSwxKSxkLnB1c2goLTEsMSksZC5wdXNoKC0xLC0xKSxkLnB1c2goMSwtMSksdGhpcy5fdmVydGV4QnVmZmVyPWMuZ2V0RW5naW5lKCkuY3JlYXRlVmVydGV4QnVmZmVyKGQpO3ZhciBlPVtdO2UucHVzaCgwKSxlLnB1c2goMSksZS5wdXNoKDIpLGUucHVzaCgwKSxlLnB1c2goMiksZS5wdXNoKDMpLHRoaXMuX2luZGV4QnVmZmVyPWMuZ2V0RW5naW5lKCkuY3JlYXRlSW5kZXhCdWZmZXIoZSksdGhpcy5fZWZmZWN0PXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLmNyZWF0ZUVmZmVjdChcImxlbnNGbGFyZVwiLFtcInBvc2l0aW9uXCJdLFtcImNvbG9yXCIsXCJ2aWV3cG9ydE1hdHJpeFwiXSxbXCJ0ZXh0dXJlU2FtcGxlclwiXSxcIlwiKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiaXNFbmFibGVkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0VuYWJsZWR9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9pc0VuYWJsZWQ9YX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLnByb3RvdHlwZS5nZXRTY2VuZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY2VuZX0sYi5wcm90b3R5cGUuZ2V0RW1pdHRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbWl0dGVyfSxiLnByb3RvdHlwZS5nZXRFbWl0dGVyUG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW1pdHRlci5nZXRBYnNvbHV0ZVBvc2l0aW9uP3RoaXMuX2VtaXR0ZXIuZ2V0QWJzb2x1dGVQb3NpdGlvbigpOnRoaXMuX2VtaXR0ZXIucG9zaXRpb259LGIucHJvdG90eXBlLmNvbXB1dGVFZmZlY3RpdmVQb3NpdGlvbj1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmdldEVtaXR0ZXJQb3NpdGlvbigpO3JldHVybiBjPWEuVmVjdG9yMy5Qcm9qZWN0KGMsYS5NYXRyaXguSWRlbnRpdHkoKSx0aGlzLl9zY2VuZS5nZXRUcmFuc2Zvcm1NYXRyaXgoKSxiKSx0aGlzLl9wb3NpdGlvblg9Yy54LHRoaXMuX3Bvc2l0aW9uWT1jLnksYz1hLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXModGhpcy5nZXRFbWl0dGVyUG9zaXRpb24oKSx0aGlzLl9zY2VuZS5nZXRWaWV3TWF0cml4KCkpLGMuej4wJiZ0aGlzLl9wb3NpdGlvblg+Yi54JiZ0aGlzLl9wb3NpdGlvblg8Yi54K2Iud2lkdGgmJnRoaXMuX3Bvc2l0aW9uWT5iLnkmJnRoaXMuX3Bvc2l0aW9uWTxiLnkrYi5oZWlnaHQ/ITA6ITF9LGIucHJvdG90eXBlLl9pc1Zpc2libGU9ZnVuY3Rpb24oKXtpZighdGhpcy5faXNFbmFibGVkKXJldHVybiExO3ZhciBiPXRoaXMuZ2V0RW1pdHRlclBvc2l0aW9uKCksYz1iLnN1YnRyYWN0KHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbiksZD1jLmxlbmd0aCgpO2Mubm9ybWFsaXplKCk7dmFyIGU9bmV3IGEuUmF5KHRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS5wb3NpdGlvbixjKSxmPXRoaXMuX3NjZW5lLnBpY2tXaXRoUmF5KGUsdGhpcy5tZXNoZXNTZWxlY3Rpb25QcmVkaWNhdGUsITApO3JldHVybiFmLmhpdHx8Zi5kaXN0YW5jZT5kfSxiLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtpZighdGhpcy5fZWZmZWN0LmlzUmVhZHkoKSlyZXR1cm4hMTt2YXIgYj10aGlzLl9zY2VuZS5nZXRFbmdpbmUoKSxjPXRoaXMuX3NjZW5lLmFjdGl2ZUNhbWVyYS52aWV3cG9ydCxkPWMudG9HbG9iYWwoYik7aWYoIXRoaXMuY29tcHV0ZUVmZmVjdGl2ZVBvc2l0aW9uKGQpKXJldHVybiExO2lmKCF0aGlzLl9pc1Zpc2libGUoKSlyZXR1cm4hMTt2YXIgZSxmO2U9dGhpcy5fcG9zaXRpb25YPHRoaXMuYm9yZGVyTGltaXQrZC54P3RoaXMuYm9yZGVyTGltaXQrZC54LXRoaXMuX3Bvc2l0aW9uWDp0aGlzLl9wb3NpdGlvblg+ZC54K2Qud2lkdGgtdGhpcy5ib3JkZXJMaW1pdD90aGlzLl9wb3NpdGlvblgtZC54LWQud2lkdGgrdGhpcy5ib3JkZXJMaW1pdDowLGY9dGhpcy5fcG9zaXRpb25ZPHRoaXMuYm9yZGVyTGltaXQrZC55P3RoaXMuYm9yZGVyTGltaXQrZC55LXRoaXMuX3Bvc2l0aW9uWTp0aGlzLl9wb3NpdGlvblk+ZC55K2QuaGVpZ2h0LXRoaXMuYm9yZGVyTGltaXQ/dGhpcy5fcG9zaXRpb25ZLWQueS1kLmhlaWdodCt0aGlzLmJvcmRlckxpbWl0OjA7dmFyIGc9ZT5mP2U6ZjtnPnRoaXMuYm9yZGVyTGltaXQmJihnPXRoaXMuYm9yZGVyTGltaXQpO3ZhciBoPTEtZy90aGlzLmJvcmRlckxpbWl0O2lmKDA+aClyZXR1cm4hMTtoPjEmJihoPTEpO3ZhciBpPWQueCtkLndpZHRoLzIsaj1kLnkrZC5oZWlnaHQvMixrPWktdGhpcy5fcG9zaXRpb25YLGw9ai10aGlzLl9wb3NpdGlvblk7Yi5lbmFibGVFZmZlY3QodGhpcy5fZWZmZWN0KSxiLnNldFN0YXRlKCExKSxiLnNldERlcHRoQnVmZmVyKCExKSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9BREQpLGIuYmluZEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLHRoaXMuX2luZGV4QnVmZmVyLHRoaXMuX3ZlcnRleERlY2xhcmF0aW9uLHRoaXMuX3ZlcnRleFN0cmlkZVNpemUsdGhpcy5fZWZmZWN0KTtmb3IodmFyIG09MDttPHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7bSsrKXt2YXIgbj10aGlzLmxlbnNGbGFyZXNbbV0sbz1pLWsqbi5wb3NpdGlvbixwPWotbCpuLnBvc2l0aW9uLHE9bi5zaXplLHI9bi5zaXplKmIuZ2V0QXNwZWN0UmF0aW8odGhpcy5fc2NlbmUuYWN0aXZlQ2FtZXJhKSxzPTIqKG8vZC53aWR0aCktMSx0PTEtMioocC9kLmhlaWdodCksdT1hLk1hdHJpeC5Gcm9tVmFsdWVzKHEvMiwwLDAsMCwwLHIvMiwwLDAsMCwwLDEsMCxzLHQsMCwxKTt0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwidmlld3BvcnRNYXRyaXhcIix1KSx0aGlzLl9lZmZlY3Quc2V0VGV4dHVyZShcInRleHR1cmVTYW1wbGVyXCIsbi50ZXh0dXJlKSx0aGlzLl9lZmZlY3Quc2V0RmxvYXQ0KFwiY29sb3JcIixuLmNvbG9yLnIqaCxuLmNvbG9yLmcqaCxuLmNvbG9yLmIqaCwxKSxiLmRyYXcoITAsMCw2KVxufXJldHVybiBiLnNldERlcHRoQnVmZmVyKCEwKSxiLnNldEFscGhhTW9kZShhLkVuZ2luZS5BTFBIQV9ESVNBQkxFKSwhMH0sYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih0aGlzLl92ZXJ0ZXhCdWZmZXImJih0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpLHRoaXMuX3ZlcnRleEJ1ZmZlcj1udWxsKSx0aGlzLl9pbmRleEJ1ZmZlciYmKHRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLl9yZWxlYXNlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKSx0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKTt0aGlzLmxlbnNGbGFyZXMubGVuZ3RoOyl0aGlzLmxlbnNGbGFyZXNbMF0uZGlzcG9zZSgpO3ZhciBhPXRoaXMuX3NjZW5lLmxlbnNGbGFyZVN5c3RlbXMuaW5kZXhPZih0aGlzKTt0aGlzLl9zY2VuZS5sZW5zRmxhcmVTeXN0ZW1zLnNwbGljZShhLDEpfSxifSgpO2EuTGVuc0ZsYXJlU3lzdGVtPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyl7dGhpcy5idT1hLHRoaXMuYnY9Yix0aGlzLmRpc3RhbmNlPWMsdGhpcy5mYWNlSWQ9MH1yZXR1cm4gYX0oKTthLkludGVyc2VjdGlvbkluZm89Yjt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt0aGlzLmhpdD0hMSx0aGlzLmRpc3RhbmNlPTAsdGhpcy5waWNrZWRQb2ludD1udWxsLHRoaXMucGlja2VkTWVzaD1udWxsLHRoaXMuYnU9MCx0aGlzLmJ2PTAsdGhpcy5mYWNlSWQ9LTF9cmV0dXJuIGIucHJvdG90eXBlLmdldE5vcm1hbD1mdW5jdGlvbigpe2lmKCF0aGlzLnBpY2tlZE1lc2h8fCF0aGlzLnBpY2tlZE1lc2guaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpKXJldHVybiBudWxsO3ZhciBiPXRoaXMucGlja2VkTWVzaC5nZXRJbmRpY2VzKCksYz10aGlzLnBpY2tlZE1lc2guZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpLGQ9YS5WZWN0b3IzLkZyb21BcnJheShjLDMqYlszKnRoaXMuZmFjZUlkXSksZT1hLlZlY3RvcjMuRnJvbUFycmF5KGMsMypiWzMqdGhpcy5mYWNlSWQrMV0pLGY9YS5WZWN0b3IzLkZyb21BcnJheShjLDMqYlszKnRoaXMuZmFjZUlkKzJdKTtyZXR1cm4gZD1kLnNjYWxlKHRoaXMuYnUpLGU9ZS5zY2FsZSh0aGlzLmJ2KSxmPWYuc2NhbGUoMS10aGlzLmJ1LXRoaXMuYnYpLG5ldyBhLlZlY3RvcjMoZC54K2UueCtmLngsZC55K2UueStmLnksZC56K2UueitmLnopfSxiLnByb3RvdHlwZS5nZXRUZXh0dXJlQ29vcmRpbmF0ZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5waWNrZWRNZXNofHwhdGhpcy5waWNrZWRNZXNoLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVktpbmQpKXJldHVybiBudWxsO3ZhciBiPXRoaXMucGlja2VkTWVzaC5nZXRJbmRpY2VzKCksYz10aGlzLnBpY2tlZE1lc2guZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWS2luZCksZD1hLlZlY3RvcjIuRnJvbUFycmF5KGMsMipiWzMqdGhpcy5mYWNlSWRdKSxlPWEuVmVjdG9yMi5Gcm9tQXJyYXkoYywyKmJbMyp0aGlzLmZhY2VJZCsxXSksZj1hLlZlY3RvcjIuRnJvbUFycmF5KGMsMipiWzMqdGhpcy5mYWNlSWQrMl0pO3JldHVybiBkPWQuc2NhbGUodGhpcy5idSksZT1lLnNjYWxlKHRoaXMuYnYpLGY9Zi5zY2FsZSgxLXRoaXMuYnUtdGhpcy5idiksbmV3IGEuVmVjdG9yMihkLngrZS54K2YueCxkLnkrZS55K2YueSl9LGJ9KCk7YS5QaWNraW5nSW5mbz1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMsZCxlLGYsZyxoKXt0aGlzLmVuZ2luZT1hLHRoaXMuY2FudmFzPWMsdGhpcy5jdXJyZW50U2NlbmU9Yix0aGlzLnNjZW5lTG9hZGVkQ2FsbGJhY2s9ZCx0aGlzLnByb2dyZXNzQ2FsbGJhY2s9ZSx0aGlzLmFkZGl0aW9ubmFsUmVuZGVyTG9vcExvZ2ljQ2FsbGJhY2s9Zix0aGlzLnRleHR1cmVMb2FkaW5nQ2FsbGJhY2s9Zyx0aGlzLnN0YXJ0aW5nUHJvY2Vzc2luZ0ZpbGVzQ2FsbGJhY2s9aH1yZXR1cm4gYi5wcm90b3R5cGUubW9uaXRvckVsZW1lbnRGb3JEcmFnTkRyb3A9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthJiYodGhpcy5lbGVtZW50VG9Nb25pdG9yPWEsdGhpcy5lbGVtZW50VG9Nb25pdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIixmdW5jdGlvbihhKXtiLmRyYWcoYSl9LCExKSx0aGlzLmVsZW1lbnRUb01vbml0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsZnVuY3Rpb24oYSl7Yi5kcmFnKGEpfSwhMSksdGhpcy5lbGVtZW50VG9Nb25pdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsZnVuY3Rpb24oYSl7Yi5kcm9wKGEpfSwhMSkpfSxiLnByb3RvdHlwZS5yZW5kZXJGdW5jdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuYWRkaXRpb25uYWxSZW5kZXJMb29wTG9naWNDYWxsYmFjayYmdGhpcy5hZGRpdGlvbm5hbFJlbmRlckxvb3BMb2dpY0NhbGxiYWNrKCksdGhpcy5jdXJyZW50U2NlbmUpe2lmKHRoaXMudGV4dHVyZUxvYWRpbmdDYWxsYmFjayl7dmFyIGE9dGhpcy5jdXJyZW50U2NlbmUuZ2V0V2FpdGluZ0l0ZW1zQ291bnQoKTthPjAmJnRoaXMudGV4dHVyZUxvYWRpbmdDYWxsYmFjayhhKX10aGlzLmN1cnJlbnRTY2VuZS5yZW5kZXIoKX19LGIucHJvdG90eXBlLmRyYWc9ZnVuY3Rpb24oYSl7YS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCl9LGIucHJvdG90eXBlLmRyb3A9ZnVuY3Rpb24oYSl7YS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCksdGhpcy5sb2FkRmlsZXMoYSl9LGIucHJvdG90eXBlLmxvYWRGaWxlcz1mdW5jdGlvbihiKXt2YXIgYz10aGlzLGQ9dGhpczt0aGlzLnN0YXJ0aW5nUHJvY2Vzc2luZ0ZpbGVzQ2FsbGJhY2smJnRoaXMuc3RhcnRpbmdQcm9jZXNzaW5nRmlsZXNDYWxsYmFjaygpO3ZhciBlLGY7aWYoYiYmYi5kYXRhVHJhbnNmZXImJmIuZGF0YVRyYW5zZmVyLmZpbGVzJiYoZj1iLmRhdGFUcmFuc2Zlci5maWxlcyksYiYmYi50YXJnZXQmJmIudGFyZ2V0LmZpbGVzJiYoZj1iLnRhcmdldC5maWxlcyksZiYmZi5sZW5ndGg+MCl7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspc3dpdGNoKGZbZ10udHlwZSl7Y2FzZVwiaW1hZ2UvanBlZ1wiOmNhc2VcImltYWdlL3BuZ1wiOmEuRmlsZXNJbnB1dC5GaWxlc1RleHR1cmVzW2ZbZ10ubmFtZV09ZltnXTticmVhaztjYXNlXCJpbWFnZS90YXJnYVwiOmNhc2VcImltYWdlL3ZuZC5tcy1kZHNcIjphLkZpbGVzSW5wdXQuRmlsZXNUb0xvYWRbZltnXS5uYW1lXT1mW2ddO2JyZWFrO2RlZmF1bHQ6LTEhPT1mW2ddLm5hbWUuaW5kZXhPZihcIi5iYWJ5bG9uXCIpJiYtMT09PWZbZ10ubmFtZS5pbmRleE9mKFwiLm1hbmlmZXN0XCIpJiYtMT09PWZbZ10ubmFtZS5pbmRleE9mKFwiLmluY3JlbWVudGFsXCIpJiYtMT09PWZbZ10ubmFtZS5pbmRleE9mKFwiLmJhYnlsb25tZXNoZGF0YVwiKSYmLTE9PT1mW2ddLm5hbWUuaW5kZXhPZihcIi5iYWJ5bG9uZ2VvbWV0cnlkYXRhXCIpJiYoZT1mW2ddKX1lPyh0aGlzLmN1cnJlbnRTY2VuZSYmKHRoaXMuZW5naW5lLnN0b3BSZW5kZXJMb29wKCksdGhpcy5jdXJyZW50U2NlbmUuZGlzcG9zZSgpKSxhLlNjZW5lTG9hZGVyLkxvYWQoXCJmaWxlOlwiLGUsdGhpcy5lbmdpbmUsZnVuY3Rpb24oYSl7ZC5jdXJyZW50U2NlbmU9YSxkLmN1cnJlbnRTY2VuZS5leGVjdXRlV2hlblJlYWR5KGZ1bmN0aW9uKCl7ZC5jdXJyZW50U2NlbmUuYWN0aXZlQ2FtZXJhJiZkLmN1cnJlbnRTY2VuZS5hY3RpdmVDYW1lcmEuYXR0YWNoQ29udHJvbChkLmNhbnZhcyksZC5zY2VuZUxvYWRlZENhbGxiYWNrJiZkLnNjZW5lTG9hZGVkQ2FsbGJhY2soZSxkLmN1cnJlbnRTY2VuZSksZC5lbmdpbmUucnVuUmVuZGVyTG9vcChmdW5jdGlvbigpe2QucmVuZGVyRnVuY3Rpb24oKX0pfSl9LGZ1bmN0aW9uKGEpe2MucHJvZ3Jlc3NDYWxsYmFjayYmYy5wcm9ncmVzc0NhbGxiYWNrKGEpfSkpOmEuVG9vbHMuRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIC5iYWJ5bG9uIGZpbGUuXCIpfX0sYi5GaWxlc1RleHR1cmVzPW5ldyBBcnJheSxiLkZpbGVzVG9Mb2FkPW5ldyBBcnJheSxifSgpO2EuRmlsZXNJbnB1dD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt0aGlzLl9yZWdpc3RlcmVkTWVzaGVzPVtdLHRoaXMudXBkYXRlQm9keVBvc2l0aW9uPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2JdO2lmKGMubWVzaD09PWF8fGMubWVzaD09PWEucGFyZW50KXt2YXIgZD1jLmJvZHkuYm9keTtyZXR1cm4gZC5zZXRQb3NpdGlvbihhLnBvc2l0aW9uLngsYS5wb3NpdGlvbi55LGEucG9zaXRpb24ueiksdm9pZCBkLnNldE9yaWVudGF0aW9uKGEucm90YXRpb24ueCxhLnJvdGF0aW9uLnksYS5yb3RhdGlvbi56KX1pZihjLm1lc2gucGFyZW50PT09YSl7YS5jb21wdXRlV29ybGRNYXRyaXgoITApLGMubWVzaC5jb21wdXRlV29ybGRNYXRyaXgoITApO3ZhciBlPWMubWVzaC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCksZj1hLnJvdGF0aW9uO3JldHVybiBkPWMuYm9keS5ib2R5LGQuc2V0UG9zaXRpb24oZS54LGUueSxlLnopLHZvaWQgZC5zZXRPcmllbnRhdGlvbihmLngsZi55LGYueil9fX19cmV0dXJuIGIucHJvdG90eXBlLl9jaGVja1dpdGhFcHNpbG9uPWZ1bmN0aW9uKGIpe3JldHVybiBiPGEuUGh5c2ljc0VuZ2luZS5FcHNpbG9uP2EuUGh5c2ljc0VuZ2luZS5FcHNpbG9uOmJ9LGIucHJvdG90eXBlLmluaXRpYWxpemU9ZnVuY3Rpb24oKXt0aGlzLl93b3JsZD1uZXcgT0lNTy5Xb3JsZCx0aGlzLl93b3JsZC5jbGVhcigpfSxiLnByb3RvdHlwZS5zZXRHcmF2aXR5PWZ1bmN0aW9uKGEpe3RoaXMuX3dvcmxkLmdyYXZpdHk9YX0sYi5wcm90b3R5cGUucmVnaXN0ZXJNZXNoPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1udWxsO3N3aXRjaCh0aGlzLnVucmVnaXN0ZXJNZXNoKGIpLGIuY29tcHV0ZVdvcmxkTWF0cml4KCEwKSxjKXtjYXNlIGEuUGh5c2ljc0VuZ2luZS5TcGhlcmVJbXBvc3Rvcjp2YXIgZj1iLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94LGc9Zi5tYXhpbXVtV29ybGQueC1mLm1pbmltdW1Xb3JsZC54LGg9Zi5tYXhpbXVtV29ybGQueS1mLm1pbmltdW1Xb3JsZC55LGk9Zi5tYXhpbXVtV29ybGQuei1mLm1pbmltdW1Xb3JsZC56LGo9TWF0aC5tYXgodGhpcy5fY2hlY2tXaXRoRXBzaWxvbihnKSx0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGgpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oaSkpLzI7ZT1uZXcgT0lNTy5Cb2R5KHt0eXBlOlwic3BoZXJlXCIsc2l6ZTpbal0scG9zOltiLnBvc2l0aW9uLngsYi5wb3NpdGlvbi55LGIucG9zaXRpb24uel0scm90OltiLnJvdGF0aW9uLngvT0lNTy5UT19SQUQsYi5yb3RhdGlvbi55L09JTU8uVE9fUkFELGIucm90YXRpb24uei9PSU1PLlRPX1JBRF0sbW92ZTowIT1kLm1hc3MsY29uZmlnOltkLm1hc3MsZC5mcmljdGlvbixkLnJlc3RpdHV0aW9uXSx3b3JsZDp0aGlzLl93b3JsZH0pLHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMucHVzaCh7bWVzaDpiLGJvZHk6ZX0pO2JyZWFrO2Nhc2UgYS5QaHlzaWNzRW5naW5lLlBsYW5lSW1wb3N0b3I6Y2FzZSBhLlBoeXNpY3NFbmdpbmUuQm94SW1wb3N0b3I6Zj1iLmdldEJvdW5kaW5nSW5mbygpLmJvdW5kaW5nQm94O3ZhciBrPWYubWluaW11bVdvcmxkLGw9Zi5tYXhpbXVtV29ybGQsbT1sLnN1YnRyYWN0KGspLG49dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihtLngpLG89dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihtLnkpLHA9dGhpcy5fY2hlY2tXaXRoRXBzaWxvbihtLnopO2U9bmV3IE9JTU8uQm9keSh7dHlwZTpcImJveFwiLHNpemU6W24sbyxwXSxwb3M6W2IucG9zaXRpb24ueCxiLnBvc2l0aW9uLnksYi5wb3NpdGlvbi56XSxyb3Q6W2Iucm90YXRpb24ueC9PSU1PLlRPX1JBRCxiLnJvdGF0aW9uLnkvT0lNTy5UT19SQUQsYi5yb3RhdGlvbi56L09JTU8uVE9fUkFEXSxtb3ZlOjAhPWQubWFzcyxjb25maWc6W2QubWFzcyxkLmZyaWN0aW9uLGQucmVzdGl0dXRpb25dLHdvcmxkOnRoaXMuX3dvcmxkfSksdGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5wdXNoKHttZXNoOmIsYm9keTplfSl9cmV0dXJuIGV9LGIucHJvdG90eXBlLnJlZ2lzdGVyTWVzaGVzQXNDb21wb3VuZD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1bXSxkPVtdLGU9W10sZj1bXSxnPWFbMF0ubWVzaCxoPTA7aDxhLmxlbmd0aDtoKyspe3ZhciBpPWFbaF0saj10aGlzLl9jcmVhdGVCb2R5QXNDb21wb3VuZChpLGIsZyk7Yy5wdXNoKGoudHlwZSksZC5wdXNoLmFwcGx5KGQsai5zaXplKSxlLnB1c2guYXBwbHkoZSxqLnBvcyksZi5wdXNoLmFwcGx5KGYsai5yb3QpfXZhciBrPW5ldyBPSU1PLkJvZHkoe3R5cGU6YyxzaXplOmQscG9zOmUscm90OmYsbW92ZTowIT1iLm1hc3MsY29uZmlnOltiLm1hc3MsYi5mcmljdGlvbixiLnJlc3RpdHV0aW9uXSx3b3JsZDp0aGlzLl93b3JsZH0pO3JldHVybiB0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLnB1c2goe21lc2g6Zyxib2R5Omt9KSxrfSxiLnByb3RvdHlwZS5fY3JlYXRlQm9keUFzQ29tcG91bmQ9ZnVuY3Rpb24oYil7dmFyIGM9bnVsbCxkPWIubWVzaDtzd2l0Y2goYi5pbXBvc3Rvcil7Y2FzZSBhLlBoeXNpY3NFbmdpbmUuU3BoZXJlSW1wb3N0b3I6dmFyIGU9ZC5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveCxmPWUubWF4aW11bVdvcmxkLngtZS5taW5pbXVtV29ybGQueCxnPWUubWF4aW11bVdvcmxkLnktZS5taW5pbXVtV29ybGQueSxoPWUubWF4aW11bVdvcmxkLnotZS5taW5pbXVtV29ybGQueixpPU1hdGgubWF4KHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oZiksdGhpcy5fY2hlY2tXaXRoRXBzaWxvbihnKSx0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGgpKS8yO2M9e3R5cGU6XCJzcGhlcmVcIixzaXplOltpLC0xLC0xXSxwb3M6W2QucG9zaXRpb24ueCxkLnBvc2l0aW9uLnksZC5wb3NpdGlvbi56XSxyb3Q6W2Qucm90YXRpb24ueC9PSU1PLlRPX1JBRCxkLnJvdGF0aW9uLnkvT0lNTy5UT19SQUQsZC5yb3RhdGlvbi56L09JTU8uVE9fUkFEXX07YnJlYWs7Y2FzZSBhLlBoeXNpY3NFbmdpbmUuUGxhbmVJbXBvc3RvcjpjYXNlIGEuUGh5c2ljc0VuZ2luZS5Cb3hJbXBvc3RvcjplPWQuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3g7dmFyIGo9ZS5taW5pbXVtV29ybGQsaz1lLm1heGltdW1Xb3JsZCxsPWsuc3VidHJhY3QoaiksbT10aGlzLl9jaGVja1dpdGhFcHNpbG9uKGwueCksbj10aGlzLl9jaGVja1dpdGhFcHNpbG9uKGwueSksbz10aGlzLl9jaGVja1dpdGhFcHNpbG9uKGwueikscD1kLnBvc2l0aW9uO2M9e3R5cGU6XCJib3hcIixzaXplOlttLG4sb10scG9zOltwLngscC55LHAuel0scm90OltkLnJvdGF0aW9uLngvT0lNTy5UT19SQUQsZC5yb3RhdGlvbi55L09JTU8uVE9fUkFELGQucm90YXRpb24uei9PSU1PLlRPX1JBRF19fXJldHVybiBjfSxiLnByb3RvdHlwZS51bnJlZ2lzdGVyTWVzaD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tiXTtpZihjLm1lc2g9PT1hfHxjLm1lc2g9PT1hLnBhcmVudClyZXR1cm4gYy5ib2R5JiYodGhpcy5fd29ybGQucmVtb3ZlUmlnaWRCb2R5KGMuYm9keS5ib2R5KSx0aGlzLl91bmJpbmRCb2R5KGMuYm9keSkpLHZvaWQgdGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5zcGxpY2UoYiwxKX19LGIucHJvdG90eXBlLl91bmJpbmRCb2R5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2JdO2MuYm9keT09PWEmJihjLmJvZHk9bnVsbCl9fSxiLnByb3RvdHlwZS5hcHBseUltcHVsc2U9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wO2Q8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7ZCsrKXt2YXIgZT10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2RdO2lmKGUubWVzaD09PWF8fGUubWVzaD09PWEucGFyZW50KXJldHVybiB2b2lkIGUuYm9keS5ib2R5LmFwcGx5SW1wdWxzZShjLnNjYWxlKE9JTU8uSU5WX1NDQUxFKSxiLnNjYWxlKE9JTU8uSU5WX1NDQUxFKSl9fSxiLnByb3RvdHlwZS5jcmVhdGVMaW5rPWZ1bmN0aW9uKGEsYixjLGQsZSl7Zm9yKHZhciBmPW51bGwsZz1udWxsLGg9MDtoPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2grKyl7dmFyIGk9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1toXTtpLm1lc2g9PT1hP2Y9aS5ib2R5LmJvZHk6aS5tZXNoPT09YiYmKGc9aS5ib2R5LmJvZHkpfXJldHVybiBmJiZnPyhlfHwoZT17fSksbmV3IE9JTU8uTGluayh7dHlwZTplLnR5cGUsYm9keTE6Zixib2R5MjpnLG1pbjplLm1pbixtYXg6ZS5tYXgsYXhlMTplLmF4ZTEsYXhlMjplLmF4ZTIscG9zMTpbYy54LGMueSxjLnpdLHBvczI6W2QueCxkLnksZC56XSxjb2xsaXNpb246ZS5jb2xsaXNpb24sc3ByaW5nOmUuc3ByaW5nLHdvcmxkOnRoaXMuX3dvcmxkfSksITApOiExfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKHRoaXMuX3dvcmxkLmNsZWFyKCk7dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7KXRoaXMudW5yZWdpc3Rlck1lc2godGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1swXS5tZXNoKX0sYi5wcm90b3R5cGUuaXNTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09T0lNT30sYi5wcm90b3R5cGUuX2dldExhc3RTaGFwZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS5zaGFwZXM7Yi5uZXh0OyliPWIubmV4dDtyZXR1cm4gYn0sYi5wcm90b3R5cGUucnVuT25lU3RlcD1mdW5jdGlvbigpe3RoaXMuX3dvcmxkLnN0ZXAoKTtmb3IodmFyIGIsYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDtjLS07KXt2YXIgZD10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2NdLmJvZHkuYm9keSxlPXRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbY10ubWVzaDtpZighZC5zbGVlcGluZylpZihkLnNoYXBlcy5uZXh0KXt2YXIgZj10aGlzLl9nZXRMYXN0U2hhcGUoZCk7ZS5wb3NpdGlvbi54PWYucG9zaXRpb24ueCpPSU1PLldPUkxEX1NDQUxFLGUucG9zaXRpb24ueT1mLnBvc2l0aW9uLnkqT0lNTy5XT1JMRF9TQ0FMRSxlLnBvc2l0aW9uLno9Zi5wb3NpdGlvbi56Kk9JTU8uV09STERfU0NBTEU7dmFyIGc9YS5NYXRyaXguRnJvbUFycmF5KGQuZ2V0TWF0cml4KCkpO2Uucm90YXRpb25RdWF0ZXJuaW9ufHwoZS5yb3RhdGlvblF1YXRlcm5pb249bmV3IGEuUXVhdGVybmlvbigwLDAsMCwxKSksZS5yb3RhdGlvblF1YXRlcm5pb24uZnJvbVJvdGF0aW9uTWF0cml4KGcpfWVsc2UgYj1kLmdldE1hdHJpeCgpLGc9YS5NYXRyaXguRnJvbUFycmF5KGIpLGUucG9zaXRpb24ueD1nLm1bMTJdLGUucG9zaXRpb24ueT1nLm1bMTNdLGUucG9zaXRpb24uej1nLm1bMTRdLGUucm90YXRpb25RdWF0ZXJuaW9ufHwoZS5yb3RhdGlvblF1YXRlcm5pb249bmV3IGEuUXVhdGVybmlvbigwLDAsMCwxKSksZS5yb3RhdGlvblF1YXRlcm5pb24uZnJvbVJvdGF0aW9uTWF0cml4KGcpfX0sYn0oKTthLk9pbW9KU1BsdWdpbj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYil7dGhpcy5fY3VycmVudFBsdWdpbj1ifHxuZXcgYS5PaW1vSlNQbHVnaW59cmV0dXJuIGIucHJvdG90eXBlLl9pbml0aWFsaXplPWZ1bmN0aW9uKGEpe3RoaXMuX2N1cnJlbnRQbHVnaW4uaW5pdGlhbGl6ZSgpLHRoaXMuX3NldEdyYXZpdHkoYSl9LGIucHJvdG90eXBlLl9ydW5PbmVTdGVwPWZ1bmN0aW9uKGEpe2E+LjE/YT0uMTowPj1hJiYoYT0xLzYwKSx0aGlzLl9jdXJyZW50UGx1Z2luLnJ1bk9uZVN0ZXAoYSl9LGIucHJvdG90eXBlLl9zZXRHcmF2aXR5PWZ1bmN0aW9uKGIpe3RoaXMuZ3Jhdml0eT1ifHxuZXcgYS5WZWN0b3IzKDAsLTkuODIsMCksdGhpcy5fY3VycmVudFBsdWdpbi5zZXRHcmF2aXR5KHRoaXMuZ3Jhdml0eSl9LGIucHJvdG90eXBlLl9yZWdpc3Rlck1lc2g9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLl9jdXJyZW50UGx1Z2luLnJlZ2lzdGVyTWVzaChhLGIsYyl9LGIucHJvdG90eXBlLl9yZWdpc3Rlck1lc2hlc0FzQ29tcG91bmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY3VycmVudFBsdWdpbi5yZWdpc3Rlck1lc2hlc0FzQ29tcG91bmQoYSxiKX0sYi5wcm90b3R5cGUuX3VucmVnaXN0ZXJNZXNoPWZ1bmN0aW9uKGEpe3RoaXMuX2N1cnJlbnRQbHVnaW4udW5yZWdpc3Rlck1lc2goYSl9LGIucHJvdG90eXBlLl9hcHBseUltcHVsc2U9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2N1cnJlbnRQbHVnaW4uYXBwbHlJbXB1bHNlKGEsYixjKX0sYi5wcm90b3R5cGUuX2NyZWF0ZUxpbms9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5fY3VycmVudFBsdWdpbi5jcmVhdGVMaW5rKGEsYixjLGQsZSl9LGIucHJvdG90eXBlLl91cGRhdGVCb2R5UG9zaXRpb249ZnVuY3Rpb24oYSl7dGhpcy5fY3VycmVudFBsdWdpbi51cGRhdGVCb2R5UG9zaXRpb24oYSl9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9jdXJyZW50UGx1Z2luLmRpc3Bvc2UoKX0sYi5wcm90b3R5cGUuaXNTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudFBsdWdpbi5pc1N1cHBvcnRlZCgpfSxiLk5vSW1wb3N0b3I9MCxiLlNwaGVyZUltcG9zdG9yPTEsYi5Cb3hJbXBvc3Rvcj0yLGIuUGxhbmVJbXBvc3Rvcj0zLGIuQ29tcG91bmRJbXBvc3Rvcj00LGIuTWVzaEltcG9zdG9yPTQsYi5DYXBzdWxlSW1wb3N0b3I9NSxiLkNvbmVJbXBvc3Rvcj02LGIuQ3lsaW5kZXJJbXBvc3Rvcj03LGIuQ29udmV4SHVsbEltcG9zdG9yPTgsYi5FcHNpbG9uPS4wMDEsYn0oKTthLlBoeXNpY3NFbmdpbmU9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7dmFyIGM9e307aWYoYy5uYW1lPWIubmFtZSxjLmlkPWIuaWQsYy50YWdzPWEuVGFncy5HZXRUYWdzKGIpLGIgaW5zdGFuY2VvZiBhLlBvaW50TGlnaHQpYy50eXBlPTAsYy5wb3NpdGlvbj1iLnBvc2l0aW9uLmFzQXJyYXkoKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkRpcmVjdGlvbmFsTGlnaHQpe2MudHlwZT0xO3ZhciBkPWI7Yy5wb3NpdGlvbj1kLnBvc2l0aW9uLmFzQXJyYXkoKSxjLmRpcmVjdGlvbj1kLmRpcmVjdGlvbi5hc0FycmF5KCl9ZWxzZSBpZihiIGluc3RhbmNlb2YgYS5TcG90TGlnaHQpe2MudHlwZT0yO3ZhciBlPWI7Yy5wb3NpdGlvbj1lLnBvc2l0aW9uLmFzQXJyYXkoKSxjLmRpcmVjdGlvbj1lLnBvc2l0aW9uLmFzQXJyYXkoKSxjLmFuZ2xlPWUuYW5nbGUsYy5leHBvbmVudD1lLmV4cG9uZW50fWVsc2UgaWYoYiBpbnN0YW5jZW9mIGEuSGVtaXNwaGVyaWNMaWdodCl7Yy50eXBlPTM7dmFyIGY9YjtjLmRpcmVjdGlvbj1mLmRpcmVjdGlvbi5hc0FycmF5KCksYy5ncm91bmRDb2xvcj1mLmdyb3VuZENvbG9yLmFzQXJyYXkoKX1yZXR1cm4gYi5pbnRlbnNpdHkmJihjLmludGVuc2l0eT1iLmludGVuc2l0eSksYy5yYW5nZT1iLnJhbmdlLGMuZGlmZnVzZT1iLmRpZmZ1c2UuYXNBcnJheSgpLGMuc3BlY3VsYXI9Yi5zcGVjdWxhci5hc0FycmF5KCksY30sYz1mdW5jdGlvbihiKXt2YXIgYz17fTtyZXR1cm4gYy5uYW1lPWIubmFtZSxjLnRhZ3M9YS5UYWdzLkdldFRhZ3MoYiksYy5pZD1iLmlkLGMucG9zaXRpb249Yi5wb3NpdGlvbi5hc0FycmF5KCksYi5wYXJlbnQmJihjLnBhcmVudElkPWIucGFyZW50LmlkKSxjLnJvdGF0aW9uPWIucm90YXRpb24uYXNBcnJheSgpLGIubG9ja2VkVGFyZ2V0JiZiLmxvY2tlZFRhcmdldC5pZCYmKGMubG9ja2VkVGFyZ2V0SWQ9Yi5sb2NrZWRUYXJnZXQuaWQpLGMuZm92PWIuZm92LGMubWluWj1iLm1pblosYy5tYXhaPWIubWF4WixjLnNwZWVkPWIuc3BlZWQsYy5pbmVydGlhPWIuaW5lcnRpYSxjLmNoZWNrQ29sbGlzaW9ucz1iLmNoZWNrQ29sbGlzaW9ucyxjLmFwcGx5R3Jhdml0eT1iLmFwcGx5R3Jhdml0eSxiLmVsbGlwc29pZCYmKGMuZWxsaXBzb2lkPWIuZWxsaXBzb2lkLmFzQXJyYXkoKSksZChiLGMpLGMubGF5ZXJNYXNrPWIubGF5ZXJNYXNrLGN9LGQ9ZnVuY3Rpb24oYSxiKXtpZihhLmFuaW1hdGlvbnMpe2IuYW5pbWF0aW9ucz1bXTtmb3IodmFyIGM9MDtjPGEuYW5pbWF0aW9ucy5sZW5ndGg7YysrKXt2YXIgZD1hLmFuaW1hdGlvbnNbY107Yi5hbmltYXRpb25zLnB1c2goZShkKSl9fX0sZT1mdW5jdGlvbihiKXt2YXIgYz17fTtjLm5hbWU9Yi5uYW1lLGMucHJvcGVydHk9Yi50YXJnZXRQcm9wZXJ0eSxjLmZyYW1lUGVyU2Vjb25kPWIuZnJhbWVQZXJTZWNvbmQsYy5kYXRhVHlwZT1iLmRhdGFUeXBlLGMubG9vcEJlaGF2aW9yPWIubG9vcE1vZGU7dmFyIGQ9Yi5kYXRhVHlwZTtjLmtleXM9W107Zm9yKHZhciBlPWIuZ2V0S2V5cygpLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXSxoPXt9O3N3aXRjaChoLmZyYW1lPWcuZnJhbWUsZCl7Y2FzZSBhLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FUOmgudmFsdWVzPVtnLnZhbHVlXTticmVhaztjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfUVVBVEVSTklPTjpjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfTUFUUklYOmNhc2UgYS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9WRUNUT1IzOmgudmFsdWVzPWcudmFsdWUuYXNBcnJheSgpfWMua2V5cy5wdXNoKGgpfXJldHVybiBjfSxmPWZ1bmN0aW9uKGIpe3ZhciBjPXt9O2MubmFtZT1iLm5hbWUsYy5pZD1iLmlkLGMudGFncz1hLlRhZ3MuR2V0VGFncyhiKSxjLm1hdGVyaWFscz1bXTtmb3IodmFyIGQ9MDtkPGIuc3ViTWF0ZXJpYWxzLmxlbmd0aDtkKyspe3ZhciBlPWIuc3ViTWF0ZXJpYWxzW2RdO2MubWF0ZXJpYWxzLnB1c2goZT9lLmlkOm51bGwpfXJldHVybiBjfSxnPWZ1bmN0aW9uKGIpe3ZhciBjPXt9O3JldHVybiBjLm5hbWU9Yi5uYW1lLGMuYW1iaWVudD1iLmFtYmllbnRDb2xvci5hc0FycmF5KCksYy5kaWZmdXNlPWIuZGlmZnVzZUNvbG9yLmFzQXJyYXkoKSxjLnNwZWN1bGFyPWIuc3BlY3VsYXJDb2xvci5hc0FycmF5KCksYy5zcGVjdWxhclBvd2VyPWIuc3BlY3VsYXJQb3dlcixjLmVtaXNzaXZlPWIuZW1pc3NpdmVDb2xvci5hc0FycmF5KCksYy5hbHBoYT1iLmFscGhhLGMuaWQ9Yi5pZCxjLnRhZ3M9YS5UYWdzLkdldFRhZ3MoYiksYy5iYWNrRmFjZUN1bGxpbmc9Yi5iYWNrRmFjZUN1bGxpbmcsYi5kaWZmdXNlVGV4dHVyZSYmKGMuZGlmZnVzZVRleHR1cmU9aChiLmRpZmZ1c2VUZXh0dXJlKSksYi5hbWJpZW50VGV4dHVyZSYmKGMuYW1iaWVudFRleHR1cmU9aChiLmFtYmllbnRUZXh0dXJlKSksYi5vcGFjaXR5VGV4dHVyZSYmKGMub3BhY2l0eVRleHR1cmU9aChiLm9wYWNpdHlUZXh0dXJlKSksYi5yZWZsZWN0aW9uVGV4dHVyZSYmKGMucmVmbGVjdGlvblRleHR1cmU9aChiLnJlZmxlY3Rpb25UZXh0dXJlKSksYi5lbWlzc2l2ZVRleHR1cmUmJihjLmVtaXNzaXZlVGV4dHVyZT1oKGIuZW1pc3NpdmVUZXh0dXJlKSksYi5zcGVjdWxhclRleHR1cmUmJihjLnNwZWN1bGFyVGV4dHVyZT1oKGIuc3BlY3VsYXJUZXh0dXJlKSksYi5idW1wVGV4dHVyZSYmKGMuYnVtcFRleHR1cmU9aChiLmJ1bXBUZXh0dXJlKSksY30saD1mdW5jdGlvbihiKXt2YXIgYz17fTtpZighYi5uYW1lKXJldHVybiBudWxsO2lmKGIgaW5zdGFuY2VvZiBhLkN1YmVUZXh0dXJlKXJldHVybiBjLm5hbWU9Yi5uYW1lLGMuaGFzQWxwaGE9Yi5oYXNBbHBoYSxjLmxldmVsPWIubGV2ZWwsYy5jb29yZGluYXRlc01vZGU9Yi5jb29yZGluYXRlc01vZGUsYztpZihiIGluc3RhbmNlb2YgYS5NaXJyb3JUZXh0dXJlKXt2YXIgZT1iO2MucmVuZGVyVGFyZ2V0U2l6ZT1lLmdldFJlbmRlclNpemUoKSxjLnJlbmRlckxpc3Q9W107Zm9yKHZhciBmPTA7ZjxlLnJlbmRlckxpc3QubGVuZ3RoO2YrKyljLnJlbmRlckxpc3QucHVzaChlLnJlbmRlckxpc3RbZl0uaWQpO2MubWlycm9yUGxhbmU9ZS5taXJyb3JQbGFuZS5hc0FycmF5KCl9ZWxzZSBpZihiIGluc3RhbmNlb2YgYS5SZW5kZXJUYXJnZXRUZXh0dXJlKXt2YXIgZz1iO2ZvcihjLnJlbmRlclRhcmdldFNpemU9Zy5nZXRSZW5kZXJTaXplKCksYy5yZW5kZXJMaXN0PVtdLGY9MDtmPGcucmVuZGVyTGlzdC5sZW5ndGg7ZisrKWMucmVuZGVyTGlzdC5wdXNoKGcucmVuZGVyTGlzdFtmXS5pZCl9dmFyIGg9YjtyZXR1cm4gYy5uYW1lPWIubmFtZSxjLmhhc0FscGhhPWIuaGFzQWxwaGEsYy5sZXZlbD1iLmxldmVsLGMuY29vcmRpbmF0ZXNJbmRleD1iLmNvb3JkaW5hdGVzSW5kZXgsYy5jb29yZGluYXRlc01vZGU9Yi5jb29yZGluYXRlc01vZGUsYy51T2Zmc2V0PWgudU9mZnNldCxjLnZPZmZzZXQ9aC52T2Zmc2V0LGMudVNjYWxlPWgudVNjYWxlLGMudlNjYWxlPWgudlNjYWxlLGMudUFuZz1oLnVBbmcsYy52QW5nPWgudkFuZyxjLndBbmc9aC53QW5nLGMud3JhcFU9Yi53cmFwVSxjLndyYXBWPWIud3JhcFYsZChiLGMpLGN9LGk9ZnVuY3Rpb24oYSl7dmFyIGI9e307Yi5uYW1lPWEubmFtZSxiLmlkPWEuaWQsYi5ib25lcz1bXTtmb3IodmFyIGM9MDtjPGEuYm9uZXMubGVuZ3RoO2MrKyl7dmFyIGQ9YS5ib25lc1tjXSxmPXtwYXJlbnRCb25lSW5kZXg6ZC5nZXRQYXJlbnQoKT9hLmJvbmVzLmluZGV4T2YoZC5nZXRQYXJlbnQoKSk6LTEsbmFtZTpkLm5hbWUsbWF0cml4OmQuZ2V0TG9jYWxNYXRyaXgoKS50b0FycmF5KCl9O2IuYm9uZXMucHVzaChmKSxkLmFuaW1hdGlvbnMmJmQuYW5pbWF0aW9ucy5sZW5ndGg+MCYmKGYuYW5pbWF0aW9uPWUoZC5hbmltYXRpb25zWzBdKSl9cmV0dXJuIGJ9LGo9ZnVuY3Rpb24oYSl7dmFyIGI9e307cmV0dXJuIGIuZW1pdHRlcklkPWEuZW1pdHRlci5pZCxiLmNhcGFjaXR5PWEuZ2V0Q2FwYWNpdHkoKSxhLnBhcnRpY2xlVGV4dHVyZSYmKGIudGV4dHVyZU5hbWU9YS5wYXJ0aWNsZVRleHR1cmUubmFtZSksYi5taW5Bbmd1bGFyU3BlZWQ9YS5taW5Bbmd1bGFyU3BlZWQsYi5tYXhBbmd1bGFyU3BlZWQ9YS5tYXhBbmd1bGFyU3BlZWQsYi5taW5TaXplPWEubWluU2l6ZSxiLm1heFNpemU9YS5tYXhTaXplLGIubWluTGlmZVRpbWU9YS5taW5MaWZlVGltZSxiLm1heExpZmVUaW1lPWEubWF4TGlmZVRpbWUsYi5lbWl0UmF0ZT1hLmVtaXRSYXRlLGIubWluRW1pdEJveD1hLm1pbkVtaXRCb3guYXNBcnJheSgpLGIubWF4RW1pdEJveD1hLm1heEVtaXRCb3guYXNBcnJheSgpLGIuZ3Jhdml0eT1hLmdyYXZpdHkuYXNBcnJheSgpLGIuZGlyZWN0aW9uMT1hLmRpcmVjdGlvbjEuYXNBcnJheSgpLGIuZGlyZWN0aW9uMj1hLmRpcmVjdGlvbjIuYXNBcnJheSgpLGIuY29sb3IxPWEuY29sb3IxLmFzQXJyYXkoKSxiLmNvbG9yMj1hLmNvbG9yMi5hc0FycmF5KCksYi5jb2xvckRlYWQ9YS5jb2xvckRlYWQuYXNBcnJheSgpLGIudXBkYXRlU3BlZWQ9YS51cGRhdGVTcGVlZCxiLnRhcmdldFN0b3BEdXJhdGlvbj1hLnRhcmdldFN0b3BEdXJhdGlvbixiLnRleHR1cmVNYXNrPWEudGV4dHVyZU1hc2suYXNBcnJheSgpLGIuYmxlbmRNb2RlPWEuYmxlbmRNb2RlLGJ9LGs9ZnVuY3Rpb24oYil7dmFyIGM9e307Yy5lbWl0dGVySWQ9Yi5nZXRFbWl0dGVyKCkuaWQsYy5ib3JkZXJMaW1pdD1iLmJvcmRlckxpbWl0LGMuZmxhcmVzPVtdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5zRmxhcmVzLmxlbmd0aDtkKyspe3ZhciBlPWIubGVuc0ZsYXJlc1tkXTtjLmZsYXJlcy5wdXNoKHtzaXplOmUuc2l6ZSxwb3NpdGlvbjplLnBvc2l0aW9uLGNvbG9yOmUuY29sb3IuYXNBcnJheSgpLHRleHR1cmVOYW1lOmEuVG9vbHMuR2V0RmlsZW5hbWUoZS50ZXh0dXJlLm5hbWUpfSl9cmV0dXJuIGN9LGw9ZnVuY3Rpb24oYSl7dmFyIGI9e30sYz1hLmdldFNoYWRvd0dlbmVyYXRvcigpO2IubGlnaHRJZD1hLmlkLGIubWFwU2l6ZT1jLmdldFNoYWRvd01hcCgpLmdldFJlbmRlclNpemUoKSxiLnVzZVZhcmlhbmNlU2hhZG93TWFwPWMudXNlVmFyaWFuY2VTaGFkb3dNYXAsYi51c2VQb2lzc29uU2FtcGxpbmc9Yy51c2VQb2lzc29uU2FtcGxpbmcsYi5yZW5kZXJMaXN0PVtdO2Zvcih2YXIgZD0wO2Q8Yy5nZXRTaGFkb3dNYXAoKS5yZW5kZXJMaXN0Lmxlbmd0aDtkKyspe3ZhciBlPWMuZ2V0U2hhZG93TWFwKCkucmVuZGVyTGlzdFtkXTtiLnJlbmRlckxpc3QucHVzaChlLmlkKX1yZXR1cm4gYn0sbT1bXSxuPWZ1bmN0aW9uKGIsYyl7aWYoIW1bYi5pZF0pe2lmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuQm94KWMuYm94ZXMucHVzaChyKGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuU3BoZXJlKWMuc3BoZXJlcy5wdXNoKHMoYikpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5DeWxpbmRlciljLmN5bGluZGVycy5wdXNoKHQoYikpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5Ub3J1cyljLnRvcnVzZXMucHVzaCh1KGIpKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuR3JvdW5kKWMuZ3JvdW5kcy5wdXNoKHYoYikpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5QbGFuZSljLnBsYW5lcy5wdXNoKHcoYikpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkuUHJpbWl0aXZlcy5Ub3J1c0tub3QpYy50b3J1c0tub3RzLnB1c2goeChiKSk7ZWxzZXtpZihiIGluc3RhbmNlb2YgYS5HZW9tZXRyeS5QcmltaXRpdmVzLl9QcmltaXRpdmUpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93IHByaW1pdGl2ZSB0eXBlXCIpO2MudmVydGV4RGF0YS5wdXNoKHAoYikpfW1bYi5pZF09ITB9fSxvPWZ1bmN0aW9uKGIpe3ZhciBjPXt9O3JldHVybiBjLmlkPWIuaWQsYS5UYWdzLkhhc1RhZ3MoYikmJihjLnRhZ3M9YS5UYWdzLkdldFRhZ3MoYikpLGN9LHA9ZnVuY3Rpb24oYil7dmFyIGM9byhiKTtyZXR1cm4gYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSYmKGMucG9zaXRpb25zPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpJiYoYy5ub3JtYWxzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVktpbmQpJiYoYy51dnM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkmJihjLnV2czI9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCkmJihjLmNvbG9ycz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSYmKGMubWF0cmljZXNJbmRpY2VzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpLGMubWF0cmljZXNJbmRpY2VzLl9pc0V4cGFuZGVkPSEwKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kKSYmKGMubWF0cmljZXNXZWlnaHRzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpKSxjLmluZGljZXM9Yi5nZXRJbmRpY2VzKCksY30scT1mdW5jdGlvbihhKXt2YXIgYj1vKGEpO3JldHVybiBiLmNhbkJlUmVnZW5lcmF0ZWQ9YS5jYW5CZVJlZ2VuZXJhdGVkKCksYn0scj1mdW5jdGlvbihhKXt2YXIgYj1xKGEpO3JldHVybiBiLnNpemU9YS5zaXplLGJ9LHM9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi5zZWdtZW50cz1hLnNlZ21lbnRzLGIuZGlhbWV0ZXI9YS5kaWFtZXRlcixifSx0PWZ1bmN0aW9uKGEpe3ZhciBiPXEoYSk7cmV0dXJuIGIuaGVpZ2h0PWEuaGVpZ2h0LGIuZGlhbWV0ZXJUb3A9YS5kaWFtZXRlclRvcCxiLmRpYW1ldGVyQm90dG9tPWEuZGlhbWV0ZXJCb3R0b20sYi50ZXNzZWxsYXRpb249YS50ZXNzZWxsYXRpb24sYn0sdT1mdW5jdGlvbihhKXt2YXIgYj1xKGEpO3JldHVybiBiLmRpYW1ldGVyPWEuZGlhbWV0ZXIsYi50aGlja25lc3M9YS50aGlja25lc3MsYi50ZXNzZWxsYXRpb249YS50ZXNzZWxsYXRpb24sYn0sdj1mdW5jdGlvbihhKXt2YXIgYj1xKGEpO3JldHVybiBiLndpZHRoPWEud2lkdGgsYi5oZWlnaHQ9YS5oZWlnaHQsYi5zdWJkaXZpc2lvbnM9YS5zdWJkaXZpc2lvbnMsYn0sdz1mdW5jdGlvbihhKXt2YXIgYj1xKGEpO3JldHVybiBiLnNpemU9YS5zaXplLGJ9LHg9ZnVuY3Rpb24oYSl7dmFyIGI9cShhKTtyZXR1cm4gYi5yYWRpdXM9YS5yYWRpdXMsYi50dWJlPWEudHViZSxiLnJhZGlhbFNlZ21lbnRzPWEucmFkaWFsU2VnbWVudHMsYi50dWJ1bGFyU2VnbWVudHM9YS50dWJ1bGFyU2VnbWVudHMsYi5wPWEucCxiLnE9YS5xLGJ9LHk9ZnVuY3Rpb24oYixjKXt2YXIgZT17fTtlLm5hbWU9Yi5uYW1lLGUuaWQ9Yi5pZCxhLlRhZ3MuSGFzVGFncyhiKSYmKGUudGFncz1hLlRhZ3MuR2V0VGFncyhiKSksZS5wb3NpdGlvbj1iLnBvc2l0aW9uLmFzQXJyYXkoKSxiLnJvdGF0aW9uUXVhdGVybmlvbj9lLnJvdGF0aW9uUXVhdGVybmlvbj1iLnJvdGF0aW9uUXVhdGVybmlvbi5hc0FycmF5KCk6Yi5yb3RhdGlvbiYmKGUucm90YXRpb249Yi5yb3RhdGlvbi5hc0FycmF5KCkpLGUuc2NhbGluZz1iLnNjYWxpbmcuYXNBcnJheSgpLGUubG9jYWxNYXRyaXg9Yi5nZXRQaXZvdE1hdHJpeCgpLmFzQXJyYXkoKSxlLmlzRW5hYmxlZD1iLmlzRW5hYmxlZCgpLGUuaXNWaXNpYmxlPWIuaXNWaXNpYmxlLGUuaW5maW5pdGVEaXN0YW5jZT1iLmluZmluaXRlRGlzdGFuY2UsZS5waWNrYWJsZT1iLmlzUGlja2FibGUsZS5yZWNlaXZlU2hhZG93cz1iLnJlY2VpdmVTaGFkb3dzLGUuYmlsbGJvYXJkTW9kZT1iLmJpbGxib2FyZE1vZGUsZS52aXNpYmlsaXR5PWIudmlzaWJpbGl0eSxlLmNoZWNrQ29sbGlzaW9ucz1iLmNoZWNrQ29sbGlzaW9ucyxiLnBhcmVudCYmKGUucGFyZW50SWQ9Yi5wYXJlbnQuaWQpO3ZhciBmPWIuX2dlb21ldHJ5O2lmKGYpe3ZhciBnPWYuaWQ7ZS5nZW9tZXRyeUlkPWcsYi5nZXRTY2VuZSgpLmdldEdlb21ldHJ5QnlJRChnKXx8bihmLGMuZ2VvbWV0cmllcyksZS5zdWJNZXNoZXM9W107Zm9yKHZhciBoPTA7aDxiLnN1Yk1lc2hlcy5sZW5ndGg7aCsrKXt2YXIgaT1iLnN1Yk1lc2hlc1toXTtlLnN1Yk1lc2hlcy5wdXNoKHttYXRlcmlhbEluZGV4OmkubWF0ZXJpYWxJbmRleCx2ZXJ0aWNlc1N0YXJ0OmkudmVydGljZXNTdGFydCx2ZXJ0aWNlc0NvdW50OmkudmVydGljZXNDb3VudCxpbmRleFN0YXJ0OmkuaW5kZXhTdGFydCxpbmRleENvdW50OmkuaW5kZXhDb3VudH0pfX1pZihiLm1hdGVyaWFsP2UubWF0ZXJpYWxJZD1iLm1hdGVyaWFsLmlkOmIubWF0ZXJpYWw9bnVsbCxiLnNrZWxldG9uJiYoZS5za2VsZXRvbklkPWIuc2tlbGV0b24uaWQpLGIuZ2V0UGh5c2ljc0ltcG9zdG9yKCkhPT1hLlBoeXNpY3NFbmdpbmUuTm9JbXBvc3Rvcilzd2l0Y2goZS5waHlzaWNzTWFzcz1iLmdldFBoeXNpY3NNYXNzKCksZS5waHlzaWNzRnJpY3Rpb249Yi5nZXRQaHlzaWNzRnJpY3Rpb24oKSxlLnBoeXNpY3NSZXN0aXR1dGlvbj1iLmdldFBoeXNpY3NSZXN0aXR1dGlvbigpLGIuZ2V0UGh5c2ljc0ltcG9zdG9yKCkpe2Nhc2UgYS5QaHlzaWNzRW5naW5lLkJveEltcG9zdG9yOmUucGh5c2ljc0ltcG9zdG9yPTE7YnJlYWs7Y2FzZSBhLlBoeXNpY3NFbmdpbmUuU3BoZXJlSW1wb3N0b3I6ZS5waHlzaWNzSW1wb3N0b3I9Mn1yZXR1cm4gZChiLGUpLGUubGF5ZXJNYXNrPWIubGF5ZXJNYXNrLGV9LHo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7fXJldHVybiBkLlNlcmlhbGl6ZT1mdW5jdGlvbihkKXt2YXIgZT17fTtlLnVzZURlbGF5ZWRUZXh0dXJlTG9hZGluZz1kLnVzZURlbGF5ZWRUZXh0dXJlTG9hZGluZyxlLmF1dG9DbGVhcj1kLmF1dG9DbGVhcixlLmNsZWFyQ29sb3I9ZC5jbGVhckNvbG9yLmFzQXJyYXkoKSxlLmFtYmllbnRDb2xvcj1kLmFtYmllbnRDb2xvci5hc0FycmF5KCksZS5ncmF2aXR5PWQuZ3Jhdml0eS5hc0FycmF5KCksZC5mb2dNb2RlJiYwIT09ZC5mb2dNb2RlJiYoZS5mb2dNb2RlPWQuZm9nTW9kZSxlLmZvZ0NvbG9yPWQuZm9nQ29sb3IuYXNBcnJheSgpLGUuZm9nU3RhcnQ9ZC5mb2dTdGFydCxlLmZvZ0VuZD1kLmZvZ0VuZCxlLmZvZ0RlbnNpdHk9ZC5mb2dEZW5zaXR5KSxlLmxpZ2h0cz1bXTtmb3IodmFyIGg9MDtoPGQubGlnaHRzLmxlbmd0aDtoKyspe3ZhciBvPWQubGlnaHRzW2hdO2UubGlnaHRzLnB1c2goYihvKSl9Zm9yKGUuY2FtZXJhcz1bXSxoPTA7aDxkLmNhbWVyYXMubGVuZ3RoO2grKyl7dmFyIHA9ZC5jYW1lcmFzW2hdO3AgaW5zdGFuY2VvZiBhLkZyZWVDYW1lcmEmJmUuY2FtZXJhcy5wdXNoKGMocCkpfWZvcihkLmFjdGl2ZUNhbWVyYSYmKGUuYWN0aXZlQ2FtZXJhSUQ9ZC5hY3RpdmVDYW1lcmEuaWQpLGUubWF0ZXJpYWxzPVtdLGUubXVsdGlNYXRlcmlhbHM9W10saD0wO2g8ZC5tYXRlcmlhbHMubGVuZ3RoO2grKyl7dmFyIHE9ZC5tYXRlcmlhbHNbaF07cSBpbnN0YW5jZW9mIGEuU3RhbmRhcmRNYXRlcmlhbD9lLm1hdGVyaWFscy5wdXNoKGcocSkpOnEgaW5zdGFuY2VvZiBhLk11bHRpTWF0ZXJpYWwmJmUubXVsdGlNYXRlcmlhbHMucHVzaChmKHEpKX1mb3IoZS5za2VsZXRvbnM9W10saD0wO2g8ZC5za2VsZXRvbnMubGVuZ3RoO2grKyllLnNrZWxldG9ucy5wdXNoKGkoZC5za2VsZXRvbnNbaF0pKTtlLmdlb21ldHJpZXM9e30sZS5nZW9tZXRyaWVzLmJveGVzPVtdLGUuZ2VvbWV0cmllcy5zcGhlcmVzPVtdLGUuZ2VvbWV0cmllcy5jeWxpbmRlcnM9W10sZS5nZW9tZXRyaWVzLnRvcnVzZXM9W10sZS5nZW9tZXRyaWVzLmdyb3VuZHM9W10sZS5nZW9tZXRyaWVzLnBsYW5lcz1bXSxlLmdlb21ldHJpZXMudG9ydXNLbm90cz1bXSxlLmdlb21ldHJpZXMudmVydGV4RGF0YT1bXSxtPVtdO2Zvcih2YXIgcj1kLmdldEdlb21ldHJpZXMoKSxoPTA7aDxyLmxlbmd0aDtoKyspe3ZhciBzPXJbaF07cy5pc1JlYWR5KCkmJm4ocyxlLmdlb21ldHJpZXMpfWZvcihlLm1lc2hlcz1bXSxoPTA7aDxkLm1lc2hlcy5sZW5ndGg7aCsrKXt2YXIgdD1kLm1lc2hlc1toXTtpZih0IGluc3RhbmNlb2YgYS5NZXNoKXt2YXIgdT10Oyh1LmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTE9BREVEfHx1LmRlbGF5TG9hZFN0YXRlPT09YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9ORSkmJmUubWVzaGVzLnB1c2goeSh1LGUpKX19Zm9yKGUucGFydGljbGVTeXN0ZW1zPVtdLGg9MDtoPGQucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtoKyspZS5wYXJ0aWNsZVN5c3RlbXMucHVzaChqKGQucGFydGljbGVTeXN0ZW1zW2hdKSk7Zm9yKGUubGVuc0ZsYXJlU3lzdGVtcz1bXSxoPTA7aDxkLmxlbnNGbGFyZVN5c3RlbXMubGVuZ3RoO2grKyllLmxlbnNGbGFyZVN5c3RlbXMucHVzaChrKGQubGVuc0ZsYXJlU3lzdGVtc1toXSkpO2ZvcihlLnNoYWRvd0dlbmVyYXRvcnM9W10saD0wO2g8ZC5saWdodHMubGVuZ3RoO2grKylvPWQubGlnaHRzW2hdLG8uZ2V0U2hhZG93R2VuZXJhdG9yKCkmJmUuc2hhZG93R2VuZXJhdG9ycy5wdXNoKGwobykpO3JldHVybiBlfSxkfSgpO2EuU2NlbmVTZXJpYWxpemVyPXp9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe31yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJGb3JjZUZ1bGxTY2VuZUxvYWRpbmdGb3JJbmNyZW1lbnRhbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fRm9yY2VGdWxsU2NlbmVMb2FkaW5nRm9ySW5jcmVtZW50YWx9LHNldDpmdW5jdGlvbihhKXtiLl9Gb3JjZUZ1bGxTY2VuZUxvYWRpbmdGb3JJbmNyZW1lbnRhbD1hfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIuX2dldFBsdWdpbkZvckZpbGVuYW1lPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmxhc3RJbmRleE9mKFwiLlwiKSxjPWEuc3Vic3RyaW5nKGIpLnRvTG93ZXJDYXNlKCksZD0wO2Q8dGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnMubGVuZ3RoO2QrKyl7dmFyIGU9dGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnNbZF07aWYoLTEhPT1lLmV4dGVuc2lvbnMuaW5kZXhPZihjKSlyZXR1cm4gZX1yZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnNbdGhpcy5fcmVnaXN0ZXJlZFBsdWdpbnMubGVuZ3RoLTFdfSxiLlJlZ2lzdGVyUGx1Z2luPWZ1bmN0aW9uKGEpe2EuZXh0ZW5zaW9ucz1hLmV4dGVuc2lvbnMudG9Mb3dlckNhc2UoKSxiLl9yZWdpc3RlcmVkUGx1Z2lucy5wdXNoKGEpfSxiLkltcG9ydE1lc2g9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpcyxqPWZ1bmN0aW9uKCl7ZS5kYXRhYmFzZT1rO3ZhciBqPWkuX2dldFBsdWdpbkZvckZpbGVuYW1lKGQpLGw9ZnVuY3Rpb24oYSl7dmFyIGc9W10saT1bXSxrPVtdO3JldHVybiBqLmltcG9ydE1lc2goYixlLGEsYyxnLGksayk/dm9pZChmJiYoZS5pbXBvcnRlZE1lc2hlc0ZpbGVzLnB1c2goYytkKSxmKGcsaSxrKSkpOnZvaWQoaCYmaChlKSl9O3JldHVybiBkLnN1YnN0ciYmXCJkYXRhOlwiPT09ZC5zdWJzdHIoMCw1KT92b2lkIGwoZC5zdWJzdHIoNSkpOnZvaWQgYS5Ub29scy5Mb2FkRmlsZShjK2QsZnVuY3Rpb24oYSl7bChhKX0sZyxrKX0saz1uZXcgYS5EYXRhYmFzZShjK2Qsail9LGIuTG9hZD1mdW5jdGlvbihiLGMsZCxlLGYsZyl7dmFyIGgsaT10aGlzLl9nZXRQbHVnaW5Gb3JGaWxlbmFtZShjLm5hbWV8fGMpLGo9ZnVuY3Rpb24oYyl7dmFyIGY9bmV3IGEuU2NlbmUoZCk7cmV0dXJuIGYuZGF0YWJhc2U9aCxpLmxvYWQoZixjLGIpP3ZvaWQoZSYmZShmKSk6dm9pZChnJiZnKGYpKX0saz1mdW5jdGlvbigpe2EuVG9vbHMuTG9hZEZpbGUoYitjLGosZixoKX07cmV0dXJuIGMuc3Vic3RyJiZcImRhdGE6XCI9PT1jLnN1YnN0cigwLDUpP3ZvaWQgaihjLnN1YnN0cig1KSk6dm9pZCgtMT09PWIuaW5kZXhPZihcImZpbGU6XCIpP2g9bmV3IGEuRGF0YWJhc2UoYitjLGspOmEuVG9vbHMuUmVhZEZpbGUoYyxqLGYpKX0sYi5fRm9yY2VGdWxsU2NlbmVMb2FkaW5nRm9ySW5jcmVtZW50YWw9ITEsYi5fcmVnaXN0ZXJlZFBsdWdpbnM9bmV3IEFycmF5LGJ9KCk7YS5TY2VuZUxvYWRlcj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXshZnVuY3Rpb24oKXt2YXIgYj1mdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IGEuQ3ViZVRleHR1cmUoYitjLm5hbWUsZCk7cmV0dXJuIGUubmFtZT1jLm5hbWUsZS5oYXNBbHBoYT1jLmhhc0FscGhhLGUubGV2ZWw9Yy5sZXZlbCxlLmNvb3JkaW5hdGVzTW9kZT1jLmNvb3JkaW5hdGVzTW9kZSxlfSxjPWZ1bmN0aW9uKGMsZCxlKXtpZighZC5uYW1lJiYhZC5pc1JlbmRlclRhcmdldClyZXR1cm4gbnVsbDtpZihkLmlzQ3ViZSlyZXR1cm4gYihjLGQsZSk7dmFyIGY7aWYoZC5taXJyb3JQbGFuZT8oZj1uZXcgYS5NaXJyb3JUZXh0dXJlKGQubmFtZSxkLnJlbmRlclRhcmdldFNpemUsZSksZi5fd2FpdGluZ1JlbmRlckxpc3Q9ZC5yZW5kZXJMaXN0LGYubWlycm9yUGxhbmU9YS5QbGFuZS5Gcm9tQXJyYXkoZC5taXJyb3JQbGFuZSkpOmQuaXNSZW5kZXJUYXJnZXQ/KGY9bmV3IGEuUmVuZGVyVGFyZ2V0VGV4dHVyZShkLm5hbWUsZC5yZW5kZXJUYXJnZXRTaXplLGUpLGYuX3dhaXRpbmdSZW5kZXJMaXN0PWQucmVuZGVyTGlzdCk6Zj1uZXcgYS5UZXh0dXJlKGMrZC5uYW1lLGUpLGYubmFtZT1kLm5hbWUsZi5oYXNBbHBoYT1kLmhhc0FscGhhLGYuZ2V0QWxwaGFGcm9tUkdCPWQuZ2V0QWxwaGFGcm9tUkdCLGYubGV2ZWw9ZC5sZXZlbCxmLmNvb3JkaW5hdGVzSW5kZXg9ZC5jb29yZGluYXRlc0luZGV4LGYuY29vcmRpbmF0ZXNNb2RlPWQuY29vcmRpbmF0ZXNNb2RlLGYudU9mZnNldD1kLnVPZmZzZXQsZi52T2Zmc2V0PWQudk9mZnNldCxmLnVTY2FsZT1kLnVTY2FsZSxmLnZTY2FsZT1kLnZTY2FsZSxmLnVBbmc9ZC51QW5nLGYudkFuZz1kLnZBbmcsZi53QW5nPWQud0FuZyxmLndyYXBVPWQud3JhcFUsZi53cmFwVj1kLndyYXBWLGQuYW5pbWF0aW9ucylmb3IodmFyIGc9MDtnPGQuYW5pbWF0aW9ucy5sZW5ndGg7ZysrKXt2YXIgaD1kLmFuaW1hdGlvbnNbZ107Zi5hbmltYXRpb25zLnB1c2goayhoKSl9cmV0dXJuIGZ9LGQ9ZnVuY3Rpb24oYixjKXtmb3IodmFyIGQ9bmV3IGEuU2tlbGV0b24oYi5uYW1lLGIuaWQsYyksZT0wO2U8Yi5ib25lcy5sZW5ndGg7ZSsrKXt2YXIgZj1iLmJvbmVzW2VdLGc9bnVsbDtmLnBhcmVudEJvbmVJbmRleD4tMSYmKGc9ZC5ib25lc1tmLnBhcmVudEJvbmVJbmRleF0pO3ZhciBoPW5ldyBhLkJvbmUoZi5uYW1lLGQsZyxhLk1hdHJpeC5Gcm9tQXJyYXkoZi5tYXRyaXgpKTtmLmFuaW1hdGlvbiYmaC5hbmltYXRpb25zLnB1c2goayhmLmFuaW1hdGlvbikpfXJldHVybiBkfSxlPWZ1bmN0aW9uKGIsZCxlKXt2YXIgZjtyZXR1cm4gZj1uZXcgYS5TdGFuZGFyZE1hdGVyaWFsKGIubmFtZSxkKSxmLmFtYmllbnRDb2xvcj1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5hbWJpZW50KSxmLmRpZmZ1c2VDb2xvcj1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5kaWZmdXNlKSxmLnNwZWN1bGFyQ29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGIuc3BlY3VsYXIpLGYuc3BlY3VsYXJQb3dlcj1iLnNwZWN1bGFyUG93ZXIsZi5lbWlzc2l2ZUNvbG9yPWEuQ29sb3IzLkZyb21BcnJheShiLmVtaXNzaXZlKSxmLmFscGhhPWIuYWxwaGEsZi5pZD1iLmlkLGEuVGFncy5BZGRUYWdzVG8oZixiLnRhZ3MpLGYuYmFja0ZhY2VDdWxsaW5nPWIuYmFja0ZhY2VDdWxsaW5nLGYud2lyZWZyYW1lPWIud2lyZWZyYW1lLGIuZGlmZnVzZVRleHR1cmUmJihmLmRpZmZ1c2VUZXh0dXJlPWMoZSxiLmRpZmZ1c2VUZXh0dXJlLGQpKSxiLmFtYmllbnRUZXh0dXJlJiYoZi5hbWJpZW50VGV4dHVyZT1jKGUsYi5hbWJpZW50VGV4dHVyZSxkKSksYi5vcGFjaXR5VGV4dHVyZSYmKGYub3BhY2l0eVRleHR1cmU9YyhlLGIub3BhY2l0eVRleHR1cmUsZCkpLGIucmVmbGVjdGlvblRleHR1cmUmJihmLnJlZmxlY3Rpb25UZXh0dXJlPWMoZSxiLnJlZmxlY3Rpb25UZXh0dXJlLGQpKSxiLmVtaXNzaXZlVGV4dHVyZSYmKGYuZW1pc3NpdmVUZXh0dXJlPWMoZSxiLmVtaXNzaXZlVGV4dHVyZSxkKSksYi5zcGVjdWxhclRleHR1cmUmJihmLnNwZWN1bGFyVGV4dHVyZT1jKGUsYi5zcGVjdWxhclRleHR1cmUsZCkpLGIuYnVtcFRleHR1cmUmJihmLmJ1bXBUZXh0dXJlPWMoZSxiLmJ1bXBUZXh0dXJlLGQpKSxmfSxmPWZ1bmN0aW9uKGEsYixjLGQpe2Zvcih2YXIgZj0wO2Y8Yi5tYXRlcmlhbHMubGVuZ3RoO2YrKyl7dmFyIGc9Yi5tYXRlcmlhbHNbZl07aWYoZy5pZD09PWEpcmV0dXJuIGUoZyxjLGQpfXJldHVybiBudWxsfSxnPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuTXVsdGlNYXRlcmlhbChiLm5hbWUsYyk7ZC5pZD1iLmlkLGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpO2Zvcih2YXIgZT0wO2U8Yi5tYXRlcmlhbHMubGVuZ3RoO2UrKyl7dmFyIGY9Yi5tYXRlcmlhbHNbZV07ZC5zdWJNYXRlcmlhbHMucHVzaChmP2MuZ2V0TWF0ZXJpYWxCeUlEKGYpOm51bGwpfXJldHVybiBkfSxoPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1jLmdldExhc3RFbnRyeUJ5SUQoYi5lbWl0dGVySWQpLGY9bmV3IGEuTGVuc0ZsYXJlU3lzdGVtKFwibGVuc0ZsYXJlU3lzdGVtI1wiK2IuZW1pdHRlcklkLGUsYyk7Zi5ib3JkZXJMaW1pdD1iLmJvcmRlckxpbWl0O2Zvcih2YXIgZz0wO2c8Yi5mbGFyZXMubGVuZ3RoO2crKyl7dmFyIGg9Yi5mbGFyZXNbZ107bmV3IGEuTGVuc0ZsYXJlKGguc2l6ZSxoLnBvc2l0aW9uLGEuQ29sb3IzLkZyb21BcnJheShoLmNvbG9yKSxkK2gudGV4dHVyZU5hbWUsZil9cmV0dXJuIGZ9LGk9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWMuZ2V0TGFzdE1lc2hCeUlEKGIuZW1pdHRlcklkKSxmPW5ldyBhLlBhcnRpY2xlU3lzdGVtKFwicGFydGljbGVzI1wiK2UubmFtZSxiLmNhcGFjaXR5LGMpO3JldHVybiBiLnRleHR1cmVOYW1lJiYoZi5wYXJ0aWNsZVRleHR1cmU9bmV3IGEuVGV4dHVyZShkK2IudGV4dHVyZU5hbWUsYyksZi5wYXJ0aWNsZVRleHR1cmUubmFtZT1iLnRleHR1cmVOYW1lKSxmLm1pbkFuZ3VsYXJTcGVlZD1iLm1pbkFuZ3VsYXJTcGVlZCxmLm1heEFuZ3VsYXJTcGVlZD1iLm1heEFuZ3VsYXJTcGVlZCxmLm1pblNpemU9Yi5taW5TaXplLGYubWF4U2l6ZT1iLm1heFNpemUsZi5taW5MaWZlVGltZT1iLm1pbkxpZmVUaW1lLGYubWF4TGlmZVRpbWU9Yi5tYXhMaWZlVGltZSxmLmVtaXR0ZXI9ZSxmLmVtaXRSYXRlPWIuZW1pdFJhdGUsZi5taW5FbWl0Qm94PWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5taW5FbWl0Qm94KSxmLm1heEVtaXRCb3g9YS5WZWN0b3IzLkZyb21BcnJheShiLm1heEVtaXRCb3gpLGYuZ3Jhdml0eT1hLlZlY3RvcjMuRnJvbUFycmF5KGIuZ3Jhdml0eSksZi5kaXJlY3Rpb24xPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5kaXJlY3Rpb24xKSxmLmRpcmVjdGlvbjI9YS5WZWN0b3IzLkZyb21BcnJheShiLmRpcmVjdGlvbjIpLGYuY29sb3IxPWEuQ29sb3I0LkZyb21BcnJheShiLmNvbG9yMSksZi5jb2xvcjI9YS5Db2xvcjQuRnJvbUFycmF5KGIuY29sb3IyKSxmLmNvbG9yRGVhZD1hLkNvbG9yNC5Gcm9tQXJyYXkoYi5jb2xvckRlYWQpLGYudXBkYXRlU3BlZWQ9Yi51cGRhdGVTcGVlZCxmLnRhcmdldFN0b3BEdXJhdGlvbj1iLnRhcmdldFN0b3BGcmFtZSxmLnRleHR1cmVNYXNrPWEuQ29sb3I0LkZyb21BcnJheShiLnRleHR1cmVNYXNrKSxmLmJsZW5kTW9kZT1iLmJsZW5kTW9kZSxmLnN0YXJ0KCksZn0saj1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZD1jLmdldExpZ2h0QnlJRChiLmxpZ2h0SWQpLGU9bmV3IGEuU2hhZG93R2VuZXJhdG9yKGIubWFwU2l6ZSxkKSxmPTA7ZjxiLnJlbmRlckxpc3QubGVuZ3RoO2YrKyl7dmFyIGc9Yy5nZXRNZXNoQnlJRChiLnJlbmRlckxpc3RbZl0pO2UuZ2V0U2hhZG93TWFwKCkucmVuZGVyTGlzdC5wdXNoKGcpfXJldHVybiBiLnVzZVBvaXNzb25TYW1wbGluZz9lLnVzZVBvaXNzb25TYW1wbGluZz0hMDplLnVzZVZhcmlhbmNlU2hhZG93TWFwPWIudXNlVmFyaWFuY2VTaGFkb3dNYXAsZX0saz1mdW5jdGlvbihiKXtmb3IodmFyIGM9bmV3IGEuQW5pbWF0aW9uKGIubmFtZSxiLnByb3BlcnR5LGIuZnJhbWVQZXJTZWNvbmQsYi5kYXRhVHlwZSxiLmxvb3BCZWhhdmlvciksZD1iLmRhdGFUeXBlLGU9W10sZj0wO2Y8Yi5rZXlzLmxlbmd0aDtmKyspe3ZhciBnLGg9Yi5rZXlzW2ZdO3N3aXRjaChkKXtjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfRkxPQVQ6Zz1oLnZhbHVlc1swXTticmVhaztjYXNlIGEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfUVVBVEVSTklPTjpnPWEuUXVhdGVybmlvbi5Gcm9tQXJyYXkoaC52YWx1ZXMpO2JyZWFrO2Nhc2UgYS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9NQVRSSVg6Zz1hLk1hdHJpeC5Gcm9tQXJyYXkoaC52YWx1ZXMpO2JyZWFrO2Nhc2UgYS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9WRUNUT1IzOmRlZmF1bHQ6Zz1hLlZlY3RvcjMuRnJvbUFycmF5KGgudmFsdWVzKX1lLnB1c2goe2ZyYW1lOmguZnJhbWUsdmFsdWU6Z30pfXJldHVybiBjLnNldEtleXMoZSksY30sbD1mdW5jdGlvbihiLGMpe3ZhciBkO3N3aXRjaChiLnR5cGUpe2Nhc2UgMDpkPW5ldyBhLlBvaW50TGlnaHQoYi5uYW1lLGEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5wb3NpdGlvbiksYyk7YnJlYWs7Y2FzZSAxOmQ9bmV3IGEuRGlyZWN0aW9uYWxMaWdodChiLm5hbWUsYS5WZWN0b3IzLkZyb21BcnJheShiLmRpcmVjdGlvbiksYyksZC5wb3NpdGlvbj1hLlZlY3RvcjMuRnJvbUFycmF5KGIucG9zaXRpb24pO2JyZWFrO2Nhc2UgMjpkPW5ldyBhLlNwb3RMaWdodChiLm5hbWUsYS5WZWN0b3IzLkZyb21BcnJheShiLnBvc2l0aW9uKSxhLlZlY3RvcjMuRnJvbUFycmF5KGIuZGlyZWN0aW9uKSxiLmFuZ2xlLGIuZXhwb25lbnQsYyk7YnJlYWs7Y2FzZSAzOmQ9bmV3IGEuSGVtaXNwaGVyaWNMaWdodChiLm5hbWUsYS5WZWN0b3IzLkZyb21BcnJheShiLmRpcmVjdGlvbiksYyksZC5ncm91bmRDb2xvcj1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5ncm91bmRDb2xvcil9aWYoZC5pZD1iLmlkLGEuVGFncy5BZGRUYWdzVG8oZCxiLnRhZ3MpLHZvaWQgMCE9PWIuaW50ZW5zaXR5JiYoZC5pbnRlbnNpdHk9Yi5pbnRlbnNpdHkpLGIucmFuZ2UmJihkLnJhbmdlPWIucmFuZ2UpLGQuZGlmZnVzZT1hLkNvbG9yMy5Gcm9tQXJyYXkoYi5kaWZmdXNlKSxkLnNwZWN1bGFyPWEuQ29sb3IzLkZyb21BcnJheShiLnNwZWN1bGFyKSxiLmV4Y2x1ZGVkTWVzaGVzSWRzJiYoZC5fZXhjbHVkZWRNZXNoZXNJZHM9Yi5leGNsdWRlZE1lc2hlc0lkcyksYi5hbmltYXRpb25zKWZvcih2YXIgZT0wO2U8Yi5hbmltYXRpb25zLmxlbmd0aDtlKyspe3ZhciBmPWIuYW5pbWF0aW9uc1tlXTtkLmFuaW1hdGlvbnMucHVzaChrKGYpKX1iLmF1dG9BbmltYXRlJiZjLmJlZ2luQW5pbWF0aW9uKGQsYi5hdXRvQW5pbWF0ZUZyb20sYi5hdXRvQW5pbWF0ZVRvLGIuYXV0b0FuaW1hdGVMb29wLDEpfSxtPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bmV3IGEuRnJlZUNhbWVyYShiLm5hbWUsYS5WZWN0b3IzLkZyb21BcnJheShiLnBvc2l0aW9uKSxjKTtpZihkLmlkPWIuaWQsYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYi5wYXJlbnRJZCYmKGQuX3dhaXRpbmdQYXJlbnRJZD1iLnBhcmVudElkKSxiLnRhcmdldD9kLnNldFRhcmdldChhLlZlY3RvcjMuRnJvbUFycmF5KGIudGFyZ2V0KSk6ZC5yb3RhdGlvbj1hLlZlY3RvcjMuRnJvbUFycmF5KGIucm90YXRpb24pLGIubG9ja2VkVGFyZ2V0SWQmJihkLl93YWl0aW5nTG9ja2VkVGFyZ2V0SWQ9Yi5sb2NrZWRUYXJnZXRJZCksZC5mb3Y9Yi5mb3YsZC5taW5aPWIubWluWixkLm1heFo9Yi5tYXhaLGQuc3BlZWQ9Yi5zcGVlZCxkLmluZXJ0aWE9Yi5pbmVydGlhLGQuY2hlY2tDb2xsaXNpb25zPWIuY2hlY2tDb2xsaXNpb25zLGQuYXBwbHlHcmF2aXR5PWIuYXBwbHlHcmF2aXR5LGIuZWxsaXBzb2lkJiYoZC5lbGxpcHNvaWQ9YS5WZWN0b3IzLkZyb21BcnJheShiLmVsbGlwc29pZCkpLGIuYW5pbWF0aW9ucylmb3IodmFyIGU9MDtlPGIuYW5pbWF0aW9ucy5sZW5ndGg7ZSsrKXt2YXIgZj1iLmFuaW1hdGlvbnNbZV07ZC5hbmltYXRpb25zLnB1c2goayhmKSl9cmV0dXJuIGIuYXV0b0FuaW1hdGUmJmMuYmVnaW5BbmltYXRpb24oZCxiLmF1dG9BbmltYXRlRnJvbSxiLmF1dG9BbmltYXRlVG8sYi5hdXRvQW5pbWF0ZUxvb3AsMSksZC5sYXllck1hc2s9Yi5sYXllck1hc2smJiFpc05hTihiLmxheWVyTWFzayk/TWF0aC5hYnMocGFyc2VJbnQoYi5sYXllck1hc2spKTo0Mjk0OTY3Mjk1LGR9LG49ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmlkO3JldHVybiBiLmdldEdlb21ldHJ5QnlJRChjKX0sbz1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLkJveChiLmlkLGMsYi5zaXplLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0scD1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLlNwaGVyZShiLmlkLGMsYi5zZWdtZW50cyxiLmRpYW1ldGVyLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0scT1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLkN5bGluZGVyKGIuaWQsYyxiLmhlaWdodCxiLmRpYW1ldGVyVG9wLGIuZGlhbWV0ZXJCb3R0b20sYi50ZXNzZWxsYXRpb24sYi5zdWJkaXZpc2lvbnMsYi5jYW5CZVJlZ2VuZXJhdGVkLG51bGwpO3JldHVybiBhLlRhZ3MuQWRkVGFnc1RvKGQsYi50YWdzKSxjLnB1c2hHZW9tZXRyeShkLCEwKSxkfSxyPWZ1bmN0aW9uKGIsYyl7aWYobihiLGMpKXJldHVybiBudWxsO3ZhciBkPW5ldyBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuVG9ydXMoYi5pZCxjLGIuZGlhbWV0ZXIsYi50aGlja25lc3MsYi50ZXNzZWxsYXRpb24sYi5jYW5CZVJlZ2VuZXJhdGVkLG51bGwpO3JldHVybiBhLlRhZ3MuQWRkVGFnc1RvKGQsYi50YWdzKSxjLnB1c2hHZW9tZXRyeShkLCEwKSxkfSxzPWZ1bmN0aW9uKGIsYyl7aWYobihiLGMpKXJldHVybiBudWxsO3ZhciBkPW5ldyBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuR3JvdW5kKGIuaWQsYyxiLndpZHRoLGIuaGVpZ2h0LGIuc3ViZGl2aXNpb25zLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0sdD1mdW5jdGlvbihiLGMpe2lmKG4oYixjKSlyZXR1cm4gbnVsbDt2YXIgZD1uZXcgYS5HZW9tZXRyeS5QcmltaXRpdmVzLlBsYW5lKGIuaWQsYyxiLnNpemUsYi5jYW5CZVJlZ2VuZXJhdGVkLG51bGwpO3JldHVybiBhLlRhZ3MuQWRkVGFnc1RvKGQsYi50YWdzKSxjLnB1c2hHZW9tZXRyeShkLCEwKSxkfSx1PWZ1bmN0aW9uKGIsYyl7aWYobihiLGMpKXJldHVybiBudWxsO3ZhciBkPW5ldyBhLkdlb21ldHJ5LlByaW1pdGl2ZXMuVG9ydXNLbm90KGIuaWQsYyxiLnJhZGl1cyxiLnR1YmUsYi5yYWRpYWxTZWdtZW50cyxiLnR1YnVsYXJTZWdtZW50cyxiLnAsYi5xLGIuY2FuQmVSZWdlbmVyYXRlZCxudWxsKTtyZXR1cm4gYS5UYWdzLkFkZFRhZ3NUbyhkLGIudGFncyksYy5wdXNoR2VvbWV0cnkoZCwhMCksZH0sdj1mdW5jdGlvbihiLGMsZCl7aWYobihiLGMpKXJldHVybiBudWxsO3ZhciBlPW5ldyBhLkdlb21ldHJ5KGIuaWQsYyk7cmV0dXJuIGEuVGFncy5BZGRUYWdzVG8oZSxiLnRhZ3MpLGIuZGVsYXlMb2FkaW5nRmlsZT8oZS5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQsZS5kZWxheUxvYWRpbmdGaWxlPWQrYi5kZWxheUxvYWRpbmdGaWxlLGUuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oYS5WZWN0b3IzLkZyb21BcnJheShiLmJvdW5kaW5nQm94TWluaW11bSksYS5WZWN0b3IzLkZyb21BcnJheShiLmJvdW5kaW5nQm94TWF4aW11bSkpLGUuX2RlbGF5SW5mbz1bXSxiLmhhc1VWcyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSxiLmhhc1VWczImJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLlVWMktpbmQpLGIuaGFzQ29sb3JzJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpLGIuaGFzTWF0cmljZXNJbmRpY2VzJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSxiLmhhc01hdHJpY2VzV2VpZ2h0cyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCksZS5fZGVsYXlMb2FkaW5nRnVuY3Rpb249eSk6eShiLGUpLGMucHVzaEdlb21ldHJ5KGUsITApLGV9LHc9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPW5ldyBhLk1lc2goYi5uYW1lLGMpO2lmKGUuaWQ9Yi5pZCxhLlRhZ3MuQWRkVGFnc1RvKGUsYi50YWdzKSxlLnBvc2l0aW9uPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5wb3NpdGlvbiksYi5yb3RhdGlvblF1YXRlcm5pb24/ZS5yb3RhdGlvblF1YXRlcm5pb249YS5RdWF0ZXJuaW9uLkZyb21BcnJheShiLnJvdGF0aW9uUXVhdGVybmlvbik6Yi5yb3RhdGlvbiYmKGUucm90YXRpb249YS5WZWN0b3IzLkZyb21BcnJheShiLnJvdGF0aW9uKSksZS5zY2FsaW5nPWEuVmVjdG9yMy5Gcm9tQXJyYXkoYi5zY2FsaW5nKSxiLmxvY2FsTWF0cml4P2Uuc2V0UGl2b3RNYXRyaXgoYS5NYXRyaXguRnJvbUFycmF5KGIubG9jYWxNYXRyaXgpKTpiLnBpdm90TWF0cml4JiZlLnNldFBpdm90TWF0cml4KGEuTWF0cml4LkZyb21BcnJheShiLnBpdm90TWF0cml4KSksZS5zZXRFbmFibGVkKGIuaXNFbmFibGVkKSxlLmlzVmlzaWJsZT1iLmlzVmlzaWJsZSxlLmluZmluaXRlRGlzdGFuY2U9Yi5pbmZpbml0ZURpc3RhbmNlLGUuc2hvd0JvdW5kaW5nQm94PWIuc2hvd0JvdW5kaW5nQm94LGUuc2hvd1N1Yk1lc2hlc0JvdW5kaW5nQm94PWIuc2hvd1N1Yk1lc2hlc0JvdW5kaW5nQm94LHZvaWQgMCE9PWIucGlja2FibGUmJihlLmlzUGlja2FibGU9Yi5waWNrYWJsZSksZS5yZWNlaXZlU2hhZG93cz1iLnJlY2VpdmVTaGFkb3dzLGUuYmlsbGJvYXJkTW9kZT1iLmJpbGxib2FyZE1vZGUsdm9pZCAwIT09Yi52aXNpYmlsaXR5JiYoZS52aXNpYmlsaXR5PWIudmlzaWJpbGl0eSksZS5jaGVja0NvbGxpc2lvbnM9Yi5jaGVja0NvbGxpc2lvbnMsZS5fc2hvdWxkR2VuZXJhdGVGbGF0U2hhZGluZz1iLnVzZUZsYXRTaGFkaW5nLGIucGFyZW50SWQmJihlLnBhcmVudD1jLmdldExhc3RFbnRyeUJ5SUQoYi5wYXJlbnRJZCkpLGIuZGVsYXlMb2FkaW5nRmlsZT8oZS5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9OT1RMT0FERUQsZS5kZWxheUxvYWRpbmdGaWxlPWQrYi5kZWxheUxvYWRpbmdGaWxlLGUuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oYS5WZWN0b3IzLkZyb21BcnJheShiLmJvdW5kaW5nQm94TWluaW11bSksYS5WZWN0b3IzLkZyb21BcnJheShiLmJvdW5kaW5nQm94TWF4aW11bSkpLGUuX2RlbGF5SW5mbz1bXSxiLmhhc1VWcyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKSxiLmhhc1VWczImJmUuX2RlbGF5SW5mby5wdXNoKGEuVmVydGV4QnVmZmVyLlVWMktpbmQpLGIuaGFzQ29sb3JzJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQpLGIuaGFzTWF0cmljZXNJbmRpY2VzJiZlLl9kZWxheUluZm8ucHVzaChhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKSxiLmhhc01hdHJpY2VzV2VpZ2h0cyYmZS5fZGVsYXlJbmZvLnB1c2goYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCksZS5fZGVsYXlMb2FkaW5nRnVuY3Rpb249eixhLlNjZW5lTG9hZGVyLkZvcmNlRnVsbFNjZW5lTG9hZGluZ0ZvckluY3JlbWVudGFsJiZlLl9jaGVja0RlbGF5U3RhdGUoKSk6eihiLGUpLGIubWF0ZXJpYWxJZD9lLnNldE1hdGVyaWFsQnlJRChiLm1hdGVyaWFsSWQpOmUubWF0ZXJpYWw9bnVsbCxiLnNrZWxldG9uSWQ+LTEmJihlLnNrZWxldG9uPWMuZ2V0TGFzdFNrZWxldG9uQnlJRChiLnNrZWxldG9uSWQpKSxiLnBoeXNpY3NJbXBvc3RvciYmKGMuaXNQaHlzaWNzRW5hYmxlZCgpfHxjLmVuYWJsZVBoeXNpY3MoKSxlLnNldFBoeXNpY3NTdGF0ZSh7aW1wb3N0b3I6Yi5waHlzaWNzSW1wb3N0b3IsbWFzczpiLnBoeXNpY3NNYXNzLGZyaWN0aW9uOmIucGh5c2ljc0ZyaWN0aW9uLHJlc3RpdHV0aW9uOmIucGh5c2ljc1Jlc3RpdHV0aW9ufSkpLGIuYW5pbWF0aW9ucylmb3IodmFyIGY9MDtmPGIuYW5pbWF0aW9ucy5sZW5ndGg7ZisrKXt2YXIgZz1iLmFuaW1hdGlvbnNbZl07XG5lLmFuaW1hdGlvbnMucHVzaChrKGcpKX1pZihiLmF1dG9BbmltYXRlJiZjLmJlZ2luQW5pbWF0aW9uKGUsYi5hdXRvQW5pbWF0ZUZyb20sYi5hdXRvQW5pbWF0ZVRvLGIuYXV0b0FuaW1hdGVMb29wLDEpLGUubGF5ZXJNYXNrPWIubGF5ZXJNYXNrJiYhaXNOYU4oYi5sYXllck1hc2spP01hdGguYWJzKHBhcnNlSW50KGIubGF5ZXJNYXNrKSk6NDI5NDk2NzI5NSxiLmluc3RhbmNlcylmb3IodmFyIGg9MDtoPGIuaW5zdGFuY2VzLmxlbmd0aDtoKyspe3ZhciBpPWIuaW5zdGFuY2VzW2hdLGo9ZS5jcmVhdGVJbnN0YW5jZShpLm5hbWUpO2lmKGEuVGFncy5BZGRUYWdzVG8oaixpLnRhZ3MpLGoucG9zaXRpb249YS5WZWN0b3IzLkZyb21BcnJheShpLnBvc2l0aW9uKSxpLnJvdGF0aW9uUXVhdGVybmlvbj9qLnJvdGF0aW9uUXVhdGVybmlvbj1hLlF1YXRlcm5pb24uRnJvbUFycmF5KGkucm90YXRpb25RdWF0ZXJuaW9uKTppLnJvdGF0aW9uJiYoai5yb3RhdGlvbj1hLlZlY3RvcjMuRnJvbUFycmF5KGkucm90YXRpb24pKSxqLnNjYWxpbmc9YS5WZWN0b3IzLkZyb21BcnJheShpLnNjYWxpbmcpLGouY2hlY2tDb2xsaXNpb25zPWUuY2hlY2tDb2xsaXNpb25zLGIuYW5pbWF0aW9ucylmb3IoZj0wO2Y8Yi5hbmltYXRpb25zLmxlbmd0aDtmKyspZz1iLmFuaW1hdGlvbnNbZl0sai5hbmltYXRpb25zLnB1c2goayhnKSl9cmV0dXJuIGV9LHg9ZnVuY3Rpb24oYSxiLGMpe2I9YiBpbnN0YW5jZW9mIEFycmF5P2I6W2JdO2Zvcih2YXIgZCBpbiBiKWlmKGEubmFtZT09PWJbZF0pcmV0dXJuIGMucHVzaChhLmlkKSwhMDtyZXR1cm4gYS5wYXJlbnRJZCYmLTEhPT1jLmluZGV4T2YoYS5wYXJlbnRJZCk/KGMucHVzaChhLmlkKSwhMCk6ITF9LHk9ZnVuY3Rpb24oYixjKXt2YXIgZD1uZXcgYS5WZXJ0ZXhEYXRhLGU9Yi5wb3NpdGlvbnM7ZSYmZC5zZXQoZSxhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpO3ZhciBmPWIubm9ybWFscztmJiZkLnNldChmLGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQpO3ZhciBnPWIudXZzO2cmJmQuc2V0KGcsYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kKTt2YXIgaD1iLnV2MnM7aCYmZC5zZXQoaCxhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKTt2YXIgaT1iLmNvbG9ycztpJiZkLnNldChpLGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCk7dmFyIGo9Yi5tYXRyaWNlc0luZGljZXM7aiYmZC5zZXQoaixhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kKTt2YXIgaz1iLm1hdHJpY2VzV2VpZ2h0cztrJiZkLnNldChrLGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpO3ZhciBsPWIuaW5kaWNlcztsJiYoZC5pbmRpY2VzPWwpLGMuc2V0QWxsVmVydGljZXNEYXRhKGQsYi51cGRhdGFibGUpfSx6PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yy5nZXRTY2VuZSgpLGU9Yi5nZW9tZXRyeUlkO2lmKGUpe3ZhciBmPWQuZ2V0R2VvbWV0cnlCeUlEKGUpO2YmJmYuYXBwbHlUb01lc2goYyl9ZWxzZSBpZihiLnBvc2l0aW9ucyYmYi5ub3JtYWxzJiZiLmluZGljZXMpe2lmKGMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCxiLnBvc2l0aW9ucywhMSksYy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCxiLm5vcm1hbHMsITEpLGIudXZzJiZjLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQsYi51dnMsITEpLGIudXZzMiYmYy5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCxiLnV2czIsITEpLGIuY29sb3JzJiZjLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Db2xvcktpbmQsYi5jb2xvcnMsITEpLGIubWF0cmljZXNJbmRpY2VzKWlmKGIubWF0cmljZXNJbmRpY2VzLl9pc0V4cGFuZGVkKWRlbGV0ZSBiLm1hdHJpY2VzSW5kaWNlcy5faXNFeHBhbmRlZCxjLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kLGIubWF0cmljZXNJbmRpY2VzLCExKTtlbHNle2Zvcih2YXIgZz1bXSxoPTA7aDxiLm1hdHJpY2VzSW5kaWNlcy5sZW5ndGg7aCsrKXt2YXIgaT1iLm1hdHJpY2VzSW5kaWNlc1toXTtnLnB1c2goMjU1JmkpLGcucHVzaCgoNjUyODAmaSk+PjgpLGcucHVzaCgoMTY3MTE2ODAmaSk+PjE2KSxnLnB1c2goaT4+MjQpfWMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQsZywhMSl9Yi5tYXRyaWNlc1dlaWdodHMmJmMuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQsYi5tYXRyaWNlc1dlaWdodHMsITEpLGMuc2V0SW5kaWNlcyhiLmluZGljZXMpfWlmKGIuc3ViTWVzaGVzKXtjLnN1Yk1lc2hlcz1bXTtmb3IodmFyIGo9MDtqPGIuc3ViTWVzaGVzLmxlbmd0aDtqKyspe3ZhciBrPWIuc3ViTWVzaGVzW2pdO25ldyBhLlN1Yk1lc2goay5tYXRlcmlhbEluZGV4LGsudmVydGljZXNTdGFydCxrLnZlcnRpY2VzQ291bnQsay5pbmRleFN0YXJ0LGsuaW5kZXhDb3VudCxjKX19Yy5fc2hvdWxkR2VuZXJhdGVGbGF0U2hhZGluZyYmKGMuY29udmVydFRvRmxhdFNoYWRlZE1lc2goKSxkZWxldGUgYy5fc2hvdWxkR2VuZXJhdGVGbGF0U2hhZGluZyksYy5jb21wdXRlV29ybGRNYXRyaXgoITApLGQuX3NlbGVjdGlvbk9jdHJlZSYmZC5fc2VsZWN0aW9uT2N0cmVlLmFkZE1lc2goYyl9O2EuU2NlbmVMb2FkZXIuUmVnaXN0ZXJQbHVnaW4oe2V4dGVuc2lvbnM6XCIuYmFieWxvblwiLGltcG9ydE1lc2g6ZnVuY3Rpb24oYSxiLGMsZSxoLGosayl7Zm9yKHZhciBsPUpTT04ucGFyc2UoYyksbT1bXSxuPVtdLG89W10scD0wO3A8bC5tZXNoZXMubGVuZ3RoO3ArKyl7dmFyIHE9bC5tZXNoZXNbcF07aWYoIWF8fHgocSxhLG8pKXtpZihhIGluc3RhbmNlb2YgQXJyYXkmJmRlbGV0ZSBhW2EuaW5kZXhPZihxLm5hbWUpXSxxLm1hdGVyaWFsSWQpe3ZhciByPS0xIT09bi5pbmRleE9mKHEubWF0ZXJpYWxJZCk7aWYoIXIpZm9yKHZhciBzPTA7czxsLm11bHRpTWF0ZXJpYWxzLmxlbmd0aDtzKyspe3ZhciB0PWwubXVsdGlNYXRlcmlhbHNbc107aWYodC5pZD09cS5tYXRlcmlhbElkKXtmb3IodmFyIHU9MDt1PHQubWF0ZXJpYWxzLmxlbmd0aDt1Kyspe3ZhciB2PXQubWF0ZXJpYWxzW3VdO24ucHVzaCh2KSxmKHYsbCxiLGUpfW4ucHVzaCh0LmlkKSxnKHQsYikscj0hMDticmVha319cnx8KG4ucHVzaChxLm1hdGVyaWFsSWQpLGYocS5tYXRlcmlhbElkLGwsYixlKSl9aWYocS5za2VsZXRvbklkPi0xJiZiLnNrZWxldG9ucyl7dmFyIHk9bS5pbmRleE9mKHEuc2tlbGV0b25JZCk+LTE7aWYoIXkpZm9yKHZhciB6PTA7ejxsLnNrZWxldG9ucy5sZW5ndGg7eisrKXt2YXIgQT1sLnNrZWxldG9uc1t6XTtBLmlkPT09cS5za2VsZXRvbklkJiYoay5wdXNoKGQoQSxiKSksbS5wdXNoKEEuaWQpKX19dmFyIEI9dyhxLGIsZSk7aC5wdXNoKEIpfX1pZihsLnBhcnRpY2xlU3lzdGVtcylmb3IocD0wO3A8bC5wYXJ0aWNsZVN5c3RlbXMubGVuZ3RoO3ArKyl7dmFyIEM9bC5wYXJ0aWNsZVN5c3RlbXNbcF07LTEhPT1vLmluZGV4T2YoQy5lbWl0dGVySWQpJiZqLnB1c2goaShDLGIsZSkpfXJldHVybiEwfSxsb2FkOmZ1bmN0aW9uKGIsYyxmKXt2YXIgaz1KU09OLnBhcnNlKGMpO2IudXNlRGVsYXllZFRleHR1cmVMb2FkaW5nPWsudXNlRGVsYXllZFRleHR1cmVMb2FkaW5nJiYhYS5TY2VuZUxvYWRlci5Gb3JjZUZ1bGxTY2VuZUxvYWRpbmdGb3JJbmNyZW1lbnRhbCxiLmF1dG9DbGVhcj1rLmF1dG9DbGVhcixiLmNsZWFyQ29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGsuY2xlYXJDb2xvciksYi5hbWJpZW50Q29sb3I9YS5Db2xvcjMuRnJvbUFycmF5KGsuYW1iaWVudENvbG9yKSxiLmdyYXZpdHk9YS5WZWN0b3IzLkZyb21BcnJheShrLmdyYXZpdHkpLGsuZm9nTW9kZSYmMCE9PWsuZm9nTW9kZSYmKGIuZm9nTW9kZT1rLmZvZ01vZGUsYi5mb2dDb2xvcj1hLkNvbG9yMy5Gcm9tQXJyYXkoay5mb2dDb2xvciksYi5mb2dTdGFydD1rLmZvZ1N0YXJ0LGIuZm9nRW5kPWsuZm9nRW5kLGIuZm9nRGVuc2l0eT1rLmZvZ0RlbnNpdHkpO2Zvcih2YXIgbj0wO248ay5saWdodHMubGVuZ3RoO24rKyl7dmFyIHg9ay5saWdodHNbbl07bCh4LGIpfWZvcihuPTA7bjxrLmNhbWVyYXMubGVuZ3RoO24rKyl7dmFyIHk9ay5jYW1lcmFzW25dO20oeSxiKX1pZihrLmFjdGl2ZUNhbWVyYUlEJiZiLnNldEFjdGl2ZUNhbWVyYUJ5SUQoay5hY3RpdmVDYW1lcmFJRCksay5tYXRlcmlhbHMpZm9yKG49MDtuPGsubWF0ZXJpYWxzLmxlbmd0aDtuKyspe3ZhciB6PWsubWF0ZXJpYWxzW25dO2UoeixiLGYpfWlmKGsubXVsdGlNYXRlcmlhbHMpZm9yKG49MDtuPGsubXVsdGlNYXRlcmlhbHMubGVuZ3RoO24rKyl7dmFyIEE9ay5tdWx0aU1hdGVyaWFsc1tuXTtnKEEsYil9aWYoay5za2VsZXRvbnMpZm9yKG49MDtuPGsuc2tlbGV0b25zLmxlbmd0aDtuKyspe3ZhciBCPWsuc2tlbGV0b25zW25dO2QoQixiKX12YXIgQz1rLmdlb21ldHJpZXM7aWYoQyl7dmFyIEQ9Qy5ib3hlcztpZihEKWZvcihuPTA7bjxELmxlbmd0aDtuKyspe3ZhciBFPURbbl07byhFLGIpfXZhciBGPUMuc3BoZXJlcztpZihGKWZvcihuPTA7bjxGLmxlbmd0aDtuKyspe3ZhciBHPUZbbl07cChHLGIpfXZhciBIPUMuY3lsaW5kZXJzO2lmKEgpZm9yKG49MDtuPEgubGVuZ3RoO24rKyl7dmFyIEk9SFtuXTtxKEksYil9dmFyIEo9Qy50b3J1c2VzO2lmKEopZm9yKG49MDtuPEoubGVuZ3RoO24rKyl7dmFyIEs9SltuXTtyKEssYil9dmFyIEw9Qy5ncm91bmRzO2lmKEwpZm9yKG49MDtuPEwubGVuZ3RoO24rKyl7dmFyIE09TFtuXTtzKE0sYil9dmFyIE49Qy5wbGFuZXM7aWYoTilmb3Iobj0wO248Ti5sZW5ndGg7bisrKXt2YXIgTz1OW25dO3QoTyxiKX12YXIgUD1DLnRvcnVzS25vdHM7aWYoUClmb3Iobj0wO248UC5sZW5ndGg7bisrKXt2YXIgUT1QW25dO3UoUSxiKX12YXIgUj1DLnZlcnRleERhdGE7aWYoUilmb3Iobj0wO248Ui5sZW5ndGg7bisrKXt2YXIgUz1SW25dO3YoUyxiLGYpfX1mb3Iobj0wO248ay5tZXNoZXMubGVuZ3RoO24rKyl7dmFyIFQ9ay5tZXNoZXNbbl07dyhULGIsZil9Zm9yKG49MDtuPGIuY2FtZXJhcy5sZW5ndGg7bisrKXt2YXIgVT1iLmNhbWVyYXNbbl07aWYoVS5fd2FpdGluZ1BhcmVudElkJiYoVS5wYXJlbnQ9Yi5nZXRMYXN0RW50cnlCeUlEKFUuX3dhaXRpbmdQYXJlbnRJZCksZGVsZXRlIFUuX3dhaXRpbmdQYXJlbnRJZCksVSBpbnN0YW5jZW9mIGEuRnJlZUNhbWVyYSl7dmFyIFY9VTtWLl93YWl0aW5nTG9ja2VkVGFyZ2V0SWQmJihWLmxvY2tlZFRhcmdldD1iLmdldExhc3RFbnRyeUJ5SUQoVi5fd2FpdGluZ0xvY2tlZFRhcmdldElkKSxkZWxldGUgVi5fd2FpdGluZ0xvY2tlZFRhcmdldElkKX19aWYoay5wYXJ0aWNsZVN5c3RlbXMpZm9yKG49MDtuPGsucGFydGljbGVTeXN0ZW1zLmxlbmd0aDtuKyspe3ZhciBXPWsucGFydGljbGVTeXN0ZW1zW25dO2koVyxiLGYpfWlmKGsubGVuc0ZsYXJlU3lzdGVtcylmb3Iobj0wO248ay5sZW5zRmxhcmVTeXN0ZW1zLmxlbmd0aDtuKyspe3ZhciBYPWsubGVuc0ZsYXJlU3lzdGVtc1tuXTtoKFgsYixmKX1pZihrLnNoYWRvd0dlbmVyYXRvcnMpZm9yKG49MDtuPGsuc2hhZG93R2VuZXJhdG9ycy5sZW5ndGg7bisrKXt2YXIgWT1rLnNoYWRvd0dlbmVyYXRvcnNbbl07aihZLGIpfXJldHVybiEwfX0pfShhLkludGVybmFsc3x8KGEuSW50ZXJuYWxzPXt9KSk7YS5JbnRlcm5hbHN9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPTAsYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMpe3RoaXMucG9zPWEsdGhpcy5ub3JtYWw9Yix0aGlzLnV2PWN9cmV0dXJuIGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiKHRoaXMucG9zLmNsb25lKCksdGhpcy5ub3JtYWwuY2xvbmUoKSx0aGlzLnV2LmNsb25lKCkpfSxiLnByb3RvdHlwZS5mbGlwPWZ1bmN0aW9uKCl7dGhpcy5ub3JtYWw9dGhpcy5ub3JtYWwuc2NhbGUoLTEpfSxiLnByb3RvdHlwZS5pbnRlcnBvbGF0ZT1mdW5jdGlvbihjLGQpe3JldHVybiBuZXcgYihhLlZlY3RvcjMuTGVycCh0aGlzLnBvcyxjLnBvcyxkKSxhLlZlY3RvcjMuTGVycCh0aGlzLm5vcm1hbCxjLm5vcm1hbCxkKSxhLlZlY3RvcjIuTGVycCh0aGlzLnV2LGMudXYsZCkpfSxifSgpLGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYil7dGhpcy5ub3JtYWw9YSx0aGlzLnc9Yn1yZXR1cm4gYi5Gcm9tUG9pbnRzPWZ1bmN0aW9uKGMsZCxlKXt2YXIgZj1lLnN1YnRyYWN0KGMpLGc9ZC5zdWJ0cmFjdChjKTtpZigwPT09Zi5sZW5ndGhTcXVhcmVkKCl8fDA9PT1nLmxlbmd0aFNxdWFyZWQoKSlyZXR1cm4gbnVsbDt2YXIgaD1hLlZlY3RvcjMuTm9ybWFsaXplKGEuVmVjdG9yMy5Dcm9zcyhmLGcpKTtyZXR1cm4gbmV3IGIoaCxhLlZlY3RvcjMuRG90KGgsYykpfSxiLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYih0aGlzLm5vcm1hbC5jbG9uZSgpLHRoaXMudyl9LGIucHJvdG90eXBlLmZsaXA9ZnVuY3Rpb24oKXt0aGlzLm5vcm1hbC5zY2FsZUluUGxhY2UoLTEpLHRoaXMudz0tdGhpcy53fSxiLnByb3RvdHlwZS5zcGxpdFBvbHlnb249ZnVuY3Rpb24oYyxkLGYsZyxoKXtmb3IodmFyIGk9MCxqPTEsaz0yLGw9MyxtPTAsbj1bXSxvPTA7bzxjLnZlcnRpY2VzLmxlbmd0aDtvKyspe3ZhciBwPWEuVmVjdG9yMy5Eb3QodGhpcy5ub3JtYWwsYy52ZXJ0aWNlc1tvXS5wb3MpLXRoaXMudyxxPXA8LWIuRVBTSUxPTj9rOnA+Yi5FUFNJTE9OP2o6aTttfD1xLG4ucHVzaChxKX1zd2l0Y2gobSl7Y2FzZSBpOihhLlZlY3RvcjMuRG90KHRoaXMubm9ybWFsLGMucGxhbmUubm9ybWFsKT4wP2Q6ZikucHVzaChjKTticmVhaztjYXNlIGo6Zy5wdXNoKGMpO2JyZWFrO2Nhc2UgazpoLnB1c2goYyk7YnJlYWs7Y2FzZSBsOnZhciByPVtdLHM9W107Zm9yKG89MDtvPGMudmVydGljZXMubGVuZ3RoO28rKyl7dmFyIHQ9KG8rMSklYy52ZXJ0aWNlcy5sZW5ndGgsdT1uW29dLHY9blt0XSx3PWMudmVydGljZXNbb10seD1jLnZlcnRpY2VzW3RdO2lmKHUhPWsmJnIucHVzaCh3KSx1IT1qJiZzLnB1c2godSE9az93LmNsb25lKCk6dyksKHV8dik9PWwpe3A9KHRoaXMudy1hLlZlY3RvcjMuRG90KHRoaXMubm9ybWFsLHcucG9zKSkvYS5WZWN0b3IzLkRvdCh0aGlzLm5vcm1hbCx4LnBvcy5zdWJ0cmFjdCh3LnBvcykpO3ZhciB5PXcuaW50ZXJwb2xhdGUoeCxwKTtyLnB1c2goeSkscy5wdXNoKHkuY2xvbmUoKSl9fWlmKHIubGVuZ3RoPj0zKXt2YXIgej1uZXcgZShyLGMuc2hhcmVkKTt6LnBsYW5lJiZnLnB1c2goeil9cy5sZW5ndGg+PTMmJih6PW5ldyBlKHMsYy5zaGFyZWQpLHoucGxhbmUmJmgucHVzaCh6KSl9fSxiLkVQU0lMT049MWUtNSxifSgpLGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7dGhpcy52ZXJ0aWNlcz1hLHRoaXMuc2hhcmVkPWIsdGhpcy5wbGFuZT1kLkZyb21Qb2ludHMoYVswXS5wb3MsYVsxXS5wb3MsYVsyXS5wb3MpfXJldHVybiBhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBiPXRoaXMudmVydGljZXMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLmNsb25lKCl9KTtyZXR1cm4gbmV3IGEoYix0aGlzLnNoYXJlZCl9LGEucHJvdG90eXBlLmZsaXA9ZnVuY3Rpb24oKXt0aGlzLnZlcnRpY2VzLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24oYSl7YS5mbGlwKCl9KSx0aGlzLnBsYW5lLmZsaXAoKX0sYX0oKSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzLnBsYW5lPW51bGwsdGhpcy5mcm9udD1udWxsLHRoaXMuYmFjaz1udWxsLHRoaXMucG9seWdvbnM9W10sYSYmdGhpcy5idWlsZChhKX1yZXR1cm4gYS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYj1uZXcgYTtyZXR1cm4gYi5wbGFuZT10aGlzLnBsYW5lJiZ0aGlzLnBsYW5lLmNsb25lKCksYi5mcm9udD10aGlzLmZyb250JiZ0aGlzLmZyb250LmNsb25lKCksYi5iYWNrPXRoaXMuYmFjayYmdGhpcy5iYWNrLmNsb25lKCksYi5wb2x5Z29ucz10aGlzLnBvbHlnb25zLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS5jbG9uZSgpfSksYn0sYS5wcm90b3R5cGUuaW52ZXJ0PWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLnBvbHlnb25zLmxlbmd0aDthKyspdGhpcy5wb2x5Z29uc1thXS5mbGlwKCk7dGhpcy5wbGFuZSYmdGhpcy5wbGFuZS5mbGlwKCksdGhpcy5mcm9udCYmdGhpcy5mcm9udC5pbnZlcnQoKSx0aGlzLmJhY2smJnRoaXMuYmFjay5pbnZlcnQoKTt2YXIgYj10aGlzLmZyb250O3RoaXMuZnJvbnQ9dGhpcy5iYWNrLHRoaXMuYmFjaz1ifSxhLnByb3RvdHlwZS5jbGlwUG9seWdvbnM9ZnVuY3Rpb24oYSl7aWYoIXRoaXMucGxhbmUpcmV0dXJuIGEuc2xpY2UoKTtmb3IodmFyIGI9W10sYz1bXSxkPTA7ZDxhLmxlbmd0aDtkKyspdGhpcy5wbGFuZS5zcGxpdFBvbHlnb24oYVtkXSxiLGMsYixjKTtyZXR1cm4gdGhpcy5mcm9udCYmKGI9dGhpcy5mcm9udC5jbGlwUG9seWdvbnMoYikpLGM9dGhpcy5iYWNrP3RoaXMuYmFjay5jbGlwUG9seWdvbnMoYyk6W10sYi5jb25jYXQoYyl9LGEucHJvdG90eXBlLmNsaXBUbz1mdW5jdGlvbihhKXt0aGlzLnBvbHlnb25zPWEuY2xpcFBvbHlnb25zKHRoaXMucG9seWdvbnMpLHRoaXMuZnJvbnQmJnRoaXMuZnJvbnQuY2xpcFRvKGEpLHRoaXMuYmFjayYmdGhpcy5iYWNrLmNsaXBUbyhhKX0sYS5wcm90b3R5cGUuYWxsUG9seWdvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBvbHlnb25zLnNsaWNlKCk7cmV0dXJuIHRoaXMuZnJvbnQmJihhPWEuY29uY2F0KHRoaXMuZnJvbnQuYWxsUG9seWdvbnMoKSkpLHRoaXMuYmFjayYmKGE9YS5jb25jYXQodGhpcy5iYWNrLmFsbFBvbHlnb25zKCkpKSxhfSxhLnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihiKXtpZihiLmxlbmd0aCl7dGhpcy5wbGFuZXx8KHRoaXMucGxhbmU9YlswXS5wbGFuZS5jbG9uZSgpKTtmb3IodmFyIGM9W10sZD1bXSxlPTA7ZTxiLmxlbmd0aDtlKyspdGhpcy5wbGFuZS5zcGxpdFBvbHlnb24oYltlXSx0aGlzLnBvbHlnb25zLHRoaXMucG9seWdvbnMsYyxkKTtjLmxlbmd0aCYmKHRoaXMuZnJvbnR8fCh0aGlzLmZyb250PW5ldyBhKSx0aGlzLmZyb250LmJ1aWxkKGMpKSxkLmxlbmd0aCYmKHRoaXMuYmFja3x8KHRoaXMuYmFjaz1uZXcgYSksdGhpcy5iYWNrLmJ1aWxkKGQpKX19LGF9KCksZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoKXt0aGlzLnBvbHlnb25zPW5ldyBBcnJheX1yZXR1cm4gZC5Gcm9tTWVzaD1mdW5jdGlvbihmKXt2YXIgZyxoLGksaixrLGwsbT1bXTtpZighKGYgaW5zdGFuY2VvZiBhLk1lc2gpKXRocm93XCJCQUJZTE9OLkNTRzpXcm9uZyBNZXNoIHR5cGUsbXVzdCBiZSBCQUJZTE9OLk1lc2hcIjtmLmNvbXB1dGVXb3JsZE1hdHJpeCghMCk7Zm9yKHZhciBuPWYuZ2V0V29ybGRNYXRyaXgoKSxvPWYucG9zaXRpb24uY2xvbmUoKSxwPWYucm90YXRpb24uY2xvbmUoKSxxPWYuc2NhbGluZy5jbG9uZSgpLHI9Zi5nZXRJbmRpY2VzKCkscz1mLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpLHQ9Zi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCksdT1mLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQpLHY9Zi5zdWJNZXNoZXMsdz0wLHg9di5sZW5ndGg7eD53O3crKylmb3IodmFyIHk9dlt3XS5pbmRleFN0YXJ0LHo9dlt3XS5pbmRleENvdW50K3Zbd10uaW5kZXhTdGFydDt6Pnk7eSs9Myl7bD1bXTtmb3IodmFyIEE9MDszPkE7QSsrKWg9bmV3IGEuVmVjdG9yMyh0WzMqclt5K0FdXSx0WzMqclt5K0FdKzFdLHRbMypyW3krQV0rMl0pLGk9bmV3IGEuVmVjdG9yMih1WzIqclt5K0FdXSx1WzIqclt5K0FdKzFdKSxqPW5ldyBhLlZlY3RvcjMoc1szKnJbeStBXV0sc1szKnJbeStBXSsxXSxzWzMqclt5K0FdKzJdKSxhLlZlY3RvcjMuVHJhbnNmb3JtQ29vcmRpbmF0ZXNUb1JlZihqLG4saiksYS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKGgsbixoKSxnPW5ldyBjKGosaCxpKSxsLnB1c2goZyk7az1uZXcgZShsLHtzdWJNZXNoSWQ6dyxtZXNoSWQ6YixtYXRlcmlhbEluZGV4OnZbd10ubWF0ZXJpYWxJbmRleH0pLGsucGxhbmUmJm0ucHVzaChrKX12YXIgQj1kLkZyb21Qb2x5Z29ucyhtKTtyZXR1cm4gQi5tYXRyaXg9bixCLnBvc2l0aW9uPW8sQi5yb3RhdGlvbj1wLEIuc2NhbGluZz1xLGIrKyxCfSxkLkZyb21Qb2x5Z29ucz1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYS5DU0c7cmV0dXJuIGMucG9seWdvbnM9YixjfSxkLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBiPW5ldyBhLkNTRztyZXR1cm4gYi5wb2x5Z29ucz10aGlzLnBvbHlnb25zLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS5jbG9uZSgpfSksYi5jb3B5VHJhbnNmb3JtQXR0cmlidXRlcyh0aGlzKSxifSxkLnByb3RvdHlwZS50b1BvbHlnb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbnN9LGQucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBmKHRoaXMuY2xvbmUoKS5wb2x5Z29ucyksYz1uZXcgZihhLmNsb25lKCkucG9seWdvbnMpO3JldHVybiBiLmNsaXBUbyhjKSxjLmNsaXBUbyhiKSxjLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLGQuRnJvbVBvbHlnb25zKGIuYWxsUG9seWdvbnMoKSkuY29weVRyYW5zZm9ybUF0dHJpYnV0ZXModGhpcyl9LGQucHJvdG90eXBlLnVuaW9uSW5QbGFjZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZih0aGlzLnBvbHlnb25zKSxjPW5ldyBmKGEucG9seWdvbnMpO2IuY2xpcFRvKGMpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYy5jbGlwVG8oYiksYy5pbnZlcnQoKSxiLmJ1aWxkKGMuYWxsUG9seWdvbnMoKSksdGhpcy5wb2x5Z29ucz1iLmFsbFBvbHlnb25zKCl9LGQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBmKHRoaXMuY2xvbmUoKS5wb2x5Z29ucyksYz1uZXcgZihhLmNsb25lKCkucG9seWdvbnMpO3JldHVybiBiLmludmVydCgpLGIuY2xpcFRvKGMpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYy5jbGlwVG8oYiksYy5pbnZlcnQoKSxiLmJ1aWxkKGMuYWxsUG9seWdvbnMoKSksYi5pbnZlcnQoKSxkLkZyb21Qb2x5Z29ucyhiLmFsbFBvbHlnb25zKCkpLmNvcHlUcmFuc2Zvcm1BdHRyaWJ1dGVzKHRoaXMpfSxkLnByb3RvdHlwZS5zdWJ0cmFjdEluUGxhY2U9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGYodGhpcy5wb2x5Z29ucyksYz1uZXcgZihhLnBvbHlnb25zKTtiLmludmVydCgpLGIuY2xpcFRvKGMpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYy5jbGlwVG8oYiksYy5pbnZlcnQoKSxiLmJ1aWxkKGMuYWxsUG9seWdvbnMoKSksYi5pbnZlcnQoKSx0aGlzLnBvbHlnb25zPWIuYWxsUG9seWdvbnMoKX0sZC5wcm90b3R5cGUuaW50ZXJzZWN0PWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBmKHRoaXMuY2xvbmUoKS5wb2x5Z29ucyksYz1uZXcgZihhLmNsb25lKCkucG9seWdvbnMpO3JldHVybiBiLmludmVydCgpLGMuY2xpcFRvKGIpLGMuaW52ZXJ0KCksYi5jbGlwVG8oYyksYy5jbGlwVG8oYiksYi5idWlsZChjLmFsbFBvbHlnb25zKCkpLGIuaW52ZXJ0KCksZC5Gcm9tUG9seWdvbnMoYi5hbGxQb2x5Z29ucygpKS5jb3B5VHJhbnNmb3JtQXR0cmlidXRlcyh0aGlzKX0sZC5wcm90b3R5cGUuaW50ZXJzZWN0SW5QbGFjZT1mdW5jdGlvbihhKXt2YXIgYj1uZXcgZih0aGlzLnBvbHlnb25zKSxjPW5ldyBmKGEucG9seWdvbnMpO2IuaW52ZXJ0KCksYy5jbGlwVG8oYiksYy5pbnZlcnQoKSxiLmNsaXBUbyhjKSxjLmNsaXBUbyhiKSxiLmJ1aWxkKGMuYWxsUG9seWdvbnMoKSksYi5pbnZlcnQoKSx0aGlzLnBvbHlnb25zPWIuYWxsUG9seWdvbnMoKX0sZC5wcm90b3R5cGUuaW52ZXJzZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2xvbmUoKTtyZXR1cm4gYS5pbnZlcnNlSW5QbGFjZSgpLGF9LGQucHJvdG90eXBlLmludmVyc2VJblBsYWNlPWZ1bmN0aW9uKCl7dGhpcy5wb2x5Z29ucy5tYXAoZnVuY3Rpb24oYSl7YS5mbGlwKCl9KX0sZC5wcm90b3R5cGUuY29weVRyYW5zZm9ybUF0dHJpYnV0ZXM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubWF0cml4PWEubWF0cml4LHRoaXMucG9zaXRpb249YS5wb3NpdGlvbix0aGlzLnJvdGF0aW9uPWEucm90YXRpb24sdGhpcy5zY2FsaW5nPWEuc2NhbGluZyx0aGlzfSxkLnByb3RvdHlwZS5idWlsZE1lc2hHZW9tZXRyeT1mdW5jdGlvbihiLGMsZCl7dmFyIGU9dGhpcy5tYXRyaXguY2xvbmUoKTtlLmludmVydCgpO3ZhciBmLGcsaCxpPW5ldyBhLk1lc2goYixjKSxqPVtdLGs9W10sbD1bXSxtPVtdLG49YS5WZWN0b3IzLlplcm8oKSxvPWEuVmVjdG9yMy5aZXJvKCkscD1hLlZlY3RvcjIuWmVybygpLHE9dGhpcy5wb2x5Z29ucyxyPVswLDAsMF0scz17fSx0PTAsdT17fTtkJiZxLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zaGFyZWQubWVzaElkPT09Yi5zaGFyZWQubWVzaElkP2Euc2hhcmVkLnN1Yk1lc2hJZC1iLnNoYXJlZC5zdWJNZXNoSWQ6YS5zaGFyZWQubWVzaElkLWIuc2hhcmVkLm1lc2hJZH0pO2Zvcih2YXIgdj0wLHc9cS5sZW5ndGg7dz52O3YrKyl7Zj1xW3ZdLHVbZi5zaGFyZWQubWVzaElkXXx8KHVbZi5zaGFyZWQubWVzaElkXT17fSksdVtmLnNoYXJlZC5tZXNoSWRdW2Yuc2hhcmVkLnN1Yk1lc2hJZF18fCh1W2Yuc2hhcmVkLm1lc2hJZF1bZi5zaGFyZWQuc3ViTWVzaElkXT17aW5kZXhTdGFydDorMS8wLGluZGV4RW5kOi0xLzAsbWF0ZXJpYWxJbmRleDpmLnNoYXJlZC5tYXRlcmlhbEluZGV4fSksaD11W2Yuc2hhcmVkLm1lc2hJZF1bZi5zaGFyZWQuc3ViTWVzaElkXTtmb3IodmFyIHg9Mix5PWYudmVydGljZXMubGVuZ3RoO3k+eDt4Kyspe3JbMF09MCxyWzFdPXgtMSxyWzJdPXg7Zm9yKHZhciB6PTA7Mz56O3orKyluLmNvcHlGcm9tKGYudmVydGljZXNbclt6XV0ucG9zKSxvLmNvcHlGcm9tKGYudmVydGljZXNbclt6XV0ubm9ybWFsKSxwLmNvcHlGcm9tKGYudmVydGljZXNbclt6XV0udXYpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKG4sZSxuKSxhLlZlY3RvcjMuVHJhbnNmb3JtTm9ybWFsVG9SZWYobyxlLG8pLGc9c1tuLngrXCIsXCIrbi55K1wiLFwiK24uel0sKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnfHxsWzMqZ10hPT1vLnh8fGxbMypnKzFdIT09by55fHxsWzMqZysyXSE9PW8uenx8bVsyKmddIT09cC54fHxtWzIqZysxXSE9PXAueSkmJihqLnB1c2gobi54LG4ueSxuLnopLG0ucHVzaChwLngscC55KSxsLnB1c2goby54LG8ueSxvLnopLGc9c1tuLngrXCIsXCIrbi55K1wiLFwiK24uel09ai5sZW5ndGgvMy0xKSxrLnB1c2goZyksaC5pbmRleFN0YXJ0PU1hdGgubWluKHQsaC5pbmRleFN0YXJ0KSxoLmluZGV4RW5kPU1hdGgubWF4KHQsaC5pbmRleEVuZCksdCsrfX1pZihpLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsaiksaS5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCxsKSxpLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQsbSksaS5zZXRJbmRpY2VzKGspLGQpe3ZhciBBLEI9MDtpLnN1Yk1lc2hlcy5sZW5ndGg9MDtmb3IodmFyIEMgaW4gdSl7QT0tMTtmb3IodmFyIEQgaW4gdVtDXSloPXVbQ11bRF0sYS5TdWJNZXNoLkNyZWF0ZUZyb21JbmRpY2VzKGgubWF0ZXJpYWxJbmRleCtCLGguaW5kZXhTdGFydCxoLmluZGV4RW5kLWguaW5kZXhTdGFydCsxLGkpLEE9TWF0aC5tYXgoaC5tYXRlcmlhbEluZGV4LEEpO0IrPSsrQX19cmV0dXJuIGl9LGQucHJvdG90eXBlLnRvTWVzaD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmJ1aWxkTWVzaEdlb21ldHJ5KGEsYyxkKTtyZXR1cm4gZS5tYXRlcmlhbD1iLGUucG9zaXRpb24uY29weUZyb20odGhpcy5wb3NpdGlvbiksZS5yb3RhdGlvbi5jb3B5RnJvbSh0aGlzLnJvdGF0aW9uKSxlLnNjYWxpbmcuY29weUZyb20odGhpcy5zY2FsaW5nKSxlLmNvbXB1dGVXb3JsZE1hdHJpeCghMCksZX0sZH0oKTthLkNTRz1nfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQsZSxmKXt2YXIgZz10aGlzO2IuY2FsbCh0aGlzLGMsXCJvY3VsdXNEaXN0b3J0aW9uQ29ycmVjdGlvblwiLFtcIkxlbnNDZW50ZXJcIixcIlNjYWxlXCIsXCJTY2FsZUluXCIsXCJIbWRXYXJwUGFyYW1cIl0sbnVsbCxmLlBvc3RQcm9jZXNzU2NhbGVGYWN0b3IsZCxhLlRleHR1cmUuQklMSU5FQVJfU0FNUExJTkdNT0RFLG51bGwsbnVsbCksdGhpcy5faXNSaWdodEV5ZT1lLHRoaXMuX2Rpc3RvcnRpb25GYWN0b3JzPWYuRGlzdG9ydGlvbkssdGhpcy5fcG9zdFByb2Nlc3NTY2FsZUZhY3Rvcj1mLlBvc3RQcm9jZXNzU2NhbGVGYWN0b3IsdGhpcy5fbGVuc0NlbnRlck9mZnNldD1mLkxlbnNDZW50ZXJPZmZzZXQsdGhpcy5vblNpemVDaGFuZ2VkPWZ1bmN0aW9uKCl7Zy5hc3BlY3RSYXRpbz0uNSpnLndpZHRoL2cuaGVpZ2h0LGcuX3NjYWxlSW49bmV3IGEuVmVjdG9yMigyLDIvZy5hc3BlY3RSYXRpbyksZy5fc2NhbGVGYWN0b3I9bmV3IGEuVmVjdG9yMiguNSooMS9nLl9wb3N0UHJvY2Vzc1NjYWxlRmFjdG9yKSwuNSooMS9nLl9wb3N0UHJvY2Vzc1NjYWxlRmFjdG9yKSpnLmFzcGVjdFJhdGlvKSxnLl9sZW5zQ2VudGVyPW5ldyBhLlZlY3RvcjIoZy5faXNSaWdodEV5ZT8uNS0uNSpnLl9sZW5zQ2VudGVyT2Zmc2V0Oi41Ky41KmcuX2xlbnNDZW50ZXJPZmZzZXQsLjUpfSx0aGlzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRGbG9hdDIoXCJMZW5zQ2VudGVyXCIsZy5fbGVuc0NlbnRlci54LGcuX2xlbnNDZW50ZXIueSksYS5zZXRGbG9hdDIoXCJTY2FsZVwiLGcuX3NjYWxlRmFjdG9yLngsZy5fc2NhbGVGYWN0b3IueSksYS5zZXRGbG9hdDIoXCJTY2FsZUluXCIsZy5fc2NhbGVJbi54LGcuX3NjYWxlSW4ueSksYS5zZXRGbG9hdDQoXCJIbWRXYXJwUGFyYW1cIixnLl9kaXN0b3J0aW9uRmFjdG9yc1swXSxnLl9kaXN0b3J0aW9uRmFjdG9yc1sxXSxnLl9kaXN0b3J0aW9uRmFjdG9yc1syXSxnLl9kaXN0b3J0aW9uRmFjdG9yc1szXSl9fXJldHVybiBfX2V4dGVuZHMoYyxiKSxjfShhLlBvc3RQcm9jZXNzKTthLk9jdWx1c0Rpc3RvcnRpb25Db3JyZWN0aW9uUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7IWZ1bmN0aW9uKGEpe2FbYS5YPTBdPVwiWFwiLGFbYS5ZPTFdPVwiWVwiLGFbYS5aPTJdPVwiWlwifShhLkpveXN0aWNrQXhpc3x8KGEuSm95c3RpY2tBeGlzPXt9KSk7dmFyIGI9KGEuSm95c3RpY2tBeGlzLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihjKXt2YXIgZD10aGlzO3RoaXMuX2xlZnRKb3lzdGljaz1jPyEwOiExLHRoaXMuX2pveXN0aWNrSW5kZXg9Yi5fZ2xvYmFsSm95c3RpY2tJbmRleCxiLl9nbG9iYWxKb3lzdGlja0luZGV4KyssdGhpcy5fYXhpc1RhcmdldGVkQnlMZWZ0QW5kUmlnaHQ9MCx0aGlzLl9heGlzVGFyZ2V0ZWRCeVVwQW5kRG93bj0xLHRoaXMucmV2ZXJzZUxlZnRSaWdodD0hMSx0aGlzLnJldmVyc2VVcERvd249ITEsdGhpcy5fdG91Y2hlcz1uZXcgYS5WaXJ0dWFsSm95c3RpY2suQ29sbGVjdGlvbix0aGlzLmRlbHRhUG9zaXRpb249YS5WZWN0b3IzLlplcm8oKSx0aGlzLl9qb3lzdGlja1NlbnNpYmlsaXR5PTI1LHRoaXMuX2ludmVyc2VkU2Vuc2liaWxpdHk9MS8odGhpcy5fam95c3RpY2tTZW5zaWJpbGl0eS8xZTMpLHRoaXMuX3JvdGF0aW9uU3BlZWQ9MjUsdGhpcy5faW52ZXJzZVJvdGF0aW9uU3BlZWQ9MS8odGhpcy5fcm90YXRpb25TcGVlZC8xZTMpLHRoaXMuX3JvdGF0ZU9uQXhpc1JlbGF0aXZlVG9NZXNoPSExLGIudmpDYW52YXN8fCh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLGZ1bmN0aW9uKCl7Yi52akNhbnZhc1dpZHRoPXdpbmRvdy5pbm5lcldpZHRoLGIudmpDYW52YXNIZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0LGIudmpDYW52YXMud2lkdGg9Yi52akNhbnZhc1dpZHRoLGIudmpDYW52YXMuaGVpZ2h0PWIudmpDYW52YXNIZWlnaHQsYi5oYWxmV2lkdGg9Yi52akNhbnZhc1dpZHRoLzIsYi5oYWxmSGVpZ2h0PWIudmpDYW52YXNIZWlnaHQvMn0sITEpLGIudmpDYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxiLnZqQ2FudmFzV2lkdGg9d2luZG93LmlubmVyV2lkdGgsYi52akNhbnZhc0hlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQsYi52akNhbnZhcy53aWR0aD13aW5kb3cuaW5uZXJXaWR0aCxiLnZqQ2FudmFzLmhlaWdodD13aW5kb3cuaW5uZXJIZWlnaHQsYi52akNhbnZhcy5zdHlsZS53aWR0aD1cIjEwMCVcIixiLnZqQ2FudmFzLnN0eWxlLmhlaWdodD1cIjEwMCVcIixiLnZqQ2FudmFzLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixiLnZqQ2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInRyYW5zcGFyZW50XCIsYi52akNhbnZhcy5zdHlsZS50b3A9XCIwcHhcIixiLnZqQ2FudmFzLnN0eWxlLmxlZnQ9XCIwcHhcIixiLnZqQ2FudmFzLnN0eWxlLnpJbmRleD1cIjVcIixiLnZqQ2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb249XCJub25lXCIsYi52akNhbnZhc0NvbnRleHQ9Yi52akNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGU9XCIjZmZmZmZmXCIsYi52akNhbnZhc0NvbnRleHQubGluZVdpZHRoPTIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiLnZqQ2FudmFzKSksYi5oYWxmV2lkdGg9Yi52akNhbnZhcy53aWR0aC8yLGIuaGFsZkhlaWdodD1iLnZqQ2FudmFzLmhlaWdodC8yLHRoaXMucHJlc3NlZD0hMSx0aGlzLl9qb3lzdGlja0NvbG9yPVwiY3lhblwiLHRoaXMuX2pveXN0aWNrUG9pbnRlcklEPS0xLHRoaXMuX2pveXN0aWNrUG9pbnRlclBvcz1uZXcgYS5WZWN0b3IyKDAsMCksdGhpcy5fam95c3RpY2tQb2ludGVyU3RhcnRQb3M9bmV3IGEuVmVjdG9yMigwLDApLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3I9bmV3IGEuVmVjdG9yMigwLDApLGIudmpDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsZnVuY3Rpb24oYSl7ZC5fb25Qb2ludGVyRG93bihhKX0sITEpLGIudmpDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsZnVuY3Rpb24oYSl7ZC5fb25Qb2ludGVyTW92ZShhKX0sITEpLGIudmpDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLGZ1bmN0aW9uKGEpe2QuX29uUG9pbnRlclVwKGEpfSwhMSksYi52akNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm91dFwiLGZ1bmN0aW9uKGEpe2QuX29uUG9pbnRlclVwKGEpfSwhMSksYi52akNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9LCExKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtkLl9kcmF3VmlydHVhbEpveXN0aWNrKCl9KX1yZXR1cm4gYi5wcm90b3R5cGUuc2V0Sm95c3RpY2tTZW5zaWJpbGl0eT1mdW5jdGlvbihhKXt0aGlzLl9qb3lzdGlja1NlbnNpYmlsaXR5PWEsdGhpcy5faW52ZXJzZWRTZW5zaWJpbGl0eT0xLyh0aGlzLl9qb3lzdGlja1NlbnNpYmlsaXR5LzFlMyl9LGIucHJvdG90eXBlLl9vblBvaW50ZXJEb3duPWZ1bmN0aW9uKGEpe3ZhciBjO2EucHJldmVudERlZmF1bHQoKSxjPXRoaXMuX2xlZnRKb3lzdGljaz09PSEwP2EuY2xpZW50WDxiLmhhbGZXaWR0aDphLmNsaWVudFg+Yi5oYWxmV2lkdGgsYyYmdGhpcy5fam95c3RpY2tQb2ludGVySUQ8MD8odGhpcy5fam95c3RpY2tQb2ludGVySUQ9YS5wb2ludGVySWQsdGhpcy5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MueD1hLmNsaWVudFgsdGhpcy5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MueT1hLmNsaWVudFksdGhpcy5fam95c3RpY2tQb2ludGVyUG9zPXRoaXMuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zLmNsb25lKCksdGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvci54PTAsdGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvci55PTAsdGhpcy5wcmVzc2VkPSEwLHRoaXMuX3RvdWNoZXMuYWRkKGEucG9pbnRlcklkLnRvU3RyaW5nKCksYSkpOmIuX2dsb2JhbEpveXN0aWNrSW5kZXg8MiYmdGhpcy5fYWN0aW9uJiYodGhpcy5fYWN0aW9uKCksdGhpcy5fdG91Y2hlcy5hZGQoYS5wb2ludGVySWQudG9TdHJpbmcoKSxhKSl9LGIucHJvdG90eXBlLl9vblBvaW50ZXJNb3ZlPWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2pveXN0aWNrUG9pbnRlcklEPT1hLnBvaW50ZXJJZCl7dGhpcy5fam95c3RpY2tQb2ludGVyUG9zLng9YS5jbGllbnRYLHRoaXMuX2pveXN0aWNrUG9pbnRlclBvcy55PWEuY2xpZW50WSx0aGlzLl9kZWx0YUpveXN0aWNrVmVjdG9yPXRoaXMuX2pveXN0aWNrUG9pbnRlclBvcy5jbG9uZSgpLHRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3I9dGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvci5zdWJ0cmFjdCh0aGlzLl9qb3lzdGlja1BvaW50ZXJTdGFydFBvcyk7dmFyIGI9dGhpcy5yZXZlcnNlTGVmdFJpZ2h0Py0xOjEsYz1iKnRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueC90aGlzLl9pbnZlcnNlZFNlbnNpYmlsaXR5O3N3aXRjaCh0aGlzLl9heGlzVGFyZ2V0ZWRCeUxlZnRBbmRSaWdodCl7Y2FzZSAwOnRoaXMuZGVsdGFQb3NpdGlvbi54PU1hdGgubWluKDEsTWF0aC5tYXgoLTEsYykpO2JyZWFrO2Nhc2UgMTp0aGlzLmRlbHRhUG9zaXRpb24ueT1NYXRoLm1pbigxLE1hdGgubWF4KC0xLGMpKTticmVhaztjYXNlIDI6dGhpcy5kZWx0YVBvc2l0aW9uLno9TWF0aC5taW4oMSxNYXRoLm1heCgtMSxjKSl9dmFyIGQ9dGhpcy5yZXZlcnNlVXBEb3duPzE6LTEsZT1kKnRoaXMuX2RlbHRhSm95c3RpY2tWZWN0b3IueS90aGlzLl9pbnZlcnNlZFNlbnNpYmlsaXR5O3N3aXRjaCh0aGlzLl9heGlzVGFyZ2V0ZWRCeVVwQW5kRG93bil7Y2FzZSAwOnRoaXMuZGVsdGFQb3NpdGlvbi54PU1hdGgubWluKDEsTWF0aC5tYXgoLTEsZSkpO2JyZWFrO2Nhc2UgMTp0aGlzLmRlbHRhUG9zaXRpb24ueT1NYXRoLm1pbigxLE1hdGgubWF4KC0xLGUpKTticmVhaztjYXNlIDI6dGhpcy5kZWx0YVBvc2l0aW9uLno9TWF0aC5taW4oMSxNYXRoLm1heCgtMSxlKSl9fWVsc2UgdGhpcy5fdG91Y2hlcy5pdGVtKGEucG9pbnRlcklkLnRvU3RyaW5nKCkpJiYodGhpcy5fdG91Y2hlcy5pdGVtKGEucG9pbnRlcklkLnRvU3RyaW5nKCkpLng9YS5jbGllbnRYLHRoaXMuX3RvdWNoZXMuaXRlbShhLnBvaW50ZXJJZC50b1N0cmluZygpKS55PWEuY2xpZW50WSl9LGIucHJvdG90eXBlLl9vblBvaW50ZXJVcD1mdW5jdGlvbihhKXt0aGlzLl9jbGVhckNhbnZhcygpLHRoaXMuX2pveXN0aWNrUG9pbnRlcklEPT1hLnBvaW50ZXJJZCYmKHRoaXMuX2pveXN0aWNrUG9pbnRlcklEPS0xLHRoaXMucHJlc3NlZD0hMSksdGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvci54PTAsdGhpcy5fZGVsdGFKb3lzdGlja1ZlY3Rvci55PTAsdGhpcy5fdG91Y2hlcy5yZW1vdmUoYS5wb2ludGVySWQudG9TdHJpbmcoKSl9LGIucHJvdG90eXBlLnNldEpveXN0aWNrQ29sb3I9ZnVuY3Rpb24oYSl7dGhpcy5fam95c3RpY2tDb2xvcj1hfSxiLnByb3RvdHlwZS5zZXRBY3Rpb25PblRvdWNoPWZ1bmN0aW9uKGEpe3RoaXMuX2FjdGlvbj1hfSxiLnByb3RvdHlwZS5zZXRBeGlzRm9yTGVmdFJpZ2h0PWZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjp0aGlzLl9heGlzVGFyZ2V0ZWRCeUxlZnRBbmRSaWdodD1hO2JyZWFrO2RlZmF1bHQ6dGhpcy5fYXhpc1RhcmdldGVkQnlMZWZ0QW5kUmlnaHQ9MH19LGIucHJvdG90eXBlLnNldEF4aXNGb3JVcERvd249ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOnRoaXMuX2F4aXNUYXJnZXRlZEJ5VXBBbmREb3duPWE7YnJlYWs7ZGVmYXVsdDp0aGlzLl9heGlzVGFyZ2V0ZWRCeVVwQW5kRG93bj0xfX0sYi5wcm90b3R5cGUuX2NsZWFyQ2FudmFzPWZ1bmN0aW9uKCl7dGhpcy5fbGVmdEpveXN0aWNrP2IudmpDYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLDAsYi52akNhbnZhc1dpZHRoLzIsYi52akNhbnZhc0hlaWdodCk6Yi52akNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KGIudmpDYW52YXNXaWR0aC8yLDAsYi52akNhbnZhc1dpZHRoLGIudmpDYW52YXNIZWlnaHQpfSxiLnByb3RvdHlwZS5fZHJhd1ZpcnR1YWxKb3lzdGljaz1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5wcmVzc2VkJiYodGhpcy5fY2xlYXJDYW52YXMoKSx0aGlzLl90b3VjaGVzLmZvckVhY2goZnVuY3Rpb24oYyl7Yy5wb2ludGVySWQ9PT1hLl9qb3lzdGlja1BvaW50ZXJJRD8oYi52akNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGU9YS5fam95c3RpY2tDb2xvcixiLnZqQ2FudmFzQ29udGV4dC5saW5lV2lkdGg9NixiLnZqQ2FudmFzQ29udGV4dC5hcmMoYS5fam95c3RpY2tQb2ludGVyU3RhcnRQb3MueCxhLl9qb3lzdGlja1BvaW50ZXJTdGFydFBvcy55LDQwLDAsMipNYXRoLlBJLCEwKSxiLnZqQ2FudmFzQ29udGV4dC5zdHJva2UoKSxiLnZqQ2FudmFzQ29udGV4dC5iZWdpblBhdGgoKSxiLnZqQ2FudmFzQ29udGV4dC5zdHJva2VTdHlsZT1hLl9qb3lzdGlja0NvbG9yLGIudmpDYW52YXNDb250ZXh0LmxpbmVXaWR0aD0yLGIudmpDYW52YXNDb250ZXh0LmFyYyhhLl9qb3lzdGlja1BvaW50ZXJTdGFydFBvcy54LGEuX2pveXN0aWNrUG9pbnRlclN0YXJ0UG9zLnksNjAsMCwyKk1hdGguUEksITApLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZSgpLGIudmpDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpLGIudmpDYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlPWEuX2pveXN0aWNrQ29sb3IsYi52akNhbnZhc0NvbnRleHQuYXJjKGEuX2pveXN0aWNrUG9pbnRlclBvcy54LGEuX2pveXN0aWNrUG9pbnRlclBvcy55LDQwLDAsMipNYXRoLlBJLCEwKSxiLnZqQ2FudmFzQ29udGV4dC5zdHJva2UoKSk6KGIudmpDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpLGIudmpDYW52YXNDb250ZXh0LmZpbGxTdHlsZT1cIndoaXRlXCIsYi52akNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGU9XCJyZWRcIixiLnZqQ2FudmFzQ29udGV4dC5saW5lV2lkdGg9NixiLnZqQ2FudmFzQ29udGV4dC5hcmMoYy54LGMueSw0MCwwLDIqTWF0aC5QSSwhMCksYi52akNhbnZhc0NvbnRleHQuc3Ryb2tlKCkpfSkpLHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuX2RyYXdWaXJ0dWFsSm95c3RpY2soKX0pfSxiLnByb3RvdHlwZS5yZWxlYXNlQ2FudmFzPWZ1bmN0aW9uKCl7Yi52akNhbnZhcyYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYi52akNhbnZhcyksYi52akNhbnZhcz1udWxsKX0sYi5fZ2xvYmFsSm95c3RpY2tJbmRleD0wLGJ9KCkpO2EuVmlydHVhbEpveXN0aWNrPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpeyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLl9jb3VudD0wLHRoaXMuX2NvbGxlY3Rpb249bmV3IEFycmF5fXJldHVybiBhLnByb3RvdHlwZS5Db3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb3VudH0sYS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHZvaWQgMCE9dGhpcy5fY29sbGVjdGlvblthXT92b2lkIDA6KHRoaXMuX2NvbGxlY3Rpb25bYV09YiwrK3RoaXMuX2NvdW50KX0sYS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PXRoaXMuX2NvbGxlY3Rpb25bYV0/dm9pZCAwOihkZWxldGUgdGhpcy5fY29sbGVjdGlvblthXSwtLXRoaXMuX2NvdW50KX0sYS5wcm90b3R5cGUuaXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fY29sbGVjdGlvblthXX0sYS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihhKXt2YXIgYjtmb3IoYiBpbiB0aGlzLl9jb2xsZWN0aW9uKXRoaXMuX2NvbGxlY3Rpb24uaGFzT3duUHJvcGVydHkoYikmJmEodGhpcy5fY29sbGVjdGlvbltiXSl9LGF9KCk7YS5Db2xsZWN0aW9uPWJ9KGEuVmlydHVhbEpveXN0aWNrfHwoYS5WaXJ0dWFsSm95c3RpY2s9e30pKTthLlZpcnR1YWxKb3lzdGlja30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPXtIUmVzb2x1dGlvbjoxMjgwLFZSZXNvbHV0aW9uOjgwMCxIU2NyZWVuU2l6ZTouMTQ5NzU5OTkzLFZTY3JlZW5TaXplOi4wOTM1OTk5OTc1LFZTY3JlZW5DZW50ZXI6LjA0Njc5OTk5ODcsRXllVG9TY3JlZW5EaXN0YW5jZTouMDQxMDAwMDAxMSxMZW5zU2VwYXJhdGlvbkRpc3RhbmNlOi4wNjM1MDAwMDIsSW50ZXJwdXBpbGxhcnlEaXN0YW5jZTouMDY0MDAwMDAzLERpc3RvcnRpb25LOlsxLC4yMTk5OTk5OTksLjIzOTk5OTk5NSwwXSxDaHJvbWFBYkNvcnJlY3Rpb246Wy45OTU5OTk5OTIsLS4wMDQwMDAwMDAxOSwxLjAxNDAwMDA2LDBdLFBvc3RQcm9jZXNzU2NhbGVGYWN0b3I6MS43MTQ2MDU1MDc4MDg0MTIsTGVuc0NlbnRlck9mZnNldDouMTUxOTc2NDIxfSxjPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoZCxlLGYsZyl7Yy5jYWxsKHRoaXMsZCxlLGYpLHRoaXMuX3dvcmtNYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuX2FjdHVhbFVwPW5ldyBhLlZlY3RvcjMoMCwwLDApLHRoaXMuX2FzcGVjdFJhdGlvQXNwZWN0UmF0aW89Yi5IUmVzb2x1dGlvbi8oMipiLlZSZXNvbHV0aW9uKSx0aGlzLl9hc3BlY3RSYXRpb0Zvdj0yKk1hdGguYXRhbihiLlBvc3RQcm9jZXNzU2NhbGVGYWN0b3IqYi5WU2NyZWVuU2l6ZS8oMipiLkV5ZVRvU2NyZWVuRGlzdGFuY2UpKTt2YXIgaD1iLkhTY3JlZW5TaXplLzQtYi5MZW5zU2VwYXJhdGlvbkRpc3RhbmNlLzIsaT00KmgvYi5IU2NyZWVuU2l6ZTt0aGlzLl9oTWF0cml4PWEuTWF0cml4LlRyYW5zbGF0aW9uKGc/aTotaSwwLDApLHRoaXMudmlld3BvcnQ9bmV3IGEuVmlld3BvcnQoZz8wOi41LDAsLjUsMSksdGhpcy5fcHJlVmlld01hdHJpeD1hLk1hdHJpeC5UcmFuc2xhdGlvbihnPy41KmIuSW50ZXJwdXBpbGxhcnlEaXN0YW5jZTotLjUqYi5JbnRlcnB1cGlsbGFyeURpc3RhbmNlLDAsMCk7bmV3IGEuT2N1bHVzRGlzdG9ydGlvbkNvcnJlY3Rpb25Qb3N0UHJvY2VzcyhcIk9jdWx1cyBEaXN0b3J0aW9uXCIsdGhpcywhZyxiKX1yZXR1cm4gX19leHRlbmRzKGQsYyksZC5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbk1hdHJpeD1mdW5jdGlvbigpe3JldHVybiBhLk1hdHJpeC5QZXJzcGVjdGl2ZUZvdkxIVG9SZWYodGhpcy5fYXNwZWN0UmF0aW9Gb3YsdGhpcy5fYXNwZWN0UmF0aW9Bc3BlY3RSYXRpbyx0aGlzLm1pblosdGhpcy5tYXhaLHRoaXMuX3dvcmtNYXRyaXgpLHRoaXMuX3dvcmtNYXRyaXgubXVsdGlwbHlUb1JlZih0aGlzLl9oTWF0cml4LHRoaXMuX3Byb2plY3Rpb25NYXRyaXgpLHRoaXMuX3Byb2plY3Rpb25NYXRyaXh9LGQucHJvdG90eXBlLl9nZXRWaWV3TWF0cml4PWZ1bmN0aW9uKCl7cmV0dXJuIGEuTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYodGhpcy5yb3RhdGlvbi55LHRoaXMucm90YXRpb24ueCx0aGlzLnJvdGF0aW9uLnosdGhpcy5fY2FtZXJhUm90YXRpb25NYXRyaXgpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHRoaXMuX3JlZmVyZW5jZVBvaW50LHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxUb1JlZih0aGlzLnVwVmVjdG9yLHRoaXMuX2NhbWVyYVJvdGF0aW9uTWF0cml4LHRoaXMuX2FjdHVhbFVwKSx0aGlzLnBvc2l0aW9uLmFkZFRvUmVmKHRoaXMuX3RyYW5zZm9ybWVkUmVmZXJlbmNlUG9pbnQsdGhpcy5fY3VycmVudFRhcmdldCksYS5NYXRyaXguTG9va0F0TEhUb1JlZih0aGlzLnBvc2l0aW9uLHRoaXMuX2N1cnJlbnRUYXJnZXQsdGhpcy5fYWN0dWFsVXAsdGhpcy5fd29ya01hdHJpeCksdGhpcy5fd29ya01hdHJpeC5tdWx0aXBseVRvUmVmKHRoaXMuX3ByZVZpZXdNYXRyaXgsdGhpcy5fdmlld01hdHJpeCksdGhpcy5fdmlld01hdHJpeH0sZH0oYS5GcmVlQ2FtZXJhKSxkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixkLGUpe2EuY2FsbCh0aGlzLGIsZCxlKSx0aGlzLl9sZWZ0Q2FtZXJhPW5ldyBjKGIrXCJfbGVmdFwiLGQuY2xvbmUoKSxlLCEwKSx0aGlzLl9yaWdodENhbWVyYT1uZXcgYyhiK1wiX3JpZ2h0XCIsZC5jbG9uZSgpLGUsITEpLHRoaXMuc3ViQ2FtZXJhcy5wdXNoKHRoaXMuX2xlZnRDYW1lcmEpLHRoaXMuc3ViQ2FtZXJhcy5wdXNoKHRoaXMuX3JpZ2h0Q2FtZXJhKSx0aGlzLl9kZXZpY2VPcmllbnRhdGlvbkhhbmRsZXI9dGhpcy5fb25PcmllbnRhdGlvbkV2ZW50LmJpbmQodGhpcyl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLl9sZWZ0Q2FtZXJhLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMucG9zaXRpb24pLHRoaXMuX3JpZ2h0Q2FtZXJhLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMucG9zaXRpb24pLHRoaXMuX3VwZGF0ZUNhbWVyYSh0aGlzLl9sZWZ0Q2FtZXJhKSx0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fcmlnaHRDYW1lcmEpLGEucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKX0sYi5wcm90b3R5cGUuX3VwZGF0ZUNhbWVyYT1mdW5jdGlvbihhKXthLm1pblo9dGhpcy5taW5aLGEubWF4Wj10aGlzLm1heFosYS5yb3RhdGlvbi54PXRoaXMucm90YXRpb24ueCxhLnJvdGF0aW9uLnk9dGhpcy5yb3RhdGlvbi55LGEucm90YXRpb24uej10aGlzLnJvdGF0aW9uLnp9LGIucHJvdG90eXBlLl9vbk9yaWVudGF0aW9uRXZlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5hbHBoYS8xODAqTWF0aC5QSSxjPWEuYmV0YS8xODAqTWF0aC5QSSxkPWEuZ2FtbWEvMTgwKk1hdGguUEk7cmV0dXJuIHRoaXMuX29mZnNldE9yaWVudGF0aW9uPyh0aGlzLnJvdGF0aW9uLnkrPWItdGhpcy5fb2Zmc2V0T3JpZW50YXRpb24ueWF3LHRoaXMucm90YXRpb24ueCs9Yy10aGlzLl9vZmZzZXRPcmllbnRhdGlvbi5waXRjaCx0aGlzLnJvdGF0aW9uLnorPXRoaXMuX29mZnNldE9yaWVudGF0aW9uLnJvbGwtZCx0aGlzLl9vZmZzZXRPcmllbnRhdGlvbi55YXc9Yix0aGlzLl9vZmZzZXRPcmllbnRhdGlvbi5waXRjaD1jLHRoaXMuX29mZnNldE9yaWVudGF0aW9uLnJvbGw9ZCx2b2lkIDApOnZvaWQodGhpcy5fb2Zmc2V0T3JpZW50YXRpb249e3lhdzpiLHBpdGNoOmMscm9sbDpkfSl9LGIucHJvdG90eXBlLmF0dGFjaENvbnRyb2w9ZnVuY3Rpb24oYixjKXthLnByb3RvdHlwZS5hdHRhY2hDb250cm9sLmNhbGwodGhpcyxiLGMpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLl9kZXZpY2VPcmllbnRhdGlvbkhhbmRsZXIpfSxiLnByb3RvdHlwZS5kZXRhY2hDb250cm9sPWZ1bmN0aW9uKGIpe2EucHJvdG90eXBlLmRldGFjaENvbnRyb2wuY2FsbCh0aGlzLGIpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIix0aGlzLl9kZXZpY2VPcmllbnRhdGlvbkhhbmRsZXIpfSxifShhLkZyZWVDYW1lcmEpO2EuT2N1bHVzQ2FtZXJhPWR9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlKXtiLmNhbGwodGhpcyxjLGQsZSksdGhpcy5fbGVmdGpveXN0aWNrPW5ldyBhLlZpcnR1YWxKb3lzdGljayghMCksdGhpcy5fbGVmdGpveXN0aWNrLnNldEF4aXNGb3JVcERvd24oMiksdGhpcy5fbGVmdGpveXN0aWNrLnNldEF4aXNGb3JMZWZ0UmlnaHQoMCksdGhpcy5fbGVmdGpveXN0aWNrLnNldEpveXN0aWNrU2Vuc2liaWxpdHkoLjE1KSx0aGlzLl9yaWdodGpveXN0aWNrPW5ldyBhLlZpcnR1YWxKb3lzdGljayghMSksdGhpcy5fcmlnaHRqb3lzdGljay5zZXRBeGlzRm9yVXBEb3duKDApLHRoaXMuX3JpZ2h0am95c3RpY2suc2V0QXhpc0ZvckxlZnRSaWdodCgxKSx0aGlzLl9yaWdodGpveXN0aWNrLnJldmVyc2VVcERvd249ITAsdGhpcy5fcmlnaHRqb3lzdGljay5zZXRKb3lzdGlja1NlbnNpYmlsaXR5KC4wNSksdGhpcy5fcmlnaHRqb3lzdGljay5zZXRKb3lzdGlja0NvbG9yKFwieWVsbG93XCIpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fY2hlY2tJbnB1dHM9ZnVuY3Rpb24oKXt2YXIgYj1hLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbCh0aGlzLnJvdGF0aW9uLnksdGhpcy5yb3RhdGlvbi54LDApLGM9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHRoaXMuX2xlZnRqb3lzdGljay5kZWx0YVBvc2l0aW9uLGIpO3RoaXMuY2FtZXJhRGlyZWN0aW9uPXRoaXMuY2FtZXJhRGlyZWN0aW9uLmFkZChjKSx0aGlzLmNhbWVyYVJvdGF0aW9uPXRoaXMuY2FtZXJhUm90YXRpb24uYWRkKHRoaXMuX3JpZ2h0am95c3RpY2suZGVsdGFQb3NpdGlvbiksdGhpcy5fbGVmdGpveXN0aWNrLnByZXNzZWR8fCh0aGlzLl9sZWZ0am95c3RpY2suZGVsdGFQb3NpdGlvbj10aGlzLl9sZWZ0am95c3RpY2suZGVsdGFQb3NpdGlvbi5zY2FsZSguOSkpLHRoaXMuX3JpZ2h0am95c3RpY2sucHJlc3NlZHx8KHRoaXMuX3JpZ2h0am95c3RpY2suZGVsdGFQb3NpdGlvbj10aGlzLl9yaWdodGpveXN0aWNrLmRlbHRhUG9zaXRpb24uc2NhbGUoLjkpKX0sYy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuX2xlZnRqb3lzdGljay5yZWxlYXNlQ2FudmFzKCl9LGN9KGEuRnJlZUNhbWVyYSk7YS5WaXJ0dWFsSm95c3RpY2tzQ2FtZXJhPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlLGYpe2IuY2FsbCh0aGlzLGMsZCksdGhpcy5fdGV4dHVyZXM9bmV3IEFycmF5LHRoaXMuX2Zsb2F0cz1uZXcgQXJyYXksdGhpcy5fZmxvYXRzQXJyYXlzPXt9LHRoaXMuX2NvbG9yczM9bmV3IEFycmF5LHRoaXMuX2NvbG9yczQ9bmV3IEFycmF5LHRoaXMuX3ZlY3RvcnMyPW5ldyBBcnJheSx0aGlzLl92ZWN0b3JzMz1uZXcgQXJyYXksdGhpcy5fbWF0cmljZXM9bmV3IEFycmF5LHRoaXMuX2NhY2hlZFdvcmxkVmlld01hdHJpeD1uZXcgYS5NYXRyaXgsdGhpcy5fc2hhZGVyUGF0aD1lLGYubmVlZEFscGhhQmxlbmRpbmc9Zi5uZWVkQWxwaGFCbGVuZGluZ3x8ITEsZi5uZWVkQWxwaGFUZXN0aW5nPWYubmVlZEFscGhhVGVzdGluZ3x8ITEsZi5hdHRyaWJ1dGVzPWYuYXR0cmlidXRlc3x8W1wicG9zaXRpb25cIixcIm5vcm1hbFwiLFwidXZcIl0sZi51bmlmb3Jtcz1mLnVuaWZvcm1zfHxbXCJ3b3JsZFZpZXdQcm9qZWN0aW9uXCJdLGYuc2FtcGxlcnM9Zi5zYW1wbGVyc3x8W10sdGhpcy5fb3B0aW9ucz1mfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5uZWVkQWxwaGFCbGVuZGluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcHRpb25zLm5lZWRBbHBoYUJsZW5kaW5nfSxjLnByb3RvdHlwZS5uZWVkQWxwaGFUZXN0aW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29wdGlvbnMubmVlZEFscGhhVGVzdGluZ30sYy5wcm90b3R5cGUuX2NoZWNrVW5pZm9ybT1mdW5jdGlvbihhKXstMT09PXRoaXMuX29wdGlvbnMudW5pZm9ybXMuaW5kZXhPZihhKSYmdGhpcy5fb3B0aW9ucy51bmlmb3Jtcy5wdXNoKGEpfSxjLnByb3RvdHlwZS5zZXRUZXh0dXJlPWZ1bmN0aW9uKGEsYil7cmV0dXJuLTE9PT10aGlzLl9vcHRpb25zLnNhbXBsZXJzLmluZGV4T2YoYSkmJnRoaXMuX29wdGlvbnMuc2FtcGxlcnMucHVzaChhKSx0aGlzLl90ZXh0dXJlc1thXT1iLHRoaXN9LGMucHJvdG90eXBlLnNldEZsb2F0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2NoZWNrVW5pZm9ybShhKSx0aGlzLl9mbG9hdHNbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRGbG9hdHM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX2Zsb2F0c0FycmF5c1thXT1iLHRoaXN9LGMucHJvdG90eXBlLnNldENvbG9yMz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9jaGVja1VuaWZvcm0oYSksdGhpcy5fY29sb3JzM1thXT1iLHRoaXN9LGMucHJvdG90eXBlLnNldENvbG9yND1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9jaGVja1VuaWZvcm0oYSksdGhpcy5fY29sb3JzNFthXT1iLHRoaXN9LGMucHJvdG90eXBlLnNldFZlY3RvcjI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX3ZlY3RvcnMyW2FdPWIsdGhpc30sYy5wcm90b3R5cGUuc2V0VmVjdG9yMz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9jaGVja1VuaWZvcm0oYSksdGhpcy5fdmVjdG9yczNbYV09Yix0aGlzfSxjLnByb3RvdHlwZS5zZXRNYXRyaXg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fY2hlY2tVbmlmb3JtKGEpLHRoaXMuX21hdHJpY2VzW2FdPWIsdGhpc30sYy5wcm90b3R5cGUuaXNSZWFkeT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKTtyZXR1cm4gdGhpcy5fZWZmZWN0PWEuY3JlYXRlRWZmZWN0KHRoaXMuX3NoYWRlclBhdGgsdGhpcy5fb3B0aW9ucy5hdHRyaWJ1dGVzLHRoaXMuX29wdGlvbnMudW5pZm9ybXMsdGhpcy5fb3B0aW9ucy5zYW1wbGVycyxcIlwiLG51bGwsdGhpcy5vbkNvbXBpbGVkLHRoaXMub25FcnJvciksdGhpcy5fZWZmZWN0LmlzUmVhZHkoKT8hMDohMX0sYy5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihhKXstMSE9PXRoaXMuX29wdGlvbnMudW5pZm9ybXMuaW5kZXhPZihcIndvcmxkXCIpJiZ0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRcIixhKSwtMSE9PXRoaXMuX29wdGlvbnMudW5pZm9ybXMuaW5kZXhPZihcInZpZXdcIikmJnRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJ2aWV3XCIsdGhpcy5nZXRTY2VuZSgpLmdldFZpZXdNYXRyaXgoKSksLTEhPT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoXCJ3b3JsZFZpZXdcIikmJihhLm11bHRpcGx5VG9SZWYodGhpcy5nZXRTY2VuZSgpLmdldFZpZXdNYXRyaXgoKSx0aGlzLl9jYWNoZWRXb3JsZFZpZXdNYXRyaXgpLHRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJ3b3JsZFZpZXdcIix0aGlzLl9jYWNoZWRXb3JsZFZpZXdNYXRyaXgpKSwtMSE9PXRoaXMuX29wdGlvbnMudW5pZm9ybXMuaW5kZXhPZihcInByb2plY3Rpb25cIikmJnRoaXMuX2VmZmVjdC5zZXRNYXRyaXgoXCJwcm9qZWN0aW9uXCIsdGhpcy5nZXRTY2VuZSgpLmdldFByb2plY3Rpb25NYXRyaXgoKSksLTEhPT10aGlzLl9vcHRpb25zLnVuaWZvcm1zLmluZGV4T2YoXCJ3b3JsZFZpZXdQcm9qZWN0aW9uXCIpJiZ0aGlzLl9lZmZlY3Quc2V0TWF0cml4KFwid29ybGRWaWV3UHJvamVjdGlvblwiLGEubXVsdGlwbHkodGhpcy5nZXRTY2VuZSgpLmdldFRyYW5zZm9ybU1hdHJpeCgpKSk7Zm9yKHZhciBiIGluIHRoaXMuX3RleHR1cmVzKXRoaXMuX2VmZmVjdC5zZXRUZXh0dXJlKGIsdGhpcy5fdGV4dHVyZXNbYl0pO2ZvcihiIGluIHRoaXMuX2Zsb2F0cyl0aGlzLl9lZmZlY3Quc2V0RmxvYXQoYix0aGlzLl9mbG9hdHNbYl0pO2ZvcihiIGluIHRoaXMuX2Zsb2F0c0FycmF5cyl0aGlzLl9lZmZlY3Quc2V0QXJyYXkoYix0aGlzLl9mbG9hdHNBcnJheXNbYl0pO2ZvcihiIGluIHRoaXMuX2NvbG9yczMpdGhpcy5fZWZmZWN0LnNldENvbG9yMyhiLHRoaXMuX2NvbG9yczNbYl0pO2ZvcihiIGluIHRoaXMuX2NvbG9yczQpe3ZhciBjPXRoaXMuX2NvbG9yczRbYl07dGhpcy5fZWZmZWN0LnNldEZsb2F0NChiLGMucixjLmcsYy5iLGMuYSl9Zm9yKGIgaW4gdGhpcy5fdmVjdG9yczIpdGhpcy5fZWZmZWN0LnNldFZlY3RvcjIoYix0aGlzLl92ZWN0b3JzMltiXSk7Zm9yKGIgaW4gdGhpcy5fdmVjdG9yczMpdGhpcy5fZWZmZWN0LnNldFZlY3RvcjMoYix0aGlzLl92ZWN0b3JzM1tiXSk7Zm9yKGIgaW4gdGhpcy5fbWF0cmljZXMpdGhpcy5fZWZmZWN0LnNldE1hdHJpeChiLHRoaXMuX21hdHJpY2VzW2JdKX0sYy5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbihhKXtmb3IodmFyIGMgaW4gdGhpcy5fdGV4dHVyZXMpdGhpcy5fdGV4dHVyZXNbY10uZGlzcG9zZSgpO3RoaXMuX3RleHR1cmVzPVtdLGIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLGEpfSxjfShhLk1hdGVyaWFsKTthLlNoYWRlck1hdGVyaWFsPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe31yZXR1cm4gYi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGIsYyl7c3dpdGNoKGMpe2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kOnRoaXMucG9zaXRpb25zPWI7YnJlYWs7Y2FzZSBhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kOnRoaXMubm9ybWFscz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kOnRoaXMudXZzPWI7YnJlYWs7Y2FzZSBhLlZlcnRleEJ1ZmZlci5VVjJLaW5kOnRoaXMudXYycz1iO2JyZWFrO2Nhc2UgYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kOnRoaXMuY29sb3JzPWI7YnJlYWs7Y2FzZSBhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc0luZGljZXNLaW5kOnRoaXMubWF0cmljZXNJbmRpY2VzPWI7YnJlYWs7Y2FzZSBhLlZlcnRleEJ1ZmZlci5NYXRyaWNlc1dlaWdodHNLaW5kOnRoaXMubWF0cmljZXNXZWlnaHRzPWJ9fSxiLnByb3RvdHlwZS5hcHBseVRvTWVzaD1mdW5jdGlvbihhLGIpe3RoaXMuX2FwcGx5VG8oYSxiKX0sYi5wcm90b3R5cGUuYXBwbHlUb0dlb21ldHJ5PWZ1bmN0aW9uKGEsYil7dGhpcy5fYXBwbHlUbyhhLGIpfSxiLnByb3RvdHlwZS51cGRhdGVNZXNoPWZ1bmN0aW9uKGEpe3RoaXMuX3VwZGF0ZShhKX0sYi5wcm90b3R5cGUudXBkYXRlR2VvbWV0cnk9ZnVuY3Rpb24oYSl7dGhpcy5fdXBkYXRlKGEpfSxiLnByb3RvdHlwZS5fYXBwbHlUbz1mdW5jdGlvbihiLGMpe3RoaXMucG9zaXRpb25zJiZiLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsdGhpcy5wb3NpdGlvbnMsYyksdGhpcy5ub3JtYWxzJiZiLnNldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Ob3JtYWxLaW5kLHRoaXMubm9ybWFscyxjKSx0aGlzLnV2cyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVZLaW5kLHRoaXMudXZzLGMpLHRoaXMudXYycyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCx0aGlzLnV2MnMsYyksdGhpcy5jb2xvcnMmJmIuc2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCx0aGlzLmNvbG9ycyxjKSx0aGlzLm1hdHJpY2VzSW5kaWNlcyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCx0aGlzLm1hdHJpY2VzSW5kaWNlcyxjKSx0aGlzLm1hdHJpY2VzV2VpZ2h0cyYmYi5zZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCx0aGlzLm1hdHJpY2VzV2VpZ2h0cyxjKSx0aGlzLmluZGljZXMmJmIuc2V0SW5kaWNlcyh0aGlzLmluZGljZXMpXG59LGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oYixjLGQpe3RoaXMucG9zaXRpb25zJiZiLnVwZGF0ZVZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsdGhpcy5wb3NpdGlvbnMsYyxkKSx0aGlzLm5vcm1hbHMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk5vcm1hbEtpbmQsdGhpcy5ub3JtYWxzLGMsZCksdGhpcy51dnMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlVWS2luZCx0aGlzLnV2cyxjLGQpLHRoaXMudXYycyYmYi51cGRhdGVWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuVVYyS2luZCx0aGlzLnV2MnMsYyxkKSx0aGlzLmNvbG9ycyYmYi51cGRhdGVWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kLHRoaXMuY29sb3JzLGMsZCksdGhpcy5tYXRyaWNlc0luZGljZXMmJmIudXBkYXRlVmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQsdGhpcy5tYXRyaWNlc0luZGljZXMsYyxkKSx0aGlzLm1hdHJpY2VzV2VpZ2h0cyYmYi51cGRhdGVWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCx0aGlzLm1hdHJpY2VzV2VpZ2h0cyxjLGQpLHRoaXMuaW5kaWNlcyYmYi5zZXRJbmRpY2VzKHRoaXMuaW5kaWNlcyl9LGIucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbihiKXt2YXIgYz1hLlZlY3RvcjMuWmVybygpO2lmKHRoaXMucG9zaXRpb25zKWZvcih2YXIgZD1hLlZlY3RvcjMuWmVybygpLGU9MDtlPHRoaXMucG9zaXRpb25zLmxlbmd0aDtlKz0zKWEuVmVjdG9yMy5Gcm9tQXJyYXlUb1JlZih0aGlzLnBvc2l0aW9ucyxlLGQpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKGQsYixjKSx0aGlzLnBvc2l0aW9uc1tlXT1jLngsdGhpcy5wb3NpdGlvbnNbZSsxXT1jLnksdGhpcy5wb3NpdGlvbnNbZSsyXT1jLno7aWYodGhpcy5ub3JtYWxzKXt2YXIgZj1hLlZlY3RvcjMuWmVybygpO2ZvcihlPTA7ZTx0aGlzLm5vcm1hbHMubGVuZ3RoO2UrPTMpYS5WZWN0b3IzLkZyb21BcnJheVRvUmVmKHRoaXMubm9ybWFscyxlLGYpLGEuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxUb1JlZihmLGIsYyksdGhpcy5ub3JtYWxzW2VdPWMueCx0aGlzLm5vcm1hbHNbZSsxXT1jLnksdGhpcy5ub3JtYWxzW2UrMl09Yy56fX0sYi5wcm90b3R5cGUubWVyZ2U9ZnVuY3Rpb24oYSl7aWYoYS5pbmRpY2VzKXt0aGlzLmluZGljZXN8fCh0aGlzLmluZGljZXM9W10pO2Zvcih2YXIgYj10aGlzLnBvc2l0aW9ucz90aGlzLnBvc2l0aW9ucy5sZW5ndGgvMzowLGM9MDtjPGEuaW5kaWNlcy5sZW5ndGg7YysrKXRoaXMuaW5kaWNlcy5wdXNoKGEuaW5kaWNlc1tjXStiKX1pZihhLnBvc2l0aW9ucylmb3IodGhpcy5wb3NpdGlvbnN8fCh0aGlzLnBvc2l0aW9ucz1bXSksYz0wO2M8YS5wb3NpdGlvbnMubGVuZ3RoO2MrKyl0aGlzLnBvc2l0aW9ucy5wdXNoKGEucG9zaXRpb25zW2NdKTtpZihhLm5vcm1hbHMpZm9yKHRoaXMubm9ybWFsc3x8KHRoaXMubm9ybWFscz1bXSksYz0wO2M8YS5ub3JtYWxzLmxlbmd0aDtjKyspdGhpcy5ub3JtYWxzLnB1c2goYS5ub3JtYWxzW2NdKTtpZihhLnV2cylmb3IodGhpcy51dnN8fCh0aGlzLnV2cz1bXSksYz0wO2M8YS51dnMubGVuZ3RoO2MrKyl0aGlzLnV2cy5wdXNoKGEudXZzW2NdKTtpZihhLnV2MnMpZm9yKHRoaXMudXYyc3x8KHRoaXMudXYycz1bXSksYz0wO2M8YS51djJzLmxlbmd0aDtjKyspdGhpcy51djJzLnB1c2goYS51djJzW2NdKTtpZihhLm1hdHJpY2VzSW5kaWNlcylmb3IodGhpcy5tYXRyaWNlc0luZGljZXN8fCh0aGlzLm1hdHJpY2VzSW5kaWNlcz1bXSksYz0wO2M8YS5tYXRyaWNlc0luZGljZXMubGVuZ3RoO2MrKyl0aGlzLm1hdHJpY2VzSW5kaWNlcy5wdXNoKGEubWF0cmljZXNJbmRpY2VzW2NdKTtpZihhLm1hdHJpY2VzV2VpZ2h0cylmb3IodGhpcy5tYXRyaWNlc1dlaWdodHN8fCh0aGlzLm1hdHJpY2VzV2VpZ2h0cz1bXSksYz0wO2M8YS5tYXRyaWNlc1dlaWdodHMubGVuZ3RoO2MrKyl0aGlzLm1hdHJpY2VzV2VpZ2h0cy5wdXNoKGEubWF0cmljZXNXZWlnaHRzW2NdKTtpZihhLmNvbG9ycylmb3IodGhpcy5jb2xvcnN8fCh0aGlzLmNvbG9ycz1bXSksYz0wO2M8YS5jb2xvcnMubGVuZ3RoO2MrKyl0aGlzLmNvbG9ycy5wdXNoKGEuY29sb3JzW2NdKX0sYi5FeHRyYWN0RnJvbU1lc2g9ZnVuY3Rpb24oYSl7cmV0dXJuIGIuX0V4dHJhY3RGcm9tKGEpfSxiLkV4dHJhY3RGcm9tR2VvbWV0cnk9ZnVuY3Rpb24oYSl7cmV0dXJuIGIuX0V4dHJhY3RGcm9tKGEpfSxiLl9FeHRyYWN0RnJvbT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiBiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpJiYoYy5wb3NpdGlvbnM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCkmJihjLm5vcm1hbHM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTm9ybWFsS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLlVWS2luZCkmJihjLnV2cz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVktpbmQpKSxiLmlzVmVydGljZXNEYXRhUHJlc2VudChhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSYmKGMudXYycz1iLmdldFZlcnRpY2VzRGF0YShhLlZlcnRleEJ1ZmZlci5VVjJLaW5kKSksYi5pc1ZlcnRpY2VzRGF0YVByZXNlbnQoYS5WZXJ0ZXhCdWZmZXIuQ29sb3JLaW5kKSYmKGMuY29sb3JzPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLkNvbG9yS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzSW5kaWNlc0tpbmQpJiYoYy5tYXRyaWNlc0luZGljZXM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNJbmRpY2VzS2luZCkpLGIuaXNWZXJ0aWNlc0RhdGFQcmVzZW50KGEuVmVydGV4QnVmZmVyLk1hdHJpY2VzV2VpZ2h0c0tpbmQpJiYoYy5tYXRyaWNlc1dlaWdodHM9Yi5nZXRWZXJ0aWNlc0RhdGEoYS5WZXJ0ZXhCdWZmZXIuTWF0cmljZXNXZWlnaHRzS2luZCkpLGMuaW5kaWNlcz1iLmdldEluZGljZXMoKSxjfSxiLkNyZWF0ZUJveD1mdW5jdGlvbihiKXt2YXIgYz1bbmV3IGEuVmVjdG9yMygwLDAsMSksbmV3IGEuVmVjdG9yMygwLDAsLTEpLG5ldyBhLlZlY3RvcjMoMSwwLDApLG5ldyBhLlZlY3RvcjMoLTEsMCwwKSxuZXcgYS5WZWN0b3IzKDAsMSwwKSxuZXcgYS5WZWN0b3IzKDAsLTEsMCldLGQ9W10sZT1bXSxmPVtdLGc9W107Yj1ifHwxO2Zvcih2YXIgaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgaT1jW2hdLGo9bmV3IGEuVmVjdG9yMyhpLnksaS56LGkueCksaz1hLlZlY3RvcjMuQ3Jvc3MoaSxqKSxsPWUubGVuZ3RoLzM7ZC5wdXNoKGwpLGQucHVzaChsKzEpLGQucHVzaChsKzIpLGQucHVzaChsKSxkLnB1c2gobCsyKSxkLnB1c2gobCszKTt2YXIgbT1pLnN1YnRyYWN0KGopLnN1YnRyYWN0KGspLnNjYWxlKGIvMik7ZS5wdXNoKG0ueCxtLnksbS56KSxmLnB1c2goaS54LGkueSxpLnopLGcucHVzaCgxLDEpLG09aS5zdWJ0cmFjdChqKS5hZGQoaykuc2NhbGUoYi8yKSxlLnB1c2gobS54LG0ueSxtLnopLGYucHVzaChpLngsaS55LGkueiksZy5wdXNoKDAsMSksbT1pLmFkZChqKS5hZGQoaykuc2NhbGUoYi8yKSxlLnB1c2gobS54LG0ueSxtLnopLGYucHVzaChpLngsaS55LGkueiksZy5wdXNoKDAsMCksbT1pLmFkZChqKS5zdWJ0cmFjdChrKS5zY2FsZShiLzIpLGUucHVzaChtLngsbS55LG0ueiksZi5wdXNoKGkueCxpLnksaS56KSxnLnB1c2goMSwwKX12YXIgbj1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiBuLmluZGljZXM9ZCxuLnBvc2l0aW9ucz1lLG4ubm9ybWFscz1mLG4udXZzPWcsbn0sYi5DcmVhdGVTcGhlcmU9ZnVuY3Rpb24oYixjKXtiPWJ8fDMyLGM9Y3x8MTtmb3IodmFyIGQ9Yy8yLGU9MitiLGY9MiplLGc9W10saD1bXSxpPVtdLGo9W10saz0wO2U+PWs7aysrKXtmb3IodmFyIGw9ay9lLG09bCpNYXRoLlBJLG49MDtmPj1uO24rKyl7dmFyIG89bi9mLHA9bypNYXRoLlBJKjIscT1hLk1hdHJpeC5Sb3RhdGlvblooLW0pLHI9YS5NYXRyaXguUm90YXRpb25ZKHApLHM9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKGEuVmVjdG9yMy5VcCgpLHEpLHQ9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKHMsciksdT10LnNjYWxlKGQpLHY9YS5WZWN0b3IzLk5vcm1hbGl6ZSh1KTtoLnB1c2godS54LHUueSx1LnopLGkucHVzaCh2Lngsdi55LHYueiksai5wdXNoKGwsbyl9aWYoaz4wKWZvcih2YXIgdz1oLmxlbmd0aC8zLHg9dy0yKihmKzEpO3c+eCtmKzI7eCsrKWcucHVzaCh4KSxnLnB1c2goeCsxKSxnLnB1c2goeCtmKzEpLGcucHVzaCh4K2YrMSksZy5wdXNoKHgrMSksZy5wdXNoKHgrZisyKX12YXIgeT1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiB5LmluZGljZXM9Zyx5LnBvc2l0aW9ucz1oLHkubm9ybWFscz1pLHkudXZzPWoseX0sYi5DcmVhdGVDeWxpbmRlcj1mdW5jdGlvbihiLGMsZCxlLGYpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBmJiYoZj0xKTt2YXIgZz1jLzIsaD1kLzIsaT1bXSxqPVtdLGs9W10sbD1bXTtiPWJ8fDEsYz1jfHwuNSxkPWR8fDEsZT1lfHwxNixmPWZ8fDEsZj0xPmY/MTpmO2Zvcih2YXIgbT1mdW5jdGlvbihiKXt2YXIgYz0yKmIqTWF0aC5QSS9lLGQ9TWF0aC5jb3MoYyksZj1NYXRoLnNpbihjKTtyZXR1cm4gbmV3IGEuVmVjdG9yMyhkLDAsZil9LG49ZnVuY3Rpb24oYyl7dmFyIGQ9Yz9nOmg7aWYoMCE9ZCl7dmFyIGY9ai5sZW5ndGgvMyxrPW5ldyBhLlZlY3RvcjMoMCxiLzIsMCksbj1uZXcgYS5WZWN0b3IyKC41LC41KTtmb3IoY3x8KGsuc2NhbGVJblBsYWNlKC0xKSxuLng9LW4ueCkscj0wO2U+cjtyKyspe3ZhciBvPW0ocikscD1vLnNjYWxlKGQpLmFkZChrKSxxPW5ldyBhLlZlY3RvcjIoby54Km4ueCsuNSxvLnoqbi55Ky41KTtqLnB1c2gocC54LHAueSxwLnopLGwucHVzaChxLngscS55KX1mb3IodmFyIHI9MDtlLTI+cjtyKyspYz8oaS5wdXNoKGYpLGkucHVzaChmKyhyKzEpJWUpLGkucHVzaChmKyhyKzIpJWUpKTooaS5wdXNoKGYpLGkucHVzaChmKyhyKzIpJWUpLGkucHVzaChmKyhyKzEpJWUpKX19LG89bmV3IGEuVmVjdG9yMygwLC0xLDApLnNjYWxlKGIvMikscD1uZXcgYS5WZWN0b3IzKDAsMSwwKS5zY2FsZShiL2YpLHE9ZSsxLHI9MDtlPj1yO3IrKylmb3IodmFyIHMsdD1tKHIpLHU9bmV3IGEuVmVjdG9yMihyL2UsMCksdj1oLHc9MDtmPj13O3crKylzPXQuc2NhbGUodikscy5hZGRJblBsYWNlKG8uYWRkKHAuc2NhbGUodykpKSx1LnkrPTEvZix2Kz0oZy1oKS9mLGoucHVzaChzLngscy55LHMueiksbC5wdXNoKHUueCx1LnkpO2YrPTE7Zm9yKHZhciB3PTA7Zi0xPnc7dysrKWZvcih2YXIgcj0wO2U+PXI7cisrKWkucHVzaChyKmYrdyksaS5wdXNoKChyKmYrKHcrZikpJShxKmYpKSxpLnB1c2gocipmKyh3KzEpKSxpLnB1c2gocipmKyh3KzEpKSxpLnB1c2goKHIqZisodytmKSklKHEqZikpLGkucHVzaCgocipmKyh3K2YrMSkpJShxKmYpKTtuKCEwKSxuKCExKSxhLlZlcnRleERhdGEuQ29tcHV0ZU5vcm1hbHMoaixpLGspO3ZhciB4PW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIHguaW5kaWNlcz1pLHgucG9zaXRpb25zPWoseC5ub3JtYWxzPWsseC51dnM9bCx4fSxiLkNyZWF0ZVRvcnVzPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1bXSxmPVtdLGc9W10saD1bXTtiPWJ8fDEsYz1jfHwuNSxkPWR8fDE2O2Zvcih2YXIgaT1kKzEsaj0wO2Q+PWo7aisrKWZvcih2YXIgaz1qL2QsbD1qKk1hdGguUEkqMi9kLU1hdGguUEkvMixtPWEuTWF0cml4LlRyYW5zbGF0aW9uKGIvMiwwLDApLm11bHRpcGx5KGEuTWF0cml4LlJvdGF0aW9uWShsKSksbj0wO2Q+PW47bisrKXt2YXIgbz0xLW4vZCxwPW4qTWF0aC5QSSoyL2QrTWF0aC5QSSxxPU1hdGguY29zKHApLHI9TWF0aC5zaW4ocCkscz1uZXcgYS5WZWN0b3IzKHEsciwwKSx0PXMuc2NhbGUoYy8yKSx1PW5ldyBhLlZlY3RvcjIoayxvKTt0PWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0LG0pLHM9YS5WZWN0b3IzLlRyYW5zZm9ybU5vcm1hbChzLG0pLGYucHVzaCh0LngsdC55LHQueiksZy5wdXNoKHMueCxzLnkscy56KSxoLnB1c2godS54LHUueSk7dmFyIHY9KGorMSklaSx3PShuKzEpJWk7ZS5wdXNoKGoqaStuKSxlLnB1c2goaippK3cpLGUucHVzaCh2KmkrbiksZS5wdXNoKGoqaSt3KSxlLnB1c2godippK3cpLGUucHVzaCh2Kmkrbil9dmFyIHg9bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4geC5pbmRpY2VzPWUseC5wb3NpdGlvbnM9Zix4Lm5vcm1hbHM9Zyx4LnV2cz1oLHh9LGIuQ3JlYXRlTGluZXM9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPVtdLGQ9W10sZT0wO2U8Yi5sZW5ndGg7ZSsrKWQucHVzaChiW2VdLngsYltlXS55LGJbZV0ueiksZT4wJiYoYy5wdXNoKGUtMSksYy5wdXNoKGUpKTt2YXIgZj1uZXcgYS5WZXJ0ZXhEYXRhO3JldHVybiBmLmluZGljZXM9YyxmLnBvc2l0aW9ucz1kLGZ9LGIuQ3JlYXRlR3JvdW5kPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmLGc9W10saD1bXSxpPVtdLGo9W107Zm9yKGI9Ynx8MSxjPWN8fDEsZD1kfHwxLGU9MDtkPj1lO2UrKylmb3IoZj0wO2Q+PWY7ZisrKXt2YXIgaz1uZXcgYS5WZWN0b3IzKGYqYi9kLWIvMiwwLChkLWUpKmMvZC1jLzIpLGw9bmV3IGEuVmVjdG9yMygwLDEsMCk7aC5wdXNoKGsueCxrLnksay56KSxpLnB1c2gobC54LGwueSxsLnopLGoucHVzaChmL2QsMS1lL2QpfWZvcihlPTA7ZD5lO2UrKylmb3IoZj0wO2Q+ZjtmKyspZy5wdXNoKGYrMSsoZSsxKSooZCsxKSksZy5wdXNoKGYrMStlKihkKzEpKSxnLnB1c2goZitlKihkKzEpKSxnLnB1c2goZisoZSsxKSooZCsxKSksZy5wdXNoKGYrMSsoZSsxKSooZCsxKSksZy5wdXNoKGYrZSooZCsxKSk7dmFyIG09bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4gbS5pbmRpY2VzPWcsbS5wb3NpdGlvbnM9aCxtLm5vcm1hbHM9aSxtLnV2cz1qLG19LGIuQ3JlYXRlVGlsZWRHcm91bmQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe2Z1bmN0aW9uIGgoYixjLGQsZSl7dmFyIGY9bi5sZW5ndGgvMyxoPWcudysxO2ZvcihpPTA7aTxnLmg7aSsrKWZvcihqPTA7ajxnLnc7aisrKXt2YXIgaz1bZitqK2kqaCxmKyhqKzEpK2kqaCxmKyhqKzEpKyhpKzEpKmgsZitqKyhpKzEpKmhdO20ucHVzaChrWzFdKSxtLnB1c2goa1syXSksbS5wdXNoKGtbM10pLG0ucHVzaChrWzBdKSxtLnB1c2goa1sxXSksbS5wdXNoKGtbM10pfXZhciBsPWEuVmVjdG9yMy5aZXJvKCkscT1uZXcgYS5WZWN0b3IzKDAsMSwwKTtmb3IoaT0wO2k8PWcuaDtpKyspZm9yKGwuej1pKihlLWMpL2cuaCtjLGo9MDtqPD1nLnc7aisrKWwueD1qKihkLWIpL2cudytiLGwueT0wLG4ucHVzaChsLngsbC55LGwueiksby5wdXNoKHEueCxxLnkscS56KSxwLnB1c2goai9nLncsaS9nLmgpfVwidW5kZWZpbmVkXCI9PXR5cGVvZiBmJiYoZj17dzoxLGg6MX0pLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnJiYoZz17dzoxLGg6MX0pO3ZhciBpLGosayxsLG09W10sbj1bXSxvPVtdLHA9W107Zi5oPWYudzwxPzE6Zi5oLGYudz1mLnc8MT8xOmYudyxnLnc9Zy53PDE/MTpnLncsZy5oPWcuaDwxPzE6Zy5oO3ZhciBxPXt3OihkLWIpL2YudyxoOihlLWMpL2YuaH07Zm9yKGs9MDtrPGYuaDtrKyspZm9yKGw9MDtsPGYudztsKyspaChiK2wqcS53LGMraypxLmgsYisobCsxKSpxLncsYysoaysxKSpxLmgpO3ZhciByPW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIHIuaW5kaWNlcz1tLHIucG9zaXRpb25zPW4sci5ub3JtYWxzPW8sci51dnM9cCxyfSxiLkNyZWF0ZUdyb3VuZEZyb21IZWlnaHRNYXA9ZnVuY3Rpb24oYixjLGQsZSxmLGcsaCxpKXt2YXIgaixrLGw9W10sbT1bXSxuPVtdLG89W107Zm9yKGo9MDtkPj1qO2orKylmb3Ioaz0wO2Q+PWs7aysrKXt2YXIgcD1uZXcgYS5WZWN0b3IzKGsqYi9kLWIvMiwwLChkLWopKmMvZC1jLzIpLHE9KHAueCtiLzIpL2IqKGgtMSl8MCxyPSgxLShwLnorYy8yKS9jKSooaS0xKXwwLHM9NCoocStyKmgpLHQ9Z1tzXS8yNTUsdT1nW3MrMV0vMjU1LHY9Z1tzKzJdLzI1NSx3PS4zKnQrLjU5KnUrLjExKnY7cC55PWUrKGYtZSkqdyxtLnB1c2gocC54LHAueSxwLnopLG4ucHVzaCgwLDAsMCksby5wdXNoKGsvZCwxLWovZCl9Zm9yKGo9MDtkPmo7aisrKWZvcihrPTA7ZD5rO2srKylsLnB1c2goaysxKyhqKzEpKihkKzEpKSxsLnB1c2goaysxK2oqKGQrMSkpLGwucHVzaChrK2oqKGQrMSkpLGwucHVzaChrKyhqKzEpKihkKzEpKSxsLnB1c2goaysxKyhqKzEpKihkKzEpKSxsLnB1c2goaytqKihkKzEpKTthLlZlcnRleERhdGEuQ29tcHV0ZU5vcm1hbHMobSxsLG4pO3ZhciB4PW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIHguaW5kaWNlcz1sLHgucG9zaXRpb25zPW0seC5ub3JtYWxzPW4seC51dnM9byx4fSxiLkNyZWF0ZVBsYW5lPWZ1bmN0aW9uKGIpe3ZhciBjPVtdLGQ9W10sZT1bXSxmPVtdO2I9Ynx8MTt2YXIgZz1iLzI7ZC5wdXNoKC1nLC1nLDApLGUucHVzaCgwLDAsLTEpLGYucHVzaCgwLDApLGQucHVzaChnLC1nLDApLGUucHVzaCgwLDAsLTEpLGYucHVzaCgxLDApLGQucHVzaChnLGcsMCksZS5wdXNoKDAsMCwtMSksZi5wdXNoKDEsMSksZC5wdXNoKC1nLGcsMCksZS5wdXNoKDAsMCwtMSksZi5wdXNoKDAsMSksYy5wdXNoKDApLGMucHVzaCgxKSxjLnB1c2goMiksYy5wdXNoKDApLGMucHVzaCgyKSxjLnB1c2goMyk7dmFyIGg9bmV3IGEuVmVydGV4RGF0YTtyZXR1cm4gaC5pbmRpY2VzPWMsaC5wb3NpdGlvbnM9ZCxoLm5vcm1hbHM9ZSxoLnV2cz1mLGh9LGIuQ3JlYXRlVG9ydXNLbm90PWZ1bmN0aW9uKGIsYyxkLGUsZixnKXt2YXIgaD1bXSxpPVtdLGo9W10saz1bXTtiPWJ8fDIsYz1jfHwuNSxkPWR8fDMyLGU9ZXx8MzIsZj1mfHwyLGc9Z3x8Mztmb3IodmFyIGw9ZnVuY3Rpb24oYyl7dmFyIGQ9TWF0aC5jb3MoYyksZT1NYXRoLnNpbihjKSxoPWcvZipjLGk9TWF0aC5jb3MoaCksaj1iKigyK2kpKi41KmQsaz1iKigyK2kpKmUqLjUsbD1iKk1hdGguc2luKGgpKi41O3JldHVybiBuZXcgYS5WZWN0b3IzKGosayxsKX0sbT0wO2Q+PW07bSsrKXt2YXIgbj1tJWQsbz1uL2QqMipmKk1hdGguUEkscD1sKG8pLHE9bChvKy4wMSkscj1xLnN1YnRyYWN0KHApLHM9cS5hZGQocCksdD1hLlZlY3RvcjMuQ3Jvc3MocixzKTtzPWEuVmVjdG9yMy5Dcm9zcyh0LHIpLHQubm9ybWFsaXplKCkscy5ub3JtYWxpemUoKTtmb3IodmFyIHU9MDtlPnU7dSsrKXt2YXIgdj11JWUsdz12L2UqMipNYXRoLlBJLHg9LWMqTWF0aC5jb3ModykseT1jKk1hdGguc2luKHcpO2kucHVzaChwLngreCpzLngreSp0LngpLGkucHVzaChwLnkreCpzLnkreSp0LnkpLGkucHVzaChwLnoreCpzLnoreSp0LnopLGsucHVzaChtL2QpLGsucHVzaCh1L2UpfX1mb3IobT0wO2Q+bTttKyspZm9yKHU9MDtlPnU7dSsrKXt2YXIgej0odSsxKSVlLEE9bSplK3UsQj0obSsxKSplK3UsQz0obSsxKSplK3osRD1tKmUrejtoLnB1c2goRCksaC5wdXNoKEIpLGgucHVzaChBKSxoLnB1c2goRCksaC5wdXNoKEMpLGgucHVzaChCKX1hLlZlcnRleERhdGEuQ29tcHV0ZU5vcm1hbHMoaSxoLGopO3ZhciBFPW5ldyBhLlZlcnRleERhdGE7cmV0dXJuIEUuaW5kaWNlcz1oLEUucG9zaXRpb25zPWksRS5ub3JtYWxzPWosRS51dnM9ayxFfSxiLkNvbXB1dGVOb3JtYWxzPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmPVtdLGc9W107Zm9yKGU9MDtlPGIubGVuZ3RoO2UrPTMpe3ZhciBoPW5ldyBhLlZlY3RvcjMoYltlXSxiW2UrMV0sYltlKzJdKTtmLnB1c2goaCksZy5wdXNoKFtdKX12YXIgaT1bXTtmb3IoZT0wO2U8Yy5sZW5ndGgvMztlKyspe3ZhciBqPWNbMyplXSxrPWNbMyplKzFdLGw9Y1szKmUrMl0sbT1mW2pdLG49ZltrXSxvPWZbbF0scD1tLnN1YnRyYWN0KG4pLHE9by5zdWJ0cmFjdChuKTtpW2VdPWEuVmVjdG9yMy5Ob3JtYWxpemUoYS5WZWN0b3IzLkNyb3NzKHAscSkpLGdbal0ucHVzaChlKSxnW2tdLnB1c2goZSksZ1tsXS5wdXNoKGUpfWZvcihlPTA7ZTxmLmxlbmd0aDtlKyspe2Zvcih2YXIgcj1nW2VdLHM9YS5WZWN0b3IzLlplcm8oKSx0PTA7dDxyLmxlbmd0aDt0Kyspcy5hZGRJblBsYWNlKGlbclt0XV0pO3M9YS5WZWN0b3IzLk5vcm1hbGl6ZShzLnNjYWxlKDEvci5sZW5ndGgpKSxkWzMqZV09cy54LGRbMyplKzFdPXMueSxkWzMqZSsyXT1zLnp9fSxifSgpO2EuVmVydGV4RGF0YT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYixjKXtiLl9sZWZ0Q2FtZXJhLmlzSW50ZXJtZWRpYXRlPSEwLGIuc3ViQ2FtZXJhcy5wdXNoKGIuX2xlZnRDYW1lcmEpLGIuc3ViQ2FtZXJhcy5wdXNoKGIuX3JpZ2h0Q2FtZXJhKSxiLl9sZWZ0VGV4dHVyZT1uZXcgYS5QYXNzUG9zdFByb2Nlc3MoYytcIl9sZWZ0VGV4dHVyZVwiLDEsYi5fbGVmdENhbWVyYSksYi5fYW5hZ2x5cGhQb3N0UHJvY2Vzcz1uZXcgYS5BbmFnbHlwaFBvc3RQcm9jZXNzKGMrXCJfYW5hZ2x5cGhcIiwxLGIuX3JpZ2h0Q2FtZXJhKSxiLl9hbmFnbHlwaFBvc3RQcm9jZXNzLm9uQXBwbHk9ZnVuY3Rpb24oYSl7YS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzKFwibGVmdFNhbXBsZXJcIixiLl9sZWZ0VGV4dHVyZSl9LGIuX3VwZGF0ZSgpfSxjPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoZCxlLGYsZyxoLGksail7Yy5jYWxsKHRoaXMsZCxlLGYsZyxoLGopLHRoaXMuX2V5ZVNwYWNlPWEuVG9vbHMuVG9SYWRpYW5zKGkpLHRoaXMuX2xlZnRDYW1lcmE9bmV3IGEuQXJjUm90YXRlQ2FtZXJhKGQrXCJfbGVmdFwiLGUtdGhpcy5fZXllU3BhY2UsZixnLGgsaiksdGhpcy5fcmlnaHRDYW1lcmE9bmV3IGEuQXJjUm90YXRlQ2FtZXJhKGQrXCJfcmlnaHRcIixlK3RoaXMuX2V5ZVNwYWNlLGYsZyxoLGopLGIodGhpcyxkKX1yZXR1cm4gX19leHRlbmRzKGQsYyksZC5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX3VwZGF0ZUNhbWVyYSh0aGlzLl9sZWZ0Q2FtZXJhKSx0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fcmlnaHRDYW1lcmEpLHRoaXMuX2xlZnRDYW1lcmEuYWxwaGE9dGhpcy5hbHBoYS10aGlzLl9leWVTcGFjZSx0aGlzLl9yaWdodENhbWVyYS5hbHBoYT10aGlzLmFscGhhK3RoaXMuX2V5ZVNwYWNlLGMucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKX0sZC5wcm90b3R5cGUuX3VwZGF0ZUNhbWVyYT1mdW5jdGlvbihhKXthLmJldGE9dGhpcy5iZXRhLGEucmFkaXVzPXRoaXMucmFkaXVzLGEubWluWj10aGlzLm1pblosYS5tYXhaPXRoaXMubWF4WixhLmZvdj10aGlzLmZvdixhLnRhcmdldD10aGlzLnRhcmdldH0sZH0oYS5BcmNSb3RhdGVDYW1lcmEpO2EuQW5hZ2x5cGhBcmNSb3RhdGVDYW1lcmE9Yzt2YXIgZD1mdW5jdGlvbihjKXtmdW5jdGlvbiBkKGQsZSxmLGcpe2MuY2FsbCh0aGlzLGQsZSxnKSx0aGlzLl9leWVTcGFjZT1hLlRvb2xzLlRvUmFkaWFucyhmKSx0aGlzLl90cmFuc2Zvcm1NYXRyaXg9bmV3IGEuTWF0cml4LHRoaXMuX2xlZnRDYW1lcmE9bmV3IGEuRnJlZUNhbWVyYShkK1wiX2xlZnRcIixlLmNsb25lKCksZyksdGhpcy5fcmlnaHRDYW1lcmE9bmV3IGEuRnJlZUNhbWVyYShkK1wiX3JpZ2h0XCIsZS5jbG9uZSgpLGcpLGIodGhpcyxkKX1yZXR1cm4gX19leHRlbmRzKGQsYyksZC5wcm90b3R5cGUuX2dldFN1YkNhbWVyYVBvc2l0aW9uPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5nZXRUYXJnZXQoKTthLk1hdHJpeC5UcmFuc2xhdGlvbigtZC54LC1kLnksLWQueikubXVsdGlwbHlUb1JlZihhLk1hdHJpeC5Sb3RhdGlvblkoYiksdGhpcy5fdHJhbnNmb3JtTWF0cml4KSx0aGlzLl90cmFuc2Zvcm1NYXRyaXg9dGhpcy5fdHJhbnNmb3JtTWF0cml4Lm11bHRpcGx5KGEuTWF0cml4LlRyYW5zbGF0aW9uKGQueCxkLnksZC56KSksYS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodGhpcy5wb3NpdGlvbix0aGlzLl90cmFuc2Zvcm1NYXRyaXgsYyl9LGQucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLl9nZXRTdWJDYW1lcmFQb3NpdGlvbigtdGhpcy5fZXllU3BhY2UsdGhpcy5fbGVmdENhbWVyYS5wb3NpdGlvbiksdGhpcy5fZ2V0U3ViQ2FtZXJhUG9zaXRpb24odGhpcy5fZXllU3BhY2UsdGhpcy5fcmlnaHRDYW1lcmEucG9zaXRpb24pLHRoaXMuX3VwZGF0ZUNhbWVyYSh0aGlzLl9sZWZ0Q2FtZXJhKSx0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fcmlnaHRDYW1lcmEpLGMucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKX0sZC5wcm90b3R5cGUuX3VwZGF0ZUNhbWVyYT1mdW5jdGlvbihhKXthLm1pblo9dGhpcy5taW5aLGEubWF4Wj10aGlzLm1heFosYS5mb3Y9dGhpcy5mb3YsYS52aWV3cG9ydD10aGlzLnZpZXdwb3J0LGEuc2V0VGFyZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpfSxkfShhLkZyZWVDYW1lcmEpO2EuQW5hZ2x5cGhGcmVlQ2FtZXJhPWR9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnKXthLmNhbGwodGhpcyxiLFwiYW5hZ2x5cGhcIixudWxsLFtcImxlZnRTYW1wbGVyXCJdLGMsZCxlLGYsZyl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGJ9KGEuUG9zdFByb2Nlc3MpO2EuQW5hZ2x5cGhQb3N0UHJvY2Vzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt9cmV0dXJuIGIuRW5hYmxlRm9yPWZ1bmN0aW9uKGEpe2EuX3RhZ3M9YS5fdGFnc3x8e30sYS5oYXNUYWdzPWZ1bmN0aW9uKCl7cmV0dXJuIGIuSGFzVGFncyhhKX0sYS5hZGRUYWdzPWZ1bmN0aW9uKGMpe3JldHVybiBiLkFkZFRhZ3NUbyhhLGMpfSxhLnJlbW92ZVRhZ3M9ZnVuY3Rpb24oYyl7cmV0dXJuIGIuUmVtb3ZlVGFnc0Zyb20oYSxjKX0sYS5tYXRjaGVzVGFnc1F1ZXJ5PWZ1bmN0aW9uKGMpe3JldHVybiBiLk1hdGNoZXNRdWVyeShhLGMpfX0sYi5EaXNhYmxlRm9yPWZ1bmN0aW9uKGEpe2RlbGV0ZSBhLl90YWdzLGRlbGV0ZSBhLmhhc1RhZ3MsZGVsZXRlIGEuYWRkVGFncyxkZWxldGUgYS5yZW1vdmVUYWdzLGRlbGV0ZSBhLm1hdGNoZXNUYWdzUXVlcnl9LGIuSGFzVGFncz1mdW5jdGlvbihiKXtyZXR1cm4gYi5fdGFncz8hYS5Ub29scy5Jc0VtcHR5KGIuX3RhZ3MpOiExfSxiLkdldFRhZ3M9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuX3RhZ3M/YS5fdGFnczpudWxsfSxiLkFkZFRhZ3NUbz1mdW5jdGlvbihhLGMpe2lmKGMpe3ZhciBkPWMuc3BsaXQoXCIgXCIpO2Zvcih2YXIgZSBpbiBkKWIuX0FkZFRhZ1RvKGEsZFtlXSl9fSxiLl9BZGRUYWdUbz1mdW5jdGlvbihhLGMpe2M9Yy50cmltKCksXCJcIiE9PWMmJlwidHJ1ZVwiIT09YyYmXCJmYWxzZVwiIT09YyYmKGMubWF0Y2goL1tcXHNdLyl8fGMubWF0Y2goL14oWyFdfChbfF18WyZdKXsyfSkvKXx8KGIuRW5hYmxlRm9yKGEpLGEuX3RhZ3NbY109ITApKX0sYi5SZW1vdmVUYWdzRnJvbT1mdW5jdGlvbihhLGMpe2lmKGIuSGFzVGFncyhhKSl7dmFyIGQ9Yy5zcGxpdChcIiBcIik7Zm9yKHZhciBlIGluIGQpYi5fUmVtb3ZlVGFnRnJvbShhLGRbZV0pfX0sYi5fUmVtb3ZlVGFnRnJvbT1mdW5jdGlvbihhLGIpe2RlbGV0ZSBhLl90YWdzW2JdfSxiLk1hdGNoZXNRdWVyeT1mdW5jdGlvbihjLGQpe3JldHVybiB2b2lkIDA9PT1kPyEwOlwiXCI9PT1kP2IuSGFzVGFncyhjKTphLkludGVybmFscy5BbmRPck5vdEV2YWx1YXRvci5FdmFsKGQsZnVuY3Rpb24oYSl7cmV0dXJuIGIuSGFzVGFncyhjKSYmYy5fdGFnc1thXX0pfSxifSgpO2EuVGFncz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7fXJldHVybiBhLkV2YWw9ZnVuY3Rpb24oYixjKXtyZXR1cm4gYj1iLm1hdGNoKC9cXChbXlxcKFxcKV0qXFwpL2cpP2IucmVwbGFjZSgvXFwoW15cXChcXCldKlxcKS9nLGZ1bmN0aW9uKGIpe3JldHVybiBiPWIuc2xpY2UoMSxiLmxlbmd0aC0xKSxhLl9IYW5kbGVQYXJlbnRoZXNpc0NvbnRlbnQoYixjKX0pOmEuX0hhbmRsZVBhcmVudGhlc2lzQ29udGVudChiLGMpLFwidHJ1ZVwiPT09Yj8hMDpcImZhbHNlXCI9PT1iPyExOmEuRXZhbChiLGMpfSxhLl9IYW5kbGVQYXJlbnRoZXNpc0NvbnRlbnQ9ZnVuY3Rpb24oYixjKXtjPWN8fGZ1bmN0aW9uKGEpe3JldHVyblwidHJ1ZVwiPT09YT8hMDohMX07dmFyIGQsZT1iLnNwbGl0KFwifHxcIik7Zm9yKHZhciBmIGluIGUpe3ZhciBnPWEuX1NpbXBsaWZ5TmVnYXRpb24oZVtmXS50cmltKCkpLGg9Zy5zcGxpdChcIiYmXCIpO2lmKGgubGVuZ3RoPjEpZm9yKHZhciBpPTA7aTxoLmxlbmd0aDsrK2kpe3ZhciBqPWEuX1NpbXBsaWZ5TmVnYXRpb24oaFtpXS50cmltKCkpO2lmKGQ9XCJ0cnVlXCIhPT1qJiZcImZhbHNlXCIhPT1qP1wiIVwiPT09alswXT8hYyhqLnN1YnN0cmluZygxKSk6YyhqKTpcInRydWVcIj09PWo/ITA6ITEsIWQpe2c9XCJmYWxzZVwiO2JyZWFrfX1pZihkfHxcInRydWVcIj09PWcpe2Q9ITA7YnJlYWt9ZD1cInRydWVcIiE9PWcmJlwiZmFsc2VcIiE9PWc/XCIhXCI9PT1nWzBdPyFjKGcuc3Vic3RyaW5nKDEpKTpjKGcpOlwidHJ1ZVwiPT09Zz8hMDohMX1yZXR1cm4gZD9cInRydWVcIjpcImZhbHNlXCJ9LGEuX1NpbXBsaWZ5TmVnYXRpb249ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9eW1xccyFdKy8sZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9bXFxzXS9nLGZ1bmN0aW9uKCl7cmV0dXJuXCJcIn0pLGEubGVuZ3RoJTI/XCIhXCI6XCJcIn0pLGE9YS50cmltKCksXCIhdHJ1ZVwiPT09YT9hPVwiZmFsc2VcIjpcIiFmYWxzZVwiPT09YSYmKGE9XCJ0cnVlXCIpLGF9LGF9KCk7YS5BbmRPck5vdEV2YWx1YXRvcj1ifShhLkludGVybmFsc3x8KGEuSW50ZXJuYWxzPXt9KSk7YS5JbnRlcm5hbHN9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7dGhpcy5fZW5hYmxlZD0hMCx0aGlzLl9yZWZDb3VudD0wLHRoaXMuX25hbWU9Yyx0aGlzLl9yZW5kZXJUZXh0dXJlPW5ldyBhLlJlbmRlclRhcmdldFRleHR1cmUoYyxkLGIpLHRoaXMuc2V0UmVuZGVyTGlzdChlKSx0aGlzLl9yZW5kZXJUZXh0dXJlLm9uQmVmb3JlUmVuZGVyPWYsdGhpcy5fcmVuZGVyVGV4dHVyZS5vbkFmdGVyUmVuZGVyPWcsdGhpcy5fc2NlbmU9Yn1yZXR1cm4gYi5wcm90b3R5cGUuX2luY1JlZkNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLl9yZWZDb3VudCYmdGhpcy5fc2NlbmUuY3VzdG9tUmVuZGVyVGFyZ2V0cy5wdXNoKHRoaXMuX3JlbmRlclRleHR1cmUpLCsrdGhpcy5fcmVmQ291bnR9LGIucHJvdG90eXBlLl9kZWNSZWZDb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWZDb3VudC0tLHRoaXMuX3JlZkNvdW50PD0wJiZ0aGlzLl9zY2VuZS5jdXN0b21SZW5kZXJUYXJnZXRzLnNwbGljZSh0aGlzLl9zY2VuZS5jdXN0b21SZW5kZXJUYXJnZXRzLmluZGV4T2YodGhpcy5fcmVuZGVyVGV4dHVyZSksMSksdGhpcy5fcmVmQ291bnR9LGIucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oKXt0aGlzLnNldFJlbmRlckxpc3QodGhpcy5fcmVuZGVyTGlzdCl9LGIucHJvdG90eXBlLnNldFJlbmRlckxpc3Q9ZnVuY3Rpb24oYSl7dGhpcy5fcmVuZGVyVGV4dHVyZS5yZW5kZXJMaXN0PWF9LGIucHJvdG90eXBlLmdldFJlbmRlclRleHR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZX0sYn0oKTthLlBvc3RQcm9jZXNzUmVuZGVyUGFzcz1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiLGMsZCxlLGYpe3RoaXMuX2VuZ2luZT1hLHRoaXMuX25hbWU9Yix0aGlzLl9wb3N0UHJvY2Vzc1R5cGU9Yyx0aGlzLl9yYXRpbz1kfHwxLHRoaXMuX3NhbXBsaW5nTW9kZT1lfHxudWxsLHRoaXMuX3NpbmdsZUluc3RhbmNlPWZ8fCEwLHRoaXMuX2NhbWVyYXM9W10sdGhpcy5fcG9zdFByb2Nlc3Nlcz1bXSx0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhPVtdLHRoaXMuX3JlbmRlclBhc3Nlcz1bXSx0aGlzLl9yZW5kZXJFZmZlY3RBc1Bhc3Nlcz1bXSx0aGlzLnBhcmFtZXRlcnM9ZnVuY3Rpb24oKXt9fXJldHVybiBiLl9HZXRJbnN0YW5jZT1mdW5jdGlvbihhLGMsZCxlKXtmb3IodmFyIGYsZyxoPVtdLGk9Yi5fR2V0UGFyYW1ldGVyc05hbWVzKGMpLGo9MDtqPGkubGVuZ3RoO2orKylzd2l0Y2goaVtqXSl7Y2FzZVwibmFtZVwiOmhbal09Yy50b1N0cmluZygpO2JyZWFrO2Nhc2VcInJhdGlvXCI6aFtqXT1kO2JyZWFrO2Nhc2VcImNhbWVyYVwiOmhbal09bnVsbDticmVhaztjYXNlXCJzYW1wbGluZ01vZGVcIjpoW2pdPWU7YnJlYWs7Y2FzZVwiZW5naW5lXCI6aFtqXT1hO2JyZWFrO2Nhc2VcInJldXNhYmxlXCI6aFtqXT0hMDticmVhaztkZWZhdWx0Omhbal09bnVsbH1yZXR1cm4gZj1mdW5jdGlvbigpe30sZi5wcm90b3R5cGU9Yy5wcm90b3R5cGUsZz1uZXcgZixjLmFwcGx5KGcsaCksZ30sYi5fR2V0UGFyYW1ldGVyc05hbWVzPWZ1bmN0aW9uKGEpe3ZhciBiPS8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9nbSxjPWEudG9TdHJpbmcoKS5yZXBsYWNlKGIsXCJcIiksZD1jLnNsaWNlKGMuaW5kZXhPZihcIihcIikrMSxjLmluZGV4T2YoXCIpXCIpKS5tYXRjaCgvKFteXFxzLF0rKS9nKTtyZXR1cm4gbnVsbD09PWQmJihkPVtdKSxkfSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuX3JlbmRlclBhc3Nlcyl0aGlzLl9yZW5kZXJQYXNzZXNbYV0uX3VwZGF0ZSgpfSxiLnByb3RvdHlwZS5hZGRQYXNzPWZ1bmN0aW9uKGEpe3RoaXMuX3JlbmRlclBhc3Nlc1thLl9uYW1lXT1hLHRoaXMuX2xpbmtQYXJhbWV0ZXJzKCl9LGIucHJvdG90eXBlLnJlbW92ZVBhc3M9ZnVuY3Rpb24oYSl7ZGVsZXRlIHRoaXMuX3JlbmRlclBhc3Nlc1thLl9uYW1lXSx0aGlzLl9saW5rUGFyYW1ldGVycygpfSxiLnByb3RvdHlwZS5hZGRSZW5kZXJFZmZlY3RBc1Bhc3M9ZnVuY3Rpb24oYSl7dGhpcy5fcmVuZGVyRWZmZWN0QXNQYXNzZXNbYS5fbmFtZV09YSx0aGlzLl9saW5rUGFyYW1ldGVycygpfSxiLnByb3RvdHlwZS5nZXRQYXNzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYiBpbiB0aGlzLl9yZW5kZXJQYXNzZXMpaWYoYj09PWEpcmV0dXJuIHRoaXMuX3JlbmRlclBhc3Nlc1thXX0sYi5wcm90b3R5cGUuZW1wdHlQYXNzZXM9ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJQYXNzZXMubGVuZ3RoPTAsdGhpcy5fbGlua1BhcmFtZXRlcnMoKX0sYi5wcm90b3R5cGUuX2F0dGFjaENhbWVyYXM9ZnVuY3Rpb24oYyl7Zm9yKHZhciBkLGU9YS5Ub29scy5NYWtlQXJyYXkoY3x8dGhpcy5fY2FtZXJhcyksZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdLGg9Zy5uYW1lO2Q9dGhpcy5fc2luZ2xlSW5zdGFuY2U/MDpoLHRoaXMuX3Bvc3RQcm9jZXNzZXNbZF09dGhpcy5fcG9zdFByb2Nlc3Nlc1tkXXx8Yi5fR2V0SW5zdGFuY2UodGhpcy5fZW5naW5lLHRoaXMuX3Bvc3RQcm9jZXNzVHlwZSx0aGlzLl9yYXRpbyx0aGlzLl9zYW1wbGluZ01vZGUpO3ZhciBpPWcuYXR0YWNoUG9zdFByb2Nlc3ModGhpcy5fcG9zdFByb2Nlc3Nlc1tkXSk7bnVsbD09PXRoaXMuX2luZGljZXNGb3JDYW1lcmFbaF0mJih0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhW2hdPVtdKSx0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhW2hdLnB1c2goaSksLTE9PT10aGlzLl9jYW1lcmFzLmluZGV4T2YoZykmJih0aGlzLl9jYW1lcmFzW2hdPWcpO2Zvcih2YXIgaiBpbiB0aGlzLl9yZW5kZXJQYXNzZXMpdGhpcy5fcmVuZGVyUGFzc2VzW2pdLl9pbmNSZWZDb3VudCgpfXRoaXMuX2xpbmtQYXJhbWV0ZXJzKCl9LGIucHJvdG90eXBlLl9kZXRhY2hDYW1lcmFzPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1hLlRvb2xzLk1ha2VBcnJheShifHx0aGlzLl9jYW1lcmFzKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1lLm5hbWU7ZS5kZXRhY2hQb3N0UHJvY2Vzcyh0aGlzLl9wb3N0UHJvY2Vzc2VzW3RoaXMuX3NpbmdsZUluc3RhbmNlPzA6Zl0sdGhpcy5faW5kaWNlc0ZvckNhbWVyYVtmXSk7dmFyIGc9dGhpcy5fY2FtZXJhcy5pbmRleE9mKGYpO3RoaXMuX2luZGljZXNGb3JDYW1lcmEuc3BsaWNlKGcsMSksdGhpcy5fY2FtZXJhcy5zcGxpY2UoZywxKTtmb3IodmFyIGggaW4gdGhpcy5fcmVuZGVyUGFzc2VzKXRoaXMuX3JlbmRlclBhc3Nlc1toXS5fZGVjUmVmQ291bnQoKX19LGIucHJvdG90eXBlLl9lbmFibGU9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPWEuVG9vbHMuTWFrZUFycmF5KGJ8fHRoaXMuX2NhbWVyYXMpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7Zm9yKHZhciBlPWNbZF0sZj1lLm5hbWUsZz0wO2c8dGhpcy5faW5kaWNlc0ZvckNhbWVyYVtmXS5sZW5ndGg7ZysrKXZvaWQgMD09PWUuX3Bvc3RQcm9jZXNzZXNbdGhpcy5faW5kaWNlc0ZvckNhbWVyYVtmXVtnXV0mJmJbZF0uYXR0YWNoUG9zdFByb2Nlc3ModGhpcy5fcG9zdFByb2Nlc3Nlc1t0aGlzLl9zaW5nbGVJbnN0YW5jZT8wOmZdLHRoaXMuX2luZGljZXNGb3JDYW1lcmFbZl1bZ10pO2Zvcih2YXIgaCBpbiB0aGlzLl9yZW5kZXJQYXNzZXMpdGhpcy5fcmVuZGVyUGFzc2VzW2hdLl9pbmNSZWZDb3VudCgpfX0sYi5wcm90b3R5cGUuX2Rpc2FibGU9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPWEuVG9vbHMuTWFrZUFycmF5KGJ8fHRoaXMuX2NhbWVyYXMpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPWUuTmFtZTtlLmRldGFjaFBvc3RQcm9jZXNzKHRoaXMuX3Bvc3RQcm9jZXNzZXNbdGhpcy5fc2luZ2xlSW5zdGFuY2U/MDpmXSx0aGlzLl9pbmRpY2VzRm9yQ2FtZXJhW2ZdKTtmb3IodmFyIGcgaW4gdGhpcy5fcmVuZGVyUGFzc2VzKXRoaXMuX3JlbmRlclBhc3Nlc1tnXS5fZGVjUmVmQ291bnQoKX19LGIucHJvdG90eXBlLmdldFBvc3RQcm9jZXNzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9zaW5nbGVJbnN0YW5jZT90aGlzLl9wb3N0UHJvY2Vzc2VzWzBdOnRoaXMuX3Bvc3RQcm9jZXNzZXNbYS5uYW1lXX0sYi5wcm90b3R5cGUuX2xpbmtQYXJhbWV0ZXJzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztmb3IodmFyIGIgaW4gdGhpcy5fcG9zdFByb2Nlc3Nlcyl0aGlzLl9wb3N0UHJvY2Vzc2VzW2JdLm9uQXBwbHk9ZnVuY3Rpb24oYil7YS5wYXJhbWV0ZXJzKGIpLGEuX2xpbmtUZXh0dXJlcyhiKX19LGIucHJvdG90eXBlLl9saW5rVGV4dHVyZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiIGluIHRoaXMuX3JlbmRlclBhc3NlcylhLnNldFRleHR1cmUoYix0aGlzLl9yZW5kZXJQYXNzZXNbYl0uZ2V0UmVuZGVyVGV4dHVyZSgpKTtmb3IodmFyIGMgaW4gdGhpcy5fcmVuZGVyRWZmZWN0QXNQYXNzZXMpYS5zZXRUZXh0dXJlRnJvbVBvc3RQcm9jZXNzKGMrXCJTYW1wbGVyXCIsdGhpcy5fcmVuZGVyRWZmZWN0QXNQYXNzZXNbY10uZ2V0UG9zdFByb2Nlc3MoKSl9LGJ9KCk7YS5Qb3N0UHJvY2Vzc1JlbmRlckVmZmVjdD1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiKXt0aGlzLl9lbmdpbmU9YSx0aGlzLl9uYW1lPWIsdGhpcy5fcmVuZGVyRWZmZWN0cz1bXSx0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzPVtdLHRoaXMuX2NhbWVyYXM9W119cmV0dXJuIGIucHJvdG90eXBlLmFkZEVmZmVjdD1mdW5jdGlvbihhKXt0aGlzLl9yZW5kZXJFZmZlY3RzW2EuX25hbWVdPWF9LGIucHJvdG90eXBlLl9lbmFibGVFZmZlY3Q9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLl9yZW5kZXJFZmZlY3RzW2JdO2QmJmQuZW5hYmxlKGEuVG9vbHMuTWFrZUFycmF5KGN8fHRoaXMuX2NhbWVyYXMpKX0sYi5wcm90b3R5cGUuX2Rpc2FibGVFZmZlY3Q9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLl9yZW5kZXJFZmZlY3RzW2JdO2QmJmQuZGlzYWJsZShhLlRvb2xzLk1ha2VBcnJheShjfHx0aGlzLl9jYW1lcmFzKSl9LGIucHJvdG90eXBlLl9hdHRhY2hDYW1lcmFzPWZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPWEuVG9vbHMuTWFrZUFycmF5KGJ8fHRoaXMuX2NhbWVyYXMpLGU9W10sZj0wO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgZz1kW2ZdLGg9Zy5uYW1lOy0xPT09dGhpcy5fY2FtZXJhcy5pbmRleE9mKGcpP3RoaXMuX2NhbWVyYXNbaF09ZzpjJiZlLnB1c2goZil9Zm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspYi5zcGxpY2UoZVtmXSwxKTtmb3IodmFyIGkgaW4gdGhpcy5fcmVuZGVyRWZmZWN0cyl0aGlzLl9yZW5kZXJFZmZlY3RzW2ldLl9hdHRhY2hDYW1lcmFzKGQpfSxiLnByb3RvdHlwZS5fZGV0YWNoQ2FtZXJhcz1mdW5jdGlvbihiKXt2YXIgYz1hLlRvb2xzLk1ha2VBcnJheShifHx0aGlzLl9jYW1lcmFzKTtmb3IodmFyIGQgaW4gdGhpcy5fcmVuZGVyRWZmZWN0cyl0aGlzLl9yZW5kZXJFZmZlY3RzW2RdLl9kZXRhY2hDYW1lcmFzKGMpO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXRoaXMuX2NhbWVyYXMuc3BsaWNlKHRoaXMuX2NhbWVyYXMuaW5kZXhPZihjW2VdKSwxKX0sYi5wcm90b3R5cGUuX2VuYWJsZURpc3BsYXlPbmx5UGFzcz1mdW5jdGlvbihjLGQpe3ZhciBlPWEuVG9vbHMuTWFrZUFycmF5KGR8fHRoaXMuX2NhbWVyYXMpLGY9bnVsbDtmb3IodmFyIGcgaW4gdGhpcy5fcmVuZGVyRWZmZWN0cylpZihmPXRoaXMuX3JlbmRlckVmZmVjdHNbZ10uZ2V0UGFzcyhjKSxudWxsIT1mKWJyZWFrO2lmKG51bGwhPT1mKXtmb3IodmFyIGcgaW4gdGhpcy5fcmVuZGVyRWZmZWN0cyl0aGlzLl9yZW5kZXJFZmZlY3RzW2ddLl9kaXNhYmxlKGUpO2YuX25hbWU9Yi5QQVNTX1NBTVBMRVJfTkFNRTtmb3IodmFyIGg9MDtoPGUubGVuZ3RoO2grKyl7dmFyIGk9ZVtoXSxqPWkubmFtZTt0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2pdPXRoaXMuX3JlbmRlckVmZmVjdHNGb3JJc29sYXRlZFBhc3Nbal18fG5ldyBhLlBvc3RQcm9jZXNzUmVuZGVyRWZmZWN0KHRoaXMuX2VuZ2luZSxiLlBBU1NfRUZGRUNUX05BTUUsXCJCQUJZTE9OLkRpc3BsYXlQYXNzUG9zdFByb2Nlc3NcIiwxLG51bGwsbnVsbCksdGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tqXS5lbXB0eVBhc3NlcygpLHRoaXMuX3JlbmRlckVmZmVjdHNGb3JJc29sYXRlZFBhc3Nbal0uYWRkUGFzcyhmKSx0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2pdLl9hdHRhY2hDYW1lcmFzKGkpfX19LGIucHJvdG90eXBlLl9kaXNhYmxlRGlzcGxheU9ubHlQYXNzPWZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1hLlRvb2xzLk1ha2VBcnJheShjfHx0aGlzLl9jYW1lcmFzKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV0sZz1mLm5hbWU7dGhpcy5fcmVuZGVyRWZmZWN0c0Zvcklzb2xhdGVkUGFzc1tnXT10aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2ddfHxuZXcgYS5Qb3N0UHJvY2Vzc1JlbmRlckVmZmVjdCh0aGlzLl9lbmdpbmUsYi5QQVNTX0VGRkVDVF9OQU1FLFwiQkFCWUxPTi5EaXNwbGF5UGFzc1Bvc3RQcm9jZXNzXCIsMSxudWxsLG51bGwpLHRoaXMuX3JlbmRlckVmZmVjdHNGb3JJc29sYXRlZFBhc3NbZ10uX2Rpc2FibGUoZil9Zm9yKHZhciBoIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpdGhpcy5fcmVuZGVyRWZmZWN0c1toXS5fZW5hYmxlKGQpfSxiLnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuX3JlbmRlckVmZmVjdHMpdGhpcy5fcmVuZGVyRWZmZWN0c1thXS5fdXBkYXRlKCk7Zm9yKHZhciBiPTA7Yjx0aGlzLl9jYW1lcmFzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX2NhbWVyYXNbYl0ubmFtZTt0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2NdJiZ0aGlzLl9yZW5kZXJFZmZlY3RzRm9ySXNvbGF0ZWRQYXNzW2NdLl91cGRhdGUoKX19LGIuUEFTU19FRkZFQ1RfTkFNRT1cInBhc3NFZmZlY3RcIixiLlBBU1NfU0FNUExFUl9OQU1FPVwicGFzc1NhbXBsZXJcIixifSgpO2EuUG9zdFByb2Nlc3NSZW5kZXJQaXBlbGluZT1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt0aGlzLl9yZW5kZXJQaXBlbGluZXM9W119cmV0dXJuIGEucHJvdG90eXBlLmFkZFBpcGVsaW5lPWZ1bmN0aW9uKGEpe3RoaXMuX3JlbmRlclBpcGVsaW5lc1thLl9uYW1lXT1hfSxhLnByb3RvdHlwZS5hdHRhY2hDYW1lcmFzVG9SZW5kZXJQaXBlbGluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fcmVuZGVyUGlwZWxpbmVzW2FdO2QmJmQuYXR0YWNoQ2FtZXJhcyhiLGMpfSxhLnByb3RvdHlwZS5kZXRhY2hDYW1lcmFzRnJvbVJlbmRlclBpcGVsaW5lPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5fcmVuZGVyUGlwZWxpbmVzW2FdO2MmJmMuZGV0YWNoQ2FtZXJhcyhiKX0sYS5wcm90b3R5cGUuZW5hYmxlRWZmZWN0SW5QaXBlbGluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fcmVuZGVyUGlwZWxpbmVzW2FdO2QmJmQuZW5hYmxlRWZmZWN0KGIsYyl9LGEucHJvdG90eXBlLmRpc2FibGVFZmZlY3RJblBpcGVsaW5lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLl9yZW5kZXJQaXBlbGluZXNbYV07ZCYmZC5kaXNhYmxlRWZmZWN0KGIsYyl9LGEucHJvdG90eXBlLmVuYWJsZURpc3BsYXlPbmx5UGFzc0luUGlwZWxpbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXTtkJiZkLmVuYWJsZURpc3BsYXlPbmx5UGFzcyhiLGMpfSxhLnByb3RvdHlwZS5kaXNhYmxlRGlzcGxheU9ubHlQYXNzSW5QaXBlbGluZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX3JlbmRlclBpcGVsaW5lc1thXTtjJiZjLmRpc2FibGVEaXNwbGF5T25seVBhc3MoYil9LGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLl9yZW5kZXJQaXBlbGluZXMpdGhpcy5fcmVuZGVyUGlwZWxpbmVzW2FdLl91cGRhdGUoKX0sYX0oKTthLlBvc3RQcm9jZXNzUmVuZGVyUGlwZWxpbmVNYW5hZ2VyPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUsZixnKXthLmNhbGwodGhpcyxiLFwiZGlzcGxheVBhc3NcIixbXCJwYXNzU2FtcGxlclwiXSxbXCJwYXNzU2FtcGxlclwiXSxjLGQsZSxmLGcpfXJldHVybiBfX2V4dGVuZHMoYixhKSxifShhLlBvc3RQcm9jZXNzKTthLkRpc3BsYXlQYXNzUG9zdFByb2Nlc3M9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3RoaXMuZnJvbnRDb2xvcj1uZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMuYmFja0NvbG9yPW5ldyBhLkNvbG9yMyguMSwuMSwuMSksdGhpcy5zaG93QmFja0xpbmVzPSEwLHRoaXMucmVuZGVyTGlzdD1uZXcgYS5TbWFydEFycmF5KDMyKSx0aGlzLl9zY2VuZT1iLHRoaXMuX2NvbG9yU2hhZGVyPW5ldyBhLlNoYWRlck1hdGVyaWFsKFwiY29sb3JTaGFkZXJcIixiLFwiY29sb3JcIix7YXR0cmlidXRlczpbXCJwb3NpdGlvblwiXSx1bmlmb3JtczpbXCJ3b3JsZFZpZXdQcm9qZWN0aW9uXCIsXCJjb2xvclwiXX0pO3ZhciBjPXRoaXMuX3NjZW5lLmdldEVuZ2luZSgpLGQ9YS5WZXJ0ZXhEYXRhLkNyZWF0ZUJveCgxKTt0aGlzLl92Yj1uZXcgYS5WZXJ0ZXhCdWZmZXIoYyxkLnBvc2l0aW9ucyxhLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQsITEpLHRoaXMuX2liPWMuY3JlYXRlSW5kZXhCdWZmZXIoWzAsMSwxLDIsMiwzLDMsMCw0LDUsNSw2LDYsNyw3LDQsMCw3LDEsNiwyLDUsMyw0XSl9cmV0dXJuIGIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5yZW5kZXJMaXN0LnJlc2V0KCl9LGIucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe2lmKDAhPXRoaXMucmVuZGVyTGlzdC5sZW5ndGgmJnRoaXMuX2NvbG9yU2hhZGVyLmlzUmVhZHkoKSl7dmFyIGI9dGhpcy5fc2NlbmUuZ2V0RW5naW5lKCk7Yi5zZXREZXB0aFdyaXRlKCExKSx0aGlzLl9jb2xvclNoYWRlci5fcHJlQmluZCgpO2Zvcih2YXIgYz0wO2M8dGhpcy5yZW5kZXJMaXN0Lmxlbmd0aDtjKyspe3ZhciBkPXRoaXMucmVuZGVyTGlzdC5kYXRhW2NdLGU9ZC5taW5pbXVtLGY9ZC5tYXhpbXVtLGc9Zi5zdWJ0cmFjdChlKSxoPWUuYWRkKGcuc2NhbGUoLjUpKSxpPWEuTWF0cml4LlNjYWxpbmcoZy54LGcueSxnLnopLm11bHRpcGx5KGEuTWF0cml4LlRyYW5zbGF0aW9uKGgueCxoLnksaC56KSkubXVsdGlwbHkoZC5nZXRXb3JsZE1hdHJpeCgpKTtiLmJpbmRCdWZmZXJzKHRoaXMuX3ZiLmdldEJ1ZmZlcigpLHRoaXMuX2liLFszXSwxMix0aGlzLl9jb2xvclNoYWRlci5nZXRFZmZlY3QoKSksdGhpcy5zaG93QmFja0xpbmVzJiYoYi5zZXREZXB0aEZ1bmN0aW9uVG9HcmVhdGVyT3JFcXVhbCgpLHRoaXMuX2NvbG9yU2hhZGVyLnNldENvbG9yMyhcImNvbG9yXCIsdGhpcy5iYWNrQ29sb3IpLHRoaXMuX2NvbG9yU2hhZGVyLmJpbmQoaSksYi5kcmF3KCExLDAsMjQpKSxiLnNldERlcHRoRnVuY3Rpb25Ub0xlc3MoKSx0aGlzLl9jb2xvclNoYWRlci5zZXRDb2xvcjMoXCJjb2xvclwiLHRoaXMuZnJvbnRDb2xvciksdGhpcy5fY29sb3JTaGFkZXIuYmluZChpKSxiLmRyYXcoITEsMCwyNCl9dGhpcy5fY29sb3JTaGFkZXIudW5iaW5kKCksYi5zZXREZXB0aEZ1bmN0aW9uVG9MZXNzT3JFcXVhbCgpLGIuc2V0RGVwdGhXcml0ZSghMCl9fSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY29sb3JTaGFkZXIuZGlzcG9zZSgpLHRoaXMuX3ZiLmRpc3Bvc2UoKSx0aGlzLl9zY2VuZS5nZXRFbmdpbmUoKS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pYil9LGJ9KCk7YS5Cb3VuZGluZ0JveFJlbmRlcmVyPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpeyFmdW5jdGlvbihiKXt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt9cmV0dXJuIGIuR2V0VEdBSGVhZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPTAsYz17aWRfbGVuZ3RoOmFbYisrXSxjb2xvcm1hcF90eXBlOmFbYisrXSxpbWFnZV90eXBlOmFbYisrXSxjb2xvcm1hcF9pbmRleDphW2IrK118YVtiKytdPDw4LGNvbG9ybWFwX2xlbmd0aDphW2IrK118YVtiKytdPDw4LGNvbG9ybWFwX3NpemU6YVtiKytdLG9yaWdpbjpbYVtiKytdfGFbYisrXTw8OCxhW2IrK118YVtiKytdPDw4XSx3aWR0aDphW2IrK118YVtiKytdPDw4LGhlaWdodDphW2IrK118YVtiKytdPDw4LHBpeGVsX3NpemU6YVtiKytdLGZsYWdzOmFbYisrXX07cmV0dXJuIGN9LGIuVXBsb2FkQ29udGVudD1mdW5jdGlvbihjLGQpe2lmKGQubGVuZ3RoPDE5KXJldHVybiB2b2lkIGEuVG9vbHMuRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBUR0EgZmlsZSAtIE5vdCBlbm91Z2ggZGF0YSB0byBjb250YWluIGhlYWRlclwiKTt2YXIgZT0xOCxmPWIuR2V0VEdBSGVhZGVyKGQpO2lmKGYuaWRfbGVuZ3RoK2U+ZC5sZW5ndGgpcmV0dXJuIHZvaWQgYS5Ub29scy5FcnJvcihcIlVuYWJsZSB0byBsb2FkIFRHQSBmaWxlIC0gTm90IGVub3VnaCBkYXRhXCIpO2UrPWYuaWRfbGVuZ3RoO3ZhciBnPSExLGg9ITEsaT0hMSxqPSExO3N3aXRjaChmLmltYWdlX3R5cGUpe2Nhc2UgYi5fVFlQRV9STEVfSU5ERVhFRDpnPSEwO2Nhc2UgYi5fVFlQRV9JTkRFWEVEOmg9ITA7YnJlYWs7Y2FzZSBiLl9UWVBFX1JMRV9SR0I6Zz0hMDtjYXNlIGIuX1RZUEVfUkdCOmk9ITA7YnJlYWs7Y2FzZSBiLl9UWVBFX1JMRV9HUkVZOmc9ITA7Y2FzZSBiLl9UWVBFX0dSRVk6aj0hMH12YXIgayxsLG09KDE1JmYuZmxhZ3MsZi5waXhlbF9zaXplPj4zKSxuPWYud2lkdGgqZi5oZWlnaHQqbTtpZihoJiYobD1kLnN1YmFycmF5KGUsZSs9Zi5jb2xvcm1hcF9sZW5ndGgqKGYuY29sb3JtYXBfc2l6ZT4+MykpKSxnKXtrPW5ldyBVaW50OEFycmF5KG4pO2Zvcih2YXIgbyxwLHEscj0wLHM9bmV3IFVpbnQ4QXJyYXkobSk7bj5lOylpZihvPWRbZSsrXSxwPSgxMjcmbykrMSwxMjgmbyl7Zm9yKHE9MDttPnE7KytxKXNbcV09ZFtlKytdO2ZvcihxPTA7cD5xOysrcSlrLnNldChzLHIrcSptKTtyKz1tKnB9ZWxzZXtmb3IocCo9bSxxPTA7cD5xOysrcSlrW3IrcV09ZFtlKytdO3IrPXB9fWVsc2Ugaz1kLnN1YmFycmF5KGUsZSs9aD9mLndpZHRoKmYuaGVpZ2h0Om4pO3ZhciB0LHUsdix3LHgseTtzd2l0Y2goKGYuZmxhZ3MmYi5fT1JJR0lOX01BU0spPj5iLl9PUklHSU5fU0hJRlQpe2RlZmF1bHQ6Y2FzZSBiLl9PUklHSU5fVUw6dD0wLHY9MSx5PWYud2lkdGgsdT0wLHc9MSx4PWYuaGVpZ2h0O2JyZWFrO2Nhc2UgYi5fT1JJR0lOX0JMOnQ9MCx2PTEseT1mLndpZHRoLHU9Zi5oZWlnaHQtMSx3PS0xLHg9LTE7YnJlYWs7Y2FzZSBiLl9PUklHSU5fVVI6dD1mLndpZHRoLTEsdj0tMSx5PS0xLHU9MCx3PTEseD1mLmhlaWdodDticmVhaztjYXNlIGIuX09SSUdJTl9CUjp0PWYud2lkdGgtMSx2PS0xLHk9LTEsdT1mLmhlaWdodC0xLHc9LTEseD0tMX12YXIgej1cIl9nZXRJbWFnZURhdGFcIisoaj9cIkdyZXlcIjpcIlwiKStmLnBpeGVsX3NpemUrXCJiaXRzXCIsQT1iW3pdKGYsbCxrLHUsdyx4LHQsdix5KTtjLnRleEltYWdlMkQoYy5URVhUVVJFXzJELDAsYy5SR0JBLGYud2lkdGgsZi5oZWlnaHQsMCxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLEEpfSxiLl9nZXRJbWFnZURhdGE4Yml0cz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSl7dmFyIGosayxsLG09YyxuPWIsbz1hLndpZHRoLHA9YS5oZWlnaHQscT0wLHI9bmV3IFVpbnQ4QXJyYXkobypwKjQpO2ZvcihsPWQ7bCE9PWY7bCs9ZSlmb3Ioaz1nO2shPT1pO2srPWgscSsrKWo9bVtxXSxyWzQqKGsrbypsKSszXT0yNTUscls0KihrK28qbCkrMl09blszKmorMF0scls0KihrK28qbCkrMV09blszKmorMV0scls0KihrK28qbCkrMF09blszKmorMl07cmV0dXJuIHJ9LGIuX2dldEltYWdlRGF0YTE2Yml0cz1mdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSl7dmFyIGosayxsLG09YyxuPWEud2lkdGgsbz1hLmhlaWdodCxwPTAscT1uZXcgVWludDhBcnJheShuKm8qNCk7Zm9yKGw9ZDtsIT09ZjtsKz1lKWZvcihrPWc7ayE9PWk7ays9aCxwKz0yKWo9bVtwKzBdKyhtW3ArMV08PDgpLHFbNCooaytuKmwpKzBdPSgzMTc0NCZqKT4+NyxxWzQqKGsrbipsKSsxXT0oOTkyJmopPj4yLHFbNCooaytuKmwpKzJdPSgzMSZqKT4+MyxxWzQqKGsrbipsKSszXT0zMjc2OCZqPzA6MjU1O3JldHVybiBxfSxiLl9nZXRJbWFnZURhdGEyNGJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbD1jLG09YS53aWR0aCxuPWEuaGVpZ2h0LG89MCxwPW5ldyBVaW50OEFycmF5KG0qbio0KTtmb3Ioaz1kO2shPT1mO2srPWUpZm9yKGo9ZztqIT09aTtqKz1oLG8rPTMpcFs0KihqK20qaykrM109MjU1LHBbNCooaittKmspKzJdPWxbbyswXSxwWzQqKGorbSprKSsxXT1sW28rMV0scFs0KihqK20qaykrMF09bFtvKzJdO3JldHVybiBwfSxiLl9nZXRJbWFnZURhdGEzMmJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbD1jLG09YS53aWR0aCxuPWEuaGVpZ2h0LG89MCxwPW5ldyBVaW50OEFycmF5KG0qbio0KTtmb3Ioaz1kO2shPT1mO2srPWUpZm9yKGo9ZztqIT09aTtqKz1oLG8rPTQpcFs0KihqK20qaykrMl09bFtvKzBdLHBbNCooaittKmspKzFdPWxbbysxXSxwWzQqKGorbSprKSswXT1sW28rMl0scFs0KihqK20qaykrM109bFtvKzNdO3JldHVybiBwfSxiLl9nZXRJbWFnZURhdGFHcmV5OGJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbCxtPWMsbj1hLndpZHRoLG89YS5oZWlnaHQscD0wLHE9bmV3IFVpbnQ4QXJyYXkobipvKjQpO2ZvcihsPWQ7bCE9PWY7bCs9ZSlmb3Ioaz1nO2shPT1pO2srPWgscCsrKWo9bVtwXSxxWzQqKGsrbipsKSswXT1qLHFbNCooaytuKmwpKzFdPWoscVs0KihrK24qbCkrMl09aixxWzQqKGsrbipsKSszXT0yNTU7cmV0dXJuIHF9LGIuX2dldEltYWdlRGF0YUdyZXkxNmJpdHM9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqLGssbD1jLG09YS53aWR0aCxuPWEuaGVpZ2h0LG89MCxwPW5ldyBVaW50OEFycmF5KG0qbio0KTtmb3Ioaz1kO2shPT1mO2srPWUpZm9yKGo9ZztqIT09aTtqKz1oLG8rPTIpcFs0KihqK20qaykrMF09bFtvKzBdLHBbNCooaittKmspKzFdPWxbbyswXSxwWzQqKGorbSprKSsyXT1sW28rMF0scFs0KihqK20qaykrM109bFtvKzFdO3JldHVybiBwfSxiLl9UWVBFX05PX0RBVEE9MCxiLl9UWVBFX0lOREVYRUQ9MSxiLl9UWVBFX1JHQj0yLGIuX1RZUEVfR1JFWT0zLGIuX1RZUEVfUkxFX0lOREVYRUQ9OSxiLl9UWVBFX1JMRV9SR0I9MTAsYi5fVFlQRV9STEVfR1JFWT0xMSxiLl9PUklHSU5fTUFTSz00OCxiLl9PUklHSU5fU0hJRlQ9NCxiLl9PUklHSU5fQkw9MCxiLl9PUklHSU5fQlI9MSxiLl9PUklHSU5fVUw9MixiLl9PUklHSU5fVVI9MyxifSgpO2IuVEdBVG9vbHM9Y30oYS5JbnRlcm5hbHN8fChhLkludGVybmFscz17fSkpO2EuSW50ZXJuYWxzfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXshZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS5jaGFyQ29kZUF0KDApKyhhLmNoYXJDb2RlQXQoMSk8PDgpKyhhLmNoYXJDb2RlQXQoMik8PDE2KSsoYS5jaGFyQ29kZUF0KDMpPDwyNCl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmYSxhPj44JjI1NSxhPj4xNiYyNTUsYT4+MjQmMjU1KX12YXIgZT01NDIzMjc4NzYsZj0xMzEwNzIsZz01MTIsaD00LGk9NjQsaj0xMzEwNzIsaz1jKFwiRFhUMVwiKSxsPWMoXCJEWFQzXCIpLG09YyhcIkRYVDVcIiksbj0zMSxvPTAscD0xLHE9MixyPTMscz00LHQ9Nyx1PTIwLHY9MjEsdz0yMix4PTI4LHk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7fXJldHVybiBiLkdldEREU0luZm89ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IEludDMyQXJyYXkoYSwwLG4pLGM9MTtyZXR1cm4gYltxXSZmJiYoYz1NYXRoLm1heCgxLGJbdF0pKSx7d2lkdGg6YltzXSxoZWlnaHQ6YltyXSxtaXBtYXBDb3VudDpjLGlzRm91ckNDOihiW3VdJmgpPT09aCxpc1JHQjooYlt1XSZpKT09PWksaXNMdW1pbmFuY2U6KGJbdV0maik9PT1qLGlzQ3ViZTooYlt4XSZnKT09PWd9fSxiLkdldFJHQkFBcnJheUJ1ZmZlcj1mdW5jdGlvbihhLGIsYyxkLGUpe2Zvcih2YXIgZj1uZXcgVWludDhBcnJheShkKSxnPW5ldyBVaW50OEFycmF5KGUpLGg9MCxpPWItMTtpPj0wO2ktLSlmb3IodmFyIGo9MDthPmo7aisrKXt2YXIgaz1jKzQqKGoraSphKTtmW2grMl09Z1trXSxmW2grMV09Z1trKzFdLGZbaF09Z1trKzJdLGZbaCszXT1nW2srM10saCs9NH1yZXR1cm4gZn0sYi5HZXRSR0JBcnJheUJ1ZmZlcj1mdW5jdGlvbihhLGIsYyxkLGUpe2Zvcih2YXIgZj1uZXcgVWludDhBcnJheShkKSxnPW5ldyBVaW50OEFycmF5KGUpLGg9MCxpPWItMTtpPj0wO2ktLSlmb3IodmFyIGo9MDthPmo7aisrKXt2YXIgaz1jKzMqKGoraSphKTtmW2grMl09Z1trXSxmW2grMV09Z1trKzFdLGZbaF09Z1trKzJdLGgrPTN9cmV0dXJuIGZ9LGIuR2V0THVtaW5hbmNlQXJyYXlCdWZmZXI9ZnVuY3Rpb24oYSxiLGMsZCxlKXtmb3IodmFyIGY9bmV3IFVpbnQ4QXJyYXkoZCksZz1uZXcgVWludDhBcnJheShlKSxoPTAsaT1iLTE7aT49MDtpLS0pZm9yKHZhciBqPTA7YT5qO2orKyl7dmFyIGs9YysoaitpKmEpO2ZbaF09Z1trXSxoKyt9cmV0dXJuIGZ9LGIuVXBsb2FkRERTTGV2ZWxzPWZ1bmN0aW9uKGMsZyxoLGksaix1KXt2YXIgeCx5LHosQSxCLEMsRCxFLEYsRyxIPW5ldyBJbnQzMkFycmF5KGgsMCxuKTtpZihIW29dIT1lKXJldHVybiB2b2lkIGEuVG9vbHMuRXJyb3IoXCJJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyXCIpO2lmKCFpLmlzRm91ckNDJiYhaS5pc1JHQiYmIWkuaXNMdW1pbmFuY2UpcmV0dXJuIHZvaWQgYS5Ub29scy5FcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDLCBSR0Igb3IgTFVNSU5BTkNFIGNvZGVcIik7aWYoaS5pc0ZvdXJDQylzd2l0Y2goeD1IW3ZdKXtjYXNlIGs6eT04LHo9Zy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDticmVhaztjYXNlIGw6eT0xNix6PWcuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7YnJlYWs7Y2FzZSBtOnk9MTYsej1nLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOlwiLGQoeCkpfUY9MSxIW3FdJmYmJmohPT0hMSYmKEY9TWF0aC5tYXgoMSxIW3RdKSk7Zm9yKHZhciBJPUhbd10sSj0wO3U+SjtKKyspe3ZhciBLPTE9PXU/Yy5URVhUVVJFXzJEOmMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK0o7Zm9yKEE9SFtzXSxCPUhbcl0sRD1IW3BdKzQsRz0wO0Y+RzsrK0cpe2lmKGkuaXNSR0IpMjQ9PUk/KEM9QSpCKjMsRT1iLkdldFJHQkFycmF5QnVmZmVyKEEsQixELEMsaCksYy50ZXhJbWFnZTJEKEssRyxjLlJHQixBLEIsMCxjLlJHQixjLlVOU0lHTkVEX0JZVEUsRSkpOihDPUEqQio0LEU9Yi5HZXRSR0JBQXJyYXlCdWZmZXIoQSxCLEQsQyxoKSxjLnRleEltYWdlMkQoSyxHLGMuUkdCQSxBLEIsMCxjLlJHQkEsYy5VTlNJR05FRF9CWVRFLEUpKTtlbHNlIGlmKGkuaXNMdW1pbmFuY2Upe3ZhciBMPWMuZ2V0UGFyYW1ldGVyKGMuVU5QQUNLX0FMSUdOTUVOVCksTT1BLE49TWF0aC5mbG9vcigoQStMLTEpL0wpKkw7Qz1OKihCLTEpK00sRT1iLkdldEx1bWluYW5jZUFycmF5QnVmZmVyKEEsQixELEMsaCksYy50ZXhJbWFnZTJEKEssRyxjLkxVTUlOQU5DRSxBLEIsMCxjLkxVTUlOQU5DRSxjLlVOU0lHTkVEX0JZVEUsRSl9ZWxzZSBDPU1hdGgubWF4KDQsQSkvNCpNYXRoLm1heCg0LEIpLzQqeSxFPW5ldyBVaW50OEFycmF5KGgsRCxDKSxjLmNvbXByZXNzZWRUZXhJbWFnZTJEKEssRyx6LEEsQiwwLEUpO0QrPUMsQSo9LjUsQio9LjUsQT1NYXRoLm1heCgxLEEpLEI9TWF0aC5tYXgoMSxCKX19fSxifSgpO2IuRERTVG9vbHM9eX0oYS5JbnRlcm5hbHN8fChhLkludGVybmFscz17fSkpO2EuSW50ZXJuYWxzfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYil7dGhpcy5sZW5ndGg9MCx0aGlzLl9kdXBsaWNhdGVJZD0wLHRoaXMuZGF0YT1uZXcgQXJyYXkoYiksdGhpcy5faWQ9YS5fR2xvYmFsSWQrK31yZXR1cm4gYS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihhKXt0aGlzLmRhdGFbdGhpcy5sZW5ndGgrK109YSx0aGlzLmxlbmd0aD50aGlzLmRhdGEubGVuZ3RoJiYodGhpcy5kYXRhLmxlbmd0aCo9MiksYS5fX3NtYXJ0QXJyYXlGbGFnc3x8KGEuX19zbWFydEFycmF5RmxhZ3M9e30pLGEuX19zbWFydEFycmF5RmxhZ3NbdGhpcy5faWRdPXRoaXMuX2R1cGxpY2F0ZUlkfSxhLnByb3RvdHlwZS5wdXNoTm9EdXBsaWNhdGU9ZnVuY3Rpb24oYSl7YS5fX3NtYXJ0QXJyYXlGbGFncyYmYS5fX3NtYXJ0QXJyYXlGbGFnc1t0aGlzLl9pZF09PT10aGlzLl9kdXBsaWNhdGVJZHx8dGhpcy5wdXNoKGEpXG59LGEucHJvdG90eXBlLnNvcnQ9ZnVuY3Rpb24oYSl7dGhpcy5kYXRhLnNvcnQoYSl9LGEucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5sZW5ndGg9MCx0aGlzLl9kdXBsaWNhdGVJZCsrfSxhLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oYSl7aWYoMCE9PWEubGVuZ3RoKXt0aGlzLmxlbmd0aCthLmxlbmd0aD50aGlzLmRhdGEubGVuZ3RoJiYodGhpcy5kYXRhLmxlbmd0aD0yKih0aGlzLmxlbmd0aCthLmxlbmd0aCkpO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuZGF0YVt0aGlzLmxlbmd0aCsrXT0oYS5kYXRhfHxhKVtiXX19LGEucHJvdG90eXBlLmNvbmNhdFdpdGhOb0R1cGxpY2F0ZT1mdW5jdGlvbihhKXtpZigwIT09YS5sZW5ndGgpe3RoaXMubGVuZ3RoK2EubGVuZ3RoPnRoaXMuZGF0YS5sZW5ndGgmJih0aGlzLmRhdGEubGVuZ3RoPTIqKHRoaXMubGVuZ3RoK2EubGVuZ3RoKSk7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPShhLmRhdGF8fGEpW2JdO3RoaXMucHVzaE5vRHVwbGljYXRlKGMpfX19LGEucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5kYXRhLmluZGV4T2YoYSk7cmV0dXJuIGI+PXRoaXMubGVuZ3RoPy0xOmJ9LGEuX0dsb2JhbElkPTAsYX0oKTthLlNtYXJ0QXJyYXk9Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcz1bXSx0aGlzLl9waHlzaWNzTWF0ZXJpYWxzPVtdLHRoaXMudXBkYXRlQm9keVBvc2l0aW9uPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2JdO2lmKGMubWVzaD09PWF8fGMubWVzaD09PWEucGFyZW50KXt2YXIgZD1jLmJvZHkuYm9keTtyZXR1cm4gZC5wb3NpdGlvbi5zZXQoYS5wb3NpdGlvbi54LGEucG9zaXRpb24ueixhLnBvc2l0aW9uLnkpLGQucXVhdGVybmlvbi54PWEucm90YXRpb25RdWF0ZXJuaW9uLngsZC5xdWF0ZXJuaW9uLno9YS5yb3RhdGlvblF1YXRlcm5pb24ueSxkLnF1YXRlcm5pb24ueT1hLnJvdGF0aW9uUXVhdGVybmlvbi56LHZvaWQoZC5xdWF0ZXJuaW9uLnc9LWEucm90YXRpb25RdWF0ZXJuaW9uLncpfX19fXJldHVybiBiLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKGEpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBhJiYoYT0xMCksdGhpcy5fd29ybGQ9bmV3IENBTk5PTi5Xb3JsZCx0aGlzLl93b3JsZC5icm9hZHBoYXNlPW5ldyBDQU5OT04uTmFpdmVCcm9hZHBoYXNlLHRoaXMuX3dvcmxkLnNvbHZlci5pdGVyYXRpb25zPWF9LGIucHJvdG90eXBlLl9jaGVja1dpdGhFcHNpbG9uPWZ1bmN0aW9uKGIpe3JldHVybiBiPGEuUGh5c2ljc0VuZ2luZS5FcHNpbG9uP2EuUGh5c2ljc0VuZ2luZS5FcHNpbG9uOmJ9LGIucHJvdG90eXBlLnJ1bk9uZVN0ZXA9ZnVuY3Rpb24oYil7dGhpcy5fd29ybGQuc3RlcChiKTtmb3IodmFyIGM9MDtjPHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5fcmVnaXN0ZXJlZE1lc2hlc1tjXTtkLmlzQ2hpbGR8fChkLm1lc2gucG9zaXRpb24ueD1kLmJvZHkucG9zaXRpb24ueCxkLm1lc2gucG9zaXRpb24ueT1kLmJvZHkucG9zaXRpb24ueixkLm1lc2gucG9zaXRpb24uej1kLmJvZHkucG9zaXRpb24ueSxkLm1lc2gucm90YXRpb25RdWF0ZXJuaW9ufHwoZC5tZXNoLnJvdGF0aW9uUXVhdGVybmlvbj1uZXcgYS5RdWF0ZXJuaW9uKDAsMCwwLDEpKSxkLm1lc2gucm90YXRpb25RdWF0ZXJuaW9uLng9ZC5ib2R5LnF1YXRlcm5pb24ueCxkLm1lc2gucm90YXRpb25RdWF0ZXJuaW9uLnk9ZC5ib2R5LnF1YXRlcm5pb24ueixkLm1lc2gucm90YXRpb25RdWF0ZXJuaW9uLno9ZC5ib2R5LnF1YXRlcm5pb24ueSxkLm1lc2gucm90YXRpb25RdWF0ZXJuaW9uLnc9LWQuYm9keS5xdWF0ZXJuaW9uLncpfX0sYi5wcm90b3R5cGUuc2V0R3Jhdml0eT1mdW5jdGlvbihhKXt0aGlzLl93b3JsZC5ncmF2aXR5LnNldChhLngsYS56LGEueSl9LGIucHJvdG90eXBlLnJlZ2lzdGVyTWVzaD1mdW5jdGlvbihiLGMsZCl7c3dpdGNoKHRoaXMudW5yZWdpc3Rlck1lc2goYiksYi5jb21wdXRlV29ybGRNYXRyaXgoITApLGMpe2Nhc2UgYS5QaHlzaWNzRW5naW5lLlNwaGVyZUltcG9zdG9yOnZhciBlPWIuZ2V0Qm91bmRpbmdJbmZvKCkuYm91bmRpbmdCb3gsZj1lLm1heGltdW1Xb3JsZC54LWUubWluaW11bVdvcmxkLngsZz1lLm1heGltdW1Xb3JsZC55LWUubWluaW11bVdvcmxkLnksaD1lLm1heGltdW1Xb3JsZC56LWUubWluaW11bVdvcmxkLno7cmV0dXJuIHRoaXMuX2NyZWF0ZVNwaGVyZShNYXRoLm1heCh0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGYpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oZyksdGhpcy5fY2hlY2tXaXRoRXBzaWxvbihoKSkvMixiLGQpO2Nhc2UgYS5QaHlzaWNzRW5naW5lLkJveEltcG9zdG9yOmU9Yi5nZXRCb3VuZGluZ0luZm8oKS5ib3VuZGluZ0JveDt2YXIgaT1lLm1pbmltdW1Xb3JsZCxqPWUubWF4aW11bVdvcmxkLGs9ai5zdWJ0cmFjdChpKS5zY2FsZSguNSk7cmV0dXJuIHRoaXMuX2NyZWF0ZUJveCh0aGlzLl9jaGVja1dpdGhFcHNpbG9uKGsueCksdGhpcy5fY2hlY2tXaXRoRXBzaWxvbihrLnkpLHRoaXMuX2NoZWNrV2l0aEVwc2lsb24oay56KSxiLGQpO2Nhc2UgYS5QaHlzaWNzRW5naW5lLlBsYW5lSW1wb3N0b3I6cmV0dXJuIHRoaXMuX2NyZWF0ZVBsYW5lKGIsZCk7Y2FzZSBhLlBoeXNpY3NFbmdpbmUuTWVzaEltcG9zdG9yOnZhciBsPWIuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCksbT1iLmdldEluZGljZXMoKTtyZXR1cm4gdGhpcy5fY3JlYXRlQ29udmV4UG9seWhlZHJvbihsLG0sYixkKX1yZXR1cm4gbnVsbH0sYi5wcm90b3R5cGUuX2NyZWF0ZVNwaGVyZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9bmV3IENBTk5PTi5TcGhlcmUoYSk7cmV0dXJuIGM/dGhpcy5fY3JlYXRlUmlnaWRCb2R5RnJvbVNoYXBlKGQsYixjLm1hc3MsYy5mcmljdGlvbixjLnJlc3RpdHV0aW9uKTpkfSxiLnByb3RvdHlwZS5fY3JlYXRlQm94PWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9bmV3IENBTk5PTi5Cb3gobmV3IENBTk5PTi5WZWMzKGEsYyxiKSk7cmV0dXJuIGU/dGhpcy5fY3JlYXRlUmlnaWRCb2R5RnJvbVNoYXBlKGYsZCxlLm1hc3MsZS5mcmljdGlvbixlLnJlc3RpdHV0aW9uKTpmfSxiLnByb3RvdHlwZS5fY3JlYXRlUGxhbmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgQ0FOTk9OLlBsYW5lO3JldHVybiBiP3RoaXMuX2NyZWF0ZVJpZ2lkQm9keUZyb21TaGFwZShjLGEsYi5tYXNzLGIuZnJpY3Rpb24sYi5yZXN0aXR1dGlvbik6Y30sYi5wcm90b3R5cGUuX2NyZWF0ZUNvbnZleFBvbHloZWRyb249ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9W10sZz1bXTtkLmNvbXB1dGVXb3JsZE1hdHJpeCghMCk7Zm9yKHZhciBoPTA7aDxiLmxlbmd0aDtoKz0zKXt2YXIgaT1hLlZlY3RvcjMuWmVybygpO2EuVmVjdG9yMy5UcmFuc2Zvcm1Ob3JtYWxGcm9tRmxvYXRzVG9SZWYoYltoXSxiW2grMV0sYltoKzJdLGQuZ2V0V29ybGRNYXRyaXgoKSxpKSxmLnB1c2gobmV3IENBTk5PTi5WZWMzKGkueCxpLnosaS55KSl9Zm9yKHZhciBqPTA7ajxjLmxlbmd0aDtqKz0zKWcucHVzaChbY1tqXSxjW2orMl0sY1tqKzFdXSk7dmFyIGs9bmV3IENBTk5PTi5Db252ZXhQb2x5aGVkcm9uKGYsZyk7cmV0dXJuIGU/dGhpcy5fY3JlYXRlUmlnaWRCb2R5RnJvbVNoYXBlKGssZCxlLm1hc3MsZS5mcmljdGlvbixlLnJlc3RpdHV0aW9uKTprfSxiLnByb3RvdHlwZS5fYWRkTWF0ZXJpYWw9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkO2ZvcihjPTA7Yzx0aGlzLl9waHlzaWNzTWF0ZXJpYWxzLmxlbmd0aDtjKyspaWYoZD10aGlzLl9waHlzaWNzTWF0ZXJpYWxzW2NdLGQuZnJpY3Rpb249PT1hJiZkLnJlc3RpdHV0aW9uPT09YilyZXR1cm4gZDt2YXIgZT1uZXcgQ0FOTk9OLk1hdGVyaWFsO2ZvcihlLmZyaWN0aW9uPWEsZS5yZXN0aXR1dGlvbj1iLHRoaXMuX3BoeXNpY3NNYXRlcmlhbHMucHVzaChlKSxjPTA7Yzx0aGlzLl9waHlzaWNzTWF0ZXJpYWxzLmxlbmd0aDtjKyspe2Q9dGhpcy5fcGh5c2ljc01hdGVyaWFsc1tjXTt2YXIgZj1uZXcgQ0FOTk9OLkNvbnRhY3RNYXRlcmlhbChkLGUsZC5mcmljdGlvbiplLmZyaWN0aW9uLGQucmVzdGl0dXRpb24qZS5yZXN0aXR1dGlvbik7Zi5jb250YWN0RXF1YXRpb25TdGlmZm5lc3M9MWUxMCxmLmNvbnRhY3RFcXVhdGlvblJlZ3VsYXJpemF0aW9uVGltZT0xMCx0aGlzLl93b3JsZC5hZGRDb250YWN0TWF0ZXJpYWwoZil9cmV0dXJuIGV9LGIucHJvdG90eXBlLl9jcmVhdGVSaWdpZEJvZHlGcm9tU2hhcGU9ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1udWxsO2Mucm90YXRpb25RdWF0ZXJuaW9uJiYoZz1jLnJvdGF0aW9uUXVhdGVybmlvbi5jbG9uZSgpLGMucm90YXRpb25RdWF0ZXJuaW9uPW5ldyBhLlF1YXRlcm5pb24oMCwwLDAsMSkpO3ZhciBoPXRoaXMuX2FkZE1hdGVyaWFsKGUsZiksaT1uZXcgQ0FOTk9OLlJpZ2lkQm9keShkLGIsaCk7cmV0dXJuIGcmJihpLnF1YXRlcm5pb24ueD1nLngsaS5xdWF0ZXJuaW9uLno9Zy55LGkucXVhdGVybmlvbi55PWcueixpLnF1YXRlcm5pb24udz0tZy53KSxpLnBvc2l0aW9uLnNldChjLnBvc2l0aW9uLngsYy5wb3NpdGlvbi56LGMucG9zaXRpb24ueSksdGhpcy5fd29ybGQuYWRkKGkpLHRoaXMuX3JlZ2lzdGVyZWRNZXNoZXMucHVzaCh7bWVzaDpjLGJvZHk6aSxtYXRlcmlhbDpofSksaX0sYi5wcm90b3R5cGUucmVnaXN0ZXJNZXNoZXNBc0NvbXBvdW5kPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBDQU5OT04uQ29tcG91bmQsZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgZT1hW2RdLm1lc2gsZj10aGlzLnJlZ2lzdGVyTWVzaChlLGFbZF0uaW1wb3N0b3IpOzA9PWQ/Yy5hZGRDaGlsZChmLG5ldyBDQU5OT04uVmVjMygwLDAsMCkpOmMuYWRkQ2hpbGQoZixuZXcgQ0FOTk9OLlZlYzMoZS5wb3NpdGlvbi54LGUucG9zaXRpb24ueixlLnBvc2l0aW9uLnkpKX12YXIgZz1hWzBdLm1lc2gsaD10aGlzLl9jcmVhdGVSaWdpZEJvZHlGcm9tU2hhcGUoYyxnLGIubWFzcyxiLmZyaWN0aW9uLGIucmVzdGl0dXRpb24pO3JldHVybiBoLnBhcnRzPWEsaH0sYi5wcm90b3R5cGUuX3VuYmluZEJvZHk9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX3JlZ2lzdGVyZWRNZXNoZXNbYl07Yy5ib2R5PT09YSYmKGMuYm9keT1udWxsKX19LGIucHJvdG90eXBlLnVucmVnaXN0ZXJNZXNoPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2JdO2lmKGMubWVzaD09PWEpcmV0dXJuIGMuYm9keSYmKHRoaXMuX3dvcmxkLnJlbW92ZShjLmJvZHkpLHRoaXMuX3VuYmluZEJvZHkoYy5ib2R5KSksdm9pZCB0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLnNwbGljZShiLDEpfX0sYi5wcm90b3R5cGUuYXBwbHlJbXB1bHNlPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9bmV3IENBTk5PTi5WZWMzKGMueCxjLnosYy55KSxlPW5ldyBDQU5OT04uVmVjMyhiLngsYi56LGIueSksZj0wO2Y8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7ZisrKXt2YXIgZz10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2ZdO2lmKGcubWVzaD09PWEpcmV0dXJuIHZvaWQgZy5ib2R5LmFwcGx5SW1wdWxzZShlLGQpfX0sYi5wcm90b3R5cGUuY3JlYXRlTGluaz1mdW5jdGlvbihhLGIsYyxkKXtmb3IodmFyIGU9bnVsbCxmPW51bGwsZz0wO2c8dGhpcy5fcmVnaXN0ZXJlZE1lc2hlcy5sZW5ndGg7ZysrKXt2YXIgaD10aGlzLl9yZWdpc3RlcmVkTWVzaGVzW2ddO2gubWVzaD09PWE/ZT1oLmJvZHk6aC5tZXNoPT09YiYmKGY9aC5ib2R5KX1pZighZXx8IWYpcmV0dXJuITE7dmFyIGk9bmV3IENBTk5PTi5Qb2ludFRvUG9pbnRDb25zdHJhaW50KGUsbmV3IENBTk5PTi5WZWMzKGMueCxjLnosYy55KSxmLG5ldyBDQU5OT04uVmVjMyhkLngsZC56LGQueSkpO3JldHVybiB0aGlzLl93b3JsZC5hZGRDb25zdHJhaW50KGkpLCEwfSxiLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKDt0aGlzLl9yZWdpc3RlcmVkTWVzaGVzLmxlbmd0aDspdGhpcy51bnJlZ2lzdGVyTWVzaCh0aGlzLl9yZWdpc3RlcmVkTWVzaGVzWzBdLm1lc2gpfSxiLnByb3RvdHlwZS5pc1N1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT13aW5kb3cuQ0FOTk9OfSxifSgpO2EuQ2Fubm9uSlNQbHVnaW49Yn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzLl9hY3Rpb25NYW5hZ2VyPWF9cmV0dXJuIGEucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sYS5wcm90b3R5cGUuX2dldFByb3BlcnR5PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9hY3Rpb25NYW5hZ2VyLl9nZXRQcm9wZXJ0eShhKX0sYS5wcm90b3R5cGUuX2dldEVmZmVjdGl2ZVRhcmdldD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9hY3Rpb25NYW5hZ2VyLl9nZXRFZmZlY3RpdmVUYXJnZXQoYSxiKX0sYX0oKTthLkNvbmRpdGlvbj1iO3ZhciBjPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYyxkLGUsZixnKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZyYmKGc9Yi5Jc0VxdWFsKSxhLmNhbGwodGhpcyxjKSx0aGlzLnByb3BlcnR5UGF0aD1lLHRoaXMudmFsdWU9Zix0aGlzLm9wZXJhdG9yPWcsdGhpcy5fdGFyZ2V0PXRoaXMuX2dldEVmZmVjdGl2ZVRhcmdldChkLHRoaXMucHJvcGVydHlQYXRoKSx0aGlzLl9wcm9wZXJ0eT10aGlzLl9nZXRQcm9wZXJ0eSh0aGlzLnByb3BlcnR5UGF0aCl9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiSXNFcXVhbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fSXNFcXVhbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIklzRGlmZmVyZW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9Jc0RpZmZlcmVudH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIklzR3JlYXRlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fSXNHcmVhdGVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiSXNMZXNzZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX0lzTGVzc2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5vcGVyYXRvcil7Y2FzZSBiLklzR3JlYXRlcjpyZXR1cm4gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XT50aGlzLnZhbHVlO2Nhc2UgYi5Jc0xlc3NlcjpyZXR1cm4gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XTx0aGlzLnZhbHVlO2Nhc2UgYi5Jc0VxdWFsOmNhc2UgYi5Jc0RpZmZlcmVudDp2YXIgYTtyZXR1cm4gYT10aGlzLnZhbHVlLmVxdWFscz90aGlzLnZhbHVlLmVxdWFscyh0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldKTp0aGlzLnZhbHVlPT09dGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XSx0aGlzLm9wZXJhdG9yPT09Yi5Jc0VxdWFsP2E6IWF9cmV0dXJuITF9LGIuX0lzRXF1YWw9MCxiLl9Jc0RpZmZlcmVudD0xLGIuX0lzR3JlYXRlcj0yLGIuX0lzTGVzc2VyPTMsYn0oYik7YS5WYWx1ZUNvbmRpdGlvbj1jO3ZhciBkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjKXthLmNhbGwodGhpcyxiKSx0aGlzLnByZWRpY2F0ZT1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJlZGljYXRlKCl9LGJ9KGIpO2EuUHJlZGljYXRlQ29uZGl0aW9uPWQ7dmFyIGU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCl7YS5jYWxsKHRoaXMsYiksdGhpcy52YWx1ZT1kLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RhcmdldC5zdGF0ZT09PXRoaXMudmFsdWV9LGJ9KGIpO2EuU3RhdGVDb25kaXRpb249ZX0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7dGhpcy50cmlnZ2VyT3B0aW9ucz1hLGEucGFyYW1ldGVyPyh0aGlzLnRyaWdnZXI9YS50cmlnZ2VyLHRoaXMuX3RyaWdnZXJQYXJhbWV0ZXI9YS5wYXJhbWV0ZXIpOnRoaXMudHJpZ2dlcj1hLHRoaXMuX25leHRBY3RpdmVBY3Rpb249dGhpcyx0aGlzLl9jb25kaXRpb249Yn1yZXR1cm4gYS5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLmdldFRyaWdnZXJQYXJhbWV0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHJpZ2dlclBhcmFtZXRlcn0sYS5wcm90b3R5cGUuX2V4ZWN1dGVDdXJyZW50PWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2NvbmRpdGlvbil7dmFyIGI9dGhpcy5fYWN0aW9uTWFuYWdlci5nZXRTY2VuZSgpLmdldFJlbmRlcklkKCk7aWYodGhpcy5fY29uZGl0aW9uLl9ldmFsdWF0aW9uSWQ9PT1iKXtpZighdGhpcy5fY29uZGl0aW9uLl9jdXJyZW50UmVzdWx0KXJldHVybn1lbHNle2lmKHRoaXMuX2NvbmRpdGlvbi5fZXZhbHVhdGlvbklkPWIsIXRoaXMuX2NvbmRpdGlvbi5pc1ZhbGlkKCkpcmV0dXJuIHZvaWQodGhpcy5fY29uZGl0aW9uLl9jdXJyZW50UmVzdWx0PSExKTt0aGlzLl9jb25kaXRpb24uX2N1cnJlbnRSZXN1bHQ9ITB9fXRoaXMuX25leHRBY3RpdmVBY3Rpb24uZXhlY3V0ZShhKSx0aGlzLl9uZXh0QWN0aXZlQWN0aW9uPXRoaXMuX25leHRBY3RpdmVBY3Rpb24uX2NoaWxkP3RoaXMuX25leHRBY3RpdmVBY3Rpb24uX2NoaWxkOnRoaXN9LGEucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXt9LGEucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2NoaWxkPWEsYS5fYWN0aW9uTWFuYWdlcj10aGlzLl9hY3Rpb25NYW5hZ2VyLGEuX3ByZXBhcmUoKSxhfSxhLnByb3RvdHlwZS5fZ2V0UHJvcGVydHk9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2FjdGlvbk1hbmFnZXIuX2dldFByb3BlcnR5KGEpfSxhLnByb3RvdHlwZS5fZ2V0RWZmZWN0aXZlVGFyZ2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2FjdGlvbk1hbmFnZXIuX2dldEVmZmVjdGl2ZVRhcmdldChhLGIpfSxhfSgpO2EuQWN0aW9uPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIsYyxkLGUpe3RoaXMuc291cmNlPWEsdGhpcy5wb2ludGVyWD1iLHRoaXMucG9pbnRlclk9Yyx0aGlzLm1lc2hVbmRlclBvaW50ZXI9ZCx0aGlzLnNvdXJjZUV2ZW50PWV9cmV0dXJuIGEuQ3JlYXRlTmV3PWZ1bmN0aW9uKGIpe3ZhciBjPWIuZ2V0U2NlbmUoKTtyZXR1cm4gbmV3IGEoYixjLnBvaW50ZXJYLGMucG9pbnRlclksYy5tZXNoVW5kZXJQb2ludGVyKX0sYS5DcmVhdGVOZXdGcm9tU2NlbmU9ZnVuY3Rpb24oYixjKXtyZXR1cm4gbmV3IGEobnVsbCxiLnBvaW50ZXJYLGIucG9pbnRlclksYi5tZXNoVW5kZXJQb2ludGVyLGMpfSxhfSgpO2EuQWN0aW9uRXZlbnQ9Yjt2YXIgYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7dGhpcy5hY3Rpb25zPW5ldyBBcnJheSx0aGlzLl9zY2VuZT1hLGEuX2FjdGlvbk1hbmFnZXJzLnB1c2godGhpcyl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiTm90aGluZ1RyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX05vdGhpbmdUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25QaWNrVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25QaWNrVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uTGVmdFBpY2tUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PbkxlZnRQaWNrVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uUmlnaHRQaWNrVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25SaWdodFBpY2tUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25DZW50ZXJQaWNrVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25DZW50ZXJQaWNrVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uUG9pbnRlck92ZXJUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PblBvaW50ZXJPdmVyVHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uUG9pbnRlck91dFRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uUG9pbnRlck91dFRyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPbkV2ZXJ5RnJhbWVUcmlnZ2VyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiLl9PbkV2ZXJ5RnJhbWVUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25JbnRlcnNlY3Rpb25FbnRlclRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uSW50ZXJzZWN0aW9uRW50ZXJUcmlnZ2VyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25JbnRlcnNlY3Rpb25FeGl0VHJpZ2dlcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIk9uS2V5RG93blRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGIuX09uS2V5RG93blRyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJPbktleVVwVHJpZ2dlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5fT25LZXlVcFRyaWdnZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX3NjZW5lLl9hY3Rpb25NYW5hZ2Vycy5pbmRleE9mKHRoaXMpO2E+LTEmJnRoaXMuX3NjZW5lLl9hY3Rpb25NYW5hZ2Vycy5zcGxpY2UoYSwxKX0sYi5wcm90b3R5cGUuZ2V0U2NlbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NlbmV9LGIucHJvdG90eXBlLmhhc1NwZWNpZmljVHJpZ2dlcnM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmFjdGlvbnMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5hY3Rpb25zW2JdO2lmKGEuaW5kZXhPZihjLnRyaWdnZXIpPi0xKXJldHVybiEwfXJldHVybiExfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJoYXNQb2ludGVyVHJpZ2dlcnNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLmFjdGlvbnMubGVuZ3RoO2ErKyl7dmFyIGM9dGhpcy5hY3Rpb25zW2FdO2lmKGMudHJpZ2dlcj49Yi5fT25QaWNrVHJpZ2dlciYmYy50cmlnZ2VyPD1iLl9PblBvaW50ZXJPdXRUcmlnZ2VyKXJldHVybiEwfXJldHVybiExfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImhhc1BpY2tUcmlnZ2Vyc1wiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuYWN0aW9ucy5sZW5ndGg7YSsrKXt2YXIgYz10aGlzLmFjdGlvbnNbYV07aWYoYy50cmlnZ2VyPj1iLl9PblBpY2tUcmlnZ2VyJiZjLnRyaWdnZXI8PWIuX09uQ2VudGVyUGlja1RyaWdnZXIpcmV0dXJuITB9cmV0dXJuITF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYi5wcm90b3R5cGUucmVnaXN0ZXJBY3Rpb249ZnVuY3Rpb24oYyl7cmV0dXJuIGMudHJpZ2dlcj09PWIuT25FdmVyeUZyYW1lVHJpZ2dlciYmdGhpcy5nZXRTY2VuZSgpLmFjdGlvbk1hbmFnZXIhPT10aGlzPyhhLlRvb2xzLldhcm4oXCJPbkV2ZXJ5RnJhbWVUcmlnZ2VyIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzY2VuZS5hY3Rpb25NYW5hZ2VyXCIpLG51bGwpOih0aGlzLmFjdGlvbnMucHVzaChjKSxjLl9hY3Rpb25NYW5hZ2VyPXRoaXMsYy5fcHJlcGFyZSgpLGMpfSxiLnByb3RvdHlwZS5wcm9jZXNzVHJpZ2dlcj1mdW5jdGlvbihhLGMpe2Zvcih2YXIgZD0wO2Q8dGhpcy5hY3Rpb25zLmxlbmd0aDtkKyspe3ZhciBlPXRoaXMuYWN0aW9uc1tkXTtpZihlLnRyaWdnZXI9PT1hKXtpZihhPT1iLk9uS2V5VXBUcmlnZ2VyfHxhPT1iLk9uS2V5RG93blRyaWdnZXIpe3ZhciBmPWUuZ2V0VHJpZ2dlclBhcmFtZXRlcigpO2lmKGYmJmMuc291cmNlRXZlbnQua2V5IT09Ziljb250aW51ZX1lLl9leGVjdXRlQ3VycmVudChjKX19fSxiLnByb3RvdHlwZS5fZ2V0RWZmZWN0aXZlVGFyZ2V0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWIuc3BsaXQoXCIuXCIpLGQ9MDtkPGMubGVuZ3RoLTE7ZCsrKWE9YVtjW2RdXTtyZXR1cm4gYX0sYi5wcm90b3R5cGUuX2dldFByb3BlcnR5PWZ1bmN0aW9uKGEpe3ZhciBiPWEuc3BsaXQoXCIuXCIpO3JldHVybiBiW2IubGVuZ3RoLTFdfSxiLl9Ob3RoaW5nVHJpZ2dlcj0wLGIuX09uUGlja1RyaWdnZXI9MSxiLl9PbkxlZnRQaWNrVHJpZ2dlcj0yLGIuX09uUmlnaHRQaWNrVHJpZ2dlcj0zLGIuX09uQ2VudGVyUGlja1RyaWdnZXI9NCxiLl9PblBvaW50ZXJPdmVyVHJpZ2dlcj01LGIuX09uUG9pbnRlck91dFRyaWdnZXI9NixiLl9PbkV2ZXJ5RnJhbWVUcmlnZ2VyPTcsYi5fT25JbnRlcnNlY3Rpb25FbnRlclRyaWdnZXI9OCxiLl9PbkludGVyc2VjdGlvbkV4aXRUcmlnZ2VyPTksYi5fT25LZXlEb3duVHJpZ2dlcj0xMCxiLl9PbktleVVwVHJpZ2dlcj0xMSxifSgpO2EuQWN0aW9uTWFuYWdlcj1jfShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYsZyxoKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZiYmKGY9MWUzKSxiLmNhbGwodGhpcyxhLGcpLHRoaXMucHJvcGVydHlQYXRoPWQsdGhpcy52YWx1ZT1lLHRoaXMuZHVyYXRpb249Zix0aGlzLnN0b3BPdGhlckFuaW1hdGlvbnM9aCx0aGlzLl90YXJnZXQ9Y31yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXQ9dGhpcy5fZ2V0RWZmZWN0aXZlVGFyZ2V0KHRoaXMuX3RhcmdldCx0aGlzLnByb3BlcnR5UGF0aCksdGhpcy5fcHJvcGVydHk9dGhpcy5fZ2V0UHJvcGVydHkodGhpcy5wcm9wZXJ0eVBhdGgpfSxjLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dmFyIGIsYz10aGlzLl9hY3Rpb25NYW5hZ2VyLmdldFNjZW5lKCksZD1be2ZyYW1lOjAsdmFsdWU6dGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BlcnR5XX0se2ZyYW1lOjEwMCx2YWx1ZTp0aGlzLnZhbHVlfV07aWYoXCJudW1iZXJcIj09dHlwZW9mIHRoaXMudmFsdWUpYj1hLkFuaW1hdGlvbi5BTklNQVRJT05UWVBFX0ZMT0FUO2Vsc2UgaWYodGhpcy52YWx1ZSBpbnN0YW5jZW9mIGEuQ29sb3IzKWI9YS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9DT0xPUjM7ZWxzZSBpZih0aGlzLnZhbHVlIGluc3RhbmNlb2YgYS5WZWN0b3IzKWI9YS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9WRUNUT1IzO2Vsc2UgaWYodGhpcy52YWx1ZSBpbnN0YW5jZW9mIGEuTWF0cml4KWI9YS5BbmltYXRpb24uQU5JTUFUSU9OVFlQRV9NQVRSSVg7ZWxzZXtpZighKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBhLlF1YXRlcm5pb24pKXJldHVybiB2b2lkIGEuVG9vbHMuV2FybihcIkludGVycG9sYXRlVmFsdWVBY3Rpb246IFVuc3VwcG9ydGVkIHR5cGUgKFwiK3R5cGVvZiB0aGlzLnZhbHVlK1wiKVwiKTtiPWEuQW5pbWF0aW9uLkFOSU1BVElPTlRZUEVfUVVBVEVSTklPTn12YXIgZT1uZXcgYS5BbmltYXRpb24oXCJJbnRlcnBvbGF0ZVZhbHVlQWN0aW9uXCIsdGhpcy5fcHJvcGVydHksMTAwKigxZTMvdGhpcy5kdXJhdGlvbiksYixhLkFuaW1hdGlvbi5BTklNQVRJT05MT09QTU9ERV9DT05TVEFOVCk7ZS5zZXRLZXlzKGQpLHRoaXMuc3RvcE90aGVyQW5pbWF0aW9ucyYmYy5zdG9wQW5pbWF0aW9uKHRoaXMuX3RhcmdldCksYy5iZWdpbkRpcmVjdEFuaW1hdGlvbih0aGlzLl90YXJnZXQsW2VdLDAsMTAwKX0sY30oYS5BY3Rpb24pO2EuSW50ZXJwb2xhdGVWYWx1ZUFjdGlvbj1ifShCQUJZTE9OfHwoQkFCWUxPTj17fSkpO3ZhciBfX2V4dGVuZHM9dGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe3RoaXMuY29uc3RydWN0b3I9YX1mb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYVtkXT1iW2RdKTtjLnByb3RvdHlwZT1iLnByb3RvdHlwZSxhLnByb3RvdHlwZT1uZXcgY30sQkFCWUxPTjshZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlKXthLmNhbGwodGhpcyxiLGUpLHRoaXMucHJvcGVydHlQYXRoPWQsdGhpcy5fdGFyZ2V0PWN9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0PXRoaXMuX2dldEVmZmVjdGl2ZVRhcmdldCh0aGlzLl90YXJnZXQsdGhpcy5wcm9wZXJ0eVBhdGgpLHRoaXMuX3Byb3BlcnR5PXRoaXMuX2dldFByb3BlcnR5KHRoaXMucHJvcGVydHlQYXRoKX0sYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV09IXRoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV19LGJ9KGEuQWN0aW9uKTthLlN3aXRjaEJvb2xlYW5BY3Rpb249Yjt2YXIgYz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUpe2EuY2FsbCh0aGlzLGIsZSksdGhpcy52YWx1ZT1kLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0LnN0YXRlPXRoaXMudmFsdWV9LGJ9KGEuQWN0aW9uKTthLlNldFN0YXRlQWN0aW9uPWM7dmFyIGQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYpe2EuY2FsbCh0aGlzLGIsZiksdGhpcy5wcm9wZXJ0eVBhdGg9ZCx0aGlzLnZhbHVlPWUsdGhpcy5fdGFyZ2V0PWN9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dGhpcy5fdGFyZ2V0PXRoaXMuX2dldEVmZmVjdGl2ZVRhcmdldCh0aGlzLl90YXJnZXQsdGhpcy5wcm9wZXJ0eVBhdGgpLHRoaXMuX3Byb3BlcnR5PXRoaXMuX2dldFByb3BlcnR5KHRoaXMucHJvcGVydHlQYXRoKX0sYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV09dGhpcy52YWx1ZX0sYn0oYS5BY3Rpb24pO2EuU2V0VmFsdWVBY3Rpb249ZDt2YXIgZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZil7Yi5jYWxsKHRoaXMsYSxmKSx0aGlzLnByb3BlcnR5UGF0aD1kLHRoaXMudmFsdWU9ZSx0aGlzLl90YXJnZXQ9Y31yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXQ9dGhpcy5fZ2V0RWZmZWN0aXZlVGFyZ2V0KHRoaXMuX3RhcmdldCx0aGlzLnByb3BlcnR5UGF0aCksdGhpcy5fcHJvcGVydHk9dGhpcy5fZ2V0UHJvcGVydHkodGhpcy5wcm9wZXJ0eVBhdGgpLFwibnVtYmVyXCIhPXR5cGVvZiB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcGVydHldJiZhLlRvb2xzLldhcm4oXCJXYXJuaW5nOiBJbmNyZW1lbnRWYWx1ZUFjdGlvbiBjYW4gb25seSBiZSB1c2VkIHdpdGggbnVtYmVyIHZhbHVlc1wiKX0sYy5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFt0aGlzLl9wcm9wZXJ0eV0rPXRoaXMudmFsdWV9LGN9KGEuQWN0aW9uKTthLkluY3JlbWVudFZhbHVlQWN0aW9uPWU7dmFyIGY9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiLGMsZCxlLGYsZyl7YS5jYWxsKHRoaXMsYixnKSx0aGlzLmZyb209ZCx0aGlzLnRvPWUsdGhpcy5sb29wPWYsdGhpcy5fdGFyZ2V0PWN9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7fSxiLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fYWN0aW9uTWFuYWdlci5nZXRTY2VuZSgpO2EuYmVnaW5BbmltYXRpb24odGhpcy5fdGFyZ2V0LHRoaXMuZnJvbSx0aGlzLnRvLHRoaXMubG9vcCl9LGJ9KGEuQWN0aW9uKTthLlBsYXlBbmltYXRpb25BY3Rpb249Zjt2YXIgZz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkKXthLmNhbGwodGhpcyxiLGQpLHRoaXMuX3RhcmdldD1jfXJldHVybiBfX2V4dGVuZHMoYixhKSxiLnByb3RvdHlwZS5fcHJlcGFyZT1mdW5jdGlvbigpe30sYi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX2FjdGlvbk1hbmFnZXIuZ2V0U2NlbmUoKTthLnN0b3BBbmltYXRpb24odGhpcy5fdGFyZ2V0KX0sYn0oYS5BY3Rpb24pO2EuU3RvcEFuaW1hdGlvbkFjdGlvbj1nO3ZhciBoPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgYyYmKGM9YS5BY3Rpb25NYW5hZ2VyLk5vdGhpbmdUcmlnZ2VyKSxiLmNhbGwodGhpcyxjLGQpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7fSxjfShhLkFjdGlvbik7YS5Eb05vdGhpbmdBY3Rpb249aDt2YXIgaT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkKXthLmNhbGwodGhpcyxiLGQpLHRoaXMuY2hpbGRyZW49Y31yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuY2hpbGRyZW4ubGVuZ3RoO2ErKyl0aGlzLmNoaWxkcmVuW2FdLl9hY3Rpb25NYW5hZ2VyPXRoaXMuX2FjdGlvbk1hbmFnZXIsdGhpcy5jaGlsZHJlblthXS5fcHJlcGFyZSgpfSxiLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8dGhpcy5jaGlsZHJlbi5sZW5ndGg7YisrKXRoaXMuY2hpbGRyZW5bYl0uZXhlY3V0ZShhKX0sYn0oYS5BY3Rpb24pO2EuQ29tYmluZUFjdGlvbj1pO3ZhciBqPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYixjLGQpe2EuY2FsbCh0aGlzLGIsZCksdGhpcy5mdW5jPWN9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oYSl7dGhpcy5mdW5jKGEpfSxifShhLkFjdGlvbik7YS5FeGVjdXRlQ29kZUFjdGlvbj1qO3ZhciBrPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSl7Yi5jYWxsKHRoaXMsYSxlKSx0aGlzLl90YXJnZXQ9Yyx0aGlzLl9wYXJlbnQ9ZH1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3ByZXBhcmU9ZnVuY3Rpb24oKXt9LGMucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtpZih0aGlzLl90YXJnZXQucGFyZW50IT09dGhpcy5fcGFyZW50KXt2YXIgYj10aGlzLl9wYXJlbnQuZ2V0V29ybGRNYXRyaXgoKS5jbG9uZSgpO2IuaW52ZXJ0KCksdGhpcy5fdGFyZ2V0LnBvc2l0aW9uPWEuVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyh0aGlzLl90YXJnZXQucG9zaXRpb24sYiksdGhpcy5fdGFyZ2V0LnBhcmVudD10aGlzLl9wYXJlbnR9fSxjfShhLkFjdGlvbik7YS5TZXRQYXJlbnRBY3Rpb249a30oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCxlLGYpe3RoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9ORSx0aGlzLl90b3RhbFZlcnRpY2VzPTAsdGhpcy5faW5kaWNlcz1bXSx0aGlzLmlkPWIsdGhpcy5fZW5naW5lPWMuZ2V0RW5naW5lKCksdGhpcy5fbWVzaGVzPVtdLHRoaXMuX3NjZW5lPWMsZD90aGlzLnNldEFsbFZlcnRpY2VzRGF0YShkLGUpOih0aGlzLl90b3RhbFZlcnRpY2VzPTAsdGhpcy5faW5kaWNlcz1bXSksZiYmdGhpcy5hcHBseVRvTWVzaChmKX1yZXR1cm4gYi5wcm90b3R5cGUuZ2V0U2NlbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NlbmV9LGIucHJvdG90eXBlLmdldEVuZ2luZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmdpbmV9LGIucHJvdG90eXBlLmlzUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURFRHx8dGhpcy5kZWxheUxvYWRTdGF0ZT09PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX05PTkV9LGIucHJvdG90eXBlLnNldEFsbFZlcnRpY2VzRGF0YT1mdW5jdGlvbihhLGIpe2EuYXBwbHlUb0dlb21ldHJ5KHRoaXMsYil9LGIucHJvdG90eXBlLnNldFZlcnRpY2VzRGF0YT1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5fdmVydGV4QnVmZmVycz10aGlzLl92ZXJ0ZXhCdWZmZXJzfHx7fSx0aGlzLl92ZXJ0ZXhCdWZmZXJzW2JdJiZ0aGlzLl92ZXJ0ZXhCdWZmZXJzW2JdLmRpc3Bvc2UoKSx0aGlzLl92ZXJ0ZXhCdWZmZXJzW2JdPW5ldyBhLlZlcnRleEJ1ZmZlcih0aGlzLl9lbmdpbmUsYyxiLGQsMD09PXRoaXMuX21lc2hlcy5sZW5ndGgpLGI9PT1hLlZlcnRleEJ1ZmZlci5Qb3NpdGlvbktpbmQpe3ZhciBlPXRoaXMuX3ZlcnRleEJ1ZmZlcnNbYl0uZ2V0U3RyaWRlU2l6ZSgpO3RoaXMuX3RvdGFsVmVydGljZXM9Yy5sZW5ndGgvZTtmb3IodmFyIGY9YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KGMsMCx0aGlzLl90b3RhbFZlcnRpY2VzKSxnPXRoaXMuX21lc2hlcyxoPWcubGVuZ3RoLGk9MDtoPmk7aSsrKXt2YXIgaj1nW2ldO2ouX3Jlc2V0UG9pbnRzQXJyYXlDYWNoZSgpLGouX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oZi5taW5pbXVtLGYubWF4aW11bSksai5fY3JlYXRlR2xvYmFsU3ViTWVzaCgpLGouY29tcHV0ZVdvcmxkTWF0cml4KCEwKX19fSxiLnByb3RvdHlwZS51cGRhdGVWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYixjLGQpe3ZhciBlPXRoaXMuZ2V0VmVydGV4QnVmZmVyKGIpO2lmKGUmJihlLnVwZGF0ZShjKSxiPT09YS5WZXJ0ZXhCdWZmZXIuUG9zaXRpb25LaW5kKSl7dmFyIGY7aWYoZCl7dmFyIGc9ZS5nZXRTdHJpZGVTaXplKCk7dGhpcy5fdG90YWxWZXJ0aWNlcz1jLmxlbmd0aC9nLGY9YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KGMsMCx0aGlzLl90b3RhbFZlcnRpY2VzKX1mb3IodmFyIGg9dGhpcy5fbWVzaGVzLGk9aC5sZW5ndGgsaj0wO2k+ajtqKyspe3ZhciBrPWhbal07ay5fcmVzZXRQb2ludHNBcnJheUNhY2hlKCksZCYmKGsuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oZi5taW5pbXVtLGYubWF4aW11bSkpfX19LGIucHJvdG90eXBlLmdldFRvdGFsVmVydGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5fdG90YWxWZXJ0aWNlczowfSxiLnByb3RvdHlwZS5nZXRWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRWZXJ0ZXhCdWZmZXIoYSk7cmV0dXJuIGI/Yi5nZXREYXRhKCk6bnVsbH0sYi5wcm90b3R5cGUuZ2V0VmVydGV4QnVmZmVyPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzUmVhZHkoKT90aGlzLl92ZXJ0ZXhCdWZmZXJzW2FdOm51bGx9LGIucHJvdG90eXBlLmdldFZlcnRleEJ1ZmZlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5fdmVydGV4QnVmZmVyczpudWxsfSxiLnByb3RvdHlwZS5pc1ZlcnRpY2VzRGF0YVByZXNlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlcnM/dm9pZCAwIT09dGhpcy5fdmVydGV4QnVmZmVyc1thXTp0aGlzLl9kZWxheUluZm8/LTEhPT10aGlzLl9kZWxheUluZm8uaW5kZXhPZihhKTohMX0sYi5wcm90b3R5cGUuZ2V0VmVydGljZXNEYXRhS2luZHM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtpZighdGhpcy5fdmVydGV4QnVmZmVycyYmdGhpcy5fZGVsYXlJbmZvKWZvcih2YXIgYiBpbiB0aGlzLl9kZWxheUluZm8pYS5wdXNoKGIpO2Vsc2UgZm9yKGIgaW4gdGhpcy5fdmVydGV4QnVmZmVycylhLnB1c2goYik7cmV0dXJuIGF9LGIucHJvdG90eXBlLnNldEluZGljZXM9ZnVuY3Rpb24oYSl7dGhpcy5faW5kZXhCdWZmZXImJnRoaXMuX2VuZ2luZS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5faW5kaWNlcz1hLDAhPT10aGlzLl9tZXNoZXMubGVuZ3RoJiZ0aGlzLl9pbmRpY2VzJiYodGhpcy5faW5kZXhCdWZmZXI9dGhpcy5fZW5naW5lLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuX2luZGljZXMpKTtmb3IodmFyIGI9dGhpcy5fbWVzaGVzLGM9Yi5sZW5ndGgsZD0wO2M+ZDtkKyspYltkXS5fY3JlYXRlR2xvYmFsU3ViTWVzaCgpfSxiLnByb3RvdHlwZS5nZXRUb3RhbEluZGljZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1JlYWR5KCk/dGhpcy5faW5kaWNlcy5sZW5ndGg6MH0sYi5wcm90b3R5cGUuZ2V0SW5kaWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzUmVhZHkoKT90aGlzLl9pbmRpY2VzOm51bGx9LGIucHJvdG90eXBlLmdldEluZGV4QnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNSZWFkeSgpP3RoaXMuX2luZGV4QnVmZmVyOm51bGx9LGIucHJvdG90eXBlLnJlbGVhc2VGb3JNZXNoPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5fbWVzaGVzLGQ9Yy5pbmRleE9mKGEpO2lmKC0xIT09ZCl7Zm9yKHZhciBlIGluIHRoaXMuX3ZlcnRleEJ1ZmZlcnMpdGhpcy5fdmVydGV4QnVmZmVyc1tlXS5kaXNwb3NlKCk7dGhpcy5faW5kZXhCdWZmZXImJnRoaXMuX2VuZ2luZS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlcikmJih0aGlzLl9pbmRleEJ1ZmZlcj1udWxsKSxjLnNwbGljZShkLDEpLGEuX2dlb21ldHJ5PW51bGwsMD09Yy5sZW5ndGgmJmImJnRoaXMuZGlzcG9zZSgpfX0sYi5wcm90b3R5cGUuYXBwbHlUb01lc2g9ZnVuY3Rpb24oYSl7aWYoYS5fZ2VvbWV0cnkhPT10aGlzKXt2YXIgYj1hLl9nZW9tZXRyeTtiJiZiLnJlbGVhc2VGb3JNZXNoKGEpO3ZhciBjPXRoaXMuX21lc2hlczthLl9nZW9tZXRyeT10aGlzLHRoaXMuX3NjZW5lLnB1c2hHZW9tZXRyeSh0aGlzKSxjLnB1c2goYSksdGhpcy5pc1JlYWR5KCk/dGhpcy5fYXBwbHlUb01lc2goYSk6YS5fYm91bmRpbmdJbmZvPXRoaXMuX2JvdW5kaW5nSW5mb319LGIucHJvdG90eXBlLl9hcHBseVRvTWVzaD1mdW5jdGlvbihiKXt2YXIgYz10aGlzLl9tZXNoZXMubGVuZ3RoO2Zvcih2YXIgZCBpbiB0aGlzLl92ZXJ0ZXhCdWZmZXJzKWlmKDE9PT1jJiZ0aGlzLl92ZXJ0ZXhCdWZmZXJzW2RdLmNyZWF0ZSgpLHRoaXMuX3ZlcnRleEJ1ZmZlcnNbZF0uX2J1ZmZlci5yZWZlcmVuY2VzPWMsZD09PWEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCl7Yi5fcmVzZXRQb2ludHNBcnJheUNhY2hlKCk7dmFyIGU9YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KHRoaXMuX3ZlcnRleEJ1ZmZlcnNbZF0uZ2V0RGF0YSgpLDAsdGhpcy5fdG90YWxWZXJ0aWNlcyk7Yi5fYm91bmRpbmdJbmZvPW5ldyBhLkJvdW5kaW5nSW5mbyhlLm1pbmltdW0sZS5tYXhpbXVtKSxiLl9jcmVhdGVHbG9iYWxTdWJNZXNoKCl9MT09PWMmJnRoaXMuX2luZGljZXMmJih0aGlzLl9pbmRleEJ1ZmZlcj10aGlzLl9lbmdpbmUuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5faW5kaWNlcykpLHRoaXMuX2luZGV4QnVmZmVyJiYodGhpcy5faW5kZXhCdWZmZXIucmVmZXJlbmNlcz1jKX0sYi5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihiLGMpe3ZhciBkPXRoaXM7aWYodGhpcy5kZWxheUxvYWRTdGF0ZSE9PWEuRW5naW5lLkRFTEFZTE9BRFNUQVRFX0xPQURJTkcpe2lmKHRoaXMuaXNSZWFkeSgpKXJldHVybiB2b2lkKGMmJmMoKSk7dGhpcy5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FESU5HLGIuX2FkZFBlbmRpbmdEYXRhKHRoaXMpLGEuVG9vbHMuTG9hZEZpbGUodGhpcy5kZWxheUxvYWRpbmdGaWxlLGZ1bmN0aW9uKGUpe2QuX2RlbGF5TG9hZGluZ0Z1bmN0aW9uKEpTT04ucGFyc2UoZSksZCksZC5kZWxheUxvYWRTdGF0ZT1hLkVuZ2luZS5ERUxBWUxPQURTVEFURV9MT0FERUQsZC5fZGVsYXlJbmZvPVtdLGIuX3JlbW92ZVBlbmRpbmdEYXRhKGQpO2Zvcih2YXIgZj1kLl9tZXNoZXMsZz1mLmxlbmd0aCxoPTA7Zz5oO2grKylkLl9hcHBseVRvTWVzaChmW2hdKTtjJiZjKCl9LGZ1bmN0aW9uKCl7fSxiLmRhdGFiYXNlKX19LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5fbWVzaGVzLGM9Yi5sZW5ndGgsZD0wO2M+ZDtkKyspdGhpcy5yZWxlYXNlRm9yTWVzaChiW2RdKTt0aGlzLl9tZXNoZXM9W107Zm9yKHZhciBlIGluIHRoaXMuX3ZlcnRleEJ1ZmZlcnMpdGhpcy5fdmVydGV4QnVmZmVyc1tlXS5kaXNwb3NlKCk7dGhpcy5fdmVydGV4QnVmZmVycz1bXSx0aGlzLl90b3RhbFZlcnRpY2VzPTAsdGhpcy5faW5kZXhCdWZmZXImJnRoaXMuX2VuZ2luZS5fcmVsZWFzZUJ1ZmZlcih0aGlzLl9pbmRleEJ1ZmZlciksdGhpcy5faW5kZXhCdWZmZXI9bnVsbCx0aGlzLl9pbmRpY2VzPVtdLHRoaXMuZGVsYXlMb2FkU3RhdGU9YS5FbmdpbmUuREVMQVlMT0FEU1RBVEVfTk9ORSx0aGlzLmRlbGF5TG9hZGluZ0ZpbGU9bnVsbCx0aGlzLl9kZWxheUxvYWRpbmdGdW5jdGlvbj1udWxsLHRoaXMuX2RlbGF5SW5mbz1bXSx0aGlzLl9ib3VuZGluZ0luZm89bnVsbDt2YXIgZj10aGlzLl9zY2VuZS5nZXRHZW9tZXRyaWVzKCk7ZD1mLmluZGV4T2YodGhpcyksZD4tMSYmZi5zcGxpY2UoZCwxKX0sYi5wcm90b3R5cGUuY29weT1mdW5jdGlvbihiKXt2YXIgYz1uZXcgYS5WZXJ0ZXhEYXRhO2MuaW5kaWNlcz1bXTtmb3IodmFyIGQ9dGhpcy5nZXRJbmRpY2VzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWMuaW5kaWNlcy5wdXNoKGRbZV0pO3ZhciBmPSExLGc9ITE7Zm9yKHZhciBoIGluIHRoaXMuX3ZlcnRleEJ1ZmZlcnMpYy5zZXQodGhpcy5nZXRWZXJ0aWNlc0RhdGEoaCksaCksZ3x8KGY9dGhpcy5nZXRWZXJ0ZXhCdWZmZXIoaCkuaXNVcGRhdGFibGUoKSxnPSFmKTt2YXIgaT1uZXcgYS5HZW9tZXRyeShiLHRoaXMuX3NjZW5lLGMsZixudWxsKTtpLmRlbGF5TG9hZFN0YXRlPXRoaXMuZGVsYXlMb2FkU3RhdGUsaS5kZWxheUxvYWRpbmdGaWxlPXRoaXMuZGVsYXlMb2FkaW5nRmlsZSxpLl9kZWxheUxvYWRpbmdGdW5jdGlvbj10aGlzLl9kZWxheUxvYWRpbmdGdW5jdGlvbjtmb3IoaCBpbiB0aGlzLl9kZWxheUluZm8paS5fZGVsYXlJbmZvPWkuX2RlbGF5SW5mb3x8W10saS5fZGVsYXlJbmZvLnB1c2goaCk7dmFyIGo9YS5Ub29scy5FeHRyYWN0TWluQW5kTWF4KHRoaXMuZ2V0VmVydGljZXNEYXRhKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCksMCx0aGlzLmdldFRvdGFsVmVydGljZXMoKSk7cmV0dXJuIGkuX2JvdW5kaW5nSW5mbz1uZXcgYS5Cb3VuZGluZ0luZm8oai5taW5pbXVtLGoubWF4aW11bSksaX0sYi5FeHRyYWN0RnJvbU1lc2g9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLl9nZW9tZXRyeTtyZXR1cm4gYz9jLmNvcHkoYik6bnVsbH0sYi5SYW5kb21JZD1mdW5jdGlvbigpe3JldHVyblwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLGZ1bmN0aW9uKGEpe3ZhciBiPTE2Kk1hdGgucmFuZG9tKCl8MCxjPVwieFwiPT1hP2I6MyZifDg7cmV0dXJuIGMudG9TdHJpbmcoMTYpfSl9LGJ9KCk7YS5HZW9tZXRyeT1iLGZ1bmN0aW9uKGIpeyFmdW5jdGlvbihjKXt2YXIgZD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkLGUsZil7dGhpcy5fYmVpbmdSZWdlbmVyYXRlZD0hMCx0aGlzLl9jYW5CZVJlZ2VuZXJhdGVkPWUsYS5jYWxsKHRoaXMsYixjLGQsITEsZiksdGhpcy5fYmVpbmdSZWdlbmVyYXRlZD0hMX1yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUuY2FuQmVSZWdlbmVyYXRlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jYW5CZVJlZ2VuZXJhdGVkfSxiLnByb3RvdHlwZS5yZWdlbmVyYXRlPWZ1bmN0aW9uKCl7dGhpcy5fY2FuQmVSZWdlbmVyYXRlZCYmKHRoaXMuX2JlaW5nUmVnZW5lcmF0ZWQ9ITAsdGhpcy5zZXRBbGxWZXJ0aWNlc0RhdGEodGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSwhMSksdGhpcy5fYmVpbmdSZWdlbmVyYXRlZD0hMSl9LGIucHJvdG90eXBlLmFzTmV3R2VvbWV0cnk9ZnVuY3Rpb24oYil7cmV0dXJuIGEucHJvdG90eXBlLmNvcHkuY2FsbCh0aGlzLGIpfSxiLnByb3RvdHlwZS5zZXRBbGxWZXJ0aWNlc0RhdGE9ZnVuY3Rpb24oYil7dGhpcy5fYmVpbmdSZWdlbmVyYXRlZCYmYS5wcm90b3R5cGUuc2V0QWxsVmVydGljZXNEYXRhLmNhbGwodGhpcyxiLCExKX0sYi5wcm90b3R5cGUuc2V0VmVydGljZXNEYXRhPWZ1bmN0aW9uKGIsYyl7dGhpcy5fYmVpbmdSZWdlbmVyYXRlZCYmYS5wcm90b3R5cGUuc2V0VmVydGljZXNEYXRhLmNhbGwodGhpcyxiLGMsITEpfSxiLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdCBtZXRob2RcIil9LGIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGJlIG92ZXJyaWRlbiBpbiBzdWItY2xhc3Nlcy5cIil9LGJ9KGIpO2MuX1ByaW1pdGl2ZT1kO3ZhciBlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmKXt0aGlzLnNpemU9ZCxiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxlLGYpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZUJveCh0aGlzLnNpemUpfSxjLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLnNpemUsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuQm94PWU7dmFyIGY9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYsZyl7dGhpcy5zZWdtZW50cz1kLHRoaXMuZGlhbWV0ZXI9ZSxiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxmLGcpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZVNwaGVyZSh0aGlzLnNlZ21lbnRzLHRoaXMuZGlhbWV0ZXIpfSxjLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLnNlZ21lbnRzLHRoaXMuZGlhbWV0ZXIsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuU3BoZXJlPWY7dmFyIGc9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMsZCxlLGYsZyxoLGksail7XCJ1bmRlZmluZWRcIj09dHlwZW9mIGgmJihoPTEpLHRoaXMuaGVpZ2h0PWQsdGhpcy5kaWFtZXRlclRvcD1lLHRoaXMuZGlhbWV0ZXJCb3R0b209Zix0aGlzLnRlc3NlbGxhdGlvbj1nLHRoaXMuc3ViZGl2aXNpb25zPWgsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksaSxqKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVDeWxpbmRlcih0aGlzLmhlaWdodCx0aGlzLmRpYW1ldGVyVG9wLHRoaXMuZGlhbWV0ZXJCb3R0b20sdGhpcy50ZXNzZWxsYXRpb24sdGhpcy5zdWJkaXZpc2lvbnMpfSxjLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhLHRoaXMuZ2V0U2NlbmUoKSx0aGlzLmhlaWdodCx0aGlzLmRpYW1ldGVyVG9wLHRoaXMuZGlhbWV0ZXJCb3R0b20sdGhpcy50ZXNzZWxsYXRpb24sdGhpcy5zdWJkaXZpc2lvbnMsdGhpcy5jYW5CZVJlZ2VuZXJhdGVkKCksbnVsbCl9LGN9KGQpO2MuQ3lsaW5kZXI9Zzt2YXIgaD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZixnLGgpe3RoaXMuZGlhbWV0ZXI9ZCx0aGlzLnRoaWNrbmVzcz1lLHRoaXMudGVzc2VsbGF0aW9uPWYsYi5jYWxsKHRoaXMsYSxjLHRoaXMuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhKCksZyxoKX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX3JlZ2VuZXJhdGVWZXJ0ZXhEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIGEuVmVydGV4RGF0YS5DcmVhdGVUb3J1cyh0aGlzLmRpYW1ldGVyLHRoaXMudGhpY2tuZXNzLHRoaXMudGVzc2VsbGF0aW9uKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy5kaWFtZXRlcix0aGlzLnRoaWNrbmVzcyx0aGlzLnRlc3NlbGxhdGlvbix0aGlzLmNhbkJlUmVnZW5lcmF0ZWQoKSxudWxsKX0sY30oZCk7Yy5Ub3J1cz1oO3ZhciBpPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcsaCl7dGhpcy53aWR0aD1kLHRoaXMuaGVpZ2h0PWUsdGhpcy5zdWJkaXZpc2lvbnM9ZixiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxnLGgpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZUdyb3VuZCh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMuc3ViZGl2aXNpb25zKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLnN1YmRpdmlzaW9ucyx0aGlzLmNhbkJlUmVnZW5lcmF0ZWQoKSxudWxsKX0sY30oZCk7Yy5Hcm91bmQ9aTt2YXIgaj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyxkLGUsZixnLGgsaSxqLGspe3RoaXMueG1pbj1kLHRoaXMuem1pbj1lLHRoaXMueG1heD1mLHRoaXMuem1heD1nLHRoaXMuc3ViZGl2aXNpb25zPWgsdGhpcy5wcmVjaXNpb249aSxiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxqLGspfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZVRpbGVkR3JvdW5kKHRoaXMueG1pbix0aGlzLnptaW4sdGhpcy54bWF4LHRoaXMuem1heCx0aGlzLnN1YmRpdmlzaW9ucyx0aGlzLnByZWNpc2lvbil9LGMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEsdGhpcy5nZXRTY2VuZSgpLHRoaXMueG1pbix0aGlzLnptaW4sdGhpcy54bWF4LHRoaXMuem1heCx0aGlzLnN1YmRpdmlzaW9ucyx0aGlzLnByZWNpc2lvbix0aGlzLmNhbkJlUmVnZW5lcmF0ZWQoKSxudWxsKX0sY30oZCk7Yy5UaWxlZEdyb3VuZD1qO3ZhciBrPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmKXt0aGlzLnNpemU9ZCxiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxlLGYpfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZVBsYW5lKHRoaXMuc2l6ZSl9LGMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEsdGhpcy5nZXRTY2VuZSgpLHRoaXMuc2l6ZSx0aGlzLmNhbkJlUmVnZW5lcmF0ZWQoKSxudWxsKX0sY30oZCk7Yy5QbGFuZT1rO3ZhciBsPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxjLGQsZSxmLGcsaCxpLGosayl7dGhpcy5yYWRpdXM9ZCx0aGlzLnR1YmU9ZSx0aGlzLnJhZGlhbFNlZ21lbnRzPWYsdGhpcy50dWJ1bGFyU2VnbWVudHM9Zyx0aGlzLnA9aCx0aGlzLnE9aSxiLmNhbGwodGhpcyxhLGMsdGhpcy5fcmVnZW5lcmF0ZVZlcnRleERhdGEoKSxqLGspfXJldHVybiBfX2V4dGVuZHMoYyxiKSxjLnByb3RvdHlwZS5fcmVnZW5lcmF0ZVZlcnRleERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gYS5WZXJ0ZXhEYXRhLkNyZWF0ZVRvcnVzS25vdCh0aGlzLnJhZGl1cyx0aGlzLnR1YmUsdGhpcy5yYWRpYWxTZWdtZW50cyx0aGlzLnR1YnVsYXJTZWdtZW50cyx0aGlzLnAsdGhpcy5xKX0sYy5wcm90b3R5cGUuY29weT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSx0aGlzLmdldFNjZW5lKCksdGhpcy5yYWRpdXMsdGhpcy50dWJlLHRoaXMucmFkaWFsU2VnbWVudHMsdGhpcy50dWJ1bGFyU2VnbWVudHMsdGhpcy5wLHRoaXMucSx0aGlzLmNhbkJlUmVnZW5lcmF0ZWQoKSxudWxsKX0sY30oZCk7Yy5Ub3J1c0tub3Q9bH0oYi5QcmltaXRpdmVzfHwoYi5QcmltaXRpdmVzPXt9KSk7Yi5QcmltaXRpdmVzfShhLkdlb21ldHJ5fHwoYS5HZW9tZXRyeT17fSkpO3ZhciBiPWEuR2VvbWV0cnl9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7dmFyIGI9dGhpczt0aGlzLmJhYnlsb25HYW1lcGFkcz1bXSx0aGlzLm9uZUdhbWVwYWRDb25uZWN0ZWQ9ITEsdGhpcy5pc01vbml0b3Jpbmc9ITEsdGhpcy5nYW1lcGFkRXZlbnRTdXBwb3J0ZWQ9XCJHYW1lcGFkRXZlbnRcImluIHdpbmRvdyx0aGlzLmdhbWVwYWRTdXBwb3J0QXZhaWxhYmxlPW5hdmlnYXRvci5nZXRHYW1lcGFkc3x8ISFuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHN8fCEhbmF2aWdhdG9yLm1zR2V0R2FtZXBhZHN8fCEhbmF2aWdhdG9yLndlYmtpdEdhbWVwYWRzLHRoaXMuYnV0dG9uQURhdGFVUkw9XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUVBQUFBQkFDQVlBQUFDcWFYSGVBQUFBQkdkQlRVRUFBSy9JTndXSzZRQUFBQmwwUlZoMFUyOW1kSGRoY21VQVFXUnZZbVVnU1cxaFoyVlNaV0ZrZVhISlpUd0FBQTlhU1VSQlZIamE3RnRwYkJ6bmVYN20zb3RjaWhTcG05WjlVSmFseFBLaFZMWmxwNmt0TnpFYXhFMEN0QW5RQWduU29QV1BCaTNzeXVpUHdvcmRGaTVRdDJoYUZ5Z0NveWxTVjRWYnk2b3MxSTNrT0xZclM2NWtYWFFveXBKSlNhRkVVVHlYeTkyNStyemZ6QzZIRkZsTDFrcEFJZTdpNWN6TzdIN3pQczk3ZnQ4TXRUQU1jU3UvZE56aXJ4a0NaZ2lZSVdDR2dCa0NaZ2k0aFYvbURSNWZTeEF0KzBaaVgwdWNEeE1TVEpMSytmODNCRlNBNlRGZ0s3NU9jbHNob3VLQkZiQSt4YVY0azdaK2ZENnNOUmxtallGWFFNdTROaVVWUy9vSGU1L2VjbkhvM01ZeGQ3UXRoTjlVY3NkVzZGcUVQd2dET0ZicXBBYWpMMlZsVHJUVUx6ajRPdzgrczQrbmlwU3hXTW94SVVreXJsL3BHc3dGdElSN1d6SGdEQ1g3N0s3dmZITmtiT0ErQXJ5allaYWRiMjdPSUpkekNOWkJLbVh3NGtiazM1cVBzVEVmSmJlRWtaRVNlbnRITWRCZkd0WTE0Mmd1MWJEdnFWLzkyNWY0dFFKbE5DYWo0aFhYN1JIWFMwQUZ1SkVBWHZmSHIvem1rNjd2UGppcjBWNjhhRkVlOHh0dVE2TzFGSGxyRVhMbUhCaWFEVXR6WUJscE5ZanJGK0dGWmZoaENjUGVCUXk1M2VoelQrSDhRQmU2dXdmUmY3bDh4aktzdlgveTVYOThqbDhmVGhEaEo0aTQ2UVFrclM1STZ2N29YNy8rKzc3dlB0TFVsRm5adG5JUmx1YnZ4UnhuSGJKbUU3OXN4RC9TcUcwb1prOE1GYXJScXVmVWtRQUZyeGNYU2tmeDBlQituT2dnS1gyakhZWmh2Zjc5ci96NEwySWlpcE84NGFZUmtBU2ZlZm5BWDY5NXAzUDNjOW1NL1V1ZnVhTVZkelJ2eFZ4N0EweGFXZE9NcVZVTEo2WjNUWnY2S21IbzB6dEs2Q2tmeHBIZTNUaDBwQXVGMGZMYm4xdSs5Y212M3ZXNzdiRTNmR29TUGkwQlZmQXZ2UEVIbTlyUHYvL2lvb1d6NW05Wi93Q1daeCtHbzlVck40OFFURDlJR01aMWNKSXpUUGlzUlFjbFBNcmhNRTRXOW1EZkIyK2krMnovK1RYejcvejJFNy84NSs5T0l1R0dFNkJWM0g3N3ptL2QzM254Nkt0cjE4ekZnMnQrRFF1ZGUybjF0TEo4dGNKOTB2RGhwRzVBbTdxVGtKQVFFcnl3aUxPbGQ3RzMvZDl4dkwwSHkxdldQYmJ0UzMvLzAwUTRoRGVhQUZYaW50cngxZnU3K2pwMnIxM2Jnb2ZYL2dhYXpiVmtKUWRMVDlQNlZxUkZEU3UyaElnWGxCVUJMZ3RDcjNjY2U0Ny9DTWVQWDBScjA4cXR6ejcrOGs4VHBmS0d0Y0txMWpQWnJlN29PYnlqZFdrR2Q2MjhsN0FYd3ZNQ2VMN0hqTzZxclM4UzFFNWtURTl0ZmJpdXI2NjVjY1U5RUIxRUY5RXAwV1hlc0VaSUpiOWo1L2IvWFV0ek5ydDI5Uncwb2cybGNobUJWcUxvOExTQUhsQ2l4YlRwZGRHbThZN3Bqa3R0Q0NVUCtKUXkzRmlhdE51eGR2VXg5RjRheW9wTy9PTDlzUWVFTjRvQS9lSG41NzdvV1BiR1ZlczExUHNyVUJ4akRhZnplMVRlMVZ6b3VxbksyVGdtTFFsalFxbXJuQXNUK2lhUFZiNWIyY283RUMrUWhCZ1VlTTFSMUFjcnNHcDlKeTYrNFc4VTNmWjhyK2UzRW5PSTJ1YUFYM2wremdOQjRPOXJXNS9COHRZNVdHbzlCdE9ySjR1TWZVbCt1ajBCOEhUbVBYajhQZXg4NnhWRW5UREJCU0Uycjc4Zlg5aTA5UlB5WmZUMkE1Y2VJTVNQd0RPSDhKSDdLazUrZkFIdFIwWmg2TVo5ZTc1MzRXYzN3Z08wc1hMaEQ5T3BGT2EwZWdqR01oZ3VEOEJnVEpvb01mUGJWMWgvdW16MjVvbmRjRlA5MEl6WTJpVGdyZlk5dUgzMWFxU2M5Q2VTRUhrQkV5SVR2MjhNOFhNR2MyL3owSEdDcFdDczhCUy85c1dyRFlPckp1Q0JaK3Z1NXNVZlhiaWNpYTVrWUd6VXc0RFdUd0pLYkFwU2pIdVRCQmpUMkg2OHpnME1ENEtsRXdhYlppMFk3d2Q4NXUvM085L0I2c1ZyUGxFWGVpRjluTW1SeFB0NlFmNHkvSHlJYmgzSHdrZEYxemVmR3Q1ZlV3Szh3UDJXQUd3aDAyTUZFLzVvZ1lyM1FnL1NUTDBXM2Q4YUIxcHBhK1B3MHVJMlR6Ni8xMzRNZytVb0lHWmxaMkhNTGFKWUhrUElDcjYvL1JCYW12UGovVUE0ZFlLc2VnR3JYcUFYTWFxTnNEVDZTcmVPWTVHdS9GcHRDZUJGTitjYUFwaEdpS0ZpR2FPakEzQUpIb0d0NnI3R2dOYmpxam81eVFrQlVWSFE4UGFKRXhqaWFaMnl1ZTEybk8yN2dDTmRIU3B0dmYveEdkdzExSTJVWlNtdkNJSmdRaUpNaG9FZmVxcE5EdlVTUnZVQjVoTVg5ZlVlY2cwYUJpK0htMnVhQXo2MzNibWJtMVZOOCtoMDdMZktKZGtPa1FCMmZMNEJUbHNqOE5vNFlMRzJwdXRNU2p3anAzUU52WmRIOFlzaUV4VjUwMWlzRmpVMzBscEY3RDhkVmZDQThzRkhwN0J1V1l0YUl3aUNzQ3JDU0RWaGg5SVg4azBDb0hzb01RODRGcmZGQUUzelFBSzBWYUx6Tzl0Szc5WEtBeFNqK2FZQUx0M1hMZk5pcFpEMXY0OTJZZXhyRS9zUDB6QmdVSVFJb1lhZmxBWGJ6MTZDenlZNllLcVlsOHVoZVRhclJpb0Q3eEF4Q1FIVXB2MThMMVl1ZCtJbG91anRrNHpRbzlXWmNLVVJxamJIY2x6S3ZqMEd2Y3c4VUE2b1kyV3FvblN1R1FHYjVJK1RKZ0VGRXNCNGRhWHpjMGVvcGFiY1gxM1cwQlh3Z0FuUlpMNFE2MnM4cHBuUi9wRnovUWpGK3RSdnhlSXNZL2Npekd3UnQ4M1A0Y3pBQ0w4SGRBMUpVaXZDTkdWb2d2ZGtOa2dhR0ROZTRDdlhGeUo4bitCNVhHTEoxRm1KWEo1M0F6alpLZ0diYXRrS0w1Yy9saU5XSVBPOHVNLzRWTzJ1S0NRWmpMbUJxUUFHSjRFbUk4Tk1hYkRUT3V5VW9iWVhtUGxDRXBpcUExSWtZZFdTQnBqcEVEbDZ3c3JGOWFBanFITk9QWER5WEFHcHJBa25ZNUIwYnRPR0drL0dsZkUxdGFxb2ZDTnV1WU5JSitvbU9pWjFycFVIdEVZV2prcFdvUDVFV1Yyc2I1aXNBN2FJUVRISHhhSW5pTkFEdWk4UElzMEViNlNZL1owVVFjK2orbVhZdW9NN1Z5L0FnZTd6a0JVeUNaR0xoUkxTT1ljV3BmWEZBMXdQaHF1cDhKTktxNVVrS2VvcVNIeFBMU29xblVRdHc1aW9jNjBJeUUvVmtPamk4bVlFMm5aRUxOZ0NYTGFPa0dERkpCZzRPekNNREVjeENmQXpTMXBRWDVmSFNORExDbExHd213emxzNnZRMDloR0ZKWWVnZFoxaGhhMmJxSUJOZWxCNVFqb2cwMlR6cEZOVkVxdVlwTXVUU1lyL2xjUVBLUEpIb1JROFcxR1lPM2xEZ3BPOXBQV1RFWkVRR251b2RnNUh5azY2THlkOGZLT1FRNmdxeVdpY3Q3R2V1V3o4SFF5V0VGdytiQjdrc0YzTmsyVjFuZnBaVExRcVNMc2x6WGxEbUhwc1Exb3NWb3kvU29sd2YvR3BkRXJwYUFRVXFqV3hMMkdXY1dhU2ZBTUlpczdSQndpdUNkdEQxT2dtTkhCSkNnN3I0dVpCbmJkamFhcSszWWV3QitVU1lpY1k4anVZUG5NdGxvcWRDakczZjM5ZU8rM0pLSUFGYWRTaWlaaWdCZGdkY3FJdE14c21aYklidlVJS2x6elFqb0VnTEdSalUyS1RwOEFqUkNrekVuQUcwbXRRaDhLdTBvQXFvazhKelArTHcwTWtCM2pwS2pLcGFwYUw1V0taeGFmRGRCcW9DNk84THR5TUFRaG9aZHpHN013TFU4RlVZS1BJTmNsK3FpbWlzbVJqMjZ2Mkk3MUkzakR4ZmRwTTQxSTZDVHNtRzRYMGRqS3ljOFJZdTl0MFZsMlFKYkJKNXhGUGlJQ0pJZzFoZGhSM2ZzNUhuV2VsZGxlWlhBQkxBOThiN1k1SHRqa2d3TkV0YlRONGlGQzVvSTNJMUNUc0Fic2ZWakFpekpCM1FieDlIcGhScDZlcXIzVERwclNZQTBGSS8zbnRPeGJwVU5NMk9qcEVjRTZIWUVXa2hJS3crSUNlQnhpK1QwOUYxV1pVK2lKcTJuOGZSRGY0WW11M1hTcmNPSWdnOEg5dU9GbjMxZk5VVkMwb2RkWjdCNVl4dER3bFRnbzY2U0VpY2kyZm9rd0NKamp1MGh3N0o1NFd5cFFzQjd0U1JBemErSCtubGQzMFkrbTJiN1NTK1FuOVBLRmwxZWdSY2lISWZXcHhDOHgrN3RkQTk3KzN6VWNOeVdYNENpL1RIT29EMngvaG1sUVRveCszZ0RqV1llZy80Z21GODUzeGpCcFVzamFHbkpSMjRmdTM2Rk56WDVwbWZZN0VQU3RsU0xJZ2I2Z3drNjE2UVJZazh0Uzg4L2wvMlBUL2xveXFiUWtFbWhQcE5HTnAxQ212dGllUUh2T05HdEw0c2R5OUhqcDVra3BUV21Tek03TDUyOWhFckhzMGNDcHQycVcwMEJ5bURWM0pYU1U4SGtBWEtJanRObmVkeFM0OG00TXI1Y1I5WWxNcngrWFRxTlJtYlAyWmtNT2p2SEtpci9QTmE1cG91aWl0RmpINDRpWjZZd081dEZBeStlbzZTZHBPVUp5aEJRVEpSK0hUOUhZTEphRnZlMFBxUW1UUUxhVk9DZG1JUklXRSt3cm1XVHpHOGlBdWdGN3FnV2pTV2tHYllhMzJFakpRVGtHRnY1ZEJaTkpLQ2VIZGI3N1VQWFpQMXJXaEtMWjRScWp2MkZ6ODZsTE1ObHB1c0NZOUJucVROVUl5VGdyVmhoczdyVnEyS29XMlRTeFdsWExPQ3FXWDRzdm1welpkRWpXdmdRY2RWV1BudStpNENsVVMrSHlMSUZuc1ZmLzllQmR1dzhlS1l5MkQxWE14TzhKZytJQjl3bCszcy91QUMzcUtNcFhZODhtL2VjblVIYVNpczNOYThBYjFVdGFDaDNqMXkrc204bTlvMEorOUZ2OU1SNFpodzZEdWZUV2FzT2Vic09zK3haS0hKT3R2dFF0ZXJ0dWxyd1YrMEJ0SDV5V3Z5VzdDeHVic0NUWDkrS1VRWjRnYTdxbWRHVUZtcnlhOFFXSHdjeGxSZU1GOE13NFFFVHJSOG95N3RxMml2SDVUdnlhOG44YVhaTUdjNEFuL25SRHB5NTJGZlI4YjVLQ0pDSW10OFlrWUYvS0R0bmVnZnd6M3NQb2RHYWpRYWpDVGs5ei80bVE2aXBoTVd2OUFBOUllTVdkeVlkbitnQmtWYzVhbXdIV1Y2bEh2VmFJMllaemZpbk45NU5ndi9odGNUL3AzMUNSTmJkVjhsOGUrK3hENUhQTmVIeGh4NUJnZjE4a1RONVQxa3ZqQmZFakdqQkpDYWk0Z25qSHFBbmx2cVM4ZTlOZXVqRWpFdWwvTm9rRGJhaTRWLzJ2b2FmSEQxUzBldmRXTGViOG9qTU55bHk1ZlMvL2ZmYmNEMEwzM2o0SzRSWDRydE1oL1VVR0xYbXI2QldYTjlNRUZBaFlmem1aNmhjWEkrVHBJU1JIODA2MVVpNjhnVFdHVUpQNGFVOVA4WnJCMzlTK1hreDF1bW1QU01rYmVibkpjeFUxam00RDVlR2h2QjdqMzJISmNwVUpIaHhMSWZ4VFpweHdHYThlS3JIQzUxYTlUbXArTjVQMVJzUTAxY0pBd0VmbEh3OC8rcGZZbi9IZ2FRK243L2ExdmQ2aytCVVMyWHZWRDQwMVRYaHU0ODhnUTByNzFRVXVMSnNyV1Q4bVNZdGZrQk1tMEJBbUZoTnJnRFg0b1JxcWVhSk13NGM2VHlJdi9xUFAwWGY4S1VKNnNYdVAxWGx1dUVFeUdzRDVUWEtnc3FCTlF2VzRSdGJua0RiNHR0SlFsR3QvSVFxTE1KRTd0V3FPU0JaQ1NyTDZkRlNxcTNBbnpoekRDL3Rld0h0NXc0bnIzc3V2Z04wK1A4bzNUZWVnRmUzdllESHRqK3hoTHQvUTNra2VXNWQ2OTNZdXVIWHNXSFpQY2l4VzR0Q3dvK3RyVlU5UUVzOEc2SEZxVzVrZEJpSFR1M0g2NGRmeHBHdUs4cjY2NVR2N3R6MkQ2ZS90UDIzY1QwRTFPQTVRUjJpaUliczFpOXUvOXFUUFBDMTJDdHdsSW9malpWdlcvQlozTFZzQzViUFc0dTVEUXV4YVBheTJOcFJJdXk2MUlrTEErZHc4aGRIY2VEVVBwdzQ5ejlUWFV5c3ZXUFh0bDNiUTR5UXRNSjFhMThEQXNidlJPL2F0dk01RFhYUFBicDl5elA4K0dYQlhUa25nS1lCZFRXdkU1UlhkbTg3K0hRRWZMaDJUNTdVSUFkTTk1SnM5KzA0TEtTRGJMekczMStPbXhweDl4ZnhLUjZBdWtraE1QMGFLdVVIc2FnNVZFekUzZkdTZGRzVVZ1NktGeklFK0gvaUpyeTBtWCtidThWZk13VE1FREJEd0F3Qk13VE1FSEFMdi81WGdBRUFTcFI1TjZyQjMwVUFBQUFBU1VWT1JLNUNZSUk9XCIsdGhpcy5fY2FsbGJhY2tHYW1lcGFkQ29ubmVjdGVkPWEsdGhpcy5nYW1lcGFkU3VwcG9ydEF2YWlsYWJsZT8odGhpcy5nYW1lcGFkRXZlbnRTdXBwb3J0ZWQ/KHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLGZ1bmN0aW9uKGEpe2IuX29uR2FtZXBhZENvbm5lY3RlZChhKVxufSwhMSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsZnVuY3Rpb24oYSl7Yi5fb25HYW1lcGFkRGlzY29ubmVjdGVkKGEpfSwhMSkpOnRoaXMuX3N0YXJ0TW9uaXRvcmluZ0dhbWVwYWRzKCksdGhpcy5vbmVHYW1lcGFkQ29ubmVjdGVkfHx0aGlzLl9pbnNlcnRHYW1lcGFkRE9NSW5zdHJ1Y3Rpb25zKCkpOnRoaXMuX2luc2VydEdhbWVwYWRET01Ob3RTdXBwb3J0ZWQoKX1yZXR1cm4gYi5wcm90b3R5cGUuX2luc2VydEdhbWVwYWRET01JbnN0cnVjdGlvbnM9ZnVuY3Rpb24oKXtiLmdhbWVwYWRET01JbmZvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTthLnNyYz10aGlzLmJ1dHRvbkFEYXRhVVJMO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2MuaW5uZXJIVE1MPVwiPHN0cm9uZz50byBhY3RpdmF0ZSBnYW1lcGFkPC9zdHJvbmc+XCIsYi5nYW1lcGFkRE9NSW5mby5hcHBlbmRDaGlsZChhKSxiLmdhbWVwYWRET01JbmZvLmFwcGVuZENoaWxkKGMpLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUud2lkdGg9XCIxMDAlXCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5oZWlnaHQ9XCI0OHB4XCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5ib3R0b209XCIwcHhcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJnYmEoMSwgMSwgMSwgMC4xNSlcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLnRleHRBbGlnbj1cImNlbnRlclwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUuekluZGV4PVwiMTBcIixhLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixhLnN0eWxlLmJvdHRvbT1cIjhweFwiLGMuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLGMuc3R5bGUuZm9udFNpemU9XCIzMnB4XCIsYy5zdHlsZS5ib3R0b209XCIzMnB4XCIsYy5zdHlsZS5jb2xvcj1cImdyZWVuXCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiLmdhbWVwYWRET01JbmZvKX0sYi5wcm90b3R5cGUuX2luc2VydEdhbWVwYWRET01Ob3RTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtiLmdhbWVwYWRET01JbmZvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7YS5pbm5lckhUTUw9XCI8c3Ryb25nPmdhbWVwYWQgbm90IHN1cHBvcnRlZDwvc3Ryb25nPlwiLGIuZ2FtZXBhZERPTUluZm8uYXBwZW5kQ2hpbGQoYSksYi5nYW1lcGFkRE9NSW5mby5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS53aWR0aD1cIjEwMCVcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLmhlaWdodD1cIjQwcHhcIixiLmdhbWVwYWRET01JbmZvLnN0eWxlLmJvdHRvbT1cIjBweFwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUuYmFja2dyb3VuZENvbG9yPVwicmdiYSgxLCAxLCAxLCAwLjE1KVwiLGIuZ2FtZXBhZERPTUluZm8uc3R5bGUudGV4dEFsaWduPVwiY2VudGVyXCIsYi5nYW1lcGFkRE9NSW5mby5zdHlsZS56SW5kZXg9XCIxMFwiLGEuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiLGEuc3R5bGUuZm9udFNpemU9XCIzMnB4XCIsYS5zdHlsZS5jb2xvcj1cInJlZFwiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYi5nYW1lcGFkRE9NSW5mbyl9LGIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIuZ2FtZXBhZERPTUluZm8pfSxiLnByb3RvdHlwZS5fb25HYW1lcGFkQ29ubmVjdGVkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX2FkZE5ld0dhbWVwYWQoYS5nYW1lcGFkKTt0aGlzLl9jYWxsYmFja0dhbWVwYWRDb25uZWN0ZWQmJnRoaXMuX2NhbGxiYWNrR2FtZXBhZENvbm5lY3RlZChiKSx0aGlzLl9zdGFydE1vbml0b3JpbmdHYW1lcGFkcygpfSxiLnByb3RvdHlwZS5fYWRkTmV3R2FtZXBhZD1mdW5jdGlvbihjKXt0aGlzLm9uZUdhbWVwYWRDb25uZWN0ZWR8fCh0aGlzLm9uZUdhbWVwYWRDb25uZWN0ZWQ9ITAsYi5nYW1lcGFkRE9NSW5mbyYmKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYi5nYW1lcGFkRE9NSW5mbyksYi5nYW1lcGFkRE9NSW5mbz1udWxsKSk7dmFyIGQ7cmV0dXJuIGQ9LTEhPT1jLmlkLnNlYXJjaChcIlhib3ggMzYwXCIpfHwtMSE9PWMuaWQuc2VhcmNoKFwieGlucHV0XCIpP25ldyBhLlhib3gzNjBQYWQoYy5pZCxjLmluZGV4LGMpOm5ldyBhLkdlbmVyaWNQYWQoYy5pZCxjLmluZGV4LGMpLHRoaXMuYmFieWxvbkdhbWVwYWRzLnB1c2goZCksZH0sYi5wcm90b3R5cGUuX29uR2FtZXBhZERpc2Nvbm5lY3RlZD1mdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gdGhpcy5iYWJ5bG9uR2FtZXBhZHMpaWYodGhpcy5iYWJ5bG9uR2FtZXBhZHNbYl0uaW5kZXg9PWEuZ2FtZXBhZC5pbmRleCl7dGhpcy5iYWJ5bG9uR2FtZXBhZHMuc3BsaWNlKGIsMSk7YnJlYWt9MD09dGhpcy5iYWJ5bG9uR2FtZXBhZHMubGVuZ3RoJiZ0aGlzLl9zdG9wTW9uaXRvcmluZ0dhbWVwYWRzKCl9LGIucHJvdG90eXBlLl9zdGFydE1vbml0b3JpbmdHYW1lcGFkcz1mdW5jdGlvbigpe3RoaXMuaXNNb25pdG9yaW5nfHwodGhpcy5pc01vbml0b3Jpbmc9ITAsdGhpcy5fY2hlY2tHYW1lcGFkc1N0YXR1cygpKX0sYi5wcm90b3R5cGUuX3N0b3BNb25pdG9yaW5nR2FtZXBhZHM9ZnVuY3Rpb24oKXt0aGlzLmlzTW9uaXRvcmluZz0hMX0sYi5wcm90b3R5cGUuX2NoZWNrR2FtZXBhZHNTdGF0dXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMuX3VwZGF0ZUdhbWVwYWRPYmplY3RzKCk7Zm9yKHZhciBiIGluIHRoaXMuYmFieWxvbkdhbWVwYWRzKXRoaXMuYmFieWxvbkdhbWVwYWRzW2JdLnVwZGF0ZSgpO3RoaXMuaXNNb25pdG9yaW5nJiYod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7YS5fY2hlY2tHYW1lcGFkc1N0YXR1cygpfSk6d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7YS5fY2hlY2tHYW1lcGFkc1N0YXR1cygpfSk6d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSYmd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2EuX2NoZWNrR2FtZXBhZHNTdGF0dXMoKX0pKX0sYi5wcm90b3R5cGUuX3VwZGF0ZUdhbWVwYWRPYmplY3RzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5hdmlnYXRvci5nZXRHYW1lcGFkcz9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTpuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHM/bmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzKCk6W10sYj0wO2I8YS5sZW5ndGg7YisrKWlmKGFbYl0paWYoYVtiXS5pbmRleCBpbiB0aGlzLmJhYnlsb25HYW1lcGFkcyl0aGlzLmJhYnlsb25HYW1lcGFkc1tiXS5icm93c2VyR2FtZXBhZD1hW2JdO2Vsc2V7dmFyIGM9dGhpcy5fYWRkTmV3R2FtZXBhZChhW2JdKTt0aGlzLl9jYWxsYmFja0dhbWVwYWRDb25uZWN0ZWQmJnRoaXMuX2NhbGxiYWNrR2FtZXBhZENvbm5lY3RlZChjKX19LGJ9KCk7YS5HYW1lcGFkcz1iO3ZhciBjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe3RoaXMueD1hLHRoaXMueT1ifXJldHVybiBhfSgpO2EuU3RpY2tWYWx1ZXM9Yzt2YXIgZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMpe3RoaXMuaWQ9YSx0aGlzLmluZGV4PWIsdGhpcy5icm93c2VyR2FtZXBhZD1jLHRoaXMuYnJvd3NlckdhbWVwYWQuYXhlcy5sZW5ndGg+PTImJih0aGlzLl9sZWZ0U3RpY2s9e3g6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzBdLHk6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzFdfSksdGhpcy5icm93c2VyR2FtZXBhZC5heGVzLmxlbmd0aD49NCYmKHRoaXMuX3JpZ2h0U3RpY2s9e3g6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzJdLHk6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzNdfSl9cmV0dXJuIGEucHJvdG90eXBlLm9ubGVmdHN0aWNrY2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLl9vbmxlZnRzdGlja2NoYW5nZWQ9YX0sYS5wcm90b3R5cGUub25yaWdodHN0aWNrY2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLl9vbnJpZ2h0c3RpY2tjaGFuZ2VkPWF9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLnByb3RvdHlwZSxcImxlZnRTdGlja1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGVmdFN0aWNrfSxzZXQ6ZnVuY3Rpb24oYSl7IXRoaXMuX29ubGVmdHN0aWNrY2hhbmdlZHx8dGhpcy5fbGVmdFN0aWNrLng9PT1hLngmJnRoaXMuX2xlZnRTdGljay55PT09YS55fHx0aGlzLl9vbmxlZnRzdGlja2NoYW5nZWQoYSksdGhpcy5fbGVmdFN0aWNrPWF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwicmlnaHRTdGlja1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmlnaHRTdGlja30sc2V0OmZ1bmN0aW9uKGEpeyF0aGlzLl9vbnJpZ2h0c3RpY2tjaGFuZ2VkfHx0aGlzLl9yaWdodFN0aWNrLng9PT1hLngmJnRoaXMuX3JpZ2h0U3RpY2sueT09PWEueXx8dGhpcy5fb25yaWdodHN0aWNrY2hhbmdlZChhKSx0aGlzLl9yaWdodFN0aWNrPWF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fbGVmdFN0aWNrJiYodGhpcy5sZWZ0U3RpY2s9e3g6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzBdLHk6dGhpcy5icm93c2VyR2FtZXBhZC5heGVzWzFdfSksdGhpcy5fcmlnaHRTdGljayYmKHRoaXMucmlnaHRTdGljaz17eDp0aGlzLmJyb3dzZXJHYW1lcGFkLmF4ZXNbMl0seTp0aGlzLmJyb3dzZXJHYW1lcGFkLmF4ZXNbM119KX0sYX0oKTthLkdhbWVwYWQ9ZDt2YXIgZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIsYyxkKXthLmNhbGwodGhpcyxiLGMsZCksdGhpcy5pZD1iLHRoaXMuaW5kZXg9Yyx0aGlzLmdhbWVwYWQ9ZCx0aGlzLl9idXR0b25zPW5ldyBBcnJheShkLmJ1dHRvbnMubGVuZ3RoKX1yZXR1cm4gX19leHRlbmRzKGIsYSksYi5wcm90b3R5cGUub25idXR0b25kb3duPWZ1bmN0aW9uKGEpe3RoaXMuX29uYnV0dG9uZG93bj1hfSxiLnByb3RvdHlwZS5vbmJ1dHRvbnVwPWZ1bmN0aW9uKGEpe3RoaXMuX29uYnV0dG9udXA9YX0sYi5wcm90b3R5cGUuX3NldEJ1dHRvblZhbHVlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYSE9PWImJih0aGlzLl9vbmJ1dHRvbmRvd24mJjE9PT1hJiZ0aGlzLl9vbmJ1dHRvbmRvd24oYyksdGhpcy5fb25idXR0b251cCYmMD09PWEmJnRoaXMuX29uYnV0dG9udXAoYykpLGF9LGIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe2EucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO2Zvcih2YXIgYj0wO2I8dGhpcy5fYnV0dG9ucy5sZW5ndGg7YisrKXRoaXMuX2J1dHRvbnNbYl09dGhpcy5fc2V0QnV0dG9uVmFsdWUodGhpcy5nYW1lcGFkLmJ1dHRvbnNbYl0udmFsdWUsdGhpcy5fYnV0dG9uc1tiXSxiKX0sYn0oZCk7YS5HZW5lcmljUGFkPWUsZnVuY3Rpb24oYSl7YVthLkE9MF09XCJBXCIsYVthLkI9MV09XCJCXCIsYVthLlg9Ml09XCJYXCIsYVthLlk9M109XCJZXCIsYVthLlN0YXJ0PTRdPVwiU3RhcnRcIixhW2EuQmFjaz01XT1cIkJhY2tcIixhW2EuTEI9Nl09XCJMQlwiLGFbYS5SQj03XT1cIlJCXCIsYVthLkxlZnRTdGljaz04XT1cIkxlZnRTdGlja1wiLGFbYS5SaWdodFN0aWNrPTldPVwiUmlnaHRTdGlja1wifShhLlhib3gzNjBCdXR0b258fChhLlhib3gzNjBCdXR0b249e30pKTthLlhib3gzNjBCdXR0b247IWZ1bmN0aW9uKGEpe2FbYS5VcD0wXT1cIlVwXCIsYVthLkRvd249MV09XCJEb3duXCIsYVthLkxlZnQ9Ml09XCJMZWZ0XCIsYVthLlJpZ2h0PTNdPVwiUmlnaHRcIn0oYS5YYm94MzYwRHBhZHx8KGEuWGJveDM2MERwYWQ9e30pKTt2YXIgZj0oYS5YYm94MzYwRHBhZCxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7YS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5fbGVmdFRyaWdnZXI9MCx0aGlzLl9yaWdodFRyaWdnZXI9MCx0aGlzLl9idXR0b25BPTAsdGhpcy5fYnV0dG9uQj0wLHRoaXMuX2J1dHRvblg9MCx0aGlzLl9idXR0b25ZPTAsdGhpcy5fYnV0dG9uQmFjaz0wLHRoaXMuX2J1dHRvblN0YXJ0PTAsdGhpcy5fYnV0dG9uTEI9MCx0aGlzLl9idXR0b25SQj0wLHRoaXMuX2J1dHRvbkxlZnRTdGljaz0wLHRoaXMuX2J1dHRvblJpZ2h0U3RpY2s9MCx0aGlzLl9kUGFkVXA9MCx0aGlzLl9kUGFkRG93bj0wLHRoaXMuX2RQYWRMZWZ0PTAsdGhpcy5fZFBhZFJpZ2h0PTB9cmV0dXJuIF9fZXh0ZW5kcyhiLGEpLGIucHJvdG90eXBlLm9ubGVmdHRyaWdnZXJjaGFuZ2VkPWZ1bmN0aW9uKGEpe3RoaXMuX29ubGVmdHRyaWdnZXJjaGFuZ2VkPWF9LGIucHJvdG90eXBlLm9ucmlnaHR0cmlnZ2VyY2hhbmdlZD1mdW5jdGlvbihhKXt0aGlzLl9vbnJpZ2h0dHJpZ2dlcmNoYW5nZWQ9YX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwibGVmdFRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlZnRUcmlnZ2VyfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fb25sZWZ0dHJpZ2dlcmNoYW5nZWQmJnRoaXMuX2xlZnRUcmlnZ2VyIT09YSYmdGhpcy5fb25sZWZ0dHJpZ2dlcmNoYW5nZWQoYSksdGhpcy5fbGVmdFRyaWdnZXI9YX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJyaWdodFRyaWdnZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JpZ2h0VHJpZ2dlcn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX29ucmlnaHR0cmlnZ2VyY2hhbmdlZCYmdGhpcy5fcmlnaHRUcmlnZ2VyIT09YSYmdGhpcy5fb25yaWdodHRyaWdnZXJjaGFuZ2VkKGEpLHRoaXMuX3JpZ2h0VHJpZ2dlcj1hfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGIucHJvdG90eXBlLm9uYnV0dG9uZG93bj1mdW5jdGlvbihhKXt0aGlzLl9vbmJ1dHRvbmRvd249YX0sYi5wcm90b3R5cGUub25idXR0b251cD1mdW5jdGlvbihhKXt0aGlzLl9vbmJ1dHRvbnVwPWF9LGIucHJvdG90eXBlLm9uZHBhZGRvd249ZnVuY3Rpb24oYSl7dGhpcy5fb25kcGFkZG93bj1hfSxiLnByb3RvdHlwZS5vbmRwYWR1cD1mdW5jdGlvbihhKXt0aGlzLl9vbmRwYWR1cD1hfSxiLnByb3RvdHlwZS5fc2V0QnV0dG9uVmFsdWU9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhIT09YiYmKHRoaXMuX29uYnV0dG9uZG93biYmMT09PWEmJnRoaXMuX29uYnV0dG9uZG93bihjKSx0aGlzLl9vbmJ1dHRvbnVwJiYwPT09YSYmdGhpcy5fb25idXR0b251cChjKSksYX0sYi5wcm90b3R5cGUuX3NldERQYWRWYWx1ZT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEhPT1iJiYodGhpcy5fb25kcGFkZG93biYmMT09PWEmJnRoaXMuX29uZHBhZGRvd24oYyksdGhpcy5fb25kcGFkdXAmJjA9PT1hJiZ0aGlzLl9vbmRwYWR1cChjKSksYX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uQVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uQX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvbkE9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25BLDApfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvbkJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbkJ9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9idXR0b25CPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uQiwxKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25YXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25YfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fYnV0dG9uWD10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvblgsMil9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uWVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uWX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvblk9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25ZLDMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvblN0YXJ0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25TdGFydH0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvblN0YXJ0PXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uU3RhcnQsNCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uQmFja1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnV0dG9uQmFja30sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvbkJhY2s9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25CYWNrLDUpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImJ1dHRvbkxCXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25MQn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvbkxCPXRoaXMuX3NldEJ1dHRvblZhbHVlKGEsdGhpcy5fYnV0dG9uTEIsNil9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiYnV0dG9uUkJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvblJCfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fYnV0dG9uUkI9dGhpcy5fc2V0QnV0dG9uVmFsdWUoYSx0aGlzLl9idXR0b25SQiw3KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25MZWZ0U3RpY2tcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1dHRvbkxlZnRTdGlja30sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2J1dHRvbkxlZnRTdGljaz10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvbkxlZnRTdGljayw4KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJidXR0b25SaWdodFN0aWNrXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9idXR0b25SaWdodFN0aWNrfSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fYnV0dG9uUmlnaHRTdGljaz10aGlzLl9zZXRCdXR0b25WYWx1ZShhLHRoaXMuX2J1dHRvblJpZ2h0U3RpY2ssOSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGIucHJvdG90eXBlLFwiZFBhZFVwXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kUGFkVXB9LHNldDpmdW5jdGlvbihhKXt0aGlzLl9kUGFkVXA9dGhpcy5fc2V0RFBhZFZhbHVlKGEsdGhpcy5fZFBhZFVwLDApfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImRQYWREb3duXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kUGFkRG93bn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2RQYWREb3duPXRoaXMuX3NldERQYWRWYWx1ZShhLHRoaXMuX2RQYWREb3duLDEpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImRQYWRMZWZ0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kUGFkTGVmdH0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuX2RQYWRMZWZ0PXRoaXMuX3NldERQYWRWYWx1ZShhLHRoaXMuX2RQYWRMZWZ0LDIpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcImRQYWRSaWdodFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZFBhZFJpZ2h0fSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5fZFBhZFJpZ2h0PXRoaXMuX3NldERQYWRWYWx1ZShhLHRoaXMuX2RQYWRSaWdodCwzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxiLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXthLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKSx0aGlzLmJ1dHRvbkE9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzBdLnZhbHVlLHRoaXMuYnV0dG9uQj10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMV0udmFsdWUsdGhpcy5idXR0b25YPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1syXS52YWx1ZSx0aGlzLmJ1dHRvblk9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzNdLnZhbHVlLHRoaXMuYnV0dG9uTEI9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzRdLnZhbHVlLHRoaXMuYnV0dG9uUkI9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzVdLnZhbHVlLHRoaXMubGVmdFRyaWdnZXI9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzZdLnZhbHVlLHRoaXMucmlnaHRUcmlnZ2VyPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1s3XS52YWx1ZSx0aGlzLmJ1dHRvbkJhY2s9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzhdLnZhbHVlLHRoaXMuYnV0dG9uU3RhcnQ9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzldLnZhbHVlLHRoaXMuYnV0dG9uTGVmdFN0aWNrPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1sxMF0udmFsdWUsdGhpcy5idXR0b25SaWdodFN0aWNrPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1sxMV0udmFsdWUsdGhpcy5kUGFkVXA9dGhpcy5icm93c2VyR2FtZXBhZC5idXR0b25zWzEyXS52YWx1ZSx0aGlzLmRQYWREb3duPXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1sxM10udmFsdWUsdGhpcy5kUGFkTGVmdD10aGlzLmJyb3dzZXJHYW1lcGFkLmJ1dHRvbnNbMTRdLnZhbHVlLHRoaXMuZFBhZFJpZ2h0PXRoaXMuYnJvd3NlckdhbWVwYWQuYnV0dG9uc1sxNV0udmFsdWV9LGJ9KGQpKTthLlhib3gzNjBQYWQ9Zn0oQkFCWUxPTnx8KEJBQllMT049e30pKTt2YXIgX19leHRlbmRzPXRoaXMuX19leHRlbmRzfHxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt0aGlzLmNvbnN0cnVjdG9yPWF9Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGFbZF09YltkXSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsYS5wcm90b3R5cGU9bmV3IGN9LEJBQllMT047IWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkLGUpe3ZhciBmPXRoaXM7Yi5jYWxsKHRoaXMsYyxkLGUpLHRoaXMuYW5ndWxhclNlbnNpYmlsaXR5PTIwMCx0aGlzLm1vdmVTZW5zaWJpbGl0eT03NSx0aGlzLl9nYW1lcGFkcz1uZXcgYS5HYW1lcGFkcyhmdW5jdGlvbihhKXtmLl9vbk5ld0dhbWVDb25uZWN0ZWQoYSl9KX1yZXR1cm4gX19leHRlbmRzKGMsYiksYy5wcm90b3R5cGUuX29uTmV3R2FtZUNvbm5lY3RlZD1mdW5jdGlvbihhKXswPT09YS5pbmRleCYmKHRoaXMuX2dhbWVwYWQ9YSl9LGMucHJvdG90eXBlLl9jaGVja0lucHV0cz1mdW5jdGlvbigpe2lmKHRoaXMuX2dhbWVwYWQpe3ZhciBiPXRoaXMuX2dhbWVwYWQubGVmdFN0aWNrLGM9Yi54L3RoaXMubW92ZVNlbnNpYmlsaXR5LGQ9Yi55L3RoaXMubW92ZVNlbnNpYmlsaXR5O2IueD1NYXRoLmFicyhjKT4uMDA1PzArYzowLGIueT1NYXRoLmFicyhkKT4uMDA1PzArZDowO3ZhciBlPXRoaXMuX2dhbWVwYWQucmlnaHRTdGljayxmPWUueC90aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eSxnPWUueS90aGlzLmFuZ3VsYXJTZW5zaWJpbGl0eTtlLng9TWF0aC5hYnMoZik+LjAwMT8wK2Y6MCxlLnk9TWF0aC5hYnMoZyk+LjAwMT8wK2c6MDt2YXIgaD1hLk1hdHJpeC5Sb3RhdGlvbllhd1BpdGNoUm9sbCh0aGlzLnJvdGF0aW9uLnksdGhpcy5yb3RhdGlvbi54LDApLGk9YS5WZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzKG5ldyBhLlZlY3RvcjMoYi54LDAsLWIueSksaCk7dGhpcy5jYW1lcmFEaXJlY3Rpb249dGhpcy5jYW1lcmFEaXJlY3Rpb24uYWRkKGkpLHRoaXMuY2FtZXJhUm90YXRpb249dGhpcy5jYW1lcmFSb3RhdGlvbi5hZGQobmV3IGEuVmVjdG9yMyhlLnksZS54LDApKX19LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLl9nYW1lcGFkcy5kaXNwb3NlKCl9LGN9KGEuRnJlZUNhbWVyYSk7YS5HYW1lcGFkQ2FtZXJhPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7dmFyIF9fZXh0ZW5kcz10aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dGhpcy5jb25zdHJ1Y3Rvcj1hfWZvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhW2RdPWJbZF0pO2MucHJvdG90eXBlPWIucHJvdG90eXBlLGEucHJvdG90eXBlPW5ldyBjfSxCQUJZTE9OOyFmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCxlKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgZSYmKGU9ITEpLGIuY2FsbCh0aGlzLGMsZCksdGhpcy5jb2xvcj1uZXcgYS5Db2xvcjMoMSwxLDEpLHRoaXMuX2luZGljZXM9bmV3IEFycmF5LHRoaXMuX2NvbG9yU2hhZGVyPW5ldyBhLlNoYWRlck1hdGVyaWFsKFwiY29sb3JTaGFkZXJcIixkLFwiY29sb3JcIix7YXR0cmlidXRlczpbXCJwb3NpdGlvblwiXSx1bmlmb3JtczpbXCJ3b3JsZFZpZXdQcm9qZWN0aW9uXCIsXCJjb2xvclwiXX0pfXJldHVybiBfX2V4dGVuZHMoYyxiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJtYXRlcmlhbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29sb3JTaGFkZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGMucHJvdG90eXBlLFwiaXNQaWNrYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5wcm90b3R5cGUsXCJjaGVja0NvbGxpc2lvbnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksYy5wcm90b3R5cGUuX2JpbmQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmdldFNjZW5lKCkuZ2V0RW5naW5lKCksYz10aGlzLl9nZW9tZXRyeS5nZXRJbmRleEJ1ZmZlcigpO2IuYmluZEJ1ZmZlcnModGhpcy5fZ2VvbWV0cnkuZ2V0VmVydGV4QnVmZmVyKGEuVmVydGV4QnVmZmVyLlBvc2l0aW9uS2luZCkuZ2V0QnVmZmVyKCksYyxbM10sMTIsdGhpcy5fY29sb3JTaGFkZXIuZ2V0RWZmZWN0KCkpLHRoaXMuX2NvbG9yU2hhZGVyLnNldENvbG9yMyhcImNvbG9yXCIsdGhpcy5jb2xvcil9LGMucHJvdG90eXBlLl9kcmF3PWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2dlb21ldHJ5JiZ0aGlzLl9nZW9tZXRyeS5nZXRWZXJ0ZXhCdWZmZXJzKCkmJnRoaXMuX2dlb21ldHJ5LmdldEluZGV4QnVmZmVyKCkpe3ZhciBiPXRoaXMuZ2V0U2NlbmUoKS5nZXRFbmdpbmUoKTtiLmRyYXcoITEsYS5pbmRleFN0YXJ0LGEuaW5kZXhDb3VudCl9fSxjLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGMucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oYSl7dGhpcy5fY29sb3JTaGFkZXIuZGlzcG9zZSgpLGIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzLGEpfSxjfShhLk1lc2gpO2EuTGluZXNNZXNoPWJ9KEJBQllMT058fChCQUJZTE9OPXt9KSk7bW9kdWxlLmV4cG9ydHM9QkFCWUxPTjsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMTEuMlxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMTItMTdUMTU6MjdaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIHdpbmRvdyBpcyBwcmVzZW50LFxuXHRcdC8vIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnlcblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGluaGVyZW50bHkgcG9zc2VzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBqUXVlcnktbWFraW5nIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHNcblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIHdpbmRvd1xuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gQ2FuJ3QgZG8gdGhpcyBiZWNhdXNlIHNldmVyYWwgYXBwcyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy9cblxudmFyIGRlbGV0ZWRJZHMgPSBbXTtcblxudmFyIHNsaWNlID0gZGVsZXRlZElkcy5zbGljZTtcblxudmFyIGNvbmNhdCA9IGRlbGV0ZWRJZHMuY29uY2F0O1xuXG52YXIgcHVzaCA9IGRlbGV0ZWRJZHMucHVzaDtcblxudmFyIGluZGV4T2YgPSBkZWxldGVkSWRzLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjEuMTEuMlwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIElFPDlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGRlbGV0ZWRJZHMuc29ydCxcblx0c3BsaWNlOiBkZWxldGVkSWRzLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNyYywgY29weUlzQXJyYXksIGNvcHksIG5hbWUsIG9wdGlvbnMsIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuXHQvLyBTaW5jZSB2ZXJzaW9uIDEuMywgRE9NIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyBsaWtlIGFsZXJ0XG5cdC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAob2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKyAxKSA+PSAwO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdC8vIE11c3QgYmUgYW4gT2JqZWN0LlxuXHRcdC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG5cdFx0aWYgKCAhb2JqIHx8IGpRdWVyeS50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0Ly8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEhhbmRsZSBpdGVyYXRpb24gb3ZlciBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuXG5cdFx0aWYgKCBzdXBwb3J0Lm93bkxhc3QgKSB7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRyZXR1cm4gaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdFx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdFx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKG9iaikgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Ly8gV29ya2Fyb3VuZHMgYmFzZWQgb24gZmluZGluZ3MgYnkgSmltIERyaXNjb2xsXG5cdC8vIGh0dHA6Ly93ZWJsb2dzLmphdmEubmV0L2Jsb2cvZHJpc2NvbGwvYXJjaGl2ZS8yMDA5LzA5LzA4L2V2YWwtamF2YXNjcmlwdC1nbG9iYWwtY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRpZiAoIGRhdGEgJiYgalF1ZXJ5LnRyaW0oIGRhdGEgKSApIHtcblx0XHRcdC8vIFdlIHVzZSBleGVjU2NyaXB0IG9uIEludGVybmV0IEV4cGxvcmVyXG5cdFx0XHQvLyBXZSB1c2UgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHNvIHRoYXQgY29udGV4dCBpcyB3aW5kb3dcblx0XHRcdC8vIHJhdGhlciB0aGFuIGpRdWVyeSBpbiBGaXJlZm94XG5cdFx0XHQoIHdpbmRvdy5leGVjU2NyaXB0IHx8IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHR3aW5kb3dbIFwiZXZhbFwiIF0uY2FsbCggd2luZG93LCBkYXRhICk7XG5cdFx0XHR9ICkoIGRhdGEgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0Ly8gYXJncyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjaywgYXJncyApIHtcblx0XHR2YXIgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIG9iaiApO1xuXG5cdFx0aWYgKCBhcmdzICkge1xuXHRcdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQSBzcGVjaWFsLCBmYXN0LCBjYXNlIGZvciB0aGUgbW9zdCBjb21tb24gdXNlIG9mIGVhY2hcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIElFPDlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheWxpa2UoIE9iamVjdChhcnIpICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0dmFyIGxlbjtcblxuXHRcdGlmICggYXJyICkge1xuXHRcdFx0aWYgKCBpbmRleE9mICkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGkgPSBpID8gaSA8IDAgPyBNYXRoLm1heCggMCwgbGVuICsgaSApIDogaSA6IDA7XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHQvLyBTa2lwIGFjY2Vzc2luZyBpbiBzcGFyc2UgYXJyYXlzXG5cdFx0XHRcdGlmICggaSBpbiBhcnIgJiYgYXJyWyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdHdoaWxlICggaiA8IGxlbiApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIFdvcmthcm91bmQgY2FzdGluZyBvZiAubGVuZ3RoIHRvIE5hTiBvbiBvdGhlcndpc2UgYXJyYXlsaWtlIG9iamVjdHMgKGUuZy4sIE5vZGVMaXN0cylcblx0XHRpZiAoIGxlbiAhPT0gbGVuICkge1xuXHRcdFx0d2hpbGUgKCBzZWNvbmRbal0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqKysgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciBhcmdzLCBwcm94eSwgdG1wO1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKyggbmV3IERhdGUoKSApO1xuXHR9LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59KTtcblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuZnVuY3Rpb24gaXNBcnJheWxpa2UoIG9iaiApIHtcblx0dmFyIGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggb2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjAtcHJlXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA4LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMTItMTZcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHQvLyBQcm9wZXIgc3ludGF4OiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncjXCIgKSxcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3KlwiICkgKyBcIilcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcblx0XHQvLyBRU0EgdmFyc1xuXHRcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xuXG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0aWYgKCAhc2VlZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgd2hlbiBwb3NzaWJsZSAoZS5nLiwgbm90IHVuZGVyIERvY3VtZW50RnJhZ21lbnQpXG5cdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFFTQSBwYXRoXG5cdFx0aWYgKCBzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0bmlkID0gb2xkID0gZXhwYW5kbztcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdGlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpICkge1xuXHRcdFx0XHRcdG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcblxuXHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gU2V0IG91ciBkb2N1bWVudFxuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIFN1cHBvcnQgdGVzdHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jLnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2MgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMV07XG5cblx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBubyBzZWVkIGFuZCBvbmx5IG9uZSBncm91cFxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0cnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICgvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8pO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBqUXVlcnkuaW5BcnJheSggZWxlbSwgcXVhbGlmaWVyICkgPj0gMCApICE9PSBub3Q7XG5cdH0pO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9KSk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcyxcblx0XHRcdGxlbiA9IHNlbGYubGVuZ3RoO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuXHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBzZWxlY3RvciA6IHNlbGVjdG9yO1xuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcblx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3IuY2hhckF0KDApID09PSBcIjxcIiAmJiBzZWxlY3Rvci5jaGFyQXQoIHNlbGVjdG9yLmxlbmd0aCAtIDEgKSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsyXSApO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCAhPT0gbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByb290alF1ZXJ5LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiByb290alF1ZXJ5LnJlYWR5ICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0cm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblx0Ly8gbWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHRcdGN1ciA9IGVsZW1bIGRpciBdO1xuXG5cdFx0d2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KCBjdXIgKS5pcyggdW50aWwgKSkgKSB7XG5cdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdH1cblx0XHRcdGN1ciA9IGN1cltkaXJdO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fSxcblxuXHRzaWJsaW5nOiBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgciA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRyLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGxlbiA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbaV0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Zm9yICggY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmIChwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleChjdXIpID4gLTEgOlxuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoY3VyLCBzZWxlY3RvcnMpKSApIHtcblxuXHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWUoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluXG5cdC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBpbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoIHRoaXNbMF0sIGpRdWVyeSggZWxlbSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KFxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzICk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZShcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0ZG8ge1xuXHRcdGN1ciA9IGN1clsgZGlyIF07XG5cdH0gd2hpbGUgKCBjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSAxICk7XG5cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goe1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgP1xuXHRcdFx0ZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50IDpcblx0XHRcdGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRyZXQgPSBqUXVlcnkudW5pcXVlKCByZXQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0ID0gcmV0LnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSk7XG52YXIgcm5vdHdoaXRlID0gKC9cXFMrL2cpO1xuXG5cblxuLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxudmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0KCBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSB8fCBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgKGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHMpXG5cdFx0bWVtb3J5LFxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cdFx0Ly8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXG5cdFx0ZmlyaW5nTGVuZ3RoLFxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXgsXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXG5cdFx0ZmlyaW5nU3RhcnQsXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cdFx0Ly8gU3RhY2sgb2YgZmlyZSBjYWxscyBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XG5cdFx0XHRmaXJlZCA9IHRydWU7XG5cdFx0XHRmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XG5cdFx0XHRmaXJpbmdTdGFydCA9IDA7XG5cdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XG5cdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTsgLy8gVG8gcHJldmVudCBmdXJ0aGVyIGNhbGxzIHVzaW5nIGFkZFxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBzdGFjayApIHtcblx0XHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGZpcmUoIHN0YWNrLnNoaWZ0KCkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHQvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQoZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHQvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZVxuXHRcdFx0XHRcdC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0Ly8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXlcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdTdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0ZmlyZSggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdMZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOiAhISggbGlzdCAmJiBsaXN0Lmxlbmd0aCApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHRmaXJpbmdMZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBIYXZlIHRoZSBsaXN0IGRvIG5vdGhpbmcgYW55bW9yZVxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgZGlzYWJsZWQ/XG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3RhY2sgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBsb2NrZWQ/XG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIXN0YWNrO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCBsaXN0ICYmICggIWZpcmVkIHx8IHN0YWNrICkgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZmlyZSggYXJncyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMV0gXShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9KTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISgtLXJlbWFpbmluZykgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0IClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59KTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuXHRcdGlmICggIWRvY3VtZW50LmJvZHkgKSB7XG5cdFx0XHRyZXR1cm4gc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBDbGVhbi11cCBtZXRob2QgZm9yIGRvbSByZWFkeSBldmVudHNcbiAqL1xuZnVuY3Rpb24gZGV0YWNoKCkge1xuXHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHR9IGVsc2Uge1xuXHRcdGRvY3VtZW50LmRldGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBjb21wbGV0ZWQgKTtcblx0XHR3aW5kb3cuZGV0YWNoRXZlbnQoIFwib25sb2FkXCIsIGNvbXBsZXRlZCApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHQvLyByZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgaXMgZ29vZCBlbm91Z2ggZm9yIHVzIHRvIGNhbGwgdGhlIGRvbSByZWFkeSBpbiBvbGRJRVxuXHRpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgfHwgZXZlbnQudHlwZSA9PT0gXCJsb2FkXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdGRldGFjaCgpO1xuXHRcdGpRdWVyeS5yZWFkeSgpO1xuXHR9XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyB3ZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0Ly8gU3RhbmRhcmRzLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnQgRE9NQ29udGVudExvYWRlZFxuXHRcdH0gZWxzZSBpZiAoIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0XHQvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCwgbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG5cdFx0XHRkb2N1bWVudC5hdHRhY2hFdmVudCggXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib25sb2FkXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0XHQvLyBJZiBJRSBhbmQgbm90IGEgZnJhbWVcblx0XHRcdC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcblx0XHRcdHZhciB0b3AgPSBmYWxzZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dG9wID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0XHRcdH0gY2F0Y2goZSkge31cblxuXHRcdFx0aWYgKCB0b3AgJiYgdG9wLmRvU2Nyb2xsICkge1xuXHRcdFx0XHQoZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuaXNSZWFkeSApIHtcblxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSB0cmljayBieSBEaWVnbyBQZXJpbmlcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cblx0XHRcdFx0XHRcdFx0dG9wLmRvU2Nyb2xsKFwibGVmdFwiKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgNTAgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZGV0YWNoIGFsbCBkb20gcmVhZHkgZXZlbnRzXG5cdFx0XHRcdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0XHRcdFx0Ly8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdFx0XHRcdFx0XHRqUXVlcnkucmVhZHkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG5cbnZhciBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkO1xuXG5cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gSXRlcmF0aW9uIG92ZXIgb2JqZWN0J3MgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIGl0cyBvd25cbnZhciBpO1xuZm9yICggaSBpbiBqUXVlcnkoIHN1cHBvcnQgKSApIHtcblx0YnJlYWs7XG59XG5zdXBwb3J0Lm93bkxhc3QgPSBpICE9PSBcIjBcIjtcblxuLy8gTm90ZTogbW9zdCBzdXBwb3J0IHRlc3RzIGFyZSBkZWZpbmVkIGluIHRoZWlyIHJlc3BlY3RpdmUgbW9kdWxlcy5cbi8vIGZhbHNlIHVudGlsIHRoZSB0ZXN0IGlzIHJ1blxuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gZmFsc2U7XG5cbi8vIEV4ZWN1dGUgQVNBUCBpbiBjYXNlIHdlIG5lZWQgdG8gc2V0IGJvZHkuc3R5bGUuem9vbVxualF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHQvLyBNaW5pZmllZDogdmFyIGEsYixjLGRcblx0dmFyIHZhbCwgZGl2LCBib2R5LCBjb250YWluZXI7XG5cblx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdGlmICggIWJvZHkgfHwgIWJvZHkuc3R5bGUgKSB7XG5cdFx0Ly8gUmV0dXJuIGZvciBmcmFtZXNldCBkb2NzIHRoYXQgZG9uJ3QgaGF2ZSBhIGJvZHlcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTZXR1cFxuXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4XCI7XG5cdGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRpZiAoIHR5cGVvZiBkaXYuc3R5bGUuem9vbSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHQvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcblx0XHQvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG5cdFx0Ly8gdGhlbSBsYXlvdXRcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwiZGlzcGxheTppbmxpbmU7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzoxcHg7d2lkdGg6MXB4O3pvb206MVwiO1xuXG5cdFx0c3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gdmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzO1xuXHRcdGlmICggdmFsICkge1xuXHRcdFx0Ly8gUHJldmVudCBJRSA2IGZyb20gYWZmZWN0aW5nIGxheW91dCBmb3IgcG9zaXRpb25lZCBlbGVtZW50cyAjMTEwNDhcblx0XHRcdC8vIFByZXZlbnQgSUUgZnJvbSBzaHJpbmtpbmcgdGhlIGJvZHkgaW4gSUUgNyBtb2RlICMxMjg2OVxuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0Ym9keS5zdHlsZS56b29tID0gMTtcblx0XHR9XG5cdH1cblxuXHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcbn0pO1xuXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRXhlY3V0ZSB0aGUgdGVzdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4ZWN1dGVkIGluIGFub3RoZXIgbW9kdWxlLlxuXHRpZiAoc3VwcG9ydC5kZWxldGVFeHBhbmRvID09IG51bGwpIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFLlxuXHRkaXYgPSBudWxsO1xufSkoKTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5qUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9EYXRhID0galF1ZXJ5Lm5vRGF0YVsgKGVsZW0ubm9kZU5hbWUgKyBcIiBcIikudG9Mb3dlckNhc2UoKSBdLFxuXHRcdG5vZGVUeXBlID0gK2VsZW0ubm9kZVR5cGUgfHwgMTtcblxuXHQvLyBEbyBub3Qgc2V0IGRhdGEgb24gbm9uLWVsZW1lbnQgRE9NIG5vZGVzIGJlY2F1c2UgaXQgd2lsbCBub3QgYmUgY2xlYXJlZCAoIzgzMzUpLlxuXHRyZXR1cm4gbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgP1xuXHRcdGZhbHNlIDpcblxuXHRcdC8vIE5vZGVzIGFjY2VwdCBkYXRhIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkOyByZWplY3Rpb24gY2FuIGJlIGNvbmRpdGlvbmFsXG5cdFx0IW5vRGF0YSB8fCBub0RhdGEgIT09IHRydWUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpID09PSBub0RhdGE7XG59O1xuXG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0dmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW0sIGtleSwgZGF0YSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbi8vIGNoZWNrcyBhIGNhY2hlIG9iamVjdCBmb3IgZW1wdGluZXNzXG5mdW5jdGlvbiBpc0VtcHR5RGF0YU9iamVjdCggb2JqICkge1xuXHR2YXIgbmFtZTtcblx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cblx0XHQvLyBpZiB0aGUgcHVibGljIGRhdGEgb2JqZWN0IGlzIGVtcHR5LCB0aGUgcHJpdmF0ZSBpcyBzdGlsbCBlbXB0eVxuXHRcdGlmICggbmFtZSA9PT0gXCJkYXRhXCIgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9ialtuYW1lXSApICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggbmFtZSAhPT0gXCJ0b0pTT05cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJldCwgdGhpc0NhY2hlLFxuXHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cblx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdC8vIGNhbid0IEdDIG9iamVjdCByZWZlcmVuY2VzIHByb3Blcmx5IGFjcm9zcyB0aGUgRE9NLUpTIGJvdW5kYXJ5XG5cdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0Ly8gYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBzbyBHQyBjYW4gb2NjdXIgYXV0b21hdGljYWxseVxuXHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblxuXHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdC8vIHRoZSBjb2RlIHRvIHNob3J0Y3V0IG9uIHRoZSBzYW1lIHBhdGggYXMgYSBET00gbm9kZSB3aXRoIG5vIGNhY2hlXG5cdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogZWxlbVsgaW50ZXJuYWxLZXkgXSAmJiBpbnRlcm5hbEtleTtcblxuXHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHQvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGxcblx0aWYgKCAoIWlkIHx8ICFjYWNoZVtpZF0gfHwgKCFwdnQgJiYgIWNhY2hlW2lkXS5kYXRhKSkgJiYgZGF0YSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggIWlkICkge1xuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgYSBuZXcgdW5pcXVlIElEIGZvciBlYWNoIGVsZW1lbnQgc2luY2UgdGhlaXIgZGF0YVxuXHRcdC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuXHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdID0gZGVsZXRlZElkcy5wb3AoKSB8fCBqUXVlcnkuZ3VpZCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZCA9IGludGVybmFsS2V5O1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdC8vIEF2b2lkIGV4cG9zaW5nIGpRdWVyeSBtZXRhZGF0YSBvbiBwbGFpbiBKUyBvYmplY3RzIHdoZW4gdGhlIG9iamVjdFxuXHRcdC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcblx0XHRjYWNoZVsgaWQgXSA9IGlzTm9kZSA/IHt9IDogeyB0b0pTT046IGpRdWVyeS5ub29wIH07XG5cdH1cblxuXHQvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0c1xuXHQvLyBzaGFsbG93IGNvcGllZCBvdmVyIG9udG8gdGhlIGV4aXN0aW5nIGNhY2hlXG5cdGlmICggdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRpZiAoIHB2dCApIHtcblx0XHRcdGNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVbIGlkIF0uZGF0YSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLmRhdGEsIG5hbWUgKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcblxuXHQvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGFcblx0Ly8gY2FjaGUgaW4gb3JkZXIgdG8gYXZvaWQga2V5IGNvbGxpc2lvbnMgYmV0d2VlbiBpbnRlcm5hbCBkYXRhIGFuZCB1c2VyLWRlZmluZWRcblx0Ly8gZGF0YS5cblx0aWYgKCAhcHZ0ICkge1xuXHRcdGlmICggIXRoaXNDYWNoZS5kYXRhICkge1xuXHRcdFx0dGhpc0NhY2hlLmRhdGEgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUuZGF0YTtcblx0fVxuXG5cdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF0gPSBkYXRhO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIGJvdGggY29udmVydGVkLXRvLWNhbWVsIGFuZCBub24tY29udmVydGVkIGRhdGEgcHJvcGVydHkgbmFtZXNcblx0Ly8gSWYgYSBkYXRhIHByb3BlcnR5IHdhcyBzcGVjaWZpZWRcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRyZXQgPSB0aGlzQ2FjaGVbIG5hbWUgXTtcblxuXHRcdC8vIFRlc3QgZm9yIG51bGx8dW5kZWZpbmVkIHByb3BlcnR5IGRhdGFcblx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHQvLyBUcnkgdG8gZmluZCB0aGUgY2FtZWxDYXNlZCBwcm9wZXJ0eVxuXHRcdFx0cmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gdGhpc0NhY2hlO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7XG5cdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHRoaXNDYWNoZSwgaSxcblx0XHRpc05vZGUgPSBlbGVtLm5vZGVUeXBlLFxuXG5cdFx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdFx0Y2FjaGUgPSBpc05vZGUgPyBqUXVlcnkuY2FjaGUgOiBlbGVtLFxuXHRcdGlkID0gaXNOb2RlID8gZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXSA6IGpRdWVyeS5leHBhbmRvO1xuXG5cdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgbm8gY2FjaGUgZW50cnkgZm9yIHRoaXMgb2JqZWN0LCB0aGVyZSBpcyBub1xuXHQvLyBwdXJwb3NlIGluIGNvbnRpbnVpbmdcblx0aWYgKCAhY2FjaGVbIGlkIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBuYW1lICkge1xuXG5cdFx0dGhpc0NhY2hlID0gcHZ0ID8gY2FjaGVbIGlkIF0gOiBjYWNoZVsgaWQgXS5kYXRhO1xuXG5cdFx0aWYgKCB0aGlzQ2FjaGUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG5cdFx0XHRpZiAoICFqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXG5cdFx0XHRcdC8vIHRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzXG5cdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblx0XHRcdFx0XHRpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVtpXSBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlXG5cdFx0XHQvLyBhbmQgbGV0IHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmIGdldCBkZXN0cm95ZWRcblx0XHRcdGlmICggcHZ0ID8gIWlzRW1wdHlEYXRhT2JqZWN0KHRoaXNDYWNoZSkgOiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QodGhpc0NhY2hlKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRpZiAoICFwdnQgKSB7XG5cdFx0ZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHQvLyBEb24ndCBkZXN0cm95IHRoZSBwYXJlbnQgY2FjaGUgdW5sZXNzIHRoZSBpbnRlcm5hbCBkYXRhIG9iamVjdFxuXHRcdC8vIGhhZCBiZWVuIHRoZSBvbmx5IHRoaW5nIGxlZnQgaW4gaXRcblx0XHRpZiAoICFpc0VtcHR5RGF0YU9iamVjdCggY2FjaGVbIGlkIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHQvLyBEZXN0cm95IHRoZSBjYWNoZVxuXHRpZiAoIGlzTm9kZSApIHtcblx0XHRqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXG5cdC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuXHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHR9IGVsc2UgaWYgKCBzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgY2FjaGUgIT0gY2FjaGUud2luZG93ICkge1xuXHRcdC8qIGpzaGludCBlcWVxZXE6IHRydWUgKi9cblx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0Ly8gV2hlbiBhbGwgZWxzZSBmYWlscywgbnVsbFxuXHR9IGVsc2Uge1xuXHRcdGNhY2hlWyBpZCBdID0gbnVsbDtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2FjaGU6IHt9LFxuXG5cdC8vIFRoZSBmb2xsb3dpbmcgZWxlbWVudHMgKHNwYWNlLXN1ZmZpeGVkIHRvIGF2b2lkIE9iamVjdC5wcm90b3R5cGUgY29sbGlzaW9ucylcblx0Ly8gdGhyb3cgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyBpZiB5b3UgYXR0ZW1wdCB0byBzZXQgZXhwYW5kbyBwcm9wZXJ0aWVzXG5cdG5vRGF0YToge1xuXHRcdFwiYXBwbGV0IFwiOiB0cnVlLFxuXHRcdFwiZW1iZWQgXCI6IHRydWUsXG5cdFx0Ly8gLi4uYnV0IEZsYXNoIG9iamVjdHMgKHdoaWNoIGhhdmUgdGhpcyBjbGFzc2lkKSAqY2FuKiBoYW5kbGUgZXhwYW5kb3Ncblx0XHRcIm9iamVjdCBcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIlxuXHR9LFxuXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGVsZW0gPSBlbGVtLm5vZGVUeXBlID8galF1ZXJ5LmNhY2hlWyBlbGVtW2pRdWVyeS5leHBhbmRvXSBdIDogZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gISFlbGVtICYmICFpc0VtcHR5RGF0YU9iamVjdCggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCB0cnVlICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1swXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBTcGVjaWFsIGV4cGVjdGlvbnMgb2YgLmRhdGEgYmFzaWNhbGx5IHRod2FydCBqUXVlcnkuYWNjZXNzLFxuXHRcdC8vIHNvIGltcGxlbWVudCB0aGUgcmVsZXZhbnQgYmVoYXZpb3Igb3Vyc2VsdmVzXG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKDUpICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgP1xuXG5cdFx0XHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSkgOlxuXG5cdFx0XHQvLyBHZXRzIG9uZSB2YWx1ZVxuXHRcdFx0Ly8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XG5cdFx0XHRlbGVtID8gZGF0YUF0dHIoIGVsZW0sIGtleSwgalF1ZXJ5LmRhdGEoIGVsZW0sIGtleSApICkgOiB1bmRlZmluZWQ7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMsIGtleSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0XHRcdHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlXCIgKTtcblx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBrZXkgKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBlbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0galF1ZXJ5Ll9kYXRhKCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdC8vIE1pbmlmaWVkOiB2YXIgYSxiLGNcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdC8vIFNldHVwXG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXG5cdC8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWRcblx0c3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSA9IGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRib2R5IGVsZW1lbnRzIGFyZW4ndCBhdXRvbWF0aWNhbGx5IGluc2VydGVkXG5cdC8vIElFIHdpbGwgaW5zZXJ0IHRoZW0gaW50byBlbXB0eSB0YWJsZXNcblx0c3VwcG9ydC50Ym9keSA9ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApLmxlbmd0aDtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcblx0Ly8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuXHRzdXBwb3J0Lmh0bWxTZXJpYWxpemUgPSAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJsaW5rXCIgKS5sZW5ndGg7XG5cblx0Ly8gTWFrZXMgc3VyZSBjbG9uaW5nIGFuIGh0bWw1IGVsZW1lbnQgZG9lcyBub3QgY2F1c2UgcHJvYmxlbXNcblx0Ly8gV2hlcmUgb3V0ZXJIVE1MIGlzIHVuZGVmaW5lZCwgdGhpcyBzdGlsbCB3b3Jrc1xuXHRzdXBwb3J0Lmh0bWw1Q2xvbmUgPVxuXHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwibmF2XCIgKS5jbG9uZU5vZGUoIHRydWUgKS5vdXRlckhUTUwgIT09IFwiPDpuYXY+PC86bmF2PlwiO1xuXG5cdC8vIENoZWNrIGlmIGEgZGlzY29ubmVjdGVkIGNoZWNrYm94IHdpbGwgcmV0YWluIGl0cyBjaGVja2VkXG5cdC8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cdGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0c3VwcG9ydC5hcHBlbmRDaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcblxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHQvLyBTdXBwb3J0OiBJRTYtSUUxMStcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGVcblx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQgdHlwZT0ncmFkaW8nIGNoZWNrZWQ9J2NoZWNrZWQnIG5hbWU9J3QnLz5cIjtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNS4xLCBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHQvLyBPcGVyYSBkb2VzIG5vdCBjbG9uZSBldmVudHMgKGFuZCB0eXBlb2YgZGl2LmF0dGFjaEV2ZW50ID09PSB1bmRlZmluZWQpLlxuXHQvLyBJRTktMTAgY2xvbmVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQsIGJ1dCB0aGV5IGRvbid0IHRyaWdnZXIgd2l0aCAuY2xpY2soKVxuXHRzdXBwb3J0Lm5vQ2xvbmVFdmVudCA9IHRydWU7XG5cdGlmICggZGl2LmF0dGFjaEV2ZW50ICkge1xuXHRcdGRpdi5hdHRhY2hFdmVudCggXCJvbmNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbGljaygpO1xuXHR9XG5cblx0Ly8gRXhlY3V0ZSB0aGUgdGVzdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4ZWN1dGVkIGluIGFub3RoZXIgbW9kdWxlLlxuXHRpZiAoc3VwcG9ydC5kZWxldGVFeHBhbmRvID09IG51bGwpIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0XHR9XG5cdH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgaSwgZXZlbnROYW1lLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5IChsYWNrIHN1Ym1pdC9jaGFuZ2UgYnViYmxlKSwgRmlyZWZveCAyMysgKGxhY2sgZm9jdXNpbiBldmVudClcblx0Zm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgY2hhbmdlOiB0cnVlLCBmb2N1c2luOiB0cnVlIH0pIHtcblx0XHRldmVudE5hbWUgPSBcIm9uXCIgKyBpO1xuXG5cdFx0aWYgKCAhKHN1cHBvcnRbIGkgKyBcIkJ1YmJsZXNcIiBdID0gZXZlbnROYW1lIGluIHdpbmRvdykgKSB7XG5cdFx0XHQvLyBCZXdhcmUgb2YgQ1NQIHJlc3RyaWN0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQKVxuXHRcdFx0ZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lLCBcInRcIiApO1xuXHRcdFx0c3VwcG9ydFsgaSArIFwiQnViYmxlc1wiIF0gPSBkaXYuYXR0cmlidXRlc1sgZXZlbnROYW1lIF0uZXhwYW5kbyA9PT0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cblxudmFyIHJmb3JtRWxlbXMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXHRcdHZhciB0bXAsIGV2ZW50cywgdCwgaGFuZGxlT2JqSW4sXG5cdFx0XHRzcGVjaWFsLCBldmVudEhhbmRsZSwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBqUXVlcnkuX2RhdGEoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiAoIWUgfHwgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlKSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBldmVudEhhbmRsZS5lbGVtLCBhcmd1bWVudHMgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHRcdC8vIEFkZCBlbGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSBmbiB0byBwcmV2ZW50IGEgbWVtb3J5IGxlYWsgd2l0aCBJRSBub24tbmF0aXZlIGV2ZW50c1xuXHRcdFx0ZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lci9hdHRhY2hFdmVudCBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyBCaW5kIHRoZSBnbG9iYWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW0uYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmF0dGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE51bGxpZnkgZWxlbSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRVxuXHRcdGVsZW0gPSBudWxsO1xuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXHRcdHZhciBqLCBoYW5kbGVPYmosIHRtcCxcblx0XHRcdG9yaWdDb3VudCwgdCwgZXZlbnRzLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsXG5cdFx0XHRuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0galF1ZXJ5Lmhhc0RhdGEoIGVsZW0gKSAmJiBqUXVlcnkuX2RhdGEoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWzJdICYmIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGVsZXRlIGVsZW1EYXRhLmhhbmRsZTtcblxuXHRcdFx0Ly8gcmVtb3ZlRGF0YSBhbHNvIGNoZWNrcyBmb3IgZW1wdGluZXNzIGFuZCBjbGVhcnMgdGhlIGV4cGFuZG8gaWYgZW1wdHlcblx0XHRcdC8vIHNvIHVzZSBpdCBpbnN0ZWFkIG9mIGRlbGV0ZVxuXHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXHRcdHZhciBoYW5kbGUsIG9udHlwZSwgY3VyLFxuXHRcdFx0YnViYmxlVHlwZSwgc3BlY2lhbCwgdG1wLCBpLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZihcIi5cIikgPj0gMCApIHtcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKFwiOlwiKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFwiLlwiKTtcblx0XHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBqUXVlcnkuX2RhdGEoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBqUXVlcnkuX2RhdGEoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0alF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIENhbid0IHVzZSBhbiAuaXNGdW5jdGlvbigpIGNoZWNrIGhlcmUgYmVjYXVzZSBJRTYvNyBmYWlscyB0aGF0IHRlc3QuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgZWxlbVsgdHlwZSBdICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0Ly8gSUU8OSBkaWVzIG9uIGZvY3VzL2JsdXIgdG8gaGlkZGVuIGVsZW1lbnQgKCMxNDg2LCMxMjUxOClcblx0XHRcdFx0XHRcdC8vIG9ubHkgcmVwcm9kdWNpYmxlIG9uIHdpblhQIElFOCBuYXRpdmUsIG5vdCBJRTkgaW4gSUU4IG1vZGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIHJldCwgaGFuZGxlT2JqLCBtYXRjaGVkLCBqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbMF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoIChtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXG5cdFx0XHRcdC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXG5cdFx0XHRcdFx0XHRcdC5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBzZWwsIGhhbmRsZU9iaiwgbWF0Y2hlcywgaSxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBidWJibGluZyBpbiBGaXJlZm94ICgjMzg2MSlcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIikgKSB7XG5cblx0XHRcdC8qIGpzaGludCBlcWVxZXE6IGZhbHNlICovXG5cdFx0XHRmb3IgKCA7IGN1ciAhPSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXHRcdFx0XHQvKiBqc2hpbnQgZXFlcWVxOiB0cnVlICovXG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIikgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMCA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gRml4IHRhcmdldCBwcm9wZXJ0eSAoIzE5MjUpXG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSAyMyssIFNhZmFyaT9cblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzLCBtZXRhS2V5PT1mYWxzZSBpZiBpdCdzIHVuZGVmaW5lZCAoIzMzNjgsICMxMTMyOClcblx0XHRldmVudC5tZXRhS2V5ID0gISFldmVudC5tZXRhS2V5O1xuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBmcm9tRWxlbWVudCBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiLnNwbGl0KFwiIFwiKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgYm9keSwgZXZlbnREb2MsIGRvYyxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uLFxuXHRcdFx0XHRmcm9tRWxlbWVudCA9IG9yaWdpbmFsLmZyb21FbGVtZW50O1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArICggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICsgKCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoICFldmVudC5yZWxhdGVkVGFyZ2V0ICYmIGZyb21FbGVtZW50ICkge1xuXHRcdFx0XHRldmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IG9yaWdpbmFsLnRvRWxlbWVudCA6IGZyb21FbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgZXJyb3Igb24gZm9jdXMgdG8gaGlkZGVuIGVsZW1lbnQgKCMxNDg2LCAjMTI1MTgpLFxuXHRcdFx0XHRcdFx0Ly8gbGV0IC50cmlnZ2VyKCkgcnVuIHRoZSBoYW5kbGVyc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgJiYgdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG5cdGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdFx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0gOlxuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdHZhciBuYW1lID0gXCJvblwiICsgdHlwZTtcblxuXHRcdGlmICggZWxlbS5kZXRhY2hFdmVudCApIHtcblxuXHRcdFx0Ly8gIzg1NDUsICM3MDU0LCBwcmV2ZW50aW5nIG1lbW9yeSBsZWFrcyBmb3IgY3VzdG9tIGV2ZW50cyBpbiBJRTYtOFxuXHRcdFx0Ly8gZGV0YWNoRXZlbnQgbmVlZGVkIHByb3BlcnR5IG9uIGVsZW1lbnQsIGJ5IG5hbWUgb2YgdGhhdCBldmVudCwgdG8gcHJvcGVybHkgZXhwb3NlIGl0IHRvIEdDXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtWyBuYW1lIF0gPT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZWxlbVsgbmFtZSBdID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5kZXRhY2hFdmVudCggbmFtZSwgaGFuZGxlICk7XG5cdFx0fVxuXHR9O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDwgOSwgQW5kcm9pZCA8IDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXHRcdGlmICggIWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJldmVudERlZmF1bHQgZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBPdGhlcndpc2Ugc2V0IHRoZSByZXR1cm5WYWx1ZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZmFsc2Vcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXHRcdGlmICggIWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIElmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMsIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIFNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuaWYgKCAhc3VwcG9ydC5zdWJtaXRCdWJibGVzICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLnN1Ym1pdCA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBPbmx5IG5lZWQgdGhpcyBmb3IgZGVsZWdhdGVkIGZvcm0gc3VibWl0IGV2ZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBOb2RlIG5hbWUgY2hlY2sgYXZvaWRzIGEgVk1MLXJlbGF0ZWQgY3Jhc2ggaW4gSUUgKCM5ODA3KVxuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0LFxuXHRcdFx0XHRcdGZvcm0gPSBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApID8gZWxlbS5mb3JtIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoIGZvcm0gJiYgIWpRdWVyeS5fZGF0YSggZm9ybSwgXCJzdWJtaXRCdWJibGVzXCIgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBmb3JtLCBcInN1Ym1pdC5fc3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50Ll9zdWJtaXRfYnViYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0QnViYmxlc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBzaW5jZSB3ZSBkb24ndCBuZWVkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0fSxcblxuXHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Ly8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIGV2ZW50Ll9zdWJtaXRfYnViYmxlICkge1xuXHRcdFx0XHRkZWxldGUgZXZlbnQuX3N1Ym1pdF9idWJibGU7XG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcInN1Ym1pdFwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkZWxlZ2F0ZWQgaGFuZGxlcnM7IGNsZWFuRGF0YSBldmVudHVhbGx5IHJlYXBzIHN1Ym1pdCBoYW5kbGVycyBhdHRhY2hlZCBhYm92ZVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX3N1Ym1pdFwiICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4XG5pZiAoICFzdXBwb3J0LmNoYW5nZUJ1YmJsZXMgKSB7XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge1xuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApICkge1xuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IGZpcmUgY2hhbmdlIG9uIGEgY2hlY2svcmFkaW8gdW50aWwgYmx1cjsgdHJpZ2dlciBpdCBvbiBjbGlja1xuXHRcdFx0XHQvLyBhZnRlciBhIHByb3BlcnR5Y2hhbmdlLiBFYXQgdGhlIGJsdXItY2hhbmdlIGluIHNwZWNpYWwuY2hhbmdlLmhhbmRsZS5cblx0XHRcdFx0Ly8gVGhpcyBzdGlsbCBmaXJlcyBvbmNoYW5nZSBhIHNlY29uZCB0aW1lIGZvciBjaGVjay9yYWRpbyBhZnRlciBibHVyLlxuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lID09PSBcImNoZWNrZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBBbGxvdyB0cmlnZ2VyZWQsIHNpbXVsYXRlZCBjaGFuZ2UgZXZlbnRzICgjMTE1MDApXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGVsZWdhdGVkIGV2ZW50OyBsYXp5LWFkZCBhIGNoYW5nZSBoYW5kbGVyIG9uIGRlc2NlbmRhbnQgaW5wdXRzXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZS50YXJnZXQ7XG5cblx0XHRcdFx0aWYgKCByZm9ybUVsZW1zLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImNoYW5nZUJ1YmJsZXNcIiApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzU2ltdWxhdGVkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGVsZW0gPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdC8vIFN3YWxsb3cgbmF0aXZlIGNoYW5nZSBldmVudHMgZnJvbSBjaGVja2JveC9yYWRpbywgd2UgYWxyZWFkeSB0cmlnZ2VyZWQgdGhlbSBhYm92ZVxuXHRcdFx0aWYgKCB0aGlzICE9PSBlbGVtIHx8IGV2ZW50LmlzU2ltdWxhdGVkIHx8IGV2ZW50LmlzVHJpZ2dlciB8fCAoZWxlbS50eXBlICE9PSBcInJhZGlvXCIgJiYgZWxlbS50eXBlICE9PSBcImNoZWNrYm94XCIpICkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fY2hhbmdlXCIgKTtcblxuXHRcdFx0cmV0dXJuICFyZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXG5pZiAoICFzdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBqUXVlcnkuX2RhdGEoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGpRdWVyeS5fZGF0YSggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGRvYywgZml4ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIHR5cGUsIG9yaWdGbjtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxuZnVuY3Rpb24gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApIHtcblx0dmFyIGxpc3QgPSBub2RlTmFtZXMuc3BsaXQoIFwifFwiICksXG5cdFx0c2FmZUZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0aWYgKCBzYWZlRnJhZy5jcmVhdGVFbGVtZW50ICkge1xuXHRcdHdoaWxlICggbGlzdC5sZW5ndGggKSB7XG5cdFx0XHRzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRsaXN0LnBvcCgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc2FmZUZyYWc7XG59XG5cbnZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuXHRcdFwiaGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixcblx0cmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLFxuXHRybm9zaGltY2FjaGUgPSBuZXcgUmVnRXhwKFwiPCg/OlwiICsgbm9kZU5hbWVzICsgXCIpW1xcXFxzLz5dXCIsIFwiaVwiKSxcblx0cmxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cnRib2R5ID0gLzx0Ym9keS9pLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblx0d3JhcE1hcCA9IHtcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblx0XHRsZWdlbmQ6IFsgMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIiBdLFxuXHRcdGFyZWE6IFsgMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiIF0sXG5cdFx0cGFyYW06IFsgMSwgXCI8b2JqZWN0PlwiLCBcIjwvb2JqZWN0PlwiIF0sXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRcdC8vIElFNi04IGNhbid0IHNlcmlhbGl6ZSBsaW5rLCBzY3JpcHQsIHN0eWxlLCBvciBhbnkgaHRtbDUgKE5vU2NvcGUpIHRhZ3MsXG5cdFx0Ly8gdW5sZXNzIHdyYXBwZWQgaW4gYSBkaXYgd2l0aCBub24tYnJlYWtpbmcgY2hhcmFjdGVycyBpbiBmcm9udCBvZiBpdC5cblx0XHRfZGVmYXVsdDogc3VwcG9ydC5odG1sU2VyaWFsaXplID8gWyAwLCBcIlwiLCBcIlwiIF0gOiBbIDEsIFwiWDxkaXY+XCIsIFwiPC9kaXY+XCIgIF1cblx0fSxcblx0c2FmZUZyYWdtZW50ID0gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApLFxuXHRmcmFnbWVudERpdiA9IHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXHR2YXIgZWxlbXMsIGVsZW0sXG5cdFx0aSA9IDAsXG5cdFx0Zm91bmQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gc3RydW5kZWZpbmVkID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0aWYgKCAhZm91bmQgKSB7XG5cdFx0Zm9yICggZm91bmQgPSBbXSwgZWxlbXMgPSBjb250ZXh0LmNoaWxkTm9kZXMgfHwgY29udGV4dDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAhdGFnIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgdGFnICkgKSB7XG5cdFx0XHRcdGZvdW5kLnB1c2goIGVsZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggZm91bmQsIGdldEFsbCggZWxlbSwgdGFnICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIGZvdW5kICkgOlxuXHRcdGZvdW5kO1xufVxuXG4vLyBVc2VkIGluIGJ1aWxkRnJhZ21lbnQsIGZpeGVzIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKSB7XG5cdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWxlbS50eXBlICkgKSB7XG5cdFx0ZWxlbS5kZWZhdWx0Q2hlY2tlZCA9IGVsZW0uY2hlY2tlZDtcblx0fVxufVxuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInR5cGVcIiApICE9PSBudWxsKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWzFdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGkgPSAwO1xuXHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgalF1ZXJ5Ll9kYXRhKCByZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIgKSApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHR5cGUsIGksIGwsXG5cdFx0b2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG5cdFx0Y3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxuXHRcdGV2ZW50cyA9IG9sZERhdGEuZXZlbnRzO1xuXG5cdGlmICggZXZlbnRzICkge1xuXHRcdGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcblx0XHRjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG5cdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIG1ha2UgdGhlIGNsb25lZCBwdWJsaWMgZGF0YSBvYmplY3QgYSBjb3B5IGZyb20gdGhlIG9yaWdpbmFsXG5cdGlmICggY3VyRGF0YS5kYXRhICkge1xuXHRcdGN1ckRhdGEuZGF0YSA9IGpRdWVyeS5leHRlbmQoIHt9LCBjdXJEYXRhLmRhdGEgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBmaXhDbG9uZU5vZGVJc3N1ZXMoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lLCBlLCBkYXRhO1xuXG5cdC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIElFNi04IGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuXHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiBkZXN0WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QgKTtcblxuXHRcdGZvciAoIGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGRlc3QsIGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vXG5cdFx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XG5cdH1cblxuXHQvLyBJRSBibGFua3MgY29udGVudHMgd2hlbiBjbG9uaW5nIHNjcmlwdHMsIGFuZCB0cmllcyB0byBldmFsdWF0ZSBuZXdseS1zZXQgdGV4dFxuXHRpZiAoIG5vZGVOYW1lID09PSBcInNjcmlwdFwiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7XG5cdFx0ZGlzYWJsZVNjcmlwdCggZGVzdCApLnRleHQgPSBzcmMudGV4dDtcblx0XHRyZXN0b3JlU2NyaXB0KCBkZXN0ICk7XG5cblx0Ly8gSUU2LTEwIGltcHJvcGVybHkgY2xvbmVzIGNoaWxkcmVuIG9mIG9iamVjdCBlbGVtZW50cyB1c2luZyBjbGFzc2lkLlxuXHQvLyBJRTEwIHRocm93cyBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciBpZiBwYXJlbnQgaXMgbnVsbCwgIzEyMTMyLlxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRpZiAoIGRlc3QucGFyZW50Tm9kZSApIHtcblx0XHRcdGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcblx0XHR9XG5cblx0XHQvLyBUaGlzIHBhdGggYXBwZWFycyB1bmF2b2lkYWJsZSBmb3IgSUU5LiBXaGVuIGNsb25pbmcgYW4gb2JqZWN0XG5cdFx0Ly8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG5cdFx0Ly8gSWYgdGhlIHNyYyBoYXMgaW5uZXJIVE1MIGFuZCB0aGUgZGVzdGluYXRpb24gZG9lcyBub3QsXG5cdFx0Ly8gY29weSB0aGUgc3JjLmlubmVySFRNTCBpbnRvIHRoZSBkZXN0LmlubmVySFRNTC4gIzEwMzI0XG5cdFx0aWYgKCBzdXBwb3J0Lmh0bWw1Q2xvbmUgJiYgKCBzcmMuaW5uZXJIVE1MICYmICFqUXVlcnkudHJpbShkZXN0LmlubmVySFRNTCkgKSApIHtcblx0XHRcdGRlc3QuaW5uZXJIVE1MID0gc3JjLmlubmVySFRNTDtcblx0XHR9XG5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdC8vIElFNi04IGZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3hcblx0XHQvLyBvciByYWRpbyBidXR0b24uIFdvcnNlLCBJRTYtNyBmYWlsIHRvIGdpdmUgdGhlIGNsb25lZCBlbGVtZW50XG5cdFx0Ly8gYSBjaGVja2VkIGFwcGVhcmFuY2UgaWYgdGhlIGRlZmF1bHRDaGVja2VkIHZhbHVlIGlzbid0IGFsc28gc2V0XG5cblx0XHRkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0XHQvLyBJRTYtNyBnZXQgY29uZnVzZWQgYW5kIGVuZCB1cCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGNsb25lZFxuXHRcdC8vIGNoZWNrYm94L3JhZGlvIGJ1dHRvbiB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBcIm9uXCJcblx0XHRpZiAoIGRlc3QudmFsdWUgIT09IHNyYy52YWx1ZSApIHtcblx0XHRcdGRlc3QudmFsdWUgPSBzcmMudmFsdWU7XG5cdFx0fVxuXG5cdC8vIElFNi04IGZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkXG5cdC8vIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFNlbGVjdGVkID0gZGVzdC5zZWxlY3RlZCA9IHNyYy5kZWZhdWx0U2VsZWN0ZWQ7XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gc2V0IHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGNvcnJlY3QgdmFsdWUgd2hlblxuXHQvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBkZXN0RWxlbWVudHMsIG5vZGUsIGNsb25lLCBpLCBzcmNFbGVtZW50cyxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRpZiAoIHN1cHBvcnQuaHRtbDVDbG9uZSB8fCBqUXVlcnkuaXNYTUxEb2MoZWxlbSkgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBcIjxcIiArIGVsZW0ubm9kZU5hbWUgKyBcIj5cIiApICkge1xuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApO1xuXG5cdFx0Ly8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFnbWVudERpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcblx0XHRcdGZyYWdtZW50RGl2LnJlbW92ZUNoaWxkKCBjbG9uZSA9IGZyYWdtZW50RGl2LmZpcnN0Q2hpbGQgKTtcblx0XHR9XG5cblx0XHRpZiAoICghc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQpICYmXG5cdFx0XHRcdChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJiAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Ly8gRml4IGFsbCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdFx0Zm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7ICsraSApIHtcblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIGRlc3RpbmF0aW9uIG5vZGUgaXMgbm90IG51bGw7IEZpeGVzICM5NTg3XG5cdFx0XHRcdGlmICggZGVzdEVsZW1lbnRzW2ldICkge1xuXHRcdFx0XHRcdGZpeENsb25lTm9kZUlzc3Vlcyggbm9kZSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgKG5vZGUgPSBzcmNFbGVtZW50c1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0ZGVzdEVsZW1lbnRzID0gc3JjRWxlbWVudHMgPSBub2RlID0gbnVsbDtcblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgaiwgZWxlbSwgY29udGFpbnMsXG5cdFx0XHR0bXAsIHRhZywgdGJvZHksIHdyYXAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoLFxuXG5cdFx0XHQvLyBFbnN1cmUgYSBzYWZlIGZyYWdtZW50XG5cdFx0XHRzYWZlID0gY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICksXG5cblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgc2FmZS5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG5cblx0XHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdFx0dGFnID0gKHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSlbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXG5cdFx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsyXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWzBdO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBNYW51YWxseSBhZGQgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgYnkgSUVcblx0XHRcdFx0XHRpZiAoICFzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyggZWxlbSApWzBdICkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggIXN1cHBvcnQudGJvZHkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cblx0XHRcdFx0XHRcdGVsZW0gPSB0YWcgPT09IFwidGFibGVcIiAmJiAhcnRib2R5LnRlc3QoIGVsZW0gKSA/XG5cdFx0XHRcdFx0XHRcdHRtcC5maXJzdENoaWxkIDpcblxuXHRcdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdFx0d3JhcFsxXSA9PT0gXCI8dGFibGU+XCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuXHRcdFx0XHRcdFx0XHRcdHRtcCA6XG5cdFx0XHRcdFx0XHRcdFx0MDtcblxuXHRcdFx0XHRcdFx0aiA9IGVsZW0gJiYgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggKHRib2R5ID0gZWxlbS5jaGlsZE5vZGVzW2pdKSwgXCJ0Ym9keVwiICkgJiYgIXRib2R5LmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIHRib2R5ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gRml4ICMxMjM5MiBmb3IgV2ViS2l0IGFuZCBJRSA+IDlcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0XHRcdFx0Ly8gRml4ICMxMjM5MiBmb3Igb2xkSUVcblx0XHRcdFx0XHR3aGlsZSAoIHRtcC5maXJzdENoaWxkICkge1xuXHRcdFx0XHRcdFx0dG1wLnJlbW92ZUNoaWxkKCB0bXAuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciBwcm9wZXIgY2xlYW51cFxuXHRcdFx0XHRcdHRtcCA9IHNhZmUubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRml4ICMxMTM1NjogQ2xlYXIgZWxlbWVudHMgZnJvbSBmcmFnbWVudFxuXHRcdGlmICggdG1wICkge1xuXHRcdFx0c2FmZS5yZW1vdmVDaGlsZCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcblx0XHQvLyBhYm91dCB0byBiZSBhcHBlbmRlZCB0byB0aGUgRE9NIGluIElFIDYvNyAoIzgwNjApXG5cdFx0aWYgKCAhc3VwcG9ydC5hcHBlbmRDaGVja2VkICkge1xuXHRcdFx0alF1ZXJ5LmdyZXAoIGdldEFsbCggbm9kZXMsIFwiaW5wdXRcIiApLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuXHRcdH1cblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBzYWZlLmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0bXAgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHNhZmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMsIC8qIGludGVybmFsICovIGFjY2VwdERhdGEgKSB7XG5cdFx0dmFyIGVsZW0sIHR5cGUsIGlkLCBkYXRhLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGUsXG5cdFx0XHRkZWxldGVFeHBhbmRvID0gc3VwcG9ydC5kZWxldGVFeHBhbmRvLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEgfHwgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHRpZCA9IGVsZW1bIGludGVybmFsS2V5IF07XG5cdFx0XHRcdGRhdGEgPSBpZCAmJiBjYWNoZVsgaWQgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGNhY2hlIG9ubHkgaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHJlbW92ZWQgYnkgalF1ZXJ5LmV2ZW50LnJlbW92ZVxuXHRcdFx0XHRcdGlmICggY2FjaGVbIGlkIF0gKSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSBjYWNoZVsgaWQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gSUUgZG9lcyBub3QgYWxsb3cgdXMgdG8gZGVsZXRlIGV4cGFuZG8gcHJvcGVydGllcyBmcm9tIG5vZGVzLFxuXHRcdFx0XHRcdFx0Ly8gbm9yIGRvZXMgaXQgaGF2ZSBhIHJlbW92ZUF0dHJpYnV0ZSBmdW5jdGlvbiBvbiBEb2N1bWVudCBub2Rlcztcblx0XHRcdFx0XHRcdC8vIHdlIG11c3QgaGFuZGxlIGFsbCBvZiB0aGVzZSBjYXNlc1xuXHRcdFx0XHRcdFx0aWYgKCBkZWxldGVFeHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZWxlbVsgaW50ZXJuYWxLZXkgXTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIGVsZW0ucmVtb3ZlQXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBpbnRlcm5hbEtleSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGVsZXRlZElkcy5wdXNoKCBpZCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggKCB0aGlzWzBdICYmIHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApLmNyZWF0ZVRleHROb2RlKCB2YWx1ZSApICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0ZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkgOiB0aGlzLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblxuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUNoaWxkKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHNlbGVjdCwgZW5zdXJlIHRoYXQgaXQgZGlzcGxheXMgZW1wdHkgKCMxMjMzNilcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdGlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHRlbGVtLm9wdGlvbnMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksIFwiXCIgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0KCBzdXBwb3J0Lmh0bWxTZXJpYWxpemUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCB2YWx1ZSApICApICYmXG5cdFx0XHRcdCggc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0pWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbaV0gfHwge307XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZmlyc3QsIG5vZGUsIGhhc1NjcmlwdHMsXG5cdFx0XHRzY3JpcHRzLCBkb2MsIGZyYWdtZW50LFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZXQgPSB0aGlzLFxuXHRcdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHRcdHZhbHVlID0gYXJnc1swXSxcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0YXJnc1swXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXNbaV0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWpRdWVyeS5fZGF0YSggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoICggbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaXggIzExODA5OiBBdm9pZCBsZWFraW5nIG1lbW9yeVxuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDE7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUodHJ1ZSk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFtpXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBNb2Rlcm4gYnJvd3NlcnMgY2FuIGFwcGx5IGpRdWVyeSBjb2xsZWN0aW9ucyBhcyBhcnJheXMsIGJ1dCBvbGRJRSBuZWVkcyBhIC5nZXQoKVxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59KTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHt9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgc3R5bGUsXG5cdFx0ZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0Ly8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcblx0XHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmICggc3R5bGUgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoIGVsZW1bIDAgXSApICkgP1xuXG5cdFx0XHQvLyBVc2Ugb2YgdGhpcyBtZXRob2QgaXMgYSB0ZW1wb3JhcnkgZml4IChtb3JlIGxpa2Ugb3B0bWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXG5cdFx0XHRzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gKCBpZnJhbWVbIDAgXS5jb250ZW50V2luZG93IHx8IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudCApLmRvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBzaHJpbmtXcmFwQmxvY2tzVmFsO1xuXG5cdHN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggc2hyaW5rV3JhcEJsb2Nrc1ZhbCAhPSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNocmlua1dyYXBCbG9ja3NWYWw7XG5cdFx0fVxuXG5cdFx0Ly8gV2lsbCBiZSBjaGFuZ2VkIGxhdGVyIGlmIG5lZWRlZC5cblx0XHRzaHJpbmtXcmFwQmxvY2tzVmFsID0gZmFsc2U7XG5cblx0XHQvLyBNaW5pZmllZDogdmFyIGIsYyxkXG5cdFx0dmFyIGRpdiwgYm9keSwgY29udGFpbmVyO1xuXG5cdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdFx0aWYgKCAhYm9keSB8fCAhYm9keS5zdHlsZSApIHtcblx0XHRcdC8vIFRlc3QgZmlyZWQgdG9vIGVhcmx5IG9yIGluIGFuIHVuc3VwcG9ydGVkIGVudmlyb25tZW50LCBleGl0LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNldHVwXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHhcIjtcblx0XHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTZcblx0XHQvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlblxuXHRcdGlmICggdHlwZW9mIGRpdi5zdHlsZS56b29tICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyXG5cdFx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7XCIgK1xuXHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtcIiArXG5cdFx0XHRcdFwicGFkZGluZzoxcHg7d2lkdGg6MXB4O3pvb206MVwiO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKS5zdHlsZS53aWR0aCA9IFwiNXB4XCI7XG5cdFx0XHRzaHJpbmtXcmFwQmxvY2tzVmFsID0gZGl2Lm9mZnNldFdpZHRoICE9PSAzO1xuXHRcdH1cblxuXHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0cmV0dXJuIHNocmlua1dyYXBCbG9ja3NWYWw7XG5cdH07XG5cbn0pKCk7XG52YXIgcm1hcmdpbiA9ICgvXm1hcmdpbi8pO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cblxuXG52YXIgZ2V0U3R5bGVzLCBjdXJDU1MsXG5cdHJwb3NpdGlvbiA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLztcblxuaWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0Z2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHRpZiAoIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0fTtcblxuXHRjdXJDU1MgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0XHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1Mzdcblx0XHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0XHQvLyBDaHJvbWUgPCAxNyBhbmQgU2FmYXJpIDUuMCB1c2VzIFwiY29tcHV0ZWQgdmFsdWVcIiBpbnN0ZWFkIG9mIFwidXNlZCB2YWx1ZVwiIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFNhZmFyaSA1LjEuNyAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0dXJuIHJldCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHJldCA6XG5cdFx0XHRyZXQgKyBcIlwiO1xuXHR9O1xufSBlbHNlIGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSApIHtcblx0Z2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY3VycmVudFN0eWxlO1xuXHR9O1xuXG5cdGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0XHR2YXIgbGVmdCwgcnMsIHJzTGVmdCwgcmV0LFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkWyBuYW1lIF0gOiB1bmRlZmluZWQ7XG5cblx0XHQvLyBBdm9pZCBzZXR0aW5nIHJldCB0byBlbXB0eSBzdHJpbmcgaGVyZVxuXHRcdC8vIHNvIHdlIGRvbid0IGRlZmF1bHQgdG8gYXV0b1xuXHRcdGlmICggcmV0ID09IG51bGwgJiYgc3R5bGUgJiYgc3R5bGVbIG5hbWUgXSApIHtcblx0XHRcdHJldCA9IHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gRnJvbSB0aGUgYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xuXHRcdC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuXHRcdC8vIElmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSByZWd1bGFyIHBpeGVsIG51bWJlclxuXHRcdC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuXHRcdC8vIGJ1dCBub3QgcG9zaXRpb24gY3NzIGF0dHJpYnV0ZXMsIGFzIHRob3NlIGFyZSBwcm9wb3J0aW9uYWwgdG8gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWRcblx0XHQvLyBhbmQgd2UgY2FuJ3QgbWVhc3VyZSB0aGUgcGFyZW50IGluc3RlYWQgYmVjYXVzZSBpdCBtaWdodCB0cmlnZ2VyIGEgXCJzdGFja2luZyBkb2xsc1wiIHByb2JsZW1cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiAhcnBvc2l0aW9uLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0bGVmdCA9IHN0eWxlLmxlZnQ7XG5cdFx0XHRycyA9IGVsZW0ucnVudGltZVN0eWxlO1xuXHRcdFx0cnNMZWZ0ID0gcnMgJiYgcnMubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldHVybiByZXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXQgOlxuXHRcdFx0cmV0ICsgXCJcIiB8fCBcImF1dG9cIjtcblx0fTtcbn1cblxuXG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29uZGl0aW9uID0gY29uZGl0aW9uRm4oKTtcblxuXHRcdFx0aWYgKCBjb25kaXRpb24gPT0gbnVsbCApIHtcblx0XHRcdFx0Ly8gVGhlIHRlc3Qgd2FzIG5vdCByZWFkeSBhdCB0aGlzIHBvaW50OyBzY3JldyB0aGUgaG9vayB0aGlzIHRpbWVcblx0XHRcdFx0Ly8gYnV0IGNoZWNrIGFnYWluIHdoZW4gbmVlZGVkIG5leHQgdGltZS5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbmRpdGlvbiApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksXG5cdFx0XHRcdC8vIHJlbW92ZSBpdC5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgYXJlIG5vIG90aGVyIGhvb2tzIGZvciBtYXJnaW5SaWdodCwgcmVtb3ZlIHRoZSB3aG9sZSBvYmplY3QuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdC8vIE1pbmlmaWVkOiB2YXIgYixjLGQsZSxmLGcsIGgsaVxuXHR2YXIgZGl2LCBzdHlsZSwgYSwgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsLCByZWxpYWJsZU1hcmdpblJpZ2h0VmFsO1xuXG5cdC8vIFNldHVwXG5cdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYVwiIClbIDAgXTtcblx0c3R5bGUgPSBhICYmIGEuc3R5bGU7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c3R5bGUuY3NzVGV4dCA9IFwiZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHQvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzIChhcyBvcHBvc2VkIHRvIGZpbHRlcilcblx0c3VwcG9ydC5vcGFjaXR5ID0gc3R5bGUub3BhY2l0eSA9PT0gXCIwLjVcIjtcblxuXHQvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXG5cdC8vIChJRSB1c2VzIHN0eWxlRmxvYXQgaW5zdGVhZCBvZiBjc3NGbG9hdClcblx0c3VwcG9ydC5jc3NGbG9hdCA9ICEhc3R5bGUuY3NzRmxvYXQ7XG5cblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRzdXBwb3J0LmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyA9PT0gXCJcIiB8fCBzdHlsZS5Nb3pCb3hTaXppbmcgPT09IFwiXCIgfHxcblx0XHRzdHlsZS5XZWJraXRCb3hTaXppbmcgPT09IFwiXCI7XG5cblx0alF1ZXJ5LmV4dGVuZChzdXBwb3J0LCB7XG5cdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsO1xuXHRcdH0sXG5cblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBwaXhlbFBvc2l0aW9uVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcmVsaWFibGVNYXJnaW5SaWdodFZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luUmlnaHRWYWw7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblx0XHQvLyBNaW5pZmllZDogdmFyIGIsYyxkLGpcblx0XHR2YXIgZGl2LCBib2R5LCBjb250YWluZXIsIGNvbnRlbnRzO1xuXG5cdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdFx0aWYgKCAhYm9keSB8fCAhYm9keS5zdHlsZSApIHtcblx0XHRcdC8vIFRlc3QgZmlyZWQgdG9vIGVhcmx5IG9yIGluIGFuIHVuc3VwcG9ydGVkIGVudmlyb25tZW50LCBleGl0LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNldHVwXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHhcIjtcblx0XHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xuXHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7XCIgK1xuXHRcdFx0XCJib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3dpZHRoOjRweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEFzc3VtZSByZWFzb25hYmxlIHZhbHVlcyBpbiB0aGUgYWJzZW5jZSBvZiBnZXRDb21wdXRlZFN0eWxlXG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGJveFNpemluZ1JlbGlhYmxlVmFsID0gZmFsc2U7XG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodFZhbCA9IHRydWU7XG5cblx0XHQvLyBDaGVjayBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzbyB0aGF0IHRoaXMgY29kZSBpcyBub3QgcnVuIGluIElFPDkuXG5cdFx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRcdHBpeGVsUG9zaXRpb25WYWwgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7fSApLnRvcCAhPT0gXCIxJVwiO1xuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPVxuXHRcdFx0XHQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIERpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lciAoIzMzMzMpXG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdGNvbnRlbnRzID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0Y29udGVudHMuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiYm94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiO1xuXHRcdFx0Y29udGVudHMuc3R5bGUubWFyZ2luUmlnaHQgPSBjb250ZW50cy5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblxuXHRcdFx0cmVsaWFibGVNYXJnaW5SaWdodFZhbCA9XG5cdFx0XHRcdCFwYXJzZUZsb2F0KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBjb250ZW50cywgbnVsbCApIHx8IHt9ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBjb250ZW50cyApO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG5cdFx0Ly8gdG8gZGlzcGxheTpub25lIGFuZCB0aGVyZSBhcmUgc3RpbGwgb3RoZXIgdmlzaWJsZSB0YWJsZSBjZWxscyBpbiBhXG5cdFx0Ly8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG5cdFx0Ly8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcblx0XHQvLyBkaXNwbGF5Om5vbmUgKGl0IGlzIHN0aWxsIHNhZmUgdG8gdXNlIG9mZnNldHMgaWYgYSBwYXJlbnQgZWxlbWVudCBpc1xuXHRcdC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCI7XG5cdFx0Y29udGVudHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGRcIiApO1xuXHRcdGNvbnRlbnRzWyAwIF0uc3R5bGUuY3NzVGV4dCA9IFwibWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowO2Rpc3BsYXk6bm9uZVwiO1xuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCA9IGNvbnRlbnRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwO1xuXHRcdGlmICggcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsICkge1xuXHRcdFx0Y29udGVudHNbIDAgXS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdGNvbnRlbnRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0cmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsID0gY29udGVudHNbIDAgXS5vZmZzZXRIZWlnaHQgPT09IDA7XG5cdFx0fVxuXG5cdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdH1cblxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0XHRyYWxwaGEgPSAvYWxwaGFcXChbXildKlxcKS9pLFxuXHRyb3BhY2l0eSA9IC9vcGFjaXR5XFxzKj1cXHMqKFteKV0qKS8sXG5cblx0Ly8gc3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gc2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF07XG5cblxuLy8gcmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIHNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIGNoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcblx0XHRvcmlnTmFtZSA9IG5hbWUsXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9yaWdOYW1lO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICYmIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gYm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IHN1cHBvcnQuYm94U2l6aW5nICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gc29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgbmVlZCB0aGUgY2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmICggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIHVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0Ly8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuXHRcdFwiZmxvYXRcIjogc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBjb252ZXJ0IHJlbGF0aXZlIG51bWJlciBzdHJpbmdzICgrPSBvciAtPSkgdG8gcmVsYXRpdmUgbnVtYmVycy4gIzczNDVcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHtcblx0XHRcdFx0dmFsdWUgPSAoIHJldFsxXSArIDEgKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldC4gU2VlOiAjNzExNlxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSApIHtcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXhlcyAjODkwOCwgaXQgY2FuIGJlIGRvbmUgbW9yZSBjb3JyZWN0bHkgYnkgc3BlY2lmaW5nIHNldHRlcnMgaW4gY3NzSG9va3MsXG5cdFx0XHQvLyBidXQgaXQgd291bGQgbWVhbiB0byBkZWZpbmUgZWlnaHQgKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0XHQvLyBTd2FsbG93IGVycm9ycyBmcm9tICdpbnZhbGlkJyBDU1MgdmFsdWVzICgjNTUwOSlcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciBudW0sIHZhbCwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggZWxlbS5zdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly9jb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdHN1cHBvcnQuYm94U2l6aW5nICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCkgOiAwXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5pZiAoICFzdXBwb3J0Lm9wYWNpdHkgKSB7XG5cdGpRdWVyeS5jc3NIb29rcy5vcGFjaXR5ID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0Ly8gSUUgdXNlcyBmaWx0ZXJzIGZvciBvcGFjaXR5XG5cdFx0XHRyZXR1cm4gcm9wYWNpdHkudGVzdCggKGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDogZWxlbS5zdHlsZS5maWx0ZXIpIHx8IFwiXCIgKSA/XG5cdFx0XHRcdCggMC4wMSAqIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApICkgKyBcIlwiIDpcblx0XHRcdFx0Y29tcHV0ZWQgPyBcIjFcIiA6IFwiXCI7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRcdFx0Y3VycmVudFN0eWxlID0gZWxlbS5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdG9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdGZpbHRlciA9IGN1cnJlbnRTdHlsZSAmJiBjdXJyZW50U3R5bGUuZmlsdGVyIHx8IHN0eWxlLmZpbHRlciB8fCBcIlwiO1xuXG5cdFx0XHQvLyBJRSBoYXMgdHJvdWJsZSB3aXRoIG9wYWNpdHkgaWYgaXQgZG9lcyBub3QgaGF2ZSBsYXlvdXRcblx0XHRcdC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcblx0XHRcdHN0eWxlLnpvb20gPSAxO1xuXG5cdFx0XHQvLyBpZiBzZXR0aW5nIG9wYWNpdHkgdG8gMSwgYW5kIG5vIG90aGVyIGZpbHRlcnMgZXhpc3QgLSBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG5cdFx0XHQvLyBpZiB2YWx1ZSA9PT0gXCJcIiwgdGhlbiByZW1vdmUgaW5saW5lIG9wYWNpdHkgIzEyNjg1XG5cdFx0XHRpZiAoICggdmFsdWUgPj0gMSB8fCB2YWx1ZSA9PT0gXCJcIiApICYmXG5cdFx0XHRcdFx0alF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICYmXG5cdFx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGUgb3IgdW5zZXQgaW5saW5lIG9wYWNpdHksIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgfHwgY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcblx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBcInN3aW5nXCI7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmXG5cdFx0XHRcdCghdHdlZW4uZWxlbS5zdHlsZSB8fCB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCkgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlsc1xuXHRcdFx0Ly8gc28sIHNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0LlxuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcyBpcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdC8vIHVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0IC0gdXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlIC0gdXNlIC5zdHlsZSBpZiBpdHNcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH1cbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKSxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC8sXG5cdGFuaW1hdGlvblByZWZpbHRlcnMgPSBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblx0dHdlZW5lcnMgPSB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKSxcblx0XHRcdFx0dGFyZ2V0ID0gdHdlZW4uY3VyKCksXG5cdFx0XHRcdHBhcnRzID0gcmZ4bnVtLmV4ZWMoIHZhbHVlICksXG5cdFx0XHRcdHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0XHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0XHRcdHN0YXJ0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICt0YXJnZXQgKSAmJlxuXHRcdFx0XHRcdHJmeG51bS5leGVjKCBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCBwcm9wICkgKSxcblx0XHRcdFx0c2NhbGUgPSAxLFxuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMjA7XG5cblx0XHRcdGlmICggc3RhcnQgJiYgc3RhcnRbIDMgXSAhPT0gdW5pdCApIHtcblx0XHRcdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdFx0XHR1bml0ID0gdW5pdCB8fCBzdGFydFsgMyBdO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHRcdFx0cGFydHMgPSBwYXJ0cyB8fCBbXTtcblxuXHRcdFx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdFx0XHRzdGFydCA9ICt0YXJnZXQgfHwgMTtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZypcblx0XHRcdFx0XHQvLyBVc2UgYSBzdHJpbmcgZm9yIGRvdWJsaW5nIGZhY3RvciBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHByb3AsIHN0YXJ0ICsgdW5pdCApO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0XHRcdC8vIEFuZCBicmVha2luZyB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXG5cdFx0XHRcdH0gd2hpbGUgKCBzY2FsZSAhPT0gKHNjYWxlID0gdHdlZW4uY3VyKCkgLyB0YXJnZXQpICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xuXHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0c3RhcnQgPSB0d2Vlbi5zdGFydCA9ICtzdGFydCB8fCArdGFyZ2V0IHx8IDA7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cblx0XHRcdFx0dHdlZW4uZW5kID0gcGFydHNbIDEgXSA/XG5cdFx0XHRcdFx0c3RhcnQgKyAoIHBhcnRzWyAxIF0gKyAxICkgKiBwYXJ0c1sgMiBdIDpcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9O1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9LFxuXHRcdGkgPSAwO1xuXG5cdC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gd2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gaGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkb2luZyB0aGlzIG1ha2VzIHN1cmUgdGhhdCB0aGUgY29tcGxldGUgaGFuZGxlciB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0Ly8gYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIGhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHQvLyBpbmxpbmUtbGV2ZWwgZWxlbWVudHMgYWNjZXB0IGlubGluZS1ibG9jaztcblx0XHRcdC8vIGJsb2NrLWxldmVsIGVsZW1lbnRzIG5lZWQgdG8gYmUgaW5saW5lIHdpdGggbGF5b3V0XG5cdFx0XHRpZiAoICFzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHlsZS56b29tID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGlmICggIXN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcygpICkge1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkpID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXG5cdFx0XHQvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBhbmltYXRpb25QcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cdFx0XHRcdC8vIGFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSAxIC0gKCAwLjUgfHwgMCApICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHsgc3BlY2lhbEVhc2luZzoge30gfSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cdFx0XHRcdFx0Ly8gaWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSlcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiIFwiKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXSA9IHR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcblx0XHRvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZFxuXHRcdFx0Ly8gdGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaCB3aWxsIGRlcXVldWVcblx0XHRcdC8vIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5fZGF0YSggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBlbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRpID0gMDtcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0Ly8gTWluaWZpZWQ6IHZhciBhLGIsYyxkLGVcblx0dmFyIGlucHV0LCBkaXYsIHNlbGVjdCwgYSwgb3B0O1xuXG5cdC8vIFNldHVwXG5cdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0ZGl2LnNldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiwgXCJ0XCIgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWyAwIF07XG5cblx0Ly8gRmlyc3QgYmF0Y2ggb2YgdGVzdHMuXG5cdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG5cdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSApO1xuXHRpbnB1dCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWyAwIF07XG5cblx0YS5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6MXB4XCI7XG5cblx0Ly8gVGVzdCBzZXRBdHRyaWJ1dGUgb24gY2FtZWxDYXNlIGNsYXNzLiBJZiBpdCB3b3Jrcywgd2UgbmVlZCBhdHRyRml4ZXMgd2hlbiBkb2luZyBnZXQvc2V0QXR0cmlidXRlIChpZTYvNylcblx0c3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGUgPSBkaXYuY2xhc3NOYW1lICE9PSBcInRcIjtcblxuXHQvLyBHZXQgdGhlIHN0eWxlIGluZm9ybWF0aW9uIGZyb20gZ2V0QXR0cmlidXRlXG5cdC8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpXG5cdHN1cHBvcnQuc3R5bGUgPSAvdG9wLy50ZXN0KCBhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpICk7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcblx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0c3VwcG9ydC5ocmVmTm9ybWFsaXplZCA9IGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiO1xuXG5cdC8vIENoZWNrIHRoZSBkZWZhdWx0IGNoZWNrYm94L3JhZGlvIHZhbHVlIChcIlwiIG9uIFdlYktpdDsgXCJvblwiIGVsc2V3aGVyZSlcblx0c3VwcG9ydC5jaGVja09uID0gISFpbnB1dC52YWx1ZTtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhIHNlbGVjdGVkLWJ5LWRlZmF1bHQgb3B0aW9uIGhhcyBhIHdvcmtpbmcgc2VsZWN0ZWQgcHJvcGVydHkuXG5cdC8vIChXZWJLaXQgZGVmYXVsdHMgdG8gZmFsc2UgaW5zdGVhZCBvZiB0cnVlLCBJRSB0b28sIGlmIGl0J3MgaW4gYW4gb3B0Z3JvdXApXG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gVGVzdHMgZm9yIGVuY3R5cGUgc3VwcG9ydCBvbiBhIGZvcm0gKCM2NzQzKVxuXHRzdXBwb3J0LmVuY3R5cGUgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGU7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHQvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlzYWJsZWQpXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFOCBvbmx5XG5cdC8vIENoZWNrIGlmIHdlIGNhbiB0cnVzdCBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRzdXBwb3J0LmlucHV0ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcblxuXHQvLyBDaGVjayBpZiBhbiBpbnB1dCBtYWludGFpbnMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0pKCk7XG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHQvLyBoYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UocnJldHVybiwgXCJcIikgOlxuXHRcdFx0XHRcdC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTEwLTExK1xuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBvbGRJRSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2XG5cdFx0XHRcdFx0XHQvLyBXaGVuIG5ldyBvcHRpb24gZWxlbWVudCBpcyBhZGRlZCB0byBzZWxlY3QgYm94IHdlIG5lZWQgdG9cblx0XHRcdFx0XHRcdC8vIGZvcmNlIHJlZmxvdyBvZiBuZXdseSBhZGRlZCBub2RlIGluIG9yZGVyIHRvIHdvcmthcm91bmQgZGVsYXlcblx0XHRcdFx0XHRcdC8vIG9mIGluaXRpYWxpemF0aW9uIHByb3BlcnRpZXNcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvblNldCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBfICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFdpbGwgYmUgZXhlY3V0ZWQgb25seSBpbiBJRTZcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnNjcm9sbEhlaWdodDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdlYmtpdFxuXHRcdFx0Ly8gXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZSxcblx0cnVzZURlZmF1bHQgPSAvXig/OmNoZWNrZWR8c2VsZWN0ZWQpJC9pLFxuXHRnZXRTZXRBdHRyaWJ1dGUgPSBzdXBwb3J0LmdldFNldEF0dHJpYnV0ZSxcblx0Z2V0U2V0SW5wdXQgPSBzdXBwb3J0LmlucHV0O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0aWYgKCBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0Ly8gQWxzbyBjbGVhciBkZWZhdWx0Q2hlY2tlZC9kZWZhdWx0U2VsZWN0ZWQgKGlmIGFwcHJvcHJpYXRlKVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA9XG5cdFx0XHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VlICM5Njk5IGZvciBleHBsYW5hdGlvbiBvZiB0aGlzIGFwcHJvYWNoIChzZXR0aW5nIGZpcnN0LCB0aGVuIHJlbW92YWwpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmF0dHIoIGVsZW0sIG5hbWUsIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBnZXRTZXRBdHRyaWJ1dGUgPyBuYW1lIDogcHJvcE5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlucHV0XCIpICkge1xuXHRcdFx0XHRcdC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU2LTlcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWUgZHVyaW5nIGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSG9vayBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuXHRcdFx0Ly8gSUU8OCBuZWVkcyB0aGUgKnByb3BlcnR5KiBuYW1lXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggIWdldFNldEF0dHJpYnV0ZSAmJiBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUsIG5hbWUgKTtcblxuXHRcdC8vIFVzZSBkZWZhdWx0Q2hlY2tlZCBhbmQgZGVmYXVsdFNlbGVjdGVkIGZvciBvbGRJRVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA9IGVsZW1bIG5hbWUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbi8vIFJldHJpZXZlIGJvb2xlYW5zIHNwZWNpYWxseVxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBnZXRTZXRJbnB1dCAmJiBnZXRTZXRBdHRyaWJ1dGUgfHwgIXJ1c2VEZWZhdWx0LnRlc3QoIG5hbWUgKSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtWyBqUXVlcnkuY2FtZWxDYXNlKCBcImRlZmF1bHQtXCIgKyBuYW1lICkgXSA/XG5cdFx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdH07XG59KTtcblxuLy8gZml4IG9sZElFIGF0dHJvcGVydGllc1xuaWYgKCAhZ2V0U2V0SW5wdXQgfHwgIWdldFNldEF0dHJpYnV0ZSApIHtcblx0alF1ZXJ5LmF0dHJIb29rcy52YWx1ZSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0Ly8gRG9lcyBub3QgcmV0dXJuIHNvIHRoYXQgc2V0QXR0cmlidXRlIGlzIGFsc28gdXNlZFxuXHRcdFx0XHRlbGVtLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVXNlIG5vZGVIb29rIGlmIGRlZmluZWQgKCMxOTU0KTsgb3RoZXJ3aXNlIHNldEF0dHJpYnV0ZSBpcyBmaW5lXG5cdFx0XHRcdHJldHVybiBub2RlSG9vayAmJiBub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJRTYvNyBkbyBub3Qgc3VwcG9ydCBnZXR0aW5nL3NldHRpbmcgc29tZSBhdHRyaWJ1dGVzIHdpdGggZ2V0L3NldEF0dHJpYnV0ZVxuaWYgKCAhZ2V0U2V0QXR0cmlidXRlICkge1xuXG5cdC8vIFVzZSB0aGlzIGZvciBhbnkgYXR0cmlidXRlIGluIElFNi83XG5cdC8vIFRoaXMgZml4ZXMgYWxtb3N0IGV2ZXJ5IElFNi83IGlzc3VlXG5cdG5vZGVIb29rID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0Ly8gU2V0IHRoZSBleGlzdGluZyBvciBjcmVhdGUgYSBuZXcgYXR0cmlidXRlIG5vZGVcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGVOb2RlKFxuXHRcdFx0XHRcdChyZXQgPSBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKCBuYW1lICkpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldC52YWx1ZSA9IHZhbHVlICs9IFwiXCI7XG5cblx0XHRcdC8vIEJyZWFrIGFzc29jaWF0aW9uIHdpdGggY2xvbmVkIGVsZW1lbnRzIGJ5IGFsc28gdXNpbmcgc2V0QXR0cmlidXRlICgjOTY0Nilcblx0XHRcdGlmICggbmFtZSA9PT0gXCJ2YWx1ZVwiIHx8IHZhbHVlID09PSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFNvbWUgYXR0cmlidXRlcyBhcmUgY29uc3RydWN0ZWQgd2l0aCBlbXB0eS1zdHJpbmcgdmFsdWVzIHdoZW4gbm90IGRlZmluZWRcblx0YXR0ckhhbmRsZS5pZCA9IGF0dHJIYW5kbGUubmFtZSA9IGF0dHJIYW5kbGUuY29vcmRzID1cblx0XHRmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgcmV0O1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiAocmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHJldC52YWx1ZSAhPT0gXCJcIiA/XG5cdFx0XHRcdFx0cmV0LnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0Ly8gRml4aW5nIHZhbHVlIHJldHJpZXZhbCBvbiBhIGJ1dHRvbiByZXF1aXJlcyB0aGlzIG1vZHVsZVxuXHRqUXVlcnkudmFsSG9va3MuYnV0dG9uID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRpZiAoIHJldCAmJiByZXQuc3BlY2lmaWVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0LnZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2V0OiBub2RlSG9vay5zZXRcblx0fTtcblxuXHQvLyBTZXQgY29udGVudGVkaXRhYmxlIHRvIGZhbHNlIG9uIHJlbW92YWxzKCMxMDQyOSlcblx0Ly8gU2V0dGluZyB0byBlbXB0eSBzdHJpbmcgdGhyb3dzIGFuIGVycm9yIGFzIGFuIGludmFsaWQgdmFsdWVcblx0alF1ZXJ5LmF0dHJIb29rcy5jb250ZW50ZWRpdGFibGUgPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRub2RlSG9vay5zZXQoIGVsZW0sIHZhbHVlID09PSBcIlwiID8gZmFsc2UgOiB2YWx1ZSwgbmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBTZXQgd2lkdGggYW5kIGhlaWdodCB0byBhdXRvIGluc3RlYWQgb2YgMCBvbiBlbXB0eSBzdHJpbmcoIEJ1ZyAjODE1MCApXG5cdC8vIFRoaXMgaXMgZm9yIHJlbW92YWxzXG5cdGpRdWVyeS5lYWNoKFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSA9IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcIlwiICkge1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBcImF1dG9cIiApO1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5pZiAoICFzdXBwb3J0LnN0eWxlICkge1xuXHRqUXVlcnkuYXR0ckhvb2tzLnN0eWxlID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBSZXR1cm4gdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIGVtcHR5IHN0cmluZ1xuXHRcdFx0Ly8gTm90ZTogSUUgdXBwZXJjYXNlcyBjc3MgcHJvcGVydHkgbmFtZXMsIGJ1dCBpZiB3ZSB3ZXJlIHRvIC50b0xvd2VyQ2FzZSgpXG5cdFx0XHQvLyAuY3NzVGV4dCwgdGhhdCB3b3VsZCBkZXN0cm95IGNhc2Ugc2Vuc3RpdGl2aXR5IGluIFVSTCdzLCBsaWtlIGluIFwiYmFja2dyb3VuZFwiXG5cdFx0XHRyZXR1cm4gZWxlbS5zdHlsZS5jc3NUZXh0IHx8IHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuICggZWxlbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgKyBcIlwiICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB0cnkvY2F0Y2ggaGFuZGxlcyBjYXNlcyB3aGVyZSBJRSBiYWxrcyAoc3VjaCBhcyByZW1vdmluZyBhIHByb3BlcnR5IG9uIHdpbmRvdylcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXNbIG5hbWUgXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0ZGVsZXRlIHRoaXNbIG5hbWUgXTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8IHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFNvbWUgYXR0cmlidXRlcyByZXF1aXJlIGEgc3BlY2lhbCBjYWxsIG9uIElFXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFzdXBwb3J0LmhyZWZOb3JtYWxpemVkICkge1xuXHQvLyBocmVmL3NyYyBwcm9wZXJ0eSBzaG91bGQgZ2V0IHRoZSBmdWxsIG5vcm1hbGl6ZWQgVVJMICgjMTAyOTkvIzEyOTE1KVxuXHRqUXVlcnkuZWFjaChbIFwiaHJlZlwiLCBcInNyY1wiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgNCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBTYWZhcmksIElFOStcbi8vIG1pcy1yZXBvcnRzIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHByb3BlcnR5IG9mIGFuIG9wdGlvblxuLy8gQWNjZXNzaW5nIHRoZSBwYXJlbnQncyBzZWxlY3RlZEluZGV4IHByb3BlcnR5IGZpeGVzIGl0XG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgaXQgYWxzbyB3b3JrcyB3aXRoIG9wdGdyb3Vwcywgc2VlICM1NzAxXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaChbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSk7XG5cbi8vIElFNi83IGNhbGwgZW5jdHlwZSBlbmNvZGluZ1xuaWYgKCAhc3VwcG9ydC5lbmN0eXBlICkge1xuXHRqUXVlcnkucHJvcEZpeC5lbmN0eXBlID0gXCJlbmNvZGluZ1wiO1xufVxuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWU7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCIgXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChjbGF6eiA9IGNsYXNzZXNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+PSAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogXCJcIjtcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoIHZhbHVlLmNhbGwodGhpcywgaSwgdGhpcy5jbGFzc05hbWUsIHN0YXRlVmFsKSwgc3RhdGVWYWwgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vIHRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdHZhciBjbGFzc05hbWUsXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdFx0d2hpbGUgKCAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0pICkge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBzdHJ1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBcImZhbHNlXCIsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogalF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIikuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9LFxuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6IHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59KTtcblxuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoL1xcPy8pO1xuXG5cblxudmFyIHJ2YWxpZHRva2VucyA9IC8oLCl8KFxcW3x7KXwofXxdKXxcIig/OlteXCJcXFxcXFxyXFxuXXxcXFxcW1wiXFxcXFxcL2JmbnJ0XXxcXFxcdVtcXGRhLWZBLUZdezR9KSpcIlxccyo6P3x0cnVlfGZhbHNlfG51bGx8LT8oPyEwXFxkKVxcZCsoPzpcXC5cXGQrfCkoPzpbZUVdWystXT9cXGQrfCkvZztcblxualF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHQvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3Rcblx0aWYgKCB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSApIHtcblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdC8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XG5cdFx0cmV0dXJuIHdpbmRvdy5KU09OLnBhcnNlKCBkYXRhICsgXCJcIiApO1xuXHR9XG5cblx0dmFyIHJlcXVpcmVOb25Db21tYSxcblx0XHRkZXB0aCA9IG51bGwsXG5cdFx0c3RyID0galF1ZXJ5LnRyaW0oIGRhdGEgKyBcIlwiICk7XG5cblx0Ly8gR3VhcmQgYWdhaW5zdCBpbnZhbGlkIChhbmQgcG9zc2libHkgZGFuZ2Vyb3VzKSBpbnB1dCBieSBlbnN1cmluZyB0aGF0IG5vdGhpbmcgcmVtYWluc1xuXHQvLyBhZnRlciByZW1vdmluZyB2YWxpZCB0b2tlbnNcblx0cmV0dXJuIHN0ciAmJiAhalF1ZXJ5LnRyaW0oIHN0ci5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIGZ1bmN0aW9uKCB0b2tlbiwgY29tbWEsIG9wZW4sIGNsb3NlICkge1xuXG5cdFx0Ly8gRm9yY2UgdGVybWluYXRpb24gaWYgd2Ugc2VlIGEgbWlzcGxhY2VkIGNvbW1hXG5cdFx0aWYgKCByZXF1aXJlTm9uQ29tbWEgJiYgY29tbWEgKSB7XG5cdFx0XHRkZXB0aCA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyZm9ybSBubyBtb3JlIHJlcGxhY2VtZW50cyBhZnRlciByZXR1cm5pbmcgdG8gb3V0ZXJtb3N0IGRlcHRoXG5cdFx0aWYgKCBkZXB0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0b2tlbjtcblx0XHR9XG5cblx0XHQvLyBDb21tYXMgbXVzdCBub3QgZm9sbG93IFwiW1wiLCBcIntcIiwgb3IgXCIsXCJcblx0XHRyZXF1aXJlTm9uQ29tbWEgPSBvcGVuIHx8IGNvbW1hO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIG5ldyBkZXB0aFxuXHRcdC8vIGFycmF5L29iamVjdCBvcGVuIChcIltcIiBvciBcIntcIik6IGRlcHRoICs9IHRydWUgLSBmYWxzZSAoaW5jcmVtZW50KVxuXHRcdC8vIGFycmF5L29iamVjdCBjbG9zZSAoXCJdXCIgb3IgXCJ9XCIpOiBkZXB0aCArPSBmYWxzZSAtIHRydWUgKGRlY3JlbWVudClcblx0XHQvLyBvdGhlciBjYXNlcyAoXCIsXCIgb3IgcHJpbWl0aXZlKTogZGVwdGggKz0gdHJ1ZSAtIHRydWUgKG51bWVyaWMgY2FzdClcblx0XHRkZXB0aCArPSAhY2xvc2UgLSAhb3BlbjtcblxuXHRcdC8vIFJlbW92ZSB0aGlzIHRva2VuXG5cdFx0cmV0dXJuIFwiXCI7XG5cdH0pICkgP1xuXHRcdCggRnVuY3Rpb24oIFwicmV0dXJuIFwiICsgc3RyICkgKSgpIDpcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEgKTtcbn07XG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWwsIHRtcDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcblx0XHRcdHRtcCA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHRcdH0gZWxzZSB7IC8vIElFXG5cdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdHhtbC5hc3luYyA9IFwiZmFsc2VcIjtcblx0XHRcdHhtbC5sb2FkWE1MKCBkYXRhICk7XG5cdFx0fVxuXHR9IGNhdGNoKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAoICF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY1BhcnRzLFxuXHRhamF4TG9jYXRpb24sXG5cblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKilcXHI/JC9tZywgLy8gSUUgbGVhdmVzIGFuIFxcciBjaGFyYWN0ZXIgYXQgRU9MXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdChcIipcIik7XG5cbi8vICM4MTM4LCBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG4vLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbnRyeSB7XG5cdGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XG59IGNhdGNoKCBlICkge1xuXHQvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxuXHQvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XG5cdGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xufVxuXG4vLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcbmFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlLmNoYXJBdCggMCApID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIgZGVlcCwga2V5LFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKGRlZXAgPSB7fSkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblx0dmFyIGZpcnN0RGF0YVR5cGUsIGN0LCBmaW5hbERhdGFUeXBlLCB0eXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHNbIFwidGhyb3dzXCIgXSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogYWpheExvY2F0aW9uLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC94bWwvLFxuXHRcdFx0aHRtbDogL2h0bWwvLFxuXHRcdFx0anNvbjogL2pzb24vXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xuXHRcdFx0cGFydHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzIGFzIHN0cmluZ1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0dHJhbnNwb3J0LFxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAoIzU4NjY6IElFNyBpc3N1ZSB3aXRoIHByb3RvY29sLWxlc3MgdXJscylcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24gKSArIFwiXCIgKS5yZXBsYWNlKCByaGFzaCwgXCJcIiApLnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIGFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UgZXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHRcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cdFx0Ly8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9KTtcblx0fTtcbn0pO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0dXJsOiB1cmwsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0pO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR2YXIgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50ICkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cblx0XHRcdGlmICggdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1swXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykud3JhcElubmVyKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwIHx8XG5cdFx0KCFzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cygpICYmXG5cdFx0XHQoKGVsZW0uc3R5bGUgJiYgZWxlbS5zdHlsZS5kaXNwbGF5KSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xufTtcblxualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSk7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9KVxuXHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdC8vIFVzZSAuaXMoXCI6ZGlzYWJsZWRcIikgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbi8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3Rcbi8vIChUaGlzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGFqYXhTZXR0aW5ncyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgIT09IHVuZGVmaW5lZCA/XG5cdC8vIFN1cHBvcnQ6IElFNitcblx0ZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBYSFIgY2Fubm90IGFjY2VzcyBsb2NhbCBmaWxlcywgYWx3YXlzIHVzZSBBY3RpdmVYIGZvciB0aGF0IGNhc2Vcblx0XHRyZXR1cm4gIXRoaXMuaXNMb2NhbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTctOFxuXHRcdFx0Ly8gb2xkSUUgWEhSIGRvZXMgbm90IHN1cHBvcnQgbm9uLVJGQzI2MTYgbWV0aG9kcyAoIzEzMjQwKVxuXHRcdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNjY0OCh2PXZzLjg1KS5hc3B4XG5cdFx0XHQvLyBhbmQgaHR0cDovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWM5Lmh0bWwjc2VjOVxuXHRcdFx0Ly8gQWx0aG91Z2ggdGhpcyBjaGVjayBmb3Igc2l4IG1ldGhvZHMgaW5zdGVhZCBvZiBlaWdodFxuXHRcdFx0Ly8gc2luY2UgSUUgYWxzbyBkb2VzIG5vdCBzdXBwb3J0IFwidHJhY2VcIiBhbmQgXCJjb25uZWN0XCJcblx0XHRcdC9eKGdldHxwb3N0fGhlYWR8cHV0fGRlbGV0ZXxvcHRpb25zKSQvaS50ZXN0KCB0aGlzLnR5cGUgKSAmJlxuXG5cdFx0XHRjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuXHR9IDpcblx0Ly8gRm9yIGFsbCBvdGhlciBicm93c2VycywgdXNlIHRoZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBvYmplY3Rcblx0Y3JlYXRlU3RhbmRhcmRYSFI7XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTwxMFxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbi8vIFNlZSBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi8yODU2NzQ2IGZvciBtb3JlIGluZm9cbmlmICggd2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBEZXRlcm1pbmUgc3VwcG9ydCBwcm9wZXJ0aWVzXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG54aHJTdXBwb3J0ZWQgPSBzdXBwb3J0LmFqYXggPSAhIXhoclN1cHBvcnRlZDtcblxuLy8gQ3JlYXRlIHRyYW5zcG9ydCBpZiB0aGUgYnJvd3NlciBjYW4gcHJvdmlkZSBhbiB4aHJcbmlmICggeGhyU3VwcG9ydGVkICkge1xuXG5cdGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluIHx8IHN1cHBvcnQuY29ycyApIHtcblxuXHRcdFx0dmFyIGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpLFxuXHRcdFx0XHRcdFx0aWQgPSArK3hocklkO1xuXG5cdFx0XHRcdFx0Ly8gT3BlbiB0aGUgc29ja2V0XG5cdFx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcblxuXHRcdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdFx0XHRcdC8vIElFJ3MgQWN0aXZlWE9iamVjdCB0aHJvd3MgYSAnVHlwZSBNaXNtYXRjaCcgZXhjZXB0aW9uIHdoZW4gc2V0dGluZ1xuXHRcdFx0XHRcdFx0Ly8gcmVxdWVzdCBoZWFkZXIgdG8gYSBudWxsLXZhbHVlLlxuXHRcdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRcdC8vIFRvIGtlZXAgY29uc2lzdGVudCB3aXRoIG90aGVyIFhIUiBpbXBsZW1lbnRhdGlvbnMsIGNhc3QgdGhlIHZhbHVlXG5cdFx0XHRcdFx0XHQvLyB0byBzdHJpbmcgYW5kIGlnbm9yZSBgdW5kZWZpbmVkYC5cblx0XHRcdFx0XHRcdGlmICggaGVhZGVyc1sgaSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKyBcIlwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRcdC8vIFRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGljaCBpcyBhY3R1YWxseVxuXHRcdFx0XHRcdC8vIGhhbmRsZWQgaW4galF1ZXJ5LmFqYXggKHNvIG5vIHRyeS9jYXRjaCBoZXJlKVxuXHRcdFx0XHRcdHhoci5zZW5kKCAoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgKSB8fCBudWxsICk7XG5cblx0XHRcdFx0XHQvLyBMaXN0ZW5lclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgc3RhdHVzLCBzdGF0dXNUZXh0LCByZXNwb25zZXM7XG5cblx0XHRcdFx0XHRcdC8vIFdhcyBuZXZlciBjYWxsZWQgYW5kIGlzIGFib3J0ZWQgb3IgY29tcGxldGVcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgJiYgKCBpc0Fib3J0IHx8IHhoci5yZWFkeVN0YXRlID09PSA0ICkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENsZWFuIHVwXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWJvcnQgbWFudWFsbHkgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdGlmICggaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTwxMFxuXHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vICgjMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcy50ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcblx0XHRcdFx0XHRcdFx0XHQvLyBzdGF0dXNUZXh0IGZvciBmYXVsdHkgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoKCBlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2Ugbm9ybWFsaXplIHdpdGggV2Via2l0IGdpdmluZyBhbiBlbXB0eSBzdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGaWx0ZXIgc3RhdHVzIGZvciBub24gc3RhbmRhcmQgYmVoYXZpb3JzXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcmVxdWVzdCBpcyBsb2NhbCBhbmQgd2UgaGF2ZSBkYXRhOiBhc3N1bWUgYSBzdWNjZXNzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gKHN1Y2Nlc3Mgd2l0aCBubyBkYXRhIHdvbid0IGdldCBub3RpZmllZCwgdGhhdCdzIHRoZSBiZXN0IHdlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY2FuIGRvIGdpdmVuIGN1cnJlbnQgaW1wbGVtZW50YXRpb25zKVxuXHRcdFx0XHRcdFx0XHRcdGlmICggIXN0YXR1cyAmJiBvcHRpb25zLmlzTG9jYWwgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSByZXNwb25zZXMudGV4dCA/IDIwMCA6IDQwNDtcblx0XHRcdFx0XHRcdFx0XHQvLyBJRSAtICMxNDUwOiBzb21ldGltZXMgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMTIyMyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwNDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ2FsbCBjb21wbGV0ZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggc3RhdHVzLCBzdGF0dXNUZXh0LCByZXNwb25zZXMsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoICFvcHRpb25zLmFzeW5jICkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgd2UncmUgaW4gc3luYyBtb2RlIHdlIGZpcmUgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXHRcdFx0XHRcdFx0Ly8gKElFNiAmIElFNykgaWYgaXQncyBpbiBjYWNoZSBhbmQgaGFzIGJlZW5cblx0XHRcdFx0XHRcdC8vIHJldHJpZXZlZCBkaXJlY3RseSB3ZSBuZWVkIHRvIGZpcmUgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBBZGQgdG8gdGhlIGxpc3Qgb2YgYWN0aXZlIHhociBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayggdW5kZWZpbmVkLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIEZ1bmN0aW9ucyB0byBjcmVhdGUgeGhyc1xuZnVuY3Rpb24gY3JlYXRlU3RhbmRhcmRYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCggZSApIHt9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVhIUigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxIVFRQXCIgKTtcblx0fSBjYXRjaCggZSApIHt9XG59XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBnbG9iYWxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdHMuZ2xvYmFsID0gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgalF1ZXJ5KFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuXHRcdFx0XHRzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggcy5zY3JpcHRDaGFyc2V0ICkge1xuXHRcdFx0XHRcdHNjcmlwdC5jaGFyc2V0ID0gcy5zY3JpcHRDaGFyc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NyaXB0LnNyYyA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG5cdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oIF8sIGlzQWJvcnQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgfHwgIXNjcmlwdC5yZWFkeVN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoIHNjcmlwdC5yZWFkeVN0YXRlICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuXHRcdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0aWYgKCBzY3JpcHQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxsYmFjayBpZiBub3QgYWJvcnRcblx0XHRcdFx0XHRcdGlmICggIWlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCAyMDAsIFwic3VjY2Vzc1wiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIENpcmN1bXZlbnQgSUU2IGJ1Z3Mgd2l0aCBiYXNlIGVsZW1lbnRzICgjMjcwOSBhbmQgIzQzNzgpIGJ5IHByZXBlbmRpbmdcblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNjcmlwdCApIHtcblx0XHRcdFx0XHRzY3JpcHQub25sb2FkKCB1bmRlZmluZWQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmICEoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgcmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCByZXNwb25zZSwgdHlwZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cblx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiwgdXJsLmxlbmd0aCApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9KS5kb25lKGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0fSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFsgXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIiBdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59KTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG5cbnZhciBkb2NFbGVtID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdGpRdWVyeS5pbkFycmF5KFwiYXV0b1wiLCBbIGN1ckNTU1RvcCwgY3VyQ1NTTGVmdCBdICkgPiAtMTtcblxuXHRcdC8vIG5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0Ly8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH1cblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgICsgKCB3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgKSAgLSAoIGRvY0VsZW0uY2xpZW50VG9wICB8fCAwICksXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArICggd2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCApIC0gKCBkb2NFbGVtLmNsaWVudExlZnQgfHwgMCApXG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0Ly8gZml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0Ly8gd2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHQvLyBub3RlOiB3aGVuIGFuIGVsZW1lbnQgaGFzIG1hcmdpbjogYXV0byB0aGUgb2Zmc2V0TGVmdCBhbmQgbWFyZ2luTGVmdFxuXHRcdC8vIGFyZSB0aGUgc2FtZSBpbiBTYWZhcmkgY2F1c2luZyBvZmZzZXQubGVmdCB0byBpbmNvcnJlY3RseSBiZSAwXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSlcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gL1kvLnRlc3QoIHByb3AgKTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyAocHJvcCBpbiB3aW4pID8gd2luWyBwcm9wIF0gOlxuXHRcdFx0XHRcdHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIG1ldGhvZCBdIDpcblx0XHRcdFx0XHRlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHRcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCB3ZSBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXHRcdFx0XHQvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0pO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXHRcdC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLCB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHQvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGNhdXNlcyBidWcgIzM4MzggaW4gSUU2Lzggb25seSwgYnV0IHRoZXJlIGlzIGN1cnJlbnRseSBubyBnb29kLCBzbWFsbCB3YXkgdG8gZml4IGl0LlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0pO1xufVxuXG5cblxuXG52YXJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluXG4vLyBBTUQgKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBsb2Rhc2ggMy42LjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzMuNi4wJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB3cmFwcGVyIG1ldGFkYXRhLiAqL1xuICB2YXIgQklORF9GTEFHID0gMSxcbiAgICAgIEJJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBDVVJSWV9GTEFHID0gOCxcbiAgICAgIENVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFBBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBBUllfRkxBRyA9IDEyOCxcbiAgICAgIFJFQVJHX0ZMQUcgPSAyNTY7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2AuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB3aGVuIGEgZnVuY3Rpb24gYmVjb21lcyBob3QuICovXG4gIHZhciBIT1RfQ09VTlQgPSAxNTAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9EUk9QX1dISUxFX0ZMQUcgPSAwLFxuICAgICAgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMjtcblxuICAvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xuICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzl8Izk2KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFya3MgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyM10vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSGV4UHJlZml4ID0gL14wW3hYXS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbiAgdmFyIHJlSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzcGVjaWFsIGNoYXJhY3RlcnNdKGh0dHA6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL2NoYXJhY3RlcnMuaHRtbCNzcGVjaWFsKS5cbiAgICogSW4gYWRkaXRpb24gdG8gc3BlY2lhbCBjaGFyYWN0ZXJzIHRoZSBmb3J3YXJkIHNsYXNoIGlzIGVzY2FwZWQgdG8gYWxsb3cgZm9yXG4gICAqIGVhc2llciBgZXZhbGAgdXNlIGFuZCBgRnVuY3Rpb25gIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhcnMgPSAvWy4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXJzID0gUmVnRXhwKHJlUmVnRXhwQ2hhcnMuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyB0byBjcmVhdGUgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVdvcmRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cHBlciA9ICdbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXScsXG4gICAgICAgIGxvd2VyID0gJ1thLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZdKyc7XG5cbiAgICByZXR1cm4gUmVnRXhwKHVwcGVyICsgJysoPz0nICsgdXBwZXIgKyBsb3dlciArICcpfCcgKyB1cHBlciArICc/JyArIGxvd2VyICsgJ3wnICsgdXBwZXIgKyAnK3xbMC05XSsnLCAnZycpO1xuICB9KCkpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCBmb3Igd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHdoaXRlc3BhY2UgPSAoXG4gICAgLy8gQmFzaWMgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICcgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmYnICtcblxuICAgIC8vIExpbmUgdGVybWluYXRvcnMuXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyBVbmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzLlxuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQXJyYXlCdWZmZXInLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXRoJywgJ051bWJlcicsXG4gICAgJ09iamVjdCcsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdfJywgJ2NsZWFyVGltZW91dCcsICdkb2N1bWVudCcsXG4gICAgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnd2luZG93J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgYnkgYF8udGhyb3R0bGVgLiAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNDJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICdgJzogJyYjOTY7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIixcbiAgICAnJiM5NjsnOiAnYCdcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YC4gKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWVcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSBvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZiAmJiBzZWxmLk9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgd2luZG93YC4gKi9cbiAgdmFyIGZyZWVXaW5kb3cgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgJiYgd2luZG93Lk9iamVjdCAmJiB3aW5kb3c7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqXG4gICAqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBgdGhpc2AgdmFsdWUgaXMgdXNlZCBpZiBpdCBpcyB0aGUgZ2xvYmFsIG9iamVjdCB0byBhdm9pZCBHcmVhc2Vtb25rZXknc1xuICAgKiByZXN0cmljdGVkIGB3aW5kb3dgIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgd2luZG93YCBvYmplY3QgaXMgdXNlZC5cbiAgICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCAoKGZyZWVXaW5kb3cgIT09ICh0aGlzICYmIHRoaXMud2luZG93KSkgJiYgZnJlZVdpbmRvdykgfHwgZnJlZVNlbGYgfHwgdGhpcztcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNvbXBhcmVBc2NlbmRpbmdgIHdoaWNoIGNvbXBhcmVzIHZhbHVlcyBhbmRcbiAgICogc29ydHMgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIgd2l0aG91dCBndWFyYW50ZWVpbmcgYSBzdGFibGUgc29ydC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZSB0byBgb3RoZXJgLlxuICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIGB2YWx1ZWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgdmFyIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyO1xuXG4gICAgICBpZiAodmFsdWUgPiBvdGhlciB8fCAhdmFsSXNSZWZsZXhpdmUgfHwgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyAmJiBvdGhJc1JlZmxleGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCBvdGhlciB8fCAhb3RoSXNSZWZsZXhpdmUgfHwgKHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJyAmJiB2YWxJc1JlZmxleGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRnVuY3Rpb25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZW52aXJvbm1lbnRzXG4gICAqIHdpdGggaW5jb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBBdm9pZCBhIENoYWtyYSBKSVQgYnVnIGluIGNvbXBhdGliaWxpdHkgbW9kZXMgb2YgSUUgMTEuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9pc3N1ZXMvMTYyMSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0IGlzIG5vdCBvbmUuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICAgKiBmb3IgYG51bGxgIG9yIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogKHZhbHVlICsgJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayBmb3Igc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyQXRDYWxsYmFjayhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjaGFycy5pbmRleE9mKHN0cmluZy5jaGFyQXQoaW5kZXgpKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAqIG9mIGBzdHJpbmdgIHRoYXQgaXMgbm90IGZvdW5kIGluIGBjaGFyc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uIGFuZCBzdGFibGVcbiAgICogc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgb2JqZWN0YC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iamVjdC5jcml0ZXJpYSwgb3RoZXIuY3JpdGVyaWEpIHx8IChvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5zb3J0QnlPcmRlcmAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGVhY2ggZWxlbWVudFxuICAgKiBpbiBhIGNvbGxlY3Rpb24gYW5kIHN0YWJsZSBzb3J0IHRoZW0gaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcbiAgICpcbiAgICogSWYgb3JkZXJzIGlzIHVuc3BlY2lmaWVkLCBzb3J0IGluIGFzY2VuZGluZyBvcmRlciBmb3IgYWxsIHByb3BlcnRpZXMuXG4gICAqIE90aGVyd2lzZSwgZm9yIGVhY2ggcHJvcGVydHksIHNvcnQgaW4gYXNjZW5kaW5nIG9yZGVyIGlmIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGluXG4gICAqIG9yZGVycyBpcyB0cnVlLCBhbmQgZGVzY2VuZGluZyBvcmRlciBpZiBmYWxzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgb2JqZWN0YC5cbiAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXJzW2luZGV4XSA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMCA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAob3RoZXIgIT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0cmltbWVkTGVmdEluZGV4YCBhbmQgYHRyaW1tZWRSaWdodEluZGV4YCB0byBkZXRlcm1pbmUgaWYgYVxuICAgKiBjaGFyYWN0ZXIgY29kZSBpcyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvZGUgVGhlIGNoYXJhY3RlciBjb2RlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgY2hhckNvZGVgIGlzIHdoaXRlc3BhY2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKChjaGFyQ29kZSA8PSAxNjAgJiYgKGNoYXJDb2RlID49IDkgJiYgY2hhckNvZGUgPD0gMTMpIHx8IGNoYXJDb2RlID09IDMyIHx8IGNoYXJDb2RlID09IDE2MCkgfHwgY2hhckNvZGUgPT0gNTc2MCB8fCBjaGFyQ29kZSA9PSA2MTU4IHx8XG4gICAgICAoY2hhckNvZGUgPj0gODE5MiAmJiAoY2hhckNvZGUgPD0gODIwMiB8fCBjaGFyQ29kZSA9PSA4MjMyIHx8IGNoYXJDb2RlID09IDgyMzMgfHwgY2hhckNvZGUgPT0gODIzOSB8fCBjaGFyQ29kZSA9PSA4Mjg3IHx8IGNoYXJDb2RlID09IDEyMjg4IHx8IGNoYXJDb2RlID09IDY1Mjc5KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIG9wdGltaXplZCBmb3Igc29ydGVkIGFycmF5cyB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHNlZW4sXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICBpZiAoIWluZGV4IHx8IHNlZW4gIT09IGNvbXB1dGVkKSB7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkTGVmdEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgaXNTcGFjZShzdHJpbmcuY2hhckNvZGVBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gdXNpbmcgYGNvbnRleHRgIHRvIG1vY2sgYERhdGUjZ2V0VGltZWAgdXNlIGluIGBfLm5vd2BcbiAgICogdmFyIG1vY2sgPSBfLnJ1bkluQ29udGV4dCh7XG4gICAqICAgJ0RhdGUnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7ICdnZXRUaW1lJzogZ2V0VGltZU1vY2sgfTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBvciBjcmVhdGluZyBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qc1xuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBET00gc3VwcG9ydC4gKi9cbiAgICB2YXIgZG9jdW1lbnQgPSAoZG9jdW1lbnQgPSBjb250ZXh0LndpbmRvdykgJiYgZG9jdW1lbnQuZG9jdW1lbnQ7XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byB0aGUgbGVuZ3RoIG9mIG4tdHVwbGVzIGZvciBgXy51bnppcGAuICovXG4gICAgdmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGVzY2FwZVJlZ0V4cChvYmpUb1N0cmluZylcbiAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3woZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheUJ1ZmZlciA9IGlzTmF0aXZlKEFycmF5QnVmZmVyID0gY29udGV4dC5BcnJheUJ1ZmZlcikgJiYgQXJyYXlCdWZmZXIsXG4gICAgICAgIGJ1ZmZlclNsaWNlID0gaXNOYXRpdmUoYnVmZmVyU2xpY2UgPSBBcnJheUJ1ZmZlciAmJiBuZXcgQXJyYXlCdWZmZXIoMCkuc2xpY2UpICYmIGJ1ZmZlclNsaWNlLFxuICAgICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBnZXRQcm90b3R5cGVPZiA9IGlzTmF0aXZlKGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKSAmJiBnZXRQcm90b3R5cGVPZixcbiAgICAgICAgcHVzaCA9IGFycmF5UHJvdG8ucHVzaCxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgU2V0ID0gaXNOYXRpdmUoU2V0ID0gY29udGV4dC5TZXQpICYmIFNldCxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5KSAmJiBVaW50OEFycmF5LFxuICAgICAgICBXZWFrTWFwID0gaXNOYXRpdmUoV2Vha01hcCA9IGNvbnRleHQuV2Vha01hcCkgJiYgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGNsb25lIGFycmF5IGJ1ZmZlcnMuICovXG4gICAgdmFyIEZsb2F0NjRBcnJheSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFNhZmFyaSA1IGVycm9ycyB3aGVuIHVzaW5nIGFuIGFycmF5IGJ1ZmZlciB0byBpbml0aWFsaXplIGEgdHlwZWQgYXJyYXlcbiAgICAgIC8vIHdoZXJlIHRoZSBhcnJheSBidWZmZXIncyBgYnl0ZUxlbmd0aGAgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIHR5cGVkXG4gICAgICAvLyBhcnJheSdzIGBCWVRFU19QRVJfRUxFTUVOVGAuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBjb250ZXh0LkZsb2F0NjRBcnJheSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBmdW5jKG5ldyBBcnJheUJ1ZmZlcigxMCksIDAsIDEpICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IGlzTmF0aXZlKG5hdGl2ZU5vdyA9IERhdGUubm93KSAmJiBuYXRpdmVOb3csXG4gICAgICAgIG5hdGl2ZU51bUlzRmluaXRlID0gaXNOYXRpdmUobmF0aXZlTnVtSXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUpICYmIG5hdGl2ZU51bUlzRmluaXRlLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgYC1JbmZpbml0eWAgYW5kIGBJbmZpbml0eWAuICovXG4gICAgdmFyIE5FR0FUSVZFX0lORklOSVRZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gICAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSBNYXRoLnBvdygyLCAzMikgLSAxLFxuICAgICAgICBNQVhfQVJSQVlfSU5ERVggPSAgTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgICAvKiogVXNlZCBhcyB0aGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGVhY2ggYEZsb2F0NjRBcnJheWAgZWxlbWVudC4gKi9cbiAgICB2YXIgRkxPQVQ2NF9CWVRFU19QRVJfRUxFTUVOVCA9IEZsb2F0NjRBcnJheSA/IEZsb2F0NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAgICAgKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgY2hhaW5pbmcuXG4gICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuICAgICAqIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXR1cm4gYSBib29sZWFuIG9yIHNpbmdsZSB2YWx1ZSB3aWxsXG4gICAgICogYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHJldHVybmluZyB0aGUgdW53cmFwcGVkIHZhbHVlLiBFeHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIG1heSBiZSBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC4gVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSxcbiAgICAgKiB0aGF0IGlzLCBleGVjdXRpb24gaXMgZGVmZXJyZWQgdW50aWwgYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseVxuICAgICAqIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLiBTaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdGhhdCBtZXJnZXMgaXRlcmF0ZWVzIHRvIGF2b2lkIGNyZWF0aW5nIGludGVybWVkaWF0ZVxuICAgICAqIGFycmF5cyBhbmQgcmVkdWNlIHRoZSBudW1iZXIgb2YgaXRlcmF0ZWUgZXhlY3V0aW9ucy5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsXG4gICAgICogYGZpcnN0YCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcGx1Y2tgLCBgcmVqZWN0YCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcbiAgICAgKiBhbmQgYHdoZXJlYFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25zdGFudGAsXG4gICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZmlsbGAsXG4gICAgICogYGZpbHRlcmAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZvckVhY2hgLFxuICAgICAqIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsIGBpbnZva2VgLCBga2V5c2AsXG4gICAgICogYGtleXNJbmAsIGBtYXBgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCwgYG1lbW9pemVgLCBgbWVyZ2VgLFxuICAgICAqIGBtaXhpbmAsIGBuZWdhdGVgLCBgbm9vcGAsIGBvbWl0YCwgYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLFxuICAgICAqIGBwYXJ0aXRpb25gLCBgcGlja2AsIGBwbGFudGAsIGBwbHVja2AsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLFxuICAgICAqIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByZWFyZ2AsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc29ydEJ5QWxsYCwgYHNvcnRCeU9yZGVyYCwgYHNwbGljZWAsXG4gICAgICogYHNwcmVhZGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCxcbiAgICAgKiBgdGhyb3R0bGVgLCBgdGhydWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCxcbiAgICAgKiBgdW5pb25gLCBgdW5pcWAsIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHZhbHVlc2AsIGB2YWx1ZXNJbmAsIGB3aGVyZWAsXG4gICAgICogYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgemlwYCwgYW5kIGB6aXBPYmplY3RgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgZGVidXJyYCxcbiAgICAgKiBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCxcbiAgICAgKiBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaW5kV2hlcmVgLCBgZmlyc3RgLCBgaGFzYCxcbiAgICAgKiBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNFcnJvcmAsXG4gICAgICogYGlzRmluaXRlYCxgaXNGdW5jdGlvbmAsIGBpc01hdGNoYCwgYGlzTmF0aXZlYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsXG4gICAgICogYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLFxuICAgICAqIGBpc1R5cGVkQXJyYXlgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsIGBtYXhgLCBgbWluYCxcbiAgICAgKiBgbm9Db25mbGljdGAsIGBub3dgLCBgcGFkYCwgYHBhZExlZnRgLCBgcGFkUmlnaHRgLCBgcGFyc2VJbnRgLCBgcG9wYCxcbiAgICAgKiBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJ1bkluQ29udGV4dGAsXG4gICAgICogYHNoaWZ0YCwgYHNpemVgLCBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3VtYCwgYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUxlZnRgLFxuICAgICAqIGB0cmltUmlnaHRgLCBgdHJ1bmNgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kIGBzYW1wbGVgIHdpbGwgcmV0dXJuIGEgd3JhcHBlZCB2YWx1ZSB3aGVuIGBuYCBpcyBwcm92aWRlZCxcbiAgICAgKiBvdGhlcndpc2UgYW4gdW53cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fY2hhaW5fXycpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBhbGwgY2hhaW5pbmcgd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgY2hhaW5pbmcgZm9yIGFsbCB3cmFwcGVyIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FjdGlvbnM9W11dIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCwgYWN0aW9ucykge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IGFjdGlvbnMgfHwgW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGVudmlyb25tZW50IGZlYXR1cmUgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAoZnVuY3Rpb24oeCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBmdW5jdGlvbnMgY2FuIGJlIGRlY29tcGlsZWQgYnkgYEZ1bmN0aW9uI3RvU3RyaW5nYFxuICAgICAgICogKGFsbCBidXQgRmlyZWZveCBPUyBjZXJ0aWZpZWQgYXBwcywgb2xkZXIgT3BlcmEgbW9iaWxlIGJyb3dzZXJzLCBhbmRcbiAgICAgICAqIHRoZSBQbGF5U3RhdGlvbiAzOyBmb3JjZWQgYGZhbHNlYCBmb3IgV2luZG93cyA4IGFwcHMpLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydC5mdW5jRGVjb21wID0gL1xcYnRoaXNcXGIvLnRlc3QoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiB0aGUgRE9NIGlzIHN1cHBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1cHBvcnQuZG9tID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLm5vZGVUeXBlID09PSAxMTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzdXBwb3J0LmRvbSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICAgKlxuICAgICAgICogSW4gRmlyZWZveCA8IDQsIElFIDwgOSwgUGhhbnRvbUpTLCBhbmQgU2FmYXJpIDwgNS4xIGBhcmd1bWVudHNgIG9iamVjdFxuICAgICAgICogaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuIENocm9tZSA8IDI1IGFuZCBOb2RlLmpzIDwgMC4xMS4wIHRyZWF0XG4gICAgICAgKiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcyBub24tZW51bWVyYWJsZSBhbmQgZmFpbCBgaGFzT3duUHJvcGVydHlgXG4gICAgICAgKiBjaGVja3MgZm9yIGluZGV4ZXMgdGhhdCBleGNlZWQgdGhlaXIgZnVuY3Rpb24ncyBmb3JtYWwgcGFyYW1ldGVycyB3aXRoXG4gICAgICAgKiBhc3NvY2lhdGVkIHZhbHVlcyBvZiBgMGAuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICB0cnkge1xuICAgICAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KDAsIDApKTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gbnVsbDtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZHJvcENvdW50X18gPSAwO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IG51bGw7XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBQT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMuX192aWV3c19fID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5fX2FjdGlvbnNfXyxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgdmlld3MgPSB0aGlzLl9fdmlld3NfXyxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG5cbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFjdGlvbnMgPyBhcnJheUNvcHkoYWN0aW9ucykgOiBudWxsO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGl0ZXJhdGVlcyA/IGFycmF5Q29weShpdGVyYXRlZXMpIDogbnVsbDtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IHZpZXdzID8gYXJyYXlDb3B5KHZpZXdzKSA6IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKTtcbiAgICAgIGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJheS5sZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcyA/IGl0ZXJhdGVlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGU7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0RST1BfV0hJTEVfRkxBRykge1xuICAgICAgICAgICAgaWYgKGRhdGEuZG9uZSAmJiAoaXNSaWdodCA/IChpbmRleCA+IGRhdGEuaW5kZXgpIDogKGluZGV4IDwgZGF0YS5pbmRleCkpKSB7XG4gICAgICAgICAgICAgIGRhdGEuY291bnQgPSAwO1xuICAgICAgICAgICAgICBkYXRhLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmICghZGF0YS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBsaW1pdCA9IGRhdGEubGltaXQ7XG4gICAgICAgICAgICAgIGlmICghKGRhdGEuZG9uZSA9IGxpbWl0ID4gLTEgPyAoZGF0YS5jb3VudCsrID49IGxpbWl0KSA6ICFpdGVyYXRlZSh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS92YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBuYW1lIENhY2hlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwRGVsZXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNhY2hlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBHZXQoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ID09ICdfX3Byb3RvX18nID8gdW5kZWZpbmVkIDogdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT0gJ19fcHJvdG9fXycgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fZGF0YV9fLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byBga2V5YCBvZiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAhPSAnX19wcm90b19fJykge1xuICAgICAgICB0aGlzLl9fZGF0YV9fW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLmRhdGEgPSB7ICdoYXNoJzogbmF0aXZlQ3JlYXRlKG51bGwpLCAnc2V0JzogbmV3IFNldCB9O1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRoaXMucHVzaCh2YWx1ZXNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNhY2hlYCBtaW1pY2tpbmcgdGhlIHJldHVybiBzaWduYXR1cmUgb2ZcbiAgICAgKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGNhY2hlLmRhdGEsXG4gICAgICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cbiAgICAgIHJldHVybiByZXN1bHQgPyAwIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcHVzaFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBkYXRhLnNldC5hZGQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXhgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlNYXgoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBORUdBVElWRV9JTkZJTklUWTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWluYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWluKGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zdW1gIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U3VtKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHQgKz0gK2FycmF5W2xlbmd0aF0gfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3RWYWx1ZSA9PSAndW5kZWZpbmVkJyA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25gIHVzZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBhc3NpZ25EZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgaWdub3Jlc1xuICAgICAqIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBjaGVja2luZyBpZiBhIHByb3BlcnR5IGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBvYmplY3QgYW5kIHNvdXJjZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25Pd25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3RWYWx1ZSA9PSAndW5kZWZpbmVkJyB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpXG4gICAgICAgID8gc291cmNlVmFsdWVcbiAgICAgICAgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIGlmICghY3VzdG9taXplcikge1xuICAgICAgICByZXR1cm4gYmFzZUNvcHkoc291cmNlLCBvYmplY3QsIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyKHZhbHVlLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZ3MgYW5kIGluZGl2aWR1YWxcbiAgICAgKiBrZXkgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgbmFtZXMgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQoY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIGlzQXJyID0gaXNMZW5ndGgobGVuZ3RoKSxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShwcm9wc0xlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZUZsb2F0KGtleSk7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzSW5kZXgoa2V5LCBsZW5ndGgpID8gY29sbGVjdGlvbltrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2FsbGJhY2tgIHdoaWNoIHN1cHBvcnRzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAodHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gZnVuY1xuICAgICAgICAgIDogYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGZ1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnXG4gICAgICAgID8gYmFzZVByb3BlcnR5KGZ1bmMgKyAnJylcbiAgICAgICAgOiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGZ1bmMgKyAnJywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCByZXN1bHQsIGtleXModmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICAgICAgPyBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApXG4gICAgICAgICAgICA6IChvYmplY3QgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZS5cbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjb250ZXh0Lk9iamVjdCgpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBhbiBpbmRleFxuICAgICAqIG9mIHdoZXJlIHRvIHNsaWNlIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgd2hpY2ggYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgY2FjaGUgPSAoaXNDb21tb24gJiYgdmFsdWVzLmxlbmd0aCA+PSAyMDApID8gY3JlYXRlQ2FjaGUodmFsdWVzKSA6IG51bGwsXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlLCAwKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6ICgrZW5kIHx8IDApO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IChlbmQgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB3aGlsZSAoc3RhcnQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRgLCBgXy5maW5kTGFzdGAsIGBfLmZpbmRLZXlgLCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0S2V5XSBTcGVjaWZ5IHJldHVybmluZyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50XG4gICAgICogIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYywgcmV0S2V5KSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmV0S2V5ID8ga2V5IDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBhZGRlZCBzdXBwb3J0IGZvciByZXN0cmljdGluZ1xuICAgICAqIGZsYXR0ZW5pbmcgYW5kIHNwZWNpZnlpbmcgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGVlcCBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdHJpY3QgUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXAsIGlzU3RyaWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlRmxhdHRlbih2YWx1ZSwgaXNEZWVwLCBpc1N0cmljdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWxJbmRleCA9IC0xLFxuICAgICAgICAgICAgICB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvckluYCBhbmQgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzXG4gICAgICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBlYWNoIHByb3BlcnR5LiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICAgKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSB0aG9zZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuICAgICAqIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3IgaWRlbnRpY2FsIHZhbHVlcy5cbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgLy8gVHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWwuXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMCB8fCAoMSAvIHZhbHVlID09IDEgLyBvdGhlcik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsVHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICBvdGhUeXBlID0gdHlwZW9mIG90aGVyO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgIGlmICgodmFsVHlwZSAhPSAnZnVuY3Rpb24nICYmIHZhbFR5cGUgIT0gJ29iamVjdCcgJiYgb3RoVHlwZSAhPSAnZnVuY3Rpb24nICYmIG90aFR5cGUgIT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsKSB7XG4gICAgICAgIC8vIFJldHVybiBgZmFsc2VgIHVubGVzcyBib3RoIHZhbHVlcyBhcmUgYE5hTmAuXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0xvb3NlXSBTcGVjaWZ5IHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gYXJyYXlUYWcsXG4gICAgICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgICAgIGlmICghb2JqSXNBcnIpIHtcbiAgICAgICAgb2JqVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICAgICAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcbiAgICAgICAgICBvYmpUYWcgPSBvYmplY3RUYWc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqVGFnICE9IG9iamVjdFRhZykge1xuICAgICAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3RoSXNBcnIpIHtcbiAgICAgICAgb3RoVGFnID0gb2JqVG9TdHJpbmcuY2FsbChvdGhlcik7XG4gICAgICAgIGlmIChvdGhUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvdGhUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb3RoSXNBcnIgPSBpc1R5cGVkQXJyYXkob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgb2JqSXNPYmogPSAob2JqVGFnID09IG9iamVjdFRhZyB8fCAoaXNMb29zZSAmJiBvYmpUYWcgPT0gZnVuY1RhZykpLFxuICAgICAgICAgIG90aElzT2JqID0gKG90aFRhZyA9PSBvYmplY3RUYWcgfHwgKGlzTG9vc2UgJiYgb3RoVGFnID09IGZ1bmNUYWcpKSxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG4gICAgICAgIHJldHVybiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICBpZiAoIWlzU2FtZVRhZyAmJiAhKG9iaklzT2JqICYmIG90aElzT2JqKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbFdyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKHZhbFdyYXBwZWQgfHwgb3RoV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmModmFsV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIGBvYmplY3RgIGFuZCBgb3RoZXJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgIHN0YWNrQS5wdXNoKG9iamVjdCk7XG4gICAgICBzdGFja0IucHVzaChvdGhlcik7XG5cbiAgICAgIHZhciByZXN1bHQgPSAob2JqSXNBcnIgPyBlcXVhbEFycmF5cyA6IGVxdWFsT2JqZWN0cykob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBzb3VyY2UgcHJvcGVydHkgbmFtZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBzb3VyY2UgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0cmljdENvbXBhcmVGbGFncyBTdHJpY3QgY29tcGFyaXNvbiBmbGFncyBmb3Igc291cmNlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIHN0cmljdENvbXBhcmVGbGFnc1tpbmRleF0pXG4gICAgICAgICAgICAgID8gdmFsdWVzW2luZGV4XSAhPT0gb2JqZWN0W3Byb3BzW2luZGV4XV1cbiAgICAgICAgICAgICAgOiAhKHByb3BzW2luZGV4XSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIHN0cmljdENvbXBhcmVGbGFnc1tpbmRleF0pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIG9ialZhbHVlICE9ICd1bmRlZmluZWQnIHx8IChrZXkgaW4gb2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2VzIG5vdCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIG9iamVjdFtrZXldID09PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlICE9ICd1bmRlZmluZWQnIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHN0cmljdENvbXBhcmVGbGFncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgdmFsdWVzW2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgc3RyaWN0Q29tcGFyZUZsYWdzW2xlbmd0aF0gPSBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgYmFzZUlzTWF0Y2godG9PYmplY3Qob2JqZWN0KSwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjb2VyY2UgYGtleWBcbiAgICAgKiB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgb2JqZWN0W2tleV0gPT09IHZhbHVlICYmXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlICE9ICd1bmRlZmluZWQnIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgYmFzZUlzRXF1YWwodmFsdWUsIG9iamVjdFtrZXldLCBudWxsLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgaXNTcmNBcnIgPSBpc0xlbmd0aChzb3VyY2UubGVuZ3RoKSAmJiAoaXNBcnJheShzb3VyY2UpIHx8IGlzVHlwZWRBcnJheShzb3VyY2UpKTtcbiAgICAgIChpc1NyY0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSwgc291cmNlKSB7XG4gICAgICAgIGlmIChpc09iamVjdExpa2Uoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNDb21tb24gPSB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaXNTcmNBcnIgfHwgdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGgsXG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBzcmNWYWx1ZSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJztcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNMZW5ndGgoc3JjVmFsdWUubGVuZ3RoKSAmJiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiAoKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkgPyBhcnJheUNvcHkodmFsdWUpIDogW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGlzQXJndW1lbnRzKHZhbHVlKVxuICAgICAgICAgICAgPyB0b1BsYWluT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZVxuICAgICAgLy8gaXQgd2l0aCBpdHMgbWVyZ2VkIHZhbHVlLlxuICAgICAgc3RhY2tBLnB1c2goc3JjVmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBvYmplY3Rba2V5XSA9IG1lcmdlRnVuYyhyZXN1bHQsIHNyY1ZhbHVlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdoaWNoIGRvZXMgbm90IGNvZXJjZSBga2V5YCB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG4gICAgICogYW5kIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAgICogdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEZyb21Db2xsZWN0aW9uIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudFxuICAgICAqICBvZiBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUNvbGxlY3Rpb24sIGVhY2hGdW5jKSB7XG4gICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0RnJvbUNvbGxlY3Rpb25cbiAgICAgICAgICA/IChpbml0RnJvbUNvbGxlY3Rpb24gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZVxuICAgICAqIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeU9yZGVyYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgcHJvcHNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgcHJvcHMsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gaXNMZW5ndGgobGVuZ3RoKSA/IEFycmF5KGxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIGNyaXRlcmlhID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBjcml0ZXJpYVtsZW5ndGhdID0gdmFsdWUgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlW3Byb3BzW2xlbmd0aF1dO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6IGluZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gK2l0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikgfHwgMDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpc0xhcmdlID0gaXNDb21tb24gJiYgbGVuZ3RoID49IDIwMCxcbiAgICAgICAgICBzZWVuID0gaXNMYXJnZSA/IGNyZWF0ZUNhY2hlKCkgOiBudWxsLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCAwKSA8IDApIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogcmV0dXJuZWQgYnkgYGtleXNGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kcm9wUmlnaHRXaGlsZWAsIGBfLmRyb3BXaGlsZWAsIGBfLnRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBhbmQgYF8udGFrZVdoaWxlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhY3Rpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbcmVzdWx0XSxcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbnNbaW5kZXhdO1xuXG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYWN0aW9uLmFyZ3MpO1xuICAgICAgICByZXN1bHQgPSBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJpbmFyeUluZGV4YCBleGNlcHQgdGhhdCBpdCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc1VuZGVmID0gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gZmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgaXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQ7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IGlzUmVmbGV4aXZlIHx8IHJldEhpZ2hlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZikge1xuICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IHR5cGVvZiBjb21wdXRlZCAhPSAndW5kZWZpbmVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUNhbGxiYWNrYCB3aGljaCBvbmx5IHN1cHBvcnRzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlclNsaWNlLmNhbGwoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXJTbGljZSkge1xuICAgICAgLy8gUGhhbnRvbUpTIGhhcyBgQXJyYXlCdWZmZXJgIGFuZCBgVWludDhBcnJheWAgYnV0IG5vdCBgRmxvYXQ2NEFycmF5YC5cbiAgICAgIGJ1ZmZlckNsb25lID0gIShBcnJheUJ1ZmZlciAmJiBVaW50OEFycmF5KSA/IGNvbnN0YW50KG51bGwpIDogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBmbG9hdExlbmd0aCA9IEZsb2F0NjRBcnJheSA/IGZsb29yKGJ5dGVMZW5ndGggLyBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5UKSA6IDAsXG4gICAgICAgICAgICBvZmZzZXQgPSBmbG9hdExlbmd0aCAqIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGZsb2F0TGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRmxvYXQ2NEFycmF5KHJlc3VsdCwgMCwgZmxvYXRMZW5ndGgpO1xuICAgICAgICAgIHZpZXcuc2V0KG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLCAwLCBmbG9hdExlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlTGVuZ3RoICE9IG9mZnNldCkge1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQsIG9mZnNldCk7XG4gICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoYXJnc0xlbmd0aCArIGxlZnRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuICAgICAgdmFyIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGFyZ3NMZW5ndGggKyByaWdodExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgcGFkID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtwYWQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbcGFkICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gYWNjdW11bGF0b3JcbiAgICAgKiBvYmplY3QgY29tcG9zZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggYW4gaXRlcmF0ZWUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5jb3VudEJ5YCwgYF8uZ3JvdXBCeWAsIGBfLmluZGV4QnlgLFxuICAgICAqIGFuZCBgXy5wYXJ0aXRpb25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBmdW5jdGlvbiB0byBpbml0aWFsaXplIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIGEgZ2l2ZW5cbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5hc3NpZ25gLCBgXy5kZWZhdWx0c2AsIGFuZCBgXy5tZXJnZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBvYmplY3QgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VzdG9taXplciA9IGFyZ3NbbGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICB0aGlzQXJnID0gYXJnc1tsZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGd1YXJkID0gYXJnc1szXTtcblxuICAgICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCA1KTtcbiAgICAgICAgICBsZW5ndGggLT0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gKGxlbmd0aCA+IDIgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ2Z1bmN0aW9uJykgPyB0aGlzQXJnIDogbnVsbDtcbiAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFyZ3NbMV0sIGFyZ3NbMl0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPT0gMyA/IG51bGwgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmRXcmFwcGVyKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBTZXRgIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdCBpZiBgU2V0YCBpcyBzdXBwb3J0ZWQsIGVsc2UgYG51bGxgLlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVDYWNoZSA9ICEobmF0aXZlQ3JlYXRlICYmIFNldCkgPyBjb25zdGFudChudWxsKSA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBjb21wb3VuZCB3b3JkcyBvdXQgb2YgdGhlIHdvcmRzIGluIGFcbiAgICAgKiBnaXZlbiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBhcnJheSA9IHdvcmRzKGRlYnVycihzdHJpbmcpKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0LCBhcnJheVtpbmRleF0sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yV3JhcHBlcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcgVGhlIGN1cnJ5IGJpdCBmbGFnLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJ5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZsYWcpIHtcbiAgICAgIGZ1bmN0aW9uIGN1cnJ5RnVuYyhmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIGFyaXR5LCBndWFyZCkpIHtcbiAgICAgICAgICBhcml0eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeUZ1bmMucGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycnlGdW5jO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5tYXhgIG9yIGBfLm1pbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBleHRyZW11bSB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWluXSBTcGVjaWZ5IHJldHVybmluZyB0aGUgbWluaW11bSwgaW5zdGVhZCBvZiB0aGUgbWF4aW11bSxcbiAgICAgKiAgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZXh0cmVtdW0gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRXh0cmVtdW0oYXJyYXlGdW5jLCBpc01pbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICAgIGl0ZXJhdGVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKCksXG4gICAgICAgICAgICBub0l0ZXJhdGVlID0gaXRlcmF0ZWUgPT0gbnVsbDtcblxuICAgICAgICBpZiAoIShmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgbm9JdGVyYXRlZSkpIHtcbiAgICAgICAgICBub0l0ZXJhdGVlID0gZmFsc2U7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBmdW5jKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JdGVyYXRlZSkge1xuICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKCFpc0FyciAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgaXRlcmF0ZWUgPSBjaGFyQXRDYWxsYmFjaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpc0FyciA/IGNvbGxlY3Rpb24gOiB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHJlbXVtQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGlzTWluKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlRmluZEluZGV4KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbVJpZ2h0KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGNvbGxlY3Rpb25baW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlRmluZChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEluZGV4YCBvciBgXy5maW5kTGFzdEluZGV4YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kSW5kZXgoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kS2V5YCBvciBgXy5maW5kTGFzdEtleWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kS2V5KG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICByZXR1cm4gYmFzZUZpbmQob2JqZWN0LCBwcmVkaWNhdGUsIG9iamVjdEZ1bmMsIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHNbMF07IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZXIsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gMCxcbiAgICAgICAgICAgIGZ1bmNzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSB3cmFwcGVyID8gJycgOiBnZXRGdW5jTmFtZShmdW5jKTtcbiAgICAgICAgICB3cmFwcGVyID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gbmV3IExvZGFzaFdyYXBwZXIoW10pIDogd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyAtMSA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyk7XG5cbiAgICAgICAgICB2YXIgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiBudWxsO1xuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkpIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpID8gd3JhcHBlcltmdW5jTmFtZV0oKSA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQoYXJnc1swXSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yRWFjaGAgb3IgYF8uZm9yRWFjaFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGFycmF5RnVuYywgZWFjaEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG4gICAgICAgICAgOiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JJbihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXNBcmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXNBcmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ucGFkTGVmdGAgb3IgYF8ucGFkUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgcGFkZGluZyBmcm9tIHRoZSByaWdodC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkRGlyKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZyAmJiAoKGZyb21SaWdodCA/IHN0cmluZyA6ICcnKSArIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSArIChmcm9tUmlnaHQgPyAnJyA6IHN0cmluZykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucGFydGlhbGAgb3IgYF8ucGFydGlhbFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBwYXJ0aWFsIGJpdCBmbGFnLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWwgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmbGFnKSB7XG4gICAgICB2YXIgcGFydGlhbEZ1bmMgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgcGFydGlhbEZ1bmMucGxhY2Vob2xkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBmbGFnLCBudWxsLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnJlZHVjZWAgb3IgYF8ucmVkdWNlUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBpbml0RnJvbUFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpXG4gICAgICAgICAgOiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXksIGVhY2hGdW5jKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWRXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIEFSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiBDVVJSWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiBDVVJSWV9CT1VORF9GTEFHLFxuICAgICAgICAgIGlzQ3VycnlSaWdodCA9IGJpdG1hc2sgJiBDVVJSWV9SSUdIVF9GTEFHO1xuXG4gICAgICB2YXIgQ3RvciA9ICFpc0JpbmRLZXkgJiYgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyksXG4gICAgICAgICAga2V5ID0gZnVuYztcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgLy8gQXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IHVzZSBkaXNxdWFsaWZ5aW5nIG9wdGltaXphdGlvbnMgYnlcbiAgICAgICAgLy8gY29udmVydGluZyBpdCB0byBhbiBhcnJheSBiZWZvcmUgcHJvdmlkaW5nIGl0IHRvIG90aGVyIGZ1bmN0aW9ucy5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJ5IHx8IGlzQ3VycnlSaWdodCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHdyYXBwZXIucGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgIGFyZ3NIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgbGVuZ3RoIC09IGFyZ3NIb2xkZXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIHZhciBuZXdBcmdQb3MgPSBhcmdQb3MgPyBhcnJheUNvcHkoYXJnUG9zKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmV3QXJpdHkgPSBuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApLFxuICAgICAgICAgICAgICAgIG5ld3NIb2xkZXJzID0gaXNDdXJyeSA/IGFyZ3NIb2xkZXJzIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gbnVsbCA6IGFyZ3NIb2xkZXJzLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IGFyZ3MgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gbnVsbCA6IGFyZ3M7XG5cbiAgICAgICAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBQQVJUSUFMX0ZMQUcgOiBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBQQVJUSUFMX1JJR0hUX0ZMQUcgOiBQQVJUSUFMX0ZMQUcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzQ3VycnlCb3VuZCkge1xuICAgICAgICAgICAgICBiaXRtYXNrICY9IH4oQklORF9GTEFHIHwgQklORF9LRVlfRkxBRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3c0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsIG5ld0hvbGRlcnNSaWdodCwgbmV3QXJnUG9zLCBhcnksIG5ld0FyaXR5XSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWRXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXM7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IChDdG9yIHx8IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpKSA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIHJlcXVpcmVkIGZvciBgc3RyaW5nYCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYGxlbmd0aGAuXG4gICAgICogVGhlIGBjaGFyc2Agc3RyaW5nIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBwYWRkaW5nIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZCBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gK2xlbmd0aDtcblxuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIHN0ckxlbmd0aDtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT0gbnVsbCA/ICcgJyA6IChjaGFycyArICcnKTtcbiAgICAgIHJldHVybiByZXBlYXQoY2hhcnMsIGNlaWwocGFkTGVuZ3RoIC8gY2hhcnMubGVuZ3RoKSkuc2xpY2UoMCwgcGFkTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqIHRoZSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgLy8gQXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IHVzZSBkaXNxdWFsaWZ5aW5nIG9wdGltaXphdGlvbnMgYnlcbiAgICAgICAgLy8gY29udmVydGluZyBpdCB0byBhbiBhcnJheSBiZWZvcmUgcHJvdmlkaW5nIGl0IGBmdW5jYC5cbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkoYXJnc0xlbmd0aCArIGxlZnRMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5zb3J0ZWRJbmRleGAgb3IgYF8uc29ydGVkTGFzdEluZGV4YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGluZGV4IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNvcnRlZEluZGV4KHJldEhpZ2hlc3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gKGZ1bmMgPT09IGJhc2VDYWxsYmFjayAmJiBpdGVyYXRlZSA9PSBudWxsKVxuICAgICAgICAgID8gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KVxuICAgICAgICAgIDogYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGZ1bmMoaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLCByZXRIaWdoZXN0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAgMjU2IC0gYF8uYXJ5YFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFBBUlRJQUxfRkxBRyB8IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICBsZW5ndGggLT0gKGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDApO1xuICAgICAgaWYgKGJpdG1hc2sgJiBQQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gbnVsbCA6IGdldERhdGEoZnVuYyksXG4gICAgICAgICAgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHldO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgICBhcml0eSA9IG5ld0RhdGFbOV07XG4gICAgICB9XG4gICAgICBuZXdEYXRhWzldID0gYXJpdHkgPT0gbnVsbFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogKG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCkgfHwgMCk7XG5cbiAgICAgIGlmIChiaXRtYXNrID09IEJJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZFdyYXBwZXIobmV3RGF0YVswXSwgbmV3RGF0YVsyXSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFBBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChCSU5EX0ZMQUcgfCBQQVJUSUFMX0ZMQUcpKSAmJiAhbmV3RGF0YVs0XS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldHRlcihyZXN1bHQsIG5ld0RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgYXJyYXlzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNMb29zZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAocmVzdWx0ICYmICsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHJlc3VsdCA9IGlzTG9vc2VcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4KVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICAgICAgdmFyIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltvdGhJbmRleF07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgICAgICA/IG90aGVyICE9ICtvdGhlclxuICAgICAgICAgICAgLy8gQnV0LCB0cmVhdCBgLTBgIHZzLiBgKzBgIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICAgIDogKG9iamVjdCA9PSAwID8gKCgxIC8gb2JqZWN0KSA9PSAoMSAvIG90aGVyKSkgOiBvYmplY3QgPT0gK290aGVyKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzTG9vc2UsXG4gICAgICAgICAgaW5kZXggPSAtMTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpc0xvb3NlXG4gICAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSlcbiAgICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgcmVzdWx0ID0gKG9ialZhbHVlICYmIG9ialZhbHVlID09PSBvdGhWYWx1ZSkgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZXh0cmVtdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggdmFsdWVcbiAgICAgKiBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNaW5dIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBtaW5pbXVtLCBpbnN0ZWFkIG9mIHRoZVxuICAgICAqICBtYXhpbXVtLCBleHRyZW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0cmVtdW1CeShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgaXNNaW4pIHtcbiAgICAgIHZhciBleFZhbHVlID0gaXNNaW4gPyBQT1NJVElWRV9JTkZJTklUWSA6IE5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICAgIGNvbXB1dGVkID0gZXhWYWx1ZSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKChpc01pbiA/IChjdXJyZW50IDwgY29tcHV0ZWQpIDogKGN1cnJlbnQgPiBjb21wdXRlZCkpIHx8XG4gICAgICAgICAgICAoY3VycmVudCA9PT0gZXhWYWx1ZSAmJiBjdXJyZW50ID09PSByZXN1bHQpKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJjYWxsYmFja1wiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uY2FsbGJhY2tgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUNhbGxiYWNrYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guY2FsbGJhY2sgfHwgY2FsbGJhY2s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGNhbGxiYWNrID8gYmFzZUNhbGxiYWNrIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ0NvdW50ID8gcmVzdWx0KGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RnVuY05hbWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudCgnJyk7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RhbnQubmFtZSA9PSAnY29uc3RhbnQnKSB7XG4gICAgICAgIHJldHVybiBiYXNlUHJvcGVydHkoJ25hbWUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLm5hbWUsXG4gICAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuXG4gICAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxudW1iZXJ9IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaW5kZXhPZiB8fCBpbmRleE9mO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbiA/IHJlc3VsdChjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmb3Jtc10gVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zID8gdHJhbnNmb3Jtcy5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICBDdG9yID0gT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoaXNEZWVwID8gYnVmZmVyQ2xvbmUoYnVmZmVyKSA6IGJ1ZmZlciwgb2JqZWN0LmJ5dGVPZmZzZXQsIG9iamVjdC5sZW5ndGgpO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3Iob2JqZWN0LnNvdXJjZSwgcmVGbGFncy5leGVjKG9iamVjdCkpO1xuICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSBvYmplY3QubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVyZXEgPSB0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVyZXEpIHtcbiAgICAgICAgdmFyIG90aGVyID0gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpO1xuICAgICAgcmV0dXJuICEhZnVuY05hbWUgJiYgZnVuYyA9PT0gbG9kYXNoW2Z1bmNOYW1lXSAmJiBmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICh2YWx1ZSA9PT0gMCA/ICgoMSAvIHZhbHVlKSA+IDApIDogIWlzT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHJlcXVpcmVkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZCBgXy5yZWFyZ2BcbiAgICAgKiBhdWdtZW50IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZSBleGVjdXRlZCBpbXBvcnRhbnQsXG4gICAgICogcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZSBhbiBleGNlcHRpb24gZm9yIGEgc2FmZVxuICAgICAqIGNvbW1vbiBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YCBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IEFSWV9GTEFHO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgIChzcmNCaXRtYXNrID09IEFSWV9GTEFHICYmIGJpdG1hc2sgPT0gQ1VSUllfRkxBRykgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBSRUFSR19GTEFHICYmIGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gKEFSWV9GTEFHIHwgUkVBUkdfRkxBRykgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gKGJpdG1hc2sgJiBCSU5EX0ZMQUcpID8gMCA6IENVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNF0pO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzZdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB0aGF0IHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgc3BlY2lmaWVkXG4gICAgICogYnkgdGhlIGBwcm9wc2AgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlBcnJheShvYmplY3QsIHByb3BzKSB7XG4gICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2AgdGhhdCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgXG4gICAgICogcmV0dXJucyB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGJhc2VGb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGFycmF5Q29weShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHkgZnVuY3Rpb25cbiAgICAgKiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWUgW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VTZXREYXRhKGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBoYXMgYSBgW1tQcm90b3R5cGVdXWBcbiAgICAgKiBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yLFxuICAgICAgICAgIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydDtcblxuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykgfHxcbiAgICAgICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmXG4gICAgICAgICAgICAoQ3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmICEoQ3RvciBpbnN0YW5jZW9mIEN0b3IpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSUUgPCA5IGl0ZXJhdGVzIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBvd24gcHJvcGVydGllcy4gSWYgdGhlIGZpcnN0XG4gICAgICAvLyBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QncyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkXG4gICAgICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBiYXNlRm9ySW4odmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICAgICAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHNMZW5ndGggJiYgb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgICBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQ7XG5cbiAgICAgIHZhciBhbGxvd0luZGV4ZXMgPSBsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKChhbGxvd0luZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpIHx8IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGlmIGl0IGlzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgcmV0dXJuIHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlclxuICAgICAgICA/IHdyYXBwZXIuY2xvbmUoKVxuICAgICAgICA6IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fLCBhcnJheUNvcHkod3JhcHBlci5fX2FjdGlvbnNfXykpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGNvbGxlY3Rpb25gIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBjb250YWluaW5nIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KCtzaXplIHx8IDEsIDEpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShjZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCBmYWxzZSwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDhdLCAnKicsIDEsIDIpO1xuICAgICAqIC8vID0+IFs0LCAnKicsIDhdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci51c2VyID09ICdiYXJuZXknO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIGZpbmRJbmRleCA9IGNyZWF0ZUZpbmRJbmRleCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci51c2VyID09ICdwZWJibGVzJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RJbmRleCA9IGNyZWF0ZUZpbmRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCB0aGUgYXJyYXkgaXMgcmVjdXJzaXZlbHlcbiAgICAgKiBmbGF0dGVuZWQsIG90aGVyd2lzZSBpdCBpcyBvbmx5IGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGlzRGVlcGBcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCAzLCBbNF1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNEZWVwLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNEZWVwLCBndWFyZCkpIHtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBhIG5lc3RlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZWN1cnNpdmVseSBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIDMsIFs0XV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSxcbiAgICAgKiBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgcGVyZm9ybXMgYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogZnJvbUluZGV4O1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlKSxcbiAgICAgICAgICAgIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgcmV0dXJuIGRyb3BSaWdodChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmcgYFNhbWVWYWx1ZVplcm9gXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IFtdLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCgoaXNDb21tb24gJiYgdmFsdWUubGVuZ3RoID49IDEyMCkgPyBjcmVhdGVDYWNoZShhcmdzSW5kZXggJiYgdmFsdWUpIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IG5hdGl2ZU1pbihmcm9tSW5kZXggfHwgMCwgbGVuZ3RoIC0gMSkpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgaW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHlcbiAgICAgKiBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZXM6KipcbiAgICAgKiAgLSBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YFxuICAgICAqICAtIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqICAgIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0XG4gICAgICogICAgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcnJheSA9IGFyZ3NbMF07XG5cbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhlcyBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBpbmRleGVzIG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbNSwgMTAsIDE1LCAyMF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFs1LCAxNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMTAsIDIwXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIGFycmF5IHx8IChhcnJheSA9IFtdKTtcbiAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGluZGV4ZXMuc29ydChiYXNlQ29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VGbG9hdChpbmRleGVzW2xlbmd0aF0pO1xuICAgICAgICBpZiAoaW5kZXggIT0gcHJldmlvdXMgJiYgaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGVcbiAgICAgKiBsaXN0cyBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGRcbiAgICAgKiBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuIElmIGFuIGl0ZXJhdGVlXG4gICAgICogZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWBcbiAgICAgKiB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbNCwgNCwgNSwgNV0sIDUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0geyAnZGF0YSc6IHsgJ3RoaXJ0eSc6IDMwLCAnZm9ydHknOiA0MCwgJ2ZpZnR5JzogNTAgfSB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYW4gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndGhpcnR5JywgJ2ZpZnR5J10sICdmb3J0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmRhdGFbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgdmFyIHNvcnRlZEluZGV4ID0gY3JlYXRlU29ydGVkSW5kZXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgdmFyIHNvcnRlZExhc3RJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZX0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgNF1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXkgdXNpbmcgYFNhbWVWYWx1ZVplcm9gXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBQcm92aWRpbmcgYHRydWVgIGZvciBgaXNTb3J0ZWRgIHBlcmZvcm1zIGEgZmFzdGVyXG4gICAgICogc2VhcmNoIGFsZ29yaXRobSBmb3Igc29ydGVkIGFycmF5cy4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXRcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZF0gU3BlY2lmeSB0aGUgYXJyYXkgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBpc1NvcnRlZGBcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDJdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDEuNSwgMl0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjVdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkICE9IG51bGwgJiYgdHlwZW9mIGlzU29ydGVkICE9ICdib29sZWFuJykge1xuICAgICAgICB0aGlzQXJnID0gaXRlcmF0ZWU7XG4gICAgICAgIGl0ZXJhdGVlID0gaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzU29ydGVkLCB0aGlzQXJnKSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soKTtcbiAgICAgIGlmICghKGZ1bmMgPT09IGJhc2VDYWxsYmFjayAmJiBpdGVyYXRlZSA9PSBudWxsKSkge1xuICAgICAgICBpdGVyYXRlZSA9IGZ1bmMoaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpc1NvcnRlZCAmJiBnZXRJbmRleE9mKCkgPT0gYmFzZUluZGV4T2YpXG4gICAgICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLWBfLnppcGBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgYXJyYXlNYXgoYXJyYXlNYXAoYXJyYXksIGdldExlbmd0aCkpKSA+Pj4gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIGBTYW1lVmFsdWVaZXJvYCBmb3JcbiAgICAgKiBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMSwgMl0sIFs0LCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCA/IGJhc2VVbmlxKHJlc3VsdCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmQgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSByZXN0UGFyYW0odW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8ucGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5c1xuICAgICAqIG9mIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuIFByb3ZpZGUgZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSxcbiAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAgb3IgdHdvIGFycmF5cywgb25lIG9mIHByb3BlcnR5IG5hbWVzXG4gICAgICogYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDQwXV0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMgPyBwcm9wcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAobGVuZ3RoICYmICF2YWx1ZXMgJiYgIWlzQXJyYXkocHJvcHNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluaW5nIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICAgIHJldHVybiBjaHIudXNlciArICcgaXMgJyArIGNoci5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3IgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mXG4gICAgICogdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9uc1xuICAgICAqIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyh1c2VycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyh1c2VycykuY2hhaW4oKVxuICAgICAqICAgLmZpcnN0KClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbmVkIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlciA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVyID0gd3JhcHBlci5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVyLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluZWQgc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVyID0gXyhhcnJheSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5wb3codmFsdWUsIDIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0gWzMsIDRdO1xuICAgICAqIHZhciBvdGhlcldyYXBwZXIgPSB3cmFwcGVyLnBsYW50KG90aGVyKTtcbiAgICAgKlxuICAgICAqIG90aGVyV3JhcHBlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgd3JhcHBlZCBhcnJheSBzbyB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUucmV2ZXJzZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXZlcnNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgcmVzdWx0IG9mIGNvZXJjaW5nIHRoZSB1bndyYXBwZWQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29lcmNlZCBzdHJpbmcgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUoKSArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSB0byBleHRyYWN0IHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHJ1biwgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXlzLCBvciBpbmRleGVzLFxuICAgICAqIG9mIGBjb2xsZWN0aW9uYC4gS2V5cyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGtleXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtwcm9wc10gVGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljaywgc3BlY2lmaWVkIGluZGl2aWR1YWxseSBvciBpbiBhcnJheXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnXSwgWzAsIDJdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICB2YXIgYXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgaWYgKGlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUF0KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/ICsrcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzQXJnICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbNCwgNSwgNl0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFs0LCA2XVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoYmFzZUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGJhc2VFYWNoUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIGFuZCB0aGVcbiAgICAgKiBzb3VyY2Ugb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBoYXMgZXF1aXZhbGVudCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbmQoY29sbGVjdGlvbiwgYmFzZU1hdGNoZXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHlcbiAgICAgKiBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4pO1xuICAgICAqIH0pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlIGZyb20gbGVmdCB0byByaWdodCBhbmQgcmV0dXJucyB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2cobiwga2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMl0pLmZvckVhY2hSaWdodChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICovXG4gICAgdmFyIGZvckVhY2hSaWdodCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoUmlnaHQsIGJhc2VFYWNoUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gIHVzaW5nIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHlcbiAgICAgKiBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldCBmcm9tXG4gICAgICogdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29udGFpbnMsIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwodGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSkpIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBjb2xsZWN0aW9uID09ICdzdHJpbmcnIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICA/IChmcm9tSW5kZXggPCBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6IChnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5RGF0YSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZnJvbUNoYXJDb2RlKG9iamVjdC5jb2RlKTtcbiAgICAgKiB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLFxuICAgICAqIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbFxuICAgICAqIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCBpcyBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBpc0xlbmd0aChsZW5ndGgpID8gQXJyYXkobGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZE5hbWUgOiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVttZXRob2ROYW1lXSk7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGZ1bmMgPyBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpbnRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2FsbGJhY2tgLCBgY2h1bmtgLCBgY2xvbmVgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsXG4gICAgICogYGRyb3BSaWdodGAsIGBldmVyeWAsIGBmaWxsYCwgYGZsYXR0ZW5gLCBgaW52ZXJ0YCwgYG1heGAsIGBtaW5gLCBgcGFyc2VJbnRgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0QnlgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltTGVmdGAsXG4gICAgICogYHRyaW1SaWdodGAsIGB0cnVuY2AsIGByYW5kb21gLCBgcmFuZ2VgLCBgc2FtcGxlYCwgYHNvbWVgLCBgdW5pcWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqICBjcmVhdGUgYSBgXy5wcm9wZXJ0eWAgb3IgYF8ubWF0Y2hlc2Agc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdGltZXNUaHJlZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDJdLCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiAxLCAnYic6IDIgfSwgdGltZXNUaHJlZSk7XG4gICAgICogLy8gPT4gWzMsIDZdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgd2hpbGUgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDI7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gW1sxLCAzXSwgWzJdXVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEuMiwgMi4zLCAzLjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKSAlIDI7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gW1sxLjIsIDMuNF0sIFsyLjNdXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIG1hcHBlciA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICByZXR1cm4gXy5wbHVjayhhcnJheSwgJ3VzZXInKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBga2V5YCBmcm9tIGFsbCBlbGVtZW50cyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIHZhciB1c2VySW5kZXggPSBfLmluZGV4QnkodXNlcnMsICd1c2VyJyk7XG4gICAgICogXy5wbHVjayh1c2VySW5kZXgsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiBbMzYsIDQwXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIGtleSkge1xuICAgICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBiYXNlUHJvcGVydHkoa2V5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGludGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYHNvcnRCeUFsbGAsIGFuZCBgc29ydEJ5T3JkZXJgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciByZWR1Y2UgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VSaWdodCA9ICBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2VSaWdodCwgYmFzZUVhY2hSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25dIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA+IDAgPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNodWZmbGUoY29sbGVjdGlvbik7XG4gICAgICByZXN1bHQubGVuZ3RoID0gbmF0aXZlTWluKG4gPCAwID8gMCA6ICgrbiB8fCAwKSwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gcmFuZCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3JhbmRdID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzTGVuZ3RoKGxlbmd0aCkgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcbiAgICAgKiBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhpcyBtZXRob2QgcGVyZm9ybXNcbiAgICAgKiBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2YgZXF1YWwgZWxlbWVudHMuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb25cbiAgICAgKiAgaW52b2tlZCBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3IgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzXG4gICAgICogIHVzZWQgdG8gY3JlYXRlIGEgYF8ucHJvcGVydHlgIG9yIGBfLm1hdGNoZXNgIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguc2luKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5zaW4obik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5zb3J0QnkodXNlcnMsICd1c2VyJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gaXNMZW5ndGgobGVuZ3RoKSA/IEFycmF5KGxlbmd0aCkgOiBbXTtcblxuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSB7ICdjcml0ZXJpYSc6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCAnaW5kZXgnOiBpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBjb21wYXJlQXNjZW5kaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgc29ydHMgYnkgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBzb3J0IGJ5LFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eSBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDI2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5QWxsKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5QWxsKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgY29sbGVjdGlvbiA9IGFyZ3NbMF0sXG4gICAgICAgICAgZ3VhcmQgPSBhcmdzWzNdLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBwcm9wc1tpbmRleF0gPSBhcmdzWysraW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFyZ3NbMV0sIGFyZ3NbMl0sIGd1YXJkKSkge1xuICAgICAgICBwcm9wcyA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKHByb3BzKSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBzb3J0IG9yZGVycyBvZiB0aGUgcHJvcGVydHkgbmFtZXMgdG8gc29ydCBieS4gQSB0cnV0aHkgdmFsdWUgaW4gYG9yZGVyc2BcbiAgICAgKiB3aWxsIHNvcnQgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZSBpbiBhc2NlbmRpbmcgb3JkZXIgd2hpbGUgYVxuICAgICAqIGZhbHNleSB2YWx1ZSB3aWxsIHNvcnQgaXQgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgcHJvcHNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBzb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBfLm1hcChfLnNvcnRCeU9yZGVyKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFt0cnVlLCBmYWxzZV0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgcHJvcHMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3BzLCBvcmRlcnMsIGd1YXJkKSkge1xuICAgICAgICBvcmRlcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHByb3BzKSkge1xuICAgICAgICBwcm9wcyA9IHByb3BzID09IG51bGwgPyBbXSA6IFtwcm9wc107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIHByb3BzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhfLndoZXJlKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAncGV0cyc6IFsnZGlubyddIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2hlcmUoY29sbGVjdGlvbiwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gbG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgZnVuY3Rpb24gdG8gYmUgaW52b2tlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBuYXRpdmVOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQgaXMgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBuO1xuICAgICAgICAgIG4gPSBmdW5jO1xuICAgICAgICAgIGZ1bmMgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbiA9IG5hdGl2ZUlzRmluaXRlKG4gPSArbikgPyBuIDogMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gYG5gIGFyZ3VtZW50cyBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgbiwgZ3VhcmQpKSB7XG4gICAgICAgIG4gPSBudWxsO1xuICAgICAgfVxuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIEFSWV9GTEFHLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCBpcyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KCcjYWRkJykub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IGFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IG47XG4gICAgICAgICAgbiA9IGZ1bmM7XG4gICAgICAgICAgZnVuYyA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgXy5iaW5kYCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAgdGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBgbGVuZ3RoYFxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgYml0bWFzayB8PSBQQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIGVudW1lcmFibGUgZnVuY3Rpb25cbiAgICAgKiBwcm9wZXJ0aWVzLCBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgYXJlIGJvdW5kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIHRoZSBlbGVtZW50IGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBtZXRob2ROYW1lcyA9IG1ldGhvZE5hbWVzLmxlbmd0aCA/IGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzKSA6IGZ1bmN0aW9ucyhvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIGFuZCBwcmVwZW5kc1xuICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogY2FsbGVkIGVpdGhlciBpbnZva2VzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgY3VycnkgPSBjcmVhdGVDdXJyeShDVVJSWV9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIGN1cnJ5UmlnaHQgPSBjcmVhdGVDdXJyeShDVVJSWV9SSUdIVF9GTEFHKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kc1xuICAgICAqIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBjb21lc1xuICAgICAqIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9uc1xuICAgICAqIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3JcbiAgICAgKiB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgZGVib3VuY2VkXG4gICAgICogZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlXG4gICAgICogIGRlbGF5ZWQgYmVmb3JlIGl0IGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBpbnZva2UgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gICAgICogICAnbWF4V2FpdCc6IDEwMDBcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBjYW5jZWwgYSBkZWJvdW5jZWQgY2FsbFxuICAgICAqIHZhciB0b2RvQ2hhbmdlcyA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDEwMDApO1xuICAgICAqIE9iamVjdC5vYnNlcnZlKG1vZGVscy50b2RvLCB0b2RvQ2hhbmdlcyk7XG4gICAgICpcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMsIGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgKiAgIGlmIChfLmZpbmQoY2hhbmdlcywgeyAndXNlcic6ICd0b2RvJywgJ3R5cGUnOiAnZGVsZXRlJ30pKSB7XG4gICAgICogICAgIHRvZG9DaGFuZ2VzLmNhbmNlbCgpO1xuICAgICAqICAgfVxuICAgICAqIH0sIFsnZGVsZXRlJ10pO1xuICAgICAqXG4gICAgICogLy8gLi4uYXQgc29tZSBwb2ludCBgbW9kZWxzLnRvZG9gIGlzIGNoYW5nZWRcbiAgICAgKiBtb2RlbHMudG9kby5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAqXG4gICAgICogLy8gLi4uYmVmb3JlIDEgc2Vjb25kIGhhcyBwYXNzZWQgYG1vZGVscy50b2RvYCBpcyBkZWxldGVkXG4gICAgICogLy8gd2hpY2ggY2FuY2VscyB0aGUgZGVib3VuY2VkIGB0b2RvQ2hhbmdlc2AgY2FsbFxuICAgICAqIGRlbGV0ZSBtb2RlbHMudG9kbztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gd2FpdCA8IDAgPyAwIDogKCt3YWl0IHx8IDApO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgbmF0aXZlTWF4KCtvcHRpb25zLm1heFdhaXQgfHwgMCwgd2FpdCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1heERlbGF5ZWQoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IG1heFdhaXQ7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIHZhciBkZWZlciA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogZnVuY3Rpb25zIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNzXSBGdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coXy5hZGQsIHNxdWFyZSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGJhY2tmbG93LCBjb21wb3NlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNzXSBGdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChzcXVhcmUsIF8uYWRkKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgY29lcmNlZCB0byBhIHN0cmluZyBhbmQgdXNlZCBhcyB0aGVcbiAgICAgKiBjYWNoZSBrZXkuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZSBbYE1hcGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1cHBlckNhc2UgPSBfLm1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdXBwZXJDYXNlLmNhY2hlLnNldCgnZnJlZCcsICdCQVJORVknKTtcbiAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnQkFSTkVZJ1xuICAgICAqXG4gICAgICogLy8gcmVwbGFjaW5nIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2Jhcm5leScgfTtcbiAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG4gICAgICpcbiAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIGlkZW50aXR5KG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgbWVtb2l6ZS5DYWNoZTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBpbnZva2VzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZShmdW5jLCAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHRcbiAgICAgKiBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgMiwgMCwgMSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcbiAgICAgKiBtYXAoZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0sIFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIFJFQVJHX0ZMQUcsIG51bGwsIG51bGwsIG51bGwsIGJhc2VGbGF0dGVuKGluZGV4ZXMpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGUgW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0UGFyYW0oZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyA/IChmdW5jLmxlbmd0aCAtIDEpIDogKCtzdGFydCB8fCAwKSwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZSBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjMpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvU3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSBQcm9taXNlXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcnJheSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMuIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAgICAgKiBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIHRyYWlsaW5nIHRocm90dGxlZCBjYWxsXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSArd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgbnVsbCwgW3ZhbHVlXSwgW10pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAgICAgKiBvdGhlcndpc2UgdGhleSBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUodXNlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZSh1c2VycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChpc0RlZXAgJiYgdHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcikpIHtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaXNEZWVwID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGN1c3RvbWl6ZXI7XG4gICAgICAgIGN1c3RvbWl6ZXIgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmdcbiAgICAgKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAodXNlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcChkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGlzT2JqZWN0TGlrZSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLmluZGV4T2YoJ0VsZW1lbnQnKSA+IC0xKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgZm9yIGVudmlyb25tZW50cyB3aXRob3V0IERPTSBzdXBwb3J0LlxuICAgIGlmICghc3VwcG9ydC5kb20pIHtcbiAgICAgIGlzRWxlbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGVtcHR5IHVubGVzcyBpdCBpcyBhblxuICAgICAqIGBhcmd1bWVudHNgIG9iamVjdCwgYXJyYXksIHN0cmluZywgb3IgalF1ZXJ5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGEgbGVuZ3RoXG4gICAgICogZ3JlYXRlciB0aGFuIGAwYCBvciBhbiBvYmplY3Qgd2l0aCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAoaXNMZW5ndGgobGVuZ3RoKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFrZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2RcbiAgICAgKiBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIG90aGVyIFssIGluZGV4fGtleV0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgKiBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZCBzdXBwb3J0XG4gICAgICogZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChhcnJheSwgb3RoZXIsIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAqICAgaWYgKF8uZXZlcnkoW3ZhbHVlLCBvdGhlcl0sIFJlZ0V4cC5wcm90b3R5cGUudGVzdCwgL15oKD86aXxlbGxvKSQvKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nICYmIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICghY3VzdG9taXplciAmJiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZXJyb3JUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIuaXNmaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgxMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShPYmplY3QoMTApKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNGaW5pdGUgPSBuYXRpdmVOdW1Jc0Zpbml0ZSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNGdW5jdGlvbiA9ICEoYmFzZUlzRnVuY3Rpb24oL3gvKSB8fCAoVWludDhBcnJheSAmJiAhYmFzZUlzRnVuY3Rpb24oVWludDhBcnJheSkpKSA/IGJhc2VJc0Z1bmN0aW9uIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgICAgIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvIGRldGVybWluZSBpZlxuICAgICAqIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWRcbiAgICAgKiBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciwgaW5kZXh8a2V5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgcHJvcGVydGllcyBvZiBhcnJheXMsIGJvb2xlYW5zLFxuICAgICAqIGBEYXRlYCBvYmplY3RzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZFxuICAgICAqIHN1cHBvcnQgZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgc291cmNlLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykgfHwgdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMyk7XG4gICAgICBpZiAoIWN1c3RvbWl6ZXIgJiYgbGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb2JqZWN0W2tleV0gJiYgKHR5cGVvZiB2YWx1ZSAhPSAndW5kZWZpbmVkJyB8fCAoa2V5IGluIHRvT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc3RyaWN0Q29tcGFyZUZsYWdzID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2xlbmd0aF0gPSBzb3VyY2VbcHJvcHNbbGVuZ3RoXV07XG4gICAgICAgIHN0cmljdENvbXBhcmVGbGFnc1tsZW5ndGhdID0gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaCh0b09iamVjdChvYmplY3QpLCBwcm9wcywgdmFsdWVzLCBzdHJpY3RDb21wYXJlRmxhZ3MsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIG5vdCB0aGUgc2FtZSBhcyBbYGlzTmFOYF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQpXG4gICAgICogd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZykge1xuICAgICAgICByZXR1cm4gcmVOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlIGNsYXNzaWZpZWRcbiAgICAgKiBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignOC40Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYXNzdW1lcyBvYmplY3RzIGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yXG4gICAgICogaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoISh2YWx1ZSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZixcbiAgICAgICAgICBvYmpQcm90byA9IGlzTmF0aXZlKHZhbHVlT2YpICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBUYWcpIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpO1xuICAgICAqIH0oMSwgMiwgMykpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZSA/IHZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvcHkodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICAgICAqIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnID8gb3RoZXIgOiB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoYmFzZUFzc2lnbik7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBiYXNlQ29weShwcm9wZXJ0aWVzLCByZXN1bHQsIGtleXMocHJvcGVydGllcykpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgdmFyIG9iamVjdCA9IGFyZ3NbMF07XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChhc3NpZ25EZWZhdWx0cyk7XG4gICAgICByZXR1cm4gYXNzaWduLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmRLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEtleSA9IGNyZWF0ZUZpbmRLZXkoYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZ1xuICAgICAqIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0b3IgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnLCAnYicsIGFuZCAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9ySW4gPSBjcmVhdGVGb3JJbihiYXNlRm9yKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdjJywgJ2InLCBhbmQgJ2EnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAnYScsICdiJywgYW5kICdjJ1xuICAgICAqL1xuICAgIHZhciBmb3JJblJpZ2h0ID0gY3JlYXRlRm9ySW4oYmFzZUZvclJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmcgYGl0ZXJhdGVlYFxuICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdG9yIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYScgYW5kICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBjcmVhdGVGb3JPd24oYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdiJyBhbmQgJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgYW5kICdiJ1xuICAgICAqL1xuICAgIHZhciBmb3JPd25SaWdodCA9IGNyZWF0ZUZvck93bihiYXNlRm9yT3duUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWZ0ZXInLCAnYXJ5JywgJ2Fzc2lnbicsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGtleWAgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgIGluc3RlYWQgb2YgYW5cbiAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGUgcHJvcGVydHlcbiAgICAgKiBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMgdW5sZXNzIGBtdWx0aVZhbHVlYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aVZhbHVlXSBBbGxvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIGtleS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG4gICAgICogXy5pbnZlcnQob2JqZWN0LCB0cnVlKTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChvYmplY3QsIG11bHRpVmFsdWUsIGd1YXJkKSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKG11bHRpVmFsdWUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkpKSkge1xuICAgICAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgKHN1cHBvcnQubm9uRW51bUFyZ3MgJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpICYmIGxlbmd0aCkgfHwgMDtcblxuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGBjdXN0b21pemVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kXG4gICAgICogc291cmNlIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgaXMgaGFuZGxlZFxuICAgICAqIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ3VzZXInOiAnZnJlZCcgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnZGF0YSc6IFt7ICdhZ2UnOiAzNiB9LCB7ICdhZ2UnOiA0MCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KGEpKSB7XG4gICAgICogICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3QnXSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoYmFzZU1lcmdlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGBwcmVkaWNhdGVgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiBvZiBgb2JqZWN0YCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZVxuICAgICAqIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIG9taXQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbMF0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChiYXNlRmxhdHRlbihwcm9wcyksIFN0cmluZyk7XG4gICAgICAgIHJldHVybiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VEaWZmZXJlbmNlKGtleXNJbihvYmplY3QpLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgdmFyIHByZWRpY2F0ZSA9IGJpbmRDYWxsYmFjayhwcm9wc1swXSwgcHJvcHNbMV0sIDMpO1xuICAgICAgcmV0dXJuIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAsXG4gICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuIFByb3BlcnR5XG4gICAgICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuICAgICAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgXy5pc1N0cmluZyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgcHJvcHNbMF0gPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgYmluZENhbGxiYWNrKHByb3BzWzBdLCBwcm9wc1sxXSwgMykpXG4gICAgICAgIDogcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRmxhdHRlbihwcm9wcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGBrZXlgIG9uIGBvYmplY3RgLiBJZiB0aGUgdmFsdWUgb2YgYGtleWAgaXNcbiAgICAgKiBhIGZ1bmN0aW9uIGl0IGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHRcbiAgICAgKiBpcyByZXR1cm5lZCwgZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyB1c2VkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqICByZXNvbHZlcyB0byBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogXy5jb25zdGFudCg0MCkgfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FnZScpO1xuICAgICAqIC8vID0+IDQwXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdGF0dXMnLCAnYnVzeScpO1xuICAgICAqIC8vID0+ICdidXN5J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3RhdHVzJywgXy5jb25zdGFudCgnYnVzeScpKTtcbiAgICAgKiAvLyA9PiAnYnVzeSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93biBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyB0aHJvdWdoIGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uIHBvdGVudGlhbGx5IG11dGF0aW5nXG4gICAgICogdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdG9yIGZ1bmN0aW9uc1xuICAgICAqIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpO1xuXG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUoaXNGdW5jdGlvbihDdG9yKSAmJiBDdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXMgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID49IHN0YXJ0ICYmIHZhbHVlIDwgZW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcbiAgICAgKiBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciBpcyByZXR1cm5lZC5cbiAgICAgKiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBtaW5gIG9yIGBtYXhgIGFyZSBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnRcbiAgICAgKiBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiBpc0l0ZXJhdGVlQ2FsbChtaW4sIG1heCwgZmxvYXRpbmcpKSB7XG4gICAgICAgIG1heCA9IGZsb2F0aW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChub01heCAmJiB0eXBlb2YgbWluID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1heDtcbiAgICAgICAgICBub01heCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub01pbiAmJiBub01heCkge1xuICAgICAgICBtYXggPSAxO1xuICAgICAgICBub01heCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbWluID0gK21pbiB8fCAwO1xuICAgICAgaWYgKG5vTWF4KSB7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heCA9ICttYXggfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBtaW4gJSAxIHx8IG1heCAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYXBpdGFsaXplcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIChzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZyBbbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrcywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSAodGFyZ2V0ICsgJycpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gdHlwZW9mIHBvc2l0aW9uID09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBsZW5ndGgpO1xuXG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLmluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgXCInXCIsIGFuZCBcIlxcYFwiLCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgICogdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gICAgICogb2YgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLFxuICAgICAqIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZlxuICAgICAqIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5cyBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpXG4gICAgICogdG8gcmVkdWNlIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAvLyBSZXNldCBgbGFzdEluZGV4YCBiZWNhdXNlIGluIElFIDwgOSBgU3RyaW5nI3JlcGxhY2VgIGRvZXMgbm90LlxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiL1wiLCBcIl5cIiwgXCIkXCIsIFwiLlwiLCBcInxcIiwgXCI/XCIsXG4gICAgICogXCIqXCIsIFwiK1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIgYW5kIFwifVwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOlxcL1xcL2xvZGFzaFxcLmNvbVxcL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhcnMudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhcnMsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQgaXMgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDIsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IGZsb29yKG1pZCksXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBjZWlsKG1pZCk7XG5cbiAgICAgIGNoYXJzID0gY3JlYXRlUGFkZGluZygnJywgcmlnaHRMZW5ndGgsIGNoYXJzKTtcbiAgICAgIHJldHVybiBjaGFycy5zbGljZSgwLCBsZWZ0TGVuZ3RoKSArIHN0cmluZyArIGNoYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCBpcyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRMZWZ0ID0gY3JlYXRlUGFkRGlyKCk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0IGlzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgdmFyIHBhZFJpZ2h0ID0gY3JlYXRlUGFkRGlyKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsXG4gICAgICogaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZSBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI0UpXG4gICAgICogb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoc3RyaW5nLCByYWRpeCk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGZvciBlbnZpcm9ubWVudHMgd2l0aCBwcmUtRVM1IGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAobmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZSArICcwOCcpICE9IDgpIHtcbiAgICAgIHBhcnNlSW50ID0gZnVuY3Rpb24oc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyBFUzMgZm9yIGBwYXJzZUludGAuXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byB0cmltIGxlYWRpbmcgPEJPTT4gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIDogcmFkaXggPT0gbnVsbCkge1xuICAgICAgICAgIHJhZGl4ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgICB9XG4gICAgICAgIHN0cmluZyA9IHRyaW0oc3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0cmluZywgcmFkaXggfHwgKHJlSGV4UHJlZml4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgbiA9ICtuO1xuICAgICAgaWYgKG4gPCAxIHx8ICFzdHJpbmcgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gZmxvb3IobiAvIDIpO1xuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IG5hdGl2ZU1pbihwb3NpdGlvbiA8IDAgPyAwIDogKCtwb3NpdGlvbiB8fCAwKSwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbb3RoZXJPcHRpb25zXSBFbmFibGVzIHRoZSBsZWdhY3kgYG9wdGlvbnNgIHBhcmFtIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb24gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IG90aGVyT3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBiYXNlQXNzaWduKGJhc2VBc3NpZ24oe30sIG90aGVyT3B0aW9ucyB8fCBvcHRpb25zKSwgc2V0dGluZ3MsIGFzc2lnbk93bkRlZmF1bHRzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBiYXNlQXNzaWduKGJhc2VBc3NpZ24oe30sIG9wdGlvbnMuaW1wb3J0cyksIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbk93bkRlZmF1bHRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG4gICAgICAgICAgPyBvcHRpb25zLnNvdXJjZVVSTFxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZyksIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzID0gKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIGNoYXJzKSwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbUxlZnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUxlZnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltUmlnaHQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJpZ2h0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQgaXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdCBvciBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywgMjQpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG4uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuYyhzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/ICgrb3B0aW9ucy5sZW5ndGggfHwgMCkgOiBsZW5ndGg7XG4gICAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSArb3B0aW9ucyB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChsZW5ndGggPj0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIG9taXNzaW9uLmxlbmd0aDtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIG5ld0VuZCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCAocmVGbGFncy5leGVjKHNlcGFyYXRvcikgfHwgJycpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PSBudWxsID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IsIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYCYjMzk7YCwgYW5kIGAmIzk2O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsIEhUTUxcbiAgICAgKiBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSkge1xuICAgICAgICBwYXR0ZXJuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuIHx8IHJlV29yZHMpIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSB0aGVcbiAgICAgKiBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYFxuICAgICAqIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluXG4gICAgICogdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaXRlcmF0ZWVcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jYWxsYmFjayA9IF8ud3JhcChfLmNhbGxiYWNrLCBmdW5jdGlvbihjYWxsYmFjaywgZnVuYywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGZ1bmMpO1xuICAgICAqICAgaWYgKCFtYXRjaCkge1xuICAgICAqICAgICByZXR1cm4gY2FsbGJhY2soZnVuYywgdGhpc0FyZyk7XG4gICAgICogICB9XG4gICAgICogICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnXG4gICAgICogICAgICAgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM11cbiAgICAgKiAgICAgICA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FnZV9fZ3QzNicpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSkge1xuICAgICAgICB0aGlzQXJnID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UoZnVuYylcbiAgICAgICAgPyBtYXRjaGVzKGZ1bmMpXG4gICAgICAgIDogYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqXG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBwZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICogYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5tYXRjaGVzKHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYGtleWAgb24gYSBnaXZlblxuICAgICAqIG9iamVjdCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcbiAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBfLm1hdGNoZXNQcm9wZXJ0eSgndXNlcicsICdmcmVkJykpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShrZXkgKyAnJywgYmFzZUNsb25lKHZhbHVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIHRoZW4gbWV0aG9kcyBhcmUgYWRkZWQgdG9cbiAgICAgKiBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb25cbiAgICAgKiBmb3IgbWl4aW5zIHRvIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9dGhpc10gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZFxuICAgICAqICBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGF2b2lkIGNvbmZsaWN0cyAoZXNwLiBpbiBOb2RlLmpzKVxuICAgICAqIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJykucnVuSW5Db250ZXh0KCk7XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiAmJiBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHByb3BzICYmIHByb3BzLmxlbmd0aCAmJiBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW3RoaXMudmFsdWUoKV07XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShmdW5jKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBjb250ZXh0Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBgdW5kZWZpbmVkYCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYGtleWAgb24gYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ3VzZXInKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKHVzZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy5zb3J0QnkodXNlcnMsIGdldE5hbWUpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGJhc2VQcm9wZXJ0eShrZXkgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYSBnaXZlbiBrZXkgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDMsICdiJzogMSwgJ2MnOiAyIH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2EnLCAnYyddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzMsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbJ2EnLCAnYicsICdjJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYycsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLiBJZiBgc3RhcnRgIGlzIGxlc3MgdGhhbiBgZW5kYFxuICAgICAqIGEgemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBpZiAoc3RlcCAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICBlbmQgPSBzdGVwID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6ICgrc3RlcCB8fCAwKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG4gICAgICB9XG4gICAgICAvLyBVc2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlcy5cbiAgICAgIC8vIFNlZSBodHRwczovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBpbnZvY2F0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkaWNlUm9sbHMgPSBfLnRpbWVzKDMsIF8ucGFydGlhbChfLnJhbmRvbSwgMSwgNiwgZmFsc2UpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikge1xuICAgICAqICAgbWFnZS5jYXN0U3BlbGwobik7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gaW52b2tlcyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzIHdpdGggYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7XG4gICAgICogICB0aGlzLmNhc3Qobik7XG4gICAgICogfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgbiA9ICtuO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IHRvIGF2b2lkIGEgSlNDIEpJVCBidWcgaW4gU2FmYXJpIDhcbiAgICAgIC8vIHdoZXJlIGBBcnJheSgwKWAgaXMgdHJlYXRlZCBhcyBgQXJyYXkoMSlgLlxuICAgICAgaWYgKG4gPCAxIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCkpO1xuXG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaWYgKGluZGV4IDwgTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBiYXNlVG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciB0byBhZGQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGVtcHR5IG9yIGZhbHNleVxuICAgICAqIGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IC1JbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgodXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqL1xuICAgIHZhciBtYXggPSBjcmVhdGVFeHRyZW11bShhcnJheU1heCk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGVtcHR5IG9yIGZhbHNleVxuICAgICAqIGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4odXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIG1pbiA9IGNyZWF0ZUV4dHJlbXVtKGFycmF5TWluLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCA2XSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIF8uc3VtKHsgJ2EnOiA0LCAnYic6IDYgfSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnbic6IDQgfSxcbiAgICAgKiAgIHsgJ24nOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zdW0ob2JqZWN0cywgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICByZXR1cm4gb2JqZWN0Lm47XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zdW0ob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soKSxcbiAgICAgICAgICBub0l0ZXJhdGVlID0gaXRlcmF0ZWUgPT0gbnVsbDtcblxuICAgICAgaWYgKCEoZnVuYyA9PT0gYmFzZUNhbGxiYWNrICYmIG5vSXRlcmF0ZWUpKSB7XG4gICAgICAgIG5vSXRlcmF0ZWUgPSBmYWxzZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBmdW5jKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub0l0ZXJhdGVlXG4gICAgICAgID8gYXJyYXlTdW0oaXNBcnJheShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pKVxuICAgICAgICA6IGJhc2VTdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYE1hcGAgY2FjaGUuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcERlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcFNldDtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBTZXRgIGNhY2hlLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXN0UGFyYW0gPSByZXN0UGFyYW07XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRCeUFsbCA9IHNvcnRCeUFsbDtcbiAgICBsb2Rhc2guc29ydEJ5T3JkZXIgPSBzb3J0QnlPcmRlcjtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guYmFja2Zsb3cgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmNvbGxlY3QgPSBtYXA7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBjYWxsYmFjaztcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kV2hlcmU7XG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRMZWZ0ID0gcGFkTGVmdDtcbiAgICBsb2Rhc2gucGFkUmlnaHQgPSBwYWRSaWdodDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG4gICAgbG9kYXNoLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbiAgICBsb2Rhc2gudHJ1bmMgPSB0cnVuYztcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoIXRoaXMuX19jaGFpbl9fICYmIG4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUodmFsdWUsIG4pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZHJvcFdoaWxlJywgJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHR5cGUpIHtcbiAgICAgIHZhciBpc0ZpbHRlciA9IHR5cGUgIT0gTEFaWV9NQVBfRkxBRyxcbiAgICAgICAgICBpc0Ryb3BXaGlsZSA9IHR5cGUgPT0gTEFaWV9EUk9QX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX19maWx0ZXJlZF9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gKGZpbHRlcmVkICYmIGlzRHJvcFdoaWxlKSA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXMuY2xvbmUoKSxcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IHJlc3VsdC5fX2l0ZXJhdGVlc19fIHx8IChyZXN1bHQuX19pdGVyYXRlZXNfXyA9IFtdKTtcblxuICAgICAgICBpdGVyYXRlZXMucHVzaCh7XG4gICAgICAgICAgJ2RvbmUnOiBmYWxzZSxcbiAgICAgICAgICAnY291bnQnOiAwLFxuICAgICAgICAgICdpbmRleCc6IDAsXG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLFxuICAgICAgICAgICdsaW1pdCc6IC0xLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gZmlsdGVyZWQgfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHdoaWxlTmFtZSA9IG1ldGhvZE5hbWUgKyAnV2hpbGUnO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX19maWx0ZXJlZF9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gKGZpbHRlcmVkICYmICFpbmRleCkgPyB0aGlzLmRyb3BXaGlsZSgpIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIG4gPSBuID09IG51bGwgPyAxIDogbmF0aXZlTWF4KGZsb29yKG4pIHx8IDAsIDApO1xuICAgICAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKHJlc3VsdC5fX3Rha2VDb3VudF9fLCBuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdChyZXN1bHQuX19pdGVyYXRlZXNfXykubGltaXQgPSBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmlld3MgPSByZXN1bHQuX192aWV3c19fIHx8IChyZXN1bHQuX192aWV3c19fID0gW10pO1xuICAgICAgICAgIHZpZXdzLnB1c2goeyAnc2l6ZSc6IG4sICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHRXaGlsZSddID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVt3aGlsZU5hbWVdKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmZpcnN0YCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnZmlyc3QnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy5yZXN0YC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3Jlc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8ucGx1Y2tgIGFuZCBgXy53aGVyZWAuXG4gICAgYXJyYXlFYWNoKFsncGx1Y2snLCAnd2hlcmUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gaW5kZXggPyAnZmlsdGVyJyA6ICdtYXAnLFxuICAgICAgICAgIGNyZWF0ZUNhbGxiYWNrID0gaW5kZXggPyBiYXNlTWF0Y2hlcyA6IGJhc2VQcm9wZXJ0eTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbb3BlcmF0aW9uTmFtZV0oY3JlYXRlQ2FsbGJhY2sodmFsdWUpKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RhcnQgPCAwID8gdGhpcy50YWtlUmlnaHQoLXN0YXJ0KSA6IHRoaXMuZHJvcChzdGFydCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZW5kICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuZCA9ICgrZW5kIHx8IDApO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcm9wKDApO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpmaXJzdHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIGBsZW5ndGhgIG90aGVyIHRoYW4gYDFgXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG9ubHlMYXp5XG4gICAgICAgICAgICA/IGZ1bmMuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgIDogbG9kYXNoRnVuYy5jYWxsKGxvZGFzaCwgdGhpcy52YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBvdGhlckFyZ3MgPSBbdmFsdWVdO1xuICAgICAgICAgIHB1c2guYXBwbHkob3RoZXJBcmdzLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIG90aGVyQXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VMYXp5KSB7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHdyYXBwZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgKGlzSHlicmlkIHx8IHJlc3VsdC5fX2FjdGlvbnNfXykpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fIHx8IChyZXN1bHQuX19hY3Rpb25zX18gPSBbXSk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiBsb2Rhc2ggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gKC9eKD86cmVwbGFjZXxzcGxpdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gc3RyaW5nUHJvdG8gOiBhcnJheVByb3RvKVttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLnZhbHVlKCksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBmdW5jdGlvbiBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUsXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcihudWxsLCBCSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7ICduYW1lJzogJ3dyYXBwZXInLCAnZnVuYyc6IG51bGwgfV07XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBsYXp5IHdyYXBwZXIuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluaW5nIGZ1bmN0aW9ucyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5ydW4gPSBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb24gYWxpYXNlcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbGxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLm1hcDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmhlYWQgPSBsb2Rhc2gucHJvdG90eXBlLmZpcnN0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuc2VsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5maWx0ZXI7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50YWlsID0gbG9kYXNoLnByb3RvdHlwZS5yZXN0O1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBsb2Rhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgdG8gYXZvaWRcbiAgICAvLyBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgbG9kYXNoIGlzIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgYW5kIG5vdCBpbnRlbmRlZFxuICAgIC8vIGFzIGFuIEFNRCBtb2R1bGUuIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvclxuICAgIC8vIG1vcmUgZGV0YWlscy5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcyBvciBSaW5nb0pTLlxuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIEV4cG9ydCBmb3IgTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZS5cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIGEgYnJvd3NlciBvciBSaGluby5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIl19
